From 1b7c0d2233456e8e8b67746bef60262a8354bc25 Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Fri, 4 Oct 2019 03:17:51 +0200
Subject: Revert c5dc41e980b311a9d49122c6e3e33a1c4483c660,
 a5d45e9ae5a6a88f859c1ca1f05b4c93a0817103,
 619bd16e7a7486ca72cde1df01791629efb61341 Conflicting with our proton meta
 patchset

Mainline edition

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 6cf7feb0d7..f522429b76 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -140,7 +140,7 @@
 @ stdcall AddAtomW(wstr)
 @ stdcall AddConsoleAliasA(str str str)
 @ stdcall AddConsoleAliasW(wstr wstr wstr)
-@ stdcall -import AddDllDirectory(wstr)
+@ stdcall AddDllDirectory(wstr)
 # @ stub AddIntegrityLabelToBoundaryDescriptor
 # @ stub AddLocalAlternateComputerNameA
 # @ stub AddLocalAlternateComputerNameW
@@ -528,7 +528,7 @@
 @ stdcall -import FreeEnvironmentStringsA(ptr)
 @ stdcall -import FreeEnvironmentStringsW(ptr)
 @ stub -i386 FreeLSCallback
-@ stdcall -import FreeLibrary(long)
+@ stdcall FreeLibrary(long)
 @ stdcall FreeLibraryAndExitThread(long long)
 @ stdcall FreeLibraryWhenCallbackReturns(ptr ptr) ntdll.TpCallbackUnloadDllOnCompletion
 @ stdcall -import FreeResource(long)
@@ -1042,10 +1042,10 @@
 @ stdcall LeaveCriticalSection(ptr) ntdll.RtlLeaveCriticalSection
 @ stdcall LeaveCriticalSectionWhenCallbackReturns(ptr ptr) ntdll.TpCallbackLeaveCriticalSectionOnCompletion
 # @ stub LoadAppInitDlls
-@ stdcall -import LoadLibraryA(str)
-@ stdcall -import LoadLibraryExA( str long long)
-@ stdcall -import LoadLibraryExW(wstr long long)
-@ stdcall -import LoadLibraryW(wstr)
+@ stdcall LoadLibraryA(str)
+@ stdcall LoadLibraryExA( str long long)
+@ stdcall LoadLibraryExW(wstr long long)
+@ stdcall LoadLibraryW(wstr)
 @ stdcall LoadModule(str ptr)
 @ stdcall -import LoadResource(long long)
 # @ stub LoadStringBaseExW
@@ -1274,7 +1274,7 @@
 @ stdcall ReplaceFileW(wstr wstr wstr long ptr ptr)
 # @ stub RemoveDirectoryTransactedA
 # @ stub RemoveDirectoryTransactedW
-@ stdcall -import RemoveDllDirectory(ptr)
+@ stdcall RemoveDllDirectory(ptr)
 # @ stub RemoveSecureMemoryCacheCallback
 # @ stub ReplacePartitionUnit
 @ stdcall RequestDeviceWakeup(long)
@@ -1379,7 +1379,7 @@
 @ stub SetDaylightFlag
 @ stdcall SetDefaultCommConfigA(str ptr long)
 @ stdcall SetDefaultCommConfigW(wstr ptr long)
-@ stdcall -import SetDefaultDllDirectories(long)
+@ stdcall SetDefaultDllDirectories(long)
 @ stdcall SetDllDirectoryA(str)
 @ stdcall SetDllDirectoryW(wstr)
 # @ stub SetDynamicTimeZoneInformation
diff --git a/dlls/kernel32/kernel_private.h b/dlls/kernel32/kernel_private.h
index af85bee84d..fdfb7a3e83 100644
--- a/dlls/kernel32/kernel_private.h
+++ b/dlls/kernel32/kernel_private.h
@@ -65,6 +65,9 @@ extern void FILE_SetDosError(void) DECLSPEC_HIDDEN;
 extern WCHAR *FILE_name_AtoW( LPCSTR name, BOOL alloc ) DECLSPEC_HIDDEN;
 extern DWORD FILE_name_WtoA( LPCWSTR src, INT srclen, LPSTR dest, INT destlen ) DECLSPEC_HIDDEN;
 
+/* module.c */
+extern WCHAR *MODULE_get_dll_load_path( LPCWSTR module, int safe_mode ) DECLSPEC_HIDDEN;
+
 extern BOOL NLS_IsUnicodeOnlyLcid(LCID) DECLSPEC_HIDDEN;
 
 /* environ.c */
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index b7f19ffe36..131c2f9621 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -47,6 +47,34 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
+#define NE_FFLAGS_LIBMODULE 0x8000
+
+struct dll_dir_entry
+{
+    struct list entry;
+    WCHAR       dir[1];
+};
+
+static struct list dll_dir_list = LIST_INIT( dll_dir_list );  /* extra dirs from AddDllDirectory */
+static DWORD default_search_flags;  /* default flags set by SetDefaultDllDirectories */
+
+/* to keep track of LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE file handles */
+struct exclusive_datafile
+{
+    struct list entry;
+    HMODULE     module;
+    HANDLE      file;
+};
+static struct list exclusive_datafile_list = LIST_INIT( exclusive_datafile_list );
+
+static CRITICAL_SECTION dlldir_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &dlldir_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": dlldir_section") }
+};
+static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 /****************************************************************************
  *              GetDllDirectoryA   (KERNEL32.@)
@@ -135,6 +163,73 @@ BOOL WINAPI SetDllDirectoryW( LPCWSTR dir )
 }
 
 
+/****************************************************************************
+ *              AddDllDirectory   (KERNEL32.@)
+ */
+DLL_DIRECTORY_COOKIE WINAPI AddDllDirectory( const WCHAR *dir )
+{
+    WCHAR path[MAX_PATH];
+    DWORD len;
+    struct dll_dir_entry *ptr;
+    DOS_PATHNAME_TYPE type = RtlDetermineDosPathNameType_U( dir );
+
+    if (type != ABSOLUTE_PATH && type != ABSOLUTE_DRIVE_PATH)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return NULL;
+    }
+    if (!(len = GetFullPathNameW( dir, MAX_PATH, path, NULL ))) return NULL;
+    if (GetFileAttributesW( path ) == INVALID_FILE_ATTRIBUTES) return NULL;
+
+    if (!(ptr = HeapAlloc( GetProcessHeap(), 0, offsetof(struct dll_dir_entry, dir[++len] )))) return NULL;
+    memcpy( ptr->dir, path, len * sizeof(WCHAR) );
+    TRACE( "%s\n", debugstr_w( ptr->dir ));
+
+    RtlEnterCriticalSection( &dlldir_section );
+    list_add_head( &dll_dir_list, &ptr->entry );
+    RtlLeaveCriticalSection( &dlldir_section );
+    return ptr;
+}
+
+
+/****************************************************************************
+ *              RemoveDllDirectory   (KERNEL32.@)
+ */
+BOOL WINAPI RemoveDllDirectory( DLL_DIRECTORY_COOKIE cookie )
+{
+    struct dll_dir_entry *ptr = cookie;
+
+    TRACE( "%s\n", debugstr_w( ptr->dir ));
+
+    RtlEnterCriticalSection( &dlldir_section );
+    list_remove( &ptr->entry );
+    HeapFree( GetProcessHeap(), 0, ptr );
+    RtlLeaveCriticalSection( &dlldir_section );
+    return TRUE;
+}
+
+
+/*************************************************************************
+ *           SetDefaultDllDirectories   (KERNEL32.@)
+ */
+BOOL WINAPI SetDefaultDllDirectories( DWORD flags )
+{
+    /* LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR doesn't make sense in default dirs */
+    const DWORD load_library_search_flags = (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
+                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
+                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
+                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
+
+    if (!flags || (flags & ~load_library_search_flags))
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
+    default_search_flags = flags;
+    return TRUE;
+}
+
+
 /***********************************************************************
  *             GetBinaryTypeW                     [KERNEL32.@]
  *
@@ -273,6 +368,564 @@ BOOL WINAPI GetBinaryTypeA( LPCSTR lpApplicationName, LPDWORD lpBinaryType )
     return GetBinaryTypeW(NtCurrentTeb()->StaticUnicodeString.Buffer, lpBinaryType);
 }
 
+/***********************************************************************
+ *           get_dll_system_path
+ */
+static const WCHAR *get_dll_system_path(void)
+{
+    static WCHAR *cached_path;
+
+    if (!cached_path)
+    {
+        WCHAR *p, *path;
+        int len = 1;
+
+        len += 2 * GetSystemDirectoryW( NULL, 0 );
+        len += GetWindowsDirectoryW( NULL, 0 );
+        p = path = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );
+        GetSystemDirectoryW( p, path + len - p);
+        p += strlenW(p);
+        /* if system directory ends in "32" add 16-bit version too */
+        if (p[-2] == '3' && p[-1] == '2')
+        {
+            *p++ = ';';
+            GetSystemDirectoryW( p, path + len - p);
+            p += strlenW(p) - 2;
+        }
+        *p++ = ';';
+        GetWindowsDirectoryW( p, path + len - p);
+        cached_path = path;
+    }
+    return cached_path;
+}
+
+/***********************************************************************
+ *           get_dll_safe_mode
+ */
+static BOOL get_dll_safe_mode(void)
+{
+    static const WCHAR keyW[] = {'\\','R','e','g','i','s','t','r','y','\\',
+                                 'M','a','c','h','i','n','e','\\',
+                                 'S','y','s','t','e','m','\\',
+                                 'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
+                                 'C','o','n','t','r','o','l','\\',
+                                 'S','e','s','s','i','o','n',' ','M','a','n','a','g','e','r',0};
+    static const WCHAR valueW[] = {'S','a','f','e','D','l','l','S','e','a','r','c','h','M','o','d','e',0};
+
+    static int safe_mode = -1;
+
+    if (safe_mode == -1)
+    {
+        char buffer[offsetof(KEY_VALUE_PARTIAL_INFORMATION, Data[sizeof(DWORD)])];
+        KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
+        OBJECT_ATTRIBUTES attr;
+        UNICODE_STRING nameW;
+        HANDLE hkey;
+        DWORD size = sizeof(buffer);
+
+        attr.Length = sizeof(attr);
+        attr.RootDirectory = 0;
+        attr.ObjectName = &nameW;
+        attr.Attributes = 0;
+        attr.SecurityDescriptor = NULL;
+        attr.SecurityQualityOfService = NULL;
+
+        safe_mode = 1;
+        RtlInitUnicodeString( &nameW, keyW );
+        if (!NtOpenKey( &hkey, KEY_READ, &attr ))
+        {
+            RtlInitUnicodeString( &nameW, valueW );
+            if (!NtQueryValueKey( hkey, &nameW, KeyValuePartialInformation, buffer, size, &size ) &&
+                info->Type == REG_DWORD && info->DataLength == sizeof(DWORD))
+                safe_mode = !!*(DWORD *)info->Data;
+            NtClose( hkey );
+        }
+        if (!safe_mode) TRACE( "SafeDllSearchMode disabled through the registry\n" );
+    }
+    return safe_mode;
+}
+
+/******************************************************************
+ *		get_module_path_end
+ *
+ * Returns the end of the directory component of the module path.
+ */
+static inline const WCHAR *get_module_path_end(const WCHAR *module)
+{
+    const WCHAR *p;
+    const WCHAR *mod_end = module;
+    if (!module) return mod_end;
+
+    if ((p = strrchrW( mod_end, '\\' ))) mod_end = p;
+    if ((p = strrchrW( mod_end, '/' ))) mod_end = p;
+    if (mod_end == module + 2 && module[1] == ':') mod_end++;
+    if (mod_end == module && module[0] && module[1] == ':') mod_end += 2;
+
+    return mod_end;
+}
+
+
+/******************************************************************
+ *		append_path_len
+ *
+ * Append a counted string to the load path. Helper for MODULE_get_dll_load_path.
+ */
+static inline WCHAR *append_path_len( WCHAR *p, const WCHAR *str, DWORD len )
+{
+    if (!len) return p;
+    memcpy( p, str, len * sizeof(WCHAR) );
+    p[len] = ';';
+    return p + len + 1;
+}
+
+
+/******************************************************************
+ *		append_path
+ *
+ * Append a string to the load path. Helper for MODULE_get_dll_load_path.
+ */
+static inline WCHAR *append_path( WCHAR *p, const WCHAR *str )
+{
+    return append_path_len( p, str, strlenW(str) );
+}
+
+
+/******************************************************************
+ *		MODULE_get_dll_load_path
+ *
+ * Compute the load path to use for a given dll.
+ * Returned pointer must be freed by caller.
+ */
+WCHAR *MODULE_get_dll_load_path( LPCWSTR module, int safe_mode )
+{
+    static const WCHAR pathW[] = {'P','A','T','H',0};
+    static const WCHAR dotW[] = {'.',0};
+
+    const WCHAR *system_path = get_dll_system_path();
+    const WCHAR *mod_end = NULL;
+    UNICODE_STRING name, value;
+    WCHAR *p, *ret;
+    int len = 0, path_len = 0, dlldir_len;
+
+    /* adjust length for module name */
+
+    if (module)
+        mod_end = get_module_path_end( module );
+    /* if module is NULL or doesn't contain a path, fall back to directory
+     * process was loaded from */
+    if (module == mod_end)
+    {
+        module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+        mod_end = get_module_path_end( module );
+    }
+    len += (mod_end - module) + 1;
+
+    len += strlenW( system_path ) + 2;
+
+    /* get the PATH variable */
+
+    RtlInitUnicodeString( &name, pathW );
+    value.Length = 0;
+    value.MaximumLength = 0;
+    value.Buffer = NULL;
+    if (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
+        path_len = value.Length;
+
+    dlldir_len = GetDllDirectoryW( 0, NULL );
+
+    if (safe_mode == -1) safe_mode = get_dll_safe_mode();
+    if (dlldir_len > 1) len += dlldir_len;
+    else len += 2;  /* current directory */
+    if ((p = ret = HeapAlloc( GetProcessHeap(), 0, path_len + len * sizeof(WCHAR) )))
+    {
+        if (module) p = append_path_len( p, module, mod_end - module );
+
+        if (dlldir_len > 1)
+        {
+            GetDllDirectoryW( len - (p - ret), p );
+            p += strlenW(p);
+            *p++ = ';';
+        }
+        else if (!safe_mode) p = append_path( p, dotW );
+
+        p = append_path( p, system_path );
+
+        if (dlldir_len <= 1 && safe_mode) p = append_path( p, dotW );
+    }
+    if (!ret) return NULL;
+
+    value.Buffer = p;
+    value.MaximumLength = path_len;
+
+    while (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
+    {
+        WCHAR *new_ptr;
+
+        /* grow the buffer and retry */
+        path_len = value.Length;
+        if (!(new_ptr = HeapReAlloc( GetProcessHeap(), 0, ret, path_len + len * sizeof(WCHAR) )))
+        {
+            HeapFree( GetProcessHeap(), 0, ret );
+            return NULL;
+        }
+        value.Buffer = new_ptr + (value.Buffer - ret);
+        value.MaximumLength = path_len;
+        ret = new_ptr;
+    }
+    value.Buffer[value.Length / sizeof(WCHAR)] = 0;
+    return ret;
+}
+
+
+/******************************************************************
+ *		get_dll_load_path_search_flags
+ */
+static WCHAR *get_dll_load_path_search_flags( LPCWSTR module, DWORD flags )
+{
+    const WCHAR *image = NULL, *mod_end, *image_end;
+    struct dll_dir_entry *dir;
+    WCHAR *p, *ret;
+    int len = 1;
+
+    if (flags & LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)
+        flags |= (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
+                  LOAD_LIBRARY_SEARCH_USER_DIRS |
+                  LOAD_LIBRARY_SEARCH_SYSTEM32);
+
+    if (flags & LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR)
+    {
+        DWORD type = RtlDetermineDosPathNameType_U( module );
+        if (type != ABSOLUTE_DRIVE_PATH && type != ABSOLUTE_PATH)
+        {
+            SetLastError( ERROR_INVALID_PARAMETER );
+            return NULL;
+        }
+        mod_end = get_module_path_end( module );
+        len += (mod_end - module) + 1;
+    }
+    else module = NULL;
+
+    RtlEnterCriticalSection( &dlldir_section );
+
+    if (flags & LOAD_LIBRARY_SEARCH_APPLICATION_DIR)
+    {
+        image = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+        image_end = get_module_path_end( image );
+        len += (image_end - image) + 1;
+    }
+
+    if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
+    {
+        LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
+            len += strlenW( dir->dir ) + 1;
+        len += GetDllDirectoryW( 0, NULL );
+    }
+
+    if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) len += GetSystemDirectoryW( NULL, 0 );
+
+    if ((p = ret = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+    {
+        if (module) p = append_path_len( p, module, mod_end - module );
+        if (image) p = append_path_len( p, image, image_end - image );
+        if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
+        {
+            LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
+                p = append_path( p, dir->dir );
+            GetDllDirectoryW( ret + len - p, p );
+            if (*p)
+            {
+                p += strlenW(p);
+                *p++ = ';';
+            }
+        }
+        if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) GetSystemDirectoryW( p, ret + len - p );
+        else
+        {
+            if (p > ret) p--;
+            *p = 0;
+        }
+    }
+
+    RtlLeaveCriticalSection( &dlldir_section );
+    return ret;
+}
+
+
+/******************************************************************
+ *		load_library_as_datafile
+ */
+static BOOL load_library_as_datafile( LPCWSTR name, HMODULE *hmod, DWORD flags )
+{
+    static const WCHAR dotDLL[] = {'.','d','l','l',0};
+
+    WCHAR filenameW[MAX_PATH];
+    HANDLE hFile = INVALID_HANDLE_VALUE;
+    HANDLE mapping;
+    HMODULE module = 0;
+    DWORD protect = PAGE_READONLY;
+    DWORD sharing = FILE_SHARE_READ | FILE_SHARE_DELETE;
+
+    *hmod = 0;
+
+    if (flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE) protect |= SEC_IMAGE;
+
+    if (SearchPathW( NULL, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
+    {
+        hFile = CreateFileW( filenameW, GENERIC_READ, sharing, NULL, OPEN_EXISTING, 0, 0 );
+    }
+    if (hFile == INVALID_HANDLE_VALUE) return FALSE;
+
+    mapping = CreateFileMappingW( hFile, NULL, protect, 0, 0, NULL );
+    if (!mapping) goto failed;
+
+    module = MapViewOfFile( mapping, FILE_MAP_READ, 0, 0, 0 );
+    CloseHandle( mapping );
+    if (!module) goto failed;
+
+    if (!(flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE))
+    {
+        /* make sure it's a valid PE file */
+        if (!RtlImageNtHeader( module )) goto failed;
+        *hmod = (HMODULE)((char *)module + 1); /* set bit 0 for data file module */
+
+        if (flags & LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE)
+        {
+            struct exclusive_datafile *file = HeapAlloc( GetProcessHeap(), 0, sizeof(*file) );
+            if (!file) goto failed;
+            file->module = *hmod;
+            file->file   = hFile;
+            list_add_head( &exclusive_datafile_list, &file->entry );
+            TRACE( "delaying close %p for module %p\n", file->file, file->module );
+            return TRUE;
+        }
+    }
+    else *hmod = (HMODULE)((char *)module + 2); /* set bit 1 for image resource module */
+
+    CloseHandle( hFile );
+    return TRUE;
+
+failed:
+    if (module) UnmapViewOfFile( module );
+    CloseHandle( hFile );
+    return FALSE;
+}
+
+
+/******************************************************************
+ *		load_library
+ *
+ * Helper for LoadLibraryExA/W.
+ */
+static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
+{
+    NTSTATUS nts;
+    HMODULE hModule;
+    WCHAR *load_path;
+    const DWORD load_library_search_flags = (LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR |
+                                             LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
+                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
+                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
+                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
+    const DWORD unsupported_flags = (LOAD_IGNORE_CODE_AUTHZ_LEVEL |
+                                     LOAD_LIBRARY_REQUIRE_SIGNED_TARGET);
+
+    if( flags & unsupported_flags)
+        FIXME("unsupported flag(s) used (flags: 0x%08x)\n", flags);
+
+    if (flags & LOAD_WITH_ALTERED_SEARCH_PATH)
+    {
+        if (flags & load_library_search_flags)
+        {
+            SetLastError( ERROR_INVALID_PARAMETER );
+            return 0;
+        }
+        if (default_search_flags) flags |= default_search_flags | LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR;
+    }
+    else if (!(flags & load_library_search_flags)) flags |= default_search_flags;
+
+    if (flags & load_library_search_flags)
+        load_path = get_dll_load_path_search_flags( libname->Buffer, flags );
+    else
+        load_path = MODULE_get_dll_load_path( flags & LOAD_WITH_ALTERED_SEARCH_PATH ? libname->Buffer : NULL, -1 );
+    if (!load_path) return 0;
+
+    if (flags & (LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE | LOAD_LIBRARY_AS_IMAGE_RESOURCE))
+    {
+        ULONG_PTR magic;
+
+        LdrLockLoaderLock( 0, NULL, &magic );
+        if (!LdrGetDllHandle( load_path, flags, libname, &hModule ))
+        {
+            LdrAddRefDll( 0, hModule );
+            LdrUnlockLoaderLock( 0, magic );
+            goto done;
+        }
+        if (load_library_as_datafile( libname->Buffer, &hModule, flags ))
+        {
+            LdrUnlockLoaderLock( 0, magic );
+            goto done;
+        }
+        LdrUnlockLoaderLock( 0, magic );
+        flags |= DONT_RESOLVE_DLL_REFERENCES; /* Just in case */
+        /* Fallback to normal behaviour */
+    }
+
+    nts = LdrLoadDll( load_path, flags, libname, &hModule );
+    if (nts != STATUS_SUCCESS)
+    {
+        hModule = 0;
+        if (nts == STATUS_DLL_NOT_FOUND && (GetVersion() & 0x80000000))
+            SetLastError( ERROR_DLL_NOT_FOUND );
+        else
+            SetLastError( RtlNtStatusToDosError( nts ) );
+    }
+done:
+    HeapFree( GetProcessHeap(), 0, load_path );
+    return hModule;
+}
+
+
+/******************************************************************
+ *		LoadLibraryExA          (KERNEL32.@)
+ *
+ * Load a dll file into the process address space.
+ *
+ * PARAMS
+ *  libname [I] Name of the file to load
+ *  hfile   [I] Reserved, must be 0.
+ *  flags   [I] Flags for loading the dll
+ *
+ * RETURNS
+ *  Success: A handle to the loaded dll.
+ *  Failure: A NULL handle. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ * The HFILE parameter is not used and marked reserved in the SDK. I can
+ * only guess that it should force a file to be mapped, but I rather
+ * ignore the parameter because it would be extremely difficult to
+ * integrate this with different types of module representations.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExA(LPCSTR libname, HANDLE hfile, DWORD flags)
+{
+    WCHAR *libnameW;
+
+    if (!(libnameW = FILE_name_AtoW( libname, FALSE ))) return 0;
+    return LoadLibraryExW( libnameW, hfile, flags );
+}
+
+/***********************************************************************
+ *           LoadLibraryExW       (KERNEL32.@)
+ *
+ * Unicode version of LoadLibraryExA.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExW(LPCWSTR libnameW, HANDLE hfile, DWORD flags)
+{
+    UNICODE_STRING      wstr;
+    HMODULE             res;
+
+    if (!libnameW)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return 0;
+    }
+    RtlInitUnicodeString( &wstr, libnameW );
+    if (wstr.Buffer[wstr.Length/sizeof(WCHAR) - 1] != ' ')
+        return load_library( &wstr, flags );
+
+    /* Library name has trailing spaces */
+    RtlCreateUnicodeString( &wstr, libnameW );
+    while (wstr.Length > sizeof(WCHAR) &&
+           wstr.Buffer[wstr.Length/sizeof(WCHAR) - 1] == ' ')
+    {
+        wstr.Length -= sizeof(WCHAR);
+    }
+    wstr.Buffer[wstr.Length/sizeof(WCHAR)] = '\0';
+    res = load_library( &wstr, flags );
+    RtlFreeUnicodeString( &wstr );
+    return res;
+}
+
+/***********************************************************************
+ *           LoadLibraryA         (KERNEL32.@)
+ *
+ * Load a dll file into the process address space.
+ *
+ * PARAMS
+ *  libname [I] Name of the file to load
+ *
+ * RETURNS
+ *  Success: A handle to the loaded dll.
+ *  Failure: A NULL handle. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ * See LoadLibraryExA().
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryA(LPCSTR libname)
+{
+    return LoadLibraryExA(libname, 0, 0);
+}
+
+/***********************************************************************
+ *           LoadLibraryW         (KERNEL32.@)
+ *
+ * Unicode version of LoadLibraryA.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryW(LPCWSTR libnameW)
+{
+    return LoadLibraryExW(libnameW, 0, 0);
+}
+
+/***********************************************************************
+ *           FreeLibrary   (KERNEL32.@)
+ *
+ * Free a dll loaded into the process address space.
+ *
+ * PARAMS
+ *  hLibModule [I] Handle to the dll returned by LoadLibraryA().
+ *
+ * RETURNS
+ *  Success: TRUE. The dll is removed if it is not still in use.
+ *  Failure: FALSE. Use GetLastError() to determine the cause.
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary(HINSTANCE hLibModule)
+{
+    if (!hLibModule)
+    {
+        SetLastError( ERROR_INVALID_HANDLE );
+        return FALSE;
+    }
+
+    if ((ULONG_PTR)hLibModule & 3) /* this is a datafile module */
+    {
+        void *ptr = (void *)((ULONG_PTR)hLibModule & ~3);
+        if (!RtlImageNtHeader( ptr ))
+        {
+            SetLastError( ERROR_BAD_EXE_FORMAT );
+            return FALSE;
+        }
+        if ((ULONG_PTR)hLibModule & 1)
+        {
+            struct exclusive_datafile *file;
+            ULONG_PTR magic;
+
+            LdrLockLoaderLock( 0, NULL, &magic );
+            LIST_FOR_EACH_ENTRY( file, &exclusive_datafile_list, struct exclusive_datafile, entry )
+            {
+                if (file->module != hLibModule) continue;
+                TRACE( "closing %p for module %p\n", file->file, file->module );
+                CloseHandle( file->file );
+                list_remove( &file->entry );
+                HeapFree( GetProcessHeap(), 0, file );
+                break;
+            }
+            LdrUnlockLoaderLock( 0, magic );
+        }
+        return UnmapViewOfFile( ptr );
+    }
+
+    return set_ntstatus( LdrUnloadDll( hLibModule ));
+}
+
 /***********************************************************************
  *           GetProcAddress   		(KERNEL32.@)
  *
diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 28fad7e61b..0eab7ec9e5 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -439,18 +439,11 @@ static HANDLE open_exe_file( const WCHAR *name, BOOL *is_64bit )
  */
 static BOOL find_exe_file( const WCHAR *name, WCHAR *buffer, int buflen, HANDLE *handle )
 {
-    WCHAR *load_path;
-    BOOL ret;
-
-    if (!set_ntstatus( RtlGetExePath( name, &load_path ))) return FALSE;
-
-    TRACE("looking for %s in %s\n", debugstr_w(name), debugstr_w(load_path) );
+    TRACE("looking for %s\n", debugstr_w(name) );
 
-    ret = (SearchPathW( load_path, name, exeW, buflen, buffer, NULL ) ||
-           /* no builtin found, try native without extension in case it is a Unix app */
-           SearchPathW( load_path, name, NULL, buflen, buffer, NULL ));
-    RtlReleasePath( load_path );
-    if (!ret) return FALSE;
+    if (!SearchPathW( NULL, name, exeW, buflen, buffer, NULL ) &&
+        /* no builtin found, try native without extension in case it is a Unix app */
+        !SearchPathW( NULL, name, NULL, buflen, buffer, NULL )) return FALSE;
 
     TRACE( "Trying native exe %s\n", debugstr_w(buffer) );
     *handle = CreateFileW( buffer, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_DELETE,
@@ -1390,7 +1383,6 @@ void * CDECL __wine_kernel_init(void)
     RTL_USER_PROCESS_PARAMETERS *params = peb->ProcessParameters;
     HANDLE boot_events[2];
     BOOL got_environment = TRUE;
-    WCHAR *load_path, *dummy;
 
     /* Initialize everything */
 
@@ -1429,14 +1421,12 @@ void * CDECL __wine_kernel_init(void)
     {
         BOOL is_64bit;
 
-        RtlGetExePath( __wine_main_wargv[0], &load_path );
-        if (!SearchPathW( load_path, __wine_main_wargv[0], exeW, MAX_PATH, main_exe_name, NULL ) &&
+        if (!SearchPathW( NULL, __wine_main_wargv[0], exeW, MAX_PATH, main_exe_name, NULL ) &&
             !get_builtin_path( __wine_main_wargv[0], exeW, main_exe_name, MAX_PATH, &is_64bit ))
         {
             MESSAGE( "wine: cannot find '%s'\n", __wine_main_argv[0] );
             ExitProcess( GetLastError() );
         }
-        RtlReleasePath( load_path );
         update_library_argv0( main_exe_name );
         if (!build_command_line( __wine_main_wargv )) goto error;
         start_wineboot( boot_events );
@@ -1449,8 +1439,8 @@ void * CDECL __wine_kernel_init(void)
     TRACE( "starting process name=%s argv[0]=%s\n",
            debugstr_w(main_exe_name), debugstr_w(__wine_main_wargv[0]) );
 
-    LdrGetDllPath( main_exe_name, 0, &load_path, &dummy );
-    RtlInitUnicodeString( &NtCurrentTeb()->Peb->ProcessParameters->DllPath, load_path );
+    RtlInitUnicodeString( &NtCurrentTeb()->Peb->ProcessParameters->DllPath,
+                          MODULE_get_dll_load_path( main_exe_name, -1 ));
 
     if (boot_events[0])
     {
diff --git a/dlls/kernel32/tests/path.c b/dlls/kernel32/tests/path.c
index 71577793b0..876ca743bc 100644
--- a/dlls/kernel32/tests/path.c
+++ b/dlls/kernel32/tests/path.c
@@ -73,15 +73,10 @@ static DWORD (WINAPI *pGetLongPathNameW)(LPWSTR,LPWSTR,DWORD);
 static BOOL  (WINAPI *pNeedCurrentDirectoryForExePathA)(LPCSTR);
 static BOOL  (WINAPI *pNeedCurrentDirectoryForExePathW)(LPCWSTR);
 
-static DLL_DIRECTORY_COOKIE (WINAPI *pAddDllDirectory)(const WCHAR*);
-static BOOL     (WINAPI *pRemoveDllDirectory)(DLL_DIRECTORY_COOKIE);
-static BOOL     (WINAPI *pSetSearchPathMode)(DWORD);
-static BOOL     (WINAPI *pSetDllDirectoryW)(LPCWSTR);
-static BOOL     (WINAPI *pSetDefaultDllDirectories)(DWORD);
-static NTSTATUS (WINAPI *pRtlGetExePath)(LPCWSTR,LPWSTR*);
+static BOOL  (WINAPI *pSetSearchPathMode)(DWORD);
+static BOOL  (WINAPI *pSetDllDirectoryA)(LPCSTR);
 static NTSTATUS (WINAPI *pRtlGetSearchPath)(LPWSTR*);
-static void     (WINAPI *pRtlReleasePath)(LPWSTR);
-static NTSTATUS (WINAPI *pLdrGetDllPath)(LPCWSTR,ULONG,LPWSTR*,LPWSTR*);
+static void (WINAPI *pRtlReleasePath)(LPWSTR);
 
 static BOOL   (WINAPI *pActivateActCtx)(HANDLE,ULONG_PTR*);
 static HANDLE (WINAPI *pCreateActCtxW)(PCACTCTXW);
@@ -2206,10 +2201,7 @@ static void init_pointers(void)
     MAKEFUNC(NeedCurrentDirectoryForExePathA);
     MAKEFUNC(NeedCurrentDirectoryForExePathW);
     MAKEFUNC(SetSearchPathMode);
-    MAKEFUNC(AddDllDirectory);
-    MAKEFUNC(RemoveDllDirectory);
-    MAKEFUNC(SetDllDirectoryW);
-    MAKEFUNC(SetDefaultDllDirectories);
+    MAKEFUNC(SetDllDirectoryA);
     MAKEFUNC(ActivateActCtx);
     MAKEFUNC(CreateActCtxW);
     MAKEFUNC(DeactivateActCtx);
@@ -2218,8 +2210,6 @@ static void init_pointers(void)
     MAKEFUNC(CheckNameLegalDOS8Dot3W);
     MAKEFUNC(CheckNameLegalDOS8Dot3A);
     mod = GetModuleHandleA("ntdll.dll");
-    MAKEFUNC(LdrGetDllPath);
-    MAKEFUNC(RtlGetExePath);
     MAKEFUNC(RtlGetSearchPath);
     MAKEFUNC(RtlReleasePath);
 #undef MAKEFUNC
@@ -2480,23 +2470,12 @@ static void test_SetSearchPathMode(void)
 
 static const WCHAR pathW[] = {'P','A','T','H',0};
 
-static void build_search_path( WCHAR *buffer, UINT size, const WCHAR *dlldir, BOOL safe )
+static void build_search_path( WCHAR *buffer, UINT size, BOOL safe )
 {
     WCHAR *p;
     GetModuleFileNameW( NULL, buffer, size );
     if (!(p = wcsrchr( buffer, '\\' ))) return;
     *p++ = ';';
-    if (dlldir)
-    {
-        lstrcpyW( p, dlldir );
-        p += lstrlenW( p );
-        if (*dlldir) *p++ = ';';
-    }
-    else if (!safe)
-    {
-        *p++ = '.';
-        *p++ = ';';
-    }
     GetSystemDirectoryW( p, buffer + size - p );
     p = buffer + lstrlenW(buffer);
     *p++ = ';';
@@ -2506,7 +2485,7 @@ static void build_search_path( WCHAR *buffer, UINT size, const WCHAR *dlldir, BO
     GetWindowsDirectoryW( p, buffer + size - p );
     p = buffer + lstrlenW(buffer);
     *p++ = ';';
-    if (!dlldir && safe)
+    if (!safe)
     {
         *p++ = '.';
         *p++ = ';';
@@ -2522,7 +2501,7 @@ static BOOL path_equal( const WCHAR *path1, const WCHAR *path2 )
         if (*path1 && *path1 != '\\' && *path1 != ';') return FALSE;
         while (*path1 && (*path1 == '\\' || *path1 == ';')) path1++;
         while (*path2 && (*path2 == '\\' || *path2 == ';')) path2++;
-        if (!*path1 || !*path2) return !*path1 && !*path2;
+        if (!*path1 && !*path2) return TRUE;
     }
 }
 
@@ -2530,7 +2509,7 @@ static void test_RtlGetSearchPath(void)
 {
     NTSTATUS ret;
     WCHAR *path;
-    WCHAR buffer[2048], old_path[2048], dlldir[4];
+    WCHAR buffer[2048], old_path[2048];
 
     if (!pRtlGetSearchPath)
     {
@@ -2539,10 +2518,8 @@ static void test_RtlGetSearchPath(void)
     }
 
     GetEnvironmentVariableW( pathW, old_path, ARRAY_SIZE(old_path) );
-    GetWindowsDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    lstrcpynW( dlldir, buffer, ARRAY_SIZE(dlldir) );
 
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
+    build_search_path( buffer, ARRAY_SIZE(buffer), FALSE );
     path = (WCHAR *)0xdeadbeef;
     ret = pRtlGetSearchPath( &path );
     ok( !ret, "RtlGetSearchPath failed %x\n", ret );
@@ -2550,195 +2527,23 @@ static void test_RtlGetSearchPath(void)
     pRtlReleasePath( path );
 
     SetEnvironmentVariableA( "PATH", "foo" );
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
+    build_search_path( buffer, ARRAY_SIZE(buffer), FALSE );
     path = (WCHAR *)0xdeadbeef;
     ret = pRtlGetSearchPath( &path );
     ok( !ret, "RtlGetSearchPath failed %x\n", ret );
     ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
     pRtlReleasePath( path );
 
-    if (pSetDllDirectoryW)
+    if (pSetDllDirectoryA)
     {
-        ok( pSetDllDirectoryW( dlldir ), "SetDllDirectoryW failed\n" );
-        build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
+        ok( pSetDllDirectoryA( "c:\\" ), "SetDllDirectoryA failed\n" );
+        build_search_path( buffer, ARRAY_SIZE(buffer), FALSE );
         path = (WCHAR *)0xdeadbeef;
         ret = pRtlGetSearchPath( &path );
         ok( !ret, "RtlGetSearchPath failed %x\n", ret );
         ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
         pRtlReleasePath( path );
-        pSetDllDirectoryW( NULL );
-    }
-
-    SetEnvironmentVariableW( pathW, old_path );
-}
-
-static void test_RtlGetExePath(void)
-{
-    static const WCHAR fooW[] = {'\\','f','o','o',0};
-    static const WCHAR emptyW[1];
-    NTSTATUS ret;
-    WCHAR *path;
-    WCHAR buffer[2048], old_path[2048], dlldir[4];
-
-    if (!pRtlGetExePath)
-    {
-        win_skip( "RtlGetExePath isn't available\n" );
-        return;
-    }
-
-    GetEnvironmentVariableW( pathW, old_path, ARRAY_SIZE(old_path) );
-    GetWindowsDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    lstrcpynW( dlldir, buffer, ARRAY_SIZE(dlldir) );
-    SetEnvironmentVariableA( "NoDefaultCurrentDirectoryInExePath", NULL );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW + 1, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    SetEnvironmentVariableA( "NoDefaultCurrentDirectoryInExePath", "yes" );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), emptyW, TRUE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW + 1, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    SetEnvironmentVariableA( "PATH", "foo" );
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    if (pSetDllDirectoryW)
-    {
-        ok( pSetDllDirectoryW( dlldir ), "SetDllDirectoryW failed\n" );
-        build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-        path = (WCHAR *)0xdeadbeef;
-        ret = pRtlGetExePath( fooW, &path );
-        ok( !ret, "RtlGetExePath failed %x\n", ret );
-        ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-        pRtlReleasePath( path );
-        pSetDllDirectoryW( NULL );
-    }
-
-    SetEnvironmentVariableW( pathW, old_path );
-}
-
-static void test_LdrGetDllPath(void)
-{
-    static const WCHAR fooW[] = {'f','o','o',0};
-    NTSTATUS ret;
-    WCHAR *path, *unknown_ptr, *p;
-    WCHAR buffer[2048], old_path[2048], dlldir[4];
-
-    if (!pLdrGetDllPath)
-    {
-        win_skip( "LdrGetDllPath isn't available\n" );
-        return;
-    }
-    GetEnvironmentVariableW( pathW, old_path, ARRAY_SIZE(old_path) );
-    GetWindowsDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    lstrcpynW( dlldir, buffer, ARRAY_SIZE(dlldir) );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
-
-    path = unknown_ptr = (WCHAR *)0xdeadbeef;
-    ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    SetEnvironmentVariableA( "PATH", "foo" );
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
-    ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    if (pSetDllDirectoryW)
-    {
-        ok( pSetDllDirectoryW( dlldir ), "SetDllDirectoryW failed\n" );
-        build_search_path( buffer, ARRAY_SIZE(buffer), dlldir, TRUE );
-        ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-        ok( !ret, "LdrGetDllPath failed %x\n", ret );
-        ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-        ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-        pRtlReleasePath( path );
-        pSetDllDirectoryW( NULL );
-    }
-
-    ret = pLdrGetDllPath( 0, LOAD_LIBRARY_SEARCH_SYSTEM32, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    GetSystemDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    ret = pLdrGetDllPath( 0, LOAD_LIBRARY_SEARCH_APPLICATION_DIR, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    GetModuleFileNameW( NULL, buffer, ARRAY_SIZE(buffer) );
-    if ((p = wcsrchr( buffer, '\\' ))) *p = 0;
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    ret = pLdrGetDllPath( fooW, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR, &path, &unknown_ptr );
-    ok( ret == STATUS_INVALID_PARAMETER, "LdrGetDllPath failed %x\n", ret );
-
-    lstrcpyW( buffer, dlldir );
-    p = buffer + lstrlenW(buffer);
-    *p++ = '\\';
-    lstrcpyW( p, fooW );
-    ret = pLdrGetDllPath( buffer, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    ok( path_equal( path, dlldir ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(dlldir));
-    pRtlReleasePath( path );
-
-    if (pAddDllDirectory)
-    {
-        DLL_DIRECTORY_COOKIE cookie = pAddDllDirectory( dlldir );
-        ok( !!cookie, "AddDllDirectory failed\n" );
-        ret = pLdrGetDllPath( 0, LOAD_LIBRARY_SEARCH_USER_DIRS, &path, &unknown_ptr );
-        ok( !ret, "LdrGetDllPath failed %x\n", ret );
-        ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-        ok( path_equal( path, dlldir ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(dlldir));
-        pRtlReleasePath( path );
-        pRemoveDllDirectory( cookie );
-    }
-
-    if (pSetDefaultDllDirectories)
-    {
-        pSetDefaultDllDirectories( LOAD_LIBRARY_SEARCH_SYSTEM32 );
-        ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-        ok( !ret, "LdrGetDllPath failed %x\n", ret );
-        ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-        GetSystemDirectoryW( buffer, ARRAY_SIZE(buffer) );
-        ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-        pRtlReleasePath( path );
-        pSetDefaultDllDirectories( 0 );
+        pSetDllDirectoryA( NULL );
     }
 
     SetEnvironmentVariableW( pathW, old_path );
@@ -2779,6 +2584,4 @@ START_TEST(path)
     test_CheckNameLegalDOS8Dot3();
     test_SetSearchPathMode();
     test_RtlGetSearchPath();
-    test_RtlGetExePath();
-    test_LdrGetDllPath();
 }
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index b64a1fc1ae..7d86399af5 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -19,7 +19,7 @@
 @ stdcall AddAuditAccessAce(ptr long long ptr long long)
 @ stdcall AddAuditAccessAceEx(ptr long long long ptr long long)
 @ stdcall AddAuditAccessObjectAce(ptr long long long ptr ptr ptr long long)
-@ stdcall AddDllDirectory(wstr)
+@ stdcall AddDllDirectory(wstr) kernel32.AddDllDirectory
 @ stdcall AddMandatoryAce(ptr long long long ptr)
 @ stdcall AddRefActCtx(ptr)
 # @ stub AddResourceAttributeAce
@@ -394,7 +394,7 @@
 @ stdcall FreeEnvironmentStringsW(ptr)
 # @ stub FreeGPOListInternalA
 # @ stub FreeGPOListInternalW
-@ stdcall FreeLibrary(long)
+@ stdcall FreeLibrary(long) kernel32.FreeLibrary
 @ stdcall FreeLibraryAndExitThread(long long)
 @ stdcall FreeLibraryWhenCallbackReturns(ptr ptr) ntdll.TpCallbackUnloadDllOnCompletion
 @ stdcall FreeResource(long)
@@ -618,7 +618,7 @@
 # @ stub GetPreviousFgPolicyRefreshInfoInternal
 @ stdcall GetPriorityClass(long)
 @ stdcall GetPrivateObjectSecurity(ptr long ptr long ptr)
-@ stdcall GetProcAddress(long str)
+@ stdcall GetProcAddress(long str) kernel32.GetProcAddress
 # @ stub GetProcAddressForCaller
 # @ stub GetProcessDefaultCpuSets
 # @ stub GetProcessGroupAffinity
@@ -922,10 +922,10 @@
 @ stdcall LeaveCriticalSectionWhenCallbackReturns(ptr ptr) ntdll.TpCallbackLeaveCriticalSectionOnCompletion
 # @ stub LoadAppInitDlls
 # @ stub LoadEnclaveData
-@ stdcall LoadLibraryA(str)
-@ stdcall LoadLibraryExA( str long long)
-@ stdcall LoadLibraryExW(wstr long long)
-@ stdcall LoadLibraryW(wstr)
+@ stdcall LoadLibraryA(str) kernel32.LoadLibraryA
+@ stdcall LoadLibraryExA( str long long) kernel32.LoadLibraryExA
+@ stdcall LoadLibraryExW(wstr long long) kernel32.LoadLibraryExW
+@ stdcall LoadLibraryW(wstr) kernel32.LoadLibraryW
 # @ stub LoadPackagedLibrary
 @ stdcall LoadResource(long long)
 @ stdcall LoadStringA(long long ptr long)
@@ -1333,7 +1333,7 @@
 @ stdcall RemapPredefinedHandleInternal(long long)
 @ stdcall RemoveDirectoryA(str) kernel32.RemoveDirectoryA
 @ stdcall RemoveDirectoryW(wstr) kernel32.RemoveDirectoryW
-@ stdcall RemoveDllDirectory(ptr)
+@ stdcall RemoveDllDirectory(ptr) kernel32.RemoveDllDirectory
 # @ stub RemovePackageStatus
 # @ stub RemovePackageStatusForUser
 @ stdcall RemoveVectoredContinueHandler(ptr) ntdll.RtlRemoveVectoredContinueHandler
@@ -1419,7 +1419,7 @@
 @ stdcall SetCriticalSectionSpinCount(ptr long) ntdll.RtlSetCriticalSectionSpinCount
 @ stdcall SetCurrentDirectoryA(str)
 @ stdcall SetCurrentDirectoryW(wstr)
-@ stdcall SetDefaultDllDirectories(long)
+@ stdcall SetDefaultDllDirectories(long) kernel32.SetDefaultDllDirectories
 # @ stub SetDynamicTimeZoneInformation
 @ stdcall SetEndOfFile(long)
 @ stub SetEnvironmentStringsW
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 4a3e0f4722..de46cc8c10 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -31,175 +31,17 @@
 #include "winnls.h"
 #include "winternl.h"
 #include "kernelbase.h"
-#include "wine/list.h"
-#include "wine/asm.h"
 #include "wine/debug.h"
 #include "wine/exception.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
 
-/* to keep track of LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE file handles */
-struct exclusive_datafile
-{
-    struct list entry;
-    HMODULE     module;
-    HANDLE      file;
-};
-static struct list exclusive_datafile_list = LIST_INIT( exclusive_datafile_list );
-
-
 /***********************************************************************
  * Modules
  ***********************************************************************/
 
 
-/******************************************************************
- *      get_proc_address
- */
-FARPROC WINAPI get_proc_address( HMODULE module, LPCSTR function )
-{
-    FARPROC proc;
-    ANSI_STRING str;
-
-    if (!module) module = NtCurrentTeb()->Peb->ImageBaseAddress;
-
-    if ((ULONG_PTR)function >> 16)
-    {
-        RtlInitAnsiString( &str, function );
-        if (!set_ntstatus( LdrGetProcedureAddress( module, &str, 0, (void**)&proc ))) return NULL;
-    }
-    else if (!set_ntstatus( LdrGetProcedureAddress( module, NULL, LOWORD(function), (void**)&proc )))
-        return NULL;
-
-    return proc;
-}
-
-
-/******************************************************************
- *      load_library_as_datafile
- */
-static BOOL load_library_as_datafile( LPCWSTR load_path, DWORD flags, LPCWSTR name, HMODULE *mod_ret )
-{
-    static const WCHAR dotDLL[] = {'.','d','l','l',0};
-
-    WCHAR filenameW[MAX_PATH];
-    HANDLE mapping, file = INVALID_HANDLE_VALUE;
-    HMODULE module = 0;
-    DWORD protect = PAGE_READONLY;
-
-    *mod_ret = 0;
-
-    if (flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE) protect |= SEC_IMAGE;
-
-    if (SearchPathW( load_path, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
-    {
-        file = CreateFileW( filenameW, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE,
-                            NULL, OPEN_EXISTING, 0, 0 );
-    }
-    if (file == INVALID_HANDLE_VALUE) return FALSE;
-
-    mapping = CreateFileMappingW( file, NULL, protect, 0, 0, NULL );
-    if (!mapping) goto failed;
-
-    module = MapViewOfFile( mapping, FILE_MAP_READ, 0, 0, 0 );
-    CloseHandle( mapping );
-    if (!module) goto failed;
-
-    if (!(flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE))
-    {
-        /* make sure it's a valid PE file */
-        if (!RtlImageNtHeader( module )) goto failed;
-        *mod_ret = (HMODULE)((char *)module + 1); /* set bit 0 for data file module */
-
-        if (flags & LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE)
-        {
-            struct exclusive_datafile *file = HeapAlloc( GetProcessHeap(), 0, sizeof(*file) );
-            if (!file) goto failed;
-            file->module = *mod_ret;
-            file->file   = file;
-            list_add_head( &exclusive_datafile_list, &file->entry );
-            TRACE( "delaying close %p for module %p\n", file->file, file->module );
-            return TRUE;
-        }
-    }
-    else *mod_ret = (HMODULE)((char *)module + 2); /* set bit 1 for image resource module */
-
-    CloseHandle( file );
-    return TRUE;
-
-failed:
-    if (module) UnmapViewOfFile( module );
-    CloseHandle( file );
-    return FALSE;
-}
-
-
-/******************************************************************
- *      load_library
- */
-static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
-{
-    const DWORD unsupported_flags = LOAD_IGNORE_CODE_AUTHZ_LEVEL | LOAD_LIBRARY_REQUIRE_SIGNED_TARGET;
-    NTSTATUS status;
-    HMODULE module;
-    WCHAR *load_path, *dummy;
-
-    if (flags & unsupported_flags) FIXME( "unsupported flag(s) used %#08x\n", flags );
-
-    if (!set_ntstatus( LdrGetDllPath( libname->Buffer, flags, &load_path, &dummy ))) return 0;
-
-    if (flags & (LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE |
-                 LOAD_LIBRARY_AS_IMAGE_RESOURCE))
-    {
-        ULONG_PTR magic;
-
-        LdrLockLoaderLock( 0, NULL, &magic );
-        if (!LdrGetDllHandle( load_path, flags, libname, &module ))
-        {
-            LdrAddRefDll( 0, module );
-            LdrUnlockLoaderLock( 0, magic );
-            goto done;
-        }
-        if (load_library_as_datafile( load_path, flags, libname->Buffer, &module ))
-        {
-            LdrUnlockLoaderLock( 0, magic );
-            goto done;
-        }
-        LdrUnlockLoaderLock( 0, magic );
-        flags |= DONT_RESOLVE_DLL_REFERENCES; /* Just in case */
-        /* Fallback to normal behaviour */
-    }
-
-    status = LdrLoadDll( load_path, flags, libname, &module );
-    if (status != STATUS_SUCCESS)
-    {
-        module = 0;
-        if (status == STATUS_DLL_NOT_FOUND && (GetVersion() & 0x80000000))
-            SetLastError( ERROR_DLL_NOT_FOUND );
-        else
-            SetLastError( RtlNtStatusToDosError( status ) );
-    }
-done:
-    RtlReleasePath( load_path );
-    return module;
-}
-
-
-/****************************************************************************
- *	AddDllDirectory   (kernelbase.@)
- */
-DLL_DIRECTORY_COOKIE WINAPI DECLSPEC_HOTPATCH AddDllDirectory( const WCHAR *dir )
-{
-    UNICODE_STRING str;
-    void *cookie;
-
-    RtlInitUnicodeString( &str, dir );
-    if (!set_ntstatus( LdrAddDllDirectory( &str, &cookie ))) return NULL;
-    return cookie;
-}
-
-
 /***********************************************************************
  *	DelayLoadFailureHook   (kernelbase.@)
  */
@@ -227,49 +69,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH DisableThreadLibraryCalls( HMODULE module )
 }
 
 
-/***********************************************************************
- *	FreeLibrary   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary( HINSTANCE module )
-{
-    if (!module)
-    {
-        SetLastError( ERROR_INVALID_HANDLE );
-        return FALSE;
-    }
-
-    if ((ULONG_PTR)module & 3) /* this is a datafile module */
-    {
-        void *ptr = (void *)((ULONG_PTR)module & ~3);
-        if (!RtlImageNtHeader( ptr ))
-        {
-            SetLastError( ERROR_BAD_EXE_FORMAT );
-            return FALSE;
-        }
-        if ((ULONG_PTR)module & 1)
-        {
-            struct exclusive_datafile *file;
-            ULONG_PTR magic;
-
-            LdrLockLoaderLock( 0, NULL, &magic );
-            LIST_FOR_EACH_ENTRY( file, &exclusive_datafile_list, struct exclusive_datafile, entry )
-            {
-                if (file->module != module) continue;
-                TRACE( "closing %p for module %p\n", file->file, file->module );
-                CloseHandle( file->file );
-                list_remove( &file->entry );
-                HeapFree( GetProcessHeap(), 0, file );
-                break;
-            }
-            LdrUnlockLoaderLock( 0, magic );
-        }
-        return UnmapViewOfFile( ptr );
-    }
-
-    return set_ntstatus( LdrUnloadDll( module ));
-}
-
-
 /***********************************************************************
  *	GetModuleFileNameA   (kernelbase.@)
  */
@@ -426,133 +225,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetModuleHandleExW( DWORD flags, LPCWSTR name, HMO
 }
 
 
-/***********************************************************************
- *	GetProcAddress   (kernelbase.@)
- */
-
-#ifdef __x86_64__
-/*
- * Work around a Delphi bug on x86_64.  When delay loading a symbol,
- * Delphi saves rcx, rdx, r8 and r9 to the stack.  It then calls
- * GetProcAddress(), pops the saved registers and calls the function.
- * This works fine if all of the parameters are ints.  However, since
- * it does not save xmm0 - 3, it relies on GetProcAddress() preserving
- * these registers if the function takes floating point parameters.
- * This wrapper saves xmm0 - 3 to the stack.
- */
-__ASM_GLOBAL_FUNC( GetProcAddress,
-                   ".byte 0x48\n\t"  /* hotpatch prolog */
-                   "pushq %rbp\n\t"
-                   __ASM_SEH(".seh_pushreg %rbp\n\t")
-                   __ASM_CFI(".cfi_adjust_cfa_offset 8\n\t")
-                   __ASM_CFI(".cfi_rel_offset %rbp,0\n\t")
-                   "movq %rsp,%rbp\n\t"
-                   __ASM_SEH(".seh_setframe %rbp,0\n\t")
-                   __ASM_CFI(".cfi_def_cfa_register %rbp\n\t")
-                   "subq $0x60,%rsp\n\t"
-                   __ASM_SEH(".seh_stackalloc 0x60\n\t")
-                   __ASM_SEH(".seh_endprologue\n\t")
-                   "movaps %xmm0,-0x10(%rbp)\n\t"
-                   "movaps %xmm1,-0x20(%rbp)\n\t"
-                   "movaps %xmm2,-0x30(%rbp)\n\t"
-                   "movaps %xmm3,-0x40(%rbp)\n\t"
-                   "call " __ASM_NAME("get_proc_address") "\n\t"
-                   "movaps -0x40(%rbp), %xmm3\n\t"
-                   "movaps -0x30(%rbp), %xmm2\n\t"
-                   "movaps -0x20(%rbp), %xmm1\n\t"
-                   "movaps -0x10(%rbp), %xmm0\n\t"
-                   "leaq 0(%rbp),%rsp\n\t"
-                   __ASM_CFI(".cfi_def_cfa_register %rsp\n\t")
-                   "popq %rbp\n\t"
-                   __ASM_CFI(".cfi_adjust_cfa_offset -8\n\t")
-                   __ASM_CFI(".cfi_same_value %rbp\n\t")
-                   "ret" )
-#else /* __x86_64__ */
-
-FARPROC WINAPI DECLSPEC_HOTPATCH GetProcAddress( HMODULE module, LPCSTR function )
-{
-    return get_proc_address( module, function );
-}
-
-#endif /* __x86_64__ */
-
-
-/***********************************************************************
- *	LoadLibraryA   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryA( LPCSTR name )
-{
-    return LoadLibraryExA( name, 0, 0 );
-}
-
-
-/***********************************************************************
- *	LoadLibraryW   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryW( LPCWSTR name )
-{
-    return LoadLibraryExW( name, 0, 0 );
-}
-
-
-/******************************************************************
- *	LoadLibraryExA   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExA( LPCSTR name, HANDLE file, DWORD flags )
-{
-    WCHAR *nameW;
-
-    if (!(nameW = file_name_AtoW( name, FALSE ))) return 0;
-    return LoadLibraryExW( nameW, file, flags );
-}
-
-
-/***********************************************************************
- *	LoadLibraryExW   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExW( LPCWSTR name, HANDLE file, DWORD flags )
-{
-    UNICODE_STRING str;
-    HMODULE module;
-
-    if (!name)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return 0;
-    }
-    RtlInitUnicodeString( &str, name );
-    if (str.Buffer[str.Length/sizeof(WCHAR) - 1] != ' ') return load_library( &str, flags );
-
-    /* library name has trailing spaces */
-    RtlCreateUnicodeString( &str, name );
-    while (str.Length > sizeof(WCHAR) && str.Buffer[str.Length/sizeof(WCHAR) - 1] == ' ')
-        str.Length -= sizeof(WCHAR);
-
-    str.Buffer[str.Length/sizeof(WCHAR)] = 0;
-    module = load_library( &str, flags );
-    RtlFreeUnicodeString( &str );
-    return module;
-}
-
-
-/****************************************************************************
- *	RemoveDllDirectory   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH RemoveDllDirectory( DLL_DIRECTORY_COOKIE cookie )
-{
-    return set_ntstatus( LdrRemoveDllDirectory( cookie ));
-}
-
-
-/*************************************************************************
- *	SetDefaultDllDirectories   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH SetDefaultDllDirectories( DWORD flags )
-{
-    return set_ntstatus( LdrSetDefaultDllDirectories( flags ));
-}
-
-
 /***********************************************************************
  * Resources
  ***********************************************************************/
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 610c62a3af..52a95877d2 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -72,25 +72,13 @@ const WCHAR system_dir[] = {'C',':','\\','w','i','n','d','o','w','s','\\',
 static const WCHAR system_path[] =
     {'C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m','3','2',';',
      'C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m',';',
-     'C',':','\\','w','i','n','d','o','w','s',0};
-
-static const WCHAR dotW[] = {'.',0};
+     'C',':','\\','w','i','n','d','o','w','s',';',0};
 
 static BOOL imports_fixup_done = FALSE;  /* set once the imports have been fixed up, before attaching them */
 static BOOL process_detaching = FALSE;  /* set on process detach to avoid deadlocks with thread detach */
 static int free_lib_count;   /* recursion depth of LdrUnloadDll calls */
 static ULONG path_safe_mode;  /* path mode set by RtlSetSearchPathMode */
-static ULONG dll_safe_mode = 1;  /* dll search mode */
 static UNICODE_STRING dll_directory;  /* extra path for LdrSetDllDirectory */
-static DWORD default_search_flags;  /* default flags set by LdrSetDefaultDllDirectories */
-
-struct dll_dir_entry
-{
-    struct list entry;
-    WCHAR       dir[1];
-};
-
-static struct list dll_dir_list = LIST_INIT( dll_dir_list );  /* extra dirs from LdrAddDllDirectory */
 
 struct ldr_notification
 {
@@ -2090,54 +2078,25 @@ static BOOL is_valid_binary( HMODULE module, const pe_image_info_t *info )
 }
 
 
-/******************************************************************
- *		get_module_path_end
- *
- * Returns the end of the directory component of the module path.
- */
-static inline const WCHAR *get_module_path_end( const WCHAR *module )
-{
-    const WCHAR *p;
-    const WCHAR *mod_end = module;
-
-    if ((p = strrchrW( mod_end, '\\' ))) mod_end = p;
-    if ((p = strrchrW( mod_end, '/' ))) mod_end = p;
-    if (mod_end == module + 2 && module[1] == ':') mod_end++;
-    if (mod_end == module && module[0] && module[1] == ':') mod_end += 2;
-    return mod_end;
-}
-
-
-/******************************************************************
- *		append_path
- *
- * Append a counted string to the load path. Helper for get_dll_load_path.
- */
-static inline WCHAR *append_path( WCHAR *p, const WCHAR *str, int len )
-{
-    if (len == -1) len = strlenW(str);
-    if (!len) return p;
-    memcpy( p, str, len * sizeof(WCHAR) );
-    p[len] = ';';
-    return p + len + 1;
-}
-
-
 /******************************************************************
  *           get_dll_load_path
  */
-static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_mode, WCHAR **path )
+static NTSTATUS get_dll_load_path( LPCWSTR module, int safe_mode, WCHAR **path )
 {
     static const WCHAR pathW[] = {'P','A','T','H',0};
+    static const WCHAR dotW[] = {'.',';',0};
 
     const WCHAR *mod_end = module;
     UNICODE_STRING name, value;
     WCHAR *p, *ret;
-    int len = ARRAY_SIZE(system_path) + 1, path_len = 0;
+    int len = ARRAY_SIZE(system_path), path_len = 0;
 
     if (module)
     {
-        mod_end = get_module_path_end( module );
+        if ((p = strrchrW( mod_end, '\\' ))) mod_end = p;
+        if ((p = strrchrW( mod_end, '/' ))) mod_end = p;
+        if (mod_end == module + 2 && module[1] == ':') mod_end++;
+        if (mod_end == module && module[0] && module[1] == ':') mod_end += 2;
         len += (mod_end - module) + 1;
     }
 
@@ -2148,18 +2107,18 @@ static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_m
     if (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
         path_len = value.Length;
 
-    if (dll_dir) len += strlenW( dll_dir ) + 1;
-    else len += 2;  /* current directory */
-    if (!(p = ret = RtlAllocateHeap( GetProcessHeap(), 0, path_len + len * sizeof(WCHAR) )))
+    len += 2;  /* current directory */
+    if (!(ret = RtlAllocateHeap( GetProcessHeap(), 0, path_len + len * sizeof(WCHAR) )))
         return STATUS_NO_MEMORY;
-
-    p = append_path( p, module, mod_end - module );
-    if (dll_dir) p = append_path( p, dll_dir, -1 );
-    else if (!safe_mode) p = append_path( p, dotW, -1 );
-    p = append_path( p, system_path, -1 );
-    if (!dll_dir && safe_mode) p = append_path( p, dotW, -1 );
-
-    value.Buffer = p;
+    memcpy( ret, module, (mod_end - module) * sizeof(WCHAR) );
+    p = ret + (mod_end - module);
+    if (p > ret) *p++ = ';';
+    *p = 0;
+    if (!safe_mode) strcatW( ret, dotW );
+    strcatW( ret, system_path );
+    if (safe_mode) strcatW( ret, dotW );
+
+    value.Buffer = ret + strlenW(ret);
     value.MaximumLength = path_len;
 
     while (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
@@ -2183,69 +2142,6 @@ static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_m
 }
 
 
-/******************************************************************
- *		get_dll_load_path_search_flags
- */
-static NTSTATUS get_dll_load_path_search_flags( LPCWSTR module, DWORD flags, WCHAR **path )
-{
-    const WCHAR *image = NULL, *mod_end, *image_end;
-    struct dll_dir_entry *dir;
-    WCHAR *p, *ret;
-    int len = 1;
-
-    if (flags & LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)
-        flags |= (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
-                  LOAD_LIBRARY_SEARCH_USER_DIRS |
-                  LOAD_LIBRARY_SEARCH_SYSTEM32);
-
-    if (flags & LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR)
-    {
-        DWORD type = RtlDetermineDosPathNameType_U( module );
-        if (type != ABSOLUTE_DRIVE_PATH && type != ABSOLUTE_PATH)
-            return STATUS_INVALID_PARAMETER;
-        mod_end = get_module_path_end( module );
-        len += (mod_end - module) + 1;
-    }
-    else module = NULL;
-
-    if (flags & LOAD_LIBRARY_SEARCH_APPLICATION_DIR)
-    {
-        image = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-        image_end = get_module_path_end( image );
-        len += (image_end - image) + 1;
-    }
-
-    if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
-    {
-        LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
-            len += strlenW( dir->dir + 4 /* \??\ */ ) + 1;
-        if (dll_directory.Length) len += dll_directory.Length / sizeof(WCHAR) + 1;
-    }
-
-    if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) len += strlenW( system_dir );
-
-    if ((p = ret = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
-    {
-        if (module) p = append_path( p, module, mod_end - module );
-        if (image) p = append_path( p, image, image_end - image );
-        if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
-        {
-            LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
-                p = append_path( p, dir->dir + 4 /* \??\ */, -1 );
-            p = append_path( p, dll_directory.Buffer, dll_directory.Length / sizeof(WCHAR) );
-        }
-        if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) strcpyW( p, system_dir );
-        else
-        {
-            if (p > ret) p--;
-            *p = 0;
-        }
-    }
-    *path = ret;
-    return STATUS_SUCCESS;
-}
-
-
 /***********************************************************************
  *	open_dll_file
  *
@@ -3926,7 +3822,6 @@ static void load_global_options(void)
                                      'S','e','s','s','i','o','n',' ','M','a','n','a','g','e','r',0};
     static const WCHAR globalflagW[] = {'G','l','o','b','a','l','F','l','a','g',0};
     static const WCHAR safesearchW[] = {'S','a','f','e','P','r','o','c','e','s','s','S','e','a','r','c','h','M','o','d','e',0};
-    static const WCHAR safedllmodeW[] = {'S','a','f','e','D','l','l','S','e','a','r','c','h','M','o','d','e',0};
     static const WCHAR critsectW[] = {'C','r','i','t','i','c','a','l','S','e','c','t','i','o','n','T','i','m','e','o','u','t',0};
     static const WCHAR heapresW[] = {'H','e','a','p','S','e','g','m','e','n','t','R','e','s','e','r','v','e',0};
     static const WCHAR heapcommitW[] = {'H','e','a','p','S','e','g','m','e','n','t','C','o','m','m','i','t',0};
@@ -3950,7 +3845,6 @@ static void load_global_options(void)
 
     query_dword_option( hkey, globalflagW, &NtCurrentTeb()->Peb->NtGlobalFlag );
     query_dword_option( hkey, safesearchW, &path_safe_mode );
-    query_dword_option( hkey, safedllmodeW, &dll_safe_mode );
 
     if (!query_dword_option( hkey, critsectW, &value ))
         NtCurrentTeb()->Peb->CriticalSectionTimeout.QuadPart = (ULONGLONG)value * -10000000;
@@ -4103,124 +3997,6 @@ NTSTATUS WINAPI LdrSetDllDirectory( const UNICODE_STRING *dir )
 }
 
 
-/****************************************************************************
- *		LdrAddDllDirectory  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrAddDllDirectory( const UNICODE_STRING *dir, void **cookie )
-{
-    FILE_BASIC_INFORMATION info;
-    UNICODE_STRING nt_name;
-    NTSTATUS status;
-    OBJECT_ATTRIBUTES attr;
-    DWORD len;
-    struct dll_dir_entry *ptr;
-    DOS_PATHNAME_TYPE type = RtlDetermineDosPathNameType_U( dir->Buffer );
-
-    if (type != ABSOLUTE_PATH && type != ABSOLUTE_DRIVE_PATH)
-        return STATUS_INVALID_PARAMETER;
-
-    status = RtlDosPathNameToNtPathName_U_WithStatus( dir->Buffer, &nt_name, NULL, NULL );
-    if (status) return status;
-    len = nt_name.Length / sizeof(WCHAR);
-    if (!(ptr = RtlAllocateHeap( GetProcessHeap(), 0, offsetof(struct dll_dir_entry, dir[++len] ))))
-        return STATUS_NO_MEMORY;
-    memcpy( ptr->dir, nt_name.Buffer, len * sizeof(WCHAR) );
-
-    attr.Length = sizeof(attr);
-    attr.RootDirectory = 0;
-    attr.Attributes = OBJ_CASE_INSENSITIVE;
-    attr.ObjectName = &nt_name;
-    attr.SecurityDescriptor = NULL;
-    attr.SecurityQualityOfService = NULL;
-    status = NtQueryAttributesFile( &attr, &info );
-    RtlFreeUnicodeString( &nt_name );
-
-    if (!status)
-    {
-        TRACE( "%s\n", debugstr_w( ptr->dir ));
-        RtlEnterCriticalSection( &dlldir_section );
-        list_add_head( &dll_dir_list, &ptr->entry );
-        RtlLeaveCriticalSection( &dlldir_section );
-        *cookie = ptr;
-    }
-    else RtlFreeHeap( GetProcessHeap(), 0, ptr );
-    return status;
-}
-
-
-/****************************************************************************
- *		LdrRemoveDllDirectory  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrRemoveDllDirectory( void *cookie )
-{
-    struct dll_dir_entry *ptr = cookie;
-
-    TRACE( "%s\n", debugstr_w( ptr->dir ));
-
-    RtlEnterCriticalSection( &dlldir_section );
-    list_remove( &ptr->entry );
-    RtlFreeHeap( GetProcessHeap(), 0, ptr );
-    RtlLeaveCriticalSection( &dlldir_section );
-    return STATUS_SUCCESS;
-}
-
-
-/*************************************************************************
- *		LdrSetDefaultDllDirectories  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrSetDefaultDllDirectories( ULONG flags )
-{
-    /* LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR doesn't make sense in default dirs */
-    const ULONG load_library_search_flags = (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
-                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
-                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
-                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
-
-    if (!flags || (flags & ~load_library_search_flags)) return STATUS_INVALID_PARAMETER;
-    default_search_flags = flags;
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************
- *		LdrGetDllPath  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrGetDllPath( PCWSTR module, ULONG flags, PWSTR *path, PWSTR *unknown )
-{
-    NTSTATUS status;
-    const ULONG load_library_search_flags = (LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR |
-                                             LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
-                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
-                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
-                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
-
-    if (flags & LOAD_WITH_ALTERED_SEARCH_PATH)
-    {
-        if (flags & load_library_search_flags) return STATUS_INVALID_PARAMETER;
-        if (default_search_flags) flags |= default_search_flags | LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR;
-    }
-    else if (!(flags & load_library_search_flags)) flags |= default_search_flags;
-
-    RtlEnterCriticalSection( &dlldir_section );
-
-    if (flags & load_library_search_flags)
-    {
-        status = get_dll_load_path_search_flags( module, flags, path );
-    }
-    else
-    {
-        const WCHAR *dlldir = dll_directory.Length ? dll_directory.Buffer : NULL;
-        if (!(flags & LOAD_WITH_ALTERED_SEARCH_PATH))
-            module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-        status = get_dll_load_path( module, dlldir, dll_safe_mode, path );
-    }
-
-    RtlLeaveCriticalSection( &dlldir_section );
-    *unknown = NULL;
-    return status;
-}
-
-
 /*************************************************************************
  *		RtlSetSearchPathMode (NTDLL.@)
  */
@@ -4253,38 +4029,13 @@ NTSTATUS WINAPI RtlSetSearchPathMode( ULONG flags )
 }
 
 
-/******************************************************************
- *           RtlGetExePath   (NTDLL.@)
- */
-NTSTATUS WINAPI RtlGetExePath( PCWSTR name, PWSTR *path )
-{
-    static const WCHAR emptyW[1];
-    const WCHAR *dlldir = dotW;
-    const WCHAR *module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-
-    /* same check as NeedCurrentDirectoryForExePathW */
-    if (!strchrW( name, '\\' ))
-    {
-        static const WCHAR env_name[] = {'N','o','D','e','f','a','u','l','t','C','u','r','r','e','n','t',
-                                         'D','i','r','e','c','t','o','r','y','I','n',
-                                         'E','x','e','P','a','t','h',0};
-        UNICODE_STRING name, value = { 0 };
-
-        RtlInitUnicodeString( &name, env_name );
-        if (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) != STATUS_VARIABLE_NOT_FOUND)
-            dlldir = emptyW;
-    }
-    return get_dll_load_path( module, dlldir, FALSE, path );
-}
-
-
 /******************************************************************
  *           RtlGetSearchPath   (NTDLL.@)
  */
 NTSTATUS WINAPI RtlGetSearchPath( PWSTR *path )
 {
-    const WCHAR *module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-    return get_dll_load_path( module, NULL, path_safe_mode, path );
+    WCHAR *module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    return get_dll_load_path( module, path_safe_mode, path );
 }
 
 
diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index fd51312e8a..fe183a6074 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -71,7 +71,6 @@
 @ stub KiUserExceptionDispatcher
 # @ stub LdrAccessOutOfProcessResource
 @ stdcall LdrAccessResource(long ptr ptr ptr)
-@ stdcall LdrAddDllDirectory(ptr ptr)
 @ stdcall LdrAddRefDll(long ptr)
 # @ stub LdrAlternateResourcesEnabled
 # @ stub LdrCreateOutOfProcessImage
@@ -85,10 +84,9 @@
 # @ stub LdrFindResourceEx_U
 @ stdcall LdrFindResource_U(long ptr long ptr)
 @ stub LdrFlushAlternateResourceModules
-@ stdcall LdrGetDllDirectory(ptr)
 @ stdcall LdrGetDllHandle(wstr long ptr ptr)
 # @ stub LdrGetDllHandleEx
-@ stdcall LdrGetDllPath(wstr long ptr ptr)
+@ stdcall LdrGetDllDirectory(ptr)
 @ stdcall LdrGetProcedureAddress(ptr ptr long ptr)
 # @ stub LdrHotPatchRoutine
 @ stub LdrInitShimEngineDynamic
@@ -100,10 +98,8 @@
 @ stdcall LdrQueryImageFileExecutionOptions(ptr wstr long ptr long ptr)
 @ stdcall LdrQueryProcessModuleInformation(ptr long ptr)
 @ stdcall LdrRegisterDllNotification(long ptr ptr ptr)
-@ stdcall LdrRemoveDllDirectory(ptr)
 @ stdcall LdrResolveDelayLoadedAPI(ptr ptr ptr ptr ptr long)
 @ stub LdrSetAppCompatDllRedirectionCallback
-@ stdcall LdrSetDefaultDllDirectories(long)
 @ stdcall LdrSetDllDirectory(ptr)
 @ stub LdrSetDllManifestProber
 @ stdcall LdrShutdownProcess()
@@ -687,7 +683,6 @@
 @ stdcall RtlGetDaclSecurityDescriptor(ptr ptr ptr ptr)
 @ stub RtlGetElementGenericTable
 # @ stub RtlGetElementGenericTableAvl
-@ stdcall RtlGetExePath(wstr ptr)
 # @ stub RtlGetFirstRange
 @ stdcall RtlGetFrame()
 @ stdcall RtlGetFullPathName_U(wstr long ptr ptr)
diff --git a/include/winternl.h b/include/winternl.h
index 16df963770..cb0172c366 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -2309,7 +2309,6 @@ NTSYSAPI NTSTATUS  WINAPI DbgUiIssueRemoteBreakin(HANDLE);
 NTSYSAPI void      WINAPI DbgUiRemoteBreakin(void*);
 NTSYSAPI void      WINAPI DbgUserBreakPoint(void);
 NTSYSAPI NTSTATUS  WINAPI LdrAccessResource(HMODULE,const IMAGE_RESOURCE_DATA_ENTRY*,void**,PULONG);
-NTSYSAPI NTSTATUS  WINAPI LdrAddDllDirectory(const UNICODE_STRING*,void**);
 NTSYSAPI NTSTATUS  WINAPI LdrAddRefDll(ULONG,HMODULE);
 NTSYSAPI NTSTATUS  WINAPI LdrDisableThreadCalloutsForDll(HMODULE);
 NTSYSAPI NTSTATUS  WINAPI LdrFindEntryForAddress(const void*, PLDR_MODULE*);
@@ -2317,15 +2316,12 @@ NTSYSAPI NTSTATUS  WINAPI LdrFindResourceDirectory_U(HMODULE,const LDR_RESOURCE_
 NTSYSAPI NTSTATUS  WINAPI LdrFindResource_U(HMODULE,const LDR_RESOURCE_INFO*,ULONG,const IMAGE_RESOURCE_DATA_ENTRY**);
 NTSYSAPI NTSTATUS  WINAPI LdrGetDllDirectory(UNICODE_STRING*);
 NTSYSAPI NTSTATUS  WINAPI LdrGetDllHandle(LPCWSTR, ULONG, const UNICODE_STRING*, HMODULE*);
-NTSYSAPI NTSTATUS  WINAPI LdrGetDllPath(PCWSTR,ULONG,PWSTR*,PWSTR*);
 NTSYSAPI NTSTATUS  WINAPI LdrGetProcedureAddress(HMODULE, const ANSI_STRING*, ULONG, void**);
 NTSYSAPI NTSTATUS  WINAPI LdrLoadDll(LPCWSTR, DWORD, const UNICODE_STRING*, HMODULE*);
 NTSYSAPI NTSTATUS  WINAPI LdrLockLoaderLock(ULONG,ULONG*,ULONG_PTR*);
 IMAGE_BASE_RELOCATION * WINAPI LdrProcessRelocationBlock(void*,UINT,USHORT*,INT_PTR);
 NTSYSAPI NTSTATUS  WINAPI LdrQueryImageFileExecutionOptions(const UNICODE_STRING*,LPCWSTR,ULONG,void*,ULONG,ULONG*);
 NTSYSAPI NTSTATUS  WINAPI LdrQueryProcessModuleInformation(SYSTEM_MODULE_INFORMATION*, ULONG, ULONG*);
-NTSYSAPI NTSTATUS  WINAPI LdrRemoveDllDirectory(void*);
-NTSYSAPI NTSTATUS  WINAPI LdrSetDefaultDllDirectories(ULONG);
 NTSYSAPI NTSTATUS  WINAPI LdrSetDllDirectory(const UNICODE_STRING*);
 NTSYSAPI void      WINAPI LdrShutdownProcess(void);
 NTSYSAPI void      WINAPI LdrShutdownThread(void);
@@ -2724,7 +2720,6 @@ NTSYSAPI NTSTATUS  WINAPI RtlGetControlSecurityDescriptor(PSECURITY_DESCRIPTOR,
 NTSYSAPI ULONG     WINAPI RtlGetCurrentDirectory_U(ULONG, LPWSTR);
 NTSYSAPI PEB *     WINAPI RtlGetCurrentPeb(void);
 NTSYSAPI NTSTATUS  WINAPI RtlGetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR,PBOOLEAN,PACL *,PBOOLEAN);
-NTSYSAPI NTSTATUS  WINAPI RtlGetExePath(PCWSTR,PWSTR*);
 NTSYSAPI TEB_ACTIVE_FRAME * WINAPI RtlGetFrame(void);
 NTSYSAPI ULONG     WINAPI RtlGetFullPathName_U(PCWSTR,ULONG,PWSTR,PWSTR*);
 NTSYSAPI NTSTATUS  WINAPI RtlGetGroupSecurityDescriptor(PSECURITY_DESCRIPTOR,PSID *,PBOOLEAN);

From 743d5f207440ef2dc05ee58b72ad0d61d05eb4c0 Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Fri, 27 Sep 2019 10:40:58 +0200
Subject: Revert "kernel32: Move delay-load functions to kernelbase."

This reverts commit 0f5538b9e349fe7b5924b8c0b84ca8a917962701.

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index e051ac0e7a..eb5e0ef5b3 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -356,7 +356,7 @@
 @ stdcall DecodeSystemPointer(ptr) ntdll.RtlDecodeSystemPointer
 @ stdcall DefineDosDeviceA(long str str)
 @ stdcall DefineDosDeviceW(long wstr wstr)
-@ stdcall -import DelayLoadFailureHook(str str)
+@ stdcall DelayLoadFailureHook(str str)
 @ stdcall DeleteAtom(long)
 # @ stub DeleteBoundaryDescriptor
 @ stdcall DeleteCriticalSection(ptr) ntdll.RtlDeleteCriticalSection
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index ad6956d1ce..24fb9e33f5 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -1018,6 +1018,23 @@ FARPROC WINAPI GetProcAddress( HMODULE hModule, LPCSTR function )
     return get_proc_address_wrapper( hModule, function );
 }
 
+/***********************************************************************
+ *           DelayLoadFailureHook  (KERNEL32.@)
+ */
+FARPROC WINAPI DelayLoadFailureHook( LPCSTR name, LPCSTR function )
+{
+    ULONG_PTR args[2];
+
+    if ((ULONG_PTR)function >> 16)
+        ERR( "failed to delay load %s.%s\n", name, function );
+    else
+        ERR( "failed to delay load %s.%u\n", name, LOWORD(function) );
+    args[0] = (ULONG_PTR)name;
+    args[1] = (ULONG_PTR)function;
+    RaiseException( EXCEPTION_WINE_STUB, EH_NONCONTINUABLE, 2, args );
+    return NULL;
+}
+
 typedef struct _PEB32
 {
     BOOLEAN InheritedAddressSpace;
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index b582b3d092..eeb46952ea 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -244,7 +244,7 @@
 # @ stub DecodeRemotePointer
 @ stdcall DecodeSystemPointer(ptr) ntdll.RtlDecodeSystemPointer
 @ stdcall DefineDosDeviceW(long wstr wstr) kernel32.DefineDosDeviceW
-@ stdcall DelayLoadFailureHook(str str)
+@ stdcall DelayLoadFailureHook(str str) kernel32.DelayLoadFailureHook
 # @ stub DelayLoadFailureHookLookup
 @ stdcall DeleteAce(ptr long)
 # @ stub DeleteBoundaryDescriptor
@@ -1343,7 +1343,7 @@
 @ stdcall ResetEvent(long)
 # @ stub ResetState
 @ stdcall ResetWriteWatch(ptr long)
-@ stdcall -import ResolveDelayLoadedAPI(ptr ptr ptr ptr ptr long) LdrResolveDelayLoadedAPI
+@ stdcall ResolveDelayLoadedAPI(ptr ptr ptr ptr ptr long) kernel32.ResolveDelayLoadedAPI
 # @ stub ResolveDelayLoadsFromDll
 @ stdcall ResolveLocaleName(wstr ptr long)
 @ stdcall RestoreLastError(long) ntdll.RtlRestoreLastWin32Error
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 9d0486d8a6..34c8add910 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -42,24 +42,6 @@ WINE_DEFAULT_DEBUG_CHANNEL(module);
  ***********************************************************************/
 
 
-/***********************************************************************
- *	DelayLoadFailureHook   (kernelbase.@)
- */
-FARPROC WINAPI DECLSPEC_HOTPATCH DelayLoadFailureHook( LPCSTR name, LPCSTR function )
-{
-    ULONG_PTR args[2];
-
-    if ((ULONG_PTR)function >> 16)
-        ERR( "failed to delay load %s.%s\n", name, function );
-    else
-        ERR( "failed to delay load %s.%u\n", name, LOWORD(function) );
-    args[0] = (ULONG_PTR)name;
-    args[1] = (ULONG_PTR)function;
-    RaiseException( EXCEPTION_WINE_STUB, EH_NONCONTINUABLE, 2, args );
-    return NULL;
-}
-
-
 /****************************************************************************
  *	DisableThreadLibraryCalls   (kernelbase.@)
  */


From 8b947e5cc131821ec51434ee2446682a707e02cb Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Tue, 13 Aug 2019 05:16:50 +0200
Subject: Revert "kernel32: Move some module functions to kernelbase."

This reverts commit 05d00276c627753487c571c30fddfc56c02ad37e.

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 016c3022dc..bb496425aa 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -377,7 +377,7 @@
 @ stdcall DeleteVolumeMountPointW(wstr)
 @ stdcall -arch=x86_64 DequeueUmsCompletionListItems(ptr long ptr)
 @ stdcall DeviceIoControl(long long ptr long ptr long ptr ptr)
-@ stdcall -import DisableThreadLibraryCalls(long)
+@ stdcall DisableThreadLibraryCalls(long)
 @ stdcall -import DisconnectNamedPipe(long)
 @ stdcall DnsHostnameToComputerNameA (str ptr ptr)
 @ stdcall DnsHostnameToComputerNameW (wstr ptr ptr)
@@ -718,12 +718,12 @@
 @ stdcall GetMailslotInfo(long ptr ptr ptr ptr)
 @ stdcall GetMaximumProcessorCount(long)
 # @ stub GetMaximumProcessorGroupCount
-@ stdcall -import GetModuleFileNameA(long ptr long)
-@ stdcall -import GetModuleFileNameW(long ptr long)
-@ stdcall -import GetModuleHandleA(str)
-@ stdcall -import GetModuleHandleExA(long ptr ptr)
-@ stdcall -import GetModuleHandleExW(long ptr ptr)
-@ stdcall -import GetModuleHandleW(wstr)
+@ stdcall GetModuleFileNameA(long ptr long)
+@ stdcall GetModuleFileNameW(long ptr long)
+@ stdcall GetModuleHandleA(str)
+@ stdcall GetModuleHandleExA(long ptr ptr)
+@ stdcall GetModuleHandleExW(long ptr ptr)
+@ stdcall GetModuleHandleW(wstr)
 # @ stub GetNamedPipeAttribute
 # @ stub GetNamedPipeClientComputerNameA
 # @ stub GetNamedPipeClientComputerNameW
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index acfc365200..386a7c2239 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -233,6 +233,33 @@ BOOL WINAPI SetDefaultDllDirectories( DWORD flags )
 }
 
 
+/****************************************************************************
+ *              DisableThreadLibraryCalls (KERNEL32.@)
+ *
+ * Inform the module loader that thread notifications are not required for a dll.
+ *
+ * PARAMS
+ *  hModule [I] Module handle to skip calls for
+ *
+ * RETURNS
+ *  Success: TRUE. Thread attach and detach notifications will not be sent
+ *           to hModule.
+ *  Failure: FALSE. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ *  This is typically called from the dll entry point of a dll during process
+ *  attachment, for dlls that do not need to process thread notifications.
+ */
+BOOL WINAPI DisableThreadLibraryCalls( HMODULE hModule )
+{
+    NTSTATUS    nts = LdrDisableThreadCalloutsForDll( hModule );
+    if (nts == STATUS_SUCCESS) return TRUE;
+
+    SetLastError( RtlNtStatusToDosError( nts ) );
+    return FALSE;
+}
+
+
 /***********************************************************************
  *             GetBinaryTypeW                     [KERNEL32.@]
  *
@@ -375,6 +402,194 @@ BOOL WINAPI GetBinaryTypeA( LPCSTR lpApplicationName, LPDWORD lpBinaryType )
     return FALSE;
 }
 
+/***********************************************************************
+ *              GetModuleHandleExA         (KERNEL32.@)
+ */
+BOOL WINAPI GetModuleHandleExA( DWORD flags, LPCSTR name, HMODULE *module )
+{
+    WCHAR *nameW;
+
+    if (!name || (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS))
+        return GetModuleHandleExW( flags, (LPCWSTR)name, module );
+
+    if (!(nameW = FILE_name_AtoW( name, FALSE ))) return FALSE;
+    return GetModuleHandleExW( flags, nameW, module );
+}
+
+/***********************************************************************
+ *              GetModuleHandleExW         (KERNEL32.@)
+ */
+BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+    HMODULE ret;
+    ULONG_PTR magic;
+    BOOL lock;
+
+    if (!module)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
+
+    /* if we are messing with the refcount, grab the loader lock */
+    lock = (flags & GET_MODULE_HANDLE_EX_FLAG_PIN) || !(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT);
+    if (lock)
+        LdrLockLoaderLock( 0, NULL, &magic );
+
+    if (!name)
+    {
+        ret = NtCurrentTeb()->Peb->ImageBaseAddress;
+    }
+    else if (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS)
+    {
+        void *dummy;
+        if (!(ret = RtlPcToFileHeader( (void *)name, &dummy ))) status = STATUS_DLL_NOT_FOUND;
+    }
+    else
+    {
+        UNICODE_STRING wstr;
+        RtlInitUnicodeString( &wstr, name );
+        status = LdrGetDllHandle( NULL, 0, &wstr, &ret );
+    }
+
+    if (status == STATUS_SUCCESS)
+    {
+        if (flags & GET_MODULE_HANDLE_EX_FLAG_PIN)
+            LdrAddRefDll( LDR_ADDREF_DLL_PIN, ret );
+        else if (!(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT))
+            LdrAddRefDll( 0, ret );
+    }
+    else SetLastError( RtlNtStatusToDosError( status ) );
+
+    if (lock)
+        LdrUnlockLoaderLock( 0, magic );
+
+    if (status == STATUS_SUCCESS) *module = ret;
+    else *module = NULL;
+
+    return (status == STATUS_SUCCESS);
+}
+
+/***********************************************************************
+ *              GetModuleHandleA         (KERNEL32.@)
+ *
+ * Get the handle of a dll loaded into the process address space.
+ *
+ * PARAMS
+ *  module [I] Name of the dll
+ *
+ * RETURNS
+ *  Success: A handle to the loaded dll.
+ *  Failure: A NULL handle. Use GetLastError() to determine the cause.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleA(LPCSTR module)
+{
+    HMODULE ret;
+
+    GetModuleHandleExA( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
+    return ret;
+}
+
+/***********************************************************************
+ *		GetModuleHandleW (KERNEL32.@)
+ *
+ * Unicode version of GetModuleHandleA.
+ */
+HMODULE WINAPI GetModuleHandleW(LPCWSTR module)
+{
+    HMODULE ret;
+
+    GetModuleHandleExW( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
+    return ret;
+}
+
+
+/***********************************************************************
+ *              GetModuleFileNameA      (KERNEL32.@)
+ *
+ * Get the file name of a loaded module from its handle.
+ *
+ * RETURNS
+ *  Success: The length of the file name, excluding the terminating NUL.
+ *  Failure: 0. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ *  This function always returns the long path of hModule
+ *  The function doesn't write a terminating '\0' if the buffer is too 
+ *  small.
+ */
+DWORD WINAPI GetModuleFileNameA(
+	HMODULE hModule,	/* [in] Module handle (32 bit) */
+	LPSTR lpFileName,	/* [out] Destination for file name */
+        DWORD size )		/* [in] Size of lpFileName in characters */
+{
+    LPWSTR filenameW = HeapAlloc( GetProcessHeap(), 0, size * sizeof(WCHAR) );
+    DWORD len;
+
+    if (!filenameW)
+    {
+        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
+        return 0;
+    }
+    if ((len = GetModuleFileNameW( hModule, filenameW, size )))
+    {
+    	len = FILE_name_WtoA( filenameW, len, lpFileName, size );
+        if (len < size)
+            lpFileName[len] = '\0';
+        else
+            SetLastError( ERROR_INSUFFICIENT_BUFFER );
+    }
+    HeapFree( GetProcessHeap(), 0, filenameW );
+    return len;
+}
+
+/***********************************************************************
+ *              GetModuleFileNameW      (KERNEL32.@)
+ *
+ * Unicode version of GetModuleFileNameA.
+ */
+DWORD WINAPI GetModuleFileNameW( HMODULE hModule, LPWSTR lpFileName, DWORD size )
+{
+    ULONG len = 0;
+    ULONG_PTR magic;
+    LDR_MODULE *pldr;
+    NTSTATUS nts;
+    WIN16_SUBSYSTEM_TIB *win16_tib;
+
+    if (!hModule && ((win16_tib = NtCurrentTeb()->Tib.SubSystemTib)) && win16_tib->exe_name)
+    {
+        len = min(size, win16_tib->exe_name->Length / sizeof(WCHAR));
+        memcpy( lpFileName, win16_tib->exe_name->Buffer, len * sizeof(WCHAR) );
+        if (len < size) lpFileName[len] = '\0';
+        goto done;
+    }
+
+    LdrLockLoaderLock( 0, NULL, &magic );
+
+    if (!hModule) hModule = NtCurrentTeb()->Peb->ImageBaseAddress;
+    nts = LdrFindEntryForAddress( hModule, &pldr );
+    if (nts == STATUS_SUCCESS)
+    {
+        len = min(size, pldr->FullDllName.Length / sizeof(WCHAR));
+        memcpy(lpFileName, pldr->FullDllName.Buffer, len * sizeof(WCHAR));
+        if (len < size)
+        {
+            lpFileName[len] = '\0';
+            SetLastError( 0 );
+        }
+        else
+            SetLastError( ERROR_INSUFFICIENT_BUFFER );
+    }
+    else SetLastError( RtlNtStatusToDosError( nts ) );
+
+    LdrUnlockLoaderLock( 0, magic );
+done:
+    TRACE( "%s\n", debugstr_wn(lpFileName, len) );
+    return len;
+}
+
+
 /***********************************************************************
  *           get_dll_system_path
  */
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 4bb2b55cde..1b8c4cc236 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -263,7 +263,7 @@
 @ stdcall DestroyPrivateObjectSecurity(ptr)
 @ stdcall DeviceIoControl(long long ptr long ptr long ptr ptr) kernel32.DeviceIoControl
 @ stdcall DisablePredefinedHandleTableInternal(long)
-@ stdcall DisableThreadLibraryCalls(long)
+@ stdcall DisableThreadLibraryCalls(long) kernel32.DisableThreadLibraryCalls
 @ stdcall DisassociateCurrentThreadFromCallback(ptr) ntdll.TpDisassociateCallback
 # @ stub DiscardVirtualMemory
 @ stdcall DisconnectNamedPipe(long)
@@ -556,14 +556,14 @@
 # @ stub GetMemoryErrorHandlingCapabilities
 # @ stub GetModuleBaseNameA
 # @ stub GetModuleBaseNameW
-@ stdcall GetModuleFileNameA(long ptr long)
+@ stdcall GetModuleFileNameA(long ptr long) kernel32.GetModuleFileNameA
 # @ stub GetModuleFileNameExA
 # @ stub GetModuleFileNameExW
-@ stdcall GetModuleFileNameW(long ptr long)
-@ stdcall GetModuleHandleA(str)
-@ stdcall GetModuleHandleExA(long ptr ptr)
-@ stdcall GetModuleHandleExW(long ptr ptr)
-@ stdcall GetModuleHandleW(wstr)
+@ stdcall GetModuleFileNameW(long ptr long) kernel32.GetModuleFileNameW
+@ stdcall GetModuleHandleA(str) kernel32.GetModuleHandleA
+@ stdcall GetModuleHandleExA(long ptr ptr) kernel32.GetModuleHandleExA
+@ stdcall GetModuleHandleExW(long ptr ptr) kernel32.GetModuleHandleExW
+@ stdcall GetModuleHandleW(wstr) kernel32.GetModuleHandleW
 # @ stub GetModuleInformation
 @ stub GetNLSVersion
 @ stub GetNLSVersionEx
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 34c8add910..91daa4ec14 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -37,176 +37,6 @@
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
 
-/***********************************************************************
- * Modules
- ***********************************************************************/
-
-
-/****************************************************************************
- *	DisableThreadLibraryCalls   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH DisableThreadLibraryCalls( HMODULE module )
-{
-    return set_ntstatus( LdrDisableThreadCalloutsForDll( module ));
-}
-
-
-/***********************************************************************
- *	GetModuleFileNameA   (kernelbase.@)
- */
-DWORD WINAPI DECLSPEC_HOTPATCH GetModuleFileNameA( HMODULE module, LPSTR filename, DWORD size )
-{
-    LPWSTR filenameW = HeapAlloc( GetProcessHeap(), 0, size * sizeof(WCHAR) );
-    DWORD len;
-
-    if (!filenameW)
-    {
-        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
-        return 0;
-    }
-    if ((len = GetModuleFileNameW( module, filenameW, size )))
-    {
-    	len = file_name_WtoA( filenameW, len, filename, size );
-        if (len < size)
-            filename[len] = 0;
-        else
-            SetLastError( ERROR_INSUFFICIENT_BUFFER );
-    }
-    HeapFree( GetProcessHeap(), 0, filenameW );
-    return len;
-}
-
-
-/***********************************************************************
- *	GetModuleFileNameW   (kernelbase.@)
- */
-DWORD WINAPI DECLSPEC_HOTPATCH GetModuleFileNameW( HMODULE module, LPWSTR filename, DWORD size )
-{
-    ULONG len = 0;
-    ULONG_PTR magic;
-    LDR_MODULE *pldr;
-    WIN16_SUBSYSTEM_TIB *win16_tib;
-
-    if (!module && ((win16_tib = NtCurrentTeb()->Tib.SubSystemTib)) && win16_tib->exe_name)
-    {
-        len = min( size, win16_tib->exe_name->Length / sizeof(WCHAR) );
-        memcpy( filename, win16_tib->exe_name->Buffer, len * sizeof(WCHAR) );
-        if (len < size) filename[len] = 0;
-        goto done;
-    }
-
-    LdrLockLoaderLock( 0, NULL, &magic );
-
-    if (!module) module = NtCurrentTeb()->Peb->ImageBaseAddress;
-    if (set_ntstatus( LdrFindEntryForAddress( module, &pldr )))
-    {
-        len = min( size, pldr->FullDllName.Length / sizeof(WCHAR) );
-        memcpy( filename, pldr->FullDllName.Buffer, len * sizeof(WCHAR) );
-        if (len < size)
-        {
-            filename[len] = 0;
-            SetLastError( 0 );
-        }
-        else SetLastError( ERROR_INSUFFICIENT_BUFFER );
-    }
-
-    LdrUnlockLoaderLock( 0, magic );
-done:
-    TRACE( "%s\n", debugstr_wn(filename, len) );
-    return len;
-}
-
-
-/***********************************************************************
- *	GetModuleHandleA   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleA( LPCSTR module )
-{
-    HMODULE ret;
-
-    GetModuleHandleExA( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
-    return ret;
-}
-
-
-/***********************************************************************
- *	GetModuleHandleW   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleW( LPCWSTR module )
-{
-    HMODULE ret;
-
-    GetModuleHandleExW( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
-    return ret;
-}
-
-
-/***********************************************************************
- *	GetModuleHandleExA   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH GetModuleHandleExA( DWORD flags, LPCSTR name, HMODULE *module )
-{
-    WCHAR *nameW;
-
-    if (!name || (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS))
-        return GetModuleHandleExW( flags, (LPCWSTR)name, module );
-
-    if (!(nameW = file_name_AtoW( name, FALSE ))) return FALSE;
-    return GetModuleHandleExW( flags, nameW, module );
-}
-
-
-/***********************************************************************
- *	GetModuleHandleExW   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-    HMODULE ret = NULL;
-    ULONG_PTR magic;
-    BOOL lock;
-
-    if (!module)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return FALSE;
-    }
-
-    /* if we are messing with the refcount, grab the loader lock */
-    lock = (flags & GET_MODULE_HANDLE_EX_FLAG_PIN) || !(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT);
-    if (lock) LdrLockLoaderLock( 0, NULL, &magic );
-
-    if (!name)
-    {
-        ret = NtCurrentTeb()->Peb->ImageBaseAddress;
-    }
-    else if (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS)
-    {
-        void *dummy;
-        if (!(ret = RtlPcToFileHeader( (void *)name, &dummy ))) status = STATUS_DLL_NOT_FOUND;
-    }
-    else
-    {
-        UNICODE_STRING wstr;
-        RtlInitUnicodeString( &wstr, name );
-        status = LdrGetDllHandle( NULL, 0, &wstr, &ret );
-    }
-
-    if (status == STATUS_SUCCESS)
-    {
-        if (flags & GET_MODULE_HANDLE_EX_FLAG_PIN)
-            LdrAddRefDll( LDR_ADDREF_DLL_PIN, ret );
-        else if (!(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT))
-            LdrAddRefDll( 0, ret );
-    }
-
-    if (lock) LdrUnlockLoaderLock( 0, magic );
-
-    *module = ret;
-    return set_ntstatus( status );
-}
-
-
 /***********************************************************************
  * Resources
  ***********************************************************************/
@@ -259,7 +89,7 @@ static NTSTATUS get_res_nameW( LPCWSTR name, UNICODE_STRING *str )
 
 
 /**********************************************************************
- *	EnumResourceLanguagesExA	(kernelbase.@)
+ *	EnumResourceLanguagesExA	(KERNEL32.@)
  */
 BOOL WINAPI DECLSPEC_HOTPATCH EnumResourceLanguagesExA( HMODULE module, LPCSTR type, LPCSTR name,
                                                         ENUMRESLANGPROCA func, LONG_PTR param,
@@ -319,7 +149,7 @@ done:
 
 
 /**********************************************************************
- *	EnumResourceLanguagesExW	(kernelbase.@)
+ *	EnumResourceLanguagesExW	(KERNEL32.@)
  */
 BOOL WINAPI DECLSPEC_HOTPATCH EnumResourceLanguagesExW( HMODULE module, LPCWSTR type, LPCWSTR name,
                                                         ENUMRESLANGPROCW func, LONG_PTR param,


From aa88eb017be4c3615d0f8aab8a2e16769a6568ad Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 27 Dec 2017 13:31:59 -0600
Subject: [PATCH] loader: Set up Steam stuff in the registry

---
 loader/wine.inf.in | 19 ++++++++++++++++---
 1 file changed, 16 insertions(+), 3 deletions(-)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 5767b29887c..75d5f4a7216 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -75,7 +75,8 @@ AddReg=\
     Tapi,\
     Timezones,\
     VersionInfo,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient
 
 [DefaultInstall.ntamd64]
 RegisterDlls=RegisterDllsSection
@@ -103,7 +104,8 @@ AddReg=\
     Tapi,\
     Timezones,\
     VersionInfo.ntamd64,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient.ntamd64
 
 [Wow64Install]
 RegisterDlls=RegisterDllsSection
@@ -118,7 +120,8 @@ AddReg=\
     Misc,\
     Tapi,\
     VersionInfo.ntamd64,\
-    LicenseInformation
+    LicenseInformation, \
+    SteamClient.ntamd64
 
 [DefaultInstall.Services]
 AddService=BITS,0,BITSService
@@ -3750,6 +3750,16 @@ HKLM,Software\Wine\LicenseInformation,"Shell-InBoxGames-Solitaire-EnableGame",0x
 HKLM,Software\Wine\LicenseInformation,"Shell-InBoxGames-SpiderSolitaire-EnableGame",0x10001,0x00000001
 HKLM,Software\Wine\LicenseInformation,"Shell-PremiumInBoxGames-Chess-EnableGame",0x10001,0x00000001
 
+[SteamClient]
+HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16422%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16422%\Steam"
+
+[SteamClient.ntamd64]
+HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"
+
 [DestinationDirs]
 l_intl_section = 11
 inf_section = 17

From bc614834ee153ce33449c06e697b4a30748e9257 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 27 Apr 2017 13:25:04 -0500
Subject: [PATCH] HACK kernelbase: Substitute the current pid for the Steam
 client pid

---
 dlls/kernelbase/process.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 85e0042024c..9c957f02c06 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -220,6 +220,22 @@ HANDLE WINAPI DECLSPEC_HOTPATCH OpenProcess( DWORD access, BOOL inherit, DWORD id )
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
 
+    if(id == 0xfffe)
+        /* STEAMOS HACK:
+         * On Windows, the Steam client puts its process ID into the registry
+         * at:
+         *
+         *   [HKCU\Software\Valve\Steam\ActiveProcess]
+         *   PID=dword:00000008
+         *
+         * Games get that pid from the registry and then query it with
+         * OpenProcess to ensure Steam is running. Since we aren't running the
+         * Windows Steam in Wine, instead we hack this magic number into the
+         * registry and then substitute the game's process itself in its place
+         * so it can query a valid process.
+         */
+        id = GetCurrentProcessId();
+
     cid.UniqueProcess = ULongToHandle(id);
     cid.UniqueThread  = 0;
 
From a277e32030a31abe90af9d38462f1159bc94b7b0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 11 May 2017 10:50:08 -0500
Subject: [PATCH] HACK: kernel32: Swap requests for steamclient.dll with
 lsteamclient

---
 dlls/kernel32/module.c | 63 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 118829895b7..cf3a0b5ed98 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -76,6 +76,23 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
+static HMODULE steamclient_hmod = NULL;
+static HMODULE lsteamclient_hmod = NULL;
+
+static WCHAR *strcasestrW( const WCHAR *str, const WCHAR *sub )
+{
+    while (*str)
+    {
+        const WCHAR *p1 = str, *p2 = sub;
+        while (*p1 && *p2 && tolowerW(*p1) == tolowerW(*p2)) { p1++; p2++; }
+        if (!*p2) return (WCHAR *)str;
+        str++;
+    }
+    return NULL;
+}
+
 /****************************************************************************
  *              GetDllDirectoryA   (KERNEL32.@)
  */
@@ -710,6 +727,10 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
     else
     {
         UNICODE_STRING wstr;
+        if(steamclient_hmod != NULL && strcasestrW(name, steamclientW)){
+            *module = steamclient_hmod;
+            return TRUE;
+        }
         RtlInitUnicodeString( &wstr, name );
         status = LdrGetDllHandle( NULL, 0, &wstr, &ret );
     }
@@ -818,6 +839,11 @@ DWORD WINAPI GetModuleFileNameW( HMODULE hModule, LPWSTR lpFileName, DWORD size
     NTSTATUS nts;
     WIN16_SUBSYSTEM_TIB *win16_tib;
 
+    if(steamclient_hmod != NULL && hModule == steamclient_hmod){
+        memcpy(lpFileName, steamclient_pathW, sizeof(steamclient_pathW));
+        return sizeof(steamclient_pathW)/sizeof(WCHAR);
+    }
+
     if (!hModule && ((win16_tib = NtCurrentTeb()->Tib.SubSystemTib)) && win16_tib->exe_name)
     {
         len = min(size, win16_tib->exe_name->Length / sizeof(WCHAR));
@@ -1194,6 +1220,7 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     NTSTATUS nts;
     HMODULE hModule;
     WCHAR *load_path;
+    const WCHAR *p;
     const DWORD load_library_search_flags = (LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR |
                                              LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
                                              LOAD_LIBRARY_SEARCH_USER_DIRS |
@@ -1207,6 +1234,36 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     if( flags & unsupported_flags)
         FIXME("unsupported flag(s) used (flags: 0x%08x)\n", flags);
 
+    if((p = strcasestrW(libname->Buffer, steamclientW)) &&
+            (p == libname->Buffer ||
+             *(p - 1) != 'l')){
+
+        if(!lsteamclient_hmod)
+            lsteamclient_hmod = LoadLibraryA("lsteamclient.dll");
+
+        if(!steamclient_hmod){
+            HANDLE f = CreateFileW(steamclient_pathW,
+                    GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                    NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+            if(f != INVALID_HANDLE_VALUE){
+                DWORD sz, readed;
+
+                sz = GetFileSize(f, NULL);
+
+                steamclient_hmod = HeapAlloc(GetProcessHeap(), 0, sz);
+                ReadFile(f, steamclient_hmod, sz, &readed, NULL);
+
+                CloseHandle(f);
+            }else{
+                /* this will fail DRM checks, but otherwise should work */
+                ERR("somehow failed to load steamclient\n");
+                steamclient_hmod = lsteamclient_hmod;
+            }
+        }
+
+        return steamclient_hmod;
+    }
+
     if (flags & load_library_search_flags)
         load_path = get_dll_load_path_search_flags( libname->Buffer, flags );
     else
@@ -1362,6 +1419,9 @@ BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary(HINSTANCE hLibModule)
         return FALSE;
     }
 
+    if(steamclient_hmod != NULL && hLibModule == steamclient_hmod)
+        return TRUE;
+
     if ((ULONG_PTR)hLibModule & 3) /* this is a datafile module */
     {
         if ((ULONG_PTR)hLibModule & 1)
@@ -1410,6 +1470,9 @@ FARPROC get_proc_address( HMODULE hModule, LPCSTR function )
 
     if (!hModule) hModule = NtCurrentTeb()->Peb->ImageBaseAddress;
 
+    if(steamclient_hmod != NULL && hModule == steamclient_hmod)
+        hModule = lsteamclient_hmod;
+
     if ((ULONG_PTR)function >> 16)
     {
         ANSI_STRING     str;

From acda0915ca65ea7e818fbb89bae14894602cf845 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 5 Jun 2017 14:41:28 -0500
Subject: [PATCH] HACK: kernel32: Load hard-coded Steam.dll path if relative
 load fails

Some games (Call of Duty is one example) try to just
LoadLibrary("Steam.dll") with no path. If that fails, it complains
"Failed to find Steam". This works on Windows because Steam sets the
PATH environment variable to include <C:\Program Files\Steam\>, which is
where Steam.dll lives, before launching the game. However, the Linux
Steam obviously doesn't do that. For this reason, we place Steam.dll in
there and this hack loads it correctly for the games.

TODO: is this enough? Should we put that path into PATH like on Windows,
in case it tries to load other binaries?
---
 dlls/kernel32/module.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index cf3a0b5ed98..6ca438d3ae2 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -77,6 +77,8 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
+static const WCHAR full_steamdllW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','S','t','e','a','m','.','d','l','l',0};
 static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
@@ -1302,6 +1304,12 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
     }
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
+
+    if(!hModule && !strcmpiW(libname->Buffer, steamdllW))
+        /* tried and failed to load Steam.dll from PATH. try again
+         * with known-good path */
+        return LoadLibraryW(full_steamdllW);
+
     return hModule;
 }
 
From 183eac81ab4739735c4f49d25c1384d98f17655d Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 9 Jun 2017 10:31:27 -0500
Subject: [PATCH] HACK: kernel32: Return steamclient instead of lsteamclient
 during GetModuleHandleEx

Found a game which passes the result from GetProcAddress to this. Ugh.
---
 dlls/kernel32/module.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 6ca438d3ae2..a1a2b0e100c 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -725,6 +725,8 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
     {
         void *dummy;
         if (!(ret = RtlPcToFileHeader( (void *)name, &dummy ))) status = STATUS_DLL_NOT_FOUND;
+        if(steamclient_hmod != NULL && ret == lsteamclient_hmod)
+            ret = steamclient_hmod;
     }
     else
     {

From 3835eee939a9e8c6a8f29733307a8531053a3616 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 13 Jun 2017 12:35:56 -0500
Subject: [PATCH] HACK: kernel32: Put Steam program files dir into PATH

---
 dlls/kernel32/module.c | 23 +++++++++++++++++------
 1 file changed, 17 insertions(+), 6 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index a1a2b0e100c..ef0295081c8 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -78,7 +78,7 @@ static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
 static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
-static const WCHAR full_steamdllW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','S','t','e','a','m','.','d','l','l',0};
+static const DWORD steamdllW_len = 9;
 static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
@@ -890,12 +890,18 @@ static const WCHAR *get_dll_system_path(void)
 
     if (!cached_path)
     {
+        static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m',0};
+        static const DWORD steamProgramPathW_len = 22;
         WCHAR *p, *path;
-        int len = 1;
+        int len = 2;
 
+        len += steamProgramPathW_len;
         len += 2 * GetSystemDirectoryW( NULL, 0 );
         len += GetWindowsDirectoryW( NULL, 0 );
         p = path = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );
+        strcpyW(p, steamProgramPathW);
+        p += steamProgramPathW_len;
+        *p++ = ';';
         GetSystemDirectoryW( p, path + len - p);
         p += strlenW(p);
         /* if system directory ends in "32" add 16-bit version too */
@@ -1307,10 +1313,15 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
 
-    if(!hModule && !strcmpiW(libname->Buffer, steamdllW))
-        /* tried and failed to load Steam.dll from PATH. try again
-         * with known-good path */
-        return LoadLibraryW(full_steamdllW);
+    if(!hModule){
+        DWORD len = lstrlenW(libname->Buffer);
+        if(len > steamdllW_len &&
+                !strcmpiW(libname->Buffer + len - steamdllW_len, steamdllW)){
+            /* tried and failed to load some path ending in Steam.dll. try
+             * again without hard-coded path */
+            return LoadLibraryW(steamdllW);
+        }
+    }
 
     return hModule;
 }

From a2f9e2806acdd83aa9121baea4a8a908e2a9e909 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 28 Dec 2017 09:43:36 -0600
Subject: [PATCH] kernel32: Support steamclient64

---
 dlls/kernel32/module.c | 11 ++++++++---
 loader/wine.inf.in     |  1 +
 2 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index ef0295081c8..32f9ddf6718 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -76,10 +76,17 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+#if defined(__x86_64__)
+static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t','6','4',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','6','4','.','d','l','l',0};
+#else
 static const WCHAR steamclientW[] = {'s','t','e','a','m','c','l','i','e','n','t',0};
+static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};
+#endif
+static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s',' ','(','x','8','6',')','\\','S','t','e','a','m',0};
+static const DWORD steamProgramPathW_len = 28;
 static const WCHAR steamdllW[] = {'S','t','e','a','m','.','d','l','l',0};
 static const DWORD steamdllW_len = 9;
-static const WCHAR steamclient_pathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m','\\','s','t','e','a','m','c','l','i','e','n','t','.','d','l','l',0};;
 static HMODULE steamclient_hmod = NULL;
 static HMODULE lsteamclient_hmod = NULL;
 
@@ -890,8 +897,6 @@ static const WCHAR *get_dll_system_path(void)
 
     if (!cached_path)
     {
-        static const WCHAR steamProgramPathW[] = {'C',':','\\','P','r','o','g','r','a','m',' ','F','i','l','e','s','\\','S','t','e','a','m',0};
-        static const DWORD steamProgramPathW_len = 22;
         WCHAR *p, *path;
         int len = 2;
 
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 75d5f4a7216..7fe2f49dcd9 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3758,6 +3758,7 @@ HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16422%\Steam"
 [SteamClient.ntamd64]
 HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
+HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll64",,"%16426%\Steam\steamclient64.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"
 
 [DestinationDirs]

From bf02d103fde2c2e54a074b03021f47e4672d4b01 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Mon, 5 Nov 2018 18:45:57 +0300
Subject: [PATCH] Add missing InstallPath registry value.

So UPlay won't try to install Steam.
---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 5610c701d..3d71722ac 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3760,6 +3760,7 @@ HKCU,Software\Valve\Steam\ActiveProcess,"PID",0x10001,0x0000fffe
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll",,"%16426%\Steam\steamclient.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamClientDll64",,"%16426%\Steam\steamclient64.dll"
 HKCU,Software\Valve\Steam\ActiveProcess,"SteamPath",,"%16426%\Steam"
+HKLM,Software\Wow6432Node\Valve\Steam,"InstallPath",,"%16422%\Steam"
 
 [DestinationDirs]
 l_intl_section = 11

From bac899cd4531229baa7633d67578b74a2a98468f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 19 Mar 2018 11:34:35 -0500
Subject: [PATCH] kernel32: Don't force-load Steam.dll

This must fail for older DRM which walks up the FS tree searching for
Steam.dll to work correctly.
---
 dlls/kernel32/module.c | 10 ----------
 1 file changed, 10 deletions(-)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 32f9ddf6718..342e408b555 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -1318,16 +1318,6 @@ static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
 done:
     HeapFree( GetProcessHeap(), 0, load_path );
 
-    if(!hModule){
-        DWORD len = lstrlenW(libname->Buffer);
-        if(len > steamdllW_len &&
-                !strcmpiW(libname->Buffer + len - steamdllW_len, steamdllW)){
-            /* tried and failed to load some path ending in Steam.dll. try
-             * again without hard-coded path */
-            return LoadLibraryW(steamdllW);
-        }
-    }
-
     return hModule;
 }
 
From 7bd039f34f5fc1123524ddb22769f6e16e7d9c88 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 11 May 2017 10:01:16 -0500
Subject: [PATCH] HACK: ws2_32: Fake success when trying to bind to an IPX
 address

---
 dlls/ws2_32/socket.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 164a48ce751..b9248c9bd5e 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3332,6 +3332,13 @@ int WINAPI WS_bind(SOCKET s, const struct WS_sockaddr* name, int namelen)
                     else if (interface_bind(s, fd, &uaddr.addr))
                         in4->sin_addr.s_addr = htonl(INADDR_ANY);
                 }
+
+                if(name->sa_family ==  WS_AF_IPX){
+                    /* Quake (and similar family) fails if we can't bind to an IPX address. This often
+                     * doesn't work on Linux, so just fake success. */
+                    return 0;
+                }
+
                 if (bind(fd, &uaddr.addr, uaddrlen) < 0)
                 {
                     int loc_errno = errno;

From 819b923a3b761944b094f5f20b881c501a522f20 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 19 Jan 2018 14:01:07 -0600
Subject: [PATCH] HACK: advapi32: Use steamuser as Wine username

---
 dlls/advapi32/advapi.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/advapi32/advapi.c b/dlls/advapi32/advapi.c
index 1c528ef7419..87792f4fbc9 100644
--- a/dlls/advapi32/advapi.c
+++ b/dlls/advapi32/advapi.c
@@ -84,7 +84,7 @@ GetUserNameA( LPSTR lpszName, LPDWORD lpSize )
 BOOL WINAPI
 GetUserNameW( LPWSTR lpszName, LPDWORD lpSize )
 {
-    const char *name = wine_get_user_name();
+    const char *name = "steamuser"/*wine_get_user_name()*/;
     DWORD i, len = MultiByteToWideChar( CP_UNIXCP, 0, name, -1, NULL, 0 );
     LPWSTR backslash;
 
From ec9e7190ea7045012b6e33e5ee64cd678bec68c9 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 22 Jan 2018 14:32:40 -0600
Subject: [PATCH] HACK: shell32: Never create links to the user's home dirs

---
 dlls/shell32/shellpath.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/dlls/shell32/shellpath.c b/dlls/shell32/shellpath.c
index f08474b3635..2f637f25537 100644
--- a/dlls/shell32/shellpath.c
+++ b/dlls/shell32/shellpath.c
@@ -4424,6 +4424,7 @@ static void _SHCreateSymbolicLinks(void)
     pszPersonal = wine_get_unix_file_name(wszTempPath);
     if (!pszPersonal) return;
 
+#if 0
     hr = XDG_UserDirLookup(xdg_dirs, num, &xdg_results);
     if (FAILED(hr)) xdg_results = NULL;
 
@@ -4477,6 +4478,7 @@ static void _SHCreateSymbolicLinks(void)
     }
     else
     {
+#endif
         /* '$HOME' doesn't exist. Create 'My Pictures', 'My Videos' and 'My Music' subdirs
          * in '%USERPROFILE%\\My Documents' or fail silently if they already exist. */
         pszHome = NULL;
@@ -4486,8 +4488,11 @@ static void _SHCreateSymbolicLinks(void)
             if (_SHAppendToUnixPath(szMyStuffTarget, MAKEINTRESOURCEW(aidsMyStuff[i])))
                 mkdir(szMyStuffTarget, 0777);
         }
+#if 0
     }
+#endif
 
+#if 0
     /* Create symbolic links for 'My Pictures', 'My Videos' and 'My Music'. */
     for (i=0; i < ARRAY_SIZE(aidsMyStuff); i++)
     {
@@ -4532,13 +4537,17 @@ static void _SHCreateSymbolicLinks(void)
         symlink(szMyStuffTarget, pszMyStuff);
         heap_free(pszMyStuff);
     }
+#endif
 
+#if 0
     /* Last but not least, the Desktop folder */
     if (pszHome)
         strcpy(szDesktopTarget, pszHome);
     else
         strcpy(szDesktopTarget, pszPersonal);
+#endif
     heap_free(pszPersonal);
+#if 0
 
     xdg_desktop_dir = xdg_results ? xdg_results[num - 1] : NULL;
     if (xdg_desktop_dir ||
@@ -4565,6 +4574,7 @@ static void _SHCreateSymbolicLinks(void)
             heap_free(xdg_results[i]);
         heap_free(xdg_results);
     }
+#endif
 }
 
 /******************************************************************************

From 134fa05a0e39b63bfec75d0823ebe49e4c9cae64 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 7 Jun 2018 14:37:03 -0500
Subject: [PATCH] HACK: winex11.drv: Disable XIM by default

libx11 has a race condition that causes XIM to crash with "double free
or corruption" errors, see winehq bug 35041. Disabling XIM works around
this, though special input methods (CJK, etc.) will no longer work.
---
 dlls/winex11.drv/x11drv_main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index db87d188236..81a63a20689 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -93,7 +93,7 @@ static void *err_callback_arg;               /* error callback argument */
 static int err_callback_result;              /* error callback result */
 static unsigned long err_serial;             /* serial number of first request */
 static int (*old_error_handler)( Display *, XErrorEvent * );
-static BOOL use_xim = TRUE;
+static BOOL use_xim = FALSE;
 static char input_style[20];
 
 #define IS_OPTION_TRUE(ch) \

From d012d137e4099d1b12079a49a8a5632d205e0a9f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 24 Sep 2018 12:37:49 -0500
Subject: [PATCH] HACK: dbghelp: Disable DWARF parsing

Patch by Zeb. Our DWARF parser has been known to crash winedbg in some
cases. Since probably no concerned parties are going to be using plain
winedbg, just don't bother parsing anything.
---
 dlls/dbghelp/dwarf.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/dlls/dbghelp/dwarf.c b/dlls/dbghelp/dwarf.c
index 31c008abb8f..ce689dbe6cf 100644
--- a/dlls/dbghelp/dwarf.c
+++ b/dlls/dbghelp/dwarf.c
@@ -3516,6 +3516,11 @@ BOOL dwarf2_parse(struct module* module, unsigned long load_offset,
     BOOL                ret = TRUE;
     struct module_format* dwarf2_modfmt;
 
+/* Our DWARF parser has been known to crash winedbg in some cases. Since
+ * probably no concerned parties are going to be using plain winedbg, just don't
+ * bother parsing anything. */
+return FALSE;
+
     dwarf2_init_section(&eh_frame,                fmap, ".eh_frame",     NULL,             &eh_frame_sect);
     dwarf2_init_section(&section[section_debug],  fmap, ".debug_info",   ".zdebug_info",   &debug_sect);
     dwarf2_init_section(&section[section_abbrev], fmap, ".debug_abbrev", ".zdebug_abbrev", &debug_abbrev_sect);

From a13270aea50af90aa6c721080b956870d67d81c2 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 30 Mar 2018 10:40:43 -0500
Subject: [PATCH] winedbg: When crash dialog is not shown, dump crash info to
 stderr

This way the backtrace and such will appear in the log file instead of
going to stdout, which we don't capture.
---
 programs/winedbg/tgt_active.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/programs/winedbg/tgt_active.c b/programs/winedbg/tgt_active.c
index f632ca0414d..72e63327831 100644
--- a/programs/winedbg/tgt_active.c
+++ b/programs/winedbg/tgt_active.c
@@ -874,6 +874,9 @@ enum dbg_start dbg_active_auto(int argc, char* argv[])
         if (event) thread = display_crash_details( event );
         if (thread) dbg_houtput = output = create_temp_file();
         break;
+    case TRUE:
+        dbg_houtput = GetStdHandle(STD_ERROR_HANDLE);
+        break;
     }
 
     input = parser_generate_command_file("echo Modules:", "info share",

From 1091eaf13692b16ed66328ceeebfc587075fec6c Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 25 Oct 2018 12:50:45 -0500
Subject: [PATCH] HACK: wined3d: Fake an AMD card in place of Nvidia cards

Some games assume they can load the nvapi library if the hardware is an
nvidia card. This obviously fails in Wine. So fake that all nvidia
hardware is actually an AMD card, so they don't try to load nvapi.
---
 dlls/wined3d/adapter_gl.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index b8a2060cf46..8259d92ebac 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -1009,6 +1009,14 @@ static const struct wined3d_gpu_description *query_gpu_description(const struct
         vendor = wined3d_settings.pci_vendor_id;
         TRACE("Overriding vendor PCI ID with 0x%04x.\n", vendor);
     }
+    else if(vendor == HW_VENDOR_NVIDIA)
+    {
+        /* XXX: Fake having an AMD card in order to avoid games trying to load
+         * the Windows-only nvapi library. */
+        WARN("Nvidia card detected. Faking an AMD RX 480!\n");
+        vendor = HW_VENDOR_AMD;
+        device = CARD_AMD_RADEON_RX_480;
+    }
 
     if (wined3d_settings.pci_device_id != PCI_DEVICE_NONE)
     {

From 29a2c4f1b8cad98e94c67e4c068d9096969074ee Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 20 Aug 2018 10:58:09 -0500
Subject: [PATCH] secur32: Return real Unix username from
 GetUserNameEx(NameDisplay)

---
 dlls/secur32/secur32.c | 19 ++++++++++++++++++-
 1 file changed, 18 insertions(+), 1 deletion(-)

diff --git a/dlls/secur32/secur32.c b/dlls/secur32/secur32.c
index ec189fda104..1c662adf44b 100644
--- a/dlls/secur32/secur32.c
+++ b/dlls/secur32/secur32.c
@@ -34,6 +34,7 @@
 #include "thunks.h"
 #include "lmcons.h"
 
+#include "wine/library.h"
 #include "wine/list.h"
 #include "wine/debug.h"
 #include "wine/unicode.h"
@@ -1201,9 +1202,25 @@ BOOLEAN WINAPI GetUserNameExW(
             return FALSE;
         }
 
+    case NameDisplay:
+        {
+            const char *name = wine_get_user_name();
+            DWORD len = MultiByteToWideChar( CP_UNIXCP, 0, name, -1, NULL, 0 );
+
+            if (len > *nSize)
+            {
+                SetLastError( ERROR_MORE_DATA );
+                *nSize = len;
+                return FALSE;
+            }
+
+            *nSize = len - 1;
+            MultiByteToWideChar( CP_UNIXCP, 0, name, -1, lpNameBuffer, len );
+            return TRUE;
+        }
+
     case NameUnknown:
     case NameFullyQualifiedDN:
-    case NameDisplay:
     case NameUniqueId:
     case NameCanonical:
     case NameUserPrincipal:


From 63f934962cb97d69ed71604985716e7479f822b1 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 23 Oct 2018 16:18:20 +0300
Subject: [PATCH] wine.inf: Add font registry entries.

---
 loader/wine.inf.in | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 1f94c38d0c6..df2b43d9106 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -181,6 +181,7 @@ CurrentVersion="Software\Microsoft\Windows\CurrentVersion"
 CurrentVersionNT="Software\Microsoft\Windows NT\CurrentVersion"
 FontSubStr="Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes"
 Control="System\CurrentControlSet\Control"
+FontsNT="Software\Microsoft\Windows NT\CurrentVersion\Fonts"
 
 [Classes]
 HKCR,.chm,,2,"chm.file"
@@ -614,6 +615,10 @@ HKLM,%FontSubStr%,"Times New Roman CYR,204",,"Times New Roman,204"
 HKLM,%FontSubStr%,"Times New Roman Greek,161",,"Times New Roman,161"
 HKLM,%FontSubStr%,"Times New Roman TUR,162",,"Times New Roman,162"
 HKLM,System\CurrentControlSet\Hardware Profiles\Current\Software\Fonts,"LogPixels",0x10003,0x00000060
+HKLM,%FontsNT%,"Arial (TrueType)",,"arial.ttf"
+HKLM,%FontsNT%,"Arial Bold (TrueType)",,"arialbd.ttf"
+HKLM,%FontsNT%,"Times New Roman (TrueType)",,"times.ttf"
+HKLM,%FontsNT%,"Courier New (TrueType)",,"cour.ttf"
 
 [MCI]
 HKLM,%Mci32Str%,"AVIVideo",,"mciavi32.dll"
     
From 174d487bf8ef5bec22c3663f50a276ae59d0a931 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 30 Oct 2018 13:04:06 -0500
Subject: [PATCH] wine.inf: Substitute Times New Roman for Palatino Linotype

For AOE2HD launcher.
---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index df2b43d9106..44ce3cd6639 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -619,6 +619,7 @@ HKLM,%FontsNT%,"Arial (TrueType)",,"arial.ttf"
 HKLM,%FontsNT%,"Arial Bold (TrueType)",,"arialbd.ttf"
 HKLM,%FontsNT%,"Times New Roman (TrueType)",,"times.ttf"
 HKLM,%FontsNT%,"Courier New (TrueType)",,"cour.ttf"
+HKCU,Software\Wine\Fonts\Replacements,"Palatino Linotype",,"Times New Roman"
 
 [MCI]
 HKLM,%Mci32Str%,"AVIVideo",,"mciavi32.dll"

From aa7fa7ce94bd4e49e3843a8ea398d29882518e43 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 6 Aug 2018 08:06:03 -0500
Subject: [PATCH] server: Set default timeout to 0

The Steam client will be waiting for the wineserver to exit to set up
some environment variables, so make it wait as short as possible.
---
 server/main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/main.c b/server/main.c
index 20d3c48c4d9..aca8738c4c0 100644
--- a/server/main.c
+++ b/server/main.c
@@ -42,7 +42,7 @@
 /* command-line options */
 int debug_level = 0;
 int foreground = 0;
-timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
+timeout_t master_socket_timeout = 0; /* master socket timeout, default is 3 seconds */
 const char *server_argv0;
 
 /* parse-line args */

From 059a15a1d521a6ba79273b2ade923822b1532205 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 13 Jul 2018 10:40:27 -0500
Subject: [PATCH] HACK: mshtml: Don't install wine-gecko on prefix creation

We only want to install this on demand.
---
 dlls/mshtml/main.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/dlls/mshtml/main.c b/dlls/mshtml/main.c
index 6ce8198aee5..f84d92cc860 100644
--- a/dlls/mshtml/main.c
+++ b/dlls/mshtml/main.c
@@ -530,8 +530,6 @@ HRESULT WINAPI DllRegisterServer(void)
     hres = __wine_register_resources( hInst );
     if(SUCCEEDED(hres))
         hres = register_server(TRUE);
-    if(SUCCEEDED(hres))
-        load_gecko();
 
     return hres;
 }

From 1ef83da3b15171782dc009bb6649665769122aa5 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 15 Jan 2019 10:10:47 -0600
Subject: [PATCH] kernel32: Don't pass SDL_AUDIODRIVER from Linux environment

---
 dlls/kernel32/process.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 9c957f02c06..e14b514ccc1 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -137,6 +137,7 @@ static inline BOOL is_special_env_var( const char *var )
             !strncmp( var, "TEMP=", sizeof("TEMP=")-1 ) ||
             !strncmp( var, "TMP=", sizeof("TMP=")-1 ) ||
             !strncmp( var, "QT_", sizeof("QT_")-1 ) ||
+            !strncmp( var, "SDL_AUDIODRIVER=", sizeof("SDL_AUDIODRIVER=")-1 ) ||
             !strncmp( var, "VK_", sizeof("VK_")-1 ));
 }
 
From 971dc3c4225b33fb5346187cd37e8355f265800f Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 18 Jun 2018 07:56:35 -0500
Subject: [PATCH] ntdll: Notice THREADNAME_INFO exceptions and set thread name
 on Linux

Patch by Zeb.
---
 dlls/ntdll/exception.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
index f85381079a2..ffe048de8c0 100644
--- a/dlls/ntdll/exception.c
+++ b/dlls/ntdll/exception.c
@@ -26,6 +26,9 @@
 #include <errno.h>
 #include <signal.h>
 #include <stdarg.h>
+#ifdef HAVE_PRCTL
+#include <sys/prctl.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -143,6 +146,16 @@ void wait_suspend( CONTEXT *context )
 }
 
 
+/* "How to: Set a Thread Name in Native Code"
+ * https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx */
+typedef struct tagTHREADNAME_INFO
+{
+   DWORD   dwType;     /* Must be 0x1000 */
+   LPCSTR  szName;     /* Pointer to name - limited to 9 bytes (8 characters + terminator) */
+   DWORD   dwThreadID; /* Thread ID (-1 = caller thread) */
+   DWORD   dwFlags;    /* Reserved for future use.  Must be zero. */
+} THREADNAME_INFO;
+
 /**********************************************************************
  *           send_debug_event
  *
@@ -162,6 +175,21 @@ NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, int first_chance, CONTEXT *con
     for (i = 0; i < min( rec->NumberParameters, EXCEPTION_MAXIMUM_PARAMETERS ); i++)
         params[i] = rec->ExceptionInformation[i];
 
+    if (rec->ExceptionCode == 0x406d1388)
+    {
+        const THREADNAME_INFO *threadname = (const THREADNAME_INFO *)rec->ExceptionInformation;
+
+        if (threadname->dwThreadID == -1)
+        {
+#ifdef HAVE_PRCTL
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+            prctl( PR_SET_NAME, threadname->szName );
+#endif
+        }
+    }
+
     context_to_server( &server_context, context );
 
     SERVER_START_REQ( queue_exception_event )

From a7542e9e279970c2ab3ac9c6c986b300135286a0 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 28 Mar 2018 09:17:30 -0500
Subject: [PATCH] wine.inf: Don't show crash dialog by default

---
 loader/wine.inf.in | 1 +
 1 file changed, 1 insertion(+)

diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 7fe2f49dcd9..e72d0dcaba1 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -540,6 +540,7 @@ HKLM,%CurrentVersionNT%\AeDebug,"Debugger",2,"winedbg --auto %ld %ld"
 HKLM,%CurrentVersionNT%\AeDebug,"Auto",2,"1"
 HKCU,Software\Wine\Debug,"RelayExclude",2,"ntdll.RtlEnterCriticalSection;ntdll.RtlTryEnterCriticalSection;ntdll.RtlLeaveCriticalSection;kernel32.48;kernel32.49;kernel32.94;kernel32.95;kernel32.96;kernel32.97;kernel32.98;kernel32.TlsGetValue;kernel32.TlsSetValue;kernel32.FlsGetValue;kernel32.FlsSetValue;kernel32.SetLastError"
 HKCU,Software\Wine\Debug,"RelayFromExclude",2,"winex11.drv;winemac.drv;user32;gdi32;advapi32;kernel32"
+HKCU,Software\Wine\WineDbg,"ShowCrashDialog",0x00010003,0x00000000
 
 [DirectX]
 HKLM,Software\Microsoft\DirectX,"Version",,"4.09.00.0904"

From 71fce64369f2ace00bc0bb8018b549dd201a5764 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 9 Jan 2019 13:24:54 +0300
Subject: [PATCH] imm32: Automatically initialize COM on window activation.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/imm32/Makefile.in     |   2 +-
 dlls/imm32/imm.c           | 129 ++++++++++++++++++++++++++++++++++++-
 dlls/imm32/imm32.spec      |   1 +
 dlls/user32/focus.c        |   2 +
 dlls/user32/misc.c         |   2 +
 dlls/user32/user_private.h |   1 +
 6 files changed, 135 insertions(+), 2 deletions(-)

diff --git a/dlls/imm32/Makefile.in b/dlls/imm32/Makefile.in
index b190888659b..ad10fc2fa45 100644
--- a/dlls/imm32/Makefile.in
+++ b/dlls/imm32/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = imm32.dll
 IMPORTLIB = imm32
-IMPORTS   = user32 gdi32 advapi32
+IMPORTS   = user32 gdi32 advapi32 ole32
 
 C_SRCS = \
 	imm.c
diff --git a/dlls/imm32/imm.c b/dlls/imm32/imm.c
index 28eb00f355a..129f7e8cb53 100644
--- a/dlls/imm32/imm.c
+++ b/dlls/imm32/imm.c
@@ -19,6 +19,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#define COBJMACROS
+
 #include <stdarg.h>
 #include <stdio.h>
 
@@ -32,6 +34,8 @@
 #include "ddk/imm.h"
 #include "winnls.h"
 #include "winreg.h"
+#include "initguid.h"
+#include "objbase.h"
 #include "wine/list.h"
 #include "wine/unicode.h"
 
@@ -95,8 +99,16 @@ typedef struct _tagIMMThreadData {
     HWND hwndDefault;
     BOOL disableIME;
     DWORD windowRefs;
+    IInitializeSpy IInitializeSpy_iface;
+    ULARGE_INTEGER spy_cookie;
+    BOOL apt_initialized;
 } IMMThreadData;
 
+static inline IMMThreadData *impl_from_IInitializeSpy(IInitializeSpy *iface)
+{
+    return CONTAINING_RECORD(iface, IMMThreadData, IInitializeSpy_iface);
+}
+
 static struct list ImmHklList = LIST_INIT(ImmHklList);
 static struct list ImmThreadDataList = LIST_INIT(ImmThreadDataList);
 
@@ -227,6 +239,88 @@ static DWORD convert_candidatelist_AtoW(
     return ret;
 }
 
+static HRESULT WINAPI initializespy_QueryInterface(IInitializeSpy *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(&IID_IInitializeSpy, riid) ||
+            IsEqualIID(&IID_IUnknown, riid))
+    {
+        *obj = iface;
+        IInitializeSpy_AddRef(iface);
+        return S_OK;
+    }
+
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI initializespy_AddRef(IInitializeSpy *iface)
+{
+    return 2;
+}
+
+static ULONG WINAPI initializespy_Release(IInitializeSpy *iface)
+{
+    return 1;
+}
+
+static void imm_couninit_thread(IMMThreadData *thread_data)
+{
+    if (!thread_data->apt_initialized)
+        return;
+
+    thread_data->apt_initialized = FALSE;
+    CoUninitialize();
+}
+
+static HRESULT WINAPI initializespy_PreInitialize(IInitializeSpy *iface, DWORD coinit, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Application requested initialization of different apartment type. */
+    if (!(coinit & COINIT_APARTMENTTHREADED))
+        imm_couninit_thread(thread_data);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI initializespy_PostInitialize(IInitializeSpy *iface, HRESULT hr, DWORD coinit, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Explicit initialization call should return S_OK first time. */
+    if (thread_data->apt_initialized && hr == S_FALSE && refs == 2)
+        hr = S_OK;
+
+    return hr;
+}
+
+static HRESULT WINAPI initializespy_PreUninitialize(IInitializeSpy *iface, DWORD refs)
+{
+    IMMThreadData *thread_data = impl_from_IInitializeSpy(iface);
+
+    /* Account for explicit uninitialization calls. */
+    if (thread_data->apt_initialized && refs == 1)
+        thread_data->apt_initialized = FALSE;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI initializespy_PostUninitialize(IInitializeSpy *iface, DWORD refs)
+{
+    return S_OK;
+}
+
+static const IInitializeSpyVtbl initializespyvtbl =
+{
+    initializespy_QueryInterface,
+    initializespy_AddRef,
+    initializespy_Release,
+    initializespy_PreInitialize,
+    initializespy_PostInitialize,
+    initializespy_PreUninitialize,
+    initializespy_PostUninitialize,
+};
+
 static IMMThreadData *IMM_GetThreadData(HWND hwnd, DWORD thread)
 {
     IMMThreadData *data;
@@ -253,6 +347,7 @@ static IMMThreadData *IMM_GetThreadData(HWND hwnd, DWORD thread)
         if (data->threadID == thread) return data;
 
     data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data));
+    data->IInitializeSpy_iface.lpVtbl = &initializespyvtbl;
     data->threadID = thread;
     list_add_head(&ImmThreadDataList,&data->entry);
     TRACE("Thread Data Created (%x)\n",thread);
@@ -281,6 +376,7 @@ static void IMM_FreeThreadData(void)
             list_remove(&data->entry);
             LeaveCriticalSection(&threaddata_cs);
             IMM_DestroyContext(data->defaultContext);
+            imm_couninit_thread(data);
             HeapFree(GetProcessHeap(),0,data);
             TRACE("Thread Data Destroyed\n");
             return;
@@ -1627,6 +1723,32 @@ static BOOL needs_ime_window(HWND hwnd)
     return TRUE;
 }
 
+void WINAPI __wine_activate_window(HWND hwnd)
+{
+    IMMThreadData *thread_data;
+
+    TRACE("(%p)\n", hwnd);
+
+    if (!needs_ime_window(hwnd))
+        return;
+
+    thread_data = IMM_GetThreadData(hwnd, 0);
+    if (!thread_data)
+        return;
+
+    if (thread_data->disableIME || disable_ime)
+    {
+        TRACE("IME for this thread is disabled\n");
+        LeaveCriticalSection(&threaddata_cs);
+        return;
+    }
+
+    if (!thread_data->apt_initialized)
+        thread_data->apt_initialized = SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED));
+
+    LeaveCriticalSection(&threaddata_cs);
+}
+
 /***********************************************************************
  *		__wine_register_window (IMM32.@)
  */
@@ -1656,6 +1778,8 @@ BOOL WINAPI __wine_register_window(HWND hwnd)
     /* Create default IME window */
     if (thread_data->windowRefs == 1)
     {
+        CoRegisterInitializeSpy(&thread_data->IInitializeSpy_iface, &thread_data->spy_cookie);
+
         /* Do not create the window inside of a critical section */
         LeaveCriticalSection(&threaddata_cs);
         new = CreateWindowExW( 0, szwIME, szwDefaultIME,
@@ -1697,8 +1821,11 @@ void WINAPI __wine_unregister_window(HWND hwnd)
           thread_data->windowRefs, thread_data->hwndDefault);
 
     /* Destroy default IME window */
-    if (thread_data->windowRefs == 0 && thread_data->hwndDefault)
+    if (thread_data->windowRefs == 0)
     {
+        CoRevokeInitializeSpy(thread_data->spy_cookie);
+        thread_data->spy_cookie.QuadPart = 0;
+        imm_couninit_thread(thread_data);
         to_destroy = thread_data->hwndDefault;
         thread_data->hwndDefault = NULL;
     }
diff --git a/dlls/imm32/imm32.spec b/dlls/imm32/imm32.spec
index 4197bb81e21..d9cdc794e9e 100644
--- a/dlls/imm32/imm32.spec
+++ b/dlls/imm32/imm32.spec
@@ -117,3 +117,4 @@
 @ stdcall __wine_get_ui_window(ptr)
 @ stdcall __wine_register_window(long)
 @ stdcall __wine_unregister_window(long)
+@ stdcall __wine_activate_window(long)
diff --git a/dlls/user32/focus.c b/dlls/user32/focus.c
index f1c883167ed..50b3323ae9f 100644
--- a/dlls/user32/focus.c
+++ b/dlls/user32/focus.c
@@ -156,6 +156,8 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
                       (LPARAM)previous );
         if (GetAncestor( hwnd, GA_PARENT ) == GetDesktopWindow())
             PostMessageW( GetDesktopWindow(), WM_PARENTNOTIFY, WM_NCACTIVATE, (LPARAM)hwnd );
+
+        imm_activate_window( hwnd );
     }
 
     /* now change focus if necessary */
diff --git a/dlls/user32/misc.c b/dlls/user32/misc.c
index c26c02a3537..5cbcc7db67d 100644
--- a/dlls/user32/misc.c
+++ b/dlls/user32/misc.c
@@ -43,6 +43,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(win);
 static HWND (WINAPI *imm_get_ui_window)(HKL);
 BOOL (WINAPI *imm_register_window)(HWND) = NULL;
 void (WINAPI *imm_unregister_window)(HWND) = NULL;
+void (WINAPI *imm_activate_window)(HWND) = NULL;
 
 /* MSIME messages */
 static UINT WM_MSIME_SERVICE;
@@ -567,6 +568,7 @@ BOOL WINAPI User32InitializeImmEntryTable(DWORD magic)
     imm_get_ui_window = (void*)GetProcAddress(imm32, "__wine_get_ui_window");
     imm_register_window = (void*)GetProcAddress(imm32, "__wine_register_window");
     imm_unregister_window = (void*)GetProcAddress(imm32, "__wine_unregister_window");
+    imm_activate_window = (void*)GetProcAddress(imm32, "__wine_activate_window");
     if (!imm_get_ui_window)
         FIXME("native imm32.dll not supported\n");
     return TRUE;
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 514cf6753f4..b86831d7d95 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -197,6 +197,7 @@ C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo)
 extern INT global_key_state_counter DECLSPEC_HIDDEN;
 extern BOOL (WINAPI *imm_register_window)(HWND) DECLSPEC_HIDDEN;
 extern void (WINAPI *imm_unregister_window)(HWND) DECLSPEC_HIDDEN;
+extern void (WINAPI *imm_activate_window)(HWND) DECLSPEC_HIDDEN;
 
 struct user_key_state_info
 {

From 8a781a3ab721a14fed0a8c1aaccd357cdd71d0ac Mon Sep 17 00:00:00 2001
From: Jactry Zeng <jzeng@codeweavers.com>
Date: Thu, 13 Dec 2018 22:21:34 +0800
Subject: [PATCH] gdi32: Add CJK font replacements.

---
 dlls/gdi32/freetype.c | 172 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 171 insertions(+), 1 deletion(-)

diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 0fc41f39021..1d721f50760 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -513,11 +513,22 @@ static const WCHAR external_fonts_reg_key[] = {'S','o','f','t','w','a','r','e','
 static const WCHAR Lucida_Sans_Unicode[] = {'L','u','c','i','d','a',' ','S','a','n','s',' ','U','n','i','c','o','d','e',0};
 static const WCHAR Microsoft_Sans_Serif[] = {'M','i','c','r','o','s','o','f','t',' ','S','a','n','s',' ','S','e','r','i','f',0 };
 static const WCHAR Tahoma[] = {'T','a','h','o','m','a',0};
+/* Japanese fonts */
 static const WCHAR MS_UI_Gothic[] = {'M','S',' ','U','I',' ','G','o','t','h','i','c',0};
+static const WCHAR atMS_UI_Gothic[] = {'@','M','S',' ','U','I',' ','G','o','t','h','i','c',0};
+static const WCHAR MS_PGothic_cp932[]= {0x30fb,0xff6d,0x30fb,0xff73,' ',0x30fb,0xff70,0x7e67,0xff74,0x7e67,0xff77,0x7e5d,0x30fb,0x3051,0};
+/* Simplified Chinese fonts */
 static const WCHAR SimSun[] = {'S','i','m','S','u','n',0};
-static const WCHAR Gulim[] = {'G','u','l','i','m',0};
+static const WCHAR atSimSun[] = {'@','S','i','m','S','u','n',0};
+static const WCHAR Microsoft_YaHei[] = {'M','i','c','r','o','s','o','f','t',' ','Y','a','H','e','i',0};
+static const WCHAR LiSu[] = {'L','i','S','u',0};
+/* Traditional Chinese fonts */
 static const WCHAR PMingLiU[] = {'P','M','i','n','g','L','i','U',0};
+static const WCHAR atPMingLiU[] = {'@','P','M','i','n','g','L','i','U',0};
+/* Korean fonts */
 static const WCHAR Batang[] = {'B','a','t','a','n','g',0};
+static const WCHAR Gulim[] = {'G','u','l','i','m',0};
+static const WCHAR atGulim[] = {'@','G','u','l','i','m',0};
 
 static const WCHAR arial[] = {'A','r','i','a','l',0};
 static const WCHAR bitstream_vera_sans[] = {'B','i','t','s','t','r','e','a','m',' ','V','e','r','a',' ','S','a','n','s',0};
@@ -2365,6 +2376,113 @@ static BOOL map_font_family(const WCHAR *orig, const WCHAR *repl)
     return FALSE;
 }
 
+static const WCHAR new_sc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',0,
+    /* Popular open source Chinese font */
+    'W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR vertical_new_sc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','S','C',0,
+    /* popular open source Chinese font */
+    '@','W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR new_tc_fonts[] = {
+    /* Ubuntu 16.04 or later, Mint 19, Fedora 29 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',0,
+    /* popular open source Chinese font */
+    'W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR vertical_new_tc_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','T','C',0,
+    /* popular open source Chinese font */
+    '@','W','e','n','Q','u','a','n','Y','i',' ','M','i','c','r','o',' ','H','e','i',0,
+    0
+};
+
+static const WCHAR new_jp_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',0,
+    0
+};
+
+static const WCHAR vertical_new_jp_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','J','P',0,
+    0
+};
+
+static const WCHAR new_kr_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    'N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',0,
+    0
+};
+
+static const WCHAR vertical_new_kr_fonts[] = {
+    /* Ubuntu 16.04 or later */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',' ','R','e','g','u','l','a','r',0,
+    /* Manjaro 18 */
+    '@','N','o','t','o',' ','S','a','n','s',' ','C','J','K',' ','K','R',0,
+    0
+};
+
+static struct font_replacements
+{
+    const WCHAR *replacements[4];
+    const int count;
+    const WCHAR *new_fonts;
+    const WCHAR *vertical_new_fonts;
+    BOOL *font_seen;
+} font_replacements_list[] =
+{
+    /* Simplified Chinese */
+    {
+        {
+            SimSun, atSimSun, Microsoft_YaHei, LiSu
+        }, 4, new_sc_fonts, vertical_new_sc_fonts, NULL
+    },
+    /* Traditional Chinese */
+    {
+        {
+            PMingLiU, atPMingLiU
+        }, 2, new_tc_fonts, vertical_new_tc_fonts, NULL
+    },
+    /* Japanese */
+    {
+        {
+            MS_UI_Gothic, atMS_UI_Gothic, MS_PGothic_cp932
+        }, 3, new_jp_fonts, vertical_new_jp_fonts, NULL
+    },
+    /* Korean */
+    {
+        {
+            Gulim, atGulim
+        }, 2, new_kr_fonts, vertical_new_kr_fonts, NULL
+    }
+};
+
 /***********************************************************
  * The replacement list is a way to map an entire font
  * family onto another family.  For example adding
@@ -2383,6 +2501,7 @@ static void LoadReplaceList(void)
     DWORD valuelen, datalen, i = 0, type, dlen, vlen;
     LPWSTR value;
     LPVOID data;
+    int replacement_count = sizeof(font_replacements_list)/sizeof(font_replacements_list[0]);
 
     /* @@ Wine registry key: HKCU\Software\Wine\Fonts\Replacements */
     if(RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Fonts\\Replacements", &hkey) == ERROR_SUCCESS)
@@ -2401,6 +2520,25 @@ static void LoadReplaceList(void)
             /* "NewName"="Oldname" */
             if(!find_family_from_any_name(value))
             {
+                int j;
+
+                for (j = 0; j < replacement_count; j++)
+                {
+                    int k;
+
+                    struct font_replacements *replacement = &font_replacements_list[j];
+
+                    replacement->font_seen = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                                                       replacement->count * sizeof(BOOL));
+                    for (k = 0; k < replacement->count; k++)
+                    {
+                        if (!replacement->font_seen[k] && !lstrcmpW(value, replacement->replacements[k]))
+                        {
+                            replacement->font_seen[k] = TRUE;
+                            break;
+                        }
+                    }
+                }
                 if (type == REG_MULTI_SZ)
                 {
                     WCHAR *replace = data;
@@ -2421,6 +2559,38 @@ static void LoadReplaceList(void)
 	    dlen = datalen;
 	    vlen = valuelen;
 	}
+
+        for (i = 0; i < replacement_count; i++)
+        {
+            int j;
+            struct font_replacements *replacement = &font_replacements_list[i];
+
+            for (j = 0; j < replacement->count; j++)
+            {
+                if (!replacement->font_seen ||
+                    (!replacement->font_seen[j] && !find_family_from_any_name(replacement->replacements[j])))
+                {
+                    const WCHAR *replace;
+
+                    if (replacement->replacements[j][0] == '@')
+                        replace = replacement->vertical_new_fonts;
+                    else
+                        replace = replacement->new_fonts;
+
+                    while (*replace)
+                    {
+                        if (map_font_family(replacement->replacements[j], replace))
+                        {
+                            TRACE("Replace %s with %s\n", wine_dbgstr_w(replacement->replacements[j]),
+                                  wine_dbgstr_w(replace));
+                            break;
+                        }
+                        replace += strlenW(replace) + 1;
+                    }
+                }
+            }
+            HeapFree(GetProcessHeap(), 0, replacement->font_seen);
+        }
 	HeapFree(GetProcessHeap(), 0, data);
 	HeapFree(GetProcessHeap(), 0, value);
 	RegCloseKey(hkey);

From 17d19e1b23bce6fc6ff5b4e61131c9c58fd57ae5 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 28 Mar 2018 09:21:41 -0500
Subject: [PATCH] HACK: Don't build winemenubuilder

---
 configure          | 2 --
 configure.ac       | 1 -
 loader/wine.inf.in | 1 -
 3 files changed, 4 deletions(-)

diff --git a/configure b/configure
index 649a8917f54..4581015d576 100755
--- a/configure
+++ b/configure
@@ -1746,7 +1746,6 @@ enable_wineconsole
 enable_winedbg
 enable_winedevice
 enable_winefile
-enable_winemenubuilder
 enable_winemine
 enable_winemsibuilder
 enable_winepath
@@ -20315,7 +20314,6 @@ wine_fn_config_makefile programs/wineconsole enable_wineconsole
 wine_fn_config_makefile programs/winedbg enable_winedbg
 wine_fn_config_makefile programs/winedevice enable_winedevice
 wine_fn_config_makefile programs/winefile enable_winefile
-wine_fn_config_makefile programs/winemenubuilder enable_winemenubuilder
 wine_fn_config_makefile programs/winemine enable_winemine
 wine_fn_config_makefile programs/winemsibuilder enable_winemsibuilder
 wine_fn_config_makefile programs/winepath enable_winepath
diff --git a/configure.ac b/configure.ac
index 704da15f404..d4168e410bc 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3998,7 +3998,6 @@ WINE_CONFIG_MAKEFILE(programs/wineconsole)
 WINE_CONFIG_MAKEFILE(programs/winedbg)
 WINE_CONFIG_MAKEFILE(programs/winedevice)
 WINE_CONFIG_MAKEFILE(programs/winefile)
-WINE_CONFIG_MAKEFILE(programs/winemenubuilder)
 WINE_CONFIG_MAKEFILE(programs/winemine)
 WINE_CONFIG_MAKEFILE(programs/winemsibuilder)
 WINE_CONFIG_MAKEFILE(programs/winepath)
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 2b049eb91f8..e6948a73427 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -3598,7 +3598,6 @@ HKR,Parameters,"ServiceDll",,"%11%\schedsvc.dll"
 HKLM,%CurrentVersionNT%\SvcHost,"netsvcs",0x00010008,"Schedule"
 
 [Services]
-HKLM,%CurrentVersion%\RunServices,"winemenubuilder",2,"%11%\winemenubuilder.exe -a -r"
 HKLM,"System\CurrentControlSet\Services\Eventlog\Application",,16
 HKLM,"System\CurrentControlSet\Services\Eventlog\System","Sources",0x10000,""
 HKLM,"System\CurrentControlSet\Services\Tcpip\Parameters","DataBasePath",2,"%11%\drivers"

From aef0f1638ce13db03a4d3c0fe53972f44443c854 Mon Sep 17 00:00:00 2001
From: Patryk Obara <dreamer.tan@gmail.com>
Date: Fri, 26 Apr 2019 20:40:31 +0200
Subject: [PATCH] winex11: Fill WM_CLASS based on Steam appid

Some desktop environments (Gnome 3, Cinnamon) decide on an application
icon in the following order:

 - If the first string in WM_CLASS property can be correlated to
  a name or StartupWMClass key in a .desktop entry file, then
  the associated icon will be used.
 - If the second string in WM_CLASS property can be correlated to
  a name or StartupWMClass key in a .desktop entry file, then
  the associated icon will be used.
 - If the application has indicated an icon resource through WM_HINTS
  property, then the associated X window or pixmaps will be used.

Upstream Wine usually deals with this by placing a .desktop file with
StartupWMClass filled to match first string in WM_CLASS property
(which is the name of exe file being run).

Wine in Proton does not do it, but still puts "Wine" as second string,
therefore desktop environment can't differentiate between Wine in
Proton and Wine installed in OS.

By replacing "Wine" with "steam_app_<appid>" we force DE to fallback
to icon indicated by WM_HINTS (ico file embedded in exe file).
Steam can override this behaviour by installing properly crafted
.desktop entry file.  If SteamAppId environment variable is missing,
then generic "steam_proton" name is used instead.
---
 dlls/winex11.drv/window.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 1ec7c706511..9ae3da3d4a2 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -870,10 +870,13 @@ static void set_initial_wm_hints( Display *display, Window window )
     /* class hints */
     if ((class_hints = XAllocClassHint()))
     {
-        static char wine[] = "Wine";
+        static char steam_proton[] = "steam_proton";
+        char proton_app_class[128];
+        const char *app_id = getenv("SteamAppId");
 
+        snprintf(proton_app_class, sizeof(proton_app_class), "steam_app_%s", app_id);
         class_hints->res_name = process_name;
-        class_hints->res_class = wine;
+        class_hints->res_class = app_id ? proton_app_class : steam_proton;
         XSetClassHint( display, window, class_hints );
         XFree( class_hints );
     }

From 7e91b897e69854cb3afe761f48ef7c9b496ecf95 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B3zef=20Kucia?= <jkucia@codeweavers.com>
Date: Wed, 1 May 2019 12:28:12 +0200
Subject: [PATCH] vulkan-1: Prefer built-in DLL.

Games may ship with their own Vulkan loader.
---
 dlls/vulkan-1/vulkan.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/dlls/vulkan-1/vulkan.c b/dlls/vulkan-1/vulkan.c
index d3b35603a17..4926cf9bf4f 100644
--- a/dlls/vulkan-1/vulkan.c
+++ b/dlls/vulkan-1/vulkan.c
@@ -32,10 +32,6 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, void *reserved)
 
     switch (reason)
     {
-        case DLL_WINE_PREATTACH:
-            /* Prefer native as it provides more functionality. */
-            return FALSE;
-
         case DLL_PROCESS_ATTACH:
             DisableThreadLibraryCalls(hinst);
             return TRUE;

From 90e3616c89ef7ed38763a3e3af3e9f0cd59697da Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Mar 2017 20:15:40 +0300
Subject: [PATCH] HACK: dwrite: Don't recommend outline rendering mode

---
 dlls/dwrite/font.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/dwrite/font.c b/dlls/dwrite/font.c
index e22559912c3..41ec809b727 100644
--- a/dlls/dwrite/font.c
+++ b/dlls/dwrite/font.c
@@ -740,7 +740,8 @@ static HRESULT WINAPI dwritefontface_GetRecommendedRenderingMode(IDWriteFontFace
 
     ppem = emSize * ppdip;
 
-    if (ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
+    /* HACK: disable outline rendering mode to workaround d2d issue */
+    if (0 && ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
         *mode = DWRITE_RENDERING_MODE_OUTLINE;
         return S_OK;
     }
From 5c59517008697ce74becddb59a3e6702a963bb49 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Fri, 16 Aug 2019 09:46:25 +0000
Subject: [PATCH] msctf: Use list to keep thread managers.

Thread managers were stored in thread local storage,
which have a major flaw that they can't not be released
by another thread.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/msctf/msctf.c          | 46 +++++++----------------
 dlls/msctf/msctf_internal.h |  1 -
 dlls/msctf/threadmgr.c      | 73 ++++++++++++++++++++++++++++++++-----
 3 files changed, 76 insertions(+), 44 deletions(-)

diff --git a/dlls/msctf/msctf.c b/dlls/msctf/msctf.c
index c6e3a2ca597..fd919295c5a 100644
--- a/dlls/msctf/msctf.c
+++ b/dlls/msctf/msctf.c
@@ -69,7 +69,6 @@ static UINT array_size;
 static struct list AtsList = LIST_INIT(AtsList);
 static UINT activated = 0;
 
-DWORD tlsIndex = 0;
 TfClientId processId = 0;
 ITfCompartmentMgr *globalCompartmentMgr = NULL;
 
@@ -397,23 +396,19 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
     ActivatedTextService *actsvr;
     ITfCategoryMgr *catmgr;
     AtsEntry *entry;
-    ITfThreadMgrEx *tm = TlsGetValue(tlsIndex);
+    ITfThreadMgr *tm;
     ITfClientId *clientid;
 
-    if (!tm) return E_UNEXPECTED;
+    if (FAILED(TF_GetThreadMgr(&tm))) return E_UNEXPECTED;
 
     actsvr = HeapAlloc(GetProcessHeap(),0,sizeof(ActivatedTextService));
-    if (!actsvr) return E_OUTOFMEMORY;
+    if (!actsvr) goto fail;
 
-    ITfThreadMgrEx_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
+    ITfThreadMgr_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
     ITfClientId_GetClientId(clientid, &lp->clsid, &actsvr->tid);
     ITfClientId_Release(clientid);
 
-    if (!actsvr->tid)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!actsvr->tid) goto fail;
 
     actsvr->pITfTextInputProcessor = NULL;
     actsvr->LanguageProfile = *lp;
@@ -440,20 +435,21 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
         deactivate_remove_conflicting_ts(&actsvr->LanguageProfile.catid);
 
     if (activated > 0)
-        activate_given_ts(actsvr, tm);
+        activate_given_ts(actsvr, (ITfThreadMgrEx *)tm);
 
     entry = HeapAlloc(GetProcessHeap(),0,sizeof(AtsEntry));
-
-    if (!entry)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!entry) goto fail;
 
     entry->ats = actsvr;
     list_add_head(&AtsList, &entry->entry);
 
+    ITfThreadMgr_Release(tm);
     return S_OK;
+
+fail:
+    ITfThreadMgr_Release(tm);
+    HeapFree(GetProcessHeap(), 0, actsvr);
+    return E_OUTOFMEMORY;
 }
 
 BOOL get_active_textservice(REFCLSID rclsid, TF_LANGUAGEPROFILE *profile)
@@ -560,11 +556,9 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD fdwReason, LPVOID fImpLoad)
             return FALSE;   /* prefer native version */
         case DLL_PROCESS_ATTACH:
             MSCTF_hinstance = hinst;
-            tlsIndex = TlsAlloc();
             break;
         case DLL_PROCESS_DETACH:
             if (fImpLoad) break;
-            TlsFree(tlsIndex);
             break;
     }
     return TRUE;
@@ -622,20 +616,6 @@ HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim)
     return ThreadMgr_Constructor(NULL,(IUnknown**)pptim);
 }
 
-/***********************************************************************
- *              TF_GetThreadMgr (MSCTF.@)
- */
-HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
-{
-    TRACE("\n");
-    *pptim = TlsGetValue(tlsIndex);
-
-    if (*pptim)
-        ITfThreadMgr_AddRef(*pptim);
-
-    return S_OK;
-}
-
 /***********************************************************************
  *              SetInputScope(MSCTF.@)
  */
diff --git a/dlls/msctf/msctf_internal.h b/dlls/msctf/msctf_internal.h
index 584bb1044ed..ace2bee23d9 100644
--- a/dlls/msctf/msctf_internal.h
+++ b/dlls/msctf/msctf_internal.h
@@ -35,7 +35,6 @@
 #define COOKIE_MAGIC_UIELEMENTSINK 0x00a0
 #define COOKIE_MAGIC_INPUTPROCESSORPROFILEACTIVATIONSINK 0x00b0
 
-extern DWORD tlsIndex DECLSPEC_HIDDEN;
 extern TfClientId processId DECLSPEC_HIDDEN;
 extern ITfCompartmentMgr *globalCompartmentMgr DECLSPEC_HIDDEN;
 
diff --git a/dlls/msctf/threadmgr.c b/dlls/msctf/threadmgr.c
index 2c208fbc04f..2119ea2193b 100644
--- a/dlls/msctf/threadmgr.c
+++ b/dlls/msctf/threadmgr.c
@@ -37,6 +37,17 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msctf);
 
+static CRITICAL_SECTION ThreadMgrCs;
+static CRITICAL_SECTION_DEBUG ThreadMgrCsDebug =
+{
+    0, 0, &ThreadMgrCs,
+    {&ThreadMgrCsDebug.ProcessLocksList,
+     &ThreadMgrCsDebug.ProcessLocksList },
+     0, 0, {(DWORD_PTR)(__FILE__ ": ThreadMgrCs")}
+};
+static CRITICAL_SECTION ThreadMgrCs = {&ThreadMgrCsDebug, -1, 0, 0, 0, 0};
+struct list ThreadMgrList = LIST_INIT(ThreadMgrList);
+
 typedef struct tagPreservedKey
 {
     struct list     entry;
@@ -98,6 +109,9 @@ typedef struct tagACLMulti {
     struct list     ThreadMgrEventSink;
     struct list     UIElementSink;
     struct list     InputProcessorProfileActivationSink;
+
+    DWORD threadId;
+    struct list entry;
 } ThreadMgr;
 
 typedef struct tagEnumTfDocumentMgr {
@@ -110,6 +124,11 @@ typedef struct tagEnumTfDocumentMgr {
 
 static HRESULT EnumTfDocumentMgr_Constructor(struct list* head, IEnumTfDocumentMgrs **ppOut);
 
+static inline ThreadMgr *impl_from_ITfThreadMgr(ITfThreadMgr *iface)
+{
+    return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
+}
+
 static inline ThreadMgr *impl_from_ITfThreadMgrEx(ITfThreadMgrEx *iface)
 {
     return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
@@ -155,6 +174,35 @@ static inline EnumTfDocumentMgr *impl_from_IEnumTfDocumentMgrs(IEnumTfDocumentMg
     return CONTAINING_RECORD(iface, EnumTfDocumentMgr, IEnumTfDocumentMgrs_iface);
 }
 
+/***********************************************************************
+ *              TF_GetThreadMgr (MSCTF.@)
+ */
+HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
+{
+    DWORD id = GetCurrentThreadId();
+    ThreadMgr *cursor;
+
+    TRACE("%p\n", pptim);
+
+    if (!pptim)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&ThreadMgrCs);
+    LIST_FOR_EACH_ENTRY(cursor, &ThreadMgrList, ThreadMgr, entry)
+    {
+        if (cursor->threadId == id)
+        {
+            ITfThreadMgrEx_AddRef(&cursor->ITfThreadMgrEx_iface);
+            *pptim = (ITfThreadMgr *)&cursor->ITfThreadMgrEx_iface;
+            LeaveCriticalSection(&ThreadMgrCs);
+            return S_OK;
+        }
+    }
+    LeaveCriticalSection(&ThreadMgrCs);
+    *pptim = NULL;
+    return E_FAIL;
+}
+
 static void ThreadMgr_Destructor(ThreadMgr *This)
 {
     struct list *cursor, *cursor2;
@@ -163,7 +211,9 @@ static void ThreadMgr_Destructor(ThreadMgr *This)
     if (This->focusHook)
         UnhookWindowsHookEx(This->focusHook);
 
-    TlsSetValue(tlsIndex,NULL);
+    EnterCriticalSection(&ThreadMgrCs);
+    list_remove(&This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
     TRACE("destroying %p\n", This);
     if (This->focus)
         ITfDocumentMgr_Release(This->focus);
@@ -386,17 +436,20 @@ static HRESULT WINAPI ThreadMgr_SetFocus(ITfThreadMgrEx *iface, ITfDocumentMgr *
 
 static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lParam)
 {
+    ITfThreadMgr *ThreadMgr_iface;
     ThreadMgr *This;
 
-    This = TlsGetValue(tlsIndex);
-    if (!This)
+    if (FAILED(TF_GetThreadMgr(&ThreadMgr_iface)))
     {
         ERR("Hook proc but no ThreadMgr for this thread. Serious Error\n");
         return 0;
     }
+
+    This = impl_from_ITfThreadMgr(ThreadMgr_iface);
     if (!This->focusHook)
     {
         ERR("Hook proc but no ThreadMgr focus Hook. Serious Error\n");
+        ITfThreadMgr_Release(ThreadMgr_iface);
         return 0;
     }
 
@@ -417,6 +470,7 @@ static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lPa
         }
     }
 
+    ITfThreadMgr_Release(ThreadMgr_iface);
     return CallNextHookEx(This->focusHook, nCode, wParam, lParam);
 }
 
@@ -1338,13 +1392,8 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
         return CLASS_E_NOAGGREGATION;
 
     /* Only 1 ThreadMgr is created per thread */
-    This = TlsGetValue(tlsIndex);
-    if (This)
-    {
-        ThreadMgr_AddRef(&This->ITfThreadMgrEx_iface);
-        *ppOut = (IUnknown*)&This->ITfThreadMgrEx_iface;
+    if (SUCCEEDED(TF_GetThreadMgr((ITfThreadMgr **)ppOut)))
         return S_OK;
-    }
 
     This = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(ThreadMgr));
     if (This == NULL)
@@ -1359,7 +1408,6 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     This->ITfUIElementMgr_iface.lpVtbl = &ThreadMgrUIElementMgrVtbl;
     This->ITfSourceSingle_iface.lpVtbl = &SourceSingleVtbl;
     This->refCount = 1;
-    TlsSetValue(tlsIndex,This);
 
     CompartmentMgr_Constructor((IUnknown*)&This->ITfThreadMgrEx_iface, &IID_IUnknown, (IUnknown**)&This->CompartmentMgr);
 
@@ -1376,6 +1424,11 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     list_init(&This->UIElementSink);
     list_init(&This->InputProcessorProfileActivationSink);
 
+    This->threadId = GetCurrentThreadId();
+    EnterCriticalSection(&ThreadMgrCs);
+    list_add_tail(&ThreadMgrList, &This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
+
     TRACE("returning %p\n", This);
     *ppOut = (IUnknown *)&This->ITfThreadMgrEx_iface;
     return S_OK;
From 57f18487fb073df1adf3fcdb0726175d530aa737 Mon Sep 17 00:00:00 2001
From: Juuso Alasuutari <juuso.alasuutari@gmail.com>
Date: Sun, 18 Aug 2019 09:27:13 +0300
Subject: [PATCH] kernel32: Ensure that the loader lock is released before
 returning from GetModuleHandleExW().

Signed-off-by: Juuso Alasuutari <juuso.alasuutari@gmail.com>
Reviewed-by: Richard Yao <ryao@gentoo.org>
---
 dlls/kernel32/module.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 9ae687cb840..4289f20d3c2 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -479,6 +479,8 @@ BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
         UNICODE_STRING wstr;
         if(steamclient_hmod != NULL && strcasestrW(name, steamclientW)){
             *module = steamclient_hmod;
+            if (lock)
+                LdrUnlockLoaderLock( 0, magic );
             return TRUE;
         }
         RtlInitUnicodeString( &wstr, name );

From ed04e35d3f7af02267fb4e21578b3ccb27703836 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 23 Sep 2019 13:29:16 -0500
Subject: [PATCH] dxdiag: Dump to stdout if no filename is given

---
 programs/dxdiag/main.c   |  8 +++++++-
 programs/dxdiag/output.c | 10 +++++++---
 2 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/programs/dxdiag/main.c b/programs/dxdiag/main.c
index 4533236f0f5..353e9f50fb9 100644
--- a/programs/dxdiag/main.c
+++ b/programs/dxdiag/main.c
@@ -71,7 +71,13 @@ static BOOL process_file_name(const WCHAR *cmdline, enum output_type output_type
         endptr = cmdline + lstrlenW(cmdline);
 
     len = endptr - cmdline;
-    if (len == 0 || len >= filename_len)
+    if (len == 0)
+    {
+        *filename = 0;
+        return TRUE;
+    }
+
+    if (len >= filename_len)
         return FALSE;
 
     memcpy(filename, cmdline, len * sizeof(WCHAR));
diff --git a/programs/dxdiag/output.c b/programs/dxdiag/output.c
index 50240fb2860..f0f6a6da0c3 100644
--- a/programs/dxdiag/output.c
+++ b/programs/dxdiag/output.c
@@ -169,8 +169,12 @@ static BOOL output_text_information(struct dxdiag_information *dxdiag_info, cons
 
     fill_system_text_output_table(dxdiag_info, output_table[0].fields);
 
-    hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
-                        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (filename && *filename)
+        hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    else
+        hFile = GetStdHandle(STD_OUTPUT_HANDLE);
+
     if (hFile == INVALID_HANDLE_VALUE)
     {
         WINE_ERR("File creation failed, last error %u\n", GetLastError());
@@ -227,7 +231,7 @@ static HRESULT save_xml_document(IXMLDOMDocument *xmldoc, const WCHAR *filename)
     VARIANT destVar;
     HRESULT hr;
 
-    if (!bstr)
+    if (!bstr || !filename || !*filename)
         return E_OUTOFMEMORY;
 
     V_VT(&destVar) = VT_BSTR;
From e485252dfad51a7e463643d56fe138129597e4b6 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 23 Sep 2019 08:56:04 -0500
Subject: [PATCH] ntdll: Always add a tail to heap allocations.

Fixes the Rockstar Games Launcher installer (and possibly other
NSIS-based installers) from crashing due to passing a too-small buffer
to GetWindowInfo().
---
 dlls/ntdll/heap.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index 6344157f384..6fefe5d6d80 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -118,9 +118,8 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
 #define HEAP_MIN_SHRINK_SIZE  (HEAP_MIN_DATA_SIZE+sizeof(ARENA_FREE))
 /* minimum size to start allocating large blocks */
 #define HEAP_MIN_LARGE_BLOCK_SIZE  0x7f000
-/* extra size to add at the end of block for tail checking */
-#define HEAP_TAIL_EXTRA_SIZE(flags) \
-    ((flags & HEAP_TAIL_CHECKING_ENABLED) || RUNNING_ON_VALGRIND ? ALIGNMENT : 0)
+/* extra size to add at the end of block to mitigate overruns and allow tail checking */
+#define HEAP_TAIL_EXTRA_SIZE ALIGNMENT
 
 /* size of the blocks on the free lists */
 #define HEAP_FREELIST_SIZE(index) \
@@ -800,7 +799,7 @@ static void HEAP_ShrinkBlock(SUBHEAP *subheap, ARENA_INUSE *pArena, SIZE_T size)
 static void *allocate_large_block( HEAP *heap, DWORD flags, SIZE_T size )
 {
     ARENA_LARGE *arena;
-    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     LPVOID address = NULL;
 
     if (block_size < size) return NULL;  /* overflow */
@@ -1814,7 +1813,7 @@ void * WINAPI DECLSPEC_HOTPATCH RtlAllocateHeap( HANDLE heap, ULONG flags, SIZE_
     if (!heapPtr) return NULL;
     flags &= HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY;
     flags |= heapPtr->flags;
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE( flags );
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size)  /* overflow */
     {
         if (flags & HEAP_GENERATE_EXCEPTIONS) RtlRaiseStatus( STATUS_NO_MEMORY );
@@ -1968,7 +1967,7 @@ PVOID WINAPI RtlReAllocateHeap( HANDLE heap, ULONG flags, PVOID ptr, SIZE_T size
     flags |= heapPtr->flags;
     if (!(flags & HEAP_NO_SERIALIZE)) RtlEnterCriticalSection( &heapPtr->critSection );
 
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size) goto oom;  /* overflow */
     if (rounded_size < HEAP_MIN_DATA_SIZE) rounded_size = HEAP_MIN_DATA_SIZE;
