From 7cfff233776a82a119b94b8c9c007370cd13d5df Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Wed, 6 Nov 2019 10:38:55 +0100
Subject: ntdll


diff --git a/dlls/ntdll/env.c b/dlls/ntdll/env.c
index 6931cb6e04..919fc64e2f 100644
--- a/dlls/ntdll/env.c
+++ b/dlls/ntdll/env.c
@@ -1149,31 +1149,19 @@ void init_user_process_params( SIZE_T data_size )
 
     if (!data_size)
     {
-        RTL_USER_PROCESS_PARAMETERS initial_params = {0};
-        WCHAR *env, curdir_buffer[MAX_PATH];
-
-        NtCurrentTeb()->Peb->ProcessParameters = &initial_params;
-        initial_params.Environment = build_initial_environment( __wine_get_main_environment() );
-        curdir.Buffer = curdir_buffer;
-        curdir.MaximumLength = sizeof(curdir_buffer);
-        get_current_directory( &curdir );
-        initial_params.CurrentDirectory.DosPath = curdir;
-        get_image_path( __wine_main_argv[0], &initial_params.ImagePathName );
-        set_library_wargv( __wine_main_argv, &initial_params.ImagePathName );
-        build_command_line( __wine_main_wargv, &cmdline );
-        LdrGetDllPath( initial_params.ImagePathName.Buffer, 0, &load_path, &dummy );
-        RtlInitUnicodeString( &dllpath, load_path );
-
-        env = initial_params.Environment;
-        initial_params.Environment = NULL;  /* avoid copying it */
-        if (RtlCreateProcessParametersEx( &params, &initial_params.ImagePathName, &dllpath, &curdir,
-                                          &cmdline, NULL, &initial_params.ImagePathName, NULL, NULL, NULL,
+        if (RtlCreateProcessParametersEx( &params, &null_str, &null_str, &empty_str, &null_str, NULL,
+                                          &null_str, &null_str, &null_str, &null_str,
                                           PROCESS_PARAMS_FLAG_NORMALIZED ))
             return;
 
-        params->Environment = env;
         NtCurrentTeb()->Peb->ProcessParameters = params;
-        RtlFreeUnicodeString( &cmdline );
+        params->Environment = build_initial_environment( __wine_get_main_environment() );
+        get_current_directory( &params->CurrentDirectory.DosPath );
+        get_image_path( __wine_main_argv[0], &params->ImagePathName );
+        set_library_wargv( __wine_main_argv, &params->ImagePathName );
+        build_command_line( __wine_main_wargv, &params->CommandLine );
+        LdrGetDllPath( params->ImagePathName.Buffer, 0, &load_path, &dummy );
+        RtlCreateUnicodeString( &params->DllPath, load_path );
         RtlReleasePath( load_path );
 
         if (isatty(0) || isatty(1) || isatty(2))
@@ -1256,3 +1244,44 @@ done:
         RtlSetCurrentDirectory_U( &curdir );
     }
 }
+
+
+/***********************************************************************
+ *           update_user_process_params
+ *
+ * Rebuild the RTL_USER_PROCESS_PARAMETERS structure once we have initialized all the fields.
+ */
+void update_user_process_params( const UNICODE_STRING *image )
+{
+    RTL_USER_PROCESS_PARAMETERS *params, *cur_params = NtCurrentTeb()->Peb->ProcessParameters;
+    UNICODE_STRING title = cur_params->WindowTitle;
+    WCHAR *env = cur_params->Environment;
+
+    cur_params->Environment = NULL;  /* avoid copying it */
+    if (!title.Buffer) title = *image;
+    if (RtlCreateProcessParametersEx( &params, image, &cur_params->DllPath, NULL,
+                                      &cur_params->CommandLine, NULL, &title, &cur_params->Desktop,
+                                      &cur_params->ShellInfo, &cur_params->RuntimeInfo,
+                                      PROCESS_PARAMS_FLAG_NORMALIZED ))
+        return;
+
+    params->DebugFlags      = cur_params->DebugFlags;
+    params->ConsoleHandle   = cur_params->ConsoleHandle;
+    params->ConsoleFlags    = cur_params->ConsoleFlags;
+    params->hStdInput       = cur_params->hStdInput;
+    params->hStdOutput      = cur_params->hStdOutput;
+    params->hStdError       = cur_params->hStdError;
+    params->dwX             = cur_params->dwX;
+    params->dwY             = cur_params->dwY;
+    params->dwXSize         = cur_params->dwXSize;
+    params->dwYSize         = cur_params->dwYSize;
+    params->dwXCountChars   = cur_params->dwXCountChars;
+    params->dwYCountChars   = cur_params->dwYCountChars;
+    params->dwFillAttribute = cur_params->dwFillAttribute;
+    params->dwFlags         = cur_params->dwFlags;
+    params->wShowWindow     = cur_params->wShowWindow;
+    params->Environment     = env;
+
+    RtlFreeHeap( GetProcessHeap(), 0, cur_params );
+    NtCurrentTeb()->Peb->ProcessParameters = params;
+}
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index dc5870aa7f..972f76d7b3 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -4620,6 +4620,7 @@ void __wine_process_init(void)
     }
 
     NtCurrentTeb()->Peb->LoaderLock = &loader_section;
+    update_user_process_params( &wm->ldr.FullDllName );
     version_init( wm->ldr.FullDllName.Buffer );
     user_shared_data_init();
     hidden_exports_init( wm->ldr.FullDllName.Buffer );
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index 01e9087a60..3ebbf1a62e 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -88,6 +88,7 @@ extern void virtual_init_threading(void) DECLSPEC_HIDDEN;
 extern void fill_cpu_info(void) DECLSPEC_HIDDEN;
 extern void heap_set_debug_flags( HANDLE handle ) DECLSPEC_HIDDEN;
 extern void init_user_process_params( SIZE_T data_size ) DECLSPEC_HIDDEN;
+extern void update_user_process_params( const UNICODE_STRING *image ) DECLSPEC_HIDDEN;
 
 /* token */
 extern HANDLE CDECL __wine_create_default_token(BOOL admin);

From fdc66a9a22cc689b90123524dce8457718ade72e Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Wed, 23 Oct 2019 03:51:13 +0200
Subject: Revert fd3735c, 2607bfa, ee56be3, 075741b, cac9599

diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 36ed82bff8..ec50ddba06 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -37,6 +37,9 @@
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
+#ifdef HAVE_SYS_PRCTL_H
+# include <sys/prctl.h>
+#endif
 #include <sys/types.h>
 #ifdef HAVE_SYS_WAIT_H
 # include <sys/wait.h>
@@ -835,28 +838,45 @@ static void set_wow64_environment(void)
 }
 
 /***********************************************************************
- *              set_library_argv
+ *              set_library_wargv
  *
- * Set the Wine library argv global variables.
+ * Set the Wine library Unicode argv global variables.
  */
-static void set_library_argv( WCHAR **wargv )
+static void set_library_wargv( char **argv )
 {
     int argc;
-    char *p, **argv;
+    char *q;
+    WCHAR *p;
+    WCHAR **wargv;
     DWORD total = 0;
 
+    for (argc = 0; argv[argc]; argc++)
+        total += MultiByteToWideChar( CP_UNIXCP, 0, argv[argc], -1, NULL, 0 );
+
+    wargv = RtlAllocateHeap( GetProcessHeap(), 0,
+                             total * sizeof(WCHAR) + (argc + 1) * sizeof(*wargv) );
+    p = (WCHAR *)(wargv + argc + 1);
+    for (argc = 0; argv[argc]; argc++)
+    {
+        DWORD reslen = MultiByteToWideChar( CP_UNIXCP, 0, argv[argc], -1, p, total );
+        wargv[argc] = p;
+        p += reslen;
+        total -= reslen;
+    }
+    wargv[argc] = NULL;
+
     /* convert argv back from Unicode since it has to be in the Ansi codepage not the Unix one */
 
     for (argc = 0; wargv[argc]; argc++)
         total += WideCharToMultiByte( CP_ACP, 0, wargv[argc], -1, NULL, 0, NULL, NULL );
 
     argv = RtlAllocateHeap( GetProcessHeap(), 0, total + (argc + 1) * sizeof(*argv) );
-    p = (char *)(argv + argc + 1);
+    q = (char *)(argv + argc + 1);
     for (argc = 0; wargv[argc]; argc++)
     {
-        DWORD reslen = WideCharToMultiByte( CP_ACP, 0, wargv[argc], -1, p, total, NULL, NULL );
-        argv[argc] = p;
-        p += reslen;
+        DWORD reslen = WideCharToMultiByte( CP_ACP, 0, wargv[argc], -1, q, total, NULL, NULL );
+        argv[argc] = q;
+        q += reslen;
         total -= reslen;
     }
     argv[argc] = NULL;
@@ -867,6 +887,173 @@ static void set_library_argv( WCHAR **wargv )
 }
 
 
+/***********************************************************************
+ *              update_library_argv0
+ *
+ * Update the argv[0] global variable with the binary we have found.
+ */
+static void update_library_argv0( const WCHAR *argv0 )
+{
+    DWORD len = strlenW( argv0 );
+
+    if (len > strlenW( __wine_main_wargv[0] ))
+    {
+        __wine_main_wargv[0] = RtlAllocateHeap( GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR) );
+    }
+    strcpyW( __wine_main_wargv[0], argv0 );
+
+    len = WideCharToMultiByte( CP_ACP, 0, argv0, -1, NULL, 0, NULL, NULL );
+    if (len > strlen( __wine_main_argv[0] ) + 1)
+    {
+        __wine_main_argv[0] = RtlAllocateHeap( GetProcessHeap(), 0, len );
+    }
+    WideCharToMultiByte( CP_ACP, 0, argv0, -1, __wine_main_argv[0], len, NULL, NULL );
+}
+
+
+/***********************************************************************
+ *           build_command_line
+ *
+ * Build the command line of a process from the argv array.
+ *
+ * Note that it does NOT necessarily include the file name.
+ * Sometimes we don't even have any command line options at all.
+ *
+ * We must quote and escape characters so that the argv array can be rebuilt
+ * from the command line:
+ * - spaces and tabs must be quoted
+ *   'a b'   -> '"a b"'
+ * - quotes must be escaped
+ *   '"'     -> '\"'
+ * - if '\'s are followed by a '"', they must be doubled and followed by '\"',
+ *   resulting in an odd number of '\' followed by a '"'
+ *   '\"'    -> '\\\"'
+ *   '\\"'   -> '\\\\\"'
+ * - '\'s are followed by the closing '"' must be doubled,
+ *   resulting in an even number of '\' followed by a '"'
+ *   ' \'    -> '" \\"'
+ *   ' \\'    -> '" \\\\"'
+ * - '\'s that are not followed by a '"' can be left as is
+ *   'a\b'   == 'a\b'
+ *   'a\\b'  == 'a\\b'
+ */
+static BOOL build_command_line( WCHAR **argv )
+{
+    int len;
+    WCHAR **arg;
+    LPWSTR p;
+    RTL_USER_PROCESS_PARAMETERS* rupp = NtCurrentTeb()->Peb->ProcessParameters;
+
+    if (rupp->CommandLine.Buffer) return TRUE; /* already got it from the server */
+
+    len = 0;
+    for (arg = argv; *arg; arg++)
+    {
+        BOOL has_space;
+        int bcount;
+        WCHAR* a;
+
+        has_space=FALSE;
+        bcount=0;
+        a=*arg;
+        if( arg == argv || !*a ) has_space=TRUE;
+        while (*a!='\0') {
+            if (*a=='\\') {
+                bcount++;
+            } else {
+                if (*a==' ' || *a=='\t') {
+                    has_space=TRUE;
+                } else if (*a=='"') {
+                    /* doubling of '\' preceding a '"',
+                     * plus escaping of said '"'
+                     */
+                    len+=2*bcount+1;
+                }
+                bcount=0;
+            }
+            a++;
+        }
+        len+=(a-*arg)+1 /* for the separating space */;
+        if (has_space)
+            len+=2+bcount; /* for the quotes and doubling of '\' preceding the closing quote */
+    }
+
+    if (!(rupp->CommandLine.Buffer = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR))))
+        return FALSE;
+
+    p = rupp->CommandLine.Buffer;
+    rupp->CommandLine.Length = (len - 1) * sizeof(WCHAR);
+    rupp->CommandLine.MaximumLength = len * sizeof(WCHAR);
+    for (arg = argv; *arg; arg++)
+    {
+        BOOL has_space,has_quote;
+        WCHAR* a;
+        int bcount;
+
+        /* Check for quotes and spaces in this argument */
+        has_space=has_quote=FALSE;
+        a=*arg;
+        if( arg == argv || !*a ) has_space=TRUE;
+        while (*a!='\0') {
+            if (*a==' ' || *a=='\t') {
+                has_space=TRUE;
+                if (has_quote)
+                    break;
+            } else if (*a=='"') {
+                has_quote=TRUE;
+                if (has_space)
+                    break;
+            }
+            a++;
+        }
+
+        /* Now transfer it to the command line */
+        if (has_space)
+            *p++='"';
+        if (has_quote || has_space) {
+            bcount=0;
+            a=*arg;
+            while (*a!='\0') {
+                if (*a=='\\') {
+                    *p++=*a;
+                    bcount++;
+                } else {
+                    if (*a=='"') {
+                        int i;
+
+                        /* Double all the '\\' preceding this '"', plus one */
+                        for (i=0;i<=bcount;i++)
+                            *p++='\\';
+                        *p++='"';
+                    } else {
+                        *p++=*a;
+                    }
+                    bcount=0;
+                }
+                a++;
+            }
+        } else {
+            WCHAR* x = *arg;
+            while ((*p=*x++)) p++;
+        }
+        if (has_space) {
+            int i;
+
+            /* Double all the '\' preceding the closing quote */
+            for (i=0;i<bcount;i++)
+                *p++='\\';
+            *p++='"';
+        }
+        *p++=' ';
+    }
+    if (p > rupp->CommandLine.Buffer)
+        p--;  /* remove last space */
+    *p = '\0';
+
+    return TRUE;
+}
+
+
 /***********************************************************************
  *           init_windows_dirs
  */
@@ -1013,6 +1200,68 @@ void WINAPI start_process( LPTHREAD_START_ROUTINE entry, PEB *peb )
 }
 
 
+/***********************************************************************
+ *           set_process_name
+ *
+ * Change the process name in the ps output.
+ */
+static void set_process_name( int argc, char *argv[] )
+{
+    BOOL shift_strings;
+    char *p, *name;
+    int i;
+
+#ifdef HAVE_SETPROCTITLE
+    setproctitle("-%s", argv[1]);
+    shift_strings = FALSE;
+#else
+    p = argv[0];
+
+    shift_strings = (argc >= 2);
+    for (i = 1; i < argc; i++)
+    {
+        p += strlen(p) + 1;
+        if (p != argv[i])
+        {
+            shift_strings = FALSE;
+            break;
+        }
+    }
+#endif
+
+    if (shift_strings)
+    {
+        int offset = argv[1] - argv[0];
+        char *end = argv[argc-1] + strlen(argv[argc-1]) + 1;
+        memmove( argv[0], argv[1], end - argv[1] );
+        memset( end - offset, 0, offset );
+        for (i = 1; i < argc; i++)
+            argv[i-1] = argv[i] - offset;
+        argv[i-1] = NULL;
+    }
+    else
+    {
+        /* remove argv[0] */
+        memmove( argv, argv + 1, argc * sizeof(argv[0]) );
+    }
+
+    name = argv[0];
+    if ((p = strrchr( name, '\\' ))) name = p + 1;
+    if ((p = strrchr( name, '/' ))) name = p + 1;
+
+#if defined(HAVE_SETPROGNAME)
+    setprogname( name );
+#endif
+
+#ifdef HAVE_PRCTL
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+    prctl( PR_SET_NAME, name );
+#endif  /* HAVE_PRCTL */
+}
+
+
 /***********************************************************************
  *           __wine_kernel_init
  *
@@ -1028,6 +1277,7 @@ void * CDECL __wine_kernel_init(void)
     RTL_USER_PROCESS_PARAMETERS *params = peb->ProcessParameters;
     HANDLE boot_events[2];
     BOOL got_environment = TRUE;
+    WCHAR *load_path, *dummy;
 
     /* Initialize everything */
 
@@ -1038,25 +1288,51 @@ void * CDECL __wine_kernel_init(void)
     RtlSetUnhandledExceptionFilter( UnhandledExceptionFilter );
 
     LOCALE_Init();
-    init_windows_dirs();
-    boot_events[0] = boot_events[1] = 0;
 
     if (!peb->ProcessParameters->WindowTitle.Buffer)
     {
         /* convert old configuration to new format */
         convert_old_config();
         got_environment = has_registry_environment();
+    }
+
+    init_windows_dirs();
+
+    set_process_name( __wine_main_argc, __wine_main_argv );
+    set_library_wargv( __wine_main_argv );
+    boot_events[0] = boot_events[1] = 0;
+
+    if (peb->ProcessParameters->ImagePathName.Buffer)
+    {
+        strcpyW( main_exe_name, peb->ProcessParameters->ImagePathName.Buffer );
+    }
+    else
+    {
+        BOOL is_64bit;
+
+        RtlGetExePath( __wine_main_wargv[0], &load_path );
+        if (!SearchPathW( load_path, __wine_main_wargv[0], exeW, MAX_PATH, main_exe_name, NULL ) &&
+            !get_builtin_path( __wine_main_wargv[0], exeW, main_exe_name, MAX_PATH, &is_64bit ))
+        {
+            MESSAGE( "wine: cannot find '%s'\n", __wine_main_argv[0] );
+            ExitProcess( GetLastError() );
+        }
+        RtlReleasePath( load_path );
+        update_library_argv0( main_exe_name );
+        if (!build_command_line( __wine_main_wargv )) goto error;
         start_wineboot( boot_events );
     }
 
     /* if there's no extension, append a dot to prevent LoadLibrary from appending .dll */
-    strcpyW( main_exe_name, peb->ProcessParameters->ImagePathName.Buffer );
     p = strrchrW( main_exe_name, '.' );
     if (!p || strchrW( p, '/' ) || strchrW( p, '\\' )) strcatW( main_exe_name, dotW );
 
     TRACE( "starting process name=%s argv[0]=%s\n",
            debugstr_w(main_exe_name), debugstr_w(__wine_main_wargv[0]) );
 
+    LdrGetDllPath( main_exe_name, 0, &load_path, &dummy );
+    RtlInitUnicodeString( &NtCurrentTeb()->Peb->ProcessParameters->DllPath, load_path );
+
     if (boot_events[0])
     {
         DWORD timeout = 2 * 60 * 1000, count = 1;
@@ -1072,7 +1348,6 @@ void * CDECL __wine_kernel_init(void)
         set_additional_environment();
     }
     set_wow64_environment();
-    set_library_argv( __wine_main_wargv );
 
     if (!(peb->ImageBaseAddress = LoadLibraryExW( main_exe_name, 0, DONT_RESOLVE_DLL_REFERENCES )))
     {
@@ -1112,6 +1387,9 @@ void * CDECL __wine_kernel_init(void)
     if (!params->CurrentDirectory.Handle) chdir("/"); /* avoid locking removable devices */
 
     return start_process_wrapper;
+
+ error:
+    ExitProcess( GetLastError() );
 }
 
 
diff --git a/dlls/ntdll/env.c b/dlls/ntdll/env.c
index 919fc64e2f..1b7d848f30 100644
--- a/dlls/ntdll/env.c
+++ b/dlls/ntdll/env.c
@@ -47,8 +47,6 @@ static WCHAR empty[] = {0};
 static const UNICODE_STRING empty_str = { 0, sizeof(empty), empty };
 static const UNICODE_STRING null_str = { 0, 0, NULL };
 
-static const BOOL is_win64 = (sizeof(void *) > sizeof(int));
-
 static const WCHAR windows_dir[] = {'C',':','\\','w','i','n','d','o','w','s',0};
 
 static inline SIZE_T get_env_length( const WCHAR *env )
@@ -442,201 +440,6 @@ static void get_current_directory( UNICODE_STRING *dir )
 }
 
 
-/***********************************************************************
- *           is_path_prefix
- */
-static inline BOOL is_path_prefix( const WCHAR *prefix, const WCHAR *path, const WCHAR *file )
-{
-    DWORD len = strlenW( prefix );
-
-    if (strncmpiW( path, prefix, len )) return FALSE;
-    while (path[len] == '\\') len++;
-    return path + len == file;
-}
-
-
-/***********************************************************************
- *           get_image_path
- */
-static void get_image_path( const char *argv0, UNICODE_STRING *path )
-{
-    static const WCHAR exeW[] = {'.','e','x','e',0};
-    WCHAR *load_path, *file_part, *name, full_name[MAX_PATH];
-    DWORD len;
-
-    len = ntdll_umbstowcs( 0, argv0, strlen(argv0) + 1, NULL, 0 );
-    if (!(name = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) ))) goto failed;
-    ntdll_umbstowcs( 0, argv0, strlen(argv0) + 1, name, len );
-
-    if (RtlDetermineDosPathNameType_U( name ) != RELATIVE_PATH ||
-        strchrW( name, '/' ) || strchrW( name, '\\' ))
-    {
-        len = RtlGetFullPathName_U( name, sizeof(full_name), full_name, &file_part );
-        if (!len || len > sizeof(full_name)) goto failed;
-        /* try first without extension */
-        if (RtlDoesFileExists_U( full_name )) goto done;
-        if (len < (MAX_PATH - 4) * sizeof(WCHAR) && !strchrW( file_part, '.' ))
-        {
-            strcatW( file_part, exeW );
-            if (RtlDoesFileExists_U( full_name )) goto done;
-        }
-        /* check for builtin path inside system directory */
-        if (!is_path_prefix( system_dir, full_name, file_part ))
-        {
-            if (!is_win64 && !is_wow64) goto failed;
-            if (!is_path_prefix( syswow64_dir, full_name, file_part )) goto failed;
-        }
-    }
-    else
-    {
-        RtlGetExePath( name, &load_path );
-        len = RtlDosSearchPath_U( load_path, name, exeW, sizeof(full_name), full_name, &file_part );
-        RtlReleasePath( load_path );
-        if (!len || len > sizeof(full_name))
-        {
-            /* build builtin path inside system directory */
-            len = strlenW( system_dir );
-            if (strlenW( name ) >= MAX_PATH - 4 - len) goto failed;
-            strcpyW( full_name, system_dir );
-            strcatW( full_name, name );
-            if (!strchrW( name, '.' )) strcatW( full_name, exeW );
-        }
-    }
-done:
-    RtlCreateUnicodeString( path, full_name );
-    RtlFreeHeap( GetProcessHeap(), 0, name );
-    return;
-
-failed:
-    MESSAGE( "wine: cannot find '%s'\n", argv0 );
-    RtlExitUserProcess( GetLastError() );
-}
-
-
-/***********************************************************************
- *              set_library_wargv
- *
- * Set the Wine library Unicode argv global variables.
- */
-static void set_library_wargv( char **argv, const UNICODE_STRING *image )
-{
-    int argc;
-    WCHAR *p, **wargv;
-    DWORD total = 0;
-
-    if (image) total += 1 + image->Length / sizeof(WCHAR);
-    for (argc = (image != NULL); argv[argc]; argc++)
-        total += ntdll_umbstowcs( 0, argv[argc], strlen(argv[argc]) + 1, NULL, 0 );
-
-    wargv = RtlAllocateHeap( GetProcessHeap(), 0,
-                             total * sizeof(WCHAR) + (argc + 1) * sizeof(*wargv) );
-    p = (WCHAR *)(wargv + argc + 1);
-    if (image)
-    {
-        strcpyW( p, image->Buffer );
-        wargv[0] = p;
-        p += 1 + image->Length / sizeof(WCHAR);
-        total -= 1 + image->Length / sizeof(WCHAR);
-    }
-    for (argc = (image != NULL); argv[argc]; argc++)
-    {
-        DWORD reslen = ntdll_umbstowcs( 0, argv[argc], strlen(argv[argc]) + 1, p, total );
-        wargv[argc] = p;
-        p += reslen;
-        total -= reslen;
-    }
-    wargv[argc] = NULL;
-
-    __wine_main_argc = argc;
-    __wine_main_wargv = wargv;
-}
-
-
-/***********************************************************************
- *           build_command_line
- *
- * Build the command line of a process from the argv array.
- *
- * Note that it does NOT necessarily include the file name.
- * Sometimes we don't even have any command line options at all.
- *
- * We must quote and escape characters so that the argv array can be rebuilt
- * from the command line:
- * - spaces and tabs must be quoted
- *   'a b'   -> '"a b"'
- * - quotes must be escaped
- *   '"'     -> '\"'
- * - if '\'s are followed by a '"', they must be doubled and followed by '\"',
- *   resulting in an odd number of '\' followed by a '"'
- *   '\"'    -> '\\\"'
- *   '\\"'   -> '\\\\\"'
- * - '\'s are followed by the closing '"' must be doubled,
- *   resulting in an even number of '\' followed by a '"'
- *   ' \'    -> '" \\"'
- *   ' \\'    -> '" \\\\"'
- * - '\'s that are not followed by a '"' can be left as is
- *   'a\b'   == 'a\b'
- *   'a\\b'  == 'a\\b'
- */
-static void build_command_line( WCHAR **argv, UNICODE_STRING *cmdline )
-{
-    int len;
-    WCHAR **arg;
-    LPWSTR p;
-
-    len = 1;
-    for (arg = argv; *arg; arg++) len += 3 + 2 * strlenW( *arg );
-    cmdline->MaximumLength = len * sizeof(WCHAR);
-    if (!(cmdline->Buffer = RtlAllocateHeap( GetProcessHeap(), 0, cmdline->MaximumLength ))) return;
-
-    p = cmdline->Buffer;
-    for (arg = argv; *arg; arg++)
-    {
-        BOOL has_space, has_quote;
-        int i, bcount;
-        WCHAR *a;
-
-        /* check for quotes and spaces in this argument */
-        if (arg == argv || !**arg) has_space = TRUE;
-        else has_space = strchrW( *arg, ' ' ) || strchrW( *arg, '\t' );
-        has_quote = strchrW( *arg, '"' ) != NULL;
-
-        /* now transfer it to the command line */
-        if (has_space) *p++ = '"';
-        if (has_quote || has_space)
-        {
-            bcount = 0;
-            for (a = *arg; *a; a++)
-            {
-                if (*a == '\\') bcount++;
-                else
-                {
-                    if (*a == '"') /* double all the '\\' preceding this '"', plus one */
-                        for (i = 0; i <= bcount; i++) *p++ = '\\';
-                    bcount = 0;
-                }
-                *p++ = *a;
-            }
-        }
-        else
-        {
-            strcpyW( p, *arg );
-            p += strlenW( p );
-        }
-        if (has_space)
-        {
-            /* Double all the '\' preceding the closing quote */
-            for (i = 0; i < bcount; i++) *p++ = '\\';
-            *p++ = '"';
-        }
-        *p++ = ' ';
-    }
-    if (p > cmdline->Buffer) p--;  /* remove last space */
-    *p = 0;
-    cmdline->Length = (p - cmdline->Buffer) * sizeof(WCHAR);
-}
-
-
 /******************************************************************************
  *  NtQuerySystemEnvironmentValue		[NTDLL.@]
  */
@@ -1140,7 +943,7 @@ static inline void get_unicode_string( UNICODE_STRING *str, WCHAR **src, UINT le
  */
 void init_user_process_params( SIZE_T data_size )
 {
-    WCHAR *src, *load_path, *dummy;
+    WCHAR *src;
     SIZE_T info_size, env_size;
     NTSTATUS status;
     startup_info_t *info = NULL;
@@ -1157,12 +960,6 @@ void init_user_process_params( SIZE_T data_size )
         NtCurrentTeb()->Peb->ProcessParameters = params;
         params->Environment = build_initial_environment( __wine_get_main_environment() );
         get_current_directory( &params->CurrentDirectory.DosPath );
-        get_image_path( __wine_main_argv[0], &params->ImagePathName );
-        set_library_wargv( __wine_main_argv, &params->ImagePathName );
-        build_command_line( __wine_main_wargv, &params->CommandLine );
-        LdrGetDllPath( params->ImagePathName.Buffer, 0, &load_path, &dummy );
-        RtlCreateUnicodeString( &params->DllPath, load_path );
-        RtlReleasePath( load_path );
 
         if (isatty(0) || isatty(1) || isatty(2))
             params->ConsoleHandle = (HANDLE)2; /* see kernel32/kernel_private.h */
@@ -1232,8 +1029,6 @@ void init_user_process_params( SIZE_T data_size )
         else params->Environment[0] = 0;
     }
 
-    set_library_wargv( __wine_main_argv, NULL );
-
 done:
     RtlFreeHeap( GetProcessHeap(), 0, info );
     if (RtlSetCurrentDirectory_U( &params->CurrentDirectory.DosPath ))
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 2bae3c7bd5..e33c24d7af 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -67,8 +67,6 @@ typedef void  (CALLBACK *LDRENUMPROC)(LDR_MODULE *, void *, BOOLEAN *);
 /* system directory with trailing backslash */
 const WCHAR system_dir[] = {'C',':','\\','w','i','n','d','o','w','s','\\',
                             's','y','s','t','e','m','3','2','\\',0};
-const WCHAR syswow64_dir[] = {'C',':','\\','w','i','n','d','o','w','s','\\',
-                              's','y','s','w','o','w','6','4','\\',0};
 
 /* system search path */
 static const WCHAR system_path[] =
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index 20e64c80c7..04aa15636d 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -123,7 +123,6 @@ extern FARPROC SNOOP_GetProcAddress( HMODULE hmod, const IMAGE_EXPORT_DIRECTORY
 extern void RELAY_SetupDLL( HMODULE hmod ) DECLSPEC_HIDDEN;
 extern void SNOOP_SetupDLL( HMODULE hmod ) DECLSPEC_HIDDEN;
 extern const WCHAR system_dir[] DECLSPEC_HIDDEN;
-extern const WCHAR syswow64_dir[] DECLSPEC_HIDDEN;
 
 extern void (WINAPI *kernel32_start_process)(LPTHREAD_START_ROUTINE,void*) DECLSPEC_HIDDEN;
 
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index be54f89082..97bd4bfeb4 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -28,9 +28,6 @@
 #ifdef HAVE_SYS_MMAN_H
 #include <sys/mman.h>
 #endif
-#ifdef HAVE_SYS_PRCTL_H
-# include <sys/prctl.h>
-#endif
 #ifdef HAVE_SYS_TIMES_H
 #include <sys/times.h>
 #endif
@@ -150,69 +147,6 @@ static ULONG_PTR get_image_addr(void)
 }
 #endif
 
-
-/***********************************************************************
- *           set_process_name
- *
- * Change the process name in the ps output.
- */
-static void set_process_name( int argc, char *argv[] )
-{
-    BOOL shift_strings;
-    char *p, *name;
-    int i;
-
-#ifdef HAVE_SETPROCTITLE
-    setproctitle("-%s", argv[1]);
-    shift_strings = FALSE;
-#else
-    p = argv[0];
-
-    shift_strings = (argc >= 2);
-    for (i = 1; i < argc; i++)
-    {
-        p += strlen(p) + 1;
-        if (p != argv[i])
-        {
-            shift_strings = FALSE;
-            break;
-        }
-    }
-#endif
-
-    if (shift_strings)
-    {
-        int offset = argv[1] - argv[0];
-        char *end = argv[argc-1] + strlen(argv[argc-1]) + 1;
-        memmove( argv[0], argv[1], end - argv[1] );
-        memset( end - offset, 0, offset );
-        for (i = 1; i < argc; i++)
-            argv[i-1] = argv[i] - offset;
-        argv[i-1] = NULL;
-    }
-    else
-    {
-        /* remove argv[0] */
-        memmove( argv, argv + 1, argc * sizeof(argv[0]) );
-    }
-
-    name = argv[0];
-    if ((p = strrchr( name, '\\' ))) name = p + 1;
-    if ((p = strrchr( name, '/' ))) name = p + 1;
-
-#if defined(HAVE_SETPROGNAME)
-    setprogname( name );
-#endif
-
-#ifdef HAVE_PRCTL
-#ifndef PR_SET_NAME
-# define PR_SET_NAME 15
-#endif
-    prctl( PR_SET_NAME, name );
-#endif  /* HAVE_PRCTL */
-}
-
-
 /***********************************************************************
  *           thread_init
  *
@@ -311,7 +245,6 @@ void thread_init(void)
         exit(1);
     }
 
-    set_process_name( __wine_main_argc, __wine_main_argv );
     init_directories();
     init_user_process_params( info_size );
 
From 860ec944323ba8435a9df7cb12ab7151a9af29dd Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Tue, 22 Oct 2019 06:31:05 +0200

This reverts commit c258b5ef1100c8c238aab0a17ca743a326829aac

diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index d2682ac83ec..693179fa05a 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -1885,9 +1885,9 @@ static RTL_USER_PROCESS_PARAMETERS *create_process_params( LPCWSTR filename, LPC
                                                            const STARTUPINFOW *startup )
 {
     RTL_USER_PROCESS_PARAMETERS *params;
-    UNICODE_STRING imageW, dllpathW, curdirW, cmdlineW, titleW, desktopW, runtimeW, newdirW;
+    UNICODE_STRING imageW, curdirW, cmdlineW, titleW, desktopW, runtimeW, newdirW;
     WCHAR imagepath[MAX_PATH];
-    WCHAR *load_path, *dummy, *envW = env;
+    WCHAR *envW = env;
 
     if(!GetLongPathNameW( filename, imagepath, MAX_PATH ))
         lstrcpynW( imagepath, filename, MAX_PATH );
@@ -1914,24 +1914,20 @@ static RTL_USER_PROCESS_PARAMETERS *create_process_params( LPCWSTR filename, LPC
         else
             cur_dir = NULL;
     }
-    LdrGetDllPath( imagepath, LOAD_WITH_ALTERED_SEARCH_PATH, &load_path, &dummy );
     RtlInitUnicodeString( &imageW, imagepath );
-    RtlInitUnicodeString( &dllpathW, load_path );
     RtlInitUnicodeString( &curdirW, cur_dir );
     RtlInitUnicodeString( &cmdlineW, cmdline );
     RtlInitUnicodeString( &titleW, startup->lpTitle ? startup->lpTitle : imagepath );
     RtlInitUnicodeString( &desktopW, startup->lpDesktop );
     runtimeW.Buffer = (WCHAR *)startup->lpReserved2;
     runtimeW.Length = runtimeW.MaximumLength = startup->cbReserved2;
-    if (RtlCreateProcessParametersEx( &params, &imageW, &dllpathW, cur_dir ? &curdirW : NULL,
+    if (RtlCreateProcessParametersEx( &params, &imageW, NULL, cur_dir ? &curdirW : NULL,
                                       &cmdlineW, envW, &titleW, &desktopW,
                                       NULL, &runtimeW, PROCESS_PARAMS_FLAG_NORMALIZED ))
     {
-        RtlReleasePath( load_path );
         if (envW != env) HeapFree( GetProcessHeap(), 0, envW );
         return NULL;
     }
-    RtlReleasePath( load_path );
 
     if (flags & CREATE_NEW_PROCESS_GROUP) params->ConsoleFlags = 1;
     if (flags & CREATE_NEW_CONSOLE) params->ConsoleHandle = KERNEL32_CONSOLE_ALLOC;

From 2d049f6e78eaa3eafbb60a884091a6fcd4c7d7be Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Tue, 22 Oct 2019 06:31:01 +0200
Subject: Revert kernelbase: Fix variable name aliasing issue.

This reverts commit 9551cb0b84dc0c0c9c1778cc37d7bafef4fd4299

diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 5b70dfd874a..456a9f2da49 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -114,12 +114,12 @@ static BOOL load_library_as_datafile( LPCWSTR load_path, DWORD flags, LPCWSTR na
 
         if (flags & LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE)
         {
-            struct exclusive_datafile *datafile = HeapAlloc( GetProcessHeap(), 0, sizeof(*datafile) );
-            if (!datafile) goto failed;
-            datafile->module = *mod_ret;
-            datafile->file   = file;
-            list_add_head( &exclusive_datafile_list, &datafile->entry );
-            TRACE( "delaying close %p for module %p\n", datafile->file, datafile->module );
+            struct exclusive_datafile *file = HeapAlloc( GetProcessHeap(), 0, sizeof(*file) );
+            if (!file) goto failed;
+            file->module = *mod_ret;
+            file->file   = file;
+            list_add_head( &exclusive_datafile_list, &file->entry );
+            TRACE( "delaying close %p for module %p\n", file->file, file->module );
             return TRUE;
         }
     }

From 171675e5015b0946ea755d7d2c4182f4cfa5358a Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Sat, 5 Oct 2019 01:33:26 +0200
Subject: Revert kernel32: Move SearchPath functions to kernelbase.

This reverts commit 8d25965e12717b266f2fc74bb10d915234d16772

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 23c25b7acd..1786c876fa 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -1324,8 +1324,8 @@
 @ stdcall -i386 -private -norelay SUnMapLS_IP_EBP_8() krnl386.exe16.SUnMapLS_IP_EBP_8
 @ stdcall -import ScrollConsoleScreenBufferA(long ptr ptr ptr ptr)
 @ stdcall -import ScrollConsoleScreenBufferW(long ptr ptr ptr ptr)
-@ stdcall -import SearchPathA(str str str long ptr ptr)
-@ stdcall -import SearchPathW(wstr wstr wstr long ptr ptr)
+@ stdcall SearchPathA(str str str long ptr ptr)
+@ stdcall SearchPathW(wstr wstr wstr long ptr ptr)
 @ stdcall SetCPGlobal(long)
 @ stdcall SetCalendarInfoA(long long long str)
 @ stdcall SetCalendarInfoW(long long long wstr)
diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
index bbe0fe268f..b580e36756 100644
--- a/dlls/kernel32/path.c
+++ b/dlls/kernel32/path.c
@@ -254,6 +254,300 @@ DWORD WINAPI GetShortPathNameA( LPCSTR longpath, LPSTR shortpath, DWORD shortlen
     return copy_filename_WtoA( shortpathW, shortpath, shortlen );
 }
 
+/***********************************************************************
+ *           contains_pathW
+ *
+ * Check if the file name contains a path; helper for SearchPathW.
+ * A relative path is not considered a path unless it starts with ./ or ../
+ */
+static inline BOOL contains_pathW (LPCWSTR name)
+{
+    if (RtlDetermineDosPathNameType_U( name ) != RELATIVE_PATH) return TRUE;
+    if (name[0] != '.') return FALSE;
+    if (name[1] == '/' || name[1] == '\\') return TRUE;
+    return (name[1] == '.' && (name[2] == '/' || name[2] == '\\'));
+}
+
+/***********************************************************************
+ *	find_actctx_dllpath
+ *
+ * Find the path (if any) of the dll from the activation context.
+ * Returned path doesn't include a name.
+ */
+static NTSTATUS find_actctx_dllpath(const WCHAR *libname, WCHAR **path)
+{
+    static const WCHAR winsxsW[] = {'\\','w','i','n','s','x','s','\\'};
+    static const WCHAR dotManifestW[] = {'.','m','a','n','i','f','e','s','t',0};
+
+    ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION *info;
+    ACTCTX_SECTION_KEYED_DATA data;
+    UNICODE_STRING nameW;
+    NTSTATUS status;
+    SIZE_T needed, size = 1024;
+    WCHAR *p;
+
+    RtlInitUnicodeString( &nameW, libname );
+    data.cbSize = sizeof(data);
+    status = RtlFindActivationContextSectionString( FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX, NULL,
+                                                    ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
+                                                    &nameW, &data );
+    if (status != STATUS_SUCCESS) return status;
+
+    for (;;)
+    {
+        if (!(info = HeapAlloc( GetProcessHeap(), 0, size )))
+        {
+            status = STATUS_NO_MEMORY;
+            goto done;
+        }
+        status = RtlQueryInformationActivationContext( 0, data.hActCtx, &data.ulAssemblyRosterIndex,
+                                                       AssemblyDetailedInformationInActivationContext,
+                                                       info, size, &needed );
+        if (status == STATUS_SUCCESS) break;
+        if (status != STATUS_BUFFER_TOO_SMALL) goto done;
+        HeapFree( GetProcessHeap(), 0, info );
+        size = needed;
+        /* restart with larger buffer */
+    }
+
+    if (!info->lpAssemblyManifestPath || !info->lpAssemblyDirectoryName)
+    {
+        status = STATUS_SXS_KEY_NOT_FOUND;
+        goto done;
+    }
+
+    if ((p = strrchrW( info->lpAssemblyManifestPath, '\\' )))
+    {
+        DWORD dirlen = info->ulAssemblyDirectoryNameLength / sizeof(WCHAR);
+
+        p++;
+        if (strncmpiW( p, info->lpAssemblyDirectoryName, dirlen ) || strcmpiW( p + dirlen, dotManifestW ))
+        {
+            /* manifest name does not match directory name, so it's not a global
+             * windows/winsxs manifest; use the manifest directory name instead */
+            dirlen = p - info->lpAssemblyManifestPath;
+            needed = (dirlen + 1) * sizeof(WCHAR);
+            if (!(*path = p = HeapAlloc( GetProcessHeap(), 0, needed )))
+            {
+                status = STATUS_NO_MEMORY;
+                goto done;
+            }
+            memcpy( p, info->lpAssemblyManifestPath, dirlen * sizeof(WCHAR) );
+            *(p + dirlen) = 0;
+            goto done;
+        }
+    }
+
+    needed = (strlenW( DIR_Windows ) * sizeof(WCHAR) +
+              sizeof(winsxsW) + info->ulAssemblyDirectoryNameLength + 2*sizeof(WCHAR));
+
+    if (!(*path = p = HeapAlloc( GetProcessHeap(), 0, needed )))
+    {
+        status = STATUS_NO_MEMORY;
+        goto done;
+    }
+    strcpyW( p, DIR_Windows );
+    p += strlenW(p);
+    memcpy( p, winsxsW, sizeof(winsxsW) );
+    p += ARRAY_SIZE( winsxsW );
+    memcpy( p, info->lpAssemblyDirectoryName, info->ulAssemblyDirectoryNameLength );
+    p += info->ulAssemblyDirectoryNameLength / sizeof(WCHAR);
+    *p++ = '\\';
+    *p = 0;
+done:
+    HeapFree( GetProcessHeap(), 0, info );
+    RtlReleaseActivationContext( data.hActCtx );
+    return status;
+}
+
+/***********************************************************************
+ * SearchPathW [KERNEL32.@]
+ *
+ * Searches for a specified file in the search path.
+ *
+ * PARAMS
+ *    path	[I] Path to search (NULL means default)
+ *    name	[I] Filename to search for.
+ *    ext	[I] File extension to append to file name. The first
+ *		    character must be a period. This parameter is
+ *                  specified only if the filename given does not
+ *                  contain an extension.
+ *    buflen	[I] size of buffer, in characters
+ *    buffer	[O] buffer for found filename
+ *    lastpart  [O] address of pointer to last used character in
+ *                  buffer (the final '\')
+ *
+ * RETURNS
+ *    Success: length of string copied into buffer, not including
+ *             terminating null character. If the filename found is
+ *             longer than the length of the buffer, the length of the
+ *             filename is returned.
+ *    Failure: Zero
+ *
+ * NOTES
+ *    If the file is not found, calls SetLastError(ERROR_FILE_NOT_FOUND)
+ *    (tested on NT 4.0)
+ */
+DWORD WINAPI SearchPathW( LPCWSTR path, LPCWSTR name, LPCWSTR ext, DWORD buflen,
+                          LPWSTR buffer, LPWSTR *lastpart )
+{
+    DWORD ret = 0;
+
+    if (!name || !name[0])
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return 0;
+    }
+
+    /* If the name contains an explicit path, ignore the path */
+
+    if (contains_pathW(name))
+    {
+        /* try first without extension */
+        if (RtlDoesFileExists_U( name ))
+            return GetFullPathNameW( name, buflen, buffer, lastpart );
+
+        if (ext)
+        {
+            LPCWSTR p = strrchrW( name, '.' );
+            if (p && !strchrW( p, '/' ) && !strchrW( p, '\\' ))
+                ext = NULL;  /* Ignore the specified extension */
+        }
+
+        /* Allocate a buffer for the file name and extension */
+        if (ext)
+        {
+            LPWSTR tmp;
+            DWORD len = strlenW(name) + strlenW(ext);
+
+            if (!(tmp = HeapAlloc( GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR) )))
+            {
+                SetLastError( ERROR_OUTOFMEMORY );
+                return 0;
+            }
+            strcpyW( tmp, name );
+            strcatW( tmp, ext );
+            if (RtlDoesFileExists_U( tmp ))
+                ret = GetFullPathNameW( tmp, buflen, buffer, lastpart );
+            HeapFree( GetProcessHeap(), 0, tmp );
+        }
+    }
+    else if (path && path[0])  /* search in the specified path */
+    {
+        ret = RtlDosSearchPath_U( path, name, ext, buflen * sizeof(WCHAR),
+                                  buffer, lastpart ) / sizeof(WCHAR);
+    }
+    else  /* search in active context and default path */
+    {
+        WCHAR *dll_path = NULL, *search = NULL;
+        DWORD req_len, name_len;
+
+        req_len = name_len = strlenW(name);
+
+        if (strchrW( name, '.' )) ext = NULL;
+        if (ext)
+        {
+            DWORD ext_len = strlenW(ext);
+
+            req_len += ext_len;
+            name_len += ext_len;
+
+            search = HeapAlloc( GetProcessHeap(), 0, (name_len + ext_len + 1) * sizeof(WCHAR) );
+            if (!search)
+            {
+                SetLastError( ERROR_OUTOFMEMORY );
+                return 0;
+            }
+            strcpyW( search, name );
+            strcatW( search, ext );
+            name = search;
+
+            /* now that we have combined name we don't need extension any more */
+        }
+
+        /* When file is found with activation context no attempt is made
+          to check if it's really exist, path is returned only basing on context info. */
+        if (find_actctx_dllpath( name, &dll_path ) == STATUS_SUCCESS)
+        {
+            DWORD path_len;
+
+            path_len = strlenW(dll_path);
+            req_len += path_len;
+
+            if (lastpart) *lastpart = NULL;
+
+            /* count null termination char too */
+            if (req_len + 1 <= buflen)
+            {
+                memcpy( buffer, dll_path, path_len * sizeof(WCHAR) );
+                memcpy( &buffer[path_len], name, name_len * sizeof(WCHAR) );
+                buffer[req_len] = 0;
+                if (lastpart) *lastpart = buffer + path_len;
+                ret = req_len;
+            }
+            else
+                ret = req_len + 1;
+
+            HeapFree( GetProcessHeap(), 0, dll_path );
+        }
+        else if (!RtlGetSearchPath( &dll_path ))
+        {
+            ret = RtlDosSearchPath_U( dll_path, name, NULL, buflen * sizeof(WCHAR),
+                                      buffer, lastpart ) / sizeof(WCHAR);
+            RtlReleasePath( dll_path );
+        }
+        HeapFree( GetProcessHeap(), 0, search );
+    }
+
+    if (!ret) SetLastError( ERROR_FILE_NOT_FOUND );
+    else TRACE( "found %s\n", debugstr_w(buffer) );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           SearchPathA   (KERNEL32.@)
+ *
+ * See SearchPathW.
+ */
+DWORD WINAPI SearchPathA( LPCSTR path, LPCSTR name, LPCSTR ext,
+                          DWORD buflen, LPSTR buffer, LPSTR *lastpart )
+{
+    WCHAR *pathW = NULL, *nameW, *extW = NULL;
+    WCHAR bufferW[MAX_PATH];
+    DWORD ret;
+
+    if (!name)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return 0;
+    }
+
+    if (!(nameW = FILE_name_AtoW( name, FALSE ))) return 0;
+    if (path && !(pathW = FILE_name_AtoW( path, TRUE ))) return 0;
+    
+    if (ext && !(extW = FILE_name_AtoW( ext, TRUE )))
+    {
+        HeapFree( GetProcessHeap(), 0, pathW );
+        return 0;
+    }
+
+    ret = SearchPathW(pathW, nameW, extW, MAX_PATH, bufferW, NULL);
+
+    HeapFree( GetProcessHeap(), 0, pathW );
+    HeapFree( GetProcessHeap(), 0, extW );
+
+    if (!ret) return 0;
+    if (ret > MAX_PATH)
+    {
+        SetLastError(ERROR_FILENAME_EXCED_RANGE);
+        return 0;
+    }
+    ret = copy_filename_WtoA( bufferW, buffer, buflen );
+    if (buflen > ret && lastpart)
+        *lastpart = strrchr(buffer, '\\') + 1;
+    return ret;
+}
 
 static BOOL is_same_file(HANDLE h1, HANDLE h2)
 {
diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index af21687aa3..7a6f843f43 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -63,137 +63,6 @@ static void WINAPI read_write_apc( void *apc_user, PIO_STATUS_BLOCK io, ULONG re
  ***********************************************************************/
 
 
-/***********************************************************************
- *	contains_path
- *
- * Check if the file name contains a path; helper for SearchPathW.
- * A relative path is not considered a path unless it starts with ./ or ../
- */
-static inline BOOL contains_path( const WCHAR *name )
-{
-    if (RtlDetermineDosPathNameType_U( name ) != RELATIVE_PATH) return TRUE;
-    if (name[0] != '.') return FALSE;
-    if (name[1] == '/' || name[1] == '\\') return TRUE;
-    return (name[1] == '.' && (name[2] == '/' || name[2] == '\\'));
-}
-
-
-/***********************************************************************
- *	append_ext
- */
-static WCHAR *append_ext( const WCHAR *name, const WCHAR *ext )
-{
-    const WCHAR *p;
-    WCHAR *ret;
-    DWORD len;
-
-    if (!ext) return NULL;
-    p = wcsrchr( name, '.' );
-    if (p && !wcschr( p, '/' ) && !wcschr( p, '\\' )) return NULL;
-
-    len = lstrlenW( name ) + lstrlenW( ext );
-    if ((ret = RtlAllocateHeap( GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR) )))
-    {
-        lstrcpyW( ret, name );
-        lstrcatW( ret, ext );
-    }
-    return ret;
-}
-
-
-/***********************************************************************
- *	find_actctx_dllpath
- *
- * Find the path (if any) of the dll from the activation context.
- * Returned path doesn't include a name.
- */
-static NTSTATUS find_actctx_dllpath( const WCHAR *name, WCHAR **path )
-{
-    static const WCHAR winsxsW[] = {'\\','w','i','n','s','x','s','\\'};
-    static const WCHAR dotManifestW[] = {'.','m','a','n','i','f','e','s','t',0};
-
-    ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION *info;
-    ACTCTX_SECTION_KEYED_DATA data;
-    UNICODE_STRING nameW;
-    NTSTATUS status;
-    SIZE_T needed, size = 1024;
-    WCHAR *p;
-
-    RtlInitUnicodeString( &nameW, name );
-    data.cbSize = sizeof(data);
-    status = RtlFindActivationContextSectionString( FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX, NULL,
-                                                    ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
-                                                    &nameW, &data );
-    if (status != STATUS_SUCCESS) return status;
-
-    for (;;)
-    {
-        if (!(info = RtlAllocateHeap( GetProcessHeap(), 0, size )))
-        {
-            status = STATUS_NO_MEMORY;
-            goto done;
-        }
-        status = RtlQueryInformationActivationContext( 0, data.hActCtx, &data.ulAssemblyRosterIndex,
-                                                       AssemblyDetailedInformationInActivationContext,
-                                                       info, size, &needed );
-        if (status == STATUS_SUCCESS) break;
-        if (status != STATUS_BUFFER_TOO_SMALL) goto done;
-        RtlFreeHeap( GetProcessHeap(), 0, info );
-        size = needed;
-        /* restart with larger buffer */
-    }
-
-    if (!info->lpAssemblyManifestPath || !info->lpAssemblyDirectoryName)
-    {
-        status = STATUS_SXS_KEY_NOT_FOUND;
-        goto done;
-    }
-
-    if ((p = wcsrchr( info->lpAssemblyManifestPath, '\\' )))
-    {
-        DWORD dirlen = info->ulAssemblyDirectoryNameLength / sizeof(WCHAR);
-
-        p++;
-        if (wcsnicmp( p, info->lpAssemblyDirectoryName, dirlen ) || wcsicmp( p + dirlen, dotManifestW ))
-        {
-            /* manifest name does not match directory name, so it's not a global
-             * windows/winsxs manifest; use the manifest directory name instead */
-            dirlen = p - info->lpAssemblyManifestPath;
-            needed = (dirlen + 1) * sizeof(WCHAR);
-            if (!(*path = p = HeapAlloc( GetProcessHeap(), 0, needed )))
-            {
-                status = STATUS_NO_MEMORY;
-                goto done;
-            }
-            memcpy( p, info->lpAssemblyManifestPath, dirlen * sizeof(WCHAR) );
-            *(p + dirlen) = 0;
-            goto done;
-        }
-    }
-
-    needed = (lstrlenW( windows_dir ) * sizeof(WCHAR) +
-              sizeof(winsxsW) + info->ulAssemblyDirectoryNameLength + 2*sizeof(WCHAR));
-
-    if (!(*path = p = RtlAllocateHeap( GetProcessHeap(), 0, needed )))
-    {
-        status = STATUS_NO_MEMORY;
-        goto done;
-    }
-    lstrcpyW( p, windows_dir );
-    p += lstrlenW(p);
-    memcpy( p, winsxsW, sizeof(winsxsW) );
-    p += ARRAY_SIZE( winsxsW );
-    memcpy( p, info->lpAssemblyDirectoryName, info->ulAssemblyDirectoryNameLength );
-    p += info->ulAssemblyDirectoryNameLength / sizeof(WCHAR);
-    *p++ = '\\';
-    *p = 0;
-done:
-    RtlFreeHeap( GetProcessHeap(), 0, info );
-    RtlReleaseActivationContext( data.hActCtx );
-    return status;
-}
-
-
 /***********************************************************************
  *           copy_filename_WtoA
  *
@@ -1452,119 +1321,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH NeedCurrentDirectoryForExePathW( LPCWSTR name )
 }
 
 
-/***********************************************************************
- *	SearchPathA   (kernelbase.@)
- */
-DWORD WINAPI DECLSPEC_HOTPATCH SearchPathA( LPCSTR path, LPCSTR name, LPCSTR ext,
-                                            DWORD buflen, LPSTR buffer, LPSTR *lastpart )
-{
-    WCHAR *pathW = NULL, *nameW, *extW = NULL;
-    WCHAR bufferW[MAX_PATH];
-    DWORD ret;
-
-    if (!name)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return 0;
-    }
-
-    if (!(nameW = file_name_AtoW( name, FALSE ))) return 0;
-    if (path && !(pathW = file_name_AtoW( path, TRUE ))) return 0;
-    if (ext && !(extW = file_name_AtoW( ext, TRUE )))
-    {
-        RtlFreeHeap( GetProcessHeap(), 0, pathW );
-        return 0;
-    }
-
-    ret = SearchPathW( pathW, nameW, extW, MAX_PATH, bufferW, NULL );
-
-    RtlFreeHeap( GetProcessHeap(), 0, pathW );
-    RtlFreeHeap( GetProcessHeap(), 0, extW );
-
-    if (!ret) return 0;
-    if (ret > MAX_PATH)
-    {
-        SetLastError( ERROR_FILENAME_EXCED_RANGE );
-        return 0;
-    }
-    ret = copy_filename_WtoA( bufferW, buffer, buflen );
-    if (buflen > ret && lastpart) *lastpart = strrchr(buffer, '\\') + 1;
-    return ret;
-}
-
-
-/***********************************************************************
- *	SearchPathW   (kernelbase.@)
- */
-DWORD WINAPI DECLSPEC_HOTPATCH SearchPathW( LPCWSTR path, LPCWSTR name, LPCWSTR ext, DWORD buflen,
-                                            LPWSTR buffer, LPWSTR *lastpart )
-{
-    DWORD ret = 0;
-    WCHAR *name_ext;
-
-    if (!name || !name[0])
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return 0;
-    }
-
-    /* If the name contains an explicit path, ignore the path */
-
-    if (contains_path( name ))
-    {
-        /* try first without extension */
-        if (RtlDoesFileExists_U( name )) return GetFullPathNameW( name, buflen, buffer, lastpart );
-
-        if ((name_ext = append_ext( name, ext )))
-        {
-            if (RtlDoesFileExists_U( name_ext ))
-                ret = GetFullPathNameW( name_ext, buflen, buffer, lastpart );
-            RtlFreeHeap( GetProcessHeap(), 0, name_ext );
-        }
-    }
-    else if (path && path[0])  /* search in the specified path */
-    {
-        ret = RtlDosSearchPath_U( path, name, ext, buflen * sizeof(WCHAR),
-                                  buffer, lastpart ) / sizeof(WCHAR);
-    }
-    else  /* search in active context and default path */
-    {
-        WCHAR *dll_path = NULL, *name_ext = append_ext( name, ext );
-
-        if (name_ext) name = name_ext;
-
-        /* When file is found with activation context no attempt is made
-          to check if it's really exist, path is returned only basing on context info. */
-        if (find_actctx_dllpath( name, &dll_path ) == STATUS_SUCCESS)
-        {
-            ret = lstrlenW( dll_path ) + lstrlenW( name ) + 1;
-
-            /* count null termination char too */
-            if (ret <= buflen)
-            {
-                lstrcpyW( buffer, dll_path );
-                lstrcatW( buffer, name );
-                if (lastpart) *lastpart = buffer + lstrlenW( dll_path );
-                ret--;
-            }
-            else if (lastpart) *lastpart = NULL;
-            RtlFreeHeap( GetProcessHeap(), 0, dll_path );
-        }
-        else if (!RtlGetSearchPath( &dll_path ))
-        {
-            ret = RtlDosSearchPath_U( dll_path, name, NULL, buflen * sizeof(WCHAR),
-                                      buffer, lastpart ) / sizeof(WCHAR);
-            RtlReleasePath( dll_path );
-        }
-        RtlFreeHeap( GetProcessHeap(), 0, name_ext );
-    }
-
-    if (!ret) SetLastError( ERROR_FILE_NOT_FOUND );
-    else TRACE( "found %s\n", debugstr_w(buffer) );
-    return ret;
-}
-
-
 /***********************************************************************
  *	SetCurrentDirectoryA   (kernelbase.@)
  */
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index c1fa479525..f80f6097dc 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -1385,8 +1385,8 @@
 # @ stub SaveStateRootFolderPath
 @ stdcall ScrollConsoleScreenBufferA(long ptr ptr ptr ptr)
 @ stdcall ScrollConsoleScreenBufferW(long ptr ptr ptr ptr)
-@ stdcall SearchPathA(str str str long ptr ptr)
-@ stdcall SearchPathW(wstr wstr wstr long ptr ptr)
+@ stdcall SearchPathA(str str str long ptr ptr) kernel32.SearchPathA
+@ stdcall SearchPathW(wstr wstr wstr long ptr ptr) kernel32.SearchPathW
 @ stdcall SetAclInformation(ptr ptr long long)
 # @ stub SetCachedSigningLevel
 @ stdcall SetCalendarInfoW(long long long wstr) kernel32.SetCalendarInfoW
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 5b70dfd874..4a3e0f4722 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -92,7 +92,7 @@ static BOOL load_library_as_datafile( LPCWSTR load_path, DWORD flags, LPCWSTR na
 
     if (flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE) protect |= SEC_IMAGE;
 
-    if (SearchPathW( NULL, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
+    if (SearchPathW( load_path, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
     {
         file = CreateFileW( filenameW, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE,
                             NULL, OPEN_EXISTING, 0, 0 );


From ea7454188b454ab164133982ac818b084b696647 Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Fri, 4 Oct 2019 03:13:09 +0200
Subject: Revert c5dc41e980b311a9d49122c6e3e33a1c4483c660,
 a5d45e9ae5a6a88f859c1ca1f05b4c93a0817103,
 619bd16e7a7486ca72cde1df01791629efb61341 Conflicting with our proton meta
 patchset

Staging edition

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 73cb8260cf..e051ac0e7a 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -140,7 +140,7 @@
 @ stdcall AddAtomW(wstr)
 @ stdcall AddConsoleAliasA(str str str)
 @ stdcall AddConsoleAliasW(wstr wstr wstr)
-@ stdcall -import AddDllDirectory(wstr)
+@ stdcall AddDllDirectory(wstr)
 # @ stub AddIntegrityLabelToBoundaryDescriptor
 # @ stub AddLocalAlternateComputerNameA
 # @ stub AddLocalAlternateComputerNameW
@@ -528,7 +528,7 @@
 @ stdcall -import FreeEnvironmentStringsA(ptr)
 @ stdcall -import FreeEnvironmentStringsW(ptr)
 @ stub -i386 FreeLSCallback
-@ stdcall -import FreeLibrary(long)
+@ stdcall FreeLibrary(long)
 @ stdcall FreeLibraryAndExitThread(long long)
 @ stdcall FreeLibraryWhenCallbackReturns(ptr ptr) ntdll.TpCallbackUnloadDllOnCompletion
 @ stdcall -import FreeResource(long)
@@ -1042,10 +1042,10 @@
 @ stdcall LeaveCriticalSection(ptr) ntdll.RtlLeaveCriticalSection
 @ stdcall LeaveCriticalSectionWhenCallbackReturns(ptr ptr) ntdll.TpCallbackLeaveCriticalSectionOnCompletion
 # @ stub LoadAppInitDlls
-@ stdcall -import LoadLibraryA(str)
-@ stdcall -import LoadLibraryExA( str long long)
-@ stdcall -import LoadLibraryExW(wstr long long)
-@ stdcall -import LoadLibraryW(wstr)
+@ stdcall LoadLibraryA(str)
+@ stdcall LoadLibraryExA( str long long)
+@ stdcall LoadLibraryExW(wstr long long)
+@ stdcall LoadLibraryW(wstr)
 @ stdcall LoadModule(str ptr)
 @ stdcall -import LoadResource(long long)
 # @ stub LoadStringBaseExW
@@ -1274,7 +1274,7 @@
 @ stdcall ReplaceFileW(wstr wstr wstr long ptr ptr)
 # @ stub RemoveDirectoryTransactedA
 # @ stub RemoveDirectoryTransactedW
-@ stdcall -import RemoveDllDirectory(ptr)
+@ stdcall RemoveDllDirectory(ptr)
 # @ stub RemoveSecureMemoryCacheCallback
 # @ stub ReplacePartitionUnit
 @ stdcall RequestDeviceWakeup(long)
@@ -1379,7 +1379,7 @@
 @ stub SetDaylightFlag
 @ stdcall SetDefaultCommConfigA(str ptr long)
 @ stdcall SetDefaultCommConfigW(wstr ptr long)
-@ stdcall -import SetDefaultDllDirectories(long)
+@ stdcall SetDefaultDllDirectories(long)
 @ stdcall SetDllDirectoryA(str)
 @ stdcall SetDllDirectoryW(wstr)
 # @ stub SetDynamicTimeZoneInformation
diff --git a/dlls/kernel32/kernel_private.h b/dlls/kernel32/kernel_private.h
index af85bee84d..fdfb7a3e83 100644
--- a/dlls/kernel32/kernel_private.h
+++ b/dlls/kernel32/kernel_private.h
@@ -65,6 +65,9 @@ extern void FILE_SetDosError(void) DECLSPEC_HIDDEN;
 extern WCHAR *FILE_name_AtoW( LPCSTR name, BOOL alloc ) DECLSPEC_HIDDEN;
 extern DWORD FILE_name_WtoA( LPCWSTR src, INT srclen, LPSTR dest, INT destlen ) DECLSPEC_HIDDEN;
 
+/* module.c */
+extern WCHAR *MODULE_get_dll_load_path( LPCWSTR module, int safe_mode ) DECLSPEC_HIDDEN;
+
 extern BOOL NLS_IsUnicodeOnlyLcid(LCID) DECLSPEC_HIDDEN;
 
 /* environ.c */
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index b7f19ffe36..131c2f9621 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -47,6 +47,34 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
+#define NE_FFLAGS_LIBMODULE 0x8000
+
+struct dll_dir_entry
+{
+    struct list entry;
+    WCHAR       dir[1];
+};
+
+static struct list dll_dir_list = LIST_INIT( dll_dir_list );  /* extra dirs from AddDllDirectory */
+static DWORD default_search_flags;  /* default flags set by SetDefaultDllDirectories */
+
+/* to keep track of LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE file handles */
+struct exclusive_datafile
+{
+    struct list entry;
+    HMODULE     module;
+    HANDLE      file;
+};
+static struct list exclusive_datafile_list = LIST_INIT( exclusive_datafile_list );
+
+static CRITICAL_SECTION dlldir_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &dlldir_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": dlldir_section") }
+};
+static CRITICAL_SECTION dlldir_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 /****************************************************************************
  *              GetDllDirectoryA   (KERNEL32.@)
@@ -135,6 +163,73 @@ BOOL WINAPI SetDllDirectoryW( LPCWSTR dir )
 }
 
 
+/****************************************************************************
+ *              AddDllDirectory   (KERNEL32.@)
+ */
+DLL_DIRECTORY_COOKIE WINAPI AddDllDirectory( const WCHAR *dir )
+{
+    WCHAR path[MAX_PATH];
+    DWORD len;
+    struct dll_dir_entry *ptr;
+    DOS_PATHNAME_TYPE type = RtlDetermineDosPathNameType_U( dir );
+
+    if (type != ABSOLUTE_PATH && type != ABSOLUTE_DRIVE_PATH)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return NULL;
+    }
+    if (!(len = GetFullPathNameW( dir, MAX_PATH, path, NULL ))) return NULL;
+    if (GetFileAttributesW( path ) == INVALID_FILE_ATTRIBUTES) return NULL;
+
+    if (!(ptr = HeapAlloc( GetProcessHeap(), 0, offsetof(struct dll_dir_entry, dir[++len] )))) return NULL;
+    memcpy( ptr->dir, path, len * sizeof(WCHAR) );
+    TRACE( "%s\n", debugstr_w( ptr->dir ));
+
+    RtlEnterCriticalSection( &dlldir_section );
+    list_add_head( &dll_dir_list, &ptr->entry );
+    RtlLeaveCriticalSection( &dlldir_section );
+    return ptr;
+}
+
+
+/****************************************************************************
+ *              RemoveDllDirectory   (KERNEL32.@)
+ */
+BOOL WINAPI RemoveDllDirectory( DLL_DIRECTORY_COOKIE cookie )
+{
+    struct dll_dir_entry *ptr = cookie;
+
+    TRACE( "%s\n", debugstr_w( ptr->dir ));
+
+    RtlEnterCriticalSection( &dlldir_section );
+    list_remove( &ptr->entry );
+    HeapFree( GetProcessHeap(), 0, ptr );
+    RtlLeaveCriticalSection( &dlldir_section );
+    return TRUE;
+}
+
+
+/*************************************************************************
+ *           SetDefaultDllDirectories   (KERNEL32.@)
+ */
+BOOL WINAPI SetDefaultDllDirectories( DWORD flags )
+{
+    /* LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR doesn't make sense in default dirs */
+    const DWORD load_library_search_flags = (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
+                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
+                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
+                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
+
+    if (!flags || (flags & ~load_library_search_flags))
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
+    default_search_flags = flags;
+    return TRUE;
+}
+
+
 /***********************************************************************
  *             GetBinaryTypeW                     [KERNEL32.@]
  *
@@ -273,6 +368,564 @@ BOOL WINAPI GetBinaryTypeA( LPCSTR lpApplicationName, LPDWORD lpBinaryType )
     return GetBinaryTypeW(NtCurrentTeb()->StaticUnicodeString.Buffer, lpBinaryType);
 }
 
+/***********************************************************************
+ *           get_dll_system_path
+ */
+static const WCHAR *get_dll_system_path(void)
+{
+    static WCHAR *cached_path;
+
+    if (!cached_path)
+    {
+        WCHAR *p, *path;
+        int len = 1;
+
+        len += 2 * GetSystemDirectoryW( NULL, 0 );
+        len += GetWindowsDirectoryW( NULL, 0 );
+        p = path = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );
+        GetSystemDirectoryW( p, path + len - p);
+        p += strlenW(p);
+        /* if system directory ends in "32" add 16-bit version too */
+        if (p[-2] == '3' && p[-1] == '2')
+        {
+            *p++ = ';';
+            GetSystemDirectoryW( p, path + len - p);
+            p += strlenW(p) - 2;
+        }
+        *p++ = ';';
+        GetWindowsDirectoryW( p, path + len - p);
+        cached_path = path;
+    }
+    return cached_path;
+}
+
+/***********************************************************************
+ *           get_dll_safe_mode
+ */
+static BOOL get_dll_safe_mode(void)
+{
+    static const WCHAR keyW[] = {'\\','R','e','g','i','s','t','r','y','\\',
+                                 'M','a','c','h','i','n','e','\\',
+                                 'S','y','s','t','e','m','\\',
+                                 'C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\',
+                                 'C','o','n','t','r','o','l','\\',
+                                 'S','e','s','s','i','o','n',' ','M','a','n','a','g','e','r',0};
+    static const WCHAR valueW[] = {'S','a','f','e','D','l','l','S','e','a','r','c','h','M','o','d','e',0};
+
+    static int safe_mode = -1;
+
+    if (safe_mode == -1)
+    {
+        char buffer[offsetof(KEY_VALUE_PARTIAL_INFORMATION, Data[sizeof(DWORD)])];
+        KEY_VALUE_PARTIAL_INFORMATION *info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
+        OBJECT_ATTRIBUTES attr;
+        UNICODE_STRING nameW;
+        HANDLE hkey;
+        DWORD size = sizeof(buffer);
+
+        attr.Length = sizeof(attr);
+        attr.RootDirectory = 0;
+        attr.ObjectName = &nameW;
+        attr.Attributes = 0;
+        attr.SecurityDescriptor = NULL;
+        attr.SecurityQualityOfService = NULL;
+
+        safe_mode = 1;
+        RtlInitUnicodeString( &nameW, keyW );
+        if (!NtOpenKey( &hkey, KEY_READ, &attr ))
+        {
+            RtlInitUnicodeString( &nameW, valueW );
+            if (!NtQueryValueKey( hkey, &nameW, KeyValuePartialInformation, buffer, size, &size ) &&
+                info->Type == REG_DWORD && info->DataLength == sizeof(DWORD))
+                safe_mode = !!*(DWORD *)info->Data;
+            NtClose( hkey );
+        }
+        if (!safe_mode) TRACE( "SafeDllSearchMode disabled through the registry\n" );
+    }
+    return safe_mode;
+}
+
+/******************************************************************
+ *		get_module_path_end
+ *
+ * Returns the end of the directory component of the module path.
+ */
+static inline const WCHAR *get_module_path_end(const WCHAR *module)
+{
+    const WCHAR *p;
+    const WCHAR *mod_end = module;
+    if (!module) return mod_end;
+
+    if ((p = strrchrW( mod_end, '\\' ))) mod_end = p;
+    if ((p = strrchrW( mod_end, '/' ))) mod_end = p;
+    if (mod_end == module + 2 && module[1] == ':') mod_end++;
+    if (mod_end == module && module[0] && module[1] == ':') mod_end += 2;
+
+    return mod_end;
+}
+
+
+/******************************************************************
+ *		append_path_len
+ *
+ * Append a counted string to the load path. Helper for MODULE_get_dll_load_path.
+ */
+static inline WCHAR *append_path_len( WCHAR *p, const WCHAR *str, DWORD len )
+{
+    if (!len) return p;
+    memcpy( p, str, len * sizeof(WCHAR) );
+    p[len] = ';';
+    return p + len + 1;
+}
+
+
+/******************************************************************
+ *		append_path
+ *
+ * Append a string to the load path. Helper for MODULE_get_dll_load_path.
+ */
+static inline WCHAR *append_path( WCHAR *p, const WCHAR *str )
+{
+    return append_path_len( p, str, strlenW(str) );
+}
+
+
+/******************************************************************
+ *		MODULE_get_dll_load_path
+ *
+ * Compute the load path to use for a given dll.
+ * Returned pointer must be freed by caller.
+ */
+WCHAR *MODULE_get_dll_load_path( LPCWSTR module, int safe_mode )
+{
+    static const WCHAR pathW[] = {'P','A','T','H',0};
+    static const WCHAR dotW[] = {'.',0};
+
+    const WCHAR *system_path = get_dll_system_path();
+    const WCHAR *mod_end = NULL;
+    UNICODE_STRING name, value;
+    WCHAR *p, *ret;
+    int len = 0, path_len = 0, dlldir_len;
+
+    /* adjust length for module name */
+
+    if (module)
+        mod_end = get_module_path_end( module );
+    /* if module is NULL or doesn't contain a path, fall back to directory
+     * process was loaded from */
+    if (module == mod_end)
+    {
+        module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+        mod_end = get_module_path_end( module );
+    }
+    len += (mod_end - module) + 1;
+
+    len += strlenW( system_path ) + 2;
+
+    /* get the PATH variable */
+
+    RtlInitUnicodeString( &name, pathW );
+    value.Length = 0;
+    value.MaximumLength = 0;
+    value.Buffer = NULL;
+    if (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
+        path_len = value.Length;
+
+    dlldir_len = GetDllDirectoryW( 0, NULL );
+
+    if (safe_mode == -1) safe_mode = get_dll_safe_mode();
+    if (dlldir_len > 1) len += dlldir_len;
+    else len += 2;  /* current directory */
+    if ((p = ret = HeapAlloc( GetProcessHeap(), 0, path_len + len * sizeof(WCHAR) )))
+    {
+        if (module) p = append_path_len( p, module, mod_end - module );
+
+        if (dlldir_len > 1)
+        {
+            GetDllDirectoryW( len - (p - ret), p );
+            p += strlenW(p);
+            *p++ = ';';
+        }
+        else if (!safe_mode) p = append_path( p, dotW );
+
+        p = append_path( p, system_path );
+
+        if (dlldir_len <= 1 && safe_mode) p = append_path( p, dotW );
+    }
+    if (!ret) return NULL;
+
+    value.Buffer = p;
+    value.MaximumLength = path_len;
+
+    while (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
+    {
+        WCHAR *new_ptr;
+
+        /* grow the buffer and retry */
+        path_len = value.Length;
+        if (!(new_ptr = HeapReAlloc( GetProcessHeap(), 0, ret, path_len + len * sizeof(WCHAR) )))
+        {
+            HeapFree( GetProcessHeap(), 0, ret );
+            return NULL;
+        }
+        value.Buffer = new_ptr + (value.Buffer - ret);
+        value.MaximumLength = path_len;
+        ret = new_ptr;
+    }
+    value.Buffer[value.Length / sizeof(WCHAR)] = 0;
+    return ret;
+}
+
+
+/******************************************************************
+ *		get_dll_load_path_search_flags
+ */
+static WCHAR *get_dll_load_path_search_flags( LPCWSTR module, DWORD flags )
+{
+    const WCHAR *image = NULL, *mod_end, *image_end;
+    struct dll_dir_entry *dir;
+    WCHAR *p, *ret;
+    int len = 1;
+
+    if (flags & LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)
+        flags |= (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
+                  LOAD_LIBRARY_SEARCH_USER_DIRS |
+                  LOAD_LIBRARY_SEARCH_SYSTEM32);
+
+    if (flags & LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR)
+    {
+        DWORD type = RtlDetermineDosPathNameType_U( module );
+        if (type != ABSOLUTE_DRIVE_PATH && type != ABSOLUTE_PATH)
+        {
+            SetLastError( ERROR_INVALID_PARAMETER );
+            return NULL;
+        }
+        mod_end = get_module_path_end( module );
+        len += (mod_end - module) + 1;
+    }
+    else module = NULL;
+
+    RtlEnterCriticalSection( &dlldir_section );
+
+    if (flags & LOAD_LIBRARY_SEARCH_APPLICATION_DIR)
+    {
+        image = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+        image_end = get_module_path_end( image );
+        len += (image_end - image) + 1;
+    }
+
+    if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
+    {
+        LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
+            len += strlenW( dir->dir ) + 1;
+        len += GetDllDirectoryW( 0, NULL );
+    }
+
+    if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) len += GetSystemDirectoryW( NULL, 0 );
+
+    if ((p = ret = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+    {
+        if (module) p = append_path_len( p, module, mod_end - module );
+        if (image) p = append_path_len( p, image, image_end - image );
+        if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
+        {
+            LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
+                p = append_path( p, dir->dir );
+            GetDllDirectoryW( ret + len - p, p );
+            if (*p)
+            {
+                p += strlenW(p);
+                *p++ = ';';
+            }
+        }
+        if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) GetSystemDirectoryW( p, ret + len - p );
+        else
+        {
+            if (p > ret) p--;
+            *p = 0;
+        }
+    }
+
+    RtlLeaveCriticalSection( &dlldir_section );
+    return ret;
+}
+
+
+/******************************************************************
+ *		load_library_as_datafile
+ */
+static BOOL load_library_as_datafile( LPCWSTR name, HMODULE *hmod, DWORD flags )
+{
+    static const WCHAR dotDLL[] = {'.','d','l','l',0};
+
+    WCHAR filenameW[MAX_PATH];
+    HANDLE hFile = INVALID_HANDLE_VALUE;
+    HANDLE mapping;
+    HMODULE module = 0;
+    DWORD protect = PAGE_READONLY;
+    DWORD sharing = FILE_SHARE_READ | FILE_SHARE_DELETE;
+
+    *hmod = 0;
+
+    if (flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE) protect |= SEC_IMAGE;
+
+    if (SearchPathW( NULL, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
+    {
+        hFile = CreateFileW( filenameW, GENERIC_READ, sharing, NULL, OPEN_EXISTING, 0, 0 );
+    }
+    if (hFile == INVALID_HANDLE_VALUE) return FALSE;
+
+    mapping = CreateFileMappingW( hFile, NULL, protect, 0, 0, NULL );
+    if (!mapping) goto failed;
+
+    module = MapViewOfFile( mapping, FILE_MAP_READ, 0, 0, 0 );
+    CloseHandle( mapping );
+    if (!module) goto failed;
+
+    if (!(flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE))
+    {
+        /* make sure it's a valid PE file */
+        if (!RtlImageNtHeader( module )) goto failed;
+        *hmod = (HMODULE)((char *)module + 1); /* set bit 0 for data file module */
+
+        if (flags & LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE)
+        {
+            struct exclusive_datafile *file = HeapAlloc( GetProcessHeap(), 0, sizeof(*file) );
+            if (!file) goto failed;
+            file->module = *hmod;
+            file->file   = hFile;
+            list_add_head( &exclusive_datafile_list, &file->entry );
+            TRACE( "delaying close %p for module %p\n", file->file, file->module );
+            return TRUE;
+        }
+    }
+    else *hmod = (HMODULE)((char *)module + 2); /* set bit 1 for image resource module */
+
+    CloseHandle( hFile );
+    return TRUE;
+
+failed:
+    if (module) UnmapViewOfFile( module );
+    CloseHandle( hFile );
+    return FALSE;
+}
+
+
+/******************************************************************
+ *		load_library
+ *
+ * Helper for LoadLibraryExA/W.
+ */
+static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
+{
+    NTSTATUS nts;
+    HMODULE hModule;
+    WCHAR *load_path;
+    const DWORD load_library_search_flags = (LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR |
+                                             LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
+                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
+                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
+                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
+    const DWORD unsupported_flags = (LOAD_IGNORE_CODE_AUTHZ_LEVEL |
+                                     LOAD_LIBRARY_REQUIRE_SIGNED_TARGET);
+
+    if( flags & unsupported_flags)
+        FIXME("unsupported flag(s) used (flags: 0x%08x)\n", flags);
+
+    if (flags & LOAD_WITH_ALTERED_SEARCH_PATH)
+    {
+        if (flags & load_library_search_flags)
+        {
+            SetLastError( ERROR_INVALID_PARAMETER );
+            return 0;
+        }
+        if (default_search_flags) flags |= default_search_flags | LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR;
+    }
+    else if (!(flags & load_library_search_flags)) flags |= default_search_flags;
+
+    if (flags & load_library_search_flags)
+        load_path = get_dll_load_path_search_flags( libname->Buffer, flags );
+    else
+        load_path = MODULE_get_dll_load_path( flags & LOAD_WITH_ALTERED_SEARCH_PATH ? libname->Buffer : NULL, -1 );
+    if (!load_path) return 0;
+
+    if (flags & (LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE | LOAD_LIBRARY_AS_IMAGE_RESOURCE))
+    {
+        ULONG_PTR magic;
+
+        LdrLockLoaderLock( 0, NULL, &magic );
+        if (!LdrGetDllHandle( load_path, flags, libname, &hModule ))
+        {
+            LdrAddRefDll( 0, hModule );
+            LdrUnlockLoaderLock( 0, magic );
+            goto done;
+        }
+        if (load_library_as_datafile( libname->Buffer, &hModule, flags ))
+        {
+            LdrUnlockLoaderLock( 0, magic );
+            goto done;
+        }
+        LdrUnlockLoaderLock( 0, magic );
+        flags |= DONT_RESOLVE_DLL_REFERENCES; /* Just in case */
+        /* Fallback to normal behaviour */
+    }
+
+    nts = LdrLoadDll( load_path, flags, libname, &hModule );
+    if (nts != STATUS_SUCCESS)
+    {
+        hModule = 0;
+        if (nts == STATUS_DLL_NOT_FOUND && (GetVersion() & 0x80000000))
+            SetLastError( ERROR_DLL_NOT_FOUND );
+        else
+            SetLastError( RtlNtStatusToDosError( nts ) );
+    }
+done:
+    HeapFree( GetProcessHeap(), 0, load_path );
+    return hModule;
+}
+
+
+/******************************************************************
+ *		LoadLibraryExA          (KERNEL32.@)
+ *
+ * Load a dll file into the process address space.
+ *
+ * PARAMS
+ *  libname [I] Name of the file to load
+ *  hfile   [I] Reserved, must be 0.
+ *  flags   [I] Flags for loading the dll
+ *
+ * RETURNS
+ *  Success: A handle to the loaded dll.
+ *  Failure: A NULL handle. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ * The HFILE parameter is not used and marked reserved in the SDK. I can
+ * only guess that it should force a file to be mapped, but I rather
+ * ignore the parameter because it would be extremely difficult to
+ * integrate this with different types of module representations.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExA(LPCSTR libname, HANDLE hfile, DWORD flags)
+{
+    WCHAR *libnameW;
+
+    if (!(libnameW = FILE_name_AtoW( libname, FALSE ))) return 0;
+    return LoadLibraryExW( libnameW, hfile, flags );
+}
+
+/***********************************************************************
+ *           LoadLibraryExW       (KERNEL32.@)
+ *
+ * Unicode version of LoadLibraryExA.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExW(LPCWSTR libnameW, HANDLE hfile, DWORD flags)
+{
+    UNICODE_STRING      wstr;
+    HMODULE             res;
+
+    if (!libnameW)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return 0;
+    }
+    RtlInitUnicodeString( &wstr, libnameW );
+    if (wstr.Buffer[wstr.Length/sizeof(WCHAR) - 1] != ' ')
+        return load_library( &wstr, flags );
+
+    /* Library name has trailing spaces */
+    RtlCreateUnicodeString( &wstr, libnameW );
+    while (wstr.Length > sizeof(WCHAR) &&
+           wstr.Buffer[wstr.Length/sizeof(WCHAR) - 1] == ' ')
+    {
+        wstr.Length -= sizeof(WCHAR);
+    }
+    wstr.Buffer[wstr.Length/sizeof(WCHAR)] = '\0';
+    res = load_library( &wstr, flags );
+    RtlFreeUnicodeString( &wstr );
+    return res;
+}
+
+/***********************************************************************
+ *           LoadLibraryA         (KERNEL32.@)
+ *
+ * Load a dll file into the process address space.
+ *
+ * PARAMS
+ *  libname [I] Name of the file to load
+ *
+ * RETURNS
+ *  Success: A handle to the loaded dll.
+ *  Failure: A NULL handle. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ * See LoadLibraryExA().
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryA(LPCSTR libname)
+{
+    return LoadLibraryExA(libname, 0, 0);
+}
+
+/***********************************************************************
+ *           LoadLibraryW         (KERNEL32.@)
+ *
+ * Unicode version of LoadLibraryA.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryW(LPCWSTR libnameW)
+{
+    return LoadLibraryExW(libnameW, 0, 0);
+}
+
+/***********************************************************************
+ *           FreeLibrary   (KERNEL32.@)
+ *
+ * Free a dll loaded into the process address space.
+ *
+ * PARAMS
+ *  hLibModule [I] Handle to the dll returned by LoadLibraryA().
+ *
+ * RETURNS
+ *  Success: TRUE. The dll is removed if it is not still in use.
+ *  Failure: FALSE. Use GetLastError() to determine the cause.
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary(HINSTANCE hLibModule)
+{
+    if (!hLibModule)
+    {
+        SetLastError( ERROR_INVALID_HANDLE );
+        return FALSE;
+    }
+
+    if ((ULONG_PTR)hLibModule & 3) /* this is a datafile module */
+    {
+        void *ptr = (void *)((ULONG_PTR)hLibModule & ~3);
+        if (!RtlImageNtHeader( ptr ))
+        {
+            SetLastError( ERROR_BAD_EXE_FORMAT );
+            return FALSE;
+        }
+        if ((ULONG_PTR)hLibModule & 1)
+        {
+            struct exclusive_datafile *file;
+            ULONG_PTR magic;
+
+            LdrLockLoaderLock( 0, NULL, &magic );
+            LIST_FOR_EACH_ENTRY( file, &exclusive_datafile_list, struct exclusive_datafile, entry )
+            {
+                if (file->module != hLibModule) continue;
+                TRACE( "closing %p for module %p\n", file->file, file->module );
+                CloseHandle( file->file );
+                list_remove( &file->entry );
+                HeapFree( GetProcessHeap(), 0, file );
+                break;
+            }
+            LdrUnlockLoaderLock( 0, magic );
+        }
+        return UnmapViewOfFile( ptr );
+    }
+
+    return set_ntstatus( LdrUnloadDll( hLibModule ));
+}
+
 /***********************************************************************
  *           GetProcAddress   		(KERNEL32.@)
  *
diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 2e96a24324..610ce1deb0 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -442,22 +442,11 @@ static HANDLE open_exe_file( const WCHAR *name, BOOL *is_64bit )
  */
 static BOOL find_exe_file( const WCHAR *name, WCHAR *buffer, int buflen, HANDLE *handle )
 {
-    WCHAR cur_dir[MAX_PATH];
-    WCHAR *load_path;
-    BOOL ret;
-
-    if (!set_ntstatus( RtlGetExePath( name, &load_path ))) return FALSE;
-
-    TRACE("looking for %s in %s\n", debugstr_w(name), debugstr_w(load_path) );
+    TRACE("looking for %s\n", debugstr_w(name) );
 
-    ret = (NeedCurrentDirectoryForExePathW( name ) && GetCurrentDirectoryW( MAX_PATH, cur_dir) &&
-           SearchPathW( cur_dir, name, exeW, buflen, buffer, NULL )) ||
-           /* not found in the working directory, try the system search path */
-           (SearchPathW( load_path, name, exeW, buflen, buffer, NULL ) ||
-           /* no builtin found, try native without extension in case it is a Unix app */
-           SearchPathW( load_path, name, NULL, buflen, buffer, NULL ));
-    RtlReleasePath( load_path );
-    if (!ret) return FALSE;
+    if (!SearchPathW( NULL, name, exeW, buflen, buffer, NULL ) &&
+        /* no builtin found, try native without extension in case it is a Unix app */
+        !SearchPathW( NULL, name, NULL, buflen, buffer, NULL )) return FALSE;
 
     TRACE( "Trying native exe %s\n", debugstr_w(buffer) );
     *handle = CreateFileW( buffer, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_DELETE,
@@ -1404,7 +1393,6 @@ void * CDECL __wine_kernel_init(void)
     RTL_USER_PROCESS_PARAMETERS *params = peb->ProcessParameters;
     HANDLE boot_events[2];
     BOOL got_environment = TRUE;
-    WCHAR *load_path, *dummy;
 
     /* Initialize everything */
 
@@ -1443,14 +1431,12 @@ void * CDECL __wine_kernel_init(void)
     {
         BOOL is_64bit;
 
-        RtlGetExePath( __wine_main_wargv[0], &load_path );
-        if (!SearchPathW( load_path, __wine_main_wargv[0], exeW, MAX_PATH, main_exe_name, NULL ) &&
+        if (!SearchPathW( NULL, __wine_main_wargv[0], exeW, MAX_PATH, main_exe_name, NULL ) &&
             !get_builtin_path( __wine_main_wargv[0], exeW, main_exe_name, MAX_PATH, &is_64bit ))
         {
             MESSAGE( "wine: cannot find '%s'\n", __wine_main_argv[0] );
             ExitProcess( GetLastError() );
         }
-        RtlReleasePath( load_path );
         update_library_argv0( main_exe_name );
         if (!build_command_line( __wine_main_wargv )) goto error;
         start_wineboot( boot_events );
@@ -1463,8 +1449,8 @@ void * CDECL __wine_kernel_init(void)
     TRACE( "starting process name=%s argv[0]=%s\n",
            debugstr_w(main_exe_name), debugstr_w(__wine_main_wargv[0]) );
 
-    LdrGetDllPath( main_exe_name, 0, &load_path, &dummy );
-    RtlInitUnicodeString( &NtCurrentTeb()->Peb->ProcessParameters->DllPath, load_path );
+    RtlInitUnicodeString( &NtCurrentTeb()->Peb->ProcessParameters->DllPath,
+                          MODULE_get_dll_load_path( main_exe_name, -1 ));
 
     if (boot_events[0])
     {
diff --git a/dlls/kernel32/tests/path.c b/dlls/kernel32/tests/path.c
index 11b5ea35f0..976993c922 100644
--- a/dlls/kernel32/tests/path.c
+++ b/dlls/kernel32/tests/path.c
@@ -73,15 +73,10 @@ static DWORD (WINAPI *pGetLongPathNameW)(LPWSTR,LPWSTR,DWORD);
 static BOOL  (WINAPI *pNeedCurrentDirectoryForExePathA)(LPCSTR);
 static BOOL  (WINAPI *pNeedCurrentDirectoryForExePathW)(LPCWSTR);
 
-static DLL_DIRECTORY_COOKIE (WINAPI *pAddDllDirectory)(const WCHAR*);
-static BOOL     (WINAPI *pRemoveDllDirectory)(DLL_DIRECTORY_COOKIE);
-static BOOL     (WINAPI *pSetSearchPathMode)(DWORD);
-static BOOL     (WINAPI *pSetDllDirectoryW)(LPCWSTR);
-static BOOL     (WINAPI *pSetDefaultDllDirectories)(DWORD);
-static NTSTATUS (WINAPI *pRtlGetExePath)(LPCWSTR,LPWSTR*);
+static BOOL  (WINAPI *pSetSearchPathMode)(DWORD);
+static BOOL  (WINAPI *pSetDllDirectoryA)(LPCSTR);
 static NTSTATUS (WINAPI *pRtlGetSearchPath)(LPWSTR*);
-static void     (WINAPI *pRtlReleasePath)(LPWSTR);
-static NTSTATUS (WINAPI *pLdrGetDllPath)(LPCWSTR,ULONG,LPWSTR*,LPWSTR*);
+static void (WINAPI *pRtlReleasePath)(LPWSTR);
 
 static BOOL   (WINAPI *pActivateActCtx)(HANDLE,ULONG_PTR*);
 static HANDLE (WINAPI *pCreateActCtxW)(PCACTCTXW);
@@ -2209,10 +2204,7 @@ static void init_pointers(void)
     MAKEFUNC(NeedCurrentDirectoryForExePathA);
     MAKEFUNC(NeedCurrentDirectoryForExePathW);
     MAKEFUNC(SetSearchPathMode);
-    MAKEFUNC(AddDllDirectory);
-    MAKEFUNC(RemoveDllDirectory);
-    MAKEFUNC(SetDllDirectoryW);
-    MAKEFUNC(SetDefaultDllDirectories);
+    MAKEFUNC(SetDllDirectoryA);
     MAKEFUNC(ActivateActCtx);
     MAKEFUNC(CreateActCtxW);
     MAKEFUNC(DeactivateActCtx);
@@ -2223,8 +2215,6 @@ static void init_pointers(void)
     MAKEFUNC(CreateSymbolicLinkW);
 
     mod = GetModuleHandleA("ntdll.dll");
-    MAKEFUNC(LdrGetDllPath);
-    MAKEFUNC(RtlGetExePath);
     MAKEFUNC(RtlGetSearchPath);
     MAKEFUNC(RtlReleasePath);
 
@@ -2486,23 +2476,12 @@ static void test_SetSearchPathMode(void)
 
 static const WCHAR pathW[] = {'P','A','T','H',0};
 
-static void build_search_path( WCHAR *buffer, UINT size, const WCHAR *dlldir, BOOL safe )
+static void build_search_path( WCHAR *buffer, UINT size, BOOL safe )
 {
     WCHAR *p;
     GetModuleFileNameW( NULL, buffer, size );
     if (!(p = wcsrchr( buffer, '\\' ))) return;
     *p++ = ';';
-    if (dlldir)
-    {
-        lstrcpyW( p, dlldir );
-        p += lstrlenW( p );
-        if (*dlldir) *p++ = ';';
-    }
-    else if (!safe)
-    {
-        *p++ = '.';
-        *p++ = ';';
-    }
     GetSystemDirectoryW( p, buffer + size - p );
     p = buffer + lstrlenW(buffer);
     *p++ = ';';
@@ -2512,7 +2491,7 @@ static void build_search_path( WCHAR *buffer, UINT size, const WCHAR *dlldir, BO
     GetWindowsDirectoryW( p, buffer + size - p );
     p = buffer + lstrlenW(buffer);
     *p++ = ';';
-    if (!dlldir && safe)
+    if (!safe)
     {
         *p++ = '.';
         *p++ = ';';
@@ -2528,7 +2507,7 @@ static BOOL path_equal( const WCHAR *path1, const WCHAR *path2 )
         if (*path1 && *path1 != '\\' && *path1 != ';') return FALSE;
         while (*path1 && (*path1 == '\\' || *path1 == ';')) path1++;
         while (*path2 && (*path2 == '\\' || *path2 == ';')) path2++;
-        if (!*path1 || !*path2) return !*path1 && !*path2;
+        if (!*path1 && !*path2) return TRUE;
     }
 }
 
@@ -2536,7 +2515,7 @@ static void test_RtlGetSearchPath(void)
 {
     NTSTATUS ret;
     WCHAR *path;
-    WCHAR buffer[2048], old_path[2048], dlldir[4];
+    WCHAR buffer[2048], old_path[2048];
 
     if (!pRtlGetSearchPath)
     {
@@ -2545,10 +2524,8 @@ static void test_RtlGetSearchPath(void)
     }
 
     GetEnvironmentVariableW( pathW, old_path, ARRAY_SIZE(old_path) );
-    GetWindowsDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    lstrcpynW( dlldir, buffer, ARRAY_SIZE(dlldir) );
 
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
+    build_search_path( buffer, ARRAY_SIZE(buffer), FALSE );
     path = (WCHAR *)0xdeadbeef;
     ret = pRtlGetSearchPath( &path );
     ok( !ret, "RtlGetSearchPath failed %x\n", ret );
@@ -2556,195 +2533,23 @@ static void test_RtlGetSearchPath(void)
     pRtlReleasePath( path );
 
     SetEnvironmentVariableA( "PATH", "foo" );
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
+    build_search_path( buffer, ARRAY_SIZE(buffer), FALSE );
     path = (WCHAR *)0xdeadbeef;
     ret = pRtlGetSearchPath( &path );
     ok( !ret, "RtlGetSearchPath failed %x\n", ret );
     ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
     pRtlReleasePath( path );
 
-    if (pSetDllDirectoryW)
+    if (pSetDllDirectoryA)
     {
-        ok( pSetDllDirectoryW( dlldir ), "SetDllDirectoryW failed\n" );
-        build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
+        ok( pSetDllDirectoryA( "c:\\" ), "SetDllDirectoryA failed\n" );
+        build_search_path( buffer, ARRAY_SIZE(buffer), FALSE );
         path = (WCHAR *)0xdeadbeef;
         ret = pRtlGetSearchPath( &path );
         ok( !ret, "RtlGetSearchPath failed %x\n", ret );
         ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
         pRtlReleasePath( path );
-        pSetDllDirectoryW( NULL );
-    }
-
-    SetEnvironmentVariableW( pathW, old_path );
-}
-
-static void test_RtlGetExePath(void)
-{
-    static const WCHAR fooW[] = {'\\','f','o','o',0};
-    static const WCHAR emptyW[1];
-    NTSTATUS ret;
-    WCHAR *path;
-    WCHAR buffer[2048], old_path[2048], dlldir[4];
-
-    if (!pRtlGetExePath)
-    {
-        win_skip( "RtlGetExePath isn't available\n" );
-        return;
-    }
-
-    GetEnvironmentVariableW( pathW, old_path, ARRAY_SIZE(old_path) );
-    GetWindowsDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    lstrcpynW( dlldir, buffer, ARRAY_SIZE(dlldir) );
-    SetEnvironmentVariableA( "NoDefaultCurrentDirectoryInExePath", NULL );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW + 1, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    SetEnvironmentVariableA( "NoDefaultCurrentDirectoryInExePath", "yes" );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), emptyW, TRUE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW + 1, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    SetEnvironmentVariableA( "PATH", "foo" );
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-    path = (WCHAR *)0xdeadbeef;
-    ret = pRtlGetExePath( fooW, &path );
-    ok( !ret, "RtlGetExePath failed %x\n", ret );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    if (pSetDllDirectoryW)
-    {
-        ok( pSetDllDirectoryW( dlldir ), "SetDllDirectoryW failed\n" );
-        build_search_path( buffer, ARRAY_SIZE(buffer), NULL, FALSE );
-        path = (WCHAR *)0xdeadbeef;
-        ret = pRtlGetExePath( fooW, &path );
-        ok( !ret, "RtlGetExePath failed %x\n", ret );
-        ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-        pRtlReleasePath( path );
-        pSetDllDirectoryW( NULL );
-    }
-
-    SetEnvironmentVariableW( pathW, old_path );
-}
-
-static void test_LdrGetDllPath(void)
-{
-    static const WCHAR fooW[] = {'f','o','o',0};
-    NTSTATUS ret;
-    WCHAR *path, *unknown_ptr, *p;
-    WCHAR buffer[2048], old_path[2048], dlldir[4];
-
-    if (!pLdrGetDllPath)
-    {
-        win_skip( "LdrGetDllPath isn't available\n" );
-        return;
-    }
-    GetEnvironmentVariableW( pathW, old_path, ARRAY_SIZE(old_path) );
-    GetWindowsDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    lstrcpynW( dlldir, buffer, ARRAY_SIZE(dlldir) );
-
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
-
-    path = unknown_ptr = (WCHAR *)0xdeadbeef;
-    ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    SetEnvironmentVariableA( "PATH", "foo" );
-    build_search_path( buffer, ARRAY_SIZE(buffer), NULL, TRUE );
-    ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    if (pSetDllDirectoryW)
-    {
-        ok( pSetDllDirectoryW( dlldir ), "SetDllDirectoryW failed\n" );
-        build_search_path( buffer, ARRAY_SIZE(buffer), dlldir, TRUE );
-        ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-        ok( !ret, "LdrGetDllPath failed %x\n", ret );
-        ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-        ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-        pRtlReleasePath( path );
-        pSetDllDirectoryW( NULL );
-    }
-
-    ret = pLdrGetDllPath( 0, LOAD_LIBRARY_SEARCH_SYSTEM32, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    GetSystemDirectoryW( buffer, ARRAY_SIZE(buffer) );
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    ret = pLdrGetDllPath( 0, LOAD_LIBRARY_SEARCH_APPLICATION_DIR, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    GetModuleFileNameW( NULL, buffer, ARRAY_SIZE(buffer) );
-    if ((p = wcsrchr( buffer, '\\' ))) *p = 0;
-    ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-    pRtlReleasePath( path );
-
-    ret = pLdrGetDllPath( fooW, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR, &path, &unknown_ptr );
-    ok( ret == STATUS_INVALID_PARAMETER, "LdrGetDllPath failed %x\n", ret );
-
-    lstrcpyW( buffer, dlldir );
-    p = buffer + lstrlenW(buffer);
-    *p++ = '\\';
-    lstrcpyW( p, fooW );
-    ret = pLdrGetDllPath( buffer, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR, &path, &unknown_ptr );
-    ok( !ret, "LdrGetDllPath failed %x\n", ret );
-    ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-    ok( path_equal( path, dlldir ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(dlldir));
-    pRtlReleasePath( path );
-
-    if (pAddDllDirectory)
-    {
-        DLL_DIRECTORY_COOKIE cookie = pAddDllDirectory( dlldir );
-        ok( !!cookie, "AddDllDirectory failed\n" );
-        ret = pLdrGetDllPath( 0, LOAD_LIBRARY_SEARCH_USER_DIRS, &path, &unknown_ptr );
-        ok( !ret, "LdrGetDllPath failed %x\n", ret );
-        ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-        ok( path_equal( path, dlldir ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(dlldir));
-        pRtlReleasePath( path );
-        pRemoveDllDirectory( cookie );
-    }
-
-    if (pSetDefaultDllDirectories)
-    {
-        pSetDefaultDllDirectories( LOAD_LIBRARY_SEARCH_SYSTEM32 );
-        ret = pLdrGetDllPath( 0, 0, &path, &unknown_ptr );
-        ok( !ret, "LdrGetDllPath failed %x\n", ret );
-        ok( !unknown_ptr, "unknown ptr %p\n", unknown_ptr );
-        GetSystemDirectoryW( buffer, ARRAY_SIZE(buffer) );
-        ok( path_equal( path, buffer ), "got %s expected %s\n", wine_dbgstr_w(path), wine_dbgstr_w(buffer));
-        pRtlReleasePath( path );
-        pSetDefaultDllDirectories( 0 );
+        pSetDllDirectoryA( NULL );
     }
 
     SetEnvironmentVariableW( pathW, old_path );
@@ -2874,7 +2679,5 @@ START_TEST(path)
     test_CheckNameLegalDOS8Dot3();
     test_SetSearchPathMode();
     test_RtlGetSearchPath();
-    test_RtlGetExePath();
-    test_LdrGetDllPath();
     test_CreateSymbolicLink();
 }
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index b64a1fc1ae..7d86399af5 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -19,7 +19,7 @@
 @ stdcall AddAuditAccessAce(ptr long long ptr long long)
 @ stdcall AddAuditAccessAceEx(ptr long long long ptr long long)
 @ stdcall AddAuditAccessObjectAce(ptr long long long ptr ptr ptr long long)
-@ stdcall AddDllDirectory(wstr)
+@ stdcall AddDllDirectory(wstr) kernel32.AddDllDirectory
 @ stdcall AddMandatoryAce(ptr long long long ptr)
 @ stdcall AddRefActCtx(ptr)
 # @ stub AddResourceAttributeAce
@@ -394,7 +394,7 @@
 @ stdcall FreeEnvironmentStringsW(ptr)
 # @ stub FreeGPOListInternalA
 # @ stub FreeGPOListInternalW
-@ stdcall FreeLibrary(long)
+@ stdcall FreeLibrary(long) kernel32.FreeLibrary
 @ stdcall FreeLibraryAndExitThread(long long)
 @ stdcall FreeLibraryWhenCallbackReturns(ptr ptr) ntdll.TpCallbackUnloadDllOnCompletion
 @ stdcall FreeResource(long)
@@ -618,7 +618,7 @@
 # @ stub GetPreviousFgPolicyRefreshInfoInternal
 @ stdcall GetPriorityClass(long)
 @ stdcall GetPrivateObjectSecurity(ptr long ptr long ptr)
-@ stdcall GetProcAddress(long str)
+@ stdcall GetProcAddress(long str) kernel32.GetProcAddress
 # @ stub GetProcAddressForCaller
 # @ stub GetProcessDefaultCpuSets
 # @ stub GetProcessGroupAffinity
@@ -922,10 +922,10 @@
 @ stdcall LeaveCriticalSectionWhenCallbackReturns(ptr ptr) ntdll.TpCallbackLeaveCriticalSectionOnCompletion
 # @ stub LoadAppInitDlls
 # @ stub LoadEnclaveData
-@ stdcall LoadLibraryA(str)
-@ stdcall LoadLibraryExA( str long long)
-@ stdcall LoadLibraryExW(wstr long long)
-@ stdcall LoadLibraryW(wstr)
+@ stdcall LoadLibraryA(str) kernel32.LoadLibraryA
+@ stdcall LoadLibraryExA( str long long) kernel32.LoadLibraryExA
+@ stdcall LoadLibraryExW(wstr long long) kernel32.LoadLibraryExW
+@ stdcall LoadLibraryW(wstr) kernel32.LoadLibraryW
 # @ stub LoadPackagedLibrary
 @ stdcall LoadResource(long long)
 @ stdcall LoadStringA(long long ptr long)
@@ -1333,7 +1333,7 @@
 @ stdcall RemapPredefinedHandleInternal(long long)
 @ stdcall RemoveDirectoryA(str) kernel32.RemoveDirectoryA
 @ stdcall RemoveDirectoryW(wstr) kernel32.RemoveDirectoryW
-@ stdcall RemoveDllDirectory(ptr)
+@ stdcall RemoveDllDirectory(ptr) kernel32.RemoveDllDirectory
 # @ stub RemovePackageStatus
 # @ stub RemovePackageStatusForUser
 @ stdcall RemoveVectoredContinueHandler(ptr) ntdll.RtlRemoveVectoredContinueHandler
@@ -1419,7 +1419,7 @@
 @ stdcall SetCriticalSectionSpinCount(ptr long) ntdll.RtlSetCriticalSectionSpinCount
 @ stdcall SetCurrentDirectoryA(str)
 @ stdcall SetCurrentDirectoryW(wstr)
-@ stdcall SetDefaultDllDirectories(long)
+@ stdcall SetDefaultDllDirectories(long) kernel32.SetDefaultDllDirectories
 # @ stub SetDynamicTimeZoneInformation
 @ stdcall SetEndOfFile(long)
 @ stub SetEnvironmentStringsW
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 4a3e0f4722..de46cc8c10 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -31,175 +31,17 @@
 #include "winnls.h"
 #include "winternl.h"
 #include "kernelbase.h"
-#include "wine/list.h"
-#include "wine/asm.h"
 #include "wine/debug.h"
 #include "wine/exception.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
 
-/* to keep track of LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE file handles */
-struct exclusive_datafile
-{
-    struct list entry;
-    HMODULE     module;
-    HANDLE      file;
-};
-static struct list exclusive_datafile_list = LIST_INIT( exclusive_datafile_list );
-
-
 /***********************************************************************
  * Modules
  ***********************************************************************/
 
 
-/******************************************************************
- *      get_proc_address
- */
-FARPROC WINAPI get_proc_address( HMODULE module, LPCSTR function )
-{
-    FARPROC proc;
-    ANSI_STRING str;
-
-    if (!module) module = NtCurrentTeb()->Peb->ImageBaseAddress;
-
-    if ((ULONG_PTR)function >> 16)
-    {
-        RtlInitAnsiString( &str, function );
-        if (!set_ntstatus( LdrGetProcedureAddress( module, &str, 0, (void**)&proc ))) return NULL;
-    }
-    else if (!set_ntstatus( LdrGetProcedureAddress( module, NULL, LOWORD(function), (void**)&proc )))
-        return NULL;
-
-    return proc;
-}
-
-
-/******************************************************************
- *      load_library_as_datafile
- */
-static BOOL load_library_as_datafile( LPCWSTR load_path, DWORD flags, LPCWSTR name, HMODULE *mod_ret )
-{
-    static const WCHAR dotDLL[] = {'.','d','l','l',0};
-
-    WCHAR filenameW[MAX_PATH];
-    HANDLE mapping, file = INVALID_HANDLE_VALUE;
-    HMODULE module = 0;
-    DWORD protect = PAGE_READONLY;
-
-    *mod_ret = 0;
-
-    if (flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE) protect |= SEC_IMAGE;
-
-    if (SearchPathW( load_path, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
-    {
-        file = CreateFileW( filenameW, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE,
-                            NULL, OPEN_EXISTING, 0, 0 );
-    }
-    if (file == INVALID_HANDLE_VALUE) return FALSE;
-
-    mapping = CreateFileMappingW( file, NULL, protect, 0, 0, NULL );
-    if (!mapping) goto failed;
-
-    module = MapViewOfFile( mapping, FILE_MAP_READ, 0, 0, 0 );
-    CloseHandle( mapping );
-    if (!module) goto failed;
-
-    if (!(flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE))
-    {
-        /* make sure it's a valid PE file */
-        if (!RtlImageNtHeader( module )) goto failed;
-        *mod_ret = (HMODULE)((char *)module + 1); /* set bit 0 for data file module */
-
-        if (flags & LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE)
-        {
-            struct exclusive_datafile *file = HeapAlloc( GetProcessHeap(), 0, sizeof(*file) );
-            if (!file) goto failed;
-            file->module = *mod_ret;
-            file->file   = file;
-            list_add_head( &exclusive_datafile_list, &file->entry );
-            TRACE( "delaying close %p for module %p\n", file->file, file->module );
-            return TRUE;
-        }
-    }
-    else *mod_ret = (HMODULE)((char *)module + 2); /* set bit 1 for image resource module */
-
-    CloseHandle( file );
-    return TRUE;
-
-failed:
-    if (module) UnmapViewOfFile( module );
-    CloseHandle( file );
-    return FALSE;
-}
-
-
-/******************************************************************
- *      load_library
- */
-static HMODULE load_library( const UNICODE_STRING *libname, DWORD flags )
-{
-    const DWORD unsupported_flags = LOAD_IGNORE_CODE_AUTHZ_LEVEL | LOAD_LIBRARY_REQUIRE_SIGNED_TARGET;
-    NTSTATUS status;
-    HMODULE module;
-    WCHAR *load_path, *dummy;
-
-    if (flags & unsupported_flags) FIXME( "unsupported flag(s) used %#08x\n", flags );
-
-    if (!set_ntstatus( LdrGetDllPath( libname->Buffer, flags, &load_path, &dummy ))) return 0;
-
-    if (flags & (LOAD_LIBRARY_AS_DATAFILE | LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE |
-                 LOAD_LIBRARY_AS_IMAGE_RESOURCE))
-    {
-        ULONG_PTR magic;
-
-        LdrLockLoaderLock( 0, NULL, &magic );
-        if (!LdrGetDllHandle( load_path, flags, libname, &module ))
-        {
-            LdrAddRefDll( 0, module );
-            LdrUnlockLoaderLock( 0, magic );
-            goto done;
-        }
-        if (load_library_as_datafile( load_path, flags, libname->Buffer, &module ))
-        {
-            LdrUnlockLoaderLock( 0, magic );
-            goto done;
-        }
-        LdrUnlockLoaderLock( 0, magic );
-        flags |= DONT_RESOLVE_DLL_REFERENCES; /* Just in case */
-        /* Fallback to normal behaviour */
-    }
-
-    status = LdrLoadDll( load_path, flags, libname, &module );
-    if (status != STATUS_SUCCESS)
-    {
-        module = 0;
-        if (status == STATUS_DLL_NOT_FOUND && (GetVersion() & 0x80000000))
-            SetLastError( ERROR_DLL_NOT_FOUND );
-        else
-            SetLastError( RtlNtStatusToDosError( status ) );
-    }
-done:
-    RtlReleasePath( load_path );
-    return module;
-}
-
-
-/****************************************************************************
- *	AddDllDirectory   (kernelbase.@)
- */
-DLL_DIRECTORY_COOKIE WINAPI DECLSPEC_HOTPATCH AddDllDirectory( const WCHAR *dir )
-{
-    UNICODE_STRING str;
-    void *cookie;
-
-    RtlInitUnicodeString( &str, dir );
-    if (!set_ntstatus( LdrAddDllDirectory( &str, &cookie ))) return NULL;
-    return cookie;
-}
-
-
 /***********************************************************************
  *	DelayLoadFailureHook   (kernelbase.@)
  */
@@ -227,49 +69,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH DisableThreadLibraryCalls( HMODULE module )
 }
 
 
-/***********************************************************************
- *	FreeLibrary   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH FreeLibrary( HINSTANCE module )
-{
-    if (!module)
-    {
-        SetLastError( ERROR_INVALID_HANDLE );
-        return FALSE;
-    }
-
-    if ((ULONG_PTR)module & 3) /* this is a datafile module */
-    {
-        void *ptr = (void *)((ULONG_PTR)module & ~3);
-        if (!RtlImageNtHeader( ptr ))
-        {
-            SetLastError( ERROR_BAD_EXE_FORMAT );
-            return FALSE;
-        }
-        if ((ULONG_PTR)module & 1)
-        {
-            struct exclusive_datafile *file;
-            ULONG_PTR magic;
-
-            LdrLockLoaderLock( 0, NULL, &magic );
-            LIST_FOR_EACH_ENTRY( file, &exclusive_datafile_list, struct exclusive_datafile, entry )
-            {
-                if (file->module != module) continue;
-                TRACE( "closing %p for module %p\n", file->file, file->module );
-                CloseHandle( file->file );
-                list_remove( &file->entry );
-                HeapFree( GetProcessHeap(), 0, file );
-                break;
-            }
-            LdrUnlockLoaderLock( 0, magic );
-        }
-        return UnmapViewOfFile( ptr );
-    }
-
-    return set_ntstatus( LdrUnloadDll( module ));
-}
-
-
 /***********************************************************************
  *	GetModuleFileNameA   (kernelbase.@)
  */
@@ -426,133 +225,6 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetModuleHandleExW( DWORD flags, LPCWSTR name, HMO
 }
 
 
-/***********************************************************************
- *	GetProcAddress   (kernelbase.@)
- */
-
-#ifdef __x86_64__
-/*
- * Work around a Delphi bug on x86_64.  When delay loading a symbol,
- * Delphi saves rcx, rdx, r8 and r9 to the stack.  It then calls
- * GetProcAddress(), pops the saved registers and calls the function.
- * This works fine if all of the parameters are ints.  However, since
- * it does not save xmm0 - 3, it relies on GetProcAddress() preserving
- * these registers if the function takes floating point parameters.
- * This wrapper saves xmm0 - 3 to the stack.
- */
-__ASM_GLOBAL_FUNC( GetProcAddress,
-                   ".byte 0x48\n\t"  /* hotpatch prolog */
-                   "pushq %rbp\n\t"
-                   __ASM_SEH(".seh_pushreg %rbp\n\t")
-                   __ASM_CFI(".cfi_adjust_cfa_offset 8\n\t")
-                   __ASM_CFI(".cfi_rel_offset %rbp,0\n\t")
-                   "movq %rsp,%rbp\n\t"
-                   __ASM_SEH(".seh_setframe %rbp,0\n\t")
-                   __ASM_CFI(".cfi_def_cfa_register %rbp\n\t")
-                   "subq $0x60,%rsp\n\t"
-                   __ASM_SEH(".seh_stackalloc 0x60\n\t")
-                   __ASM_SEH(".seh_endprologue\n\t")
-                   "movaps %xmm0,-0x10(%rbp)\n\t"
-                   "movaps %xmm1,-0x20(%rbp)\n\t"
-                   "movaps %xmm2,-0x30(%rbp)\n\t"
-                   "movaps %xmm3,-0x40(%rbp)\n\t"
-                   "call " __ASM_NAME("get_proc_address") "\n\t"
-                   "movaps -0x40(%rbp), %xmm3\n\t"
-                   "movaps -0x30(%rbp), %xmm2\n\t"
-                   "movaps -0x20(%rbp), %xmm1\n\t"
-                   "movaps -0x10(%rbp), %xmm0\n\t"
-                   "leaq 0(%rbp),%rsp\n\t"
-                   __ASM_CFI(".cfi_def_cfa_register %rsp\n\t")
-                   "popq %rbp\n\t"
-                   __ASM_CFI(".cfi_adjust_cfa_offset -8\n\t")
-                   __ASM_CFI(".cfi_same_value %rbp\n\t")
-                   "ret" )
-#else /* __x86_64__ */
-
-FARPROC WINAPI DECLSPEC_HOTPATCH GetProcAddress( HMODULE module, LPCSTR function )
-{
-    return get_proc_address( module, function );
-}
-
-#endif /* __x86_64__ */
-
-
-/***********************************************************************
- *	LoadLibraryA   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryA( LPCSTR name )
-{
-    return LoadLibraryExA( name, 0, 0 );
-}
-
-
-/***********************************************************************
- *	LoadLibraryW   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryW( LPCWSTR name )
-{
-    return LoadLibraryExW( name, 0, 0 );
-}
-
-
-/******************************************************************
- *	LoadLibraryExA   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExA( LPCSTR name, HANDLE file, DWORD flags )
-{
-    WCHAR *nameW;
-
-    if (!(nameW = file_name_AtoW( name, FALSE ))) return 0;
-    return LoadLibraryExW( nameW, file, flags );
-}
-
-
-/***********************************************************************
- *	LoadLibraryExW   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH LoadLibraryExW( LPCWSTR name, HANDLE file, DWORD flags )
-{
-    UNICODE_STRING str;
-    HMODULE module;
-
-    if (!name)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return 0;
-    }
-    RtlInitUnicodeString( &str, name );
-    if (str.Buffer[str.Length/sizeof(WCHAR) - 1] != ' ') return load_library( &str, flags );
-
-    /* library name has trailing spaces */
-    RtlCreateUnicodeString( &str, name );
-    while (str.Length > sizeof(WCHAR) && str.Buffer[str.Length/sizeof(WCHAR) - 1] == ' ')
-        str.Length -= sizeof(WCHAR);
-
-    str.Buffer[str.Length/sizeof(WCHAR)] = 0;
-    module = load_library( &str, flags );
-    RtlFreeUnicodeString( &str );
-    return module;
-}
-
-
-/****************************************************************************
- *	RemoveDllDirectory   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH RemoveDllDirectory( DLL_DIRECTORY_COOKIE cookie )
-{
-    return set_ntstatus( LdrRemoveDllDirectory( cookie ));
-}
-
-
-/*************************************************************************
- *	SetDefaultDllDirectories   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH SetDefaultDllDirectories( DWORD flags )
-{
-    return set_ntstatus( LdrSetDefaultDllDirectories( flags ));
-}
-
-
 /***********************************************************************
  * Resources
  ***********************************************************************/
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index de304d8cd5..8d435f7862 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -73,9 +73,7 @@ const WCHAR system_dir[] = {'C',':','\\','w','i','n','d','o','w','s','\\',
 static const WCHAR system_path[] =
     {'C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m','3','2',';',
      'C',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m',';',
-     'C',':','\\','w','i','n','d','o','w','s',0};
-
-static const WCHAR dotW[] = {'.',0};
+     'C',':','\\','w','i','n','d','o','w','s',';',0};
 
 #define IS_OPTION_TRUE(ch) ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
 
@@ -84,17 +82,7 @@ static BOOL imports_fixup_done = FALSE;  /* set once the imports have been fixed
 static BOOL process_detaching = FALSE;  /* set on process detach to avoid deadlocks with thread detach */
 static int free_lib_count;   /* recursion depth of LdrUnloadDll calls */
 static ULONG path_safe_mode;  /* path mode set by RtlSetSearchPathMode */
-static ULONG dll_safe_mode = 1;  /* dll search mode */
 static UNICODE_STRING dll_directory;  /* extra path for LdrSetDllDirectory */
-static DWORD default_search_flags;  /* default flags set by LdrSetDefaultDllDirectories */
-
-struct dll_dir_entry
-{
-    struct list entry;
-    WCHAR       dir[1];
-};
-
-static struct list dll_dir_list = LIST_INIT( dll_dir_list );  /* extra dirs from LdrAddDllDirectory */
 
 static BOOL hide_wine_exports = FALSE;  /* try to hide ntdll wine exports from applications */
 
@@ -2249,54 +2237,25 @@ static BOOL is_valid_binary( HMODULE module, const pe_image_info_t *info )
 }
 
 
-/******************************************************************
- *		get_module_path_end
- *
- * Returns the end of the directory component of the module path.
- */
-static inline const WCHAR *get_module_path_end( const WCHAR *module )
-{
-    const WCHAR *p;
-    const WCHAR *mod_end = module;
-
-    if ((p = strrchrW( mod_end, '\\' ))) mod_end = p;
-    if ((p = strrchrW( mod_end, '/' ))) mod_end = p;
-    if (mod_end == module + 2 && module[1] == ':') mod_end++;
-    if (mod_end == module && module[0] && module[1] == ':') mod_end += 2;
-    return mod_end;
-}
-
-
-/******************************************************************
- *		append_path
- *
- * Append a counted string to the load path. Helper for get_dll_load_path.
- */
-static inline WCHAR *append_path( WCHAR *p, const WCHAR *str, int len )
-{
-    if (len == -1) len = strlenW(str);
-    if (!len) return p;
-    memcpy( p, str, len * sizeof(WCHAR) );
-    p[len] = ';';
-    return p + len + 1;
-}
-
-
 /******************************************************************
  *           get_dll_load_path
  */
-static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_mode, WCHAR **path )
+static NTSTATUS get_dll_load_path( LPCWSTR module, int safe_mode, WCHAR **path )
 {
     static const WCHAR pathW[] = {'P','A','T','H',0};
+    static const WCHAR dotW[] = {'.',';',0};
 
     const WCHAR *mod_end = module;
     UNICODE_STRING name, value;
     WCHAR *p, *ret;
-    int len = ARRAY_SIZE(system_path) + 1, path_len = 0;
+    int len = ARRAY_SIZE(system_path), path_len = 0;
 
     if (module)
     {
-        mod_end = get_module_path_end( module );
+        if ((p = strrchrW( mod_end, '\\' ))) mod_end = p;
+        if ((p = strrchrW( mod_end, '/' ))) mod_end = p;
+        if (mod_end == module + 2 && module[1] == ':') mod_end++;
+        if (mod_end == module && module[0] && module[1] == ':') mod_end += 2;
         len += (mod_end - module) + 1;
     }
 
@@ -2307,18 +2266,18 @@ static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_m
     if (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
         path_len = value.Length;
 
-    if (dll_dir) len += strlenW( dll_dir ) + 1;
-    else len += 2;  /* current directory */
-    if (!(p = ret = RtlAllocateHeap( GetProcessHeap(), 0, path_len + len * sizeof(WCHAR) )))
+    len += 2;  /* current directory */
+    if (!(ret = RtlAllocateHeap( GetProcessHeap(), 0, path_len + len * sizeof(WCHAR) )))
         return STATUS_NO_MEMORY;
-
-    p = append_path( p, module, mod_end - module );
-    if (dll_dir) p = append_path( p, dll_dir, -1 );
-    else if (!safe_mode) p = append_path( p, dotW, -1 );
-    p = append_path( p, system_path, -1 );
-    if (!dll_dir && safe_mode) p = append_path( p, dotW, -1 );
-
-    value.Buffer = p;
+    memcpy( ret, module, (mod_end - module) * sizeof(WCHAR) );
+    p = ret + (mod_end - module);
+    if (p > ret) *p++ = ';';
+    *p = 0;
+    if (!safe_mode) strcatW( ret, dotW );
+    strcatW( ret, system_path );
+    if (safe_mode) strcatW( ret, dotW );
+
+    value.Buffer = ret + strlenW(ret);
     value.MaximumLength = path_len;
 
     while (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) == STATUS_BUFFER_TOO_SMALL)
@@ -2342,69 +2301,6 @@ static NTSTATUS get_dll_load_path( LPCWSTR module, LPCWSTR dll_dir, ULONG safe_m
 }
 
 
-/******************************************************************
- *		get_dll_load_path_search_flags
- */
-static NTSTATUS get_dll_load_path_search_flags( LPCWSTR module, DWORD flags, WCHAR **path )
-{
-    const WCHAR *image = NULL, *mod_end, *image_end;
-    struct dll_dir_entry *dir;
-    WCHAR *p, *ret;
-    int len = 1;
-
-    if (flags & LOAD_LIBRARY_SEARCH_DEFAULT_DIRS)
-        flags |= (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
-                  LOAD_LIBRARY_SEARCH_USER_DIRS |
-                  LOAD_LIBRARY_SEARCH_SYSTEM32);
-
-    if (flags & LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR)
-    {
-        DWORD type = RtlDetermineDosPathNameType_U( module );
-        if (type != ABSOLUTE_DRIVE_PATH && type != ABSOLUTE_PATH)
-            return STATUS_INVALID_PARAMETER;
-        mod_end = get_module_path_end( module );
-        len += (mod_end - module) + 1;
-    }
-    else module = NULL;
-
-    if (flags & LOAD_LIBRARY_SEARCH_APPLICATION_DIR)
-    {
-        image = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-        image_end = get_module_path_end( image );
-        len += (image_end - image) + 1;
-    }
-
-    if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
-    {
-        LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
-            len += strlenW( dir->dir + 4 /* \??\ */ ) + 1;
-        if (dll_directory.Length) len += dll_directory.Length / sizeof(WCHAR) + 1;
-    }
-
-    if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) len += strlenW( system_dir );
-
-    if ((p = ret = RtlAllocateHeap( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
-    {
-        if (module) p = append_path( p, module, mod_end - module );
-        if (image) p = append_path( p, image, image_end - image );
-        if (flags & LOAD_LIBRARY_SEARCH_USER_DIRS)
-        {
-            LIST_FOR_EACH_ENTRY( dir, &dll_dir_list, struct dll_dir_entry, entry )
-                p = append_path( p, dir->dir + 4 /* \??\ */, -1 );
-            p = append_path( p, dll_directory.Buffer, dll_directory.Length / sizeof(WCHAR) );
-        }
-        if (flags & LOAD_LIBRARY_SEARCH_SYSTEM32) strcpyW( p, system_dir );
-        else
-        {
-            if (p > ret) p--;
-            *p = 0;
-        }
-    }
-    *path = ret;
-    return STATUS_SUCCESS;
-}
-
-
 /***********************************************************************
  *	open_dll_file
  *
@@ -4143,7 +4039,6 @@ static void load_global_options(void)
                                      'S','e','s','s','i','o','n',' ','M','a','n','a','g','e','r',0};
     static const WCHAR globalflagW[] = {'G','l','o','b','a','l','F','l','a','g',0};
     static const WCHAR safesearchW[] = {'S','a','f','e','P','r','o','c','e','s','s','S','e','a','r','c','h','M','o','d','e',0};
-    static const WCHAR safedllmodeW[] = {'S','a','f','e','D','l','l','S','e','a','r','c','h','M','o','d','e',0};
     static const WCHAR critsectW[] = {'C','r','i','t','i','c','a','l','S','e','c','t','i','o','n','T','i','m','e','o','u','t',0};
     static const WCHAR heapresW[] = {'H','e','a','p','S','e','g','m','e','n','t','R','e','s','e','r','v','e',0};
     static const WCHAR heapcommitW[] = {'H','e','a','p','S','e','g','m','e','n','t','C','o','m','m','i','t',0};
@@ -4167,7 +4062,6 @@ static void load_global_options(void)
 
     query_dword_option( hkey, globalflagW, &NtCurrentTeb()->Peb->NtGlobalFlag );
     query_dword_option( hkey, safesearchW, &path_safe_mode );
-    query_dword_option( hkey, safedllmodeW, &dll_safe_mode );
 
     if (!query_dword_option( hkey, critsectW, &value ))
         NtCurrentTeb()->Peb->CriticalSectionTimeout.QuadPart = (ULONGLONG)value * -10000000;
@@ -4320,124 +4214,6 @@ NTSTATUS WINAPI LdrSetDllDirectory( const UNICODE_STRING *dir )
 }
 
 
-/****************************************************************************
- *		LdrAddDllDirectory  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrAddDllDirectory( const UNICODE_STRING *dir, void **cookie )
-{
-    FILE_BASIC_INFORMATION info;
-    UNICODE_STRING nt_name;
-    NTSTATUS status;
-    OBJECT_ATTRIBUTES attr;
-    DWORD len;
-    struct dll_dir_entry *ptr;
-    DOS_PATHNAME_TYPE type = RtlDetermineDosPathNameType_U( dir->Buffer );
-
-    if (type != ABSOLUTE_PATH && type != ABSOLUTE_DRIVE_PATH)
-        return STATUS_INVALID_PARAMETER;
-
-    status = RtlDosPathNameToNtPathName_U_WithStatus( dir->Buffer, &nt_name, NULL, NULL );
-    if (status) return status;
-    len = nt_name.Length / sizeof(WCHAR);
-    if (!(ptr = RtlAllocateHeap( GetProcessHeap(), 0, offsetof(struct dll_dir_entry, dir[++len] ))))
-        return STATUS_NO_MEMORY;
-    memcpy( ptr->dir, nt_name.Buffer, len * sizeof(WCHAR) );
-
-    attr.Length = sizeof(attr);
-    attr.RootDirectory = 0;
-    attr.Attributes = OBJ_CASE_INSENSITIVE;
-    attr.ObjectName = &nt_name;
-    attr.SecurityDescriptor = NULL;
-    attr.SecurityQualityOfService = NULL;
-    status = NtQueryAttributesFile( &attr, &info );
-    RtlFreeUnicodeString( &nt_name );
-
-    if (!status)
-    {
-        TRACE( "%s\n", debugstr_w( ptr->dir ));
-        RtlEnterCriticalSection( &dlldir_section );
-        list_add_head( &dll_dir_list, &ptr->entry );
-        RtlLeaveCriticalSection( &dlldir_section );
-        *cookie = ptr;
-    }
-    else RtlFreeHeap( GetProcessHeap(), 0, ptr );
-    return status;
-}
-
-
-/****************************************************************************
- *		LdrRemoveDllDirectory  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrRemoveDllDirectory( void *cookie )
-{
-    struct dll_dir_entry *ptr = cookie;
-
-    TRACE( "%s\n", debugstr_w( ptr->dir ));
-
-    RtlEnterCriticalSection( &dlldir_section );
-    list_remove( &ptr->entry );
-    RtlFreeHeap( GetProcessHeap(), 0, ptr );
-    RtlLeaveCriticalSection( &dlldir_section );
-    return STATUS_SUCCESS;
-}
-
-
-/*************************************************************************
- *		LdrSetDefaultDllDirectories  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrSetDefaultDllDirectories( ULONG flags )
-{
-    /* LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR doesn't make sense in default dirs */
-    const ULONG load_library_search_flags = (LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
-                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
-                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
-                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
-
-    if (!flags || (flags & ~load_library_search_flags)) return STATUS_INVALID_PARAMETER;
-    default_search_flags = flags;
-    return STATUS_SUCCESS;
-}
-
-
-/******************************************************************
- *		LdrGetDllPath  (NTDLL.@)
- */
-NTSTATUS WINAPI LdrGetDllPath( PCWSTR module, ULONG flags, PWSTR *path, PWSTR *unknown )
-{
-    NTSTATUS status;
-    const ULONG load_library_search_flags = (LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR |
-                                             LOAD_LIBRARY_SEARCH_APPLICATION_DIR |
-                                             LOAD_LIBRARY_SEARCH_USER_DIRS |
-                                             LOAD_LIBRARY_SEARCH_SYSTEM32 |
-                                             LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
-
-    if (flags & LOAD_WITH_ALTERED_SEARCH_PATH)
-    {
-        if (flags & load_library_search_flags) return STATUS_INVALID_PARAMETER;
-        if (default_search_flags) flags |= default_search_flags | LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR;
-    }
-    else if (!(flags & load_library_search_flags)) flags |= default_search_flags;
-
-    RtlEnterCriticalSection( &dlldir_section );
-
-    if (flags & load_library_search_flags)
-    {
-        status = get_dll_load_path_search_flags( module, flags, path );
-    }
-    else
-    {
-        const WCHAR *dlldir = dll_directory.Length ? dll_directory.Buffer : NULL;
-        if (!(flags & LOAD_WITH_ALTERED_SEARCH_PATH))
-            module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-        status = get_dll_load_path( module, dlldir, dll_safe_mode, path );
-    }
-
-    RtlLeaveCriticalSection( &dlldir_section );
-    *unknown = NULL;
-    return status;
-}
-
-
 /*************************************************************************
  *		RtlSetSearchPathMode (NTDLL.@)
  */
@@ -4470,38 +4246,13 @@ NTSTATUS WINAPI RtlSetSearchPathMode( ULONG flags )
 }
 
 
-/******************************************************************
- *           RtlGetExePath   (NTDLL.@)
- */
-NTSTATUS WINAPI RtlGetExePath( PCWSTR name, PWSTR *path )
-{
-    static const WCHAR emptyW[1];
-    const WCHAR *dlldir = dotW;
-    const WCHAR *module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-
-    /* same check as NeedCurrentDirectoryForExePathW */
-    if (!strchrW( name, '\\' ))
-    {
-        static const WCHAR env_name[] = {'N','o','D','e','f','a','u','l','t','C','u','r','r','e','n','t',
-                                         'D','i','r','e','c','t','o','r','y','I','n',
-                                         'E','x','e','P','a','t','h',0};
-        UNICODE_STRING name, value = { 0 };
-
-        RtlInitUnicodeString( &name, env_name );
-        if (RtlQueryEnvironmentVariable_U( NULL, &name, &value ) != STATUS_VARIABLE_NOT_FOUND)
-            dlldir = emptyW;
-    }
-    return get_dll_load_path( module, dlldir, FALSE, path );
-}
-
-
 /******************************************************************
  *           RtlGetSearchPath   (NTDLL.@)
  */
 NTSTATUS WINAPI RtlGetSearchPath( PWSTR *path )
 {
-    const WCHAR *module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-    return get_dll_load_path( module, NULL, path_safe_mode, path );
+    WCHAR *module = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    return get_dll_load_path( module, path_safe_mode, path );
 }
 
 
diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 1881571b41..00332c7a20 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -71,7 +71,6 @@
 @ stub KiUserExceptionDispatcher
 # @ stub LdrAccessOutOfProcessResource
 @ stdcall LdrAccessResource(long ptr ptr ptr)
-@ stdcall LdrAddDllDirectory(ptr ptr)
 @ stdcall LdrAddRefDll(long ptr)
 # @ stub LdrAlternateResourcesEnabled
 # @ stub LdrCreateOutOfProcessImage
@@ -85,10 +84,9 @@
 # @ stub LdrFindResourceEx_U
 @ stdcall LdrFindResource_U(long ptr long ptr)
 @ stub LdrFlushAlternateResourceModules
-@ stdcall LdrGetDllDirectory(ptr)
 @ stdcall LdrGetDllHandle(wstr long ptr ptr)
 # @ stub LdrGetDllHandleEx
-@ stdcall LdrGetDllPath(wstr long ptr ptr)
+@ stdcall LdrGetDllDirectory(ptr)
 @ stdcall LdrGetProcedureAddress(ptr ptr long ptr)
 # @ stub LdrHotPatchRoutine
 @ stub LdrInitShimEngineDynamic
@@ -100,10 +98,8 @@
 @ stdcall LdrQueryImageFileExecutionOptions(ptr wstr long ptr long ptr)
 @ stdcall LdrQueryProcessModuleInformation(ptr long ptr)
 @ stdcall LdrRegisterDllNotification(long ptr ptr ptr)
-@ stdcall LdrRemoveDllDirectory(ptr)
 @ stdcall LdrResolveDelayLoadedAPI(ptr ptr ptr ptr ptr long)
 @ stub LdrSetAppCompatDllRedirectionCallback
-@ stdcall LdrSetDefaultDllDirectories(long)
 @ stdcall LdrSetDllDirectory(ptr)
 @ stub LdrSetDllManifestProber
 @ stdcall LdrShutdownProcess()
@@ -687,7 +683,6 @@
 @ stdcall RtlGetDaclSecurityDescriptor(ptr ptr ptr ptr)
 @ stub RtlGetElementGenericTable
 # @ stub RtlGetElementGenericTableAvl
-@ stdcall RtlGetExePath(wstr ptr)
 # @ stub RtlGetFirstRange
 @ stdcall RtlGetFrame()
 @ stdcall RtlGetFullPathName_U(wstr long ptr ptr)
diff --git a/include/winternl.h b/include/winternl.h
index e542d3cc90..0eb1fdd162 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -2421,7 +2421,6 @@ NTSYSAPI NTSTATUS  WINAPI DbgUiIssueRemoteBreakin(HANDLE);
 NTSYSAPI void      WINAPI DbgUiRemoteBreakin(void*);
 NTSYSAPI void      WINAPI DbgUserBreakPoint(void);
 NTSYSAPI NTSTATUS  WINAPI LdrAccessResource(HMODULE,const IMAGE_RESOURCE_DATA_ENTRY*,void**,PULONG);
-NTSYSAPI NTSTATUS  WINAPI LdrAddDllDirectory(const UNICODE_STRING*,void**);
 NTSYSAPI NTSTATUS  WINAPI LdrAddRefDll(ULONG,HMODULE);
 NTSYSAPI NTSTATUS  WINAPI LdrDisableThreadCalloutsForDll(HMODULE);
 NTSYSAPI NTSTATUS  WINAPI LdrFindEntryForAddress(const void*, PLDR_MODULE*);
@@ -2429,15 +2428,12 @@ NTSYSAPI NTSTATUS  WINAPI LdrFindResourceDirectory_U(HMODULE,const LDR_RESOURCE_
 NTSYSAPI NTSTATUS  WINAPI LdrFindResource_U(HMODULE,const LDR_RESOURCE_INFO*,ULONG,const IMAGE_RESOURCE_DATA_ENTRY**);
 NTSYSAPI NTSTATUS  WINAPI LdrGetDllDirectory(UNICODE_STRING*);
 NTSYSAPI NTSTATUS  WINAPI LdrGetDllHandle(LPCWSTR, ULONG, const UNICODE_STRING*, HMODULE*);
-NTSYSAPI NTSTATUS  WINAPI LdrGetDllPath(PCWSTR,ULONG,PWSTR*,PWSTR*);
 NTSYSAPI NTSTATUS  WINAPI LdrGetProcedureAddress(HMODULE, const ANSI_STRING*, ULONG, void**);
 NTSYSAPI NTSTATUS  WINAPI LdrLoadDll(LPCWSTR, DWORD, const UNICODE_STRING*, HMODULE*);
 NTSYSAPI NTSTATUS  WINAPI LdrLockLoaderLock(ULONG,ULONG*,ULONG_PTR*);
 IMAGE_BASE_RELOCATION * WINAPI LdrProcessRelocationBlock(void*,UINT,USHORT*,INT_PTR);
 NTSYSAPI NTSTATUS  WINAPI LdrQueryImageFileExecutionOptions(const UNICODE_STRING*,LPCWSTR,ULONG,void*,ULONG,ULONG*);
 NTSYSAPI NTSTATUS  WINAPI LdrQueryProcessModuleInformation(SYSTEM_MODULE_INFORMATION*, ULONG, ULONG*);
-NTSYSAPI NTSTATUS  WINAPI LdrRemoveDllDirectory(void*);
-NTSYSAPI NTSTATUS  WINAPI LdrSetDefaultDllDirectories(ULONG);
 NTSYSAPI NTSTATUS  WINAPI LdrSetDllDirectory(const UNICODE_STRING*);
 NTSYSAPI void      WINAPI LdrShutdownProcess(void);
 NTSYSAPI void      WINAPI LdrShutdownThread(void);
@@ -2837,7 +2833,6 @@ NTSYSAPI NTSTATUS  WINAPI RtlGetControlSecurityDescriptor(PSECURITY_DESCRIPTOR,
 NTSYSAPI ULONG     WINAPI RtlGetCurrentDirectory_U(ULONG, LPWSTR);
 NTSYSAPI PEB *     WINAPI RtlGetCurrentPeb(void);
 NTSYSAPI NTSTATUS  WINAPI RtlGetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR,PBOOLEAN,PACL *,PBOOLEAN);
-NTSYSAPI NTSTATUS  WINAPI RtlGetExePath(PCWSTR,PWSTR*);
 NTSYSAPI TEB_ACTIVE_FRAME * WINAPI RtlGetFrame(void);
 NTSYSAPI ULONG     WINAPI RtlGetFullPathName_U(PCWSTR,ULONG,PWSTR,PWSTR*);
 NTSYSAPI NTSTATUS  WINAPI RtlGetGroupSecurityDescriptor(PSECURITY_DESCRIPTOR,PSID *,PBOOLEAN);

From 743d5f207440ef2dc05ee58b72ad0d61d05eb4c0 Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Fri, 27 Sep 2019 10:40:58 +0200
Subject: Revert "kernel32: Move delay-load functions to kernelbase."

This reverts commit 0f5538b9e349fe7b5924b8c0b84ca8a917962701.

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index e051ac0e7a..eb5e0ef5b3 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -356,7 +356,7 @@
 @ stdcall DecodeSystemPointer(ptr) ntdll.RtlDecodeSystemPointer
 @ stdcall DefineDosDeviceA(long str str)
 @ stdcall DefineDosDeviceW(long wstr wstr)
-@ stdcall -import DelayLoadFailureHook(str str)
+@ stdcall DelayLoadFailureHook(str str)
 @ stdcall DeleteAtom(long)
 # @ stub DeleteBoundaryDescriptor
 @ stdcall DeleteCriticalSection(ptr) ntdll.RtlDeleteCriticalSection
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index ad6956d1ce..24fb9e33f5 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -1018,6 +1018,23 @@ FARPROC WINAPI GetProcAddress( HMODULE hModule, LPCSTR function )
     return get_proc_address_wrapper( hModule, function );
 }
 
+/***********************************************************************
+ *           DelayLoadFailureHook  (KERNEL32.@)
+ */
+FARPROC WINAPI DelayLoadFailureHook( LPCSTR name, LPCSTR function )
+{
+    ULONG_PTR args[2];
+
+    if ((ULONG_PTR)function >> 16)
+        ERR( "failed to delay load %s.%s\n", name, function );
+    else
+        ERR( "failed to delay load %s.%u\n", name, LOWORD(function) );
+    args[0] = (ULONG_PTR)name;
+    args[1] = (ULONG_PTR)function;
+    RaiseException( EXCEPTION_WINE_STUB, EH_NONCONTINUABLE, 2, args );
+    return NULL;
+}
+
 typedef struct _PEB32
 {
     BOOLEAN InheritedAddressSpace;
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index b582b3d092..eeb46952ea 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -244,7 +244,7 @@
 # @ stub DecodeRemotePointer
 @ stdcall DecodeSystemPointer(ptr) ntdll.RtlDecodeSystemPointer
 @ stdcall DefineDosDeviceW(long wstr wstr) kernel32.DefineDosDeviceW
-@ stdcall DelayLoadFailureHook(str str)
+@ stdcall DelayLoadFailureHook(str str) kernel32.DelayLoadFailureHook
 # @ stub DelayLoadFailureHookLookup
 @ stdcall DeleteAce(ptr long)
 # @ stub DeleteBoundaryDescriptor
@@ -1343,7 +1343,7 @@
 @ stdcall ResetEvent(long)
 # @ stub ResetState
 @ stdcall ResetWriteWatch(ptr long)
-@ stdcall -import ResolveDelayLoadedAPI(ptr ptr ptr ptr ptr long) LdrResolveDelayLoadedAPI
+@ stdcall ResolveDelayLoadedAPI(ptr ptr ptr ptr ptr long) kernel32.ResolveDelayLoadedAPI
 # @ stub ResolveDelayLoadsFromDll
 @ stdcall ResolveLocaleName(wstr ptr long)
 @ stdcall RestoreLastError(long) ntdll.RtlRestoreLastWin32Error
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 9d0486d8a6..34c8add910 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -42,24 +42,6 @@ WINE_DEFAULT_DEBUG_CHANNEL(module);
  ***********************************************************************/
 
 
-/***********************************************************************
- *	DelayLoadFailureHook   (kernelbase.@)
- */
-FARPROC WINAPI DECLSPEC_HOTPATCH DelayLoadFailureHook( LPCSTR name, LPCSTR function )
-{
-    ULONG_PTR args[2];
-
-    if ((ULONG_PTR)function >> 16)
-        ERR( "failed to delay load %s.%s\n", name, function );
-    else
-        ERR( "failed to delay load %s.%u\n", name, LOWORD(function) );
-    args[0] = (ULONG_PTR)name;
-    args[1] = (ULONG_PTR)function;
-    RaiseException( EXCEPTION_WINE_STUB, EH_NONCONTINUABLE, 2, args );
-    return NULL;
-}
-
-
 /****************************************************************************
  *	DisableThreadLibraryCalls   (kernelbase.@)
  */


From 8b947e5cc131821ec51434ee2446682a707e02cb Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Tue, 13 Aug 2019 05:16:50 +0200
Subject: Revert "kernel32: Move some module functions to kernelbase."

This reverts commit 05d00276c627753487c571c30fddfc56c02ad37e.

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 016c3022dc..bb496425aa 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -377,7 +377,7 @@
 @ stdcall DeleteVolumeMountPointW(wstr)
 @ stdcall -arch=x86_64 DequeueUmsCompletionListItems(ptr long ptr)
 @ stdcall DeviceIoControl(long long ptr long ptr long ptr ptr)
-@ stdcall -import DisableThreadLibraryCalls(long)
+@ stdcall DisableThreadLibraryCalls(long)
 @ stdcall -import DisconnectNamedPipe(long)
 @ stdcall DnsHostnameToComputerNameA (str ptr ptr)
 @ stdcall DnsHostnameToComputerNameW (wstr ptr ptr)
@@ -718,12 +718,12 @@
 @ stdcall GetMailslotInfo(long ptr ptr ptr ptr)
 @ stdcall GetMaximumProcessorCount(long)
 @ stdcall GetMaximumProcessorGroupCount()
-@ stdcall -import GetModuleFileNameA(long ptr long)
-@ stdcall -import GetModuleFileNameW(long ptr long)
-@ stdcall -import GetModuleHandleA(str)
-@ stdcall -import GetModuleHandleExA(long ptr ptr)
-@ stdcall -import GetModuleHandleExW(long ptr ptr)
-@ stdcall -import GetModuleHandleW(wstr)
+@ stdcall GetModuleFileNameA(long ptr long)
+@ stdcall GetModuleFileNameW(long ptr long)
+@ stdcall GetModuleHandleA(str)
+@ stdcall GetModuleHandleExA(long ptr ptr)
+@ stdcall GetModuleHandleExW(long ptr ptr)
+@ stdcall GetModuleHandleW(wstr)
 # @ stub GetNamedPipeAttribute
 # @ stub GetNamedPipeClientComputerNameA
 # @ stub GetNamedPipeClientComputerNameW
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index acfc365200..386a7c2239 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -233,6 +233,33 @@ BOOL WINAPI SetDefaultDllDirectories( DWORD flags )
 }
 
 
+/****************************************************************************
+ *              DisableThreadLibraryCalls (KERNEL32.@)
+ *
+ * Inform the module loader that thread notifications are not required for a dll.
+ *
+ * PARAMS
+ *  hModule [I] Module handle to skip calls for
+ *
+ * RETURNS
+ *  Success: TRUE. Thread attach and detach notifications will not be sent
+ *           to hModule.
+ *  Failure: FALSE. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ *  This is typically called from the dll entry point of a dll during process
+ *  attachment, for dlls that do not need to process thread notifications.
+ */
+BOOL WINAPI DisableThreadLibraryCalls( HMODULE hModule )
+{
+    NTSTATUS    nts = LdrDisableThreadCalloutsForDll( hModule );
+    if (nts == STATUS_SUCCESS) return TRUE;
+
+    SetLastError( RtlNtStatusToDosError( nts ) );
+    return FALSE;
+}
+
+
 /***********************************************************************
  *             GetBinaryTypeW                     [KERNEL32.@]
  *
@@ -375,6 +402,194 @@ BOOL WINAPI GetBinaryTypeA( LPCSTR lpApplicationName, LPDWORD lpBinaryType )
     return FALSE;
 }
 
+/***********************************************************************
+ *              GetModuleHandleExA         (KERNEL32.@)
+ */
+BOOL WINAPI GetModuleHandleExA( DWORD flags, LPCSTR name, HMODULE *module )
+{
+    WCHAR *nameW;
+
+    if (!name || (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS))
+        return GetModuleHandleExW( flags, (LPCWSTR)name, module );
+
+    if (!(nameW = FILE_name_AtoW( name, FALSE ))) return FALSE;
+    return GetModuleHandleExW( flags, nameW, module );
+}
+
+/***********************************************************************
+ *              GetModuleHandleExW         (KERNEL32.@)
+ */
+BOOL WINAPI GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+    HMODULE ret;
+    ULONG_PTR magic;
+    BOOL lock;
+
+    if (!module)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
+
+    /* if we are messing with the refcount, grab the loader lock */
+    lock = (flags & GET_MODULE_HANDLE_EX_FLAG_PIN) || !(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT);
+    if (lock)
+        LdrLockLoaderLock( 0, NULL, &magic );
+
+    if (!name)
+    {
+        ret = NtCurrentTeb()->Peb->ImageBaseAddress;
+    }
+    else if (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS)
+    {
+        void *dummy;
+        if (!(ret = RtlPcToFileHeader( (void *)name, &dummy ))) status = STATUS_DLL_NOT_FOUND;
+    }
+    else
+    {
+        UNICODE_STRING wstr;
+        RtlInitUnicodeString( &wstr, name );
+        status = LdrGetDllHandle( NULL, 0, &wstr, &ret );
+    }
+
+    if (status == STATUS_SUCCESS)
+    {
+        if (flags & GET_MODULE_HANDLE_EX_FLAG_PIN)
+            LdrAddRefDll( LDR_ADDREF_DLL_PIN, ret );
+        else if (!(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT))
+            LdrAddRefDll( 0, ret );
+    }
+    else SetLastError( RtlNtStatusToDosError( status ) );
+
+    if (lock)
+        LdrUnlockLoaderLock( 0, magic );
+
+    if (status == STATUS_SUCCESS) *module = ret;
+    else *module = NULL;
+
+    return (status == STATUS_SUCCESS);
+}
+
+/***********************************************************************
+ *              GetModuleHandleA         (KERNEL32.@)
+ *
+ * Get the handle of a dll loaded into the process address space.
+ *
+ * PARAMS
+ *  module [I] Name of the dll
+ *
+ * RETURNS
+ *  Success: A handle to the loaded dll.
+ *  Failure: A NULL handle. Use GetLastError() to determine the cause.
+ */
+HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleA(LPCSTR module)
+{
+    HMODULE ret;
+
+    GetModuleHandleExA( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
+    return ret;
+}
+
+/***********************************************************************
+ *		GetModuleHandleW (KERNEL32.@)
+ *
+ * Unicode version of GetModuleHandleA.
+ */
+HMODULE WINAPI GetModuleHandleW(LPCWSTR module)
+{
+    HMODULE ret;
+
+    GetModuleHandleExW( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
+    return ret;
+}
+
+
+/***********************************************************************
+ *              GetModuleFileNameA      (KERNEL32.@)
+ *
+ * Get the file name of a loaded module from its handle.
+ *
+ * RETURNS
+ *  Success: The length of the file name, excluding the terminating NUL.
+ *  Failure: 0. Use GetLastError() to determine the cause.
+ *
+ * NOTES
+ *  This function always returns the long path of hModule
+ *  The function doesn't write a terminating '\0' if the buffer is too 
+ *  small.
+ */
+DWORD WINAPI GetModuleFileNameA(
+	HMODULE hModule,	/* [in] Module handle (32 bit) */
+	LPSTR lpFileName,	/* [out] Destination for file name */
+        DWORD size )		/* [in] Size of lpFileName in characters */
+{
+    LPWSTR filenameW = HeapAlloc( GetProcessHeap(), 0, size * sizeof(WCHAR) );
+    DWORD len;
+
+    if (!filenameW)
+    {
+        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
+        return 0;
+    }
+    if ((len = GetModuleFileNameW( hModule, filenameW, size )))
+    {
+    	len = FILE_name_WtoA( filenameW, len, lpFileName, size );
+        if (len < size)
+            lpFileName[len] = '\0';
+        else
+            SetLastError( ERROR_INSUFFICIENT_BUFFER );
+    }
+    HeapFree( GetProcessHeap(), 0, filenameW );
+    return len;
+}
+
+/***********************************************************************
+ *              GetModuleFileNameW      (KERNEL32.@)
+ *
+ * Unicode version of GetModuleFileNameA.
+ */
+DWORD WINAPI GetModuleFileNameW( HMODULE hModule, LPWSTR lpFileName, DWORD size )
+{
+    ULONG len = 0;
+    ULONG_PTR magic;
+    LDR_MODULE *pldr;
+    NTSTATUS nts;
+    WIN16_SUBSYSTEM_TIB *win16_tib;
+
+    if (!hModule && ((win16_tib = NtCurrentTeb()->Tib.SubSystemTib)) && win16_tib->exe_name)
+    {
+        len = min(size, win16_tib->exe_name->Length / sizeof(WCHAR));
+        memcpy( lpFileName, win16_tib->exe_name->Buffer, len * sizeof(WCHAR) );
+        if (len < size) lpFileName[len] = '\0';
+        goto done;
+    }
+
+    LdrLockLoaderLock( 0, NULL, &magic );
+
+    if (!hModule) hModule = NtCurrentTeb()->Peb->ImageBaseAddress;
+    nts = LdrFindEntryForAddress( hModule, &pldr );
+    if (nts == STATUS_SUCCESS)
+    {
+        len = min(size, pldr->FullDllName.Length / sizeof(WCHAR));
+        memcpy(lpFileName, pldr->FullDllName.Buffer, len * sizeof(WCHAR));
+        if (len < size)
+        {
+            lpFileName[len] = '\0';
+            SetLastError( 0 );
+        }
+        else
+            SetLastError( ERROR_INSUFFICIENT_BUFFER );
+    }
+    else SetLastError( RtlNtStatusToDosError( nts ) );
+
+    LdrUnlockLoaderLock( 0, magic );
+done:
+    TRACE( "%s\n", debugstr_wn(lpFileName, len) );
+    return len;
+}
+
+
 /***********************************************************************
  *           get_dll_system_path
  */
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 4bb2b55cde..1b8c4cc236 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -263,7 +263,7 @@
 @ stdcall DestroyPrivateObjectSecurity(ptr)
 @ stdcall DeviceIoControl(long long ptr long ptr long ptr ptr) kernel32.DeviceIoControl
 @ stdcall DisablePredefinedHandleTableInternal(long)
-@ stdcall DisableThreadLibraryCalls(long)
+@ stdcall DisableThreadLibraryCalls(long) kernel32.DisableThreadLibraryCalls
 @ stdcall DisassociateCurrentThreadFromCallback(ptr) ntdll.TpDisassociateCallback
 # @ stub DiscardVirtualMemory
 @ stdcall DisconnectNamedPipe(long)
@@ -556,14 +556,14 @@
 # @ stub GetMemoryErrorHandlingCapabilities
 # @ stub GetModuleBaseNameA
 # @ stub GetModuleBaseNameW
-@ stdcall GetModuleFileNameA(long ptr long)
+@ stdcall GetModuleFileNameA(long ptr long) kernel32.GetModuleFileNameA
 # @ stub GetModuleFileNameExA
 # @ stub GetModuleFileNameExW
-@ stdcall GetModuleFileNameW(long ptr long)
-@ stdcall GetModuleHandleA(str)
-@ stdcall GetModuleHandleExA(long ptr ptr)
-@ stdcall GetModuleHandleExW(long ptr ptr)
-@ stdcall GetModuleHandleW(wstr)
+@ stdcall GetModuleFileNameW(long ptr long) kernel32.GetModuleFileNameW
+@ stdcall GetModuleHandleA(str) kernel32.GetModuleHandleA
+@ stdcall GetModuleHandleExA(long ptr ptr) kernel32.GetModuleHandleExA
+@ stdcall GetModuleHandleExW(long ptr ptr) kernel32.GetModuleHandleExW
+@ stdcall GetModuleHandleW(wstr) kernel32.GetModuleHandleW
 # @ stub GetModuleInformation
 @ stub GetNLSVersion
 @ stub GetNLSVersionEx
diff --git a/dlls/kernelbase/loader.c b/dlls/kernelbase/loader.c
index 34c8add910..91daa4ec14 100644
--- a/dlls/kernelbase/loader.c
+++ b/dlls/kernelbase/loader.c
@@ -37,176 +37,6 @@
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
 
-/***********************************************************************
- * Modules
- ***********************************************************************/
-
-
-/****************************************************************************
- *	DisableThreadLibraryCalls   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH DisableThreadLibraryCalls( HMODULE module )
-{
-    return set_ntstatus( LdrDisableThreadCalloutsForDll( module ));
-}
-
-
-/***********************************************************************
- *	GetModuleFileNameA   (kernelbase.@)
- */
-DWORD WINAPI DECLSPEC_HOTPATCH GetModuleFileNameA( HMODULE module, LPSTR filename, DWORD size )
-{
-    LPWSTR filenameW = HeapAlloc( GetProcessHeap(), 0, size * sizeof(WCHAR) );
-    DWORD len;
-
-    if (!filenameW)
-    {
-        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
-        return 0;
-    }
-    if ((len = GetModuleFileNameW( module, filenameW, size )))
-    {
-    	len = file_name_WtoA( filenameW, len, filename, size );
-        if (len < size)
-            filename[len] = 0;
-        else
-            SetLastError( ERROR_INSUFFICIENT_BUFFER );
-    }
-    HeapFree( GetProcessHeap(), 0, filenameW );
-    return len;
-}
-
-
-/***********************************************************************
- *	GetModuleFileNameW   (kernelbase.@)
- */
-DWORD WINAPI DECLSPEC_HOTPATCH GetModuleFileNameW( HMODULE module, LPWSTR filename, DWORD size )
-{
-    ULONG len = 0;
-    ULONG_PTR magic;
-    LDR_MODULE *pldr;
-    WIN16_SUBSYSTEM_TIB *win16_tib;
-
-    if (!module && ((win16_tib = NtCurrentTeb()->Tib.SubSystemTib)) && win16_tib->exe_name)
-    {
-        len = min( size, win16_tib->exe_name->Length / sizeof(WCHAR) );
-        memcpy( filename, win16_tib->exe_name->Buffer, len * sizeof(WCHAR) );
-        if (len < size) filename[len] = 0;
-        goto done;
-    }
-
-    LdrLockLoaderLock( 0, NULL, &magic );
-
-    if (!module) module = NtCurrentTeb()->Peb->ImageBaseAddress;
-    if (set_ntstatus( LdrFindEntryForAddress( module, &pldr )))
-    {
-        len = min( size, pldr->FullDllName.Length / sizeof(WCHAR) );
-        memcpy( filename, pldr->FullDllName.Buffer, len * sizeof(WCHAR) );
-        if (len < size)
-        {
-            filename[len] = 0;
-            SetLastError( 0 );
-        }
-        else SetLastError( ERROR_INSUFFICIENT_BUFFER );
-    }
-
-    LdrUnlockLoaderLock( 0, magic );
-done:
-    TRACE( "%s\n", debugstr_wn(filename, len) );
-    return len;
-}
-
-
-/***********************************************************************
- *	GetModuleHandleA   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleA( LPCSTR module )
-{
-    HMODULE ret;
-
-    GetModuleHandleExA( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
-    return ret;
-}
-
-
-/***********************************************************************
- *	GetModuleHandleW   (kernelbase.@)
- */
-HMODULE WINAPI DECLSPEC_HOTPATCH GetModuleHandleW( LPCWSTR module )
-{
-    HMODULE ret;
-
-    GetModuleHandleExW( GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, module, &ret );
-    return ret;
-}
-
-
-/***********************************************************************
- *	GetModuleHandleExA   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH GetModuleHandleExA( DWORD flags, LPCSTR name, HMODULE *module )
-{
-    WCHAR *nameW;
-
-    if (!name || (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS))
-        return GetModuleHandleExW( flags, (LPCWSTR)name, module );
-
-    if (!(nameW = file_name_AtoW( name, FALSE ))) return FALSE;
-    return GetModuleHandleExW( flags, nameW, module );
-}
-
-
-/***********************************************************************
- *	GetModuleHandleExW   (kernelbase.@)
- */
-BOOL WINAPI DECLSPEC_HOTPATCH GetModuleHandleExW( DWORD flags, LPCWSTR name, HMODULE *module )
-{
-    NTSTATUS status = STATUS_SUCCESS;
-    HMODULE ret = NULL;
-    ULONG_PTR magic;
-    BOOL lock;
-
-    if (!module)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return FALSE;
-    }
-
-    /* if we are messing with the refcount, grab the loader lock */
-    lock = (flags & GET_MODULE_HANDLE_EX_FLAG_PIN) || !(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT);
-    if (lock) LdrLockLoaderLock( 0, NULL, &magic );
-
-    if (!name)
-    {
-        ret = NtCurrentTeb()->Peb->ImageBaseAddress;
-    }
-    else if (flags & GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS)
-    {
-        void *dummy;
-        if (!(ret = RtlPcToFileHeader( (void *)name, &dummy ))) status = STATUS_DLL_NOT_FOUND;
-    }
-    else
-    {
-        UNICODE_STRING wstr;
-        RtlInitUnicodeString( &wstr, name );
-        status = LdrGetDllHandle( NULL, 0, &wstr, &ret );
-    }
-
-    if (status == STATUS_SUCCESS)
-    {
-        if (flags & GET_MODULE_HANDLE_EX_FLAG_PIN)
-            LdrAddRefDll( LDR_ADDREF_DLL_PIN, ret );
-        else if (!(flags & GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT))
-            LdrAddRefDll( 0, ret );
-    }
-
-    if (lock) LdrUnlockLoaderLock( 0, magic );
-
-    *module = ret;
-    return set_ntstatus( status );
-}
-
-
 /***********************************************************************
  * Resources
  ***********************************************************************/
@@ -259,7 +89,7 @@ static NTSTATUS get_res_nameW( LPCWSTR name, UNICODE_STRING *str )
 
 
 /**********************************************************************
- *	EnumResourceLanguagesExA	(kernelbase.@)
+ *	EnumResourceLanguagesExA	(KERNEL32.@)
  */
 BOOL WINAPI DECLSPEC_HOTPATCH EnumResourceLanguagesExA( HMODULE module, LPCSTR type, LPCSTR name,
                                                         ENUMRESLANGPROCA func, LONG_PTR param,
@@ -319,7 +149,7 @@ done:
 
 
 /**********************************************************************
- *	EnumResourceLanguagesExW	(kernelbase.@)
+ *	EnumResourceLanguagesExW	(KERNEL32.@)
  */
 BOOL WINAPI DECLSPEC_HOTPATCH EnumResourceLanguagesExW( HMODULE module, LPCWSTR type, LPCWSTR name,
                                                         ENUMRESLANGPROCW func, LONG_PTR param,

 
