From a1c074a5eec1e9a005cdfaec915dd860e84c4ab4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 8 Sep 2023 14:24:11 +0200
Subject: [PATCH] winex11: Always ignore MotionNotify event after SetCursorPos.

Trying to workaround spurious Wayland mouse motion.

CW-Bug-Id: #22650
---
 dlls/winex11.drv/mouse.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 72a5d0173e4..2f208da3645 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1674,7 +1674,7 @@ BOOL X11DRV_MotionNotify( HWND hwnd, XEvent *xev )
     input.u.mi.time        = x11drv_time_to_ticks( event->time );
     input.u.mi.dwExtraInfo = 0;
 
-    if (!hwnd && is_old_motion_event( event->serial ))
+    if (is_old_motion_event( event->serial ))
     {
         TRACE( "pos %d,%d old serial %lu, ignoring\n", event->x, event->y, event->serial );
         return FALSE;

From 7940050635c1de9636194b59845e07ee7be49842 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 12 Oct 2023 21:38:46 -0600
Subject: [PATCH] ntdll: HACK: Avoid unitialized Dr7 in RtlRaiseException on
 x64.

CW-Bug-Id: #22848
---
 dlls/ntdll/signal_x86_64.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index f41a09f9ca4..3cb6e09736c 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -1553,6 +1553,8 @@ __ASM_GLOBAL_FUNC( RtlRaiseException,
                    "movq 0x4f8(%rsp),%rax\n\t"  /* return address */
                    "movq %rax,0xf8(%rdx)\n\t"   /* context->Rip */
                    "movq %rax,0x10(%rcx)\n\t"   /* rec->ExceptionAddress */
+                   "xor %rax,%rax\n\t"
+                   "movq %rax,0x70(%rdx)\n\t"   /* Context->Dr7 */
                    "movl $1,%r8d\n\t"
                    "movq %gs:(0x30),%rax\n\t"   /* Teb */
                    "movq 0x60(%rax),%rax\n\t"   /* Peb */

From 7bc7829db283134946d1c7ae0468ddc1bbf993a0 Mon Sep 17 00:00:00 2001
From: deltaconnected <deltaconnected@gmail.com>
Date: Thu, 26 Aug 2021 03:06:23 +0200
Subject: [PATCH] ntdll: Use a critical section for setting the newly created timer in RtlCreateTimer

In RtlCreateTimer, NewTimer is being set after RtlLeaveCriticalSection, which
seems to allow callbacks created with DueTime == 0 to execute and finish and
delete an invalid timer before the scheduling thread is switched back.

Fixes crashes inside DeleteTimerQueueEx and DeleteTimerQueueTimer for 
Guild Wars 2 with Arcdps (https://www.deltaconnected.com/arcdps/)

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51683
---
 dlls/ntdll/threadpool.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index ca323919d05..20096573c2b 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -936,12 +936,13 @@ NTSTATUS WINAPI RtlCreateTimer(PHANDLE NewTimer, HANDLE TimerQueue,
     if (q->quit)
         status = STATUS_INVALID_HANDLE;
     else
+    {
+        *NewTimer = t;
         queue_add_timer(t, queue_current_time() + DueTime, TRUE);
+    }
     RtlLeaveCriticalSection(&q->cs);
 
-    if (status == STATUS_SUCCESS)
-        *NewTimer = t;
-    else
+    if (status != STATUS_SUCCESS)
         RtlFreeHeap(GetProcessHeap(), 0, t);
 
     return status;
-- 
2.33.0

From 988ed7cef7c734708b61bad84911486ed3107b7e Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 1 May 2023 21:19:09 -0600
Subject: [PATCH] ntdll: HACK: Set thread teb earlier in start_main_thread().

CW-Bug-Id: #22218
---
 dlls/ntdll/unix/loader.c        | 3 +++
 dlls/ntdll/unix/signal_i386.c   | 6 ++++++
 dlls/ntdll/unix/signal_x86_64.c | 4 ++++
 dlls/ntdll/unix/unix_private.h  | 1 +
 4 files changed, 14 insertions(+)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 19d30b4f0d5..d3dea1b0dd1 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2138,6 +2138,9 @@ static void start_main_thread(void)
     virtual_map_user_shared_data();
     init_cpu_info();
     init_files();
+
+    set_thread_teb( teb );
+
     init_startup_info();
     *(ULONG_PTR *)&peb->CloudFileFlags = get_image_address();
     set_load_order_app_name( main_wargv[0] );
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index eb40bda2d94..5b7d460372c 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -2393,6 +2393,12 @@ void signal_init_threading(void)
 #endif
 }
 
+void set_thread_teb( TEB *teb )
+{
+    struct x86_thread_data *thread_data = (struct x86_thread_data *)&teb->GdiTebBatch;
+
+    ldt_set_fs( thread_data->fs, teb );
+}
 
 /**********************************************************************
  *		signal_alloc_thread
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index ea826a7e8dc..63f732b45b4 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -2814,6 +2814,10 @@ void signal_init_process(void)
     exit(1);
 }
 
+void set_thread_teb( TEB *teb )
+{
+    arch_prctl( ARCH_SET_GS, teb );
+}
 
 /***********************************************************************
  *           call_init_thunk
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index b09255e8dbd..5e4cfbd834b 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -295,6 +295,7 @@ extern BOOL get_thread_times( int unix_p
                               LARGE_INTEGER *user_time ) DECLSPEC_HIDDEN;
 extern void signal_init_threading(void) DECLSPEC_HIDDEN;
 extern NTSTATUS signal_alloc_thread( TEB *teb ) DECLSPEC_HIDDEN;
+extern void set_thread_teb( TEB *teb );
 extern void signal_free_thread( TEB *teb ) DECLSPEC_HIDDEN;
 extern void signal_init_process(void) DECLSPEC_HIDDEN;
 extern void signal_init_early(void) DECLSPEC_HIDDEN;

From 11511dfebb9ffd465a8eeb8fca6ad5e2bfbd012b Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 26 Jan 2024 23:01:11 -0600
Subject: [PATCH] kernelbase: Workaround forced stack aligment for
 SignalObjectAndWait().

CW-Bug-Id: #23256
---
 dlls/kernelbase/sync.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/kernelbase/sync.c b/dlls/kernelbase/sync.c
index 406af74c269..7406291ed78 100644
--- a/dlls/kernelbase/sync.c
+++ b/dlls/kernelbase/sync.c
@@ -284,7 +284,11 @@ DWORD WINAPI DECLSPEC_HOTPATCH SignalObjectAndWait( HANDLE signal, HANDLE wait,
                                                     DWORD timeout, BOOL alertable )
 {
     NTSTATUS status;
+#ifdef __i386__
+    DECLSPEC_ALIGN(4) LARGE_INTEGER time;
+#else
     LARGE_INTEGER time;
+#endif
 
     TRACE( "%p %p %ld %d\n", signal, wait, timeout, alertable );
 
From 38ee816b818e08a36aa94c697f26ce8c317a7c1d Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 18 Dec 2023 17:02:28 -0600
Subject: [PATCH] ntdll: Only allocate debug info with
 RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO in
 RtlInitializeCriticalSectionEx().

CW-Bug-Id: #23142
---
 dlls/kernel32/tests/sync.c | 23 ++++++++++++++++++++++-
 dlls/ntdll/sync.c          |  6 +++---
 include/winnt.h            |  1 +
 3 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index d872d75fdd1..28f07f572c3 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -205,7 +205,7 @@ static inline NTSTATUS wait_semaphore( RTL_CRITICAL_SECTION *crit, int timeout )
  */
 NTSTATUS WINAPI RtlInitializeCriticalSection( RTL_CRITICAL_SECTION *crit )
 {
-    return RtlInitializeCriticalSectionEx( crit, 0, 0 );
+    return RtlInitializeCriticalSectionEx( crit, 0, RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO );
 }
 
 
@@ -214,7 +214,7 @@ NTSTATUS WINAPI RtlInitializeCriticalSection( RTL_CRITICAL_SECTION *crit )
  */
 NTSTATUS WINAPI RtlInitializeCriticalSectionAndSpinCount( RTL_CRITICAL_SECTION *crit, ULONG spincount )
 {
-    return RtlInitializeCriticalSectionEx( crit, spincount, 0 );
+    return RtlInitializeCriticalSectionEx( crit, spincount, RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO );
 }
 
 
@@ -232,7 +232,7 @@ NTSTATUS WINAPI RtlInitializeCriticalSectionEx( RTL_CRITICAL_SECTION *crit, ULON
      * is done, then debug info should be managed through Rtlp[Allocate|Free]DebugInfo
      * so (e.g.) MakeCriticalSectionGlobal() doesn't free it using HeapFree().
      */
-    if (flags & RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO)
+    if (!(flags & RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO))
         crit->DebugInfo = no_debug_info_marker;
     else
     {
diff --git a/include/winnt.h b/include/winnt.h
index 20db9a8aabd..0e1a197d423 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -6056,6 +6056,7 @@ typedef struct _RTL_CRITICAL_SECTION {
 #define RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO 0x1000000
 #define RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN  0x2000000
 #define RTL_CRITICAL_SECTION_FLAG_STATIC_INIT   0x4000000
+#define RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO 0x10000000
 #define RTL_CRITICAL_SECTION_ALL_FLAG_BITS      0xFF000000
 #define RTL_CRITICAL_SECTION_FLAG_RESERVED      (RTL_CRITICAL_SECTION_ALL_FLAG_BITS & ~0x7000000)
 
From 14f7b22769d6cc6f2ded0dad7fde3755459bc407 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 18 Dec 2023 17:49:20 -0600
Subject: [PATCH] ntdll: Set DebugInfo to NULL for absent DebugInfo in
 RtlDeleteCriticalSection().

CW-Bug-Id: #23142
---
 dlls/kernel32/tests/sync.c | 6 +++---
 dlls/ntdll/sync.c          | 6 +++++-
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 28f07f572c3..54a8a122dc0 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -288,7 +288,11 @@ NTSTATUS WINAPI RtlDeleteCriticalSection( RTL_CRITICAL_SECTION *crit )
             crit->DebugInfo = NULL;
         }
     }
-    else NtClose( crit->LockSemaphore );
+    else
+    {
+        NtClose( crit->LockSemaphore );
+        crit->DebugInfo = NULL;
+    }
     crit->LockSemaphore = 0;
     return STATUS_SUCCESS;
 }

From 26e3d2ecedb4f48d0002b7e75dd4d80eb00b54a9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 6 Feb 2024 18:01:59 +0200
Subject: [PATCH] win32u: Use consistent locking order for display related
 mutexes.

Most paths that hold both the display_lock and the display_devices_init
mutex acquire them in the order just mentioned. However, there are two
cases where these are acquired in the opposite order, which with
unfortunate thread interactions and timings can lead to a deadlock. Fix
these cases to use the same order as the rest of the code.
---
 dlls/win32u/sysparams.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 9a43de8fd76..673082056b1 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -1251,8 +1251,8 @@ static void add_gpu( const struct gdi_gpu *gpu, void *param )
 
     if (!ctx->mutex)
     {
-        ctx->mutex = get_display_device_init_mutex();
         pthread_mutex_lock( &display_lock );
+        ctx->mutex = get_display_device_init_mutex();
         prepare_devices();
     }
 
@@ -1717,8 +1717,8 @@ static BOOL update_display_cache_from_registry(void)
 
     if (key.LastWriteTime.QuadPart <= last_query_display_time) return TRUE;
 
-    mutex = get_display_device_init_mutex();
     pthread_mutex_lock( &display_lock );
+    mutex = get_display_device_init_mutex();
 
     clear_display_devices();
 
-- 
GitLab

From 7562292ceae1b36b5e7ac2402ac0fba7486acd7a Mon Sep 17 00:00:00 2001
From: Eric Pouech <epouech@codeweavers.com>
Date: Tue, 7 Nov 2023 19:12:39 +0100
Subject: [PATCH] user32: Use SecureZeroMemory to clear magic fields.

Signed-off-by: Eric Pouech <epouech@codeweavers.com>
---
 dlls/user32/dde_misc.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/user32/dde_misc.c b/dlls/user32/dde_misc.c
index 39b439976cd..b5ccf449692 100644
--- a/dlls/user32/dde_misc.c
+++ b/dlls/user32/dde_misc.c
@@ -2113,7 +2113,8 @@ void WDML_RemoveConv(WDML_CONV* pRef, WDML_SIDE side)
 	    {
 		pPrev->next = pCurrent->next;
 	    }
-	    pCurrent->magic = 0;
+            /* Ensure compiler doesn't optimize out the assignment with 0. */
+	    SecureZeroMemory(&pCurrent->magic, sizeof(pCurrent->magic));
 	    HeapFree(GetProcessHeap(), 0, pCurrent);
 	    break;
 	}
-- 
GitLab

From 6a862c997584816064be6f0e0ec9308dece6d376 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Thu, 21 Apr 2022 00:09:40 +0900
Subject: [PATCH 1/6] user32/tests: Make test_unicode_wm_char robust against
 superfluous messages.

Commit e445303ab45 (user32/tests: Make a few more messages optional.,
2014-03-20) modified test_unicode_wm_char so that it skips non-essential
messages (e.g. WM_DWMNCRENDERINGCHANGED) from GetMessageW.

Extend this for messages from GetMessageA as well.

Also, handle the case where no messages other than WM_QUIT are received
at all.

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/user32/tests/msg.c | 20 +++++++++++++-------
 1 file changed, 13 insertions(+), 7 deletions(-)

From c6df0448fee728c997f1756ec9eff65f5b774992 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Sun, 17 Apr 2022 00:49:56 +0900
Subject: [PATCH 2/6] include: Add definition for
 UOI_TIMERPROC_EXCEPTION_SUPPRESSION

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 include/winuser.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/include/winuser.h b/include/winuser.h
index 453f561e62f..666deeb6cbe 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -99,6 +99,7 @@ typedef void* HPOWERNOTIFY;
 #define UOI_NAME        2
 #define UOI_TYPE        3
 #define UOI_USER_SID    4
+#define UOI_TIMERPROC_EXCEPTION_SUPPRESSION 7
 
 #define WSF_VISIBLE     1
 #define DF_ALLOWOTHERACCOUNTHOOK  1
-- 
GitLab

From 5ba99e842f71b3b8d2632c55ae202ccde1751f42 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Mon, 18 Apr 2022 19:27:38 +0900
Subject: [PATCH 4/6] user32: Implement UOI_TIMERPROC_EXCEPTION_SUPPRESSION.

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/user32/message.c      | 11 ++++++++++-
 dlls/user32/tests/msg.c    |  6 ------
 dlls/user32/user32.spec    |  2 +-
 dlls/user32/user_main.c    |  1 +
 dlls/user32/user_private.h |  1 +
 dlls/user32/winstation.c   | 23 ++++++++++++++++++++++-
 6 files changed, 35 insertions(+), 9 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 4016c95539a..54ee5317eed 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -861,6 +861,15 @@ static LRESULT dispatch_message( const MSG *msg, BOOL ansi )
 }
 
 
+static LONG WINAPI timerproc_exception_filter(EXCEPTION_POINTERS *eptr)
+{
+    if (suppress_timerproc_exception)
+        return EXCEPTION_EXECUTE_HANDLER;
+
+    return EXCEPTION_CONTINUE_SEARCH;
+}
+
+
 /***********************************************************************
  *		DispatchMessageA (USER32.@)
  *
@@ -878,7 +887,7 @@ LRESULT WINAPI DECLSPEC_HOTPATCH DispatchMessageA( const MSG* msg )
             retval = CallWindowProcA( (WNDPROC)msg->lParam, msg->hwnd,
                                       msg->message, msg->wParam, GetTickCount() );
         }
-        __EXCEPT_ALL
+        __EXCEPT(timerproc_exception_filter)
         {
             retval = 0;
         }

diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index 96e6e1a7d6b..6a605ae4216 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -721,7 +721,7 @@
 @ stdcall SetThreadDpiAwarenessContext(ptr)
 @ stdcall SetTimer(long long long ptr)
 @ stdcall SetUserObjectInformationA(long long ptr long)
-@ stdcall SetUserObjectInformationW(long long ptr long) NtUserSetObjectInformation
+@ stdcall SetUserObjectInformationW(long long ptr long)
 @ stdcall SetUserObjectSecurity(long ptr ptr)
 @ stdcall SetWinEventHook(long long long ptr long long long)
 @ stdcall SetWindowCompositionAttribute(ptr ptr)
diff --git a/dlls/user32/user_main.c b/dlls/user32/user_main.c
index ef2b94ba698..f375462487b 100644
--- a/dlls/user32/user_main.c
+++ b/dlls/user32/user_main.c
@@ -29,6 +29,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(graphics);
 WINE_DECLARE_DEBUG_CHANNEL(message);
 
 HMODULE user32_module = 0;
+BOOL suppress_timerproc_exception = TRUE;
 
 extern void WDML_NotifyThreadDetach(void);
 
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index a9bbdd16fb0..91612f9c6c5 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -44,6 +44,7 @@ struct wm_char_mapping_data
 };
 
 extern HMODULE user32_module;
+extern BOOL suppress_timerproc_exception;
 
 extern BOOL post_dde_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, DWORD dest_tid,
                               DWORD type );
diff --git a/dlls/user32/winstation.c b/dlls/user32/winstation.c
index 62593ca046f..789e45f8928 100644
--- a/dlls/user32/winstation.c
+++ b/dlls/user32/winstation.c
@@ -389,12 +389,33 @@ BOOL WINAPI GetUserObjectInformationA( HANDLE handle, INT index, LPVOID info, DW
 }
 
 
+/******************************************************************************
+ *              SetUserObjectInformationW   (USER32.@)
+ */
+BOOL WINAPI SetUserObjectInformationW( HANDLE handle, INT index, LPVOID info, DWORD len )
+{
+    if (index == UOI_TIMERPROC_EXCEPTION_SUPPRESSION)
+    {
+        if (handle != GetCurrentProcess() || len != sizeof(BOOL))
+        {
+            SetLastError(ERROR_INVALID_PARAMETER);
+            return FALSE;
+        }
+
+        suppress_timerproc_exception = *(const BOOL *)info;
+        return TRUE;
+    }
+
+    return NtUserSetObjectInformation( handle, index, info, len );
+}
+
+
 /******************************************************************************
  *              SetUserObjectInformationA   (USER32.@)
  */
 BOOL WINAPI SetUserObjectInformationA( HANDLE handle, INT index, LPVOID info, DWORD len )
 {
-    return NtUserSetObjectInformation( handle, index, info, len );
+    return SetUserObjectInformationW( handle, index, info, len );
 }
 
 
-- 
GitLab

From 66fb617b6945bac43a1ac8a5073aae06d602b4e1 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Mon, 18 Apr 2022 19:39:07 +0900
Subject: [PATCH 6/6] win32u: Ignore unhandled info index in
 NtUserSetObjectInformation.

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/win32u/tests/win32u.c | 4 ----
 dlls/win32u/winstation.c   | 2 ++
 2 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index b187b246941..0a84cf03552 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -395,6 +395,8 @@ BOOL WINAPI NtUserSetObjectInformation( HANDLE handle, INT index, void *info, DW
     BOOL ret;
     const USEROBJECTFLAGS *obj_flags = info;
 
+    if (index == UOI_TIMERPROC_EXCEPTION_SUPPRESSION) return TRUE;
+
     if (index != UOI_FLAGS || !info || len < sizeof(*obj_flags))
     {
         RtlSetLastWin32Error( ERROR_INVALID_PARAMETER );
-- 
GitLab

From 61176033a2bb3c6a5a229078f684b85ee085ef80 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 6 Feb 2024 19:05:00 -0600
Subject: [PATCH] ntdll: Better track thread pool wait's wait_pending state.

CW-Bug-Id: #21509
---
 dlls/ntdll/threadpool.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 4f22114a55e..9a8f380bf72 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -1265,6 +1265,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                                   u.wait.wait_entry )
         {
             assert( wait->type == TP_OBJECT_TYPE_WAIT );
+            assert( wait->u.wait.wait_pending );
             if (wait->u.wait.timeout <= now.QuadPart)
             {
                 /* Wait object timed out. */
@@ -1272,6 +1273,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                 {
                     list_remove( &wait->u.wait.wait_entry );
                     list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+                    wait->u.wait.wait_pending = FALSE;
                 }
                 if ((wait->u.wait.flags & (WT_EXECUTEINWAITTHREAD | WT_EXECUTEINIOTHREAD)))
                 {
@@ -1329,6 +1331,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                     {
                         list_remove( &wait->u.wait.wait_entry );
                         list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+                        wait->u.wait.wait_pending = FALSE;
                     }
                     if ((wait->u.wait.flags & (WT_EXECUTEINWAITTHREAD | WT_EXECUTEINIOTHREAD)))
                     {

From 25d2d4c847b03b409564079a5cef1ab6ff71e457 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 6 Feb 2024 19:14:40 -0600
Subject: [PATCH] ntdll: Make sure wakeups from already unset events are
 ignored in waitqueue_thread_proc().

CW-Bug-Id: #21509
---
 dlls/ntdll/threadpool.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 9a8f380bf72..2887e84b12c 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -160,6 +160,7 @@ struct threadpool_object
     LONG                    num_pending_callbacks;
     LONG                    num_running_callbacks;
     LONG                    num_associated_callbacks;
+    LONG                    update_serial;
     /* arguments for callback */
     union
     {
@@ -1243,6 +1244,7 @@ static void tp_timerqueue_unlock( struct threadpool_object *timer )
 static void CALLBACK waitqueue_thread_proc( void *param )
 {
     struct threadpool_object *objects[MAXIMUM_WAITQUEUE_OBJECTS];
+    LONG update_serials[MAXIMUM_WAITQUEUE_OBJECTS];
     HANDLE handles[MAXIMUM_WAITQUEUE_OBJECTS + 1];
     struct waitqueue_bucket *bucket = param;
     struct threadpool_object *wait, *next;
@@ -1295,6 +1297,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                 InterlockedIncrement( &wait->refcount );
                 objects[num_handles] = wait;
                 handles[num_handles] = wait->u.wait.handle;
+                update_serials[num_handles] = wait->update_serial;
                 num_handles++;
             }
         }
@@ -1323,7 +1326,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
             {
                 wait = objects[status - STATUS_WAIT_0];
                 assert( wait->type == TP_OBJECT_TYPE_WAIT );
-                if (wait->u.wait.bucket)
+                if (wait->u.wait.bucket && wait->update_serial == update_serials[status - STATUS_WAIT_0])
                 {
                     /* Wait object signaled. */
                     assert( wait->u.wait.bucket == bucket );
@@ -1344,7 +1347,10 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                     else tp_object_submit( wait, TRUE );
                 }
                 else
-                    WARN("wait object %p triggered while object was destroyed\n", wait);
+                {
+                    WARN("wait object %p triggered while object was %s.\n",
+                            wait, wait->u.wait.bucket ? "updated" : "destroyed");
+                }
             }
 
             /* Release temporary references to wait objects. */
@@ -1917,6 +1923,7 @@ static void tp_object_initialize( struct threadpool_object *object, struct threa
     object->num_pending_callbacks   = 0;
     object->num_running_callbacks   = 0;
     object->num_associated_callbacks = 0;
+    object->update_serial           = 0;
 
     if (environment)
     {
@@ -3050,12 +3061,15 @@ VOID WINAPI TpSetWait( TP_WAIT *wait, HA
 {
     struct threadpool_object *this = impl_from_TP_WAIT( wait );
     ULONGLONG timestamp = MAXLONGLONG;
+    BOOL same_handle;
 
     TRACE( "%p %p %p\n", wait, handle, timeout );
 
     enter_critical_section( &waitqueue.cs );
 
     assert( this->u.wait.bucket );
+
+    same_handle = this->u.wait.handle == handle;
     this->u.wait.handle = handle;
 
     if (handle || this->u.wait.wait_pending)
@@ -3090,6 +3100,8 @@ VOID WINAPI TpSetWait( TP_WAIT *wait, HANDLE handle, LARGE_INTEGER *timeout )
         }
 
         /* Wake up the wait queue thread. */
+        if (!same_handle)
+            ++this->update_serial;
         NtSetEvent( bucket->update_event, NULL );
     }
 
From a4cf21c6f78639f60aa3af69de4cac9d0468f13f Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Sat, 17 Feb 2024 22:11:43 +0900
Subject: [PATCH] ntdll: Don't leak objattr allocation in NtCreateSemaphore.

https://github.com/ValveSoftware/wine/pull/219
---
 dlls/ntdll/unix/sync.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index ed30388b026..dd08632e21c 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -272,7 +272,6 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
 
     *handle = 0;
     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     if (do_fsync())
         return fsync_create_semaphore( handle, access, attr, initial, max );
@@ -280,6 +279,8 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
     if (do_esync())
         return esync_create_semaphore( handle, access, attr, initial, max );
 
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
     SERVER_START_REQ( create_semaphore )
     {
         req->access  = access;

From f392d0687cb74f47dbfceb4a57b496191f183969 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 29 Feb 2024 20:02:48 -0600
Subject: [PATCH] fixup! ntdll: Read process memory on the client side in
 NtReadVirtualMemory().

CW-Bug-Id: #23456
---
 dlls/ntdll/unix/virtual.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index ba2fe258ede..97b55022c7a 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -6305,13 +6305,21 @@ NTSTATUS WINAPI NtReadVirtualMemory( HANDLE process, const void *addr, void *buf
     int unix_pid;
     ssize_t ret;
 
-    SERVER_START_REQ( read_process_memory )
+    if (process == NtCurrentProcess())
     {
-        req->handle = wine_server_obj_handle( process );
-        status = wine_server_call( req );
-        unix_pid = reply->unix_pid;
+        unix_pid = getpid();
+        status = STATUS_SUCCESS;
+    }
+    else
+    {
+        SERVER_START_REQ( read_process_memory )
+        {
+            req->handle = wine_server_obj_handle( process );
+            status = wine_server_call( req );
+            unix_pid = reply->unix_pid;
+        }
+        SERVER_END_REQ;
     }
-    SERVER_END_REQ;
 
     if (status)
     {


From 146c2631276b3e826085a6d270d71c5f56b75d87 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 5 Apr 2024 12:11:51 -0600
Subject: [PATCH] ntdll: Return STATUS_NO_YIELD_PERFORMED from
 NtYieldExecution() on Linux if no yield was performed.

---
 dlls/ntdll/unix/sync.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index ae7bc115ffe..e070233104b 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -43,6 +43,9 @@
 #ifdef HAVE_SCHED_H
 # include <sched.h>
 #endif
+#ifdef HAVE_SYS_RESOURCE_H
+# include <sys/resource.h>
+#endif
 #include <string.h>
 #include <stdarg.h>
 #include <stdio.h>
@@ -1514,7 +1517,17 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
 NTSTATUS WINAPI NtYieldExecution(void)
 {
 #ifdef HAVE_SCHED_YIELD
+#ifdef RUSAGE_THREAD
+    struct rusage u1, u2;
+    int ret;
+
+    ret = getrusage( RUSAGE_THREAD, &u1 );
+#endif
     sched_yield();
+#ifdef RUSAGE_THREAD
+    if (!ret) ret = getrusage( RUSAGE_THREAD, &u2 );
+    if (!ret && u1.ru_nvcsw == u2.ru_nvcsw && u1.ru_nivcsw == u2.ru_nivcsw) return STATUS_NO_YIELD_PERFORMED;
+#endif
     return STATUS_SUCCESS;
 #else
     return STATUS_NO_YIELD_PERFORMED;
-- 
GitLab
From c55cce6fcbadca3d5b5fd4e2a434ada2c2012479 Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Thu, 16 Nov 2023 19:54:07 +0100
Subject: [PATCH] server: Initialize pe image struct padding to avoid Valgrind
 warning.

---
 include/wine/server_protocol.h | 3 ++-
 server/mapping.c               | 1 +
 server/protocol.def            | 1 +
 3 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 15156a12353..139a7bca69e 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -844,6 +844,7 @@ typedef struct
     unsigned char  contains_code : 1;
     unsigned char  wine_builtin : 1;
     unsigned char  wine_fakedll : 1;
+    unsigned char  padding : 5;
     unsigned char  image_flags;
     unsigned int   loader_flags;
     unsigned int   header_size;
@@ -6506,7 +6507,7 @@ union generic_reply
 
 /* ### protocol_version begin ### */
 
-#define SERVER_PROTOCOL_VERSION 785
+#define SERVER_PROTOCOL_VERSION 786
 
 /* ### protocol_version end ### */
 
diff --git a/server/mapping.c b/server/mapping.c
index a795dc4b38b..b5684c484d2 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -842,6 +842,7 @@ static unsigned int get_image_params( struct mapping *mapping, file_pos_t file_s
         return STATUS_INVALID_IMAGE_FORMAT;
     }
 
+    mapping->image.padding       = 0;
     mapping->image.map_addr      = get_fd_map_address( mapping->fd );
     mapping->image.image_charact = nt.FileHeader.Characteristics;
     mapping->image.machine       = nt.FileHeader.Machine;
diff --git a/server/protocol.def b/server/protocol.def
index b4d6d74d6fc..5d60e7fcda3 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -860,6 +860,7 @@ typedef struct
     unsigned char  contains_code : 1;
     unsigned char  wine_builtin : 1;
     unsigned char  wine_fakedll : 1;
+    unsigned char  padding : 5;
     unsigned char  image_flags;
     unsigned int   loader_flags;
     unsigned int   header_size;
-- 
GitLab

From 9dc80b13bec0b482150dbd8c9236dbb8b6a31ccd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 21 Dec 2023 11:44:39 +0100
Subject: [PATCH 1/2] server: Introduce a new get_desktop_cursor_thread_input
 helper.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=55961
---
 server/queue.c | 30 +++++++++++++++++++-----------
 1 file changed, 19 insertions(+), 11 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index ee8bdf34b7f..d2cf9800258 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -429,26 +429,34 @@ static void queue_cursor_message( struct desktop *desktop, user_handle_t win, un
     queue_hardware_message( desktop, msg, 1 );
 }
 
+static struct thread_input *get_desktop_cursor_thread_input( struct desktop *desktop )
+{
+    struct thread_input *input = NULL;
+    struct thread *thread;
+
+    if ((thread = get_window_thread( desktop->cursor.win )))
+    {
+        if (thread->queue) input = thread->queue->input;
+        release_object( thread );
+    }
+
+    return input;
+}
+
 static int update_desktop_cursor_window( struct desktop *desktop, user_handle_t win )
 {
     int updated = win != desktop->cursor.win;
-    user_handle_t handle = desktop->cursor.handle;
+    struct thread_input *input;
     desktop->cursor.win = win;
-    if (updated)
-    {
-        struct thread *thread;
-
-        if ((thread = get_window_thread( win )))
-        {
-            struct thread_input *input = thread->queue->input;
-            if (input) handle = input->cursor_count < 0 ? 0 : input->cursor;
-            release_object( thread );
-        }
 
+    if (updated && (input = get_desktop_cursor_thread_input( desktop )))
+    {
+        user_handle_t handle = input->cursor_count < 0 ? 0 : input->cursor;
         /* when clipping send the message to the foreground window as well, as some driver have an artificial overlay window */
         if (is_cursor_clipped( desktop )) queue_cursor_message( desktop, 0, WM_WINE_SETCURSOR, win, handle );
         queue_cursor_message( desktop, win, WM_WINE_SETCURSOR, win, handle );
     }
+
     return updated;
 }
 
-- 
GitLab

From d1789fbb40d74b747451c9c5d9e738c463a6aa67 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 21 Dec 2023 11:47:00 +0100
Subject: [PATCH 2/2] server: Change desktop cursor only when inside the
 thread's windows.

Getting rid of the desktop cursor handle at the same time.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=55961
---
 server/queue.c | 13 ++++---------
 server/user.h  |  1 -
 2 files changed, 4 insertions(+), 10 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index d2cf9800258..cd913ae03e5 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -478,13 +478,11 @@ static int update_desktop_cursor_pos( struct desktop *desktop, user_handle_t win
     return updated;
 }
 
-static void update_desktop_cursor_handle( struct desktop *desktop, user_handle_t handle )
+static void update_desktop_cursor_handle( struct desktop *desktop, struct thread_input *input )
 {
-    int updated = desktop->cursor.handle != handle;
-    user_handle_t win = desktop->cursor.win;
-    desktop->cursor.handle = handle;
-    if (updated)
+    if (input == get_desktop_cursor_thread_input( desktop ))
     {
+        user_handle_t handle = input->cursor_count < 0 ? 0 : input->cursor, win = desktop->cursor.win;
         /* when clipping send the message to the foreground window as well, as some driver have an artificial overlay window */
         if (is_cursor_clipped( desktop )) queue_cursor_message( desktop, 0, WM_WINE_SETCURSOR, win, handle );
         queue_cursor_message( desktop, win, WM_WINE_SETCURSOR, win, handle );
@@ -3414,10 +3412,7 @@ DECL_HANDLER(set_cursor)
     if (req->flags & SET_CURSOR_NOCLIP) set_clip_rectangle( desktop, NULL, SET_CURSOR_NOCLIP, 0 );
 
     if (req->flags & (SET_CURSOR_HANDLE | SET_CURSOR_COUNT))
-    {
-        if (input->cursor_count < 0) update_desktop_cursor_handle( desktop, 0 );
-        else update_desktop_cursor_handle( desktop, input->cursor );
-    }
+        update_desktop_cursor_handle( desktop, input );
 
     reply->new_x       = desktop->cursor.x;
     reply->new_y       = desktop->cursor.y;
diff --git a/server/user.h b/server/user.h
index b6f47bcac1c..8fa55e09b0f 100644
--- a/server/user.h
+++ b/server/user.h
@@ -59,7 +59,6 @@ struct global_cursor
     rectangle_t          clip;             /* cursor clip rectangle */
     unsigned int         last_change;      /* time of last position change */
     user_handle_t        win;              /* window that contains the cursor */
-    user_handle_t        handle;           /* last set cursor handle */
 };
 
 struct desktop
-- 
GitLab

From 6c44228c1f673f4147153db53247b2dc700ae24e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Jan 2024 23:25:33 +0100
Subject: [PATCH] winex11: Sync with gdi_display before closing the threads
 display.

---
 dlls/winex11.drv/x11drv_main.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 1b9555bcfbf..25a36cb8c0c 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -721,6 +721,7 @@ void X11DRV_ThreadDetach(void)
         vulkan_thread_detach();
         if (data->xim) XCloseIM( data->xim );
         if (data->font_set) XFreeFontSet( data->display, data->font_set );
+        XSync( gdi_display, False ); /* make sure XReparentWindow requests have completed before closing the thread display */
         XCloseDisplay( data->display );
         free( data );
         /* clear data in case we get re-entered from user32 before the thread is truly dead */
-- 
GitLab

From e390b67fa52b0808b71bb4c7feb08ca12a3a7444 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Mon, 21 Sep 2020 17:27:00 +0300
Subject: [PATCH] server: Try to retrieve the unix name on handles created from
 file descriptors.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46070
Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 server/fd.c   | 39 +++++++++++++++++++++++++++++++++++++++
 server/file.c |  1 +
 server/file.h |  2 ++
 3 files changed, 42 insertions(+)

diff --git a/server/fd.c b/server/fd.c
index 11111111111..11111111111 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -2312,6 +2312,45 @@ struct fd *create_anonymous_fd( const struct fd_ops *fd_user_ops, int unix_fd, s
     return NULL;
 }
 
+void set_unix_name_of_fd( struct fd *fd, const struct stat *fd_st )
+{
+#ifdef __linux__
+    static const char procfs_fmt[] = "/proc/self/fd/%d";
+
+    char path[PATH_MAX], procfs_path[sizeof(procfs_fmt) - 2 /* %d */ + 11];
+    struct stat path_st;
+    ssize_t len;
+
+    sprintf( procfs_path, procfs_fmt, fd->unix_fd );
+    len = readlink( procfs_path, path, sizeof(path) );
+    if (len == -1 || len >= sizeof(path) )
+        return;
+    path[len] = '\0';
+
+    /* Make sure it's an absolute path, has at least one hardlink, and the same inode */
+    if (path[0] != '/' || stat( path, &path_st ) || path_st.st_nlink < 1 ||
+        path_st.st_dev != fd_st->st_dev || path_st.st_ino != fd_st->st_ino)
+        return;
+
+    if (!(fd->unix_name = mem_alloc( len + 1 )))
+        return;
+    memcpy( fd->unix_name, path, len + 1 );
+
+#elif defined(F_GETPATH)
+    char path[PATH_MAX];
+    size_t size;
+
+    if (fcntl( fd->unix_fd, F_GETPATH, path ) == -1 || path[0] != '/')
+        return;
+
+    size = strlen(path) + 1;
+    if (!(fd->unix_name = mem_alloc( size )))
+        return;
+    memcpy( fd->unix_name, path, size );
+
+#endif
+}
+
 /* retrieve the object that is using an fd */
 void *get_fd_user( struct fd *fd )
 {
diff --git a/server/file.c b/server/file.c
index 11111111111..11111111111 100644
--- a/server/file.c
+++ b/server/file.c
@@ -187,6 +187,7 @@ struct file *create_file_for_fd( int fd, unsigned int access, unsigned int shari
         release_object( file );
         return NULL;
     }
+    set_unix_name_of_fd( file->fd, &st );
     allow_fd_caching( file->fd );
     return file;
 }
diff --git a/server/file.h b/server/file.h
index 11111111111..11111111111 100644
--- a/server/file.h
+++ b/server/file.h
@@ -22,6 +22,7 @@
 #define __WINE_SERVER_FILE_H
 
 #include <sys/types.h>
+#include <sys/stat.h>
 
 #include "object.h"
 
@@ -85,6 +86,7 @@ extern struct fd *open_fd( struct fd *root, const char *name, struct unicode_str
                            unsigned int sharing, unsigned int options );
 extern struct fd *create_anonymous_fd( const struct fd_ops *fd_user_ops,
                                        int unix_fd, struct object *user, unsigned int options );
+extern void set_unix_name_of_fd( struct fd *fd, const struct stat *fd_st );
 extern struct fd *dup_fd_object( struct fd *orig, unsigned int access, unsigned int sharing,
                                  unsigned int options );
 extern struct fd *get_fd_object_for_mapping( struct fd *fd, unsigned int access, unsigned int sharing );
-- 
0.0.0

From 36e637ec9c2e14836e316e30546c5f6936a7e249 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 31 Jul 2020 09:09:47 +0200
Subject: [PATCH] ntdll: Use RTLD_NOLOAD to find already mapped modules.

This makes it possible to detect modules that weren't unmapped from
dlclose, and that we should not fixup again.
---
 dlls/ntdll/unix/loader.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -1142,8 +1142,10 @@ static NTSTATUS dlopen_dll( const char *so_name, UNICODE_STRING *nt_name, void *
 {
     void *module, *handle;
     const IMAGE_NT_HEADERS *nt;
+    BOOL mapped = FALSE;
 
-    handle = dlopen( so_name, RTLD_NOW );
+    if ((handle = dlopen( so_name, RTLD_NOW | RTLD_NOLOAD ))) mapped = TRUE;
+    else handle = dlopen( so_name, RTLD_NOW );
     if (!handle)
     {
         WARN( "failed to load .so lib %s: %s\n", debugstr_a(so_name), dlerror() );
@@ -1165,7 +1167,7 @@ static NTSTATUS dlopen_dll( const char *so_name, UNICODE_STRING *nt_name, void *
         return STATUS_SUCCESS;
     }
 
-    if (map_so_dll( nt, module ))
+    if (!mapped && map_so_dll( nt, module ))
     {
         dlclose( handle );
         return STATUS_NO_MEMORY;

From: Paul Gofman <pgofman@codeweavers.com>
Subject: [PATCH v3 1/3] server: Update system regs from set_thread_context handler only.
Message-Id: <20210527101600.348718-1-pgofman@codeweavers.com>
Date: Thu, 27 May 2021 13:15:58 +0300

Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
---
    Supersedes 206374-206376.
v3:
    - replaced patch.

 server/thread.c | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/server/thread.c b/server/thread.c
index 11111111111..11111111111 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -2165,9 +2165,6 @@ DECL_HANDLER(select)
         {
             apc_call_t *data;
             data_size_t size = sizeof(*data) + (ctx->regs[CTX_WOW].flags ? 2 : 1) * sizeof(context_t);
-            unsigned int flags = system_flags & ctx->regs[CTX_NATIVE].flags;
-
-            if (flags) set_thread_context( current, &ctx->regs[CTX_NATIVE], flags );
             size = min( size, get_reply_max_size() );
             if ((data = set_reply_data_size( size )))
             {
@@ -2413,7 +2410,7 @@ DECL_HANDLER(set_thread_context)
         unsigned int flags = system_flags & contexts[CTX_NATIVE].flags;
 
         if (thread != current) stop_thread( thread );
-        else if (flags) set_thread_context( thread, &contexts[CTX_NATIVE], flags );
+        if (flags) set_thread_context( thread, &contexts[CTX_NATIVE], flags );
 
         if (thread->context && !get_error())
         {

-- 
0.0.0

From a2f384b71cafb619124a10471f4b2c84fe1da278 Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Tue, 16 Apr 2024 23:19:05 +0500
Subject: [PATCH 1/6] Fix initialization of the handler_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
handler_fd_ops in server/signal.c -- is being initialized.

It looks like field list in initialization of the handler_fd_ops in
server/signal.c was out-of-sync for a long time.  Take a look, for
example, on patches ad1e0609a0f (server: Get rid of no loner used
cancel_async from fd_ops., 2016-12-01) (which removed "reference" to the
cancel_async field correctly, but did not add "references" to the read
and write fields, for example), or 837b39b2028 (server: Add read and
write fd member functions., 2015-05-05) (which updated `struct fd_ops'
but did not change initialization of the handler_fd_ops at all).

Because the main purpose of initialization of the handler_fd_ops made in
server/signal.c is to assign address of the handler_poll_event()
function to the poll_event field, while making all other fields NULLed,
lacking some fields in that initialization is not an error according to
C standard:

> 6.7.11 Initialization
>
> 11 ... If an object that has static or thread storage duration is not
> initialized explicitly, or any object is initialized with an empty
> initializer, then it is subject to default initialization, which
> initializes an object as follows:
>
>   - if it has pointer type, it is initialized to a null pointer;
> ...
> 22 If there are fewer initializers in a brace-enclosed list than there
> are elements or members of an aggregate, or fewer characters in a
> string literal used to initialize an array of known size than there
> are elements in the array, the remainder of the aggregate is subject
> to default initialization.

But to maintain code consistency I believe initialization of the
handler_fd_ops object should enumerate all fields of the
`struct fd_ops' type.

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/signal.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/server/signal.c b/server/signal.c
index 19b76d44c16..45a516f4599 100644
--- a/server/signal.c
+++ b/server/signal.c
@@ -84,9 +84,14 @@ static const struct fd_ops handler_fd_ops =
 {
     NULL,                     /* get_poll_events */
     handler_poll_event,       /* poll_event */
-    NULL,                     /* flush */
     NULL,                     /* get_fd_type */
+    NULL,                     /* read */
+    NULL,                     /* write */
+    NULL,                     /* flush */
+    NULL,                     /* get_file_info */
+    NULL,                     /* get_volume_info */
     NULL,                     /* ioctl */
+    NULL,                     /* cancel_async */
     NULL,                     /* queue_async */
     NULL                      /* reselect_async */
 };
-- 
GitLab


From ea2e56de5f5afb7983fd209f466e92424a403a59 Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Wed, 17 Apr 2024 11:44:35 +0500
Subject: [PATCH 2/6] Fix initialization of the master_socket_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
master_socket_fd_ops in server/request.c -- is being initialized.

For motivation behind this patch please read message of the previous
commit 0bd610a1680 (Fix initialization of the handler_fd_ops,
2024-04-16).

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/request.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/server/request.c b/server/request.c
index 2691e0c7cff..bb9b978df46 100644
--- a/server/request.c
+++ b/server/request.c
@@ -110,9 +110,14 @@ static const struct fd_ops master_socket_fd_ops =
 {
     NULL,                          /* get_poll_events */
     master_socket_poll_event,      /* poll_event */
-    NULL,                          /* flush */
     NULL,                          /* get_fd_type */
+    NULL,                          /* read */
+    NULL,                          /* write */
+    NULL,                          /* flush */
+    NULL,                          /* get_file_info */
+    NULL,                          /* get_volume_info */
     NULL,                          /* ioctl */
+    NULL,                          /* cancel_async */
     NULL,                          /* queue_async */
     NULL                           /* reselect_async */
 };
-- 
GitLab


From 436b01b543ea88f22da4973f43b3f00311f87409 Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Wed, 17 Apr 2024 15:01:28 +0500
Subject: [PATCH 3/6] Fix initialization of the inotify_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
inotify_fd_ops in server/change.c -- is being initialized.

For motivation behind this patch please read message of commit
0bd610a1680 (Fix initialization of the handler_fd_ops, 2024-04-16).

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/change.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/server/change.c b/server/change.c
index f773ccf8831..36c648f18b7 100644
--- a/server/change.c
+++ b/server/change.c
@@ -644,9 +644,14 @@ static const struct fd_ops inotify_fd_ops =
 {
     inotify_get_poll_events,     /* get_poll_events */
     inotify_poll_event,          /* poll_event */
-    NULL,                        /* flush */
     NULL,                        /* get_fd_type */
+    NULL,                        /* read */
+    NULL,                        /* write */
+    NULL,                        /* flush */
+    NULL,                        /* get_file_info */
+    NULL,                        /* get_volume_info */
     NULL,                        /* ioctl */
+    NULL,                        /* cancel_async */
     NULL,                        /* queue_async */
     NULL                         /* reselect_async */
 };
-- 
GitLab


From 44212a437dcad90f7f3eb05e949d2a42199dd62e Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Wed, 17 Apr 2024 15:09:54 +0500
Subject: [PATCH 4/6] Fix initialization of the thread_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
thread_fd_ops in server/thread.c -- is being initialized.

For motivation behind this patch please read message of commit
0bd610a1680 (Fix initialization of the handler_fd_ops, 2024-04-16).

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/thread.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/server/thread.c b/server/thread.c
index 55bd63d3030..d88698092bb 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -207,9 +207,14 @@ static const struct fd_ops thread_fd_ops =
 {
     NULL,                       /* get_poll_events */
     thread_poll_event,          /* poll_event */
-    NULL,                       /* flush */
     NULL,                       /* get_fd_type */
+    NULL,                       /* read */
+    NULL,                       /* write */
+    NULL,                       /* flush */
+    NULL,                       /* get_file_info */
+    NULL,                       /* get_volume_info */
     NULL,                       /* ioctl */
+    NULL,                       /* cancel_async */
     NULL,                       /* queue_async */
     NULL                        /* reselect_async */
 };
-- 
GitLab


From 4369162d6f0b21f2daee89887e0a03a5933f4b55 Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Wed, 17 Apr 2024 15:16:52 +0500
Subject: [PATCH 5/6] Fix initialization of the process_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
process_fd_ops in server/process.c -- is being initialized.

For motivation behind this patch please read message of commit
0bd610a1680 (Fix initialization of the handler_fd_ops, 2024-04-16).

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/process.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/server/process.c b/server/process.c
index f6d1641cb94..83c16cec17a 100644
--- a/server/process.c
+++ b/server/process.c
@@ -125,12 +125,16 @@ static const struct fd_ops process_fd_ops =
 {
     NULL,                        /* get_poll_events */
     process_poll_event,          /* poll_event */
-    NULL,                        /* flush */
     NULL,                        /* get_fd_type */
+    NULL,                        /* read */
+    NULL,                        /* write */
+    NULL,                        /* flush */
+    NULL,                        /* get_file_info */
+    NULL,                        /* get_volume_info */
     NULL,                        /* ioctl */
+    NULL,                        /* cancel_async */
     NULL,                        /* queue_async */
-    NULL,                        /* reselect_async */
-    NULL                         /* cancel async */
+    NULL                         /* reselect_async */
 };
 
 /* process startup info */
-- 
GitLab


From bee383d256daf444967a0837f1e8a3aa52563313 Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Wed, 17 Apr 2024 15:22:21 +0500
Subject: [PATCH 6/6] Fix initialization of the msg_queue_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
msg_queue_fd_ops in server/queue.c -- is being initialized.

For motivation behind this patch please read message of commit
0bd610a1680 (Fix initialization of the handler_fd_ops, 2024-04-16).

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/queue.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index ed099b3b989..2d891f66e43 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -196,12 +196,16 @@ static const struct fd_ops msg_queue_fd_ops =
 {
     NULL,                        /* get_poll_events */
     msg_queue_poll_event,        /* poll_event */
-    NULL,                        /* flush */
     NULL,                        /* get_fd_type */
+    NULL,                        /* read */
+    NULL,                        /* write */
+    NULL,                        /* flush */
+    NULL,                        /* get_file_info */
+    NULL,                        /* get_volume_info */
     NULL,                        /* ioctl */
+    NULL,                        /* cancel_async */
     NULL,                        /* queue_async */
-    NULL,                        /* reselect_async */
-    NULL                         /* cancel async */
+    NULL                         /* reselect_async */
 };
 
 
-- 
GitLab

From aeda480e2a0a1b83dc738c3419b3827fd70ac197 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Sat, 25 Nov 2023 23:17:34 +0800
Subject: [PATCH] ntdll: Fix an out-of-bounds write (Coverity).

---
 dlls/ntdll/unix/system.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index a6f1382a5fa..5516831a7b7 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -874,7 +874,7 @@ static void fill_performance_core_info(void)
 
         for(i = beg; i <= end; i++)
         {
-            if (i / 32 > performance_cores_capacity)
+            if (i / 32 >= performance_cores_capacity)
             {
                 p = realloc(performance_cores, performance_cores_capacity * 2 * sizeof(ULONG));
                 if (!p) goto done;
-- 
GitLab

From 2146a4428933b3f582ac533de3393ae9075627d8 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Sat, 25 Nov 2023 23:00:15 +0800
Subject: [PATCH] ntdll: Fix a memory leak (Coverity).

---
 dlls/ntdll/unix/security.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/ntdll/unix/security.c b/dlls/ntdll/unix/security.c
index 76a5cc3f253..3f66d959373 100644
--- a/dlls/ntdll/unix/security.c
+++ b/dlls/ntdll/unix/security.c
@@ -87,7 +87,10 @@ NTSTATUS WINAPI NtCreateToken( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIB
     }
 
     if (primary_group == -1)
+    {
+        free( objattr );
         return STATUS_INVALID_PRIMARY_GROUP;
+    }
 
     groups_info = malloc( groups_size );
     if (!groups_info)
-- 
GitLab

From c2b7453b05b74b012c2417f6953846680a6bd3fb Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 20 Jun 2018 15:07:28 -0500
Subject: [PATCH] HACK: user32: Remove hooks that time out.

In accordance with Win7+ behaviour.
---
 dlls/win32u/hook.c | 19 +++++++++++++------
 1 file changed, 13 insertions(+), 6 deletions(-)

diff --git a/dlls/win32u/hook.c b/dlls/win32u/hook.c
index 378eda40abb..7cdd327a9f5 100644
--- a/dlls/win32u/hook.c
+++ b/dlls/win32u/hook.c
@@ -204,6 +204,7 @@ static LRESULT call_hook( struct win_hook_params *info, const WCHAR *module, siz
                           size_t message_size, BOOL ansi )
 {
     DWORD_PTR ret = 0;
+    LRESULT lres = 0;
 
     if (info->tid)
     {
@@ -218,20 +219,26 @@ static LRESULT call_hook( struct win_hook_params *info, const WCHAR *module, siz
         switch(info->id)
         {
         case WH_KEYBOARD_LL:
-            send_internal_message_timeout( info->pid, info->tid, WM_WINE_KEYBOARD_LL_HOOK,
-                                           info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
-                                           get_ll_hook_timeout(), &ret );
+            lres = send_internal_message_timeout( info->pid, info->tid, WM_WINE_KEYBOARD_LL_HOOK,
+                                                  info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
+                                                  get_ll_hook_timeout(), &ret );
             break;
         case WH_MOUSE_LL:
-            send_internal_message_timeout( info->pid, info->tid, WM_WINE_MOUSE_LL_HOOK,
-                                           info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
-                                           get_ll_hook_timeout(), &ret );
+            lres = send_internal_message_timeout( info->pid, info->tid, WM_WINE_MOUSE_LL_HOOK,
+                                                  info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
+                                                  get_ll_hook_timeout(), &ret );
             break;
         default:
             ERR("Unknown hook id %d\n", info->id);
             assert(0);
             break;
         }
+
+        if (!lres && RtlGetLastWin32Error() == ERROR_TIMEOUT)
+        {
+            TRACE( "Hook %p timed out; removing it.\n", info->handle );
+            NtUserUnhookWindowsHookEx( info->handle );
+        }
     }
     else if (info->proc)
     {

From 8e6caf3f5e751b5202efdc455d43214d037e5a30 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 16 Jun 2023 09:58:54 +0200
Subject: [PATCH] user32: Refresh active hook list only when needed.

Instead of doing it on every get_message request.
---
 dlls/win32u/hook.c    | 29 ++++++++++++++++++++++++-----
 dlls/win32u/message.c |  4 +++-
 server/hook.c         |  8 +++++++-
 server/protocol.def   |  8 +++++++-
 server/queue.c        |  2 --
 server/user.h         |  1 -
 6 files changed, 41 insertions(+), 11 deletions(-)

diff --git a/dlls/win32u/hook.c b/dlls/win32u/hook.c
index f37928e5836..2dadf485c0f 100644
--- a/dlls/win32u/hook.c
+++ b/dlls/win32u/hook.c
@@ -60,12 +60,31 @@ static const char *debugstr_hook_id( unsigned int id )
     return hook_names[id - WH_MINHOOK];
 }
 
-BOOL is_hooked( INT id )
+/***********************************************************************
+ *      get_active_hooks
+ *
+ */
+static UINT get_active_hooks(void)
 {
     struct user_thread_info *thread_info = get_user_thread_info();
 
-    if (!thread_info->active_hooks) return TRUE;
-    return (thread_info->active_hooks & (1 << (id - WH_MINHOOK))) != 0;
+    if (!thread_info->active_hooks)
+    {
+        SERVER_START_REQ( get_active_hooks )
+        {
+            if (!wine_server_call( req )) thread_info->active_hooks = reply->active_hooks;
+        }
+        SERVER_END_REQ;
+    }
+
+    return thread_info->active_hooks;
+}
+
+BOOL is_hooked( INT id )
+{
+    UINT active_hooks = get_active_hooks();
+    if (!active_hooks) return TRUE;
+    return (active_hooks & (1 << (id - WH_MINHOOK))) != 0;
 }
 
 /***********************************************************************
@@ -432,7 +451,7 @@ LRESULT call_message_hooks( INT id, INT code, WPARAM wparam, LPARAM lparam, size
 
     if (!is_hooked( id ))
     {
-        TRACE( "skipping hook %s mask %x\n", hook_names[id-WH_MINHOOK], thread_info->active_hooks );
+        TRACE( "skipping hook %s mask %x\n", hook_names[id-WH_MINHOOK], get_active_hooks() );
         return 0;
     }
 
@@ -571,7 +590,7 @@ void WINAPI NtUserNotifyWinEvent( DWORD event, HWND hwnd, LONG object_id, LONG c
 
     if (!is_hooked( WH_WINEVENT ))
     {
-        TRACE( "skipping hook mask %x\n", thread_info->active_hooks );
+        TRACE( "skipping hook mask %x\n", get_active_hooks() );
         return;
     }
 
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index a7266a6b768..2f1e11f89d2 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -2787,12 +2787,14 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                 info.msg.pt.x    = reply->x;
                 info.msg.pt.y    = reply->y;
                 hw_id            = 0;
-                thread_info->active_hooks = reply->active_hooks;
             }
             else buffer_size = reply->total;
         }
         SERVER_END_REQ;
 
+        /* force refreshing hooks */
+        thread_info->active_hooks = 0;
+
         if (res)
         {
             free( buffer );
diff --git a/server/hook.c b/server/hook.c
index 5abdf39ad37..dd3657c2eac 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -355,7 +355,7 @@ static int is_hook_active( struct hook_table *table, int index )
 }
 
 /* get a bitmap of all active hooks for the current thread */
-unsigned int get_active_hooks(void)
+static unsigned int get_active_hooks(void)
 {
     struct hook_table *table = get_queue_hooks( current );
     struct hook_table *global_hooks = get_global_hooks( current );
@@ -382,6 +382,12 @@ struct thread *get_first_global_hook( int id )
     return hook->owner;
 }
 
+/* get thread active hooks */
+DECL_HANDLER(get_active_hooks)
+{
+    reply->active_hooks = get_active_hooks();
+}
+
 /* set a window hook */
 DECL_HANDLER(set_hook)
 {
diff --git a/server/protocol.def b/server/protocol.def
index 8f35a0772f4..cb54b6ebb79 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2193,7 +2193,6 @@ enum message_type
     int             x;         /* message x position */
     int             y;         /* message y position */
     unsigned int    time;      /* message time */
-    unsigned int    active_hooks; /* active hooks bitmap */
     data_size_t     total;     /* total size of extra data */
     VARARG(data,message_data); /* message data for sent messages */
 @END
@@ -2990,6 +2989,13 @@ enum caret_state
 };
 
 
+/* get thread active hooks */
+@REQ(get_active_hooks)
+@REPLY
+    unsigned int   active_hooks;   /* active hooks bitmap */
+@END
+
+
 /* Set a window hook */
 @REQ(set_hook)
     int            id;             /* id of the hook */
diff --git a/server/user.h b/server/user.h
index 0ad24ba20df..c753e1799a4 100644
--- a/server/user.h
+++ b/server/user.h
@@ -91,7 +91,6 @@ extern void cleanup_clipboard_thread( struct thread *thread );
 /* hook functions */
 
 extern void remove_thread_hooks( struct thread *thread );
-extern unsigned int get_active_hooks(void);
 extern struct thread *get_first_global_hook( int id );
 
 /* queue functions */


From 74e8b85db92a4f5643115d6c7f434795d5b535e3 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 24 Apr 2023 19:58:11 -0600
Subject: [PATCH] HACK: server: Disable hooks that time out.

An addition to "HACK: user32: Remove hooks that time out."

CW-Bug-Id: #22178
---
 server/hook.c  | 25 ++++++++++++++++++++++++-
 server/queue.c | 22 ++++++++++++++++++----
 server/user.h  |  3 ++-
 3 files changed, 44 insertions(+), 6 deletions(-)

diff --git a/server/hook.c b/server/hook.c
index 3a89a883c3c..24eb27434db 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -374,16 +374,39 @@ static unsigned int get_active_hooks(void)
 }
 
 /* return the thread that owns the first global hook */
-struct thread *get_first_global_hook( int id )
+struct thread *get_first_global_hook( int id, thread_id_t *thread_id, client_ptr_t *proc )
 {
     struct hook *hook;
     struct hook_table *global_hooks = get_global_hooks( current );
 
     if (!global_hooks) return NULL;
     if (!(hook = get_first_valid_hook( global_hooks, id - WH_MINHOOK, EVENT_MIN, 0, 0, 0 ))) return NULL;
+    *thread_id = hook->owner->id;
+    *proc = hook->proc;
     return hook->owner;
 }
 
+void disable_hung_hook( struct desktop *desktop, int id, thread_id_t thread_id, client_ptr_t proc )
+{
+    struct hook_table *global_hooks = desktop->global_hooks;
+    int index = id - WH_MINHOOK;
+    struct hook *hook;
+
+    if (!global_hooks || !proc) return;
+
+    hook = get_first_hook( global_hooks, index );
+
+    while (hook)
+    {
+        if (hook->proc == proc && hook->owner->id == thread_id)
+        {
+            hook->proc = 0;
+            return;
+        }
+        hook = HOOK_ENTRY( list_next( &global_hooks->hooks[index], &hook->chain ) );
+    }
+}
+
 /* get thread active hooks */
 DECL_HANDLER(get_active_hooks)
 {
diff --git a/server/queue.c b/server/queue.c
index fb6fe2d9478..12592241c92 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -68,6 +68,8 @@ struct message_result
     void                  *data;          /* message reply data */
     unsigned int           data_size;     /* size of message reply data */
     struct timeout_user   *timeout;       /* result timeout */
+    thread_id_t            hook_thread_id;/* Hook owner thread id. */
+    client_ptr_t           hook_proc;     /* Hook proc address. */
 };
 
 struct message
@@ -986,6 +988,13 @@ static void result_timeout( void *private )
     {
         struct message *msg = result->msg;
 
+        if (result->sender && result->hook_thread_id && result->hook_proc)
+        {
+            if (debug_level > 1)
+                fprintf( stderr, "disabling hung hook: tid %04x, proc %#lx\n",
+                         result->hook_thread_id, (unsigned long)result->hook_proc );
+            disable_hung_hook( result->sender->input->desktop, msg->msg, result->hook_thread_id, result->hook_proc );
+        }
         result->msg = NULL;
         msg->result = NULL;
         remove_queue_message( result->receiver, msg, SEND_MESSAGE );
@@ -997,7 +1006,8 @@ static void result_timeout( void *private )
 /* allocate and fill a message result structure */
 static struct message_result *alloc_message_result( struct msg_queue *send_queue,
                                                     struct msg_queue *recv_queue,
-                                                    struct message *msg, timeout_t timeout )
+                                                    struct message *msg, timeout_t timeout,
+                                                    thread_id_t hook_thread_id, client_ptr_t hook_proc)
 {
     struct message_result *result = mem_alloc( sizeof(*result) );
     if (result)
@@ -1012,6 +1022,8 @@ static struct message_result *alloc_message_result( struct msg_queue *send_queue
         result->hardware_msg = NULL;
         result->desktop      = NULL;
         result->callback_msg = NULL;
+        result->hook_thread_id = hook_thread_id;
+        result->hook_proc = hook_proc;
 
         if (msg->type == MSG_CALLBACK)
         {
@@ -2001,8 +2013,10 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
     struct message *msg;
     timeout_t timeout = 2000 * -10000;  /* FIXME: load from registry */
     int id = (input->type == INPUT_MOUSE) ? WH_MOUSE_LL : WH_KEYBOARD_LL;
+    thread_id_t hook_thread_id;
+    client_ptr_t hook_proc;
 
-    if (!(hook_thread = get_first_global_hook( id ))) return 0;
+    if (!(hook_thread = get_first_global_hook( id, &hook_thread_id, &hook_proc ))) return 0;
     if (!(queue = hook_thread->queue)) return 0;
     if (is_queue_hung( queue )) return 0;
 
@@ -2027,7 +2041,7 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
     else msg->lparam = input->mouse.data << 16;
 
     if (!(msg->data = memdup( hardware_msg->data, hardware_msg->data_size )) ||
-        !(msg->result = alloc_message_result( sender, queue, msg, timeout )))
+        !(msg->result = alloc_message_result( sender, queue, msg, timeout, hook_thread_id, hook_proc )))
     {
         free_message( msg );
         return 0;
@@ -3031,7 +3045,7 @@ DECL_HANDLER(send_message)
         case MSG_ASCII:
         case MSG_UNICODE:
         case MSG_CALLBACK:
-            if (!(msg->result = alloc_message_result( send_queue, recv_queue, msg, req->timeout )))
+            if (!(msg->result = alloc_message_result( send_queue, recv_queue, msg, req->timeout, 0, 0 )))
             {
                 free_message( msg );
                 break;
diff --git a/server/user.h b/server/user.h
index 26d22a00240..a6ef5fc1f83 100644
--- a/server/user.h
+++ b/server/user.h
@@ -92,7 +92,8 @@ extern void cleanup_clipboard_thread( struct thread *thread );
 /* hook functions */
 
 extern void remove_thread_hooks( struct thread *thread );
-extern struct thread *get_first_global_hook( int id );
+extern struct thread *get_first_global_hook( int id, thread_id_t *thread_id, client_ptr_t *proc );
+extern void disable_hung_hook( struct desktop *desktop, int id, thread_id_t thread_id, client_ptr_t proc );
 
 /* queue functions */
 
From 5b833c83beadcad2ace5f27e95554c164f6f7c86 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 20 Jan 2024 16:05:17 +0100
Subject: [PATCH] server: Stop waiting on LL-hooks for non-injected input.

---
 server/queue.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 0b9430c5f4d..91284f1da17 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2871,7 +2871,8 @@ DECL_HANDLER(send_hardware_message)
 {
     struct desktop *desktop;
     unsigned int origin = (req->flags & SEND_HWMSG_INJECTED ? IMO_INJECTED : IMO_HARDWARE);
-    struct msg_queue *sender = get_current_queue();
+    struct msg_queue *sender = req->flags & SEND_HWMSG_INJECTED ? get_current_queue() : NULL;
+    int wait = 0;
 
     if (!(desktop = get_hardware_input_desktop( req->win ))) return;
     if ((origin == IMO_INJECTED && desktop != current->queue->input->desktop) ||
@@ -2756,10 +2781,10 @@ DECL_HANDLER(send_hardware_message)
     switch (req->input.type)
     {
     case INPUT_MOUSE:
-        reply->wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender, req->flags );
+        wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender, req->flags );
         break;
     case INPUT_KEYBOARD:
-        reply->wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender, req->flags );
+        wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender, req->flags );
         break;
     case INPUT_HARDWARE:
         queue_custom_hardware_message( desktop, req->win, origin, &req->input );
@@ -2900,6 +2901,7 @@ DECL_HANDLER(send_hardware_message)
         set_error( STATUS_INVALID_PARAMETER );
     }
 
+    reply->wait = sender ? wait : 0;
     reply->new_x = desktop->cursor.x;
     reply->new_y = desktop->cursor.y;
     release_object( desktop );
@@ -2795,8 +2821,6 @@ DECL_HANDLER(get_message)
     user_handle_t get_win = get_user_full_handle( req->get_win );
     unsigned int filter = req->flags >> 16;
 
-    reply->active_hooks = get_active_hooks();
-
     /* first check for internal messages */
     if (queue && get_queued_message( queue, 0, SEND_MESSAGE, 0, 0x80000000, 0xffffffff, PM_REMOVE, reply ))
         return;

