From a1c074a5eec1e9a005cdfaec915dd860e84c4ab4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 8 Sep 2023 14:24:11 +0200
Subject: [PATCH] winex11: Always ignore MotionNotify event after SetCursorPos.

Trying to workaround spurious Wayland mouse motion.

CW-Bug-Id: #22650
---
 dlls/winex11.drv/mouse.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 72a5d0173e4..2f208da3645 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -1674,7 +1674,7 @@ BOOL X11DRV_MotionNotify( HWND hwnd, XEvent *xev )
     input.u.mi.time        = x11drv_time_to_ticks( event->time );
     input.u.mi.dwExtraInfo = 0;
 
-    if (!hwnd && is_old_motion_event( event->serial ))
+    if (is_old_motion_event( event->serial ))
     {
         TRACE( "pos %d,%d old serial %lu, ignoring\n", event->x, event->y, event->serial );
         return FALSE;

From 7940050635c1de9636194b59845e07ee7be49842 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 12 Oct 2023 21:38:46 -0600
Subject: [PATCH] ntdll: HACK: Avoid unitialized Dr7 in RtlRaiseException on
 x64.

CW-Bug-Id: #22848
---
 dlls/ntdll/signal_x86_64.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index f41a09f9ca4..3cb6e09736c 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -1553,6 +1553,8 @@ __ASM_GLOBAL_FUNC( RtlRaiseException,
                    "movq 0x4f8(%rsp),%rax\n\t"  /* return address */
                    "movq %rax,0xf8(%rdx)\n\t"   /* context->Rip */
                    "movq %rax,0x10(%rcx)\n\t"   /* rec->ExceptionAddress */
+                   "xor %rax,%rax\n\t"
+                   "movq %rax,0x70(%rdx)\n\t"   /* Context->Dr7 */
                    "movl $1,%r8d\n\t"
                    "movq %gs:(0x30),%rax\n\t"   /* Teb */
                    "movq 0x60(%rax),%rax\n\t"   /* Peb */

From 7bc7829db283134946d1c7ae0468ddc1bbf993a0 Mon Sep 17 00:00:00 2001
From: deltaconnected <deltaconnected@gmail.com>
Date: Thu, 26 Aug 2021 03:06:23 +0200
Subject: [PATCH] ntdll: Use a critical section for setting the newly created timer in RtlCreateTimer

In RtlCreateTimer, NewTimer is being set after RtlLeaveCriticalSection, which
seems to allow callbacks created with DueTime == 0 to execute and finish and
delete an invalid timer before the scheduling thread is switched back.

Fixes crashes inside DeleteTimerQueueEx and DeleteTimerQueueTimer for 
Guild Wars 2 with Arcdps (https://www.deltaconnected.com/arcdps/)

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51683
---
 dlls/ntdll/threadpool.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index ca323919d05..20096573c2b 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -936,12 +936,13 @@ NTSTATUS WINAPI RtlCreateTimer(PHANDLE NewTimer, HANDLE TimerQueue,
     if (q->quit)
         status = STATUS_INVALID_HANDLE;
     else
+    {
+        *NewTimer = t;
         queue_add_timer(t, queue_current_time() + DueTime, TRUE);
+    }
     RtlLeaveCriticalSection(&q->cs);
 
-    if (status == STATUS_SUCCESS)
-        *NewTimer = t;
-    else
+    if (status != STATUS_SUCCESS)
         RtlFreeHeap(GetProcessHeap(), 0, t);
 
     return status;
-- 
2.33.0

From 988ed7cef7c734708b61bad84911486ed3107b7e Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 1 May 2023 21:19:09 -0600
Subject: [PATCH] ntdll: HACK: Set thread teb earlier in start_main_thread().

CW-Bug-Id: #22218
---
 dlls/ntdll/unix/loader.c        | 3 +++
 dlls/ntdll/unix/signal_i386.c   | 6 ++++++
 dlls/ntdll/unix/signal_x86_64.c | 4 ++++
 dlls/ntdll/unix/unix_private.h  | 1 +
 4 files changed, 14 insertions(+)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 19d30b4f0d5..d3dea1b0dd1 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2138,6 +2138,9 @@ static void start_main_thread(void)
     virtual_map_user_shared_data();
     init_cpu_info();
     init_files();
+
+    set_thread_teb( teb );
+
     init_startup_info();
     *(ULONG_PTR *)&peb->CloudFileFlags = get_image_address();
     set_load_order_app_name( main_wargv[0] );
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index eb40bda2d94..5b7d460372c 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -2393,6 +2393,12 @@ void signal_init_threading(void)
 #endif
 }
 
+void set_thread_teb( TEB *teb )
+{
+    struct x86_thread_data *thread_data = (struct x86_thread_data *)&teb->GdiTebBatch;
+
+    ldt_set_fs( thread_data->fs, teb );
+}
 
 /**********************************************************************
  *		signal_alloc_thread
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index ea826a7e8dc..63f732b45b4 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -2814,6 +2814,10 @@ void signal_init_process(void)
     exit(1);
 }
 
+void set_thread_teb( TEB *teb )
+{
+    arch_prctl( ARCH_SET_GS, teb );
+}
 
 /***********************************************************************
  *           call_init_thunk
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index b09255e8dbd..5e4cfbd834b 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -295,6 +295,7 @@ extern BOOL get_thread_times( int unix_p
                               LARGE_INTEGER *user_time ) DECLSPEC_HIDDEN;
 extern void signal_init_threading(void) DECLSPEC_HIDDEN;
 extern NTSTATUS signal_alloc_thread( TEB *teb ) DECLSPEC_HIDDEN;
+extern void set_thread_teb( TEB *teb );
 extern void signal_free_thread( TEB *teb ) DECLSPEC_HIDDEN;
 extern void signal_init_process(void) DECLSPEC_HIDDEN;
 extern void signal_init_early(void) DECLSPEC_HIDDEN;

From 11511dfebb9ffd465a8eeb8fca6ad5e2bfbd012b Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 26 Jan 2024 23:01:11 -0600
Subject: [PATCH] kernelbase: Workaround forced stack aligment for
 SignalObjectAndWait().

CW-Bug-Id: #23256
---
 dlls/kernelbase/sync.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/dlls/kernelbase/sync.c b/dlls/kernelbase/sync.c
index 406af74c269..7406291ed78 100644
--- a/dlls/kernelbase/sync.c
+++ b/dlls/kernelbase/sync.c
@@ -284,7 +284,11 @@ DWORD WINAPI DECLSPEC_HOTPATCH SignalObjectAndWait( HANDLE signal, HANDLE wait,
                                                     DWORD timeout, BOOL alertable )
 {
     NTSTATUS status;
+#ifdef __i386__
+    DECLSPEC_ALIGN(4) LARGE_INTEGER time;
+#else
     LARGE_INTEGER time;
+#endif
 
     TRACE( "%p %p %ld %d\n", signal, wait, timeout, alertable );
 
From 38ee816b818e08a36aa94c697f26ce8c317a7c1d Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 18 Dec 2023 17:02:28 -0600
Subject: [PATCH] ntdll: Only allocate debug info with
 RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO in
 RtlInitializeCriticalSectionEx().

CW-Bug-Id: #23142
---
 dlls/kernel32/tests/sync.c | 23 ++++++++++++++++++++++-
 dlls/ntdll/sync.c          |  6 +++---
 include/winnt.h            |  1 +
 3 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index d872d75fdd1..28f07f572c3 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -205,7 +205,7 @@ static inline NTSTATUS wait_semaphore( RTL_CRITICAL_SECTION *crit, int timeout )
  */
 NTSTATUS WINAPI RtlInitializeCriticalSection( RTL_CRITICAL_SECTION *crit )
 {
-    return RtlInitializeCriticalSectionEx( crit, 0, 0 );
+    return RtlInitializeCriticalSectionEx( crit, 0, RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO );
 }
 
 
@@ -214,7 +214,7 @@ NTSTATUS WINAPI RtlInitializeCriticalSection( RTL_CRITICAL_SECTION *crit )
  */
 NTSTATUS WINAPI RtlInitializeCriticalSectionAndSpinCount( RTL_CRITICAL_SECTION *crit, ULONG spincount )
 {
-    return RtlInitializeCriticalSectionEx( crit, spincount, 0 );
+    return RtlInitializeCriticalSectionEx( crit, spincount, RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO );
 }
 
 
@@ -232,7 +232,7 @@ NTSTATUS WINAPI RtlInitializeCriticalSectionEx( RTL_CRITICAL_SECTION *crit, ULON
      * is done, then debug info should be managed through Rtlp[Allocate|Free]DebugInfo
      * so (e.g.) MakeCriticalSectionGlobal() doesn't free it using HeapFree().
      */
-    if (flags & RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO)
+    if (!(flags & RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO))
         crit->DebugInfo = no_debug_info_marker;
     else
     {
diff --git a/include/winnt.h b/include/winnt.h
index 20db9a8aabd..0e1a197d423 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -6056,6 +6056,7 @@ typedef struct _RTL_CRITICAL_SECTION {
 #define RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO 0x1000000
 #define RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN  0x2000000
 #define RTL_CRITICAL_SECTION_FLAG_STATIC_INIT   0x4000000
+#define RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO 0x10000000
 #define RTL_CRITICAL_SECTION_ALL_FLAG_BITS      0xFF000000
 #define RTL_CRITICAL_SECTION_FLAG_RESERVED      (RTL_CRITICAL_SECTION_ALL_FLAG_BITS & ~0x7000000)
 
From 14f7b22769d6cc6f2ded0dad7fde3755459bc407 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 18 Dec 2023 17:49:20 -0600
Subject: [PATCH] ntdll: Set DebugInfo to NULL for absent DebugInfo in
 RtlDeleteCriticalSection().

CW-Bug-Id: #23142
---
 dlls/kernel32/tests/sync.c | 6 +++---
 dlls/ntdll/sync.c          | 6 +++++-
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 28f07f572c3..54a8a122dc0 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -288,7 +288,11 @@ NTSTATUS WINAPI RtlDeleteCriticalSection( RTL_CRITICAL_SECTION *crit )
             crit->DebugInfo = NULL;
         }
     }
-    else NtClose( crit->LockSemaphore );
+    else
+    {
+        NtClose( crit->LockSemaphore );
+        crit->DebugInfo = NULL;
+    }
     crit->LockSemaphore = 0;
     return STATUS_SUCCESS;
 }

From 26e3d2ecedb4f48d0002b7e75dd4d80eb00b54a9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 6 Feb 2024 18:01:59 +0200
Subject: [PATCH] win32u: Use consistent locking order for display related
 mutexes.

Most paths that hold both the display_lock and the display_devices_init
mutex acquire them in the order just mentioned. However, there are two
cases where these are acquired in the opposite order, which with
unfortunate thread interactions and timings can lead to a deadlock. Fix
these cases to use the same order as the rest of the code.
---
 dlls/win32u/sysparams.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 9a43de8fd76..673082056b1 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -1251,8 +1251,8 @@ static void add_gpu( const struct gdi_gpu *gpu, void *param )
 
     if (!ctx->mutex)
     {
-        ctx->mutex = get_display_device_init_mutex();
         pthread_mutex_lock( &display_lock );
+        ctx->mutex = get_display_device_init_mutex();
         prepare_devices();
     }
 
@@ -1717,8 +1717,8 @@ static BOOL update_display_cache_from_registry(void)
 
     if (key.LastWriteTime.QuadPart <= last_query_display_time) return TRUE;
 
-    mutex = get_display_device_init_mutex();
     pthread_mutex_lock( &display_lock );
+    mutex = get_display_device_init_mutex();
 
     clear_display_devices();
 
-- 
GitLab

From 7562292ceae1b36b5e7ac2402ac0fba7486acd7a Mon Sep 17 00:00:00 2001
From: Eric Pouech <epouech@codeweavers.com>
Date: Tue, 7 Nov 2023 19:12:39 +0100
Subject: [PATCH] user32: Use SecureZeroMemory to clear magic fields.

Signed-off-by: Eric Pouech <epouech@codeweavers.com>
---
 dlls/user32/dde_misc.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/user32/dde_misc.c b/dlls/user32/dde_misc.c
index 39b439976cd..b5ccf449692 100644
--- a/dlls/user32/dde_misc.c
+++ b/dlls/user32/dde_misc.c
@@ -2113,7 +2113,8 @@ void WDML_RemoveConv(WDML_CONV* pRef, WDML_SIDE side)
 	    {
 		pPrev->next = pCurrent->next;
 	    }
-	    pCurrent->magic = 0;
+            /* Ensure compiler doesn't optimize out the assignment with 0. */
+	    SecureZeroMemory(&pCurrent->magic, sizeof(pCurrent->magic));
 	    HeapFree(GetProcessHeap(), 0, pCurrent);
 	    break;
 	}
-- 
GitLab

From 6a862c997584816064be6f0e0ec9308dece6d376 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Thu, 21 Apr 2022 00:09:40 +0900
Subject: [PATCH 1/6] user32/tests: Make test_unicode_wm_char robust against
 superfluous messages.

Commit e445303ab45 (user32/tests: Make a few more messages optional.,
2014-03-20) modified test_unicode_wm_char so that it skips non-essential
messages (e.g. WM_DWMNCRENDERINGCHANGED) from GetMessageW.

Extend this for messages from GetMessageA as well.

Also, handle the case where no messages other than WM_QUIT are received
at all.

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/user32/tests/msg.c | 20 +++++++++++++-------
 1 file changed, 13 insertions(+), 7 deletions(-)

From c6df0448fee728c997f1756ec9eff65f5b774992 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Sun, 17 Apr 2022 00:49:56 +0900
Subject: [PATCH 2/6] include: Add definition for
 UOI_TIMERPROC_EXCEPTION_SUPPRESSION

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 include/winuser.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/include/winuser.h b/include/winuser.h
index 453f561e62f..666deeb6cbe 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -99,6 +99,7 @@ typedef void* HPOWERNOTIFY;
 #define UOI_NAME        2
 #define UOI_TYPE        3
 #define UOI_USER_SID    4
+#define UOI_TIMERPROC_EXCEPTION_SUPPRESSION 7
 
 #define WSF_VISIBLE     1
 #define DF_ALLOWOTHERACCOUNTHOOK  1
-- 
GitLab

From 5ba99e842f71b3b8d2632c55ae202ccde1751f42 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Mon, 18 Apr 2022 19:27:38 +0900
Subject: [PATCH 4/6] user32: Implement UOI_TIMERPROC_EXCEPTION_SUPPRESSION.

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/user32/message.c      | 11 ++++++++++-
 dlls/user32/tests/msg.c    |  6 ------
 dlls/user32/user32.spec    |  2 +-
 dlls/user32/user_main.c    |  1 +
 dlls/user32/user_private.h |  1 +
 dlls/user32/winstation.c   | 23 ++++++++++++++++++++++-
 6 files changed, 35 insertions(+), 9 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 4016c95539a..54ee5317eed 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -861,6 +861,15 @@ static LRESULT dispatch_message( const MSG *msg, BOOL ansi )
 }
 
 
+static LONG WINAPI timerproc_exception_filter(EXCEPTION_POINTERS *eptr)
+{
+    if (suppress_timerproc_exception)
+        return EXCEPTION_EXECUTE_HANDLER;
+
+    return EXCEPTION_CONTINUE_SEARCH;
+}
+
+
 /***********************************************************************
  *		DispatchMessageA (USER32.@)
  *
@@ -878,7 +887,7 @@ LRESULT WINAPI DECLSPEC_HOTPATCH DispatchMessageA( const MSG* msg )
             retval = CallWindowProcA( (WNDPROC)msg->lParam, msg->hwnd,
                                       msg->message, msg->wParam, GetTickCount() );
         }
-        __EXCEPT_ALL
+        __EXCEPT(timerproc_exception_filter)
         {
             retval = 0;
         }

diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index 96e6e1a7d6b..6a605ae4216 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -721,7 +721,7 @@
 @ stdcall SetThreadDpiAwarenessContext(ptr)
 @ stdcall SetTimer(long long long ptr)
 @ stdcall SetUserObjectInformationA(long long ptr long)
-@ stdcall SetUserObjectInformationW(long long ptr long) NtUserSetObjectInformation
+@ stdcall SetUserObjectInformationW(long long ptr long)
 @ stdcall SetUserObjectSecurity(long ptr ptr)
 @ stdcall SetWinEventHook(long long long ptr long long long)
 @ stdcall SetWindowCompositionAttribute(ptr ptr)
diff --git a/dlls/user32/user_main.c b/dlls/user32/user_main.c
index ef2b94ba698..f375462487b 100644
--- a/dlls/user32/user_main.c
+++ b/dlls/user32/user_main.c
@@ -29,6 +29,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(graphics);
 WINE_DECLARE_DEBUG_CHANNEL(message);
 
 HMODULE user32_module = 0;
+BOOL suppress_timerproc_exception = TRUE;
 
 extern void WDML_NotifyThreadDetach(void);
 
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index a9bbdd16fb0..91612f9c6c5 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -44,6 +44,7 @@ struct wm_char_mapping_data
 };
 
 extern HMODULE user32_module;
+extern BOOL suppress_timerproc_exception;
 
 extern BOOL post_dde_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, DWORD dest_tid,
                               DWORD type );
diff --git a/dlls/user32/winstation.c b/dlls/user32/winstation.c
index 62593ca046f..789e45f8928 100644
--- a/dlls/user32/winstation.c
+++ b/dlls/user32/winstation.c
@@ -389,12 +389,33 @@ BOOL WINAPI GetUserObjectInformationA( HANDLE handle, INT index, LPVOID info, DW
 }
 
 
+/******************************************************************************
+ *              SetUserObjectInformationW   (USER32.@)
+ */
+BOOL WINAPI SetUserObjectInformationW( HANDLE handle, INT index, LPVOID info, DWORD len )
+{
+    if (index == UOI_TIMERPROC_EXCEPTION_SUPPRESSION)
+    {
+        if (handle != GetCurrentProcess() || len != sizeof(BOOL))
+        {
+            SetLastError(ERROR_INVALID_PARAMETER);
+            return FALSE;
+        }
+
+        suppress_timerproc_exception = *(const BOOL *)info;
+        return TRUE;
+    }
+
+    return NtUserSetObjectInformation( handle, index, info, len );
+}
+
+
 /******************************************************************************
  *              SetUserObjectInformationA   (USER32.@)
  */
 BOOL WINAPI SetUserObjectInformationA( HANDLE handle, INT index, LPVOID info, DWORD len )
 {
-    return NtUserSetObjectInformation( handle, index, info, len );
+    return SetUserObjectInformationW( handle, index, info, len );
 }
 
 
-- 
GitLab

From 66fb617b6945bac43a1ac8a5073aae06d602b4e1 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Mon, 18 Apr 2022 19:39:07 +0900
Subject: [PATCH 6/6] win32u: Ignore unhandled info index in
 NtUserSetObjectInformation.

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/win32u/tests/win32u.c | 4 ----
 dlls/win32u/winstation.c   | 2 ++
 2 files changed, 2 insertions(+), 4 deletions(-)

diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index b187b246941..0a84cf03552 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -395,6 +395,8 @@ BOOL WINAPI NtUserSetObjectInformation( HANDLE handle, INT index, void *info, DW
     BOOL ret;
     const USEROBJECTFLAGS *obj_flags = info;
 
+    if (index == UOI_TIMERPROC_EXCEPTION_SUPPRESSION) return TRUE;
+
     if (index != UOI_FLAGS || !info || len < sizeof(*obj_flags))
     {
         RtlSetLastWin32Error( ERROR_INVALID_PARAMETER );
-- 
GitLab

From 61176033a2bb3c6a5a229078f684b85ee085ef80 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 6 Feb 2024 19:05:00 -0600
Subject: [PATCH] ntdll: Better track thread pool wait's wait_pending state.

CW-Bug-Id: #21509
---
 dlls/ntdll/threadpool.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 4f22114a55e..9a8f380bf72 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -1265,6 +1265,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                                   u.wait.wait_entry )
         {
             assert( wait->type == TP_OBJECT_TYPE_WAIT );
+            assert( wait->u.wait.wait_pending );
             if (wait->u.wait.timeout <= now.QuadPart)
             {
                 /* Wait object timed out. */
@@ -1272,6 +1273,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                 {
                     list_remove( &wait->u.wait.wait_entry );
                     list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+                    wait->u.wait.wait_pending = FALSE;
                 }
                 if ((wait->u.wait.flags & (WT_EXECUTEINWAITTHREAD | WT_EXECUTEINIOTHREAD)))
                 {
@@ -1329,6 +1331,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                     {
                         list_remove( &wait->u.wait.wait_entry );
                         list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+                        wait->u.wait.wait_pending = FALSE;
                     }
                     if ((wait->u.wait.flags & (WT_EXECUTEINWAITTHREAD | WT_EXECUTEINIOTHREAD)))
                     {

From 25d2d4c847b03b409564079a5cef1ab6ff71e457 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 6 Feb 2024 19:14:40 -0600
Subject: [PATCH] ntdll: Make sure wakeups from already unset events are
 ignored in waitqueue_thread_proc().

CW-Bug-Id: #21509
---
 dlls/ntdll/threadpool.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 9a8f380bf72..2887e84b12c 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -160,6 +160,7 @@ struct threadpool_object
     LONG                    num_pending_callbacks;
     LONG                    num_running_callbacks;
     LONG                    num_associated_callbacks;
+    LONG                    update_serial;
     /* arguments for callback */
     union
     {
@@ -1243,6 +1244,7 @@ static void tp_timerqueue_unlock( struct threadpool_object *timer )
 static void CALLBACK waitqueue_thread_proc( void *param )
 {
     struct threadpool_object *objects[MAXIMUM_WAITQUEUE_OBJECTS];
+    LONG update_serials[MAXIMUM_WAITQUEUE_OBJECTS];
     HANDLE handles[MAXIMUM_WAITQUEUE_OBJECTS + 1];
     struct waitqueue_bucket *bucket = param;
     struct threadpool_object *wait, *next;
@@ -1295,6 +1297,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                 InterlockedIncrement( &wait->refcount );
                 objects[num_handles] = wait;
                 handles[num_handles] = wait->u.wait.handle;
+                update_serials[num_handles] = wait->update_serial;
                 num_handles++;
             }
         }
@@ -1323,7 +1326,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
             {
                 wait = objects[status - STATUS_WAIT_0];
                 assert( wait->type == TP_OBJECT_TYPE_WAIT );
-                if (wait->u.wait.bucket)
+                if (wait->u.wait.bucket && wait->update_serial == update_serials[status - STATUS_WAIT_0])
                 {
                     /* Wait object signaled. */
                     assert( wait->u.wait.bucket == bucket );
@@ -1344,7 +1347,10 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                     else tp_object_submit( wait, TRUE );
                 }
                 else
-                    WARN("wait object %p triggered while object was destroyed\n", wait);
+                {
+                    WARN("wait object %p triggered while object was %s.\n",
+                            wait, wait->u.wait.bucket ? "updated" : "destroyed");
+                }
             }
 
             /* Release temporary references to wait objects. */
@@ -1917,6 +1923,7 @@ static void tp_object_initialize( struct threadpool_object *object, struct threa
     object->num_pending_callbacks   = 0;
     object->num_running_callbacks   = 0;
     object->num_associated_callbacks = 0;
+    object->update_serial           = 0;
 
     if (environment)
     {
@@ -3050,12 +3061,15 @@ VOID WINAPI TpSetWait( TP_WAIT *wait, HA
 {
     struct threadpool_object *this = impl_from_TP_WAIT( wait );
     ULONGLONG timestamp = MAXLONGLONG;
+    BOOL same_handle;
 
     TRACE( "%p %p %p\n", wait, handle, timeout );
 
     enter_critical_section( &waitqueue.cs );
 
     assert( this->u.wait.bucket );
+
+    same_handle = this->u.wait.handle == handle;
     this->u.wait.handle = handle;
 
     if (handle || this->u.wait.wait_pending)
@@ -3090,6 +3100,8 @@ VOID WINAPI TpSetWait( TP_WAIT *wait, HANDLE handle, LARGE_INTEGER *timeout )
         }
 
         /* Wake up the wait queue thread. */
+        if (!same_handle)
+            ++this->update_serial;
         NtSetEvent( bucket->update_event, NULL );
     }
 
From a4cf21c6f78639f60aa3af69de4cac9d0468f13f Mon Sep 17 00:00:00 2001
From: Tatsuyuki Ishi <ishitatsuyuki@gmail.com>
Date: Sat, 17 Feb 2024 22:11:43 +0900
Subject: [PATCH] ntdll: Don't leak objattr allocation in NtCreateSemaphore.

https://github.com/ValveSoftware/wine/pull/219
---
 dlls/ntdll/unix/sync.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index ed30388b026..dd08632e21c 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -272,7 +272,6 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
 
     *handle = 0;
     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
-    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     if (do_fsync())
         return fsync_create_semaphore( handle, access, attr, initial, max );
@@ -280,6 +279,8 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
     if (do_esync())
         return esync_create_semaphore( handle, access, attr, initial, max );
 
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
     SERVER_START_REQ( create_semaphore )
     {
         req->access  = access;

From f392d0687cb74f47dbfceb4a57b496191f183969 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 29 Feb 2024 20:02:48 -0600
Subject: [PATCH] fixup! ntdll: Read process memory on the client side in
 NtReadVirtualMemory().

CW-Bug-Id: #23456
---
 dlls/ntdll/unix/virtual.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index ba2fe258ede..97b55022c7a 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -6305,13 +6305,21 @@ NTSTATUS WINAPI NtReadVirtualMemory( HANDLE process, const void *addr, void *buf
     int unix_pid;
     ssize_t ret;
 
-    SERVER_START_REQ( read_process_memory )
+    if (process == NtCurrentProcess())
     {
-        req->handle = wine_server_obj_handle( process );
-        status = wine_server_call( req );
-        unix_pid = reply->unix_pid;
+        unix_pid = getpid();
+        status = STATUS_SUCCESS;
+    }
+    else
+    {
+        SERVER_START_REQ( read_process_memory )
+        {
+            req->handle = wine_server_obj_handle( process );
+            status = wine_server_call( req );
+            unix_pid = reply->unix_pid;
+        }
+        SERVER_END_REQ;
     }
-    SERVER_END_REQ;
 
     if (status)
     {


From 146c2631276b3e826085a6d270d71c5f56b75d87 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 5 Apr 2024 12:11:51 -0600
Subject: [PATCH] ntdll: Return STATUS_NO_YIELD_PERFORMED from
 NtYieldExecution() on Linux if no yield was performed.

---
 dlls/ntdll/unix/sync.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index ae7bc115ffe..e070233104b 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -43,6 +43,9 @@
 #ifdef HAVE_SCHED_H
 # include <sched.h>
 #endif
+#ifdef HAVE_SYS_RESOURCE_H
+# include <sys/resource.h>
+#endif
 #include <string.h>
 #include <stdarg.h>
 #include <stdio.h>
@@ -1514,7 +1517,17 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
 NTSTATUS WINAPI NtYieldExecution(void)
 {
 #ifdef HAVE_SCHED_YIELD
+#ifdef RUSAGE_THREAD
+    struct rusage u1, u2;
+    int ret;
+
+    ret = getrusage( RUSAGE_THREAD, &u1 );
+#endif
     sched_yield();
+#ifdef RUSAGE_THREAD
+    if (!ret) ret = getrusage( RUSAGE_THREAD, &u2 );
+    if (!ret && u1.ru_nvcsw == u2.ru_nvcsw && u1.ru_nivcsw == u2.ru_nivcsw) return STATUS_NO_YIELD_PERFORMED;
+#endif
     return STATUS_SUCCESS;
 #else
     return STATUS_NO_YIELD_PERFORMED;
-- 
GitLab
From c55cce6fcbadca3d5b5fd4e2a434ada2c2012479 Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Thu, 16 Nov 2023 19:54:07 +0100
Subject: [PATCH] server: Initialize pe image struct padding to avoid Valgrind
 warning.

---
 include/wine/server_protocol.h | 3 ++-
 server/mapping.c               | 1 +
 server/protocol.def            | 1 +
 3 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 15156a12353..139a7bca69e 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -844,6 +844,7 @@ typedef struct
     unsigned char  contains_code : 1;
     unsigned char  wine_builtin : 1;
     unsigned char  wine_fakedll : 1;
+    unsigned char  padding : 5;
     unsigned char  image_flags;
     unsigned int   loader_flags;
     unsigned int   header_size;
@@ -6506,7 +6507,7 @@ union generic_reply
 
 /* ### protocol_version begin ### */
 
-#define SERVER_PROTOCOL_VERSION 785
+#define SERVER_PROTOCOL_VERSION 786
 
 /* ### protocol_version end ### */
 
diff --git a/server/mapping.c b/server/mapping.c
index a795dc4b38b..b5684c484d2 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -842,6 +842,7 @@ static unsigned int get_image_params( struct mapping *mapping, file_pos_t file_s
         return STATUS_INVALID_IMAGE_FORMAT;
     }
 
+    mapping->image.padding       = 0;
     mapping->image.map_addr      = get_fd_map_address( mapping->fd );
     mapping->image.image_charact = nt.FileHeader.Characteristics;
     mapping->image.machine       = nt.FileHeader.Machine;
diff --git a/server/protocol.def b/server/protocol.def
index b4d6d74d6fc..5d60e7fcda3 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -860,6 +860,7 @@ typedef struct
     unsigned char  contains_code : 1;
     unsigned char  wine_builtin : 1;
     unsigned char  wine_fakedll : 1;
+    unsigned char  padding : 5;
     unsigned char  image_flags;
     unsigned int   loader_flags;
     unsigned int   header_size;
-- 
GitLab

From 9dc80b13bec0b482150dbd8c9236dbb8b6a31ccd Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 21 Dec 2023 11:44:39 +0100
Subject: [PATCH 1/2] server: Introduce a new get_desktop_cursor_thread_input
 helper.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=55961
---
 server/queue.c | 30 +++++++++++++++++++-----------
 1 file changed, 19 insertions(+), 11 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index ee8bdf34b7f..d2cf9800258 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -429,26 +429,34 @@ static void queue_cursor_message( struct desktop *desktop, user_handle_t win, un
     queue_hardware_message( desktop, msg, 1 );
 }
 
+static struct thread_input *get_desktop_cursor_thread_input( struct desktop *desktop )
+{
+    struct thread_input *input = NULL;
+    struct thread *thread;
+
+    if ((thread = get_window_thread( desktop->cursor.win )))
+    {
+        if (thread->queue) input = thread->queue->input;
+        release_object( thread );
+    }
+
+    return input;
+}
+
 static int update_desktop_cursor_window( struct desktop *desktop, user_handle_t win )
 {
     int updated = win != desktop->cursor.win;
-    user_handle_t handle = desktop->cursor.handle;
+    struct thread_input *input;
     desktop->cursor.win = win;
-    if (updated)
-    {
-        struct thread *thread;
-
-        if ((thread = get_window_thread( win )))
-        {
-            struct thread_input *input = thread->queue->input;
-            if (input) handle = input->cursor_count < 0 ? 0 : input->cursor;
-            release_object( thread );
-        }
 
+    if (updated && (input = get_desktop_cursor_thread_input( desktop )))
+    {
+        user_handle_t handle = input->cursor_count < 0 ? 0 : input->cursor;
         /* when clipping send the message to the foreground window as well, as some driver have an artificial overlay window */
         if (is_cursor_clipped( desktop )) queue_cursor_message( desktop, 0, WM_WINE_SETCURSOR, win, handle );
         queue_cursor_message( desktop, win, WM_WINE_SETCURSOR, win, handle );
     }
+
     return updated;
 }
 
-- 
GitLab

From d1789fbb40d74b747451c9c5d9e738c463a6aa67 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 21 Dec 2023 11:47:00 +0100
Subject: [PATCH 2/2] server: Change desktop cursor only when inside the
 thread's windows.

Getting rid of the desktop cursor handle at the same time.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=55961
---
 server/queue.c | 13 ++++---------
 server/user.h  |  1 -
 2 files changed, 4 insertions(+), 10 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index d2cf9800258..cd913ae03e5 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -478,13 +478,11 @@ static int update_desktop_cursor_pos( struct desktop *desktop, user_handle_t win
     return updated;
 }
 
-static void update_desktop_cursor_handle( struct desktop *desktop, user_handle_t handle )
+static void update_desktop_cursor_handle( struct desktop *desktop, struct thread_input *input )
 {
-    int updated = desktop->cursor.handle != handle;
-    user_handle_t win = desktop->cursor.win;
-    desktop->cursor.handle = handle;
-    if (updated)
+    if (input == get_desktop_cursor_thread_input( desktop ))
     {
+        user_handle_t handle = input->cursor_count < 0 ? 0 : input->cursor, win = desktop->cursor.win;
         /* when clipping send the message to the foreground window as well, as some driver have an artificial overlay window */
         if (is_cursor_clipped( desktop )) queue_cursor_message( desktop, 0, WM_WINE_SETCURSOR, win, handle );
         queue_cursor_message( desktop, win, WM_WINE_SETCURSOR, win, handle );
@@ -3414,10 +3412,7 @@ DECL_HANDLER(set_cursor)
     if (req->flags & SET_CURSOR_NOCLIP) set_clip_rectangle( desktop, NULL, SET_CURSOR_NOCLIP, 0 );
 
     if (req->flags & (SET_CURSOR_HANDLE | SET_CURSOR_COUNT))
-    {
-        if (input->cursor_count < 0) update_desktop_cursor_handle( desktop, 0 );
-        else update_desktop_cursor_handle( desktop, input->cursor );
-    }
+        update_desktop_cursor_handle( desktop, input );
 
     reply->new_x       = desktop->cursor.x;
     reply->new_y       = desktop->cursor.y;
diff --git a/server/user.h b/server/user.h
index b6f47bcac1c..8fa55e09b0f 100644
--- a/server/user.h
+++ b/server/user.h
@@ -59,7 +59,6 @@ struct global_cursor
     rectangle_t          clip;             /* cursor clip rectangle */
     unsigned int         last_change;      /* time of last position change */
     user_handle_t        win;              /* window that contains the cursor */
-    user_handle_t        handle;           /* last set cursor handle */
 };
 
 struct desktop
-- 
GitLab

From 6c44228c1f673f4147153db53247b2dc700ae24e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Jan 2024 23:25:33 +0100
Subject: [PATCH] winex11: Sync with gdi_display before closing the threads
 display.

---
 dlls/winex11.drv/x11drv_main.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 1b9555bcfbf..25a36cb8c0c 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -721,6 +721,7 @@ void X11DRV_ThreadDetach(void)
         vulkan_thread_detach();
         if (data->xim) XCloseIM( data->xim );
         if (data->font_set) XFreeFontSet( data->display, data->font_set );
+        XSync( gdi_display, False ); /* make sure XReparentWindow requests have completed before closing the thread display */
         XCloseDisplay( data->display );
         free( data );
         /* clear data in case we get re-entered from user32 before the thread is truly dead */
-- 
GitLab

From e390b67fa52b0808b71bb4c7feb08ca12a3a7444 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Mon, 21 Sep 2020 17:27:00 +0300
Subject: [PATCH] server: Try to retrieve the unix name on handles created from
 file descriptors.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=46070
Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 server/fd.c   | 39 +++++++++++++++++++++++++++++++++++++++
 server/file.c |  1 +
 server/file.h |  2 ++
 3 files changed, 42 insertions(+)

diff --git a/server/fd.c b/server/fd.c
index 11111111111..11111111111 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -2312,6 +2312,45 @@ struct fd *create_anonymous_fd( const struct fd_ops *fd_user_ops, int unix_fd, s
     return NULL;
 }
 
+void set_unix_name_of_fd( struct fd *fd, const struct stat *fd_st )
+{
+#ifdef __linux__
+    static const char procfs_fmt[] = "/proc/self/fd/%d";
+
+    char path[PATH_MAX], procfs_path[sizeof(procfs_fmt) - 2 /* %d */ + 11];
+    struct stat path_st;
+    ssize_t len;
+
+    sprintf( procfs_path, procfs_fmt, fd->unix_fd );
+    len = readlink( procfs_path, path, sizeof(path) );
+    if (len == -1 || len >= sizeof(path) )
+        return;
+    path[len] = '\0';
+
+    /* Make sure it's an absolute path, has at least one hardlink, and the same inode */
+    if (path[0] != '/' || stat( path, &path_st ) || path_st.st_nlink < 1 ||
+        path_st.st_dev != fd_st->st_dev || path_st.st_ino != fd_st->st_ino)
+        return;
+
+    if (!(fd->unix_name = mem_alloc( len + 1 )))
+        return;
+    memcpy( fd->unix_name, path, len + 1 );
+
+#elif defined(F_GETPATH)
+    char path[PATH_MAX];
+    size_t size;
+
+    if (fcntl( fd->unix_fd, F_GETPATH, path ) == -1 || path[0] != '/')
+        return;
+
+    size = strlen(path) + 1;
+    if (!(fd->unix_name = mem_alloc( size )))
+        return;
+    memcpy( fd->unix_name, path, size );
+
+#endif
+}
+
 /* retrieve the object that is using an fd */
 void *get_fd_user( struct fd *fd )
 {
diff --git a/server/file.c b/server/file.c
index 11111111111..11111111111 100644
--- a/server/file.c
+++ b/server/file.c
@@ -187,6 +187,7 @@ struct file *create_file_for_fd( int fd, unsigned int access, unsigned int shari
         release_object( file );
         return NULL;
     }
+    set_unix_name_of_fd( file->fd, &st );
     allow_fd_caching( file->fd );
     return file;
 }
diff --git a/server/file.h b/server/file.h
index 11111111111..11111111111 100644
--- a/server/file.h
+++ b/server/file.h
@@ -22,6 +22,7 @@
 #define __WINE_SERVER_FILE_H
 
 #include <sys/types.h>
+#include <sys/stat.h>
 
 #include "object.h"
 
@@ -85,6 +86,7 @@ extern struct fd *open_fd( struct fd *root, const char *name, struct unicode_str
                            unsigned int sharing, unsigned int options );
 extern struct fd *create_anonymous_fd( const struct fd_ops *fd_user_ops,
                                        int unix_fd, struct object *user, unsigned int options );
+extern void set_unix_name_of_fd( struct fd *fd, const struct stat *fd_st );
 extern struct fd *dup_fd_object( struct fd *orig, unsigned int access, unsigned int sharing,
                                  unsigned int options );
 extern struct fd *get_fd_object_for_mapping( struct fd *fd, unsigned int access, unsigned int sharing );
-- 
0.0.0

From 36e637ec9c2e14836e316e30546c5f6936a7e249 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 31 Jul 2020 09:09:47 +0200
Subject: [PATCH] ntdll: Use RTLD_NOLOAD to find already mapped modules.

This makes it possible to detect modules that weren't unmapped from
dlclose, and that we should not fixup again.
---
 dlls/ntdll/unix/loader.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -1142,8 +1142,10 @@ static NTSTATUS dlopen_dll( const char *so_name, UNICODE_STRING *nt_name, void *
 {
     void *module, *handle;
     const IMAGE_NT_HEADERS *nt;
+    BOOL mapped = FALSE;
 
-    handle = dlopen( so_name, RTLD_NOW );
+    if ((handle = dlopen( so_name, RTLD_NOW | RTLD_NOLOAD ))) mapped = TRUE;
+    else handle = dlopen( so_name, RTLD_NOW );
     if (!handle)
     {
         WARN( "failed to load .so lib %s: %s\n", debugstr_a(so_name), dlerror() );
@@ -1165,7 +1167,7 @@ static NTSTATUS dlopen_dll( const char *so_name, UNICODE_STRING *nt_name, void *
         return STATUS_SUCCESS;
     }
 
-    if (map_so_dll( nt, module ))
+    if (!mapped && map_so_dll( nt, module ))
     {
         dlclose( handle );
         return STATUS_NO_MEMORY;

From: Paul Gofman <pgofman@codeweavers.com>
Subject: [PATCH v3 1/3] server: Update system regs from set_thread_context handler only.
Message-Id: <20210527101600.348718-1-pgofman@codeweavers.com>
Date: Thu, 27 May 2021 13:15:58 +0300

Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
---
    Supersedes 206374-206376.
v3:
    - replaced patch.

 server/thread.c | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/server/thread.c b/server/thread.c
index 11111111111..11111111111 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -2165,9 +2165,6 @@ DECL_HANDLER(select)
         {
             apc_call_t *data;
             data_size_t size = sizeof(*data) + (ctx->regs[CTX_WOW].flags ? 2 : 1) * sizeof(context_t);
-            unsigned int flags = system_flags & ctx->regs[CTX_NATIVE].flags;
-
-            if (flags) set_thread_context( current, &ctx->regs[CTX_NATIVE], flags );
             size = min( size, get_reply_max_size() );
             if ((data = set_reply_data_size( size )))
             {
@@ -2413,7 +2410,7 @@ DECL_HANDLER(set_thread_context)
         unsigned int flags = system_flags & contexts[CTX_NATIVE].flags;
 
         if (thread != current) stop_thread( thread );
-        else if (flags) set_thread_context( thread, &contexts[CTX_NATIVE], flags );
+        if (flags) set_thread_context( thread, &contexts[CTX_NATIVE], flags );
 
         if (thread->context && !get_error())
         {

-- 
0.0.0

From a2f384b71cafb619124a10471f4b2c84fe1da278 Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Tue, 16 Apr 2024 23:19:05 +0500
Subject: [PATCH 1/6] Fix initialization of the handler_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
handler_fd_ops in server/signal.c -- is being initialized.

It looks like field list in initialization of the handler_fd_ops in
server/signal.c was out-of-sync for a long time.  Take a look, for
example, on patches ad1e0609a0f (server: Get rid of no loner used
cancel_async from fd_ops., 2016-12-01) (which removed "reference" to the
cancel_async field correctly, but did not add "references" to the read
and write fields, for example), or 837b39b2028 (server: Add read and
write fd member functions., 2015-05-05) (which updated `struct fd_ops'
but did not change initialization of the handler_fd_ops at all).

Because the main purpose of initialization of the handler_fd_ops made in
server/signal.c is to assign address of the handler_poll_event()
function to the poll_event field, while making all other fields NULLed,
lacking some fields in that initialization is not an error according to
C standard:

> 6.7.11 Initialization
>
> 11 ... If an object that has static or thread storage duration is not
> initialized explicitly, or any object is initialized with an empty
> initializer, then it is subject to default initialization, which
> initializes an object as follows:
>
>   - if it has pointer type, it is initialized to a null pointer;
> ...
> 22 If there are fewer initializers in a brace-enclosed list than there
> are elements or members of an aggregate, or fewer characters in a
> string literal used to initialize an array of known size than there
> are elements in the array, the remainder of the aggregate is subject
> to default initialization.

But to maintain code consistency I believe initialization of the
handler_fd_ops object should enumerate all fields of the
`struct fd_ops' type.

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/signal.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/server/signal.c b/server/signal.c
index 19b76d44c16..45a516f4599 100644
--- a/server/signal.c
+++ b/server/signal.c
@@ -84,9 +84,14 @@ static const struct fd_ops handler_fd_ops =
 {
     NULL,                     /* get_poll_events */
     handler_poll_event,       /* poll_event */
-    NULL,                     /* flush */
     NULL,                     /* get_fd_type */
+    NULL,                     /* read */
+    NULL,                     /* write */
+    NULL,                     /* flush */
+    NULL,                     /* get_file_info */
+    NULL,                     /* get_volume_info */
     NULL,                     /* ioctl */
+    NULL,                     /* cancel_async */
     NULL,                     /* queue_async */
     NULL                      /* reselect_async */
 };
-- 
GitLab


From ea2e56de5f5afb7983fd209f466e92424a403a59 Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Wed, 17 Apr 2024 11:44:35 +0500
Subject: [PATCH 2/6] Fix initialization of the master_socket_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
master_socket_fd_ops in server/request.c -- is being initialized.

For motivation behind this patch please read message of the previous
commit 0bd610a1680 (Fix initialization of the handler_fd_ops,
2024-04-16).

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/request.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/server/request.c b/server/request.c
index 2691e0c7cff..bb9b978df46 100644
--- a/server/request.c
+++ b/server/request.c
@@ -110,9 +110,14 @@ static const struct fd_ops master_socket_fd_ops =
 {
     NULL,                          /* get_poll_events */
     master_socket_poll_event,      /* poll_event */
-    NULL,                          /* flush */
     NULL,                          /* get_fd_type */
+    NULL,                          /* read */
+    NULL,                          /* write */
+    NULL,                          /* flush */
+    NULL,                          /* get_file_info */
+    NULL,                          /* get_volume_info */
     NULL,                          /* ioctl */
+    NULL,                          /* cancel_async */
     NULL,                          /* queue_async */
     NULL                           /* reselect_async */
 };
-- 
GitLab


From 436b01b543ea88f22da4973f43b3f00311f87409 Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Wed, 17 Apr 2024 15:01:28 +0500
Subject: [PATCH 3/6] Fix initialization of the inotify_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
inotify_fd_ops in server/change.c -- is being initialized.

For motivation behind this patch please read message of commit
0bd610a1680 (Fix initialization of the handler_fd_ops, 2024-04-16).

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/change.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/server/change.c b/server/change.c
index f773ccf8831..36c648f18b7 100644
--- a/server/change.c
+++ b/server/change.c
@@ -644,9 +644,14 @@ static const struct fd_ops inotify_fd_ops =
 {
     inotify_get_poll_events,     /* get_poll_events */
     inotify_poll_event,          /* poll_event */
-    NULL,                        /* flush */
     NULL,                        /* get_fd_type */
+    NULL,                        /* read */
+    NULL,                        /* write */
+    NULL,                        /* flush */
+    NULL,                        /* get_file_info */
+    NULL,                        /* get_volume_info */
     NULL,                        /* ioctl */
+    NULL,                        /* cancel_async */
     NULL,                        /* queue_async */
     NULL                         /* reselect_async */
 };
-- 
GitLab


From 44212a437dcad90f7f3eb05e949d2a42199dd62e Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Wed, 17 Apr 2024 15:09:54 +0500
Subject: [PATCH 4/6] Fix initialization of the thread_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
thread_fd_ops in server/thread.c -- is being initialized.

For motivation behind this patch please read message of commit
0bd610a1680 (Fix initialization of the handler_fd_ops, 2024-04-16).

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/thread.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/server/thread.c b/server/thread.c
index 55bd63d3030..d88698092bb 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -207,9 +207,14 @@ static const struct fd_ops thread_fd_ops =
 {
     NULL,                       /* get_poll_events */
     thread_poll_event,          /* poll_event */
-    NULL,                       /* flush */
     NULL,                       /* get_fd_type */
+    NULL,                       /* read */
+    NULL,                       /* write */
+    NULL,                       /* flush */
+    NULL,                       /* get_file_info */
+    NULL,                       /* get_volume_info */
     NULL,                       /* ioctl */
+    NULL,                       /* cancel_async */
     NULL,                       /* queue_async */
     NULL                        /* reselect_async */
 };
-- 
GitLab


From 4369162d6f0b21f2daee89887e0a03a5933f4b55 Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Wed, 17 Apr 2024 15:16:52 +0500
Subject: [PATCH 5/6] Fix initialization of the process_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
process_fd_ops in server/process.c -- is being initialized.

For motivation behind this patch please read message of commit
0bd610a1680 (Fix initialization of the handler_fd_ops, 2024-04-16).

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/process.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/server/process.c b/server/process.c
index f6d1641cb94..83c16cec17a 100644
--- a/server/process.c
+++ b/server/process.c
@@ -125,12 +125,16 @@ static const struct fd_ops process_fd_ops =
 {
     NULL,                        /* get_poll_events */
     process_poll_event,          /* poll_event */
-    NULL,                        /* flush */
     NULL,                        /* get_fd_type */
+    NULL,                        /* read */
+    NULL,                        /* write */
+    NULL,                        /* flush */
+    NULL,                        /* get_file_info */
+    NULL,                        /* get_volume_info */
     NULL,                        /* ioctl */
+    NULL,                        /* cancel_async */
     NULL,                        /* queue_async */
-    NULL,                        /* reselect_async */
-    NULL                         /* cancel async */
+    NULL                         /* reselect_async */
 };
 
 /* process startup info */
-- 
GitLab


From bee383d256daf444967a0837f1e8a3aa52563313 Mon Sep 17 00:00:00 2001
From: Ruslan Garipov <ruslanngaripov@gmail.com>
Date: Wed, 17 Apr 2024 15:22:21 +0500
Subject: [PATCH 6/6] Fix initialization of the msg_queue_fd_ops

This lists all fields of the `struct fd_ops' when object of that type --
msg_queue_fd_ops in server/queue.c -- is being initialized.

For motivation behind this patch please read message of commit
0bd610a1680 (Fix initialization of the handler_fd_ops, 2024-04-16).

No functional changes intended.

Signed-off-by: Ruslan Garipov <ruslanngaripov@gmail.com>
---
 server/queue.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index ed099b3b989..2d891f66e43 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -196,12 +196,16 @@ static const struct fd_ops msg_queue_fd_ops =
 {
     NULL,                        /* get_poll_events */
     msg_queue_poll_event,        /* poll_event */
-    NULL,                        /* flush */
     NULL,                        /* get_fd_type */
+    NULL,                        /* read */
+    NULL,                        /* write */
+    NULL,                        /* flush */
+    NULL,                        /* get_file_info */
+    NULL,                        /* get_volume_info */
     NULL,                        /* ioctl */
+    NULL,                        /* cancel_async */
     NULL,                        /* queue_async */
-    NULL,                        /* reselect_async */
-    NULL                         /* cancel async */
+    NULL                         /* reselect_async */
 };
 
 
-- 
GitLab

From aeda480e2a0a1b83dc738c3419b3827fd70ac197 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Sat, 25 Nov 2023 23:17:34 +0800
Subject: [PATCH] ntdll: Fix an out-of-bounds write (Coverity).

---
 dlls/ntdll/unix/system.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index a6f1382a5fa..5516831a7b7 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -874,7 +874,7 @@ static void fill_performance_core_info(void)
 
         for(i = beg; i <= end; i++)
         {
-            if (i / 32 > performance_cores_capacity)
+            if (i / 32 >= performance_cores_capacity)
             {
                 p = realloc(performance_cores, performance_cores_capacity * 2 * sizeof(ULONG));
                 if (!p) goto done;
-- 
GitLab

From 2146a4428933b3f582ac533de3393ae9075627d8 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Sat, 25 Nov 2023 23:00:15 +0800
Subject: [PATCH] ntdll: Fix a memory leak (Coverity).

---
 dlls/ntdll/unix/security.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/ntdll/unix/security.c b/dlls/ntdll/unix/security.c
index 76a5cc3f253..3f66d959373 100644
--- a/dlls/ntdll/unix/security.c
+++ b/dlls/ntdll/unix/security.c
@@ -87,7 +87,10 @@ NTSTATUS WINAPI NtCreateToken( HANDLE *handle, ACCESS_MASK access, OBJECT_ATTRIB
     }
 
     if (primary_group == -1)
+    {
+        free( objattr );
         return STATUS_INVALID_PRIMARY_GROUP;
+    }
 
     groups_info = malloc( groups_size );
     if (!groups_info)
-- 
GitLab

From c2b7453b05b74b012c2417f6953846680a6bd3fb Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Wed, 20 Jun 2018 15:07:28 -0500
Subject: [PATCH] HACK: user32: Remove hooks that time out.

In accordance with Win7+ behaviour.
---
 dlls/win32u/hook.c | 19 +++++++++++++------
 1 file changed, 13 insertions(+), 6 deletions(-)

diff --git a/dlls/win32u/hook.c b/dlls/win32u/hook.c
index 378eda40abb..7cdd327a9f5 100644
--- a/dlls/win32u/hook.c
+++ b/dlls/win32u/hook.c
@@ -204,6 +204,7 @@ static LRESULT call_hook( struct win_hook_params *info, const WCHAR *module, siz
                           size_t message_size, BOOL ansi )
 {
     DWORD_PTR ret = 0;
+    LRESULT lres = 0;
 
     if (info->tid)
     {
@@ -218,20 +219,26 @@ static LRESULT call_hook( struct win_hook_params *info, const WCHAR *module, siz
         switch(info->id)
         {
         case WH_KEYBOARD_LL:
-            send_internal_message_timeout( info->pid, info->tid, WM_WINE_KEYBOARD_LL_HOOK,
-                                           info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
-                                           get_ll_hook_timeout(), &ret );
+            lres = send_internal_message_timeout( info->pid, info->tid, WM_WINE_KEYBOARD_LL_HOOK,
+                                                  info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
+                                                  get_ll_hook_timeout(), &ret );
             break;
         case WH_MOUSE_LL:
-            send_internal_message_timeout( info->pid, info->tid, WM_WINE_MOUSE_LL_HOOK,
-                                           info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
-                                           get_ll_hook_timeout(), &ret );
+            lres = send_internal_message_timeout( info->pid, info->tid, WM_WINE_MOUSE_LL_HOOK,
+                                                  info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
+                                                  get_ll_hook_timeout(), &ret );
             break;
         default:
             ERR("Unknown hook id %d\n", info->id);
             assert(0);
             break;
         }
+
+        if (!lres && RtlGetLastWin32Error() == ERROR_TIMEOUT)
+        {
+            TRACE( "Hook %p timed out; removing it.\n", info->handle );
+            NtUserUnhookWindowsHookEx( info->handle );
+        }
     }
     else if (info->proc)
     {

From 8e6caf3f5e751b5202efdc455d43214d037e5a30 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 16 Jun 2023 09:58:54 +0200
Subject: [PATCH] user32: Refresh active hook list only when needed.

Instead of doing it on every get_message request.
---
 dlls/win32u/hook.c    | 29 ++++++++++++++++++++++++-----
 dlls/win32u/message.c |  4 +++-
 server/hook.c         |  8 +++++++-
 server/protocol.def   |  8 +++++++-
 server/queue.c        |  2 --
 server/user.h         |  1 -
 6 files changed, 41 insertions(+), 11 deletions(-)

diff --git a/dlls/win32u/hook.c b/dlls/win32u/hook.c
index f37928e5836..2dadf485c0f 100644
--- a/dlls/win32u/hook.c
+++ b/dlls/win32u/hook.c
@@ -60,12 +60,31 @@ static const char *debugstr_hook_id( unsigned int id )
     return hook_names[id - WH_MINHOOK];
 }
 
-BOOL is_hooked( INT id )
+/***********************************************************************
+ *      get_active_hooks
+ *
+ */
+static UINT get_active_hooks(void)
 {
     struct user_thread_info *thread_info = get_user_thread_info();
 
-    if (!thread_info->active_hooks) return TRUE;
-    return (thread_info->active_hooks & (1 << (id - WH_MINHOOK))) != 0;
+    if (!thread_info->active_hooks)
+    {
+        SERVER_START_REQ( get_active_hooks )
+        {
+            if (!wine_server_call( req )) thread_info->active_hooks = reply->active_hooks;
+        }
+        SERVER_END_REQ;
+    }
+
+    return thread_info->active_hooks;
+}
+
+BOOL is_hooked( INT id )
+{
+    UINT active_hooks = get_active_hooks();
+    if (!active_hooks) return TRUE;
+    return (active_hooks & (1 << (id - WH_MINHOOK))) != 0;
 }
 
 /***********************************************************************
@@ -432,7 +451,7 @@ LRESULT call_message_hooks( INT id, INT code, WPARAM wparam, LPARAM lparam, size
 
     if (!is_hooked( id ))
     {
-        TRACE( "skipping hook %s mask %x\n", hook_names[id-WH_MINHOOK], thread_info->active_hooks );
+        TRACE( "skipping hook %s mask %x\n", hook_names[id-WH_MINHOOK], get_active_hooks() );
         return 0;
     }
 
@@ -571,7 +590,7 @@ void WINAPI NtUserNotifyWinEvent( DWORD event, HWND hwnd, LONG object_id, LONG c
 
     if (!is_hooked( WH_WINEVENT ))
     {
-        TRACE( "skipping hook mask %x\n", thread_info->active_hooks );
+        TRACE( "skipping hook mask %x\n", get_active_hooks() );
         return;
     }
 
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index a7266a6b768..2f1e11f89d2 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -2787,12 +2787,14 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                 info.msg.pt.x    = reply->x;
                 info.msg.pt.y    = reply->y;
                 hw_id            = 0;
-                thread_info->active_hooks = reply->active_hooks;
             }
             else buffer_size = reply->total;
         }
         SERVER_END_REQ;
 
+        /* force refreshing hooks */
+        thread_info->active_hooks = 0;
+
         if (res)
         {
             free( buffer );
diff --git a/server/hook.c b/server/hook.c
index 5abdf39ad37..dd3657c2eac 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -355,7 +355,7 @@ static int is_hook_active( struct hook_table *table, int index )
 }
 
 /* get a bitmap of all active hooks for the current thread */
-unsigned int get_active_hooks(void)
+static unsigned int get_active_hooks(void)
 {
     struct hook_table *table = get_queue_hooks( current );
     struct hook_table *global_hooks = get_global_hooks( current );
@@ -382,6 +382,12 @@ struct thread *get_first_global_hook( int id )
     return hook->owner;
 }
 
+/* get thread active hooks */
+DECL_HANDLER(get_active_hooks)
+{
+    reply->active_hooks = get_active_hooks();
+}
+
 /* set a window hook */
 DECL_HANDLER(set_hook)
 {
diff --git a/server/protocol.def b/server/protocol.def
index 8f35a0772f4..cb54b6ebb79 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2193,7 +2193,6 @@ enum message_type
     int             x;         /* message x position */
     int             y;         /* message y position */
     unsigned int    time;      /* message time */
-    unsigned int    active_hooks; /* active hooks bitmap */
     data_size_t     total;     /* total size of extra data */
     VARARG(data,message_data); /* message data for sent messages */
 @END
@@ -2990,6 +2989,13 @@ enum caret_state
 };
 
 
+/* get thread active hooks */
+@REQ(get_active_hooks)
+@REPLY
+    unsigned int   active_hooks;   /* active hooks bitmap */
+@END
+
+
 /* Set a window hook */
 @REQ(set_hook)
     int            id;             /* id of the hook */
diff --git a/server/user.h b/server/user.h
index 0ad24ba20df..c753e1799a4 100644
--- a/server/user.h
+++ b/server/user.h
@@ -91,7 +91,6 @@ extern void cleanup_clipboard_thread( struct thread *thread );
 /* hook functions */
 
 extern void remove_thread_hooks( struct thread *thread );
-extern unsigned int get_active_hooks(void);
 extern struct thread *get_first_global_hook( int id );
 
 /* queue functions */


From 74e8b85db92a4f5643115d6c7f434795d5b535e3 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 24 Apr 2023 19:58:11 -0600
Subject: [PATCH] HACK: server: Disable hooks that time out.

An addition to "HACK: user32: Remove hooks that time out."

CW-Bug-Id: #22178
---
 server/hook.c  | 25 ++++++++++++++++++++++++-
 server/queue.c | 22 ++++++++++++++++++----
 server/user.h  |  3 ++-
 3 files changed, 44 insertions(+), 6 deletions(-)

diff --git a/server/hook.c b/server/hook.c
index 3a89a883c3c..24eb27434db 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -374,16 +374,39 @@ static unsigned int get_active_hooks(void)
 }
 
 /* return the thread that owns the first global hook */
-struct thread *get_first_global_hook( int id )
+struct thread *get_first_global_hook( int id, thread_id_t *thread_id, client_ptr_t *proc )
 {
     struct hook *hook;
     struct hook_table *global_hooks = get_global_hooks( current );
 
     if (!global_hooks) return NULL;
     if (!(hook = get_first_valid_hook( global_hooks, id - WH_MINHOOK, EVENT_MIN, 0, 0, 0 ))) return NULL;
+    *thread_id = hook->owner->id;
+    *proc = hook->proc;
     return hook->owner;
 }
 
+void disable_hung_hook( struct desktop *desktop, int id, thread_id_t thread_id, client_ptr_t proc )
+{
+    struct hook_table *global_hooks = desktop->global_hooks;
+    int index = id - WH_MINHOOK;
+    struct hook *hook;
+
+    if (!global_hooks || !proc) return;
+
+    hook = get_first_hook( global_hooks, index );
+
+    while (hook)
+    {
+        if (hook->proc == proc && hook->owner->id == thread_id)
+        {
+            hook->proc = 0;
+            return;
+        }
+        hook = HOOK_ENTRY( list_next( &global_hooks->hooks[index], &hook->chain ) );
+    }
+}
+
 /* get thread active hooks */
 DECL_HANDLER(get_active_hooks)
 {
diff --git a/server/queue.c b/server/queue.c
index fb6fe2d9478..12592241c92 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -68,6 +68,8 @@ struct message_result
     void                  *data;          /* message reply data */
     unsigned int           data_size;     /* size of message reply data */
     struct timeout_user   *timeout;       /* result timeout */
+    thread_id_t            hook_thread_id;/* Hook owner thread id. */
+    client_ptr_t           hook_proc;     /* Hook proc address. */
 };
 
 struct message
@@ -986,6 +988,13 @@ static void result_timeout( void *private )
     {
         struct message *msg = result->msg;
 
+        if (result->sender && result->hook_thread_id && result->hook_proc)
+        {
+            if (debug_level > 1)
+                fprintf( stderr, "disabling hung hook: tid %04x, proc %#lx\n",
+                         result->hook_thread_id, (unsigned long)result->hook_proc );
+            disable_hung_hook( result->sender->input->desktop, msg->msg, result->hook_thread_id, result->hook_proc );
+        }
         result->msg = NULL;
         msg->result = NULL;
         remove_queue_message( result->receiver, msg, SEND_MESSAGE );
@@ -997,7 +1006,8 @@ static void result_timeout( void *private )
 /* allocate and fill a message result structure */
 static struct message_result *alloc_message_result( struct msg_queue *send_queue,
                                                     struct msg_queue *recv_queue,
-                                                    struct message *msg, timeout_t timeout )
+                                                    struct message *msg, timeout_t timeout,
+                                                    thread_id_t hook_thread_id, client_ptr_t hook_proc)
 {
     struct message_result *result = mem_alloc( sizeof(*result) );
     if (result)
@@ -1012,6 +1022,8 @@ static struct message_result *alloc_message_result( struct msg_queue *send_queue
         result->hardware_msg = NULL;
         result->desktop      = NULL;
         result->callback_msg = NULL;
+        result->hook_thread_id = hook_thread_id;
+        result->hook_proc = hook_proc;
 
         if (msg->type == MSG_CALLBACK)
         {
@@ -2001,8 +2013,10 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
     struct message *msg;
     timeout_t timeout = 2000 * -10000;  /* FIXME: load from registry */
     int id = (input->type == INPUT_MOUSE) ? WH_MOUSE_LL : WH_KEYBOARD_LL;
+    thread_id_t hook_thread_id;
+    client_ptr_t hook_proc;
 
-    if (!(hook_thread = get_first_global_hook( id ))) return 0;
+    if (!(hook_thread = get_first_global_hook( id, &hook_thread_id, &hook_proc ))) return 0;
     if (!(queue = hook_thread->queue)) return 0;
     if (is_queue_hung( queue )) return 0;
 
@@ -2027,7 +2041,7 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
     else msg->lparam = input->mouse.data << 16;
 
     if (!(msg->data = memdup( hardware_msg->data, hardware_msg->data_size )) ||
-        !(msg->result = alloc_message_result( sender, queue, msg, timeout )))
+        !(msg->result = alloc_message_result( sender, queue, msg, timeout, hook_thread_id, hook_proc )))
     {
         free_message( msg );
         return 0;
@@ -3031,7 +3045,7 @@ DECL_HANDLER(send_message)
         case MSG_ASCII:
         case MSG_UNICODE:
         case MSG_CALLBACK:
-            if (!(msg->result = alloc_message_result( send_queue, recv_queue, msg, req->timeout )))
+            if (!(msg->result = alloc_message_result( send_queue, recv_queue, msg, req->timeout, 0, 0 )))
             {
                 free_message( msg );
                 break;
diff --git a/server/user.h b/server/user.h
index 26d22a00240..a6ef5fc1f83 100644
--- a/server/user.h
+++ b/server/user.h
@@ -92,7 +92,8 @@ extern void cleanup_clipboard_thread( struct thread *thread );
 /* hook functions */
 
 extern void remove_thread_hooks( struct thread *thread );
-extern struct thread *get_first_global_hook( int id );
+extern struct thread *get_first_global_hook( int id, thread_id_t *thread_id, client_ptr_t *proc );
+extern void disable_hung_hook( struct desktop *desktop, int id, thread_id_t thread_id, client_ptr_t proc );
 
 /* queue functions */
 
From 5b833c83beadcad2ace5f27e95554c164f6f7c86 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 20 Jan 2024 16:05:17 +0100
Subject: [PATCH] server: Stop waiting on LL-hooks for non-injected input.

---
 server/queue.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 0b9430c5f4d..91284f1da17 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2871,7 +2871,8 @@ DECL_HANDLER(send_hardware_message)
 {
     struct desktop *desktop;
     unsigned int origin = (req->flags & SEND_HWMSG_INJECTED ? IMO_INJECTED : IMO_HARDWARE);
-    struct msg_queue *sender = get_current_queue();
+    struct msg_queue *sender = req->flags & SEND_HWMSG_INJECTED ? get_current_queue() : NULL;
+    int wait = 0;
 
     if (!(desktop = get_hardware_input_desktop( req->win ))) return;
     if ((origin == IMO_INJECTED && desktop != current->queue->input->desktop) ||
@@ -2756,10 +2781,10 @@ DECL_HANDLER(send_hardware_message)
     switch (req->input.type)
     {
     case INPUT_MOUSE:
-        reply->wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender, req->flags );
+        wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender, req->flags );
         break;
     case INPUT_KEYBOARD:
-        reply->wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender, req->flags );
+        wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender, req->flags );
         break;
     case INPUT_HARDWARE:
         queue_custom_hardware_message( desktop, req->win, origin, &req->input );
@@ -2900,6 +2901,7 @@ DECL_HANDLER(send_hardware_message)
         set_error( STATUS_INVALID_PARAMETER );
     }
 
+    reply->wait = sender ? wait : 0;
     reply->new_x = desktop->cursor.x;
     reply->new_y = desktop->cursor.y;
     release_object( desktop );
@@ -2795,8 +2821,6 @@ DECL_HANDLER(get_message)
     user_handle_t get_win = get_user_full_handle( req->get_win );
     unsigned int filter = req->flags >> 16;
 
-    reply->active_hooks = get_active_hooks();
-
     /* first check for internal messages */
     if (queue && get_queued_message( queue, 0, SEND_MESSAGE, 0, 0x80000000, 0xffffffff, PM_REMOVE, reply ))
         return;

From aff22319b2ff45f71b44ac1d93873e8206eacf93 Mon Sep 17 00:00:00 2001
From: Infinite Loop <teardown@inbox.ru>
Date: Wed, 6 Mar 2024 20:43:08 +0300
Subject: [PATCH] ntdll: Add stubs for Rtl*GenericTable*Avl functions

Those are required to stop Fortnite from crashing during runtime

Signed-off-by: Infinite Loop <teardown@inbox.ru>
---
 dlls/ntdll/ntdll.spec               | 10 +++---
 dlls/ntdll/rtl.c                    | 52 +++++++++++++++++++++++++++--
 dlls/ntoskrnl.exe/ntoskrnl.exe.spec | 10 +++---
 include/ddk/ntddk.h                 |  7 +++-
 4 files changed, 65 insertions(+), 14 deletions(-)

diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 014c221e59f..a40be4c7521 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -602,7 +602,7 @@
 @ stdcall RtlDeleteCriticalSection(ptr)
 @ stdcall -arch=!i386 RtlDeleteGrowableFunctionTable(ptr)
 @ stub RtlDeleteElementGenericTable
-@ stub RtlDeleteElementGenericTableAvl
+@ stdcall RtlDeleteElementGenericTableAvl(ptr ptr)
 @ cdecl -arch=!i386 RtlDeleteFunctionTable(ptr)
 @ stub RtlDeleteNoSplay
 @ stub RtlDeleteOwnersRanges
@@ -646,7 +646,7 @@
 @ stdcall RtlEnterCriticalSection(ptr)
 @ stub RtlEnumProcessHeaps
 @ stub RtlEnumerateGenericTable
-# @ stub RtlEnumerateGenericTableAvl
+@ stdcall RtlEnumerateGenericTableAvl(ptr long)
 # @ stub RtlEnumerateGenericTableLikeADirectory
 @ stdcall RtlEnumerateGenericTableWithoutSplaying(ptr ptr)
 # @ stub RtlEnumerateGenericTableWithoutSplayingAvl
@@ -725,7 +725,7 @@
 @ stdcall RtlGetCurrentTransaction()
 @ stdcall RtlGetDaclSecurityDescriptor(ptr ptr ptr ptr)
 @ stdcall RtlGetElementGenericTable(ptr long)
-# @ stub RtlGetElementGenericTableAvl
+@ stdcall RtlGetElementGenericTableAvl(ptr long)
 @ stdcall RtlGetEnabledExtendedFeatures(int64)
 @ stdcall RtlGetExePath(wstr ptr)
 @ stdcall RtlGetExtendedContextLength(long ptr)
@@ -876,7 +876,7 @@
 # @ stub RtlLogStackBackTrace
 @ stdcall RtlLookupAtomInAtomTable(ptr wstr ptr)
 @ stdcall RtlLookupElementGenericTable(ptr ptr)
-# @ stub RtlLookupElementGenericTableAvl
+@ stdcall RtlLookupElementGenericTableAvl(ptr ptr)
 @ stdcall -arch=!i386 RtlLookupFunctionEntry(long ptr ptr)
 @ stdcall -arch=!i386 RtlLookupFunctionTable(long ptr ptr)
 @ stdcall RtlMakeSelfRelativeSD(ptr ptr ptr)
@@ -898,7 +898,7 @@
 @ stdcall RtlNtStatusToDosError(long)
 @ stdcall RtlNtStatusToDosErrorNoTeb(long)
 @ stdcall RtlNumberGenericTableElements(ptr)
-# @ stub RtlNumberGenericTableElementsAvl
+@ stdcall RtlNumberGenericTableElementsAvl(ptr)
 @ stdcall RtlNumberOfClearBits(ptr)
 @ stdcall RtlNumberOfSetBits(ptr)
 @ stdcall RtlOemStringToUnicodeSize(ptr)
diff --git a/dlls/ntdll/rtl.c b/dlls/ntdll/rtl.c
index 3d482ec2f92..08b584a8dec 100644
--- a/dlls/ntdll/rtl.c
+++ b/dlls/ntdll/rtl.c
@@ -2164,15 +2164,61 @@ BOOLEAN WINAPI RtlIsProcessorFeaturePresent( UINT feature )
 void WINAPI RtlInitializeGenericTableAvl(PRTL_AVL_TABLE table, PRTL_AVL_COMPARE_ROUTINE compare,
                                          PRTL_AVL_ALLOCATE_ROUTINE allocate, PRTL_AVL_FREE_ROUTINE free, void *context)
 {
-    FIXME("%p %p %p %p %p: stub\n", table, compare, allocate, free, context);
+    FIXME("(%p, %p, %p, %p, %p): stub\n", table, compare, allocate, free, context);
 }
 
 /***********************************************************************
  *           RtlInsertElementGenericTableAvl  (NTDLL.@)
  */
-void WINAPI RtlInsertElementGenericTableAvl(PRTL_AVL_TABLE table, void *buffer, ULONG size, BOOL *element)
+void * WINAPI RtlInsertElementGenericTableAvl(PRTL_AVL_TABLE table, void *buffer, ULONG size, BOOLEAN *element)
 {
-    FIXME("%p %p %lu %p: stub\n", table, buffer, size, element);
+    FIXME("(%p, %p, %lu, %p): stub\n", table, buffer, size, element);
+    return NULL;
+}
+
+/***********************************************************************
+ *           RtlGetElementGenericTableAvl  (NTDLL.@)
+ */
+void * WINAPI RtlGetElementGenericTableAvl(PRTL_AVL_TABLE table, ULONG index)
+{
+    FIXME("(%p, %lu): stub\n", table, index);
+    return NULL;
+}
+
+/***********************************************************************
+ *           RtlLookupElementGenericTableAvl  (NTDLL.@)
+ */
+void * WINAPI RtlLookupElementGenericTableAvl(PRTL_AVL_TABLE table, void *buffer)
+{
+    FIXME("(%p, %p): stub\n", table, buffer);
+    return NULL;
+}
+
+/***********************************************************************
+ *           RtlDeleteElementGenericTableAvl  (NTDLL.@)
+ */
+BOOLEAN WINAPI RtlDeleteElementGenericTableAvl(PRTL_AVL_TABLE table, void *buffer)
+{
+    FIXME("(%p, %p): stub\n", table, buffer);
+    return FALSE;
+}
+
+/***********************************************************************
+ *           RtlEnumerateGenericTableAvl  (NTDLL.@)
+ */
+void * WINAPI RtlEnumerateGenericTableAvl(PRTL_AVL_TABLE table, BOOLEAN restart)
+{
+    FIXME("(%p, %s): stub\n", table, restart ? "TRUE" : "FALSE");
+    return NULL;
+}
+
+/***********************************************************************
+ *           RtlNumberGenericTableElementsAvl  (NTDLL.@)
+ */
+ULONG WINAPI RtlNumberGenericTableElementsAvl(PRTL_AVL_TABLE table)
+{
+    FIXME("(%p): stub\n", table);
+    return 0UL;
 }
 
 /*********************************************************************
diff --git a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
index 996777fd7fd..fefea530f84 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
+++ b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
@@ -1053,7 +1053,7 @@
 @ stdcall RtlDeleteAce(ptr long)
 @ stdcall RtlDeleteAtomFromAtomTable(ptr long)
 @ stub RtlDeleteElementGenericTable
-@ stub RtlDeleteElementGenericTableAvl
+@ stdcall RtlDeleteElementGenericTableAvl(ptr ptr)
 @ stub RtlDeleteNoSplay
 @ stub RtlDeleteOwnersRanges
 @ stub RtlDeleteRange
@@ -1069,7 +1069,7 @@
 @ stdcall -arch=win32 RtlEnlargedUnsignedDivide(int64 long ptr)
 @ stdcall -arch=win32 -ret64 RtlEnlargedUnsignedMultiply(long long)
 @ stub RtlEnumerateGenericTable
-@ stub RtlEnumerateGenericTableAvl
+@ stdcall RtlEnumerateGenericTableAvl(ptr long)
 @ stub RtlEnumerateGenericTableLikeADirectory
 @ stdcall RtlEnumerateGenericTableWithoutSplaying(ptr ptr)
 @ stub RtlEnumerateGenericTableWithoutSplayingAvl
@@ -1114,7 +1114,7 @@
 @ stdcall RtlGetDaclSecurityDescriptor(ptr ptr ptr ptr)
 @ stub RtlGetDefaultCodePage
 @ stdcall RtlGetElementGenericTable(ptr long)
-@ stub RtlGetElementGenericTableAvl
+@ stdcall RtlGetElementGenericTableAvl(ptr long)
 @ stdcall RtlGetExtendedContextLength(long ptr)
 @ stdcall RtlGetExtendedContextLength2(long ptr int64)
 @ stub RtlGetFirstRange
@@ -1199,7 +1199,7 @@
 @ stub RtlLockBootStatusData
 @ stdcall RtlLookupAtomInAtomTable(ptr wstr ptr)
 @ stdcall RtlLookupElementGenericTable(ptr ptr)
-@ stub RtlLookupElementGenericTableAvl
+@ stdcall RtlLookupElementGenericTableAvl(ptr ptr)
 @ stub RtlLookupElementGenericTableFull
 @ stub RtlLookupElementGenericTableFullAvl
 @ stdcall -arch=!i386 RtlLookupFunctionEntry(long ptr ptr)
@@ -1214,7 +1214,7 @@
 @ stdcall RtlNtStatusToDosError(long)
 @ stdcall RtlNtStatusToDosErrorNoTeb(long)
 @ stdcall RtlNumberGenericTableElements(ptr)
-@ stub RtlNumberGenericTableElementsAvl
+@ stdcall RtlNumberGenericTableElementsAvl(ptr)
 @ stdcall RtlNumberOfClearBits(ptr)
 @ stdcall RtlNumberOfSetBits(ptr)
 @ stub RtlOemStringToCountedUnicodeString
diff --git a/include/ddk/ntddk.h b/include/ddk/ntddk.h
index c705958e147..45933dc6eb2 100644
--- a/include/ddk/ntddk.h
+++ b/include/ddk/ntddk.h
@@ -278,7 +278,12 @@ BOOLEAN   WINAPI RtlEqualString(const STRING*,const STRING*,BOOLEAN);
 void *    WINAPI RtlGetElementGenericTable(PRTL_GENERIC_TABLE,ULONG);
 void      WINAPI RtlInitializeGenericTable(PRTL_GENERIC_TABLE,PRTL_GENERIC_COMPARE_ROUTINE,PRTL_GENERIC_ALLOCATE_ROUTINE,PRTL_GENERIC_FREE_ROUTINE,void *);
 void      WINAPI RtlInitializeGenericTableAvl(PRTL_AVL_TABLE,PRTL_AVL_COMPARE_ROUTINE,PRTL_AVL_ALLOCATE_ROUTINE, PRTL_AVL_FREE_ROUTINE,void *);
-void      WINAPI RtlInsertElementGenericTableAvl(PRTL_AVL_TABLE,void *,ULONG,BOOL*);
+void *    WINAPI RtlInsertElementGenericTableAvl(PRTL_AVL_TABLE,void *,ULONG,BOOLEAN*);
+void *    WINAPI RtlGetElementGenericTableAvl(PRTL_AVL_TABLE,ULONG);
+void *    WINAPI RtlLookupElementGenericTableAvl(PRTL_AVL_TABLE,void *);
+BOOLEAN   WINAPI RtlDeleteElementGenericTableAvl(PRTL_AVL_TABLE,void *);
+void *    WINAPI RtlEnumerateGenericTableAvl(PRTL_AVL_TABLE,BOOLEAN);
+ULONG     WINAPI RtlNumberGenericTableElementsAvl(PRTL_AVL_TABLE);
 void *    WINAPI RtlLookupElementGenericTable(PRTL_GENERIC_TABLE,void *);
 void      WINAPI RtlMapGenericMask(ACCESS_MASK*,const GENERIC_MAPPING*);
 ULONG     WINAPI RtlNumberGenericTableElements(PRTL_GENERIC_TABLE);
-- 
GitLab

From deb273a92669435214051ffa7d360b174e90ced7 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 12 Apr 2024 15:20:17 -0600
Subject: [PATCH] ntdll: Implement
 NtQuerySystemInformation(SystemProcessIdInformation).

---
 dlls/ntdll/tests/info.c        | 129 +++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/system.c       |  39 ++++++++++
 dlls/wow64/struct32.h          |   6 ++
 dlls/wow64/system.c            |  18 +++++
 include/wine/server_protocol.h |   4 +-
 include/winternl.h             |   6 ++
 server/process.c               |   5 +-
 server/protocol.def            |   1 +
 server/request.h               |   3 +-
 server/trace.c                 |   1 +
 10 files changed, 208 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index 15c4a49e611..6e240e38cad 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -3289,6 +3289,45 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
         break;
     }
 
+    case SystemProcessIdInformation: /* 88 */
+    {
+        SYSTEM_PROCESS_ID_INFORMATION *id = info;
+        UNICODE_STRING *str = &id->ImageName;
+        ULONG name_len = 0;
+        void *buffer;
+
+        len = sizeof(*id);
+        if (ret_size) *ret_size = len;
+
+        if (len > size)                ret = STATUS_INFO_LENGTH_MISMATCH;
+        else if (id->ImageName.Length) ret = STATUS_INVALID_PARAMETER;
+        else if (!id->ProcessId)       ret = STATUS_INVALID_CID;
+
+        if (ret) return ret;
+
+        buffer = malloc( str->MaximumLength );
+        SERVER_START_REQ( get_process_image_name )
+        {
+            req->pid = id->ProcessId;
+            wine_server_set_reply( req, buffer, str->MaximumLength );
+            ret = wine_server_call( req );
+            name_len = reply->len;
+        }
+        SERVER_END_REQ;
+
+        if (ret == STATUS_BUFFER_TOO_SMALL) ret = STATUS_INFO_LENGTH_MISMATCH;
+        if (!ret && name_len + sizeof(WCHAR) > str->MaximumLength) ret = STATUS_INFO_LENGTH_MISMATCH;
+        if (!ret || ret == STATUS_INFO_LENGTH_MISMATCH) str->MaximumLength = name_len + sizeof(WCHAR);
+        if (!ret)
+        {
+            str->Length = name_len;
+            memcpy( str->Buffer, buffer, str->Length );
+            str->Buffer[str->Length / sizeof(WCHAR)] = 0;
+        }
+        free( buffer );
+        return ret;
+    }
+
     case SystemDynamicTimeZoneInformation:  /* 102 */
     {
         RTL_DYNAMIC_TIME_ZONE_INFORMATION tz;
diff --git a/dlls/wow64/struct32.h b/dlls/wow64/struct32.h
index 9535fba3a84..87e219045f4 100644
--- a/dlls/wow64/struct32.h
+++ b/dlls/wow64/struct32.h
@@ -524,6 +524,12 @@ typedef struct
     ULONG Flags;
 } SYSTEM_CACHE_INFORMATION32;
 
+typedef struct
+{
+    ULONG ProcessId;
+    UNICODE_STRING32 ImageName;
+} SYSTEM_PROCESS_ID_INFORMATION32;
+
 typedef struct
 {
     ULONG  OwnerPid;
diff --git a/dlls/wow64/system.c b/dlls/wow64/system.c
index b2c8eec8769..6e78c462984 100644
--- a/dlls/wow64/system.c
+++ b/dlls/wow64/system.c
@@ -406,6 +406,24 @@ NTSTATUS WINAPI wow64_NtQuerySystemInformation( UINT *args )
         }
         return status;
 
+    case SystemProcessIdInformation:  /* SYSTEM_PROCESS_ID_INFORMATION */
+    {
+        SYSTEM_PROCESS_ID_INFORMATION32 *info32 = ptr;
+        SYSTEM_PROCESS_ID_INFORMATION info;
+
+        if (retlen) *retlen = sizeof(*info32);
+        if (len < sizeof(*info32)) return STATUS_INFO_LENGTH_MISMATCH;
+
+        info.ProcessId = info32->ProcessId;
+        unicode_str_32to64( &info.ImageName, &info32->ImageName );
+        if (!(status = NtQuerySystemInformation( class, &info, sizeof(info), NULL )))
+        {
+            info32->ImageName.MaximumLength = info.ImageName.MaximumLength;
+            info32->ImageName.Length = info.ImageName.Length;
+        }
+        return status;
+    }
+
     case SystemHandleInformation:  /* SYSTEM_HANDLE_INFORMATION */
         if (len >= sizeof(SYSTEM_HANDLE_INFORMATION32))
         {
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index cd9ff143e12..48e778ce07f 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -1089,8 +1089,8 @@ struct get_process_image_name_request
 {
     struct request_header __header;
     obj_handle_t handle;
+    process_id_t pid;
     int          win32;
-    char __pad_20[4];
 };
 struct get_process_image_name_reply
 {
diff --git a/include/winternl.h b/include/winternl.h
index 5b897b0276c..22cdceeaedb 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -3023,6 +3023,12 @@ typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION
     UCHAR TableBuffer[1];
 } SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;
 
+typedef struct _SYSTEM_PROCESS_ID_INFORMATION
+{
+    ULONG_PTR ProcessId;
+    UNICODE_STRING ImageName;
+} SYSTEM_PROCESS_ID_INFORMATION, *PSYSTEM_PROCESS_ID_INFORMATION;
+
 typedef struct _TIME_FIELDS
 {   CSHORT Year;
     CSHORT Month;
diff --git a/server/process.c b/server/process.c
index b7c7df38e44..f6d1641cb94 100644
--- a/server/process.c
+++ b/server/process.c
@@ -1512,7 +1512,10 @@ DECL_HANDLER(get_process_debug_info)
 /* fetch the name of the process image */
 DECL_HANDLER(get_process_image_name)
 {
-    struct process *process = get_process_from_handle( req->handle, PROCESS_QUERY_LIMITED_INFORMATION );
+    struct process *process;
+
+    if (req->pid) process = get_process_from_id( req->pid );
+    else          process = get_process_from_handle( req->handle, PROCESS_QUERY_LIMITED_INFORMATION );
 
     if (!process) return;
     if (process->image)
diff --git a/server/protocol.def b/server/protocol.def
index 69b8db3ebef..f6d644d6182 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1034,6 +1034,7 @@ typedef struct
 /* Fetch the name of the process image */
 @REQ(get_process_image_name)
     obj_handle_t handle;           /* process handle */
+    process_id_t pid;              /* process id */
     int          win32;            /* return a win32 filename? */
 @REPLY
     data_size_t  len;              /* len in bytes required to store filename */
diff --git a/server/request.h b/server/request.h
index c5e9f69cc8a..5e85e31de45 100644
--- a/server/request.h
+++ b/server/request.h
@@ -831,7 +831,8 @@ C_ASSERT( FIELD_OFFSET(struct get_process_debug_info_reply, debug) == 8 );
 C_ASSERT( FIELD_OFFSET(struct get_process_debug_info_reply, debug_children) == 12 );
 C_ASSERT( sizeof(struct get_process_debug_info_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_process_image_name_request, handle) == 12 );
-C_ASSERT( FIELD_OFFSET(struct get_process_image_name_request, win32) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_process_image_name_request, pid) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_process_image_name_request, win32) == 20 );
 C_ASSERT( sizeof(struct get_process_image_name_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct get_process_image_name_reply, len) == 8 );
 C_ASSERT( sizeof(struct get_process_image_name_reply) == 16 );
diff --git a/server/trace.c b/server/trace.c
index b254a96f7a4..d76d13152aa 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -1543,6 +1543,7 @@ static void dump_get_process_debug_info_reply( const struct get_process_debug_in
 static void dump_get_process_image_name_request( const struct get_process_image_name_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", pid=%04x", req->pid );
     fprintf( stderr, ", win32=%d", req->win32 );
 }
 
-- 
GitLab

From 0bfa27bdb256faf411e86d4bbd54dedcd3225157 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 13 Mar 2024 18:44:31 -0600
Subject: [PATCH] ntdll: Wait for thread suspension in NtSuspendThread().

CW-Bug-Id: #23552
---
 dlls/ntdll/unix/thread.c | 26 ++++++++++++++++++++++----
 server/protocol.def      |  6 ++++--
 server/thread.c          | 28 ++++++++++++++++++++++++----
 3 files changed, 50 insertions(+), 10 deletions(-)

diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 64cad6e7c0e..c69d3de3e15 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -1611,22 +1611,40 @@ NTSTATUS WINAPI NtOpenThread( HANDLE *handle, ACCESS_MASK access,
 /******************************************************************************
  *              NtSuspendThread   (NTDLL.@)
  */
-NTSTATUS WINAPI NtSuspendThread( HANDLE handle, ULONG *count )
+NTSTATUS WINAPI NtSuspendThread( HANDLE handle, ULONG *ret_count )
 {
     BOOL self = FALSE;
-    unsigned int ret;
+    unsigned int ret, count = 0;
+    HANDLE wait_handle = NULL;
 
     SERVER_START_REQ( suspend_thread )
     {
         req->handle = wine_server_obj_handle( handle );
-        if (!(ret = wine_server_call( req )))
+        if (!(ret = wine_server_call( req )) || ret == STATUS_PENDING)
         {
             self = reply->count & 0x80000000;
-            if (count) *count = reply->count & 0x7fffffff;
+            count = reply->count & 0x7fffffff;;
+            wait_handle = wine_server_ptr_handle( reply->wait_handle );
         }
     }
     SERVER_END_REQ;
+
     if (self) usleep( 0 );
+
+    if (ret == STATUS_PENDING && wait_handle)
+    {
+        NtWaitForSingleObject( wait_handle, FALSE, NULL );
+
+        SERVER_START_REQ( suspend_thread )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            req->waited_handle = wine_server_obj_handle( wait_handle );
+            ret = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+    }
+
+    if (!ret && ret_count) *ret_count = count;
     return ret;
 }
 
diff --git a/server/protocol.def b/server/protocol.def
index 848afbcc19c..a223b4f4665 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1182,9 +1182,11 @@ typedef volatile struct input_shared_memory input_shm_t;
 
 /* Suspend a thread */
 @REQ(suspend_thread)
-    obj_handle_t handle;       /* thread handle */
+    obj_handle_t handle;        /* thread handle */
+    obj_handle_t waited_handle; /* handle waited on */
 @REPLY
-    int          count;        /* new suspend count */
+    int          count;         /* new suspend count */
+    obj_handle_t wait_handle;   /* handle to wait on */
 @END
 
 
diff --git a/server/thread.c b/server/thread.c
index a6039b35d9d..e54e83c178a 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -1815,12 +1815,32 @@ DECL_HANDLER(suspend_thread)
 {
     struct thread *thread;
 
-    if ((thread = get_thread_from_handle( req->handle, THREAD_SUSPEND_RESUME )))
+    if (req->waited_handle)
     {
-        if (thread->state == TERMINATED) set_error( STATUS_ACCESS_DENIED );
-        else reply->count = suspend_thread( thread );
-        release_object( thread );
+        struct context *context;
+
+        if (!(context = (struct context *)get_handle_obj( current->process, req->waited_handle,
+                                                          0, &context_ops )))
+            return;
+        close_handle( current->process, req->waited_handle ); /* avoid extra server call */
+        set_error( context->status );
+        release_object( context );
+        return;
     }
+
+    if (!(thread = get_thread_from_handle( req->handle, THREAD_SUSPEND_RESUME ))) return;
+
+    if (thread->state != RUNNING) set_error( STATUS_ACCESS_DENIED );
+    else
+    {
+        reply->count = suspend_thread( thread );
+        if (!get_error() && thread != current && thread->context && thread->context->status == STATUS_PENDING)
+        {
+            set_error( STATUS_PENDING );
+            reply->wait_handle = alloc_handle( current->process, thread->context, SYNCHRONIZE, 0 );
+        }
+    }
+    release_object( thread );
 }
 
 /* resume a thread */

From 20d7c6d6e0c2ad95b3dcec9b054893e888023c5d Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 3 May 2023 17:23:40 -0600
Subject: [PATCH] ntdll: Do not inherit Unix std handles for files without a
 name.

CW-Bug-Id: #22237
---
 dlls/ntdll/unix/env.c | 27 ++++++++++++++++++++++++---
 1 file changed, 24 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
index ff3f28d93e1..29f5aa2b17f 100644
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -1394,6 +1394,27 @@ static void add_registry_environment( WCHAR **env, SIZE_T *pos, SIZE_T *size )
     }
 }
 
+static void get_std_handle( int fd, unsigned int access, unsigned int attributes, HANDLE *handle )
+{
+    IO_STATUS_BLOCK io;
+    FILE_POSITION_INFORMATION pos_info;
+    FILE_NAME_INFORMATION name_info;
+    NTSTATUS status;
+
+    wine_server_fd_to_handle( fd, access, attributes, handle );
+    if (!*handle) return;
+
+    /* Python checks if a file is seekable and if so expects the file name to be gettable from handle. */
+    if (NtQueryInformationFile( *handle, &io, &pos_info, sizeof(pos_info), FilePositionInformation ))
+        return;
+
+    TRACE("handle for fd %d is seekable.\n", fd);
+    if (!(status = NtQueryInformationFile( *handle, &io, &name_info, sizeof(name_info), FileNameInformation ))
+          || status == STATUS_BUFFER_OVERFLOW) return;
+    TRACE("closing handle for fd %d.\n", fd);
+    NtClose( *handle );
+    *handle = NULL;
+}
 
 /*************************************************************************
  *		get_initial_console
@@ -1404,9 +1425,9 @@ static void get_initial_console( RTL_USER_PROCESS_PARAMETERS *params )
 {
     int output_fd = -1;
 
-    wine_server_fd_to_handle( 0, GENERIC_READ|SYNCHRONIZE,  OBJ_INHERIT, &params->hStdInput );
-    wine_server_fd_to_handle( 1, GENERIC_WRITE|SYNCHRONIZE, OBJ_INHERIT, &params->hStdOutput );
-    wine_server_fd_to_handle( 2, GENERIC_WRITE|SYNCHRONIZE, OBJ_INHERIT, &params->hStdError );
+    get_std_handle( 0, GENERIC_READ|SYNCHRONIZE,  OBJ_INHERIT, &params->hStdInput );
+    get_std_handle( 1, GENERIC_WRITE|SYNCHRONIZE, OBJ_INHERIT, &params->hStdOutput );
+    get_std_handle( 2, GENERIC_WRITE|SYNCHRONIZE, OBJ_INHERIT, &params->hStdError );
 
     if (main_image_info.SubSystemType != IMAGE_SUBSYSTEM_WINDOWS_CUI)
         return;

From ae659100f551f1e0d8b02781d51b3a4266595fec Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 13 Jul 2020 10:21:49 -0500
Subject: [PATCH] ntdll: Handle NULL object name buffer in
 nt_to_unix_file_name_attr().

CW-Bug-Id: #17864
---
 dlls/ntdll/tests/file.c | 22 +++++++++++++++++++++-
 dlls/ntdll/unix/file.c  |  5 ++++-
 2 files changed, 25 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index ddea0e994cc..367cc6763cd 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -4475,7 +4475,7 @@ static NTSTATUS nt_to_unix_file_name_no_
     name     = nameW->Buffer;
     name_len = nameW->Length / sizeof(WCHAR);
 
-    if (!name_len || name[0] != '\\') return STATUS_OBJECT_PATH_SYNTAX_BAD;
+    if (!name || !name_len || name[0] != '\\') return STATUS_OBJECT_PATH_SYNTAX_BAD;
 
     if (!(pos = get_dos_prefix_len( nameW )))
         return STATUS_BAD_DEVICE_TYPE;  /* no DOS prefix, assume NT native name */
@@ -4589,6 +4589,9 @@ NTSTATUS nt_to_unix_file_name_internal(
     int name_len, unix_len;
     NTSTATUS status;
 
+    if (!attr->ObjectName->Buffer && attr->ObjectName->Length)
+        return STATUS_ACCESS_VIOLATION;
+
     fileobj.FileName = *attr->ObjectName;
 reparse:
     if (reparse_count++ == 31)

From 83e30e835c2099d9b9ab2e4e704ad64efd2f6cb7 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 26 Jun 2020 15:26:53 +0300
Subject: [PATCH] Avoid undefined result in ntdll_wcstoumbs() in case of error.

CW-Bug-Id: #17864

Undefined result is due to RtlUnicodeToUTF8N() not setting output
length on error which is a correct behaviour according to
existing tests.

'Planet Zoo' is affected which passes NULL object name buffer to
NtCreateFile().

Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
---
 dlls/ntdll/unix/env.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
index 9b7c4ea2cd9..ff3f28d93e1 100644
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -399,7 +399,7 @@ DWORD ntdll_umbstowcs( const char *src, DWORD srclen, WCHAR *dst, DWORD dstlen )
  */
 int ntdll_wcstoumbs( const WCHAR *src, DWORD srclen, char *dst, DWORD dstlen, BOOL strict )
 {
-    unsigned int i, reslen;
+    unsigned int i, reslen = 0;
 
     if (unix_cp.CodePage != CP_UTF8)
     {

From 9ec501141e153aa01bcd6e4ce3846d1a4f786d51 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 4 Jun 2024 22:40:46 +0200
Subject: [PATCH] server: Avoid calling set_event from within
 msg_queue_add_queue.

---
 server/queue.c  | 10 ++++++++--
 server/thread.c |  8 ++++++--
 server/user.h   |  1 +
 3 files changed, 15 insertions(+), 4 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index e881e40271d..7a1a8b6ece6 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -1098,7 +1098,6 @@ static int is_queue_hung( struct msg_queue *queue )
 static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry )
 {
     struct msg_queue *queue = (struct msg_queue *)obj;
-    struct process *process = get_wait_queue_thread(entry)->process;
 
     /* a thread can only wait on its own queue */
     if (get_wait_queue_thread(entry)->queue != queue)
@@ -1106,7 +1105,6 @@ static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *ent
         set_error( STATUS_ACCESS_DENIED );
         return 0;
     }
-    if (process->idle_event && !(queue->wake_mask & QS_SMRESULT)) set_event( process->idle_event );
 
     if (queue->fd && list_empty( &obj->wait_queue ))  /* first on the queue */
         set_fd_events( queue->fd, POLLIN );
@@ -1255,6 +1253,14 @@ static int check_queue_input_window( struct msg_queue *queue, user_handle_t wind
     return ret;
 }
 
+/* check if the thread queue is idle and set the process idle event if so */
+void check_thread_queue_idle( struct thread *thread )
+{
+    struct msg_queue *queue = thread->queue;
+    if ((queue->wake_mask & QS_SMRESULT)) return;
+    if (thread->process->idle_event) set_event( thread->process->idle_event );
+}
+
 /* make sure the specified thread has a queue */
 int init_thread_queue( struct thread *thread )
 {
diff --git a/server/thread.c b/server/thread.c
index 55bd63d3030..6542e1584ab 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -778,7 +778,7 @@ static int wait_on( const select_op_t *select_op, unsigned int count, struct obj
 {
     struct thread_wait *wait;
     struct wait_queue_entry *entry;
-    unsigned int i;
+    unsigned int i, idle = 0;
 
     if (!(wait = mem_alloc( FIELD_OFFSET(struct thread_wait, queues[count]) ))) return 0;
     wait->next    = current->wait;
@@ -802,8 +802,12 @@ static int wait_on( const select_op_t *select_op, unsigned int count, struct obj
             end_wait( current, get_error() );
             return 0;
         }
+
+        if (obj == (struct object *)current->queue) idle = 1;
     }
-    return 1;
+
+    if (idle) check_thread_queue_idle( current );
+    return current->wait ? 1 : 0;
 }
 
 static int wait_on_handles( const select_op_t *select_op, unsigned int count, const obj_handle_t *handles,
diff --git a/server/user.h b/server/user.h
index d805a179d16..703a55d5009 100644
--- a/server/user.h
+++ b/server/user.h
@@ -113,6 +113,7 @@ extern void set_queue_hooks( struct thread *thread, struct hook_table *hooks );
 extern void inc_queue_paint_count( struct thread *thread, int incr );
 extern void queue_cleanup_window( struct thread *thread, user_handle_t win );
 extern int init_thread_queue( struct thread *thread );
+extern void check_thread_queue_idle( struct thread *thread );
 extern int attach_thread_input( struct thread *thread_from, struct thread *thread_to );
 extern void detach_thread_input( struct thread *thread_from );
 extern void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect,
-- 
GitLab

From c4c30d4615e0f991ce38d53cf71bc63f4df50a3f Mon Sep 17 00:00:00 2001
From: Dmitry Timoshkov <dmitry@baikal.ru>
Date: Tue, 4 Jun 2024 16:17:24 +0300
Subject: [PATCH] server: Remove limitation for waiting on idle_event of the
 current process.

Signed-off-by: Dmitry Timoshkov <dmitry@baikal.ru>
---
 server/process.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/process.c b/server/process.c
index f6d1641cb94..733b0288f72 100644
--- a/server/process.c
+++ b/server/process.c
@@ -1686,7 +1686,7 @@ DECL_HANDLER(get_process_idle_event)
     reply->event = 0;
     if ((process = get_process_from_handle( req->handle, PROCESS_QUERY_INFORMATION )))
     {
-        if (process->idle_event && process != current->process)
+        if (process->idle_event)
             reply->event = alloc_handle( current->process, process->idle_event,
                                          EVENT_ALL_ACCESS, 0 );
         release_object( process );
-- 
GitLab

From 8dbda2116167c42ba8a35b8abd28731576d37fc4 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Thu, 16 May 2024 21:27:08 -0600
Subject: [PATCH] ntdll: Fill object pointer in NtQueryInformation(
 SystemHandleInformation / SystemExtendedHandleInformation ).

CW-Bug-Id: #23813
---
 dlls/ntdll/tests/info.c  | 37 +++++++++++++++++++++++++++++++------
 dlls/ntdll/unix/system.c |  4 ++--
 server/handle.c          |  1 +
 server/protocol.def      |  2 ++
 tools/make_requests      |  2 +-
 5 files changed, 37 insertions(+), 9 deletions(-)

diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index 0e77e7d7b14..3ca2e88447b 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -3188,7 +3188,7 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
                     shi->Handle[i].AccessMask   = handle_info[i].access;
                     shi->Handle[i].HandleFlags  = handle_info[i].attributes;
                     shi->Handle[i].ObjectType   = handle_info[i].type;
-                    /* FIXME: Fill out ObjectPointer */
+                    shi->Handle[i].ObjectPointer = wine_server_get_ptr( handle_info[i].object );
                 }
             }
             else if (ret == STATUS_BUFFER_TOO_SMALL)
@@ -3409,7 +3409,7 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
                     shi->Handles[i].GrantedAccess    = handle_info[i].access;
                     shi->Handles[i].HandleAttributes = handle_info[i].attributes;
                     shi->Handles[i].ObjectTypeIndex  = handle_info[i].type;
-                    /* FIXME: Fill out Object */
+                    shi->Handles[i].Object           = wine_server_get_ptr( handle_info[i].object );
                 }
             }
             else if (ret == STATUS_BUFFER_TOO_SMALL)
diff --git a/server/handle.c b/server/handle.c
index 48b5d8101bb..79c0f3f0dff 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -855,6 +855,7 @@ static int enum_handles( struct process *process, void *user )
         handle->access     = entry->access & ~RESERVED_ALL;
         handle->type       = entry->ptr->ops->type->index;
         handle->attributes = 0;
+        handle->object     = (client_ptr_t)(ULONG_PTR)entry->ptr | (client_ptr_t)0xffff800000000000;
         if (entry->access & RESERVED_INHERIT) handle->attributes |= OBJ_INHERIT;
         if (entry->access & RESERVED_CLOSE_PROTECT) handle->attributes |= OBJ_PROTECT_CLOSE;
         info->count--;
diff --git a/server/protocol.def b/server/protocol.def
index d611701e0ab..302563cbe66 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -3459,11 +3459,13 @@ enum caret_state
 
 struct handle_info
 {
+    client_ptr_t object;
     process_id_t owner;
     obj_handle_t handle;
     unsigned int access;
     unsigned int attributes;
     unsigned int type;
+    unsigned int __pad;
 };
 
 /* Return a list of all opened handles */
diff --git a/tools/make_requests b/tools/make_requests
index b450e22c2b8..9dc259b9e94 100755
--- a/tools/make_requests
+++ b/tools/make_requests
@@ -64,7 +64,7 @@ my %formats =
     "startup_info_t"           => [  96,  4 ],
     "user_apc_t"               => [  40,  8 ],
     "struct filesystem_event"  => [ 12, 4 ],
-    "struct handle_info"       => [ 20, 4 ],
+    "struct handle_info"       => [ 32, 8 ],
     "struct luid_attr"         => [ 12, 4 ],
     "struct object_attributes" => [ 16, 4 ],
     "struct object_type_info"  => [ 44, 4 ],

From 09edd1391979bf41fe6c99f34488823cef0280a6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Pawe=C5=82=20Ulita?= <pawelulita@fastmail.com>
Date: Sun, 12 Nov 2023 15:21:27 +0100
Subject: [PATCH] user32: Add stubs for GetWindowDpiHostingBehavior and
 SetThreadDpiHostingBehavior.

This prevents Native Instruments Kontakt 7 from crashing on start-up.
---
 dlls/user32/sysparams.c |  9 +++++++++
 dlls/user32/user32.spec |  2 ++
 dlls/user32/win.c       | 10 ++++++++++
 include/windef.h        |  6 ++++++
 include/winuser.h       |  2 ++
 5 files changed, 29 insertions(+)

diff --git a/dlls/user32/sysparams.c b/dlls/user32/sysparams.c
index 5ededfee62a..bc78c1fef88 100644
--- a/dlls/user32/sysparams.c
+++ b/dlls/user32/sysparams.c
@@ -746,6 +746,15 @@ DPI_AWARENESS_CONTEXT WINAPI SetThreadDpiAwarenessContext( DPI_AWARENESS_CONTEXT
     return ULongToHandle( prev );
 }
 
+/**********************************************************************
+ *              SetThreadDpiHostingBehavior   (USER32.@)
+ */
+DPI_HOSTING_BEHAVIOR WINAPI SetThreadDpiHostingBehavior( DPI_HOSTING_BEHAVIOR value )
+{
+    FIXME("(%d): stub\n", value);
+    return DPI_HOSTING_BEHAVIOR_DEFAULT;
+}
+
 /***********************************************************************
  *		MonitorFromRect (USER32.@)
  */
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index 96e6e1a7d6b..9f9f03041b4 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -410,6 +410,7 @@
 @ stdcall GetWindowDC(long) NtUserGetWindowDC
 @ stdcall GetWindowDisplayAffinity(long ptr)
 @ stdcall GetWindowDpiAwarenessContext(long)
+@ stdcall GetWindowDpiHostingBehavior(long)
 @ stdcall GetWindowInfo(long ptr)
 @ stdcall GetWindowLongA(long long)
 @ stdcall -arch=win64 GetWindowLongPtrA(long long)
@@ -719,6 +720,7 @@
 @ stdcall SetTaskmanWindow (long)
 @ stdcall SetThreadDesktop(long) NtUserSetThreadDesktop
 @ stdcall SetThreadDpiAwarenessContext(ptr)
+@ stdcall SetThreadDpiHostingBehavior(ptr)
 @ stdcall SetTimer(long long long ptr)
 @ stdcall SetUserObjectInformationA(long long ptr long)
 @ stdcall SetUserObjectInformationW(long long ptr long) NtUserSetObjectInformation
diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 6459ddf9f28..b8c04047333 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -616,6 +616,16 @@ DPI_AWARENESS_CONTEXT WINAPI GetWindowDpiAwarenessContext( HWND hwnd )
 }
 
 
+/***********************************************************************
+ *		GetWindowDpiHostingBehavior  (USER32.@)
+ */
+DPI_HOSTING_BEHAVIOR WINAPI GetWindowDpiHostingBehavior( HWND hwnd )
+{
+    FIXME("(%p): stub\n", hwnd);
+    return DPI_HOSTING_BEHAVIOR_DEFAULT;
+}
+
+
 static LONG_PTR get_window_long_ptr( HWND hwnd, int offset, LONG_PTR ret, BOOL ansi )
 {
     if (offset == DWLP_DLGPROC && NtUserGetDialogInfo( hwnd ))
diff --git a/include/windef.h b/include/windef.h
index b22e15c4dbf..78e4f56052c 100644
--- a/include/windef.h
+++ b/include/windef.h
@@ -439,4 +439,10 @@ typedef enum DPI_AWARENESS
 }
 #endif
 
+typedef enum {
+  DPI_HOSTING_BEHAVIOR_INVALID = -1,
+  DPI_HOSTING_BEHAVIOR_DEFAULT = 0,
+  DPI_HOSTING_BEHAVIOR_MIXED = 1
+} DPI_HOSTING_BEHAVIOR;
+
 #endif /* _WINDEF_ */
diff --git a/include/winuser.h b/include/winuser.h
index 73e7919aaea..ee0f05e1cb8 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -4296,6 +4296,7 @@ WINUSERAPI DWORD       WINAPI GetWindowContextHelpId(HWND);
 WINUSERAPI HDC         WINAPI GetWindowDC(HWND);
 WINUSERAPI BOOL        WINAPI GetWindowDisplayAffinity(HWND,DWORD*);
 WINUSERAPI DPI_AWARENESS_CONTEXT WINAPI GetWindowDpiAwarenessContext(HWND);
+WINUSERAPI DPI_HOSTING_BEHAVIOR WINAPI GetWindowDpiHostingBehavior(HWND);
 WINUSERAPI BOOL        WINAPI GetWindowFeedbackSetting(HWND,FEEDBACK_TYPE,DWORD,UINT32*,void*);
 WINUSERAPI BOOL        WINAPI GetWindowInfo(HWND, PWINDOWINFO);
 WINUSERAPI LONG        WINAPI GetWindowLongA(HWND,INT);
@@ -4608,6 +4609,7 @@ WINUSERAPI BOOL        WINAPI SetSystemMenu(HWND,HMENU);
 WINUSERAPI UINT_PTR    WINAPI SetSystemTimer(HWND,UINT_PTR,UINT,void*);
 WINUSERAPI BOOL        WINAPI SetThreadDesktop(HDESK);
 WINUSERAPI DPI_AWARENESS_CONTEXT WINAPI SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT);
+WINUSERAPI DPI_HOSTING_BEHAVIOR WINAPI SetThreadDpiHostingBehavior(DPI_HOSTING_BEHAVIOR);
 WINUSERAPI UINT_PTR    WINAPI SetTimer(HWND,UINT_PTR,UINT,TIMERPROC);
 WINUSERAPI BOOL        WINAPI SetUserObjectInformationA(HANDLE,INT,LPVOID,DWORD);
 WINUSERAPI BOOL        WINAPI SetUserObjectInformationW(HANDLE,INT,LPVOID,DWORD);
-- 
GitLab

From 35de72453c4e60876c8ff79280982efd50aeb681 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 28 May 2024 18:12:14 -0500
Subject: [PATCH] ntdll: Move IOCTL_SERIAL_WAIT_ON_MASK to the server.

Tested with a serial pair with a null modem.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=55947
---
 dlls/ntdll/unix/serial.c | 225 +++++++++++++++++----------------------
 server/serial.c          |  49 +++++++++
 2 files changed, 149 insertions(+), 125 deletions(-)

diff --git a/dlls/ntdll/unix/serial.c b/dlls/ntdll/unix/serial.c
index bb8d52cc627..d73ece47d0b 100644
--- a/dlls/ntdll/unix/serial.c
+++ b/dlls/ntdll/unix/serial.c
@@ -979,10 +979,8 @@ typedef struct serial_irq_info
  */
 typedef struct async_commio
 {
-    HANDLE              hDevice;
+    struct async_fileio io;
     DWORD*              events;
-    client_ptr_t        iosb;
-    HANDLE              hEvent;
     UINT                evtmask;
     UINT                cookie;
     UINT                mstat;
@@ -1083,84 +1081,87 @@ static DWORD check_events(int fd, UINT mask,
     return ret & mask;
 }
 
-/***********************************************************************
- *             wait_for_event      (INTERNAL)
- *
- *  We need to poll for what is interesting
- *  TIOCMIWAIT only checks modem status line and may not be aborted by a changing mask
- *
- */
-static void CALLBACK wait_for_event(LPVOID arg)
+static BOOL async_wait_proc( void *user, ULONG_PTR *info, unsigned int *status )
 {
-    async_commio *commio = arg;
+    async_commio *commio = user;
     int fd, needs_close;
 
-    if (!server_get_unix_fd( commio->hDevice, FILE_READ_DATA | FILE_WRITE_DATA, &fd, &needs_close, NULL, NULL ))
+    if (*status != STATUS_ALERTED)
+    {
+        release_fileio( &commio->io );
+        return TRUE;
+    }
+
+    if (!server_get_unix_fd( commio->io.handle, FILE_READ_DATA | FILE_WRITE_DATA, &fd, &needs_close, NULL, NULL ))
     {
         serial_irq_info new_irq_info;
         UINT new_mstat, dummy, cookie;
-        LARGE_INTEGER time;
 
-        TRACE("device=%p fd=0x%08x mask=0x%08x buffer=%p event=%p irq_info=%p\n",
-              commio->hDevice, fd, commio->evtmask, commio->events, commio->hEvent, &commio->irq_info);
+        TRACE( "device=%p fd=0x%08x mask=0x%08x buffer=%p irq_info=%p\n",
+               commio->io.handle, fd, commio->evtmask, commio->events, &commio->irq_info );
 
-        time.QuadPart = (ULONGLONG)10000;
-        time.QuadPart = -time.QuadPart;
-        for (;;)
+        /*
+         * FIXME:
+         * We don't handle the EV_RXFLAG (the eventchar)
+         */
+        get_irq_info(fd, &new_irq_info);
+        if (get_modem_status(fd, &new_mstat))
+        {
+            TRACE("get_modem_status failed\n");
+            *commio->events = 0;
+            *status = STATUS_CANCELLED;
+            *info = 0;
+        }
+        else
         {
-            /*
-             * TIOCMIWAIT is not adequate
-             *
-             * FIXME:
-             * We don't handle the EV_RXFLAG (the eventchar)
-             */
-            NtDelayExecution(FALSE, &time);
-            get_irq_info(fd, &new_irq_info);
-            if (get_modem_status(fd, &new_mstat))
+            DWORD events = check_events( fd, commio->evtmask,
+                                         &new_irq_info, &commio->irq_info,
+                                         new_mstat, commio->mstat, commio->pending_write );
+            TRACE("events %#x\n", (int)events);
+            if (events)
             {
-                TRACE("get_modem_status failed\n");
-                *commio->events = 0;
-                break;
+                *commio->events = events;
+                *status = STATUS_SUCCESS;
+                *info = sizeof(events);
             }
-            *commio->events = check_events(fd, commio->evtmask,
-                                           &new_irq_info, &commio->irq_info,
-                                           new_mstat, commio->mstat, commio->pending_write);
-            if (*commio->events) break;
-            get_wait_mask(commio->hDevice, &dummy, &cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL, FALSE);
-            if (commio->cookie != cookie)
+            else
             {
-                *commio->events = 0;
-                break;
+                get_wait_mask( commio->io.handle, &dummy, &cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL, FALSE );
+                if (commio->cookie != cookie)
+                {
+                    *commio->events = 0;
+                    *status = STATUS_CANCELLED;
+                    *info = 0;
+                }
+                else
+                {
+                    if (needs_close) close( fd );
+                    return FALSE;
+                }
             }
         }
+
         if (needs_close) close( fd );
     }
-    if (*commio->events) set_async_iosb( commio->iosb, STATUS_SUCCESS, sizeof(DWORD) );
-    else set_async_iosb( commio->iosb, STATUS_CANCELLED, 0 );
-    stop_waiting(commio->hDevice);
-    if (commio->hEvent) NtSetEvent(commio->hEvent, NULL);
-    free( commio );
-    NtTerminateThread( GetCurrentThread(), 0 );
+    stop_waiting( commio->io.handle );
+    release_fileio( &commio->io );
+    return TRUE;
 }
 
-static NTSTATUS wait_on(HANDLE hDevice, int fd, HANDLE hEvent, client_ptr_t iosb_ptr, DWORD* events)
+static NTSTATUS wait_on( HANDLE handle, int fd, HANDLE event, PIO_APC_ROUTINE apc,
+                         void *apc_user, IO_STATUS_BLOCK *io, DWORD *out_buffer )
 {
     async_commio*       commio;
     NTSTATUS            status;
-    HANDLE handle;
+    HANDLE wait_handle;
+    ULONG options;
 
-    if ((status = NtResetEvent(hEvent, NULL)))
-        return status;
+    if (!(commio = (async_commio *)alloc_fileio( sizeof(*commio), async_wait_proc, handle )))
+        return STATUS_NO_MEMORY;
 
-    commio = malloc( sizeof(async_commio) );
-    if (!commio) return STATUS_NO_MEMORY;
-
-    commio->hDevice = hDevice;
-    commio->events  = events;
-    commio->iosb    = iosb_ptr;
-    commio->hEvent  = hEvent;
+    commio->events = out_buffer;
     commio->pending_write = 0;
-    status = get_wait_mask(commio->hDevice, &commio->evtmask, &commio->cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL, TRUE);
+    status = get_wait_mask( handle, &commio->evtmask, &commio->cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL, TRUE );
     if (status)
     {
         free( commio );
@@ -1209,23 +1210,42 @@ static NTSTATUS wait_on(HANDLE hDevice, int fd, HANDLE hEvent, client_ptr_t iosb
         (commio->evtmask & (EV_CTS | EV_DSR| EV_RING| EV_RLSD)))
 	goto out_now;
 
-    /* We might have received something or the TX buffer is delivered */
-    *events = check_events(fd, commio->evtmask,
-                               &commio->irq_info, &commio->irq_info,
-                               commio->mstat, commio->mstat, commio->pending_write);
-    if (*events)
+    SERVER_START_REQ( ioctl )
     {
-        status = STATUS_SUCCESS;
-        goto out_now;
+        req->code   = IOCTL_SERIAL_WAIT_ON_MASK;
+        req->async  = server_async( handle, &commio->io, event, apc, apc_user, iosb_client_ptr(io) );
+        status = wine_server_call( req );
+        wait_handle = wine_server_ptr_handle( reply->wait );
+        options     = reply->options;
     }
+    SERVER_END_REQ;
 
-    /* create the worker thread for the task */
-    /* FIXME: should use async I/O instead */
-    status = NtCreateThreadEx( &handle, THREAD_ALL_ACCESS, NULL, GetCurrentProcess(),
-                               wait_for_event, commio, 0, 0, 0, 0, NULL );
-    if (status != STATUS_SUCCESS) goto out_now;
-    NtClose( handle );
-    return STATUS_PENDING;
+    if (status == STATUS_ALERTED)
+    {
+        /* We might have received something or the TX buffer is delivered */
+        DWORD events = check_events(fd, commio->evtmask,
+                                    &commio->irq_info, &commio->irq_info,
+                                    commio->mstat, commio->mstat, commio->pending_write);
+        if (events)
+        {
+            status = STATUS_SUCCESS;
+            io->Status = STATUS_SUCCESS;
+            io->Information = sizeof(events);
+            *out_buffer = events;
+            set_async_direct_result( &wait_handle, STATUS_SUCCESS, sizeof(events), FALSE );
+        }
+        else
+        {
+            status = STATUS_PENDING;
+            set_async_direct_result( &wait_handle, STATUS_PENDING, 0, TRUE );
+        }
+    }
+
+    if (status != STATUS_PENDING)
+        release_fileio( &commio->io );
+
+    if (wait_handle) status = wait_async( wait_handle, options & FILE_SYNCHRONOUS_IO_ALERT );
+    return status;
 
 #if !defined(TIOCINQ) || (!(defined(TIOCSERGETLSR) && defined(TIOCSER_TEMT)) || !defined(TIOCINQ)) || !defined(TIOCMGET) || !defined(TIOCM_CTS) ||!defined(TIOCM_DSR) || !defined(TIOCM_RNG) || !defined(TIOCM_CAR)
 error_caps:
@@ -1233,7 +1253,6 @@ error_caps:
     status = STATUS_INVALID_PARAMETER;
 #endif
 out_now:
-    stop_waiting(commio->hDevice);
     free( commio );
     return status;
 }
@@ -1247,9 +1266,9 @@ static NTSTATUS xmit_immediate(HANDLE hDevice, int fd, const char* ptr)
     return STATUS_SUCCESS;
 }
 
-static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                            IO_STATUS_BLOCK *io, UINT code, void *in_buffer,
-                            UINT in_size, void *out_buffer, UINT out_size )
+NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                                 IO_STATUS_BLOCK *io, UINT code, void *in_buffer,
+                                 UINT in_size, void *out_buffer, UINT out_size )
 {
     DWORD sz = 0, access = FILE_READ_DATA;
     NTSTATUS status = STATUS_SUCCESS;
@@ -1447,11 +1466,14 @@ static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, vo
     case IOCTL_SERIAL_WAIT_ON_MASK:
         if (out_buffer && out_size == sizeof(DWORD))
         {
-            if (!(status = wait_on(device, fd, event, iosb_client_ptr(io), out_buffer)))
-                sz = sizeof(DWORD);
+            status = wait_on( device, fd, event, apc, apc_user, io, out_buffer );
+            if (needs_close) close( fd );
+            return status;
         }
         else
+        {
             status = STATUS_INVALID_PARAMETER;
+        }
         break;
     default:
         FIXME("Unsupported IOCTL %x (type=%x access=%x func=%x meth=%x)\n",
@@ -1464,54 +1486,7 @@ static NTSTATUS io_control( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, vo
  error:
     io->Status = status;
     io->Information = sz;
-    if (event && status != STATUS_PENDING) NtSetEvent(event, NULL);
-    return status;
-}
-
-/******************************************************************
- *		serial_DeviceIoControl
- */
-NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                                 IO_STATUS_BLOCK *io, UINT code, void *in_buffer,
-                                 UINT in_size, void *out_buffer, UINT out_size )
-{
-    NTSTATUS    status;
-
-    if (code == IOCTL_SERIAL_WAIT_ON_MASK)
-    {
-        HANDLE hev = event;
-
-        /* this is an ioctl we implement in a non blocking way if event is not null
-         * so we have to explicitly wait if no event is provided
-         */
-        if (!hev)
-        {
-            OBJECT_ATTRIBUTES   attr;
-
-            attr.Length                   = sizeof(attr);
-            attr.RootDirectory            = 0;
-            attr.ObjectName               = NULL;
-            attr.Attributes               = OBJ_CASE_INSENSITIVE | OBJ_OPENIF;
-            attr.SecurityDescriptor       = NULL;
-            attr.SecurityQualityOfService = NULL;
-            status = NtCreateEvent(&hev, EVENT_ALL_ACCESS, &attr, SynchronizationEvent, FALSE);
-
-            if (status) return status;
-        }
-        status = io_control( device, hev, apc, apc_user, io, code,
-                             in_buffer, in_size, out_buffer, out_size );
-        if (hev != event)
-        {
-            if (status == STATUS_PENDING)
-            {
-                NtWaitForSingleObject(hev, FALSE, NULL);
-                status = STATUS_SUCCESS;
-            }
-            NtClose(hev);
-        }
-    }
-    else status = io_control( device, event, apc, apc_user, io, code,
-                              in_buffer, in_size, out_buffer, out_size );
+    if (event) NtSetEvent(event, NULL);
     return status;
 }
 
diff --git a/server/serial.c b/server/serial.c
index d665eb7fa35..68b489822b4 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -51,6 +51,12 @@
 #include "thread.h"
 #include "request.h"
 
+struct wait_req
+{
+    struct serial *serial;
+    struct timeout_user *timeout;
+};
+
 static void serial_dump( struct object *obj, int verbose );
 static struct fd *serial_get_fd( struct object *obj );
 static void serial_destroy(struct object *obj);
@@ -65,6 +71,8 @@ struct serial
     struct object       obj;
     struct fd          *fd;
 
+    struct async_queue  wait_q; /* queue for asynchronous WAIT_ON_MASK */
+
     struct timeout_user *read_timer;
     SERIAL_TIMEOUTS     timeouts;
     unsigned int        eventmask;
@@ -138,6 +146,7 @@ struct object *create_serial( struct fd *fd )
     serial->pending_write = 0;
     serial->pending_wait = 0;
     memset( &serial->timeouts, 0, sizeof(serial->timeouts) );
+    init_async_queue( &serial->wait_q );
     serial->fd = (struct fd *)grab_object( fd );
     set_fd_user( fd, &serial_fd_ops, &serial->obj );
     return &serial->obj;
@@ -153,6 +162,7 @@ static void serial_destroy( struct object *obj)
 {
     struct serial *serial = (struct serial *)obj;
     if (serial->read_timer) remove_timeout_user( serial->read_timer );
+    free_async_queue( &serial->wait_q );
     release_object( serial->fd );
 }
 
@@ -173,6 +183,25 @@ static enum server_fd_type serial_get_fd_type( struct fd *fd )
     return FD_TYPE_SERIAL;
 }
 
+#define WAIT_ON_MASK_POLL_INTERVAL -10000
+
+static void free_wait_req( void *private )
+{
+    struct wait_req *req = private;
+
+    if (req->timeout) remove_timeout_user( req->timeout );
+    release_object( req->serial );
+    free( req );
+}
+
+static void async_wait_timeout( void *private )
+{
+    struct wait_req *req = private;
+
+    async_wake_up( &req->serial->wait_q, STATUS_ALERTED );
+    req->timeout = add_timeout_user( WAIT_ON_MASK_POLL_INTERVAL, async_wait_timeout, req );
+}
+
 static void serial_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
 {
     struct serial *serial = get_fd_user( fd );
@@ -217,6 +246,26 @@ static void serial_ioctl( struct fd *fd, ioctl_code_t code, struct async *async
         fd_async_wake_up( serial->fd, ASYNC_TYPE_WAIT, STATUS_SUCCESS );
         return;
 
+    case IOCTL_SERIAL_WAIT_ON_MASK:
+    {
+        struct wait_req *req;
+
+        if (!(req = mem_alloc(sizeof(*req))))
+            return;
+
+        req->serial = (struct serial *)grab_object( serial );
+        if (!(req->timeout = add_timeout_user( WAIT_ON_MASK_POLL_INTERVAL, async_wait_timeout, req )))
+        {
+            free( req );
+            return;
+        }
+
+        async_set_completion_callback( async, free_wait_req, req );
+        queue_async( &serial->wait_q, async );
+        set_error( STATUS_ALERTED );
+        return;
+    }
+
     default:
         set_error( STATUS_NOT_SUPPORTED );
     }
-- 
GitLab

From 6b7834d4074eee098711b5935208224bfed9fc3b Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 28 May 2024 18:41:05 -0500
Subject: [PATCH 1/2] server: Check for an existing serial wait ioctl within
 the ioctl handler.

---
 dlls/ntdll/unix/serial.c       | 22 +++-------------------
 include/wine/server_protocol.h |  3 +--
 server/protocol.def            |  1 -
 server/serial.c                | 31 ++++++-------------------------
 4 files changed, 10 insertions(+), 47 deletions(-)

diff --git a/dlls/ntdll/unix/serial.c b/dlls/ntdll/unix/serial.c
index d73ece47d0b..5af3f9afced 100644
--- a/dlls/ntdll/unix/serial.c
+++ b/dlls/ntdll/unix/serial.c
@@ -452,21 +452,7 @@ static NTSTATUS get_status(int fd, SERIAL_STATUS* ss)
     return status;
 }
 
-static void stop_waiting( HANDLE handle )
-{
-    unsigned int status;
-
-    SERVER_START_REQ( set_serial_info )
-    {
-        req->handle = wine_server_obj_handle( handle );
-        req->flags = SERIALINFO_PENDING_WAIT;
-        if ((status = wine_server_call( req )))
-            ERR("failed to clear waiting state: %#x\n", status);
-    }
-    SERVER_END_REQ;
-}
-
-static NTSTATUS get_wait_mask(HANDLE hDevice, UINT *mask, UINT *cookie, BOOL *pending_write, BOOL start_wait)
+static NTSTATUS get_wait_mask( HANDLE hDevice, UINT *mask, UINT *cookie, BOOL *pending_write )
 {
     unsigned int status;
 
@@ -474,7 +460,6 @@ static NTSTATUS get_wait_mask(HANDLE hDevice, UINT *mask, UINT *cookie, BOOL *pe
     {
         req->handle = wine_server_obj_handle( hDevice );
         req->flags = pending_write ? SERIALINFO_PENDING_WRITE : 0;
-        if (start_wait) req->flags |= SERIALINFO_PENDING_WAIT;
         if (!(status = wine_server_call( req )))
         {
             *mask = reply->eventmask;
@@ -1126,7 +1111,7 @@ static BOOL async_wait_proc( void *user, ULONG_PTR *info, unsigned int *status )
             }
             else
             {
-                get_wait_mask( commio->io.handle, &dummy, &cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL, FALSE );
+                get_wait_mask( commio->io.handle, &dummy, &cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL );
                 if (commio->cookie != cookie)
                 {
                     *commio->events = 0;
@@ -1143,7 +1128,6 @@ static BOOL async_wait_proc( void *user, ULONG_PTR *info, unsigned int *status )
 
         if (needs_close) close( fd );
     }
-    stop_waiting( commio->io.handle );
     release_fileio( &commio->io );
     return TRUE;
 }
@@ -1161,7 +1145,7 @@ static NTSTATUS wait_on( HANDLE handle, int fd, HANDLE event, PIO_APC_ROUTINE ap
 
     commio->events = out_buffer;
     commio->pending_write = 0;
-    status = get_wait_mask( handle, &commio->evtmask, &commio->cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL, TRUE );
+    status = get_wait_mask( handle, &commio->evtmask, &commio->cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL );
     if (status)
     {
         free( commio );
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 8a5ae71b856..71e28f8eac2 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -3035,7 +3035,6 @@ struct set_serial_info_reply
     struct reply_header __header;
 };
 #define SERIALINFO_PENDING_WRITE 0x04
-#define SERIALINFO_PENDING_WAIT  0x08
 
 
 struct cancel_sync_request
diff --git a/server/protocol.def b/server/protocol.def
index 25184641082..b543fdabaae 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2256,7 +2256,6 @@ enum message_type
     int          flags;        /* bitmask to set values (see below) */
 @END
 #define SERIALINFO_PENDING_WRITE 0x04
-#define SERIALINFO_PENDING_WAIT  0x08
 
 /* Cancel all sync io on a thread */
 @REQ(cancel_sync)
diff --git a/server/serial.c b/server/serial.c
index 68b489822b4..2fab9bbe7e6 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -78,7 +78,6 @@ struct serial
     unsigned int        eventmask;
     unsigned int        generation; /* event mask change counter */
     unsigned int        pending_write : 1;
-    unsigned int        pending_wait  : 1;
 
     struct termios      original;
 
@@ -144,7 +143,6 @@ struct object *create_serial( struct fd *fd )
     serial->eventmask    = 0;
     serial->generation   = 0;
     serial->pending_write = 0;
-    serial->pending_wait = 0;
     memset( &serial->timeouts, 0, sizeof(serial->timeouts) );
     init_async_queue( &serial->wait_q );
     serial->fd = (struct fd *)grab_object( fd );
@@ -250,6 +248,12 @@ static void serial_ioctl( struct fd *fd, ioctl_code_t code, struct async *async
     {
         struct wait_req *req;
 
+        if (async_queued( &serial->wait_q ))
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+
         if (!(req = mem_alloc(sizeof(*req))))
             return;
 
@@ -329,17 +333,6 @@ DECL_HANDLER(get_serial_info)
 
     if ((serial = get_serial_obj( current->process, req->handle, 0 )))
     {
-        if (req->flags & SERIALINFO_PENDING_WAIT)
-        {
-            if (serial->pending_wait)
-            {
-                release_object( serial );
-                set_error( STATUS_INVALID_PARAMETER );
-                return;
-            }
-            serial->pending_wait = 1;
-        }
-
         /* event mask */
         reply->eventmask    = serial->eventmask;
         reply->cookie       = serial->generation;
@@ -359,18 +352,6 @@ DECL_HANDLER(set_serial_info)
 
     if ((serial = get_serial_obj( current->process, req->handle, 0 )))
     {
-        if (req->flags & SERIALINFO_PENDING_WAIT)
-        {
-            if (!serial->pending_wait)
-            {
-                release_object( serial );
-                set_error( STATUS_INVALID_PARAMETER );
-                return;
-            }
-            serial->pending_wait = 0;
-        }
-
-        /* pending write */
         if (req->flags & SERIALINFO_PENDING_WRITE)
             serial->pending_write = 1;
 
-- 
GitLab


From aa0ab31571141aedbb8ad9cd4e5220dfcb5b0807 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 28 May 2024 18:45:27 -0500
Subject: [PATCH 2/2] server: Directly wake up wait asyncs when the serial mask
 changes.

---
 dlls/ntdll/unix/serial.c       | 23 ++++++-----------------
 include/wine/server_protocol.h |  4 +---
 server/protocol.def            |  1 -
 server/request.h               |  5 ++---
 server/serial.c                |  6 +-----
 server/trace.c                 |  1 -
 6 files changed, 10 insertions(+), 30 deletions(-)

diff --git a/dlls/ntdll/unix/serial.c b/dlls/ntdll/unix/serial.c
index 5af3f9afced..ea9931d891a 100644
--- a/dlls/ntdll/unix/serial.c
+++ b/dlls/ntdll/unix/serial.c
@@ -452,7 +452,7 @@ static NTSTATUS get_status(int fd, SERIAL_STATUS* ss)
     return status;
 }
 
-static NTSTATUS get_wait_mask( HANDLE hDevice, UINT *mask, UINT *cookie, BOOL *pending_write )
+static NTSTATUS get_wait_mask( HANDLE hDevice, UINT *mask, BOOL *pending_write )
 {
     unsigned int status;
 
@@ -463,7 +463,6 @@ static NTSTATUS get_wait_mask( HANDLE hDevice, UINT *mask, UINT *cookie, BOOL *p
         if (!(status = wine_server_call( req )))
         {
             *mask = reply->eventmask;
-            if (cookie) *cookie = reply->cookie;
             if (pending_write) *pending_write = reply->pending_write;
         }
     }
@@ -967,7 +966,6 @@ typedef struct async_commio
     struct async_fileio io;
     DWORD*              events;
     UINT                evtmask;
-    UINT                cookie;
     UINT                mstat;
     BOOL                pending_write;
     serial_irq_info     irq_info;
@@ -1080,7 +1078,7 @@ static BOOL async_wait_proc( void *user, ULONG_PTR *info, unsigned int *status )
     if (!server_get_unix_fd( commio->io.handle, FILE_READ_DATA | FILE_WRITE_DATA, &fd, &needs_close, NULL, NULL ))
     {
         serial_irq_info new_irq_info;
-        UINT new_mstat, dummy, cookie;
+        UINT new_mstat, dummy;
 
         TRACE( "device=%p fd=0x%08x mask=0x%08x buffer=%p irq_info=%p\n",
                commio->io.handle, fd, commio->evtmask, commio->events, &commio->irq_info );
@@ -1111,18 +1109,9 @@ static BOOL async_wait_proc( void *user, ULONG_PTR *info, unsigned int *status )
             }
             else
             {
-                get_wait_mask( commio->io.handle, &dummy, &cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL );
-                if (commio->cookie != cookie)
-                {
-                    *commio->events = 0;
-                    *status = STATUS_CANCELLED;
-                    *info = 0;
-                }
-                else
-                {
-                    if (needs_close) close( fd );
-                    return FALSE;
-                }
+                get_wait_mask( commio->io.handle, &dummy, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL );
+                if (needs_close) close( fd );
+                return FALSE;
             }
         }
 
@@ -1145,7 +1134,7 @@ static NTSTATUS wait_on( HANDLE handle, int fd, HANDLE event, PIO_APC_ROUTINE ap
 
     commio->events = out_buffer;
     commio->pending_write = 0;
-    status = get_wait_mask( handle, &commio->evtmask, &commio->cookie, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL );
+    status = get_wait_mask( handle, &commio->evtmask, (commio->evtmask & EV_TXEMPTY) ? &commio->pending_write : NULL );
     if (status)
     {
         free( commio );
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 71e28f8eac2..e16f1ceb7c3 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -3016,9 +3016,7 @@ struct get_serial_info_reply
 {
     struct reply_header __header;
     unsigned int eventmask;
-    unsigned int cookie;
     unsigned int pending_write;
-    char __pad_20[4];
 };
 
 
diff --git a/server/protocol.def b/server/protocol.def
index b543fdabaae..766674d3e30 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2245,7 +2245,6 @@ enum message_type
     int          flags;
 @REPLY
     unsigned int eventmask;
-    unsigned int cookie;
     unsigned int pending_write;
 @END
 
diff --git a/server/request.h b/server/request.h
index acee48c2faf..67de9bb1779 100644
--- a/server/request.h
+++ b/server/request.h
@@ -1455,9 +1455,8 @@ C_ASSERT( FIELD_OFFSET(struct get_serial_info_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct get_serial_info_request, flags) == 16 );
 C_ASSERT( sizeof(struct get_serial_info_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct get_serial_info_reply, eventmask) == 8 );
-C_ASSERT( FIELD_OFFSET(struct get_serial_info_reply, cookie) == 12 );
-C_ASSERT( FIELD_OFFSET(struct get_serial_info_reply, pending_write) == 16 );
-C_ASSERT( sizeof(struct get_serial_info_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct get_serial_info_reply, pending_write) == 12 );
+C_ASSERT( sizeof(struct get_serial_info_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct set_serial_info_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct set_serial_info_request, flags) == 16 );
 C_ASSERT( sizeof(struct set_serial_info_request) == 24 );
diff --git a/server/serial.c b/server/serial.c
index 2fab9bbe7e6..209f2e9174e 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -76,7 +76,6 @@ struct serial
     struct timeout_user *read_timer;
     SERIAL_TIMEOUTS     timeouts;
     unsigned int        eventmask;
-    unsigned int        generation; /* event mask change counter */
     unsigned int        pending_write : 1;
 
     struct termios      original;
@@ -141,7 +140,6 @@ struct object *create_serial( struct fd *fd )
 
     serial->read_timer   = NULL;
     serial->eventmask    = 0;
-    serial->generation   = 0;
     serial->pending_write = 0;
     memset( &serial->timeouts, 0, sizeof(serial->timeouts) );
     init_async_queue( &serial->wait_q );
@@ -240,8 +238,7 @@ static void serial_ioctl( struct fd *fd, ioctl_code_t code, struct async *async
             return;
         }
         serial->eventmask = *(unsigned int *)get_req_data();
-        serial->generation++;
-        fd_async_wake_up( serial->fd, ASYNC_TYPE_WAIT, STATUS_SUCCESS );
+        async_wake_up( &serial->wait_q, STATUS_CANCELLED );
         return;
 
     case IOCTL_SERIAL_WAIT_ON_MASK:
@@ -335,7 +332,6 @@ DECL_HANDLER(get_serial_info)
     {
         /* event mask */
         reply->eventmask    = serial->eventmask;
-        reply->cookie       = serial->generation;
 
         /* pending write */
         reply->pending_write = serial->pending_write;
diff --git a/server/trace.c b/server/trace.c
index 1aa0d5c1518..08adda28230 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -2856,7 +2856,6 @@ static void dump_get_serial_info_request( const struct get_serial_info_request *
 static void dump_get_serial_info_reply( const struct get_serial_info_reply *req )
 {
     fprintf( stderr, " eventmask=%08x", req->eventmask );
-    fprintf( stderr, ", cookie=%08x", req->cookie );
     fprintf( stderr, ", pending_write=%08x", req->pending_write );
 }
 
-- 
GitLab

From 2745228b14d138ea2c7f631c212440ecf7b8f453 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 22 Mar 2024 13:58:11 -0600
Subject: [PATCH] ntdll: Don't use debug info presence to detect critical
 section global status.

---
 dlls/ntdll/sync.c | 39 +++++++++++----------------------------
 1 file changed, 11 insertions(+), 28 deletions(-)

diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 00ab614803f..a764d2afc09 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -163,29 +163,16 @@ static const char *crit_section_get_name( const RTL_CRITICAL_SECTION *crit )
 
 static inline HANDLE get_semaphore( RTL_CRITICAL_SECTION *crit )
 {
-    HANDLE ret = crit->LockSemaphore;
-    if (!ret)
-    {
-        HANDLE sem;
-        if (NtCreateSemaphore( &sem, SEMAPHORE_ALL_ACCESS, NULL, 0, 1 )) return 0;
-        if (!(ret = InterlockedCompareExchangePointer( &crit->LockSemaphore, sem, 0 )))
-            ret = sem;
-        else
-            NtClose(sem);  /* somebody beat us to it */
-    }
-    return ret;
+    if ((ULONG_PTR)crit->LockSemaphore > 1) return crit->LockSemaphore;
+    return NULL;
 }
 
 static inline NTSTATUS wait_semaphore( RTL_CRITICAL_SECTION *crit, int timeout )
 {
     LARGE_INTEGER time = {.QuadPart = timeout * (LONGLONG)-10000000};
+    HANDLE sem = get_semaphore( crit );
 
-    /* debug info is cleared by MakeCriticalSectionGlobal */
-    if (!crit_section_has_debuginfo( crit ))
-    {
-        HANDLE sem = get_semaphore( crit );
-        return NtWaitForSingleObject( sem, FALSE, &time );
-    }
+    if (sem) return NtWaitForSingleObject( sem, FALSE, &time );
     else
     {
         LONG *lock = (LONG *)&crit->LockSemaphore;
@@ -276,6 +263,8 @@ ULONG WINAPI RtlSetCriticalSectionSpinCount( RTL_CRITICAL_SECTION *crit, ULONG s
  */
 NTSTATUS WINAPI RtlDeleteCriticalSection( RTL_CRITICAL_SECTION *crit )
 {
+    HANDLE sem;
+
     crit->LockCount      = -1;
     crit->RecursionCount = 0;
     crit->OwningThread   = 0;
@@ -288,11 +277,9 @@ NTSTATUS WINAPI RtlDeleteCriticalSection( RTL_CRITICAL_SECTION *crit )
             crit->DebugInfo = NULL;
         }
     }
-    else
-    {
-        NtClose( crit->LockSemaphore );
-        crit->DebugInfo = NULL;
-    }
+    else crit->DebugInfo = NULL;
+
+    if ((sem = get_semaphore( crit ))) NtClose( sem );
     crit->LockSemaphore = 0;
     return STATUS_SUCCESS;
 }
@@ -335,13 +322,9 @@ NTSTATUS WINAPI RtlpWaitForCriticalSection( RTL_CRITICAL_SECTION *crit )
 NTSTATUS WINAPI RtlpUnWaitCriticalSection( RTL_CRITICAL_SECTION *crit )
 {
     NTSTATUS ret;
+    HANDLE sem = get_semaphore( crit );
 
-    /* debug info is cleared by MakeCriticalSectionGlobal */
-    if (!crit_section_has_debuginfo( crit ))
-    {
-        HANDLE sem = get_semaphore( crit );
-        ret = NtReleaseSemaphore( sem, 1, NULL );
-    }
+    if (sem) ret = NtReleaseSemaphore( sem, 1, NULL );
     else
     {
         LONG *lock = (LONG *)&crit->LockSemaphore;
-- 
GitLab


