From c335b69e584dd9f3a3ef6d5a1adc120db7fc2fb6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 4 Jun 2021 10:24:10 +0200
Subject: [PATCH] wineboot: Compute and write the TSC frequency to registry
 ~Mhz.

In HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor

Squashed with patches from:

* Arkadiusz Hiler <ahiler@codeweavers.com>

Check if the kernel trusts TSC before using it for Qpc.

Even if the bits are claiming that TSC meets our requirements the
hardware implementation may still be broken.

The Linux kernel does a lot of quality testing before deciding to use as
the clock source. If it (or the user, through an override) does not trust
the TSC we should not trust it either.

* Joshua Ashton <joshua@froggi.es>

Some games such as Horizon Zero Dawn use this registry value to
correlate values from rtdsc to real time.

Testing across a few devices, is seems like Windows always returns the
TSC frequency in this entry, not the current/maximum frequency of the
processor.

Returning the nominal/maximum cpu frequency here causes the game to run
in slow motion as it may not match the tsc frequency of the processor.

Ideally we'd not have to measure this and the kernel would return
tsc_khz to userspace, but this is a good enough stop-gap until
https://lkml.org/lkml/2020/12/31/72 or something similar is merged.
---
 programs/wineboot/wineboot.c | 175 ++++++++++++++++++++++++++++++++++-
 1 file changed, 170 insertions(+), 5 deletions(-)

diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index 728c41fffa9..f5612ce310f 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -82,6 +82,8 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(wineboot);
 
+#define TICKSPERSEC        10000000
+
 extern BOOL shutdown_close_windows( BOOL force );
 extern BOOL shutdown_all_desktops( BOOL force );
 extern void kill_processes( BOOL kill_desktop );
@@ -240,15 +242,173 @@ static void initialize_xstate_features(struct _KUSER_SHARED_DATA *data)
     TRACE("XSAVE feature 2 %#x, %#x, %#x, %#x.\n", regs[0], regs[1], regs[2], regs[3]);
 }
 
+static UINT64 read_tsc_frequency( BOOL has_rdtscp )
+{
+    UINT64 freq = 0;
+
+/* FIXME: Intel provides TSC freq in some CPUID but it's been slightly broken,
+   fix it properly and test it on real Intel hardware */
+
+#if 0
+    int regs[4], cpuid_level, tmp;
+    UINT64 denom, numer;
+
+    __cpuid( regs, 0 );
+    tmp = regs[2];
+    regs[2] = regs[3];
+    regs[3] = tmp;
+
+    /* only available on some intel CPUs */
+    if (memcmp( regs + 1, "GenuineIntel", 12 )) freq = 0;
+    else if ((cpuid_level = regs[0]) < 0x15) freq = 0;
+    else
+    {
+        __cpuid( regs, 0x15 );
+        if (!(denom = regs[0]) || !(numer = regs[1])) freq = 0;
+        else
+        {
+            if ((freq = regs[2])) freq = freq * numer / denom;
+            else if (cpuid_level >= 0x16)
+            {
+                __cpuid( regs, 0x16 ); /* eax is base freq in MHz */
+                freq = regs[0] * (UINT64)1000000;
+            }
+            else freq = 0;
+        }
+
+        if (!freq) WARN( "Failed to read TSC frequency from CPUID, falling back to calibration.\n" );
+        else TRACE( "TSC frequency read from CPUID, found %I64u Hz\n", freq );
+    }
+#endif
+
+    if (freq == 0)
+    {
+        LONGLONG time0, time1, tsc0, tsc1, tsc2, tsc3, freq0, freq1, error;
+        unsigned int aux;
+        UINT retries = 50;
+        int regs[4];
+
+        do
+        {
+            if (has_rdtscp)
+            {
+                tsc0 = __rdtscp( &aux );
+                time0 = RtlGetSystemTimePrecise();
+                tsc1 = __rdtscp( &aux );
+                Sleep( 1 );
+                tsc2 = __rdtscp( &aux );
+                time1 = RtlGetSystemTimePrecise();
+                tsc3 = __rdtscp( &aux );
+            }
+            else
+            {
+                tsc0 = __rdtsc(); __cpuid( regs, 0 );
+                time0 = RtlGetSystemTimePrecise();
+                tsc1 = __rdtsc(); __cpuid( regs, 0 );
+                Sleep(1);
+                tsc2 = __rdtsc(); __cpuid( regs, 0 );
+                time1 = RtlGetSystemTimePrecise();
+                tsc3 = __rdtsc(); __cpuid( regs, 0 );
+            }
+
+            freq0 = (tsc2 - tsc0) * 10000000 / (time1 - time0);
+            freq1 = (tsc3 - tsc1) * 10000000 / (time1 - time0);
+            error = llabs( (freq1 - freq0) * 1000000 / min( freq1, freq0 ) );
+        }
+        while (error > 100 && retries--);
+
+        if (!retries) WARN( "TSC frequency calibration failed, unstable TSC?\n" );
+        else
+        {
+            freq = (freq0 + freq1) / 2;
+            TRACE( "TSC frequency calibration complete, found %I64u Hz\n", freq );
+        }
+    }
+
+    return freq;
+}
+
+static BOOL is_tsc_trusted_by_the_kernel(void)
+{
+    char buf[4] = {};
+    DWORD num_read;
+    HANDLE handle;
+    BOOL ret = TRUE;
+
+    handle = CreateFileA( "\\??\\unix\\sys\\bus\\clocksource\\devices\\clocksource0\\current_clocksource",
+                          GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0 );
+    if (handle == INVALID_HANDLE_VALUE) return TRUE;
+
+    if (ReadFile( handle, buf, sizeof(buf) - 1, &num_read, NULL ) && strcmp( "tsc", buf ))
+        ret = FALSE;
+
+    CloseHandle( handle );
+    return ret;
+}
+
+static void initialize_qpc_features( struct _KUSER_SHARED_DATA *data, UINT64 *tsc_frequency )
+{
+    BOOL has_rdtscp = FALSE;
+    int regs[4];
+
+    data->QpcBypassEnabled = 0;
+    data->QpcFrequency = TICKSPERSEC;
+    data->QpcShift = 0;
+    data->QpcBias = 0;
+    *tsc_frequency = 0;
+
+    if (!is_tsc_trusted_by_the_kernel())
+    {
+        WARN( "Failed to compute TSC frequency, not trusted by the kernel.\n" );
+        return;
+    }
+
+    if (!data->ProcessorFeatures[PF_RDTSC_INSTRUCTION_AVAILABLE])
+    {
+        WARN( "Failed to compute TSC frequency, RDTSC instruction not supported.\n" );
+        return;
+    }
+
+    __cpuid( regs, 0x80000000 );
+    if (regs[0] < 0x80000007)
+    {
+        WARN( "Failed to compute TSC frequency, unable to check invariant TSC.\n" );
+        return;
+    }
+
+    /* check for invariant tsc bit */
+    __cpuid( regs, 0x80000007 );
+    if (!(regs[3] & (1 << 8)))
+    {
+        WARN( "Failed to compute TSC frequency, no invariant TSC.\n" );
+        return;
+    }
+
+    /* check for rdtscp support bit */
+    __cpuid( regs, 0x80000001 );
+    if ((regs[3] & (1 << 27))) has_rdtscp = TRUE;
+
+    *tsc_frequency = read_tsc_frequency( has_rdtscp );
+}
+
 #else
 
 static void initialize_xstate_features(struct _KUSER_SHARED_DATA *data)
 {
 }
 
+static void initialize_qpc_features( struct _KUSER_SHARED_DATA *data, UINT64 *tsc_frequency )
+{
+    data->QpcBypassEnabled = 0;
+    data->QpcFrequency = TICKSPERSEC;
+    data->QpcShift = 0;
+    data->QpcBias = 0;
+    *tsc_frequency = 0;
+}
+
 #endif
 
-static void create_user_shared_data(void)
+static void create_user_shared_data( UINT64 *tsc_frequency )
 {
     struct _KUSER_SHARED_DATA *data;
     RTL_OSVERSIONINFOEXW version;
@@ -367,6 +527,7 @@ static void create_user_shared_data(void)
     data->ActiveGroupCount = 1;
 
     initialize_xstate_features( data );
+    initialize_qpc_features( data, tsc_frequency );
 
     UnmapViewOfFile( data );
 }
@@ -659,7 +820,7 @@ static void create_bios_key( HKEY system_key )
 }
 
 /* create the volatile hardware registry keys */
-static void create_hardware_registry_keys(void)
+static void create_hardware_registry_keys( UINT64 tsc_frequency )
 {
     unsigned int i;
     HKEY hkey, system_key, cpu_key, fpu_key;
@@ -736,13 +897,16 @@ static void create_hardware_registry_keys(void)
         if (!RegCreateKeyExW( cpu_key, numW, 0, NULL, REG_OPTION_VOLATILE,
                               KEY_ALL_ACCESS, NULL, &hkey, NULL ))
         {
+            DWORD tsc_freq_mhz = (DWORD)(tsc_frequency / 1000000ull); /* Hz -> Mhz */
+            if (!tsc_freq_mhz) tsc_freq_mhz = power_info[i].MaxMhz;
+
             RegSetValueExW( hkey, L"FeatureSet", 0, REG_DWORD, (BYTE *)&sci.ProcessorFeatureBits, sizeof(DWORD) );
             set_reg_value( hkey, L"Identifier", id );
             /* TODO: report ARM properly */
             RegSetValueExA( hkey, "ProcessorNameString", 0, REG_SZ, (const BYTE *)name_buffer,
                             strlen( (char *)name_buffer ) + 1 );
             set_reg_value( hkey, L"VendorIdentifier", vendorid );
-            RegSetValueExW( hkey, L"~MHz", 0, REG_DWORD, (BYTE *)&power_info[i].MaxMhz, sizeof(DWORD) );
+            RegSetValueExW( hkey, L"~MHz", 0, REG_DWORD, (BYTE *)&tsc_freq_mhz, sizeof(DWORD) );
             RegCloseKey( hkey );
         }
         if (sci.ProcessorArchitecture != PROCESSOR_ARCHITECTURE_ARM &&
@@ -1627,6 +1791,7 @@ int __cdecl main( int argc, char *argv[] )
     BOOL end_session, force, init, kill, restart, shutdown, update;
     HANDLE event;
     OBJECT_ATTRIBUTES attr;
+    UINT64 tsc_frequency = 0;
     UNICODE_STRING nameW = RTL_CONSTANT_STRING( L"\\KernelObjects\\__wineboot_event" );
     BOOL is_wow64;
 
@@ -1712,8 +1877,8 @@ int __cdecl main( int argc, char *argv[] )
 
     ResetEvent( event );  /* in case this is a restart */
 
-    create_user_shared_data();
-    create_hardware_registry_keys();
+    create_user_shared_data( &tsc_frequency );
+    create_hardware_registry_keys( tsc_frequency );
     create_dynamic_registry_keys();
     create_environment_registry_keys();
     create_computer_name_keys();

From dcb4536d9fb1b3d63960cc999f0720dd45bd9ccf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 4 Mar 2021 10:25:28 +0100
Subject: [PATCH] ntdll: Read Qpc frequency from user shared data.

---
 dlls/ntdll/time.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/time.c b/dlls/ntdll/time.c
index 105a6cf5bc8..5ff297eedd2 100644
--- a/dlls/ntdll/time.c
+++ b/dlls/ntdll/time.c
@@ -391,7 +391,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH RtlQueryPerformanceCounter( LARGE_INTEGER *counter
  */
 BOOL WINAPI DECLSPEC_HOTPATCH RtlQueryPerformanceFrequency( LARGE_INTEGER *frequency )
 {
-    frequency->QuadPart = TICKSPERSEC;
+    frequency->QuadPart = user_shared_data->QpcFrequency;
     return TRUE;
 }
 

From f373b29628cef8d8b085f2714177ce63255fed4b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 4 Mar 2021 10:50:48 +0100
Subject: [PATCH] ntdll: Prefer RtlQueryPerformanceCounter over
 NtQueryPerformanceCounter.

---
 dlls/ntdll/threadpool.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 4f22114a55e..e46a9d3e113 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -599,8 +599,10 @@ static DWORD WINAPI timer_callback_wrapper(LPVOID p)
 
 static inline ULONGLONG queue_current_time(void)
 {
-    LARGE_INTEGER now, freq;
-    NtQueryPerformanceCounter(&now, &freq);
+    static LARGE_INTEGER freq;
+    LARGE_INTEGER now;
+    if (!freq.QuadPart) RtlQueryPerformanceFrequency(&freq);
+    RtlQueryPerformanceCounter(&now);
     return now.QuadPart * 1000 / freq.QuadPart;
 }
 

From aa3d0658e8be3f2a244971d4148cff98d377a787 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 4 Mar 2021 10:51:05 +0100
Subject: [PATCH] hal: Prefer RtlQueryPerformanceCounter over
 NtQueryPerformanceCounter.

---
 dlls/hal/hal.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/hal/hal.c b/dlls/hal/hal.c
index e339f21ab6c..48667d00635 100644
--- a/dlls/hal/hal.c
+++ b/dlls/hal/hal.c
@@ -193,6 +193,7 @@ ULONGLONG WINAPI KeQueryPerformanceCounter(LARGE_INTEGER *frequency)
 
     TRACE("(%p)\n", frequency);
 
-    NtQueryPerformanceCounter(&counter, frequency);
+    RtlQueryPerformanceFrequency(frequency);
+    RtlQueryPerformanceCounter(&counter);
     return counter.QuadPart;
 }

From 1d829b84f58b20b9885079570f6d97b8156e3d8a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 4 Mar 2021 10:51:17 +0100
Subject: [PATCH] kernelbase: Prefer RtlQueryPerformanceCounter over
 NtQueryPerformanceCounter.

---
 dlls/kernelbase/registry.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/kernelbase/registry.c b/dlls/kernelbase/registry.c
index a767d993254..a0f1b3a6d2f 100644
--- a/dlls/kernelbase/registry.c
+++ b/dlls/kernelbase/registry.c
@@ -1564,7 +1564,8 @@ static DWORD query_perf_data( const WCHAR *query, DWORD *type, void *data, DWORD
     pdb->HeaderLength = sizeof(*pdb);
     pdb->NumObjectTypes = 0;
     pdb->DefaultObject = 0;
-    NtQueryPerformanceCounter( &pdb->PerfTime, &pdb->PerfFreq );
+    RtlQueryPerformanceFrequency( &pdb->PerfFreq );
+    RtlQueryPerformanceCounter( &pdb->PerfTime );
 
     data = pdb + 1;
     pdb->SystemNameOffset = sizeof(*pdb);

From fc8ec0f96f847bcb286a4e5603677bb9034a77f6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 4 Mar 2021 12:39:58 +0100
Subject: [PATCH] winmm: Only call QueryPerformanceFrequency once.

---
 dlls/winmm/time.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/winmm/time.c b/dlls/winmm/time.c
index e00b5ca7b54..55221903ed1 100644
--- a/dlls/winmm/time.c
+++ b/dlls/winmm/time.c
@@ -254,10 +254,11 @@ MMRESULT WINAPI timeGetSystemTime(LPMMTIME lpTime, UINT wSize)
  */
 DWORD WINAPI timeGetTime(void)
 {
-    LARGE_INTEGER now, freq;
+    static LARGE_INTEGER freq;
+    LARGE_INTEGER now;
 
+    if (!freq.QuadPart) QueryPerformanceFrequency(&freq);
     QueryPerformanceCounter(&now);
-    QueryPerformanceFrequency(&freq);
 
     return (now.QuadPart * 1000) / freq.QuadPart;
 }

From 5540bb2330e66c2fde103b9a0b465e870ff89def Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 10 Sep 2021 22:55:38 +0200
Subject: [PATCH] server: Use a single macro instead of
 atomic_store_(ulong|long).

---
 server/fd.c | 52 +++++++++++++++++++++-------------------------------
 1 file changed, 21 insertions(+), 31 deletions(-)

diff --git a/server/fd.c b/server/fd.c
index 7cdd329bcbb..60bf98c8938 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -340,27 +340,15 @@ timeout_t monotonic_time;
 struct _KUSER_SHARED_DATA *user_shared_data = NULL;
 static const int user_shared_data_timeout = 16;
 
-static void atomic_store_ulong(volatile ULONG *ptr, ULONG value)
-{
-    /* on x86 there should be total store order guarantees, so volatile is
-     * enough to ensure the stores aren't reordered by the compiler, and then
-     * they will always be seen in-order from other CPUs. On other archs, we
-     * need atomic intrinsics to guarantee that. */
+/* on x86 there should be total store order guarantees, so volatile is
+ * enough to ensure the stores aren't reordered by the compiler, and then
+ * they will always be seen in-order from other CPUs. On other archs, we
+ * need atomic intrinsics to guarantee that. */
 #if defined(__i386__) || defined(__x86_64__)
-    *ptr = value;
+#define ATOMIC_STORE(ptr, value) *(ptr) = (value)
 #else
-    __atomic_store_n(ptr, value, __ATOMIC_SEQ_CST);
+#define ATOMIC_STORE(ptr, value) __atomic_store_n(ptr, value, __ATOMIC_SEQ_CST)
 #endif
-}
-
-static void atomic_store_long(volatile LONG *ptr, LONG value)
-{
-#if defined(__i386__) || defined(__x86_64__)
-    *ptr = value;
-#else
-    __atomic_store_n(ptr, value, __ATOMIC_SEQ_CST);
-#endif
-}
 
 static void set_user_shared_data_time(void)
 {
@@ -398,26 +387,28 @@ static void set_user_shared_data_time(vo
         if (tm->tm_isdst) timezone_bias -= 3600;
         timezone_bias *= TICKS_PER_SEC;
 
-        atomic_store_long(&user_shared_data->TimeZoneBias.High2Time, timezone_bias >> 32);
-        atomic_store_ulong(&user_shared_data->TimeZoneBias.LowPart, timezone_bias);
-        atomic_store_long(&user_shared_data->TimeZoneBias.High1Time, timezone_bias >> 32);
+        ATOMIC_STORE(&user_shared_data->TimeZoneBias.High2Time, timezone_bias >> 32);
+        ATOMIC_STORE(&user_shared_data->TimeZoneBias.LowPart, timezone_bias);
+        ATOMIC_STORE(&user_shared_data->TimeZoneBias.High1Time, timezone_bias >> 32);
 
         last_timezone_update = monotonic_time;
     }
 
-    atomic_store_long(&user_shared_data->SystemTime.High2Time, current_time >> 32);
-    atomic_store_ulong(&user_shared_data->SystemTime.LowPart, current_time);
-    atomic_store_long(&user_shared_data->SystemTime.High1Time, current_time >> 32);
-
-    atomic_store_long(&user_shared_data->InterruptTime.High2Time, monotonic_time >> 32);
-    atomic_store_ulong(&user_shared_data->InterruptTime.LowPart, monotonic_time);
-    atomic_store_long(&user_shared_data->InterruptTime.High1Time, monotonic_time >> 32);
-
-    atomic_store_long(&user_shared_data->TickCount.High2Time, tick_count >> 32);
-    atomic_store_ulong(&user_shared_data->TickCount.LowPart, tick_count);
-    atomic_store_long(&user_shared_data->TickCount.High1Time, tick_count >> 32);
-    atomic_store_ulong(&user_shared_data->TickCountLowDeprecated, tick_count);
+    ATOMIC_STORE(&user_shared_data->SystemTime.High2Time, current_time >> 32);
+    ATOMIC_STORE(&user_shared_data->SystemTime.LowPart, current_time);
+    ATOMIC_STORE(&user_shared_data->SystemTime.High1Time, current_time >> 32);
+ 
+    ATOMIC_STORE(&user_shared_data->InterruptTime.High2Time, monotonic_time >> 32);
+    ATOMIC_STORE(&user_shared_data->InterruptTime.LowPart, monotonic_time);
+    ATOMIC_STORE(&user_shared_data->InterruptTime.High1Time, monotonic_time >> 32);
+ 
+    ATOMIC_STORE(&user_shared_data->TickCount.High2Time, tick_count >> 32);
+    ATOMIC_STORE(&user_shared_data->TickCount.LowPart, tick_count);
+    ATOMIC_STORE(&user_shared_data->TickCount.High1Time, tick_count >> 32);
+    ATOMIC_STORE(&user_shared_data->TickCountLowDeprecated, tick_count);
 }
+ 
+#undef ATOMIC_STORE
 
 pthread_mutex_t global_lock = PTHREAD_MUTEX_INITIALIZER;
 int poll_exit_pipe[2];

From f2a1e41f0399cea5f43354e73acd6bdde8f11678 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 4 Mar 2021 10:46:06 +0100
Subject: [PATCH] ntdll: Use rdtsc(p) for RtlQueryPerformanceCounter when
 enabled.

---
 dlls/ntdll/time.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/dlls/ntdll/time.c b/dlls/ntdll/time.c
index 5ff297eedd2..20b720708fd 100644
--- a/dlls/ntdll/time.c
+++ b/dlls/ntdll/time.c
@@ -38,6 +38,7 @@
 #include "wine/exception.h"
 #include "wine/debug.h"
 #include "ntdll_misc.h"
+#include "intrin.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
@@ -382,6 +383,26 @@ LONGLONG WINAPI RtlGetSystemTimePrecise( void )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH RtlQueryPerformanceCounter( LARGE_INTEGER *counter )
 {
+    if (user_shared_data->QpcBypassEnabled & SHARED_GLOBAL_FLAGS_QPC_BYPASS_ENABLED)
+    {
+        unsigned __int64 tsc;
+        unsigned int aux;
+
+        if (user_shared_data->QpcBypassEnabled & SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_RDTSCP)
+            tsc = __rdtscp(&aux);
+        else
+        {
+            if (user_shared_data->QpcBypassEnabled & SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_MFENCE)
+                __asm__ __volatile__ ( "mfence" : : : "memory" );
+            if (user_shared_data->QpcBypassEnabled & SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_LFENCE)
+                __asm__ __volatile__ ( "lfence" : : : "memory" );
+            tsc = __rdtsc();
+        }
+
+        counter->QuadPart = (tsc + user_shared_data->QpcBias) >> user_shared_data->QpcShift;
+        return TRUE;
+    }
+
     NtQueryPerformanceCounter( counter, NULL );
     return TRUE;
 }

From ed295a4afe2556a2d48b072e048ada3b1f41790a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 Nov 2021 21:56:55 +0100
Subject: [PATCH] ntdll: Create and user hypervisor shared data page.

---
 dlls/ntdll/ntdll_misc.h        |  8 ++++
 dlls/ntdll/thread.c            |  1 +
 dlls/ntdll/time.c              | 11 +++++
 dlls/ntdll/unix/loader.c       |  1 +
 dlls/ntdll/unix/system.c       | 12 ++++++
 dlls/ntdll/unix/unix_private.h |  2 +
 dlls/ntdll/unix/virtual.c      | 38 +++++++++++++++++
 programs/wineboot/wineboot.c   | 76 ++++++++++++++++++++++++++++++++++
 server/directory.c             |  3 ++
 server/fd.c                    |  1 +
 server/file.h                  | 10 +++++
 server/mapping.c               | 14 +++++++
 12 files changed, 177 insertions(+)

diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index ad8e2691224..12cb78d02b3 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -89,6 +89,14 @@ extern const WCHAR system_dir[] DECLSPEC_HIDDEN;
 
 extern void (FASTCALL *pBaseThreadInitThunk)(DWORD,LPTHREAD_START_ROUTINE,void *) DECLSPEC_HIDDEN;
 
+struct hypervisor_shared_data
+{
+    UINT64 unknown;
+    UINT64 QpcMultiplier;
+    UINT64 QpcBias;
+};
+
+extern struct hypervisor_shared_data *hypervisor_shared_data DECLSPEC_HIDDEN;
 extern struct _KUSER_SHARED_DATA *user_shared_data DECLSPEC_HIDDEN;
 
 extern int CDECL NTDLL__vsnprintf( char *str, SIZE_T len, const char *format, va_list args ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index e1311570e41..9c850cfe5b1 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -37,6 +37,7 @@ WINE_DECLARE_DEBUG_CHANNEL(pid);
 WINE_DECLARE_DEBUG_CHANNEL(timestamp);
 WINE_DECLARE_DEBUG_CHANNEL(microsecs);
 
+struct hypervisor_shared_data *hypervisor_shared_data = (void *)0x7ffd0000;
 struct _KUSER_SHARED_DATA *user_shared_data = (void *)0x7ffe0000;
 
 struct debug_info
diff --git a/dlls/ntdll/time.c b/dlls/ntdll/time.c
index 20b720708fd..01e6cf02833 100644
--- a/dlls/ntdll/time.c
+++ b/dlls/ntdll/time.c
@@ -378,6 +378,14 @@ LONGLONG WINAPI RtlGetSystemTimePrecise( void )
     return ret;
 }
 
+/* 128-bit multiply a by b and return the high 64 bits, same as __umulh */
+static UINT64 multiply_tsc(UINT64 a, UINT64 b)
+{
+    UINT64 ah = a >> 32, al = (UINT32)a, bh = b >> 32, bl = (UINT32)b, m;
+    m = (ah * bl) + (bh * al) + ((al * bl) >> 32);
+    return (ah * bh) + (m >> 32);
+}
+
 /******************************************************************************
  *  RtlQueryPerformanceCounter   [NTDLL.@]
  */
@@ -399,6 +407,9 @@ BOOL WINAPI DECLSPEC_HOTPATCH RtlQueryPerformanceCounter( LARGE_INTEGER *counter
             tsc = __rdtsc();
         }
 
+        if (user_shared_data->QpcBypassEnabled & SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_HV_PAGE)
+            tsc = multiply_tsc(tsc, hypervisor_shared_data->QpcMultiplier) + hypervisor_shared_data->QpcBias;
+
         counter->QuadPart = (tsc + user_shared_data->QpcBias) >> user_shared_data->QpcShift;
         return TRUE;
     }
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 915f68a6ca2..b7743a58c6b 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -2117,6 +2117,7 @@ static void start_main_thread(int argc, char *argv[])
     dbg_init();
     startup_info_size = server_init_process();
     virtual_map_user_shared_data();
+    virtual_map_hypervisor_shared_data();
     init_cpu_info();
     init_files();
     init_startup_info();
diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index 4fbe45b2dd9..8b961218fdb 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -3262,6 +3262,18 @@ NTSTATUS WINAPI NtQuerySystemInformation( SYSTEM_INFORMATION_CLASS class,
     case SystemCpuSetInformation:  /* 175 */
         return NtQuerySystemInformationEx(class, NULL, 0, info, size, ret_size);
 
+    case SystemHypervisorSharedPageInformation:
+    {
+        len = sizeof(void *);
+        if (size >= len)
+        {
+            if (!info) ret = STATUS_ACCESS_VIOLATION;
+            else *(void **)info = hypervisor_shared_data;
+        }
+        else ret = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+    }
+
     /* Wine extensions */
 
     case SystemWineVersionInformation:  /* 1000 */
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 345d70c9217..30ae0682208 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -172,6 +172,7 @@ extern BOOL process_exiting DECLSPEC_HIDDEN;
 extern HANDLE keyed_event DECLSPEC_HIDDEN;
 extern timeout_t server_start_time DECLSPEC_HIDDEN;
 extern sigset_t server_block_set DECLSPEC_HIDDEN;
+extern void *hypervisor_shared_data DECLSPEC_HIDDEN;
 extern struct _KUSER_SHARED_DATA *user_shared_data DECLSPEC_HIDDEN;
 extern SYSTEM_CPU_INFORMATION cpu_info DECLSPEC_HIDDEN;
 #ifdef __i386__
@@ -249,6 +250,7 @@ extern NTSTATUS virtual_clear_tls_index( ULONG index ) DECLSPEC_HIDDEN;
 extern NTSTATUS virtual_alloc_thread_stack( INITIAL_TEB *stack, ULONG_PTR limit_low, ULONG_PTR limit_high,
                                             SIZE_T reserve_size, SIZE_T commit_size, BOOL guard_page ) DECLSPEC_HIDDEN;
 extern void virtual_map_user_shared_data(void) DECLSPEC_HIDDEN;
+extern void virtual_map_hypervisor_shared_data(void) DECLSPEC_HIDDEN;
 extern NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack ) DECLSPEC_HIDDEN;
 extern unsigned int virtual_locked_server_call( void *req_ptr ) DECLSPEC_HIDDEN;
 extern ssize_t virtual_locked_read( int fd, void *addr, size_t size ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index 934f5118537..e36e6f2068b 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -186,6 +186,7 @@ static void *working_set_limit   = (void *)0x7fff0000;
 static struct file_view *arm64ec_view;
 
 ULONG_PTR user_space_wow_limit = 0;
+void *hypervisor_shared_data = (void *)0x7ffd0000;
 struct _KUSER_SHARED_DATA *user_shared_data = (void *)0x7ffe0000;
 
 /* TEB allocation blocks */
@@ -3415,6 +3416,14 @@ TEB *virtual_alloc_first_teb(void)
         exit(1);
     }
 
+    status = NtAllocateVirtualMemory( NtCurrentProcess(), (void **)&hypervisor_shared_data, 0, &data_size,
+                                      MEM_RESERVE | MEM_COMMIT, PAGE_READONLY );
+    if (status)
+    {
+        ERR( "wine: failed to map the shared user data: %08x\n", status );
+        exit(1);
+    }
+
     NtAllocateVirtualMemory( NtCurrentProcess(), &teb_block, is_win64 ? limit_2g - 1 : 0, &total,
                              MEM_RESERVE | MEM_TOP_DOWN, PAGE_READWRITE );
     teb_block_pos = 30;
@@ -3680,6 +3689,35 @@ static BOOL is_inside_thread_stack( void *ptr, struct thread_stack_info *stack )
 }
 
 
+/***********************************************************************
+ *           virtual_map_hypervisor_shared_data
+ */
+void virtual_map_hypervisor_shared_data(void)
+{
+    static const WCHAR nameW[] = {'\\','K','e','r','n','e','l','O','b','j','e','c','t','s',
+                                  '\\','_','_','w','i','n','e','_','h','y','p','e','r','v','i','s','o','r','_','s','h','a','r','e','d','_','d','a','t','a',0};
+    UNICODE_STRING name_str = { sizeof(nameW) - sizeof(WCHAR), sizeof(nameW), (WCHAR *)nameW };
+    OBJECT_ATTRIBUTES attr = { sizeof(attr), 0, &name_str };
+    NTSTATUS status;
+    HANDLE section;
+    int res, fd, needs_close;
+
+    if ((status = NtOpenSection( &section, SECTION_ALL_ACCESS, &attr )))
+    {
+        ERR( "failed to open the hypervisor shared data section: %#x\n", (int)status );
+        exit(1);
+    }
+    if ((res = server_get_unix_fd( section, 0, &fd, &needs_close, NULL, NULL )) ||
+        (hypervisor_shared_data != mmap( hypervisor_shared_data, page_size, PROT_READ, MAP_SHARED|MAP_FIXED, fd, 0 )))
+    {
+        ERR( "failed to remap the process hypervisor shared data: %d\n", res );
+        exit(1);
+    }
+    if (needs_close) close( fd );
+    NtClose( section );
+}
+
+
 /***********************************************************************
  *           grow_thread_stack
  */
diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index f5612ce310f..a8d3fa7fe69 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -408,6 +408,81 @@ static void initialize_qpc_features( struct _KUSER_SHARED_DATA *data, UINT64 *ts
 
 #endif
 
+struct hypervisor_shared_data
+{
+    UINT64 unknown;
+    UINT64 QpcMultiplier;
+    UINT64 QpcBias;
+};
+
+static UINT64 muldiv_tsc(UINT64 a, UINT64 b, UINT64 c)
+{
+    UINT64 ka = a / c, ra = a % c, kb = b / c, rb = b % c;
+    return ka * kb * c + kb * ra + ka * rb + (ra * rb + c / 2) / c;
+}
+
+static void create_hypervisor_shared_data( DWORD tsc_frequency )
+{
+    struct _KUSER_SHARED_DATA *user_shared_data = (void *)0x7ffe0000;
+    struct hypervisor_shared_data *hypervisor_shared_data;
+    OBJECT_ATTRIBUTES attr = {sizeof(attr)};
+    UNICODE_STRING name;
+    NTSTATUS status;
+    HANDLE handle;
+
+    RtlInitUnicodeString( &name, L"\\KernelObjects\\__wine_hypervisor_shared_data" );
+    InitializeObjectAttributes( &attr, &name, OBJ_OPENIF, NULL, NULL );
+    if ((status = NtOpenSection( &handle, SECTION_ALL_ACCESS, &attr )))
+    {
+        ERR( "cannot open __wine_hypervisor_shared_data, status %#lx\n", status );
+        return;
+    }
+    hypervisor_shared_data = MapViewOfFile( handle, FILE_MAP_WRITE, 0, 0, sizeof(*hypervisor_shared_data) );
+    CloseHandle( handle );
+    if (!hypervisor_shared_data)
+    {
+        ERR( "cannot map __wine_hypervisor_shared_data\n" );
+        return;
+    }
+
+    RtlInitUnicodeString( &name, L"\\KernelObjects\\__wine_user_shared_data" );
+    InitializeObjectAttributes( &attr, &name, OBJ_OPENIF, NULL, NULL );
+    if ((status = NtOpenSection( &handle, SECTION_ALL_ACCESS, &attr )))
+    {
+        ERR( "cannot open __wine_user_shared_data, status %#lx\n", status );
+        UnmapViewOfFile( hypervisor_shared_data );
+        return;
+    }
+    user_shared_data = MapViewOfFile( handle, FILE_MAP_WRITE, 0, 0, sizeof(*user_shared_data) );
+    CloseHandle( handle );
+    if (!user_shared_data)
+    {
+        ERR( "cannot map __wine_user_shared_data\n" );
+        UnmapViewOfFile( hypervisor_shared_data );
+        return;
+    }
+
+    hypervisor_shared_data->unknown = 0;
+    hypervisor_shared_data->QpcMultiplier = 0;
+    hypervisor_shared_data->QpcBias = 0;
+
+    if (user_shared_data->QpcBypassEnabled & SHARED_GLOBAL_FLAGS_QPC_BYPASS_ENABLED)
+    {
+        hypervisor_shared_data->QpcMultiplier = muldiv_tsc((UINT64)5000 << 32, (UINT64)2000 << 32, tsc_frequency);
+        user_shared_data->QpcBypassEnabled |= SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_HV_PAGE;
+        user_shared_data->QpcInterruptTimeIncrement = (ULONGLONG)1 << 63;
+        user_shared_data->QpcInterruptTimeIncrementShift = 1;
+        user_shared_data->QpcSystemTimeIncrement = (ULONGLONG)1 << 63;
+        user_shared_data->QpcSystemTimeIncrementShift = 1;
+        user_shared_data->QpcFrequency = 10000000;
+        user_shared_data->QpcShift = 0;
+        user_shared_data->QpcBias = 0;
+    }
+
+    UnmapViewOfFile( user_shared_data );
+    UnmapViewOfFile( hypervisor_shared_data );
+}
+
 static void create_user_shared_data( UINT64 *tsc_frequency )
 {
     struct _KUSER_SHARED_DATA *data;
@@ -1878,6 +1953,7 @@ int __cdecl main( int argc, char *argv[] )
     ResetEvent( event );  /* in case this is a restart */
 
     create_user_shared_data( &tsc_frequency );
+    create_hypervisor_shared_data( tsc_frequency );
     create_hardware_registry_keys( tsc_frequency );
     create_dynamic_registry_keys();
     create_environment_registry_keys();
diff --git a/server/directory.c b/server/directory.c
index 23d7eb0a2b7..b1e39bf6cab 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -439,8 +439,10 @@ void init_directories( struct fd *intl_fd )
     /* mappings */
     static const WCHAR intlW[] = {'N','l','s','S','e','c','t','i','o','n','L','A','N','G','_','I','N','T','L'};
     static const WCHAR user_dataW[] = {'_','_','w','i','n','e','_','u','s','e','r','_','s','h','a','r','e','d','_','d','a','t','a'};
+    static const WCHAR hypervisor_dataW[] = {'_','_','w','i','n','e','_','h','y','p','e','r','v','i','s','o','r','_','s','h','a','r','e','d','_','d','a','t','a'};
     static const struct unicode_str intl_str = {intlW, sizeof(intlW)};
     static const struct unicode_str user_data_str = {user_dataW, sizeof(user_dataW)};
+    static const struct unicode_str hypervisor_data_str = {hypervisor_dataW, sizeof(hypervisor_dataW)};
 
     struct directory *dir_driver, *dir_device, *dir_global, *dir_kernel, *dir_nls;
     struct object *named_pipe_device, *mailslot_device, *null_device;
@@ -489,6 +491,7 @@ void init_directories( struct fd *intl_fd )
     /* mappings */
     release_object( create_fd_mapping( &dir_nls->obj, &intl_str, intl_fd, OBJ_PERMANENT, NULL ));
     release_object( create_user_data_mapping( &dir_kernel->obj, &user_data_str, OBJ_PERMANENT, NULL ));
+    release_object( create_hypervisor_data_mapping( &dir_kernel->obj, &hypervisor_data_str, OBJ_PERMANENT, NULL ));
     release_object( intl_fd );
 
     release_object( named_pipe_device );
diff --git a/server/fd.c b/server/fd.c
index 60bf98c8938..b2c8d4c8dbd 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -337,6 +337,7 @@ static struct list rel_timeout_list = LIST_INIT(rel_timeout_list); /* sorted rel
 timeout_t current_time;
 timeout_t monotonic_time;
 
+struct hypervisor_shared_data *hypervisor_shared_data = NULL;
 struct _KUSER_SHARED_DATA *user_shared_data = NULL;
 static const int user_shared_data_timeout = 16;
 
diff --git a/server/file.h b/server/file.h
index a43b4afad08..51023da96c8 100644
--- a/server/file.h
+++ b/server/file.h
@@ -134,6 +134,14 @@ static inline struct fd *get_obj_fd( struct object *obj ) { return obj->ops->get
 struct timeout_user;
 extern timeout_t current_time;
 extern timeout_t monotonic_time;
+
+struct hypervisor_shared_data
+{
+    UINT64 unknown;
+    UINT64 QpcMultiplier;
+    UINT64 QpcBias;
+};
+extern struct hypervisor_shared_data *hypervisor_shared_data;
 extern struct _KUSER_SHARED_DATA *user_shared_data;
 
 #define TICKS_PER_SEC 10000000
@@ -184,6 +192,8 @@ extern struct mapping *create_fd_mapping( struct object *root, const struct unic
                                           unsigned int attr, const struct security_descriptor *sd );
 extern struct object *create_user_data_mapping( struct object *root, const struct unicode_str *name,
                                                 unsigned int attr, const struct security_descriptor *sd );
+extern struct object *create_hypervisor_data_mapping( struct object *root, const struct unicode_str *name,
+                                                      unsigned int attr, const struct security_descriptor *sd );
 
 /* device functions */
 
diff --git a/server/mapping.c b/server/mapping.c
index 5d4df2050e4..281d797dd37 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -1126,6 +1126,20 @@ struct object *create_user_data_mapping( struct object *root, const struct unico
     return &mapping->obj;
 }
 
+struct object *create_hypervisor_data_mapping( struct object *root, const struct unicode_str *name,
+                                               unsigned int attr, const struct security_descriptor *sd )
+{
+    void *ptr;
+    struct mapping *mapping;
+
+    if (!(mapping = create_mapping( root, name, attr, sizeof(struct hypervisor_shared_data),
+                                    SEC_COMMIT, 0, FILE_READ_DATA | FILE_WRITE_DATA, sd ))) return NULL;
+    ptr = mmap( NULL, mapping->size, PROT_WRITE, MAP_SHARED, get_unix_fd( mapping->fd ), 0 );
+    if (ptr != MAP_FAILED)
+        hypervisor_shared_data = ptr;
+    return &mapping->obj;
+}
+
 /* create a file mapping */
 DECL_HANDLER(create_mapping)
 {

From 98fd80a14e1c1e2ba78ff75340069cc2f6527ec2 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Fri, 8 Sep 2023 16:07:21 +0200
Subject: [PATCH 1001/2] ntdll: Add __wine_get_tsc_calibration internal function.

---
 dlls/ntdll/ntdll.spec          |   3 +
 dlls/ntdll/time.c              |  14 +++
 dlls/ntdll/unix/loader.c       |   2 +
 dlls/ntdll/unix/sync.c         | 162 +++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/unix_private.h |   1 +
 dlls/ntdll/unixlib.h           |   7 ++
 include/winternl.h             |   1 +
 7 files changed, 190 insertions(+)

diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 11111111111..11111111111 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -1733,3 +1733,6 @@
 # Filesystem
 @ stdcall -syscall wine_nt_to_unix_file_name(ptr ptr ptr long)
 @ stdcall -syscall wine_unix_to_nt_file_name(str ptr ptr)
+
+# Time
+@ cdecl __wine_get_tsc_calibration(ptr ptr)
diff --git a/dlls/ntdll/time.c b/dlls/ntdll/time.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/time.c
+++ b/dlls/ntdll/time.c
@@ -427,6 +427,20 @@ BOOL WINAPI DECLSPEC_HOTPATCH RtlQueryPerformanceFrequency( LARGE_INTEGER *frequ
     return TRUE;
 }
 
+/***********************************************************************
+ *  __wine_get_tsc_calibration   [NTDLL.@]
+ */
+NTSTATUS __cdecl __wine_get_tsc_calibration( ULONGLONG *frequency, LONGLONG *offset )
+{
+    struct wine_get_tsc_calibration_params params = { 0 };
+    NTSTATUS ret;
+
+    ret = WINE_UNIX_CALL( unix_wine_get_tsc_calibration, &params );
+    *frequency = params.frequency;
+    *offset = params.offset;
+    return ret;
+}
+
 /******************************************************************************
  * NtGetTickCount   (NTDLL.@)
  * ZwGetTickCount   (NTDLL.@)
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -1262,6 +1262,7 @@ static const unixlib_entry_t unix_call_funcs[] =
     load_so_dll,
     unwind_builtin_dll,
     unixcall_wine_dbg_write,
+    unixcall_wine_get_tsc_calibration,
     unixcall_wine_needs_override_large_address_aware,
     unixcall_wine_server_call,
     unixcall_wine_server_fd_to_handle,
@@ -1281,6 +1282,7 @@ const unixlib_entry_t unix_call_wow64_funcs[] =
     wow64_load_so_dll,
     wow64_unwind_builtin_dll,
     wow64_wine_dbg_write,
+    unixcall_wine_get_tsc_calibration,
     wow64_wine_server_call,
     wow64_wine_server_fd_to_handle,
     wow64_wine_server_handle_to_fd,
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -54,6 +54,9 @@
 # include <mach/semaphore.h>
 # include <mach/mach_time.h>
 #endif
+#ifdef __linux__
+# include <linux/perf_event.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -1840,6 +1843,165 @@ NTSTATUS system_time_precise( void *args )
 }
 
 
+#ifdef __linux__
+
+static inline int perf_event_open( struct perf_event_attr *attr, pid_t pid, int cpu, int group_fd, unsigned long flags )
+{
+    return syscall( __NR_perf_event_open, attr, pid, cpu, group_fd, flags );
+}
+
+/* 128-bit multiply a by b and return the high 64 bits, same as __umulh */
+static UINT64 multiply_tsc( UINT64 a, UINT64 b )
+{
+    UINT64 ah = a >> 32, al = (UINT32)a, bh = b >> 32, bl = (UINT32)b, m;
+    m = (ah * bl) + (bh * al) + ((al * bl) >> 32);
+    return (ah * bh) + (m >> 32);
+}
+
+static UINT64 muldiv_tsc( UINT64 a, UINT64 b, UINT64 c )
+{
+    UINT64 ka = a / c, ra = a % c, kb = b / c, rb = b % c;
+    return ka * kb * c + kb * ra + ka * rb + (ra * rb + c / 2) / c;
+}
+
+static UINT64 do_rdtsc(void)
+{
+    UINT64 ret;
+    __asm__ __volatile__( "" : : : "memory" );
+    if ((user_shared_data->QpcBypassEnabled & SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_RDTSCP))
+    {
+        unsigned int aux;
+        ret = __builtin_ia32_rdtscp( &aux );
+    }
+    else
+    {
+        if ((user_shared_data->QpcBypassEnabled & SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_LFENCE))
+            __asm__ __volatile__ ( "lfence" : : : "memory" );
+        if ((user_shared_data->QpcBypassEnabled & SHARED_GLOBAL_FLAGS_QPC_BYPASS_USE_MFENCE))
+            __asm__ __volatile__ ( "mfence" : : : "memory" );
+        ret = __builtin_ia32_rdtsc();
+    }
+    __asm__ __volatile__( "" : : : "memory" );
+    return ret;
+}
+
+static NTSTATUS map_perf_event_mmap_page( struct perf_event_mmap_page **addr )
+{
+    struct perf_event_attr attr;
+    int fd;
+
+    memset( &attr, 0, sizeof(attr) );
+    attr.type = PERF_TYPE_SOFTWARE;
+    attr.size = sizeof(attr);
+    attr.config = PERF_COUNT_SW_DUMMY;
+    attr.disabled = 1;
+    attr.exclude_kernel = 1;
+    attr.exclude_hv = 1;
+    attr.exclude_host = 1;
+    attr.remove_on_exec = 1;
+    fd = perf_event_open( &attr, 0, -1, -1, PERF_FLAG_FD_CLOEXEC );
+    if (fd == -1)
+    {
+        fd = perf_event_open( &attr, 0, -1, -1, 0 );
+        if (fd != -1)
+            fcntl( fd, F_SETFD, FD_CLOEXEC );
+    }
+    if (fd == -1)
+        return errno_to_status( errno );
+    *addr = mmap( NULL, page_size, PROT_READ, MAP_SHARED, fd, 0 );
+    close( fd );
+    if (*addr == MAP_FAILED)
+        return errno_to_status( errno );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS get_time_shift_mult( struct perf_event_mmap_page *page, __u32 *time_mult, __u16 *time_shift )
+{
+    BOOL user_time_supported;
+    __u32 seq;
+
+    /* See linux/perf_event.h */
+    do
+    {
+        while (((seq = page->lock) % 2)) YieldProcessor();
+        __asm__ __volatile__( "" : : : "memory" );
+        user_time_supported = page->cap_user_time && !page->cap_user_time_short;
+        if (user_time_supported)
+        {
+            *time_mult = page->time_mult;
+            *time_shift = page->time_shift;
+        }
+        __asm__ __volatile__( "" : : : "memory" );
+    } while (page->lock != seq);
+    if (!user_time_supported)
+        return STATUS_NOT_SUPPORTED;
+    return STATUS_SUCCESS;
+}
+
+#define hz_from_shift_mult(mul,sft) muldiv_tsc( 1000000000, (__u32)1 << (sft), (mul) )
+#define timespec_to_ns(ts) ((ts)->tv_sec * 1000000000 + (ts)->tv_nsec)
+
+static int monotonic_time_raw( struct timespec *ts )
+{
+#ifdef HAVE_CLOCK_GETTIME
+    ULONGLONG ticks;
+#ifdef CLOCK_MONOTONIC_RAW
+    if (!clock_gettime( CLOCK_MONOTONIC_RAW, ts ))
+        return 0;
+#endif
+    return clock_gettime( CLOCK_MONOTONIC, ts );
+#endif
+    return -ENOTSUP;
+}
+
+NTSTATUS unixcall_wine_get_tsc_calibration( void *args )
+{
+    UINT64 tsc_freq, tsc1, tsc2, clock_ts, tsc_ts;
+    struct wine_get_tsc_calibration_params *ret = args;
+    struct perf_event_mmap_page *page;
+    struct timespec ts;
+    __u16 time_shift;
+    __u32 time_mult;
+    NTSTATUS s;
+
+    if (monotonic_time_raw( &ts ))
+        return STATUS_NOT_SUPPORTED;
+
+    s = map_perf_event_mmap_page( &page );
+    if (s)
+        return s;
+    s = get_time_shift_mult( page, &time_mult, &time_shift );
+    munmap( page, page_size );
+    if (s)
+        return s;
+
+    tsc_freq = hz_from_shift_mult( time_mult, time_shift ) + 500;
+    tsc_freq = tsc_freq - tsc_freq % 1000;
+
+    /* Duplicated deliberately, affects timing in the .1 us range */
+    tsc1 = do_rdtsc();
+    monotonic_time_raw( &ts );
+    tsc1 = do_rdtsc();
+    monotonic_time_raw( &ts );
+    tsc2 = do_rdtsc();
+    clock_ts = timespec_to_ns(&ts);
+    tsc_ts = multiply_tsc( tsc1 + tsc2, muldiv_tsc( (UINT64)(50000 / 2) << 32, (UINT64)20000 << 32, tsc_freq ) );
+
+    ret->frequency = tsc_freq;
+    ret->offset = (INT64)(clock_ts - tsc_ts + 50) / 100;
+    return STATUS_SUCCESS;
+}
+
+#else
+
+NTSTATUS unixcall_wine_get_tsc_calibration( void *args )
+{
+    return STATUS_NOT_SUPPORTED;
+}
+
+#endif /* defined(__linux__) */
+
+
 /******************************************************************************
  *              NtCreateKeyedEvent (NTDLL.@)
  */
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -327,6 +327,7 @@ extern void add_completion( HANDLE handle, ULONG_PTR value, NTSTATUS status, ULO
 extern void set_async_direct_result( HANDLE *async_handle, NTSTATUS status, ULONG_PTR information, BOOL mark_pending ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS unixcall_wine_dbg_write( void *args ) DECLSPEC_HIDDEN;
+extern NTSTATUS unixcall_wine_get_tsc_calibration( void *args ) DECLSPEC_HIDDEN;
 extern NTSTATUS unixcall_wine_needs_override_large_address_aware( void *args ) DECLSPEC_HIDDEN;
 extern NTSTATUS unixcall_wine_server_call( void *args ) DECLSPEC_HIDDEN;
 extern NTSTATUS unixcall_wine_server_fd_to_handle( void *args ) DECLSPEC_HIDDEN;
diff --git a/dlls/ntdll/unixlib.h b/dlls/ntdll/unixlib.h
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unixlib.h
+++ b/dlls/ntdll/unixlib.h
@@ -31,6 +31,12 @@ struct wine_dbg_write_params
     unsigned int len;
 };
 
+struct wine_get_tsc_calibration_params
+{
+    ULONGLONG frequency;
+    LONGLONG offset;
+};
+
 struct wine_server_fd_to_handle_params
 {
     int          fd;
@@ -71,6 +77,7 @@ enum ntdll_unix_funcs
     unix_load_so_dll,
     unix_unwind_builtin_dll,
     unix_wine_dbg_write,
+    unix_wine_get_tsc_calibration,
     unix_wine_needs_override_large_address_aware,
     unix_wine_server_call,
     unix_wine_server_fd_to_handle,
diff --git a/include/winternl.h b/include/winternl.h
index 11111111111..11111111111 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -5180,6 +5180,7 @@ static inline PLIST_ENTRY RemoveTailList(PLIST_ENTRY le)
 /* Wine internal functions */
 
 extern NTSTATUS WINAPI __wine_unix_spawnvp( char * const argv[], int wait );
+extern NTSTATUS __cdecl __wine_get_tsc_calibration( ULONGLONG *frequency, LONGLONG *offset );
 
 /* The thread information for 16-bit threads */
 /* NtCurrentTeb()->SubSystemTib points to this */
-- 
0.0.0

