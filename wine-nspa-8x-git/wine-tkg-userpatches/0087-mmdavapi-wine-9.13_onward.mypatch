From eef4a25d0cfe4ffbb703a07692360e7a8d2e07cb Mon Sep 17 00:00:00 2001
From: David McFarland <corngood@gmail.com>
Date: Fri, 11 Aug 2023 23:13:11 -0300
Subject: [PATCH 1/5] mmdevapi/tests: Add test for
 AudioClient3_InitializeSharedAudioStream.

---
 dlls/mmdevapi/tests/render.c | 22 +++++++++++++++++++++-
 1 file changed, 21 insertions(+), 1 deletion(-)

diff --git a/dlls/mmdevapi/tests/render.c b/dlls/mmdevapi/tests/render.c
index 3e24ac45944..fac88e211e4 100644
--- a/dlls/mmdevapi/tests/render.c
+++ b/dlls/mmdevapi/tests/render.c
@@ -341,8 +341,28 @@ static void test_audioclient(void)
             broken(hr == E_NOINTERFACE) /* win8 */,
             "Failed to query IAudioClient3 interface: %08lx\n", hr);
 
-    if(hr == S_OK)
+    if(hr == S_OK){
+        UINT32 default_period = 0, unit_period, min_period, max_period;
+
+        hr = IAudioClient3_GetSharedModeEnginePeriod(
+            ac3, pwfx, &default_period, &unit_period, &min_period, &max_period);
+        todo_wine
+        ok(hr == S_OK, "GetSharedModeEnginePeriod returns %08lx\n", hr);
+
+        hr = IAudioClient3_InitializeSharedAudioStream(
+            ac3, AUDCLNT_SHAREMODE_SHARED, default_period, pwfx, NULL);
+        todo_wine
+        ok(hr == S_OK, "InitializeSharedAudioStream returns %08lx\n", hr);
+
         IAudioClient3_Release(ac3);
+        IAudioClient_Release(ac);
+
+        hr = IMMDevice_Activate(dev, &IID_IAudioClient, CLSCTX_INPROC_SERVER,
+                NULL, (void**)&ac);
+        ok(hr == S_OK, "Activation failed with %08lx\n", hr);
+    }
+    else
+        win_skip("IAudioClient3 is not present\n");
 
     test_uninitialized(ac);
 
-- 
GitLab


From 73a6f764d08e24ad06433816408f9bb39fdaa4f1 Mon Sep 17 00:00:00 2001
From: David McFarland <corngood@gmail.com>
Date: Sat, 12 Aug 2023 00:11:49 -0300
Subject: [PATCH 2/5] mmdevapi: Implement
 IAudioClient3_InitializeSharedAudioStream.

---
 dlls/mmdevapi/client.c       | 10 ++++++++--
 dlls/mmdevapi/tests/render.c |  1 -
 2 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index 3e0c70a44f4..5d71f079483 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -950,8 +950,14 @@ static HRESULT WINAPI client_InitializeSharedAudioStream(IAudioClient3 *iface, D
                                                   const GUID *session_guid)
 {
     struct audio_client *This = impl_from_IAudioClient3(iface);
-    FIXME("(%p)->(0x%lx, %u, %p, %s) - stub\n", This, flags, period_frames, format, debugstr_guid(session_guid));
-    return E_NOTIMPL;
+    REFERENCE_TIME duration;
+    FIXME("(%p)->(0x%lx, %u, %p, %s) - partial stub\n", This, flags, period_frames, format, debugstr_guid(session_guid));
+
+    if (!format)
+        return E_POINTER;
+
+    duration = period_frames * (REFERENCE_TIME)10000000 / format->nSamplesPerSec;
+    return client_Initialize(iface, AUDCLNT_SHAREMODE_SHARED, flags, duration, 0, format, session_guid);
 }
 
 const IAudioClient3Vtbl AudioClient3_Vtbl =
diff --git a/dlls/mmdevapi/tests/render.c b/dlls/mmdevapi/tests/render.c
index fac88e211e4..14442036763 100644
--- a/dlls/mmdevapi/tests/render.c
+++ b/dlls/mmdevapi/tests/render.c
@@ -351,7 +351,6 @@ static void test_audioclient(void)
 
         hr = IAudioClient3_InitializeSharedAudioStream(
             ac3, AUDCLNT_SHAREMODE_SHARED, default_period, pwfx, NULL);
-        todo_wine
         ok(hr == S_OK, "InitializeSharedAudioStream returns %08lx\n", hr);
 
         IAudioClient3_Release(ac3);
-- 
GitLab


From a30a617212788e92a7684cd861634c6bc4a8e0e0 Mon Sep 17 00:00:00 2001
From: David McFarland <corngood@gmail.com>
Date: Sat, 12 Aug 2023 00:11:49 -0300
Subject: [PATCH 3/5] mmdevapi: Implement
 IAudioClient3_GetSharedModeEnginePeriod.

For now min/max/default are all hard-coded to ~10ms.
---
 dlls/mmdevapi/client.c       | 15 +++++++++++----
 dlls/mmdevapi/tests/render.c |  1 -
 2 files changed, 11 insertions(+), 5 deletions(-)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index 5d71f079483..e0c12b8e534 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -929,10 +929,17 @@ static HRESULT WINAPI client_GetSharedModeEnginePeriod(IAudioClient3 *iface,
                                                 UINT32 *max_period_frames)
 {
     struct audio_client *This = impl_from_IAudioClient3(iface);
-    FIXME("(%p)->(%p, %p, %p, %p, %p) - stub\n", This, format, default_period_frames,
-                                                 unit_period_frames, min_period_frames,
-                                                 max_period_frames);
-    return E_NOTIMPL;
+    FIXME("(%p)->(%p, %p, %p, %p, %p) - partial stub\n",
+          This, format, default_period_frames,
+          unit_period_frames, min_period_frames,
+          max_period_frames);
+
+    *default_period_frames =
+        *min_period_frames =
+        *max_period_frames =
+        format->nSamplesPerSec / 100; /* ~10ms */
+    *unit_period_frames = 1;
+    return S_OK;
 }
 
 static HRESULT WINAPI client_GetCurrentSharedModeEnginePeriod(IAudioClient3 *iface,
diff --git a/dlls/mmdevapi/tests/render.c b/dlls/mmdevapi/tests/render.c
index 14442036763..a7da68ec3f1 100644
--- a/dlls/mmdevapi/tests/render.c
+++ b/dlls/mmdevapi/tests/render.c
@@ -346,7 +346,6 @@ static void test_audioclient(void)
 
         hr = IAudioClient3_GetSharedModeEnginePeriod(
             ac3, pwfx, &default_period, &unit_period, &min_period, &max_period);
-        todo_wine
         ok(hr == S_OK, "GetSharedModeEnginePeriod returns %08lx\n", hr);
 
         hr = IAudioClient3_InitializeSharedAudioStream(
-- 
GitLab


From ec2db2ff754055515b1485496cb9415e9a7d2afd Mon Sep 17 00:00:00 2001
From: David McFarland <corngood@gmail.com>
Date: Sat, 12 Aug 2023 00:50:44 -0300
Subject: [PATCH 4/5] mmdevapi/tests: Add test for IDeviceTopology.

---
 dlls/mmdevapi/tests/mmdevenum.c | 68 +++++++++++++++++++++++++++++++++
 1 file changed, 68 insertions(+)

diff --git a/dlls/mmdevapi/tests/mmdevenum.c b/dlls/mmdevapi/tests/mmdevenum.c
index a5b692a53ee..f34386a575a 100644
--- a/dlls/mmdevapi/tests/mmdevenum.c
+++ b/dlls/mmdevapi/tests/mmdevenum.c
@@ -29,6 +29,7 @@
 #include "dshow.h"
 #include "dsound.h"
 #include "devpkey.h"
+#include "devicetopology.h"
 
 DEFINE_GUID(GUID_NULL,0,0,0,0,0,0,0,0,0,0,0);
 
@@ -382,6 +383,71 @@ static IMMNotificationClientVtbl notif_vtbl = {
 
 static IMMNotificationClient notif = { &notif_vtbl };
 
+static void test_connectors(IDeviceTopology *dt)
+{
+    HRESULT hr;
+    UINT connector_count;
+
+    hr = IDeviceTopology_GetConnectorCount(dt, &connector_count);
+    ok(hr == S_OK, "GetConnectorCount returns 0x%08lx\n", hr);
+    trace("connector count: %u\n", connector_count);
+
+    if (hr == S_OK && connector_count > 0)
+    {
+        IConnector *connector;
+
+        hr = IDeviceTopology_GetConnector(dt, 0, &connector);
+        ok(hr == S_OK, "GetConnector returns 0x%08lx\n", hr);
+
+        if (hr == S_OK)
+        {
+            ConnectorType type;
+
+            hr = IConnector_GetType(connector, &type);
+            ok(hr == S_OK, "GetConnector returns 0x%08lx\n", hr);
+            trace("connector 0 type: %u\n", connector_count);
+        }
+    }
+}
+
+static void test_DeviceTopology(IMMDeviceEnumerator *mme)
+{
+    IMMDevice *dev = NULL;
+    IDeviceTopology *dt = NULL;
+    HRESULT hr;
+
+    hr = IMMDeviceEnumerator_GetDefaultAudioEndpoint(mme, eRender, eMultimedia, &dev);
+    ok(hr == S_OK || hr == E_NOTFOUND, "GetDefaultAudioEndpoint failed: 0x%08lx\n", hr);
+    if (hr != S_OK || !dev)
+    {
+        if (hr == E_NOTFOUND)
+            win_skip("No sound card available\n");
+        else
+            skip("GetDefaultAudioEndpoint returns 0x%08lx\n", hr);
+        goto cleanup;
+    }
+
+    hr = IMMDevice_Activate(dev, &IID_IDeviceTopology, CLSCTX_INPROC_SERVER, NULL, (void**)&dt);
+    ok(hr == S_OK || hr == E_NOINTERFACE, "IDeviceTopology Activation failed: 0x%08lx\n", hr);
+    if (hr != S_OK || !dev)
+    {
+        if (hr == E_NOINTERFACE)
+            todo_wine
+            win_skip("IDeviceTopology interface not found\n");
+        else
+            skip("IDeviceTopology Activation returns 0x%08lx\n", hr);
+        goto cleanup;
+    }
+
+    test_connectors(dt);
+
+    IDeviceTopology_Release(dt);
+
+cleanup:
+    if (dev)
+        IMMDevice_Release(dev);
+}
+
 /* Only do parameter tests here, the actual MMDevice testing should be a separate test */
 START_TEST(mmdevenum)
 {
@@ -478,6 +544,8 @@ START_TEST(mmdevenum)
     hr = IMMDeviceEnumerator_UnregisterEndpointNotificationCallback(mme, &notif);
     ok(hr == E_NOTFOUND, "UnregisterEndpointNotificationCallback failed: %08lx\n", hr);
 
+    test_DeviceTopology(mme);
+
     IMMDeviceEnumerator_Release(mme);
 
     test_ActivateAudioInterfaceAsync();
-- 
GitLab


From 1496ce16147dfee4048dfa3ad6f8d758b0f9f691 Mon Sep 17 00:00:00 2001
From: David McFarland <corngood@gmail.com>
Date: Sat, 12 Aug 2023 00:50:24 -0300
Subject: [PATCH 5/5] mmdevapi: Add stub for IDeviceTopology.

---
 dlls/mmdevapi/devenum.c         | 298 +++++++++++++++++++++++++++++++-
 dlls/mmdevapi/tests/mmdevenum.c |   1 -
 2 files changed, 297 insertions(+), 2 deletions(-)

diff --git a/dlls/mmdevapi/devenum.c b/dlls/mmdevapi/devenum.c
index 3c2085339ed..66f954fad44 100644
--- a/dlls/mmdevapi/devenum.c
+++ b/dlls/mmdevapi/devenum.c
@@ -87,6 +87,16 @@ typedef struct IPropertyBagImpl {
 
 static const IPropertyBagVtbl PB_Vtbl;
 
+typedef struct IConnectorImpl {
+    IConnector IConnector_iface;
+    LONG ref;
+} IConnectorImpl;
+
+typedef struct IDeviceTopologyImpl {
+    IDeviceTopology IDeviceTopology_iface;
+    LONG ref;
+} IDeviceTopologyImpl;
+
 static HRESULT MMDevPropStore_Create(MMDevice *This, DWORD access, IPropertyStore **ppv);
 
 static inline MMDevPropStore *impl_from_IPropertyStore(IPropertyStore *iface)
@@ -109,6 +119,18 @@ static inline IPropertyBagImpl *impl_from_IPropertyBag(IPropertyBag *iface)
     return CONTAINING_RECORD(iface, IPropertyBagImpl, IPropertyBag_iface);
 }
 
+static HRESULT DeviceTopology_Create(IMMDevice *device, IDeviceTopology **ppv);
+
+static inline IConnectorImpl *impl_from_IConnector(IConnector *iface)
+{
+    return CONTAINING_RECORD(iface, IConnectorImpl, IConnector_iface);
+}
+
+static inline IDeviceTopologyImpl *impl_from_IDeviceTopology(IDeviceTopology *iface)
+{
+    return CONTAINING_RECORD(iface, IDeviceTopologyImpl, IDeviceTopology_iface);
+}
+
 static const WCHAR propkey_formatW[] = L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X},%d";
 
 static HRESULT MMDevPropStore_OpenPropKey(const GUID *guid, DWORD flow, HKEY *propkey)
@@ -667,7 +689,7 @@ static HRESULT WINAPI MMDevice_Activate(IMMDevice *iface, REFIID riid, DWORD cls
     }
     else if (IsEqualIID(riid, &IID_IDeviceTopology))
     {
-        FIXME("IID_IDeviceTopology unsupported\n");
+        hr = DeviceTopology_Create(iface, (IDeviceTopology**)ppv);
     }
     else if (IsEqualIID(riid, &IID_IDirectSound)
              || IsEqualIID(riid, &IID_IDirectSound8))
@@ -1660,3 +1682,277 @@ static const IMMDeviceVtbl info_device_Vtbl =
 static IMMDevice info_device = {
     &info_device_Vtbl
 };
+
+static HRESULT WINAPI Connector_QueryInterface(IConnector *iface, REFIID riid, void **ppv)
+{
+    IConnectorImpl *This = impl_from_IConnector(iface);
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IConnector))
+        *ppv = &This->IConnector_iface;
+    else {
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+
+    return S_OK;
+}
+
+static ULONG WINAPI Connector_AddRef(IConnector *iface)
+{
+    IConnectorImpl *This = impl_from_IConnector(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) new ref %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI Connector_Release(IConnector *iface)
+{
+    IConnectorImpl *This = impl_from_IConnector(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) new ref %lu\n", This, ref);
+
+    if (!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+
+    return ref;
+}
+
+static HRESULT WINAPI Connector_GetType(
+    IConnector *This,
+    ConnectorType *pType)
+{
+    FIXME("(%p) - partial stub\n", This);
+    *pType = Physical_Internal;
+    return S_OK;
+}
+
+static HRESULT WINAPI Connector_GetDataFlow(
+    IConnector *This,
+    DataFlow *pFlow)
+{
+    FIXME("(%p) - stub\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI Connector_ConnectTo(
+    IConnector *This,
+    IConnector *pConnectTo)
+{
+    FIXME("(%p) - stub\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI Connector_Disconnect(
+    IConnector *This)
+{
+    FIXME("(%p) - stub\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI Connector_IsConnected(
+    IConnector *This,
+    BOOL *pbConnected)
+{
+    FIXME("(%p) - stub\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI Connector_GetConnectedTo(
+    IConnector *This,
+    IConnector **ppConTo)
+{
+    FIXME("(%p) - stub\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI Connector_GetConnectorIdConnectedTo(
+    IConnector *This,
+    LPWSTR *ppwstrConnectorId)
+{
+    FIXME("(%p) - stub\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI Connector_GetDeviceIdConnectedTo(
+    IConnector *This,
+    LPWSTR *ppwstrDeviceId)
+{
+    FIXME("(%p) - stub\n", This);
+    return E_NOTIMPL;
+}
+
+static const IConnectorVtbl Connector_Vtbl =
+{
+    Connector_QueryInterface,
+    Connector_AddRef,
+    Connector_Release,
+    Connector_GetType,
+    Connector_GetDataFlow,
+    Connector_ConnectTo,
+    Connector_Disconnect,
+    Connector_IsConnected,
+    Connector_GetConnectedTo,
+    Connector_GetConnectorIdConnectedTo,
+    Connector_GetDeviceIdConnectedTo,
+};
+
+HRESULT Connector_Create(IConnector **ppv)
+{
+    IConnectorImpl *This;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    if (!This)
+        return E_OUTOFMEMORY;
+
+    This->IConnector_iface.lpVtbl = &Connector_Vtbl;
+    This->ref = 1;
+
+    *ppv = &This->IConnector_iface;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI DT_QueryInterface(IDeviceTopology *iface, REFIID riid, void **ppv)
+{
+    IDeviceTopologyImpl *This = impl_from_IDeviceTopology(iface);
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+        IsEqualIID(riid, &IID_IDeviceTopology))
+        *ppv = &This->IDeviceTopology_iface;
+    else {
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+
+    return S_OK;
+}
+
+static ULONG WINAPI DT_AddRef(IDeviceTopology *iface)
+{
+    IDeviceTopologyImpl *This = impl_from_IDeviceTopology(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) new ref %lu\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI DT_Release(IDeviceTopology *iface)
+{
+    IDeviceTopologyImpl *This = impl_from_IDeviceTopology(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) new ref %lu\n", This, ref);
+
+    if (!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+
+    return ref;
+}
+
+static HRESULT WINAPI DT_GetConnectorCount(IDeviceTopology *This,
+                                           UINT *pCount)
+{
+    FIXME("(%p)->(%p) - partial stub\n", This, pCount);
+
+    if (!pCount)
+        return E_POINTER;
+
+    *pCount = 1;
+    return S_OK;
+}
+
+static HRESULT WINAPI DT_GetConnector(IDeviceTopology *This,
+                                      UINT nIndex,
+                                      IConnector **ppConnector)
+{
+    FIXME("(%p)->(%u, %p) - partial stub\n", This, nIndex, ppConnector);
+
+    if (nIndex == 0)
+    {
+        return Connector_Create(ppConnector);
+    }
+
+    return E_INVALIDARG;
+}
+
+static HRESULT WINAPI DT_GetSubunitCount(IDeviceTopology *This,
+                                         UINT *pCount)
+{
+    FIXME("(%p)->(%p) - stub\n", This, pCount);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DT_GetSubunit(IDeviceTopology *This,
+                                    UINT nIndex,
+                                    ISubUnit **ppConnector)
+{
+    FIXME("(%p)->(%u, %p) - stub\n", This, nIndex, ppConnector);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DT_GetPartById(IDeviceTopology *This,
+                                     UINT nId,
+                                     IPart **ppPart)
+{
+    FIXME("(%p)->(%u, %p) - stub\n", This, nId, ppPart);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DT_GetDeviceId(IDeviceTopology *This,
+                                     LPWSTR *ppwstrDeviceId)
+{
+    FIXME("(%p)->(%p) - stub\n", This, ppwstrDeviceId);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI DT_GetSignalPath(IDeviceTopology *This,
+                                       IPart *pIPartFrom,
+                                       IPart *pIPartTo,
+                                       BOOL bRejectMixedPaths,
+                                       IPartsList **ppParts)
+{
+    FIXME("(%p)->(%p, %p, %s, %p) - stub\n",
+          This, pIPartFrom, pIPartTo, bRejectMixedPaths ? "TRUE" : "FALSE", ppParts);
+    return E_NOTIMPL;
+}
+
+static const IDeviceTopologyVtbl DeviceTopology_Vtbl =
+{
+    DT_QueryInterface,
+    DT_AddRef,
+    DT_Release,
+    DT_GetConnectorCount,
+    DT_GetConnector,
+    DT_GetSubunitCount,
+    DT_GetSubunit,
+    DT_GetPartById,
+    DT_GetDeviceId,
+    DT_GetSignalPath,
+};
+
+static HRESULT DeviceTopology_Create(IMMDevice *device, IDeviceTopology **ppv)
+{
+    IDeviceTopologyImpl *This;
+
+    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    if (!This)
+        return E_OUTOFMEMORY;
+
+    This->IDeviceTopology_iface.lpVtbl = &DeviceTopology_Vtbl;
+    This->ref = 1;
+
+    *ppv = &This->IDeviceTopology_iface;
+
+    return S_OK;
+}
diff --git a/dlls/mmdevapi/tests/mmdevenum.c b/dlls/mmdevapi/tests/mmdevenum.c
index f34386a575a..3bceefb91a3 100644
--- a/dlls/mmdevapi/tests/mmdevenum.c
+++ b/dlls/mmdevapi/tests/mmdevenum.c
@@ -432,7 +432,6 @@ static void test_DeviceTopology(IMMDeviceEnumerator *mme)
     if (hr != S_OK || !dev)
     {
         if (hr == E_NOINTERFACE)
-            todo_wine
             win_skip("IDeviceTopology interface not found\n");
         else
             skip("IDeviceTopology Activation returns 0x%08lx\n", hr);
-- 
GitLab

From d86627a27af1e69f08b1d2a9e10dd93804d88b2c Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Thu, 21 Mar 2024 11:48:32 -0700
Subject: [PATCH] mmdevapi: Make IMMDeviceCollection immutable after creation.

---
 dlls/mmdevapi/devenum.c | 70 ++++++++++++++++++++++++++---------------
 1 file changed, 44 insertions(+), 26 deletions(-)

diff --git a/dlls/mmdevapi/devenum.c b/dlls/mmdevapi/devenum.c
index 66f954fad44..52c88ad0a03 100644
--- a/dlls/mmdevapi/devenum.c
+++ b/dlls/mmdevapi/devenum.c
@@ -76,8 +76,8 @@ typedef struct MMDevColImpl
 {
     IMMDeviceCollection IMMDeviceCollection_iface;
     LONG ref;
-    EDataFlow flow;
-    DWORD state;
+    IMMDevice **devices;
+    UINT devices_count;
 } MMDevColImpl;
 
 typedef struct IPropertyBagImpl {
@@ -827,6 +827,8 @@ static const IMMEndpointVtbl MMEndpointVtbl =
 static HRESULT MMDevCol_Create(IMMDeviceCollection **ppv, EDataFlow flow, DWORD state)
 {
     MMDevColImpl *This;
+    MMDevice *cur;
+    UINT i = 0;
 
     This = malloc(sizeof(*This));
     *ppv = NULL;
@@ -834,14 +836,43 @@ static HRESULT MMDevCol_Create(IMMDeviceCollection **ppv, EDataFlow flow, DWORD
         return E_OUTOFMEMORY;
     This->IMMDeviceCollection_iface.lpVtbl = &MMDevColVtbl;
     This->ref = 1;
-    This->flow = flow;
-    This->state = state;
+    This->devices = NULL;
+    This->devices_count = 0;
     *ppv = &This->IMMDeviceCollection_iface;
+
+    LIST_FOR_EACH_ENTRY(cur, &device_list, MMDevice, entry)
+    {
+        if ((cur->flow == flow || flow == eAll) && (cur->state & state))
+            This->devices_count++;
+    }
+
+    if (This->devices_count)
+    {
+        This->devices = malloc(This->devices_count * sizeof(IMMDevice *));
+        if (!This->devices_count)
+            return E_OUTOFMEMORY;
+
+        LIST_FOR_EACH_ENTRY(cur, &device_list, MMDevice, entry)
+        {
+            if ((cur->flow == flow || flow == eAll) && (cur->state & state))
+            {
+                This->devices[i] = &cur->IMMDevice_iface;
+                IMMDevice_AddRef(This->devices[i]);
+                i++;
+            }
+        }
+    }
+
     return S_OK;
 }
 
 static void MMDevCol_Destroy(MMDevColImpl *This)
 {
+    UINT i;
+    for (i = 0; i < This->devices_count; i++)
+        IMMDevice_Release(This->devices[i]);
+
+    free(This->devices);
     free(This);
 }
 
@@ -884,46 +915,33 @@ static ULONG WINAPI MMDevCol_Release(IMMDeviceCollection *iface)
 static HRESULT WINAPI MMDevCol_GetCount(IMMDeviceCollection *iface, UINT *numdevs)
 {
     MMDevColImpl *This = impl_from_IMMDeviceCollection(iface);
-    MMDevice *cur;
 
     TRACE("(%p)->(%p)\n", This, numdevs);
     if (!numdevs)
         return E_POINTER;
 
-    *numdevs = 0;
-    LIST_FOR_EACH_ENTRY(cur, &device_list, MMDevice, entry)
-    {
-        if ((cur->flow == This->flow || This->flow == eAll)
-            && (cur->state & This->state))
-            ++(*numdevs);
-    }
+    *numdevs = This->devices_count;
     return S_OK;
 }
 
 static HRESULT WINAPI MMDevCol_Item(IMMDeviceCollection *iface, UINT n, IMMDevice **dev)
 {
     MMDevColImpl *This = impl_from_IMMDeviceCollection(iface);
-    MMDevice *cur;
-    DWORD i = 0;
 
     TRACE("(%p)->(%u, %p)\n", This, n, dev);
     if (!dev)
         return E_POINTER;
 
-    LIST_FOR_EACH_ENTRY(cur, &device_list, MMDevice, entry)
+    if (n >= This->devices_count)
     {
-        if ((cur->flow == This->flow || This->flow == eAll)
-            && (cur->state & This->state)
-            && i++ == n)
-        {
-            *dev = &cur->IMMDevice_iface;
-            IMMDevice_AddRef(*dev);
-            return S_OK;
-        }
+        WARN("Could not obtain item %u\n", n);
+        *dev = NULL;
+        return E_INVALIDARG;
     }
-    WARN("Could not obtain item %u\n", n);
-    *dev = NULL;
-    return E_INVALIDARG;
+
+    *dev = This->devices[n];
+    IMMDevice_AddRef(*dev);
+    return S_OK;
 }
 
 static const IMMDeviceCollectionVtbl MMDevColVtbl =
-- 
GitLab

From aaad795901d8fe59fd94f9ff2390f4a32d6a4ad7 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 2 Apr 2024 20:16:29 -0600
Subject: [PATCH] mmdevapi: Implement SAC_IsAudioObjectFormatSupported().

---
 dlls/mmdevapi/spatialaudio.c       | 67 ++++++++++++++++++++----------
 dlls/mmdevapi/tests/spatialaudio.c | 21 ++++++++++
 2 files changed, 66 insertions(+), 22 deletions(-)

diff --git a/dlls/mmdevapi/spatialaudio.c b/dlls/mmdevapi/spatialaudio.c
index 23f3de31428..b721af6229b 100644
--- a/dlls/mmdevapi/spatialaudio.c
+++ b/dlls/mmdevapi/spatialaudio.c
@@ -49,6 +49,36 @@ static UINT32 AudioObjectType_to_index(AudioObjectType type)
     return o - 2;
 }
 
+static const char *debugstr_fmtex(const WAVEFORMATEX *fmt)
+{
+    static char buf[2048];
+
+    if (!fmt)
+    {
+        strcpy(buf, "(null)");
+    }
+    else if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
+    {
+        const WAVEFORMATEXTENSIBLE *fmtex = (const WAVEFORMATEXTENSIBLE *)fmt;
+        snprintf(buf, sizeof(buf), "tag: 0x%x (%s), ch: %u (mask: 0x%lx), rate: %lu, depth: %u",
+                fmt->wFormatTag, debugstr_guid(&fmtex->SubFormat),
+                fmt->nChannels, fmtex->dwChannelMask, fmt->nSamplesPerSec,
+                fmt->wBitsPerSample);
+    }
+    else
+    {
+        snprintf(buf, sizeof(buf), "tag: 0x%x, ch: %u, rate: %lu, depth: %u",
+                fmt->wFormatTag, fmt->nChannels, fmt->nSamplesPerSec,
+                fmt->wBitsPerSample);
+    }
+    return buf;
+}
+
+static BOOL formats_equal(const WAVEFORMATEX *fmt1, const WAVEFORMATEX *fmt2)
+{
+    return !memcmp(fmt1, fmt2, sizeof(*fmt1)) && !memcmp(fmt1 + 1, fmt2 + 1, fmt1->cbSize);
+}
+
 typedef struct SpatialAudioImpl SpatialAudioImpl;
 typedef struct SpatialAudioStreamImpl SpatialAudioStreamImpl;
 typedef struct SpatialAudioObjectImpl SpatialAudioObjectImpl;
@@ -610,9 +640,20 @@ static HRESULT WINAPI SAC_GetMaxFrameCount(ISpatialAudioClient *iface,
 static HRESULT WINAPI SAC_IsAudioObjectFormatSupported(ISpatialAudioClient *iface,
         const WAVEFORMATEX *format)
 {
-    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
-    FIXME("(%p)->(%p)\n", This, format);
-    return E_NOTIMPL;
+    SpatialAudioImpl *sac = impl_from_ISpatialAudioClient(iface);
+
+    TRACE("sac %p, format %s.\n", sac, debugstr_fmtex(format));
+
+    if (!format)
+        return E_POINTER;
+
+    if (!formats_equal(&sac->object_fmtex.Format, format))
+    {
+        FIXME("Reporting format %s as unsupported.\n", debugstr_fmtex(format));
+        return E_INVALIDARG;
+    }
+
+    return S_OK;
 }
 
 static HRESULT WINAPI SAC_IsSpatialAudioStreamAvailable(ISpatialAudioClient *iface,
@@ -630,23 +671,6 @@ static WAVEFORMATEX *clone_fmtex(const WAVEFORMATEX *src)
     return r;
 }
 
-static const char *debugstr_fmtex(const WAVEFORMATEX *fmt)
-{
-    static char buf[2048];
-    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
-        const WAVEFORMATEXTENSIBLE *fmtex = (const WAVEFORMATEXTENSIBLE *)fmt;
-        snprintf(buf, sizeof(buf), "tag: 0x%x (%s), ch: %u (mask: 0x%lx), rate: %lu, depth: %u",
-                fmt->wFormatTag, debugstr_guid(&fmtex->SubFormat),
-                fmt->nChannels, fmtex->dwChannelMask, fmt->nSamplesPerSec,
-                fmt->wBitsPerSample);
-    }else{
-        snprintf(buf, sizeof(buf), "tag: 0x%x, ch: %u, rate: %lu, depth: %u",
-                fmt->wFormatTag, fmt->nChannels, fmt->nSamplesPerSec,
-                fmt->wBitsPerSample);
-    }
-    return buf;
-}
-
 static void static_mask_to_channels(AudioObjectType static_mask, WORD *count, DWORD *mask, UINT32 *map)
 {
     UINT32 out_chan = 0, map_idx = 0;
@@ -776,8 +800,7 @@ static HRESULT WINAPI SAC_ActivateSpatialAudioStream(ISpatialAudioClient *iface,
             return E_INVALIDARG;
         }
 
-        if(!params->ObjectFormat ||
-                memcmp(params->ObjectFormat, &This->object_fmtex.Format, sizeof(*params->ObjectFormat) + params->ObjectFormat->cbSize)){
+        if(!(params->ObjectFormat && formats_equal(params->ObjectFormat, &This->object_fmtex.Format))) {
             *stream = NULL;
             return AUDCLNT_E_UNSUPPORTED_FORMAT;
         }
diff --git a/dlls/mmdevapi/tests/spatialaudio.c b/dlls/mmdevapi/tests/spatialaudio.c
index a382b57e7a2..4d8073d49ce 100644
--- a/dlls/mmdevapi/tests/spatialaudio.c
+++ b/dlls/mmdevapi/tests/spatialaudio.c
@@ -64,6 +64,27 @@ static void test_formats(void)
     ok(fmt->nAvgBytesPerSec == 192000, "Wrong avg bytes per sec, expected 192000 got %lu\n", fmt->nAvgBytesPerSec);
     ok(fmt->cbSize == 0, "Wrong cbSize for simple format, expected 0, got %hu\n", fmt->cbSize);
 
+    hr = ISpatialAudioClient_IsAudioObjectFormatSupported(sac, NULL);
+    ok(hr == E_POINTER, "Got %#lx.\n", hr);
+
+    memcpy(&format, fmt, sizeof(format));
+    hr = ISpatialAudioClient_IsAudioObjectFormatSupported(sac, &format);
+    ok(hr == S_OK, "Got %#lx.\n", hr);
+
+    format.nBlockAlign *= 2;
+    hr = ISpatialAudioClient_IsAudioObjectFormatSupported(sac, &format);
+    todo_wine ok(hr == S_OK, "Got %#lx.\n", hr);
+
+    memcpy(&format, fmt, sizeof(format));
+    format.wBitsPerSample *= 2;
+    hr = ISpatialAudioClient_IsAudioObjectFormatSupported(sac, &format);
+    ok(hr == E_INVALIDARG, "Got %#lx.\n", hr);
+
+    memcpy(&format, fmt, sizeof(format));
+    format.nChannels = 2;
+    hr = ISpatialAudioClient_IsAudioObjectFormatSupported(sac, &format);
+    ok(hr == E_INVALIDARG, "Got %#lx.\n", hr);
+
     memcpy(&format, fmt, sizeof(format));
 
     IAudioFormatEnumerator_Release(afe);
-- 
GitLab

From f612029d4e6a7198c88ad4f3ef94677db85c93d6 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Fri, 17 May 2024 08:32:09 +0100
Subject: [PATCH] mmdevapi: Remove unused ACImpl typedef.

---
 dlls/mmdevapi/mmdevdrv.h | 2 --
 1 file changed, 2 deletions(-)

diff --git a/dlls/mmdevapi/mmdevdrv.h b/dlls/mmdevapi/mmdevdrv.h
index df21859cbad..1f4d65e4436 100644
--- a/dlls/mmdevapi/mmdevdrv.h
+++ b/dlls/mmdevapi/mmdevdrv.h
@@ -19,8 +19,6 @@
 
 #include <wine/list.h>
 
-typedef struct audio_client ACImpl;
-
 typedef struct audio_session {
     GUID guid;
     struct list clients;
-- 
GitLab

From 5c6e63bac21d3cbeed56ad76f45f16fa8fc76518 Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Wed, 29 May 2024 21:28:18 +0200
Subject: [PATCH 1/6] winealsa: Return minimum period in get_device_period if
 requested.

---
 dlls/winealsa.drv/alsa.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winealsa.drv/alsa.c b/dlls/winealsa.drv/alsa.c
index aa1ad4abe6c..3172e1ece81 100644
--- a/dlls/winealsa.drv/alsa.c
+++ b/dlls/winealsa.drv/alsa.c
@@ -2153,7 +2153,7 @@ static NTSTATUS alsa_get_device_period(void *args)
     if (params->def_period)
         *params->def_period = def_period;
     if (params->min_period)
-        *params->min_period = def_period;
+        *params->min_period = min_period;
 
     params->result = S_OK;
 
-- 
GitLab


From 2d55bd5dbdaff60983dc9e043317b276dbc97a5f Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Thu, 2 May 2024 02:02:27 +0200
Subject: [PATCH 2/6] mmdevapi: Adjust timing in AudioClient_Initialize.

---
 dlls/mmdevapi/client.c | 58 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index e0c12b8e534..0b849e47e3d 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -99,6 +99,61 @@ static inline struct audio_client *impl_from_IAudioStreamVolume(IAudioStreamVolu
     return CONTAINING_RECORD(iface, struct audio_client, IAudioStreamVolume_iface);
 }
 
+static HRESULT adjust_timing(struct audio_client *This,
+                             REFERENCE_TIME *duration, REFERENCE_TIME *period,
+                             const AUDCLNT_SHAREMODE mode, const DWORD flags,
+                             const WAVEFORMATEX *fmt)
+{
+    struct get_device_period_params params;
+    REFERENCE_TIME def_period, min_period;
+
+    TRACE("Requested duration %lu and period %lu\n", (ULONG)*duration, (ULONG)*period);
+
+    params.device     = This->device_name;
+    params.flow       = This->dataflow;
+    params.def_period = &def_period;
+    params.min_period = &min_period;
+
+    wine_unix_call(get_device_period, &params);
+
+    if (FAILED(params.result))
+        return params.result;
+
+    TRACE("Device periods: %lu default and %lu minimum\n", (ULONG)def_period, (ULONG)min_period);
+
+    if (mode == AUDCLNT_SHAREMODE_SHARED) {
+        *period = def_period;
+        if (*duration < 3 * *period)
+            *duration = 3 * *period;
+    } else {
+        const WAVEFORMATEXTENSIBLE *fmtex = (WAVEFORMATEXTENSIBLE *)fmt;
+        if (fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
+           (fmtex->dwChannelMask == 0 || fmtex->dwChannelMask & SPEAKER_RESERVED))
+            params.result = AUDCLNT_E_UNSUPPORTED_FORMAT;
+        else {
+            if (*period == 0)
+                *period = def_period;
+            if (*period < min_period || *period > 5000000)
+                params.result = AUDCLNT_E_INVALID_DEVICE_PERIOD;
+            else if (*duration > 20000000) /* The smaller the period, the lower this limit. */
+                params.result = AUDCLNT_E_BUFFER_SIZE_ERROR;
+            else if (flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) {
+                if (*duration != *period)
+                    params.result = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
+
+                FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
+
+                params.result = AUDCLNT_E_DEVICE_IN_USE;
+            } else if (*duration < 8 * *period)
+                *duration = 8 * *period; /* May grow above 2s. */
+        }
+    }
+
+    TRACE("Adjusted duration %lu and period %lu\n", (ULONG)*duration, (ULONG)*period);
+
+    return params.result;
+}
+
 static void dump_fmt(const WAVEFORMATEX *fmt)
 {
     TRACE("wFormatTag: 0x%x (", fmt->wFormatTag);
@@ -502,6 +557,9 @@ static HRESULT WINAPI client_Initialize(IAudioClient3 *iface, AUDCLNT_SHAREMODE
         return E_INVALIDARG;
     }
 
+    if (FAILED(params.result = adjust_timing(This, &duration, &period, mode, flags, fmt)))
+        return params.result;
+
     sessions_lock();
 
     if (This->stream) {
-- 
GitLab


From 42e471f5c6e02ebb79a1b24ce2489a9fdd4cce4e Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Thu, 2 May 2024 00:23:22 +0200
Subject: [PATCH 3/6] winealsa: Remove superfluous timing adjustment.

---
 dlls/winealsa.drv/alsa.c | 30 ------------------------------
 1 file changed, 30 deletions(-)

diff --git a/dlls/winealsa.drv/alsa.c b/dlls/winealsa.drv/alsa.c
index 3172e1ece81..a24cb56d1d8 100644
--- a/dlls/winealsa.drv/alsa.c
+++ b/dlls/winealsa.drv/alsa.c
@@ -810,36 +810,6 @@ static NTSTATUS alsa_create_stream(void *args)
 
     params->result = S_OK;
 
-    if (params->share == AUDCLNT_SHAREMODE_SHARED) {
-        params->period = def_period;
-        if (params->duration < 3 * params->period)
-            params->duration = 3 * params->period;
-    } else {
-        if (fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
-           (fmtex->dwChannelMask == 0 || fmtex->dwChannelMask & SPEAKER_RESERVED))
-            params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-        else {
-            if (!params->period)
-                params->period = def_period;
-            if (params->period < min_period || params->period > 5000000)
-                params->result = AUDCLNT_E_INVALID_DEVICE_PERIOD;
-            else if (params->duration > 20000000) /* The smaller the period, the lower this limit. */
-                params->result = AUDCLNT_E_BUFFER_SIZE_ERROR;
-            else if (params->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) {
-                if (params->duration != params->period)
-                    params->result = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
-
-                FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
-
-                params->result = AUDCLNT_E_DEVICE_IN_USE;
-            } else if (params->duration < 8 * params->period)
-                params->duration = 8 * params->period; /* May grow above 2s. */
-        }
-    }
-
-    if (FAILED(params->result))
-        return STATUS_SUCCESS;
-
     stream = calloc(1, sizeof(*stream));
     if(!stream){
         params->result = E_OUTOFMEMORY;
-- 
GitLab


From f8d374e8ed1aed600b3553af6df39945319b7862 Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Thu, 2 May 2024 00:24:18 +0200
Subject: [PATCH 4/6] winecoreaudio: Remove superfluous timing adjustment.

---
 dlls/winecoreaudio.drv/coreaudio.c | 31 ------------------------------
 1 file changed, 31 deletions(-)

diff --git a/dlls/winecoreaudio.drv/coreaudio.c b/dlls/winecoreaudio.drv/coreaudio.c
index a79a0d16839..deb9df1b45a 100644
--- a/dlls/winecoreaudio.drv/coreaudio.c
+++ b/dlls/winecoreaudio.drv/coreaudio.c
@@ -725,37 +725,6 @@ static NTSTATUS unix_create_stream(void *args)
 
     params->result = S_OK;
 
-    if (params->share == AUDCLNT_SHAREMODE_SHARED) {
-        params->period = def_period;
-        if (params->duration < 3 * params->period)
-            params->duration = 3 * params->period;
-    } else {
-        const WAVEFORMATEXTENSIBLE *fmtex = (WAVEFORMATEXTENSIBLE *)params->fmt;
-        if (fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
-           (fmtex->dwChannelMask == 0 || fmtex->dwChannelMask & SPEAKER_RESERVED))
-            params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-        else {
-            if (!params->period)
-                params->period = def_period;
-            if (params->period < min_period || params->period > 5000000)
-                params->result = AUDCLNT_E_INVALID_DEVICE_PERIOD;
-            else if (params->duration > 20000000) /* The smaller the period, the lower this limit. */
-                params->result = AUDCLNT_E_BUFFER_SIZE_ERROR;
-            else if (params->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) {
-                if (params->duration != params->period)
-                    params->result = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
-
-                FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
-
-                params->result = AUDCLNT_E_DEVICE_IN_USE;
-            } else if (params->duration < 8 * params->period)
-                params->duration = 8 * params->period; /* May grow above 2s. */
-        }
-    }
-
-    if (FAILED(params->result))
-        return STATUS_SUCCESS;
-
     if (!(stream = calloc(1, sizeof(*stream)))) {
         params->result = E_OUTOFMEMORY;
         return STATUS_SUCCESS;
-- 
GitLab


From 53a636b034e172115d47e33dc4da35b5148c76fb Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Thu, 2 May 2024 00:24:38 +0200
Subject: [PATCH 5/6] wineoss: Remove superfluous timing adjustment.

---
 dlls/wineoss.drv/oss.c | 30 ------------------------------
 1 file changed, 30 deletions(-)

diff --git a/dlls/wineoss.drv/oss.c b/dlls/wineoss.drv/oss.c
index 89e626f39d6..819e876606c 100644
--- a/dlls/wineoss.drv/oss.c
+++ b/dlls/wineoss.drv/oss.c
@@ -576,36 +576,6 @@ static NTSTATUS oss_create_stream(void *args)
 
     params->result = S_OK;
 
-    if (params->share == AUDCLNT_SHAREMODE_SHARED) {
-        params->period = def_period;
-        if (params->duration < 3 * params->period)
-            params->duration = 3 * params->period;
-    } else {
-        if (fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
-           (fmtex->dwChannelMask == 0 || fmtex->dwChannelMask & SPEAKER_RESERVED))
-            params->result = AUDCLNT_E_UNSUPPORTED_FORMAT;
-        else {
-            if (!params->period)
-                params->period = def_period;
-            if (params->period < min_period || params->period > 5000000)
-                params->result = AUDCLNT_E_INVALID_DEVICE_PERIOD;
-            else if (params->duration > 20000000) /* The smaller the period, the lower this limit. */
-                params->result = AUDCLNT_E_BUFFER_SIZE_ERROR;
-            else if (params->flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) {
-                if (params->duration != params->period)
-                    params->result = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
-
-                FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
-
-                params->result = AUDCLNT_E_DEVICE_IN_USE;
-            } else if (params->duration < 8 * params->period)
-                params->duration = 8 * params->period; /* May grow above 2s. */
-        }
-    }
-
-    if (FAILED(params->result))
-        return STATUS_SUCCESS;
-
     stream = calloc(1, sizeof(*stream));
     if(!stream){
         params->result = E_OUTOFMEMORY;
-- 
GitLab


From fc9525a6211f853bdf211546fff4f69b31ba3b89 Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Thu, 2 May 2024 00:30:56 +0200
Subject: [PATCH 6/6] winepulse: Remove superfluous timing adjustment.

Please note that exclusive mode is not supported in this driver.
---
 dlls/winepulse.drv/pulse.c | 19 ++++++-------------
 1 file changed, 6 insertions(+), 13 deletions(-)

diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index 62658fc98e6..dd8d0b4441d 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -1116,7 +1116,6 @@ static HRESULT get_device_period_helper(EDataFlow flow, const char *pulse_name,
 static NTSTATUS pulse_create_stream(void *args)
 {
     struct create_stream_params *params = args;
-    REFERENCE_TIME period, duration = params->duration;
     struct pulse_stream *stream;
     unsigned int i, bufsize_bytes;
     HRESULT hr;
@@ -1156,21 +1155,15 @@ static NTSTATUS pulse_create_stream(void *args)
     if (FAILED(hr))
         goto exit;
 
-    period = 0;
-    hr = get_device_period_helper(params->flow, params->device, &period, NULL);
-    if (FAILED(hr))
-        goto exit;
-
-    if (duration < 3 * period)
-        duration = 3 * period;
-
-    stream->def_period = period;
+    stream->def_period = params->period;
 
-    stream->period_bytes = pa_frame_size(&stream->ss) * muldiv(period, stream->ss.rate, 10000000);
+    stream->period_bytes = pa_frame_size(&stream->ss) * muldiv(params->period,
+                                                               stream->ss.rate,
+                                                               10000000);
 
-    stream->bufsize_frames = ceil((duration / 10000000.) * params->fmt->nSamplesPerSec);
+    stream->bufsize_frames = ceil((params->duration / 10000000.) * params->fmt->nSamplesPerSec);
     bufsize_bytes = stream->bufsize_frames * pa_frame_size(&stream->ss);
-    stream->mmdev_period_usec = period / 10;
+    stream->mmdev_period_usec = params->period / 10;
 
     stream->share = params->share;
     stream->flags = params->flags;
-- 
GitLab

From 805d0c58d9487a389eebd754538c8722a7d953fb Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Sat, 1 Jun 2024 22:21:20 +0200
Subject: [PATCH 1/6] mmdevapi/tests: Add tests for IAudioSessionControl2
 GetDisplayName / SetDisplayName.

---
 dlls/mmdevapi/tests/render.c | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/dlls/mmdevapi/tests/render.c b/dlls/mmdevapi/tests/render.c
index a7da68ec3f1..4ec2b5e3f04 100644
--- a/dlls/mmdevapi/tests/render.c
+++ b/dlls/mmdevapi/tests/render.c
@@ -1453,6 +1453,7 @@ static void test_session(void)
     WAVEFORMATEX *pwfx;
     ULONG ref;
     HRESULT hr;
+    WCHAR *str;
 
     hr = CoCreateGuid(&ses1_guid);
     ok(hr == S_OK, "CoCreateGuid failed: %08lx\n", hr);
@@ -1575,6 +1576,40 @@ static void test_session(void)
     ok(hr == S_OK, "GetState failed: %08lx\n", hr);
     ok(state == AudioSessionStateInactive, "Got wrong state: %d\n", state);
 
+    /* Test GetDisplayName / SetDisplayName */
+
+    hr = IAudioSessionControl2_GetDisplayName(ses1_ctl2, NULL);
+    todo_wine
+    ok(hr == E_POINTER, "GetDisplayName failed: %08lx\n", hr);
+
+    str = NULL;
+    hr = IAudioSessionControl2_GetDisplayName(ses1_ctl2, &str);
+    todo_wine
+    ok(hr == S_OK, "GetDisplayName failed: %08lx\n", hr);
+    todo_wine
+    ok(str && !wcscmp(str, L""), "Got %s\n", wine_dbgstr_w(str));
+    if (str)
+        CoTaskMemFree(str);
+
+    hr = IAudioSessionControl2_SetDisplayName(ses1_ctl2, NULL, NULL);
+    todo_wine
+    ok(hr == HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER), "SetDisplayName failed: %08lx\n", hr);
+
+    hr = IAudioSessionControl2_SetDisplayName(ses1_ctl2, L"WineDisplayName", NULL);
+    todo_wine
+    ok(hr == S_OK, "SetDisplayName failed: %08lx\n", hr);
+
+    str = NULL;
+    hr = IAudioSessionControl2_GetDisplayName(ses1_ctl2, &str);
+    todo_wine
+    ok(hr == S_OK, "GetDisplayName failed: %08lx\n", hr);
+    todo_wine
+    ok(str && !wcscmp(str, L"WineDisplayName"), "Got %s\n", wine_dbgstr_w(str));
+    if (str)
+        CoTaskMemFree(str);
+
+    /* Test capture */
+
     if(cap_ctl){
         hr = IAudioSessionControl2_GetState(cap_ctl, &state);
         ok(hr == S_OK, "GetState failed: %08lx\n", hr);
-- 
GitLab


From 8e7092390a0f1bd2606717a0ebffdda9397acb68 Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Tue, 4 Jun 2024 01:03:17 +0200
Subject: [PATCH 2/6] mmdevapi/tests: Add tests for IAudioSessionControl2
 GetIconPath / SetIconPath.

---
 dlls/mmdevapi/tests/render.c | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/dlls/mmdevapi/tests/render.c b/dlls/mmdevapi/tests/render.c
index 4ec2b5e3f04..77028e9ef77 100644
--- a/dlls/mmdevapi/tests/render.c
+++ b/dlls/mmdevapi/tests/render.c
@@ -1608,6 +1608,38 @@ static void test_session(void)
     if (str)
         CoTaskMemFree(str);
 
+    /* Test GetIconPath / SetIconPath */
+
+    hr = IAudioSessionControl2_GetIconPath(ses1_ctl2, NULL);
+    todo_wine
+    ok(hr == E_POINTER, "GetIconPath failed: %08lx\n", hr);
+
+    str = NULL;
+    hr = IAudioSessionControl2_GetIconPath(ses1_ctl2, &str);
+    todo_wine
+    ok(hr == S_OK, "GetIconPath failed: %08lx\n", hr);
+    todo_wine
+    ok(str && !wcscmp(str, L""), "Got %s\n", wine_dbgstr_w(str));
+    if(str)
+        CoTaskMemFree(str);
+
+    hr = IAudioSessionControl2_SetIconPath(ses1_ctl2, NULL, NULL);
+    todo_wine
+    ok(hr == HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER), "SetIconPath failed: %08lx\n", hr);
+
+    hr = IAudioSessionControl2_SetIconPath(ses1_ctl2, L"WineIconPath", NULL);
+    todo_wine
+    ok(hr == S_OK, "SetIconPath failed: %08lx\n", hr);
+
+    str = NULL;
+    hr = IAudioSessionControl2_GetIconPath(ses1_ctl2, &str);
+    todo_wine
+    ok(hr == S_OK, "GetIconPath failed: %08lx\n", hr);
+    todo_wine
+    ok(str && !wcscmp(str, L"WineIconPath"), "Got %s\n", wine_dbgstr_w(str));
+    if (str)
+        CoTaskMemFree(str);
+
     /* Test capture */
 
     if(cap_ctl){
-- 
GitLab


From ae7cb868cf759362e024671c9176363959352a77 Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Tue, 4 Jun 2024 01:03:39 +0200
Subject: [PATCH 3/6] mmdevapi/tests: Add tests for IAudioSessionControl2
 GetGroupingParam / SetGroupingParam.

---
 dlls/mmdevapi/tests/render.c | 30 ++++++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)

diff --git a/dlls/mmdevapi/tests/render.c b/dlls/mmdevapi/tests/render.c
index 77028e9ef77..23ff0892dfe 100644
--- a/dlls/mmdevapi/tests/render.c
+++ b/dlls/mmdevapi/tests/render.c
@@ -1454,6 +1454,7 @@ static void test_session(void)
     ULONG ref;
     HRESULT hr;
     WCHAR *str;
+    GUID guid1 = GUID_NULL, guid2 = GUID_NULL;
 
     hr = CoCreateGuid(&ses1_guid);
     ok(hr == S_OK, "CoCreateGuid failed: %08lx\n", hr);
@@ -1640,6 +1641,35 @@ static void test_session(void)
     if (str)
         CoTaskMemFree(str);
 
+    /* Test GetGroupingParam / SetGroupingParam */
+
+    hr = IAudioSessionControl2_GetGroupingParam(ses1_ctl2, NULL);
+    todo_wine
+    ok(hr == HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER), "GetGroupingParam failed: %08lx\n", hr);
+
+    hr = IAudioSessionControl2_GetGroupingParam(ses1_ctl2, &guid1);
+    todo_wine
+    ok(hr == S_OK, "GetGroupingParam failed: %08lx\n", hr);
+    todo_wine
+    ok(!IsEqualGUID(&guid1, &guid2), "Expected non null GUID\n"); /* MSDN is wrong here, it is not GUID_NULL */
+
+    hr = IAudioSessionControl2_SetGroupingParam(ses1_ctl2, NULL, NULL);
+    todo_wine
+    ok(hr == HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER), "SetGroupingParam failed: %08lx\n", hr);
+
+    hr = CoCreateGuid(&guid2);
+    ok(hr == S_OK, "CoCreateGuid failed: %08lx\n", hr);
+
+    hr = IAudioSessionControl2_SetGroupingParam(ses1_ctl2, &guid2, NULL);
+    todo_wine
+    ok(hr == S_OK, "SetGroupingParam failed: %08lx\n", hr);
+
+    hr = IAudioSessionControl2_GetGroupingParam(ses1_ctl2, &guid1);
+    todo_wine
+    ok(hr == S_OK, "GetGroupingParam failed: %08lx\n", hr);
+    todo_wine
+    ok(IsEqualGUID(&guid1, &guid2), "Got %s\n", wine_dbgstr_guid(&guid1));
+
     /* Test capture */
 
     if(cap_ctl){
-- 
GitLab


From b23608ea7d1786ef2572ea87668ddf643716ff21 Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Tue, 4 Jun 2024 01:44:42 +0200
Subject: [PATCH 4/6] mmdevapi: Implement IAudioSessionControl2 GetDisplayName
 / SetDisplayName.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=56763
---
 dlls/mmdevapi/mmdevdrv.h     |  2 ++
 dlls/mmdevapi/session.c      | 37 +++++++++++++++++++++++++++++++-----
 dlls/mmdevapi/tests/render.c |  7 -------
 3 files changed, 34 insertions(+), 12 deletions(-)

diff --git a/dlls/mmdevapi/mmdevdrv.h b/dlls/mmdevapi/mmdevdrv.h
index 1f4d65e4436..115c5e32fcc 100644
--- a/dlls/mmdevapi/mmdevdrv.h
+++ b/dlls/mmdevapi/mmdevdrv.h
@@ -30,6 +30,8 @@ typedef struct audio_session {
     float *channel_vols;
     BOOL mute;
 
+    WCHAR *display_name;
+
     struct list entry;
 } AudioSession;
 
diff --git a/dlls/mmdevapi/session.c b/dlls/mmdevapi/session.c
index 9a36adb5bf2..d4948e3b141 100644
--- a/dlls/mmdevapi/session.c
+++ b/dlls/mmdevapi/session.c
@@ -37,6 +37,15 @@ WINE_DEFAULT_DEBUG_CHANNEL(mmdevapi);
 extern void sessions_lock(void) DECLSPEC_HIDDEN;
 extern void sessions_unlock(void) DECLSPEC_HIDDEN;
 
+static WCHAR *duplicate_wstr(const WCHAR *str)
+{
+    const WCHAR *source = str ? str : L"";
+    int len = (wcslen(source) + 1) * sizeof(WCHAR);
+    WCHAR *ret = CoTaskMemAlloc(len);
+    memcpy(ret, source, len);
+    return ret;
+}
+
 extern void set_stream_volumes(struct audio_client *This) DECLSPEC_HIDDEN;
 
 static struct list sessions = LIST_INIT(sessions);
@@ -144,16 +153,34 @@ static HRESULT WINAPI control_GetState(IAudioSessionControl2 *iface, AudioSessio
 static HRESULT WINAPI control_GetDisplayName(IAudioSessionControl2 *iface, WCHAR **name)
 {
     struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, name);
-    return E_NOTIMPL;
+    struct audio_session *session = This->session;
+
+    TRACE("(%p)->(%p) - stub\n", This, name);
+
+    if (!name)
+        return E_POINTER;
+
+    *name = duplicate_wstr(session->display_name);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI control_SetDisplayName(IAudioSessionControl2 *iface, const WCHAR *name,
-                                         const GUID *session)
+                                         const GUID *event_context)
 {
     struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(session));
-    return E_NOTIMPL;
+    struct audio_session *session = This->session;
+
+    TRACE("(%p)->(%p, %s) - stub\n", This, name, debugstr_guid(event_context));
+    FIXME("Ignoring event_context\n");
+
+    if (!name)
+        return HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER);
+
+    free(session->display_name);
+    session->display_name = wcsdup(name);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI control_GetIconPath(IAudioSessionControl2 *iface, WCHAR **path)
diff --git a/dlls/mmdevapi/tests/render.c b/dlls/mmdevapi/tests/render.c
index 23ff0892dfe..6d76bff8b22 100644
--- a/dlls/mmdevapi/tests/render.c
+++ b/dlls/mmdevapi/tests/render.c
@@ -1580,31 +1580,24 @@ static void test_session(void)
     /* Test GetDisplayName / SetDisplayName */
 
     hr = IAudioSessionControl2_GetDisplayName(ses1_ctl2, NULL);
-    todo_wine
     ok(hr == E_POINTER, "GetDisplayName failed: %08lx\n", hr);
 
     str = NULL;
     hr = IAudioSessionControl2_GetDisplayName(ses1_ctl2, &str);
-    todo_wine
     ok(hr == S_OK, "GetDisplayName failed: %08lx\n", hr);
-    todo_wine
     ok(str && !wcscmp(str, L""), "Got %s\n", wine_dbgstr_w(str));
     if (str)
         CoTaskMemFree(str);
 
     hr = IAudioSessionControl2_SetDisplayName(ses1_ctl2, NULL, NULL);
-    todo_wine
     ok(hr == HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER), "SetDisplayName failed: %08lx\n", hr);
 
     hr = IAudioSessionControl2_SetDisplayName(ses1_ctl2, L"WineDisplayName", NULL);
-    todo_wine
     ok(hr == S_OK, "SetDisplayName failed: %08lx\n", hr);
 
     str = NULL;
     hr = IAudioSessionControl2_GetDisplayName(ses1_ctl2, &str);
-    todo_wine
     ok(hr == S_OK, "GetDisplayName failed: %08lx\n", hr);
-    todo_wine
     ok(str && !wcscmp(str, L"WineDisplayName"), "Got %s\n", wine_dbgstr_w(str));
     if (str)
         CoTaskMemFree(str);
-- 
GitLab


From 0d4d778b5647c7700dd2aed9d0f5f9289319fd5f Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Tue, 4 Jun 2024 01:36:21 +0200
Subject: [PATCH 5/6] mmdevapi: Implement IAudioSessionControl2 GetIconPath /
 SetIconPath.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=56763
---
 dlls/mmdevapi/mmdevdrv.h     |  1 +
 dlls/mmdevapi/session.c      | 28 +++++++++++++++++++++++-----
 dlls/mmdevapi/tests/render.c |  7 -------
 3 files changed, 24 insertions(+), 12 deletions(-)

diff --git a/dlls/mmdevapi/mmdevdrv.h b/dlls/mmdevapi/mmdevdrv.h
index 115c5e32fcc..d4060fa304f 100644
--- a/dlls/mmdevapi/mmdevdrv.h
+++ b/dlls/mmdevapi/mmdevdrv.h
@@ -31,6 +31,7 @@ typedef struct audio_session {
     BOOL mute;
 
     WCHAR *display_name;
+    WCHAR *icon_path;
 
     struct list entry;
 } AudioSession;
diff --git a/dlls/mmdevapi/session.c b/dlls/mmdevapi/session.c
index d4948e3b141..3620205ca20 100644
--- a/dlls/mmdevapi/session.c
+++ b/dlls/mmdevapi/session.c
@@ -186,16 +186,34 @@ static HRESULT WINAPI control_SetDisplayName(IAudioSessionControl2 *iface, const
 static HRESULT WINAPI control_GetIconPath(IAudioSessionControl2 *iface, WCHAR **path)
 {
     struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, path);
-    return E_NOTIMPL;
+    struct audio_session *session = This->session;
+
+    TRACE("(%p)->(%p) - stub\n", This, path);
+
+    if (!path)
+        return E_POINTER;
+
+    *path = duplicate_wstr(session->icon_path);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI control_SetIconPath(IAudioSessionControl2 *iface, const WCHAR *path,
-                                      const GUID *session)
+                                      const GUID *event_context)
 {
     struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_w(path), debugstr_guid(session));
-    return E_NOTIMPL;
+    struct audio_session *session = This->session;
+
+    TRACE("(%p)->(%s, %s) - stub\n", This, debugstr_w(path), debugstr_guid(event_context));
+    FIXME("Ignoring event_context\n");
+
+    if (!path)
+        return HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER);
+
+    free(session->icon_path);
+    session->icon_path = wcsdup(path);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI control_GetGroupingParam(IAudioSessionControl2 *iface, GUID *group)
diff --git a/dlls/mmdevapi/tests/render.c b/dlls/mmdevapi/tests/render.c
index 6d76bff8b22..64bb2799705 100644
--- a/dlls/mmdevapi/tests/render.c
+++ b/dlls/mmdevapi/tests/render.c
@@ -1605,31 +1605,24 @@ static void test_session(void)
     /* Test GetIconPath / SetIconPath */
 
     hr = IAudioSessionControl2_GetIconPath(ses1_ctl2, NULL);
-    todo_wine
     ok(hr == E_POINTER, "GetIconPath failed: %08lx\n", hr);
 
     str = NULL;
     hr = IAudioSessionControl2_GetIconPath(ses1_ctl2, &str);
-    todo_wine
     ok(hr == S_OK, "GetIconPath failed: %08lx\n", hr);
-    todo_wine
     ok(str && !wcscmp(str, L""), "Got %s\n", wine_dbgstr_w(str));
     if(str)
         CoTaskMemFree(str);
 
     hr = IAudioSessionControl2_SetIconPath(ses1_ctl2, NULL, NULL);
-    todo_wine
     ok(hr == HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER), "SetIconPath failed: %08lx\n", hr);
 
     hr = IAudioSessionControl2_SetIconPath(ses1_ctl2, L"WineIconPath", NULL);
-    todo_wine
     ok(hr == S_OK, "SetIconPath failed: %08lx\n", hr);
 
     str = NULL;
     hr = IAudioSessionControl2_GetIconPath(ses1_ctl2, &str);
-    todo_wine
     ok(hr == S_OK, "GetIconPath failed: %08lx\n", hr);
-    todo_wine
     ok(str && !wcscmp(str, L"WineIconPath"), "Got %s\n", wine_dbgstr_w(str));
     if (str)
         CoTaskMemFree(str);
-- 
GitLab


From 75babad433a8df4c8401d9de7ec386780f2f0472 Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Tue, 4 Jun 2024 01:40:47 +0200
Subject: [PATCH 6/6] mmdevapi: Implement IAudioSessionControl2
 GetGroupingParam SetGroupingParam.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=56763
---
 dlls/mmdevapi/mmdevdrv.h     |  1 +
 dlls/mmdevapi/session.c      | 29 ++++++++++++++++++++++++-----
 dlls/mmdevapi/tests/render.c |  7 -------
 3 files changed, 25 insertions(+), 12 deletions(-)

diff --git a/dlls/mmdevapi/mmdevdrv.h b/dlls/mmdevapi/mmdevdrv.h
index d4060fa304f..42b01443ff0 100644
--- a/dlls/mmdevapi/mmdevdrv.h
+++ b/dlls/mmdevapi/mmdevdrv.h
@@ -32,6 +32,7 @@ typedef struct audio_session {
 
     WCHAR *display_name;
     WCHAR *icon_path;
+    GUID grouping_param;
 
     struct list entry;
 } AudioSession;
diff --git a/dlls/mmdevapi/session.c b/dlls/mmdevapi/session.c
index 3620205ca20..d22619b03a1 100644
--- a/dlls/mmdevapi/session.c
+++ b/dlls/mmdevapi/session.c
@@ -219,16 +219,33 @@ static HRESULT WINAPI control_SetIconPath(IAudioSessionControl2 *iface, const WC
 static HRESULT WINAPI control_GetGroupingParam(IAudioSessionControl2 *iface, GUID *group)
 {
     struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%p) - stub\n", This, group);
-    return E_NOTIMPL;
+    struct audio_session *session = This->session;
+
+    TRACE("(%p)->(%p) - stub\n", This, group);
+
+    if (!group)
+        return HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER);
+
+    *group = session->grouping_param;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI control_SetGroupingParam(IAudioSessionControl2 *iface, const GUID *group,
-                                           const GUID *session)
+                                           const GUID *event_context)
 {
     struct audio_session_wrapper *This = impl_from_IAudioSessionControl2(iface);
-    FIXME("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group), debugstr_guid(session));
-    return E_NOTIMPL;
+    struct audio_session *session = This->session;
+
+    TRACE("(%p)->(%s, %s) - stub\n", This, debugstr_guid(group), debugstr_guid(event_context));
+    FIXME("Ignoring event_context\n");
+
+    if (!group)
+        return HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER);
+
+    session->grouping_param = *group;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI control_RegisterAudioSessionNotification(IAudioSessionControl2 *iface,
@@ -631,6 +648,8 @@ static struct audio_session *session_create(const GUID *guid, IMMDevice *device,
 
     ret->master_vol = 1.f;
 
+    CoCreateGuid(&ret->grouping_param);
+
     return ret;
 }
 
diff --git a/dlls/mmdevapi/tests/render.c b/dlls/mmdevapi/tests/render.c
index 64bb2799705..b8ef4b5a549 100644
--- a/dlls/mmdevapi/tests/render.c
+++ b/dlls/mmdevapi/tests/render.c
@@ -1630,30 +1630,23 @@ static void test_session(void)
     /* Test GetGroupingParam / SetGroupingParam */
 
     hr = IAudioSessionControl2_GetGroupingParam(ses1_ctl2, NULL);
-    todo_wine
     ok(hr == HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER), "GetGroupingParam failed: %08lx\n", hr);
 
     hr = IAudioSessionControl2_GetGroupingParam(ses1_ctl2, &guid1);
-    todo_wine
     ok(hr == S_OK, "GetGroupingParam failed: %08lx\n", hr);
-    todo_wine
     ok(!IsEqualGUID(&guid1, &guid2), "Expected non null GUID\n"); /* MSDN is wrong here, it is not GUID_NULL */
 
     hr = IAudioSessionControl2_SetGroupingParam(ses1_ctl2, NULL, NULL);
-    todo_wine
     ok(hr == HRESULT_FROM_WIN32(RPC_X_NULL_REF_POINTER), "SetGroupingParam failed: %08lx\n", hr);
 
     hr = CoCreateGuid(&guid2);
     ok(hr == S_OK, "CoCreateGuid failed: %08lx\n", hr);
 
     hr = IAudioSessionControl2_SetGroupingParam(ses1_ctl2, &guid2, NULL);
-    todo_wine
     ok(hr == S_OK, "SetGroupingParam failed: %08lx\n", hr);
 
     hr = IAudioSessionControl2_GetGroupingParam(ses1_ctl2, &guid1);
-    todo_wine
     ok(hr == S_OK, "GetGroupingParam failed: %08lx\n", hr);
-    todo_wine
     ok(IsEqualGUID(&guid1, &guid2), "Got %s\n", wine_dbgstr_guid(&guid1));
 
     /* Test capture */
-- 
GitLab

From 86ac5f5638f90388d5f484aea1cb8e0b1c945e4c Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Fri, 14 Jun 2024 22:41:15 +0200
Subject: [PATCH 1/2] mmdevapi: Set the default period to a minimum of 10 ms.

---
 dlls/mmdevapi/client.c | 55 ++++++++++++++++++++++--------------------
 1 file changed, 29 insertions(+), 26 deletions(-)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index 0b849e47e3d..ed635bcf98a 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -99,25 +99,36 @@ static inline struct audio_client *impl_from_IAudioStreamVolume(IAudioStreamVolu
     return CONTAINING_RECORD(iface, struct audio_client, IAudioStreamVolume_iface);
 }
 
-static HRESULT adjust_timing(struct audio_client *This,
+static HRESULT get_periods(struct audio_client *client,
+                           REFERENCE_TIME *def_period, REFERENCE_TIME *min_period)
+{
+    static const REFERENCE_TIME min_def_period = 100000; /* 10 ms */
+    struct get_device_period_params params;
+
+    params.device     = client->device_name;
+    params.flow       = client->dataflow;
+    params.def_period = def_period;
+    params.min_period = min_period;
+
+    wine_unix_call(get_device_period, &params);
+
+    if (def_period) *def_period = max(*def_period, min_def_period);
+
+    return params.result;
+}
+
+static HRESULT adjust_timing(struct audio_client *client,
                              REFERENCE_TIME *duration, REFERENCE_TIME *period,
                              const AUDCLNT_SHAREMODE mode, const DWORD flags,
                              const WAVEFORMATEX *fmt)
 {
-    struct get_device_period_params params;
     REFERENCE_TIME def_period, min_period;
+    HRESULT hr;
 
     TRACE("Requested duration %lu and period %lu\n", (ULONG)*duration, (ULONG)*period);
 
-    params.device     = This->device_name;
-    params.flow       = This->dataflow;
-    params.def_period = &def_period;
-    params.min_period = &min_period;
-
-    wine_unix_call(get_device_period, &params);
-
-    if (FAILED(params.result))
-        return params.result;
+    if (FAILED(hr = get_periods(client, &def_period, &min_period)))
+        return hr;
 
     TRACE("Device periods: %lu default and %lu minimum\n", (ULONG)def_period, (ULONG)min_period);
 
@@ -129,21 +140,21 @@ static HRESULT adjust_timing(struct audio_client *This,
         const WAVEFORMATEXTENSIBLE *fmtex = (WAVEFORMATEXTENSIBLE *)fmt;
         if (fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
            (fmtex->dwChannelMask == 0 || fmtex->dwChannelMask & SPEAKER_RESERVED))
-            params.result = AUDCLNT_E_UNSUPPORTED_FORMAT;
+            hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
         else {
             if (*period == 0)
                 *period = def_period;
             if (*period < min_period || *period > 5000000)
-                params.result = AUDCLNT_E_INVALID_DEVICE_PERIOD;
+                hr = AUDCLNT_E_INVALID_DEVICE_PERIOD;
             else if (*duration > 20000000) /* The smaller the period, the lower this limit. */
-                params.result = AUDCLNT_E_BUFFER_SIZE_ERROR;
+                hr = AUDCLNT_E_BUFFER_SIZE_ERROR;
             else if (flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) {
                 if (*duration != *period)
-                    params.result = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
+                    hr = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
 
                 FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
 
-                params.result = AUDCLNT_E_DEVICE_IN_USE;
+                hr = AUDCLNT_E_DEVICE_IN_USE;
             } else if (*duration < 8 * *period)
                 *duration = 8 * *period; /* May grow above 2s. */
         }
@@ -151,7 +162,7 @@ static HRESULT adjust_timing(struct audio_client *This,
 
     TRACE("Adjusted duration %lu and period %lu\n", (ULONG)*duration, (ULONG)*period);
 
-    return params.result;
+    return hr;
 }
 
 static void dump_fmt(const WAVEFORMATEX *fmt)
@@ -748,21 +759,13 @@ static HRESULT WINAPI client_GetDevicePeriod(IAudioClient3 *iface, REFERENCE_TIM
                                       REFERENCE_TIME *minperiod)
 {
     struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct get_device_period_params params;
 
     TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
 
     if (!defperiod && !minperiod)
         return E_POINTER;
 
-    params.device     = This->device_name;
-    params.flow       = This->dataflow;
-    params.def_period = defperiod;
-    params.min_period = minperiod;
-
-    wine_unix_call(get_device_period, &params);
-
-    return params.result;
+    return get_periods(This, defperiod, minperiod);
 }
 
 static HRESULT WINAPI client_Start(IAudioClient3 *iface)
-- 
GitLab


From 28818e6bd58512530b339a1a9232af82c252c7c9 Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Fri, 7 Jun 2024 20:12:58 +0200
Subject: [PATCH 2/2] winepulse: Don't set a floor for the period(s).

This driver, unlike the others, queries the engine for the actual device period.

The default period floor is not needed anymore because it now lives in mmdevapi.
The minimum period floor never mattered because exclusive mode is not supported.
---
 dlls/winepulse.drv/pulse.c | 9 ---------
 1 file changed, 9 deletions(-)

diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index dd8d0b4441d..068245f03b2 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -113,9 +113,6 @@ static pa_mainloop *pulse_ml;
 static struct list g_phys_speakers = LIST_INIT(g_phys_speakers);
 static struct list g_phys_sources = LIST_INIT(g_phys_sources);
 
-static const REFERENCE_TIME MinimumPeriod = 30000;
-static const REFERENCE_TIME DefaultPeriod = 100000;
-
 static pthread_mutex_t pulse_mutex;
 static pthread_cond_t pulse_cond = PTHREAD_COND_INITIALIZER;
 
@@ -750,12 +747,6 @@ static void pulse_probe_settings(int render, const char *pulse_name, WAVEFORMATE
     if (length)
         *def_period = *min_period = pa_bytes_to_usec(10 * length, &ss);
 
-    if (*min_period < MinimumPeriod)
-        *min_period = MinimumPeriod;
-
-    if (*def_period < DefaultPeriod)
-        *def_period = DefaultPeriod;
-
     wfx->wFormatTag = WAVE_FORMAT_EXTENSIBLE;
     wfx->cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
 
-- 
GitLab

From 5dcb879df1aa18dab2c97a0b963aafbf7079a68f Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Wed, 19 Jun 2024 02:51:58 +0200
Subject: [PATCH 1/5] mmdevapi: Return errors early in adjust_timing().

---
 dlls/mmdevapi/client.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index ed635bcf98a..1058c639ff9 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -140,21 +140,21 @@ static HRESULT adjust_timing(struct audio_client *client,
         const WAVEFORMATEXTENSIBLE *fmtex = (WAVEFORMATEXTENSIBLE *)fmt;
         if (fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
            (fmtex->dwChannelMask == 0 || fmtex->dwChannelMask & SPEAKER_RESERVED))
-            hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+            return AUDCLNT_E_UNSUPPORTED_FORMAT;
         else {
             if (*period == 0)
                 *period = def_period;
             if (*period < min_period || *period > 5000000)
-                hr = AUDCLNT_E_INVALID_DEVICE_PERIOD;
+                return AUDCLNT_E_INVALID_DEVICE_PERIOD;
             else if (*duration > 20000000) /* The smaller the period, the lower this limit. */
-                hr = AUDCLNT_E_BUFFER_SIZE_ERROR;
+                return AUDCLNT_E_BUFFER_SIZE_ERROR;
             else if (flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) {
                 if (*duration != *period)
-                    hr = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
+                    return AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
 
                 FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
 
-                hr = AUDCLNT_E_DEVICE_IN_USE;
+                return AUDCLNT_E_DEVICE_IN_USE;
             } else if (*duration < 8 * *period)
                 *duration = 8 * *period; /* May grow above 2s. */
         }
-- 
GitLab


From 73a501ab46581be49be0bcd52db93fb7c0dec8a7 Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Thu, 20 Jun 2024 19:58:07 +0200
Subject: [PATCH 2/5] mmdevapi: Introduce helper stream_init().

---
 dlls/mmdevapi/client.c | 183 +++++++++++++++++++++--------------------
 1 file changed, 96 insertions(+), 87 deletions(-)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index 1058c639ff9..7a141f03e19 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -355,6 +355,100 @@ skip:
     return wcsdup(name);
 }
 
+static HRESULT stream_init(struct audio_client *client,
+                           const AUDCLNT_SHAREMODE mode, const DWORD flags,
+                           REFERENCE_TIME duration, REFERENCE_TIME period,
+                           const WAVEFORMATEX *fmt, const GUID *sessionguid)
+{
+    struct create_stream_params params;
+    UINT32 i, channel_count;
+    stream_handle stream;
+    WCHAR *name;
+
+    if (!fmt)
+        return E_POINTER;
+
+    dump_fmt(fmt);
+
+    if (mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
+        return E_INVALIDARG;
+
+    if (flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
+                  AUDCLNT_STREAMFLAGS_LOOPBACK |
+                  AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
+                  AUDCLNT_STREAMFLAGS_NOPERSIST |
+                  AUDCLNT_STREAMFLAGS_RATEADJUST |
+                  AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
+                  AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
+                  AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED |
+                  AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY |
+                  AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM)) {
+        FIXME("Unknown flags: %08lx\n", flags);
+        return E_INVALIDARG;
+    }
+
+    if (FAILED(params.result = adjust_timing(client, &duration, &period, mode, flags, fmt)))
+        return params.result;
+
+    sessions_lock();
+
+    if (client->stream) {
+        sessions_unlock();
+        return AUDCLNT_E_ALREADY_INITIALIZED;
+    }
+
+    if (FAILED(params.result = main_loop_start())) {
+        sessions_unlock();
+        return params.result;
+    }
+
+    params.name = name   = get_application_name();
+    params.device        = client->device_name;
+    params.flow          = client->dataflow;
+    params.share         = mode;
+    params.flags         = flags;
+    params.duration      = duration;
+    params.period        = period;
+    params.fmt           = fmt;
+    params.channel_count = &channel_count;
+    params.stream        = &stream;
+
+    wine_unix_call(create_stream, &params);
+
+    free(name);
+
+    if (FAILED(params.result)) {
+        sessions_unlock();
+        return params.result;
+    }
+
+    if (!(client->vols = malloc(channel_count * sizeof(*client->vols)))) {
+        params.result = E_OUTOFMEMORY;
+        goto exit;
+    }
+
+    for (i = 0; i < channel_count; i++)
+        client->vols[i] = 1.f;
+
+    params.result = get_audio_session(sessionguid, client->parent, channel_count, &client->session);
+
+exit:
+    if (FAILED(params.result)) {
+        stream_release(stream, NULL);
+        free(client->vols);
+        client->vols = NULL;
+    } else {
+        list_add_tail(&client->session->clients, &client->entry);
+        client->stream = stream;
+        client->channel_count = channel_count;
+        set_stream_volumes(client);
+    }
+
+    sessions_unlock();
+
+    return params.result;
+}
+
 static HRESULT WINAPI capture_QueryInterface(IAudioCaptureClient *iface, REFIID riid, void **ppv)
 {
     struct audio_client *This = impl_from_IAudioCaptureClient(iface);
@@ -537,97 +631,12 @@ static HRESULT WINAPI client_Initialize(IAudioClient3 *iface, AUDCLNT_SHAREMODE
                                  const WAVEFORMATEX *fmt, const GUID *sessionguid)
 {
     struct audio_client *This = impl_from_IAudioClient3(iface);
-    struct create_stream_params params;
-    UINT32 i, channel_count;
-    stream_handle stream;
-    WCHAR *name;
 
     TRACE("(%p)->(%x, %lx, %s, %s, %p, %s)\n", This, mode, flags, wine_dbgstr_longlong(duration),
                                                wine_dbgstr_longlong(period), fmt,
                                                debugstr_guid(sessionguid));
 
-    if (!fmt)
-        return E_POINTER;
-
-    dump_fmt(fmt);
-
-    if (mode != AUDCLNT_SHAREMODE_SHARED && mode != AUDCLNT_SHAREMODE_EXCLUSIVE)
-        return E_INVALIDARG;
-
-    if (flags & ~(AUDCLNT_STREAMFLAGS_CROSSPROCESS |
-                  AUDCLNT_STREAMFLAGS_LOOPBACK |
-                  AUDCLNT_STREAMFLAGS_EVENTCALLBACK |
-                  AUDCLNT_STREAMFLAGS_NOPERSIST |
-                  AUDCLNT_STREAMFLAGS_RATEADJUST |
-                  AUDCLNT_SESSIONFLAGS_EXPIREWHENUNOWNED |
-                  AUDCLNT_SESSIONFLAGS_DISPLAY_HIDE |
-                  AUDCLNT_SESSIONFLAGS_DISPLAY_HIDEWHENEXPIRED |
-                  AUDCLNT_STREAMFLAGS_SRC_DEFAULT_QUALITY |
-                  AUDCLNT_STREAMFLAGS_AUTOCONVERTPCM)) {
-        FIXME("Unknown flags: %08lx\n", flags);
-        return E_INVALIDARG;
-    }
-
-    if (FAILED(params.result = adjust_timing(This, &duration, &period, mode, flags, fmt)))
-        return params.result;
-
-    sessions_lock();
-
-    if (This->stream) {
-        sessions_unlock();
-        return AUDCLNT_E_ALREADY_INITIALIZED;
-    }
-
-    if (FAILED(params.result = main_loop_start())) {
-        sessions_unlock();
-        return params.result;
-    }
-
-    params.name = name   = get_application_name();
-    params.device        = This->device_name;
-    params.flow          = This->dataflow;
-    params.share         = mode;
-    params.flags         = flags;
-    params.duration      = duration;
-    params.period        = period;
-    params.fmt           = fmt;
-    params.channel_count = &channel_count;
-    params.stream        = &stream;
-
-    wine_unix_call(create_stream, &params);
-
-    free(name);
-
-    if (FAILED(params.result)) {
-        sessions_unlock();
-        return params.result;
-    }
-
-    if (!(This->vols = malloc(channel_count * sizeof(*This->vols)))) {
-        params.result = E_OUTOFMEMORY;
-        goto exit;
-    }
-
-    for (i = 0; i < channel_count; i++)
-        This->vols[i] = 1.f;
-
-    params.result = get_audio_session(sessionguid, This->parent, channel_count, &This->session);
-
-exit:
-    if (FAILED(params.result)) {
-        stream_release(stream, NULL);
-        free(This->vols);
-        This->vols = NULL;
-    } else {
-        list_add_tail(&This->session->clients, &This->entry);
-        This->stream = stream;
-        This->channel_count = channel_count;
-        set_stream_volumes(This);
-    }
-
-    sessions_unlock();
-
-    return params.result;
+    return stream_init(This, mode, flags, duration, period, fmt, sessionguid);
 }
 
 static HRESULT WINAPI client_GetBufferSize(IAudioClient3 *iface, UINT32 *out)
@@ -1025,7 +1034,7 @@ static HRESULT WINAPI client_InitializeSharedAudioStream(IAudioClient3 *iface, D
         return E_POINTER;
 
     duration = period_frames * (REFERENCE_TIME)10000000 / format->nSamplesPerSec;
-    return client_Initialize(iface, AUDCLNT_SHAREMODE_SHARED, flags, duration, 0, format, session_guid);
+    return stream_init(This, AUDCLNT_SHAREMODE_SHARED, flags, duration, 0, format, session_guid);
 }
 
 const IAudioClient3Vtbl AudioClient3_Vtbl =
-- 
GitLab


From 9d046996cb2f150c39cfe341f6a8a29513d00736 Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Thu, 20 Jun 2024 20:00:02 +0200
Subject: [PATCH 3/5] mmdevapi: Complete
 IAudioClient3_InitializeSharedAudioStream.

---
 dlls/mmdevapi/client.c | 23 ++++++++++++++---------
 1 file changed, 14 insertions(+), 9 deletions(-)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index 7a141f03e19..1d6eefd5dbb 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -117,7 +117,7 @@ static HRESULT get_periods(struct audio_client *client,
     return params.result;
 }
 
-static HRESULT adjust_timing(struct audio_client *client,
+static HRESULT adjust_timing(struct audio_client *client, const BOOLEAN force_def_period,
                              REFERENCE_TIME *duration, REFERENCE_TIME *period,
                              const AUDCLNT_SHAREMODE mode, const DWORD flags,
                              const WAVEFORMATEX *fmt)
@@ -133,7 +133,10 @@ static HRESULT adjust_timing(struct audio_client *client,
     TRACE("Device periods: %lu default and %lu minimum\n", (ULONG)def_period, (ULONG)min_period);
 
     if (mode == AUDCLNT_SHAREMODE_SHARED) {
-        *period = def_period;
+        if (*period == 0 || force_def_period)
+            *period = def_period;
+        else if (*period < min_period)
+            return AUDCLNT_E_INVALID_DEVICE_PERIOD;
         if (*duration < 3 * *period)
             *duration = 3 * *period;
     } else {
@@ -355,7 +358,7 @@ skip:
     return wcsdup(name);
 }
 
-static HRESULT stream_init(struct audio_client *client,
+static HRESULT stream_init(struct audio_client *client, const BOOLEAN force_def_period,
                            const AUDCLNT_SHAREMODE mode, const DWORD flags,
                            REFERENCE_TIME duration, REFERENCE_TIME period,
                            const WAVEFORMATEX *fmt, const GUID *sessionguid)
@@ -387,7 +390,7 @@ static HRESULT stream_init(struct audio_client *client,
         return E_INVALIDARG;
     }
 
-    if (FAILED(params.result = adjust_timing(client, &duration, &period, mode, flags, fmt)))
+    if (FAILED(params.result = adjust_timing(client, force_def_period, &duration, &period, mode, flags, fmt)))
         return params.result;
 
     sessions_lock();
@@ -636,7 +639,7 @@ static HRESULT WINAPI client_Initialize(IAudioClient3 *iface, AUDCLNT_SHAREMODE
                                                wine_dbgstr_longlong(period), fmt,
                                                debugstr_guid(sessionguid));
 
-    return stream_init(This, mode, flags, duration, period, fmt, sessionguid);
+    return stream_init(This, TRUE, mode, flags, duration, period, fmt, sessionguid);
 }
 
 static HRESULT WINAPI client_GetBufferSize(IAudioClient3 *iface, UINT32 *out)
@@ -1027,14 +1030,16 @@ static HRESULT WINAPI client_InitializeSharedAudioStream(IAudioClient3 *iface, D
                                                   const GUID *session_guid)
 {
     struct audio_client *This = impl_from_IAudioClient3(iface);
-    REFERENCE_TIME duration;
-    FIXME("(%p)->(0x%lx, %u, %p, %s) - partial stub\n", This, flags, period_frames, format, debugstr_guid(session_guid));
+    REFERENCE_TIME period;
+
+    TRACE("(%p)->(0x%lx, %u, %p, %s)\n", This, flags, period_frames, format, debugstr_guid(session_guid));
 
     if (!format)
         return E_POINTER;
 
-    duration = period_frames * (REFERENCE_TIME)10000000 / format->nSamplesPerSec;
-    return stream_init(This, AUDCLNT_SHAREMODE_SHARED, flags, duration, 0, format, session_guid);
+    period = period_frames * (REFERENCE_TIME)10000000 / format->nSamplesPerSec;
+
+    return stream_init(This, FALSE, AUDCLNT_SHAREMODE_SHARED, flags, 0, period, format, session_guid);
 }
 
 const IAudioClient3Vtbl AudioClient3_Vtbl =
-- 
GitLab


From 235d527fa51b7d1ef25f9944d2bd69f05f67ce96 Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Thu, 20 Jun 2024 20:03:51 +0200
Subject: [PATCH 4/5] mmdevapi: Complete
 IAudioClient3_GetSharedModeEnginePeriod.

---
 dlls/mmdevapi/client.c | 20 +++++++++++++-------
 1 file changed, 13 insertions(+), 7 deletions(-)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index 1d6eefd5dbb..e0344aefa54 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -1002,17 +1002,23 @@ static HRESULT WINAPI client_GetSharedModeEnginePeriod(IAudioClient3 *iface,
                                                 UINT32 *max_period_frames)
 {
     struct audio_client *This = impl_from_IAudioClient3(iface);
-    FIXME("(%p)->(%p, %p, %p, %p, %p) - partial stub\n",
+    REFERENCE_TIME def_period, min_period;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %p, %p, %p, %p)\n",
           This, format, default_period_frames,
           unit_period_frames, min_period_frames,
           max_period_frames);
 
-    *default_period_frames =
-        *min_period_frames =
-        *max_period_frames =
-        format->nSamplesPerSec / 100; /* ~10ms */
-    *unit_period_frames = 1;
-    return S_OK;
+    if (FAILED(hr = get_periods(This, &def_period, &min_period)))
+        return hr;
+
+    *default_period_frames = def_period * format->nSamplesPerSec / (REFERENCE_TIME)10000000;
+    *min_period_frames     = min_period * format->nSamplesPerSec / (REFERENCE_TIME)10000000;
+    *max_period_frames     = *default_period_frames;
+    *unit_period_frames    = 1;
+
+    return hr;
 }
 
 static HRESULT WINAPI client_GetCurrentSharedModeEnginePeriod(IAudioClient3 *iface,
-- 
GitLab


From b34b5d84a6b5387a5d44cad34558676f01de5f4f Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Fri, 21 Jun 2024 22:38:56 +0200
Subject: [PATCH 5/5] mmdevapi: Implement
 IAudioClient3_GetCurrentSharedModeEnginePeriod.

---
 dlls/mmdevapi/client.c | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index e0344aefa54..132b6abae5e 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -1026,8 +1026,18 @@ static HRESULT WINAPI client_GetCurrentSharedModeEnginePeriod(IAudioClient3 *ifa
                                                        UINT32 *cur_period_frames)
 {
     struct audio_client *This = impl_from_IAudioClient3(iface);
-    FIXME("(%p)->(%p, %p) - stub\n", This, cur_format, cur_period_frames);
-    return E_NOTIMPL;
+    UINT32 dummy;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %p)\n", This, cur_format, cur_period_frames);
+
+    if (!cur_format || !cur_period_frames)
+        return E_POINTER;
+
+    if (FAILED(hr = client_GetMixFormat(iface, cur_format)))
+        return hr;
+
+    return client_GetSharedModeEnginePeriod(iface, *cur_format, cur_period_frames, &dummy, &dummy, &dummy);
 }
 
 static HRESULT WINAPI client_InitializeSharedAudioStream(IAudioClient3 *iface, DWORD flags,
-- 
GitLab

From 103cd4fa7a3e707c6966ca0975a92f4accdf0144 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 17 Jun 2024 18:12:34 -0600
Subject: [PATCH 1/6] mmdevapi: Store device_name as a pointer in struct
 audio_client.

---
 dlls/mmdevapi/client.c   | 9 ++++-----
 dlls/mmdevapi/mmdevdrv.h | 4 +---
 2 files changed, 5 insertions(+), 8 deletions(-)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index 132b6abae5e..4a205632b12 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -623,6 +623,7 @@ static ULONG WINAPI client_Release(IAudioClient3 *iface)
         if (This->stream)
             stream_release(This->stream, This->timer_thread);
 
+        free(This->device_name);
         free(This);
     }
 
@@ -1492,7 +1493,6 @@ HRESULT AudioClient_Create(GUID *guid, IMMDevice *device, IAudioClient **out)
     struct audio_client *This;
     char *name;
     EDataFlow dataflow;
-    size_t size;
     HRESULT hr;
 
     TRACE("%s %p %p\n", debugstr_guid(guid), device, out);
@@ -1507,15 +1507,13 @@ HRESULT AudioClient_Create(GUID *guid, IMMDevice *device, IAudioClient **out)
         return E_UNEXPECTED;
     }
 
-    size = strlen(name) + 1;
-    This = calloc(1, FIELD_OFFSET(struct audio_client, device_name[size]));
+    This = calloc(1, sizeof(*This));
     if (!This) {
         free(name);
         return E_OUTOFMEMORY;
     }
 
-    memcpy(This->device_name, name, size);
-    free(name);
+    This->device_name = name;
 
     This->IAudioCaptureClient_iface.lpVtbl = &AudioCaptureClient_Vtbl;
     This->IAudioClient3_iface.lpVtbl       = &AudioClient3_Vtbl;
@@ -1529,6 +1527,7 @@ HRESULT AudioClient_Create(GUID *guid, IMMDevice *device, IAudioClient **out)
 
     hr = CoCreateFreeThreadedMarshaler((IUnknown *)&This->IAudioClient3_iface, &This->marshal);
     if (FAILED(hr)) {
+        free(This->device_name);
         free(This);
         return hr;
     }
diff --git a/dlls/mmdevapi/mmdevdrv.h b/dlls/mmdevapi/mmdevdrv.h
index 42b01443ff0..7683867a9c1 100644
--- a/dlls/mmdevapi/mmdevdrv.h
+++ b/dlls/mmdevapi/mmdevdrv.h
@@ -80,7 +80,5 @@ struct audio_client {
     struct audio_session_wrapper *session_wrapper;
 
     struct list entry;
-
-    /* Keep at end */
-    char device_name[0];
+    char *device_name;
 };
-- 
GitLab


From 0ca742689729f0a547facf2bd8e046711c57b12c Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 17 Jun 2024 19:16:01 -0600
Subject: [PATCH 2/6] mmdevapi: Adjust timing after main loop start in
 client_Initialize().

---
 dlls/mmdevapi/client.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index 4a205632b12..70fd176f3a7 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -390,9 +390,6 @@ static HRESULT stream_init(struct audio_client *client, const BOOLEAN force_def_
         return E_INVALIDARG;
     }
 
-    if (FAILED(params.result = adjust_timing(client, force_def_period, &duration, &period, mode, flags, fmt)))
-        return params.result;
-
     sessions_lock();
 
     if (client->stream) {
@@ -405,6 +402,11 @@ static HRESULT stream_init(struct audio_client *client, const BOOLEAN force_def_
         return params.result;
     }
 
+    if (FAILED(params.result = adjust_timing(client, force_def_period, &duration, &period, mode, flags, fmt))) {
+        sessions_unlock();
+        return params.result;
+    }
+
     params.name = name   = get_application_name();
     params.device        = client->device_name;
     params.flow          = client->dataflow;
-- 
GitLab


From 9fec6e7dfa801a2401e1b17ef7b2dc4e088ff80a Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 17 Jun 2024 15:27:05 -0600
Subject: [PATCH 3/6] mmdevapi: Stub AUDCLNT_STREAMFLAGS_LOOPBACK support.

---
 dlls/mmdevapi/client.c             | 35 ++++++++++++++++++++++++++++++
 dlls/mmdevapi/unixlib.h            | 10 +++++++++
 dlls/winealsa.drv/alsa.c           |  2 ++
 dlls/winecoreaudio.drv/coreaudio.c |  2 ++
 dlls/wineoss.drv/oss.c             |  2 ++
 dlls/winepulse.drv/pulse.c         |  2 ++
 6 files changed, 53 insertions(+)

diff --git a/dlls/mmdevapi/client.c b/dlls/mmdevapi/client.c
index 70fd176f3a7..860c31f4b49 100644
--- a/dlls/mmdevapi/client.c
+++ b/dlls/mmdevapi/client.c
@@ -21,6 +21,9 @@
 
 #define COBJMACROS
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
 #include <wchar.h>
 
 #include <audiopolicy.h>
@@ -402,6 +405,38 @@ static HRESULT stream_init(struct audio_client *client, const BOOLEAN force_def_
         return params.result;
     }
 
+    if (flags & AUDCLNT_STREAMFLAGS_LOOPBACK) {
+        struct get_loopback_capture_device_params params;
+
+        if (client->dataflow != eRender) {
+            sessions_unlock();
+            return AUDCLNT_E_WRONG_ENDPOINT_TYPE;
+        }
+
+        params.device = client->device_name;
+        params.name = name = get_application_name();
+        params.ret_device_len = 0;
+        params.ret_device = NULL;
+        params.result = E_NOTIMPL;
+        wine_unix_call(get_loopback_capture_device, &params);
+        while (params.result == STATUS_BUFFER_TOO_SMALL) {
+            free(params.ret_device);
+            params.ret_device = malloc(params.ret_device_len);
+            wine_unix_call(get_loopback_capture_device, &params);
+        }
+        free(name);
+        if (FAILED(params.result)) {
+            sessions_unlock();
+            free(params.ret_device);
+            if (params.result == E_NOTIMPL)
+                FIXME("get_loopback_capture_device is not supported by backend.\n");
+            return params.result;
+        }
+        free(client->device_name);
+        client->device_name = params.ret_device;
+        client->dataflow = eCapture;
+    }
+
     if (FAILED(params.result = adjust_timing(client, force_def_period, &duration, &period, mode, flags, fmt))) {
         sessions_unlock();
         return params.result;
diff --git a/dlls/mmdevapi/unixlib.h b/dlls/mmdevapi/unixlib.h
index d83ed918a51..4cb4c881bcf 100644
--- a/dlls/mmdevapi/unixlib.h
+++ b/dlls/mmdevapi/unixlib.h
@@ -140,6 +140,15 @@ struct is_format_supported_params
     HRESULT result;
 };
 
+struct get_loopback_capture_device_params
+{
+    const WCHAR *name;
+    const char *device;
+    char *ret_device;
+    UINT32 ret_device_len;
+    HRESULT result;
+};
+
 struct get_mix_format_params
 {
     const char *device;
@@ -313,6 +322,7 @@ enum unix_funcs
     get_capture_buffer,
     release_capture_buffer,
     is_format_supported,
+    get_loopback_capture_device,
     get_mix_format,
     get_device_period,
     get_buffer_size,
diff --git a/dlls/winealsa.drv/alsa.c b/dlls/winealsa.drv/alsa.c
index a24cb56d1d8..970db59ad12 100644
--- a/dlls/winealsa.drv/alsa.c
+++ b/dlls/winealsa.drv/alsa.c
@@ -2491,6 +2491,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     alsa_get_capture_buffer,
     alsa_release_capture_buffer,
     alsa_is_format_supported,
+    alsa_not_implemented,
     alsa_get_mix_format,
     alsa_get_device_period,
     alsa_get_buffer_size,
@@ -2947,6 +2948,7 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     alsa_wow64_get_capture_buffer,
     alsa_release_capture_buffer,
     alsa_wow64_is_format_supported,
+    alsa_not_implemented,
     alsa_wow64_get_mix_format,
     alsa_wow64_get_device_period,
     alsa_wow64_get_buffer_size,
diff --git a/dlls/winecoreaudio.drv/coreaudio.c b/dlls/winecoreaudio.drv/coreaudio.c
index deb9df1b45a..db5e1116bf8 100644
--- a/dlls/winecoreaudio.drv/coreaudio.c
+++ b/dlls/winecoreaudio.drv/coreaudio.c
@@ -1837,6 +1837,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     unix_get_capture_buffer,
     unix_release_capture_buffer,
     unix_is_format_supported,
+    unix_not_implemented,
     unix_get_mix_format,
     unix_get_device_period,
     unix_get_buffer_size,
@@ -2292,6 +2293,7 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     unix_wow64_get_capture_buffer,
     unix_release_capture_buffer,
     unix_wow64_is_format_supported,
+    unix_not_implemented,
     unix_wow64_get_mix_format,
     unix_wow64_get_device_period,
     unix_wow64_get_buffer_size,
diff --git a/dlls/wineoss.drv/oss.c b/dlls/wineoss.drv/oss.c
index 819e876606c..a017d242a98 100644
--- a/dlls/wineoss.drv/oss.c
+++ b/dlls/wineoss.drv/oss.c
@@ -1691,6 +1691,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     oss_get_capture_buffer,
     oss_release_capture_buffer,
     oss_is_format_supported,
+    oss_not_implemented,
     oss_get_mix_format,
     oss_get_device_period,
     oss_get_buffer_size,
@@ -2186,6 +2187,7 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     oss_wow64_get_capture_buffer,
     oss_release_capture_buffer,
     oss_wow64_is_format_supported,
+    oss_not_implemented,
     oss_wow64_get_mix_format,
     oss_wow64_get_device_period,
     oss_wow64_get_buffer_size,
diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index 068245f03b2..9d3363e2638 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -2536,6 +2536,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     pulse_get_capture_buffer,
     pulse_release_capture_buffer,
     pulse_is_format_supported,
+    pulse_not_implemented,
     pulse_get_mix_format,
     pulse_get_device_period,
     pulse_get_buffer_size,
@@ -3007,6 +3008,7 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     pulse_wow64_get_capture_buffer,
     pulse_release_capture_buffer,
     pulse_wow64_is_format_supported,
+    pulse_not_implemented,
     pulse_wow64_get_mix_format,
     pulse_wow64_get_device_period,
     pulse_wow64_get_buffer_size,
-- 
GitLab


From cc27bc6d34fc8d77c2cfdfd97f1a5e95e0676d8c Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 17 Jun 2024 18:41:09 -0600
Subject: [PATCH 4/6] winepulse.drv: Factor out wait_pa_operation_complete().

---
 dlls/winepulse.drv/pulse.c | 51 ++++++++++++--------------------------
 1 file changed, 16 insertions(+), 35 deletions(-)

diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index 9d3363e2638..dac1b40257f 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -203,6 +203,17 @@ static char *wstr_to_str(const WCHAR *wstr)
     return str;
 }
 
+static BOOL wait_pa_operation_complete(pa_operation *o)
+{
+    if (!o)
+        return FALSE;
+
+    while (pa_operation_get_state(o) == PA_OPERATION_RUNNING)
+        pulse_cond_wait();
+    pa_operation_unref(o);
+    return TRUE;
+}
+
 /* Following pulseaudio design here, mainloop has the lock taken whenever
  * it is handling something for pulse, and the lock is required whenever
  * doing any pa_* call that can affect the state in any way
@@ -1548,7 +1559,6 @@ static NTSTATUS pulse_timer_loop(void *args)
     pa_usec_t last_time;
     UINT32 adv_bytes;
     int success;
-    pa_operation *o;
 
     pulse_lock();
     delay.QuadPart = -stream->mmdev_period_usec * 10;
@@ -1566,13 +1576,7 @@ static NTSTATUS pulse_timer_loop(void *args)
 
         delay.QuadPart = -stream->mmdev_period_usec * 10;
 
-        o = pa_stream_update_timing_info(stream->stream, pulse_op_cb, &success);
-        if (o)
-        {
-            while (pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-                pulse_cond_wait();
-            pa_operation_unref(o);
-        }
+        wait_pa_operation_complete(pa_stream_update_timing_info(stream->stream, pulse_op_cb, &success));
         err = pa_stream_get_time(stream->stream, &now);
         if (err == 0)
         {
@@ -1653,7 +1657,6 @@ static NTSTATUS pulse_start(void *args)
     struct start_params *params = args;
     struct pulse_stream *stream = handle_get_stream(params->stream);
     int success;
-    pa_operation *o;
 
     params->result = S_OK;
     pulse_lock();
@@ -1682,14 +1685,7 @@ static NTSTATUS pulse_start(void *args)
 
     if (pa_stream_is_corked(stream->stream))
     {
-        o = pa_stream_cork(stream->stream, 0, pulse_op_cb, &success);
-        if (o)
-        {
-            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-                pulse_cond_wait();
-            pa_operation_unref(o);
-        }
-        else
+        if (!wait_pa_operation_complete(pa_stream_cork(stream->stream, 0, pulse_op_cb, &success)))
             success = 0;
         if (!success)
             params->result = E_FAIL;
@@ -1708,7 +1704,6 @@ static NTSTATUS pulse_stop(void *args)
 {
     struct stop_params *params = args;
     struct pulse_stream *stream = handle_get_stream(params->stream);
-    pa_operation *o;
     int success;
 
     pulse_lock();
@@ -1729,14 +1724,7 @@ static NTSTATUS pulse_stop(void *args)
     params->result = S_OK;
     if (stream->dataflow == eRender)
     {
-        o = pa_stream_cork(stream->stream, 1, pulse_op_cb, &success);
-        if (o)
-        {
-            while(pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-                pulse_cond_wait();
-            pa_operation_unref(o);
-        }
-        else
+        if (!wait_pa_operation_complete(pa_stream_cork(stream->stream, 1, pulse_op_cb, &success)))
             success = 0;
         if (!success)
             params->result = E_FAIL;
@@ -1779,15 +1767,8 @@ static NTSTATUS pulse_reset(void *args)
         /* If there is still data in the render buffer it needs to be removed from the server */
         int success = 0;
         if (stream->held_bytes)
-        {
-            pa_operation *o = pa_stream_flush(stream->stream, pulse_op_cb, &success);
-            if (o)
-            {
-                while (pa_operation_get_state(o) == PA_OPERATION_RUNNING)
-                    pulse_cond_wait();
-                pa_operation_unref(o);
-            }
-        }
+            wait_pa_operation_complete(pa_stream_flush(stream->stream, pulse_op_cb, &success));
+
         if (success || !stream->held_bytes)
         {
             stream->clock_lastpos = stream->clock_written = 0;
-- 
GitLab


From 0bb23c2c91cca3da599eb3710c5e0cf20c01aa45 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 17 Jun 2024 17:22:14 -0600
Subject: [PATCH 5/6] winepulse.drv: Implement
 pulse_get_loopback_capture_device().

---
 dlls/winepulse.drv/pulse.c | 112 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 110 insertions(+), 2 deletions(-)

diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index dac1b40257f..263d0f1a45a 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -2199,6 +2199,89 @@ static NTSTATUS pulse_is_format_supported(void *args)
     return STATUS_SUCCESS;
 }
 
+static void sink_name_info_cb(pa_context *c, const pa_sink_info *i, int eol, void *userdata)
+{
+    uint32_t *current_device_index = userdata;
+    pulse_broadcast();
+
+    if (!i || !i->name || !i->name[0])
+        return;
+    *current_device_index = i->index;
+}
+
+struct find_monitor_of_sink_cb_param
+{
+    struct get_loopback_capture_device_params *params;
+    uint32_t current_device_index;
+};
+
+static void find_monitor_of_sink_cb(pa_context *c, const pa_source_info *i, int eol, void *userdata)
+{
+    struct find_monitor_of_sink_cb_param *p = userdata;
+    unsigned int len;
+
+    pulse_broadcast();
+
+    if (!i || !i->name || !i->name[0])
+        return;
+    if (i->monitor_of_sink != p->current_device_index)
+        return;
+
+    len = strlen(i->name) + 1;
+    if (len <= p->params->ret_device_len)
+    {
+        memcpy(p->params->ret_device, i->name, len);
+        p->params->result = STATUS_SUCCESS;
+        return;
+    }
+    p->params->ret_device_len = len;
+    p->params->result = STATUS_BUFFER_TOO_SMALL;
+}
+
+static NTSTATUS pulse_get_loopback_capture_device(void *args)
+{
+    struct get_loopback_capture_device_params *params = args;
+    uint32_t current_device_index = PA_INVALID_INDEX;
+    struct find_monitor_of_sink_cb_param p;
+    const char *device_name;
+    char *name;
+
+    pulse_lock();
+
+    if (!pulse_ml)
+    {
+        pulse_unlock();
+        ERR("Called without main loop running.\n");
+        params->result = E_INVALIDARG;
+        return STATUS_SUCCESS;
+    }
+
+    name = wstr_to_str(params->name);
+    params->result = pulse_connect(name);
+    free(name);
+
+    if (FAILED(params->result))
+    {
+        pulse_unlock();
+        return STATUS_SUCCESS;
+    }
+
+    device_name = params->device;
+    if (device_name && !device_name[0]) device_name = NULL;
+
+    params->result = E_FAIL;
+    wait_pa_operation_complete(pa_context_get_sink_info_by_name(pulse_ctx, device_name, &sink_name_info_cb, &current_device_index));
+    if (current_device_index != PA_INVALID_INDEX)
+    {
+        p.current_device_index = current_device_index;
+        p.params = params;
+        wait_pa_operation_complete(pa_context_get_source_info_list(pulse_ctx, &find_monitor_of_sink_cb, &p));
+    }
+
+    pulse_unlock();
+    return STATUS_SUCCESS;
+}
+
 static NTSTATUS pulse_get_mix_format(void *args)
 {
     struct get_mix_format_params *params = args;
@@ -2517,7 +2600,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     pulse_get_capture_buffer,
     pulse_release_capture_buffer,
     pulse_is_format_supported,
-    pulse_not_implemented,
+    pulse_get_loopback_capture_device,
     pulse_get_mix_format,
     pulse_get_device_period,
     pulse_get_buffer_size,
@@ -2709,6 +2792,31 @@ static NTSTATUS pulse_wow64_is_format_supported(void *args)
     return STATUS_SUCCESS;
 }
 
+static NTSTATUS pulse_wow64_get_loopback_capture_device(void *args)
+{
+    struct
+    {
+        PTR32 name;
+        PTR32 device;
+        PTR32 ret_device;
+        UINT32 ret_device_len;
+        HRESULT result;
+    } *params32 = args;
+
+    struct get_loopback_capture_device_params params =
+    {
+        .name = ULongToPtr(params32->name),
+        .device = ULongToPtr(params32->device),
+        .ret_device = ULongToPtr(params32->ret_device),
+        .ret_device_len = params32->ret_device_len,
+    };
+
+    pulse_get_loopback_capture_device(&params);
+    params32->result = params.result;
+    params32->ret_device_len = params.ret_device_len;
+    return STATUS_SUCCESS;
+}
+
 static NTSTATUS pulse_wow64_get_mix_format(void *args)
 {
     struct
@@ -2989,7 +3097,7 @@ const unixlib_entry_t __wine_unix_call_wow64_funcs[] =
     pulse_wow64_get_capture_buffer,
     pulse_release_capture_buffer,
     pulse_wow64_is_format_supported,
-    pulse_not_implemented,
+    pulse_wow64_get_loopback_capture_device,
     pulse_wow64_get_mix_format,
     pulse_wow64_get_device_period,
     pulse_wow64_get_buffer_size,
-- 
GitLab


From e727324e15f781f21f33046e1ed430cdc38ca183 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 17 Jun 2024 20:06:19 -0600
Subject: [PATCH 6/6] mmdevapi/tests: Add test for capturing render loopback.

---
 dlls/mmdevapi/tests/capture.c | 62 +++++++++++++++++++++++++++++++++--
 1 file changed, 60 insertions(+), 2 deletions(-)

diff --git a/dlls/mmdevapi/tests/capture.c b/dlls/mmdevapi/tests/capture.c
index 08ab730ef1a..e3ae87fd9bd 100644
--- a/dlls/mmdevapi/tests/capture.c
+++ b/dlls/mmdevapi/tests/capture.c
@@ -41,7 +41,8 @@
 /* undocumented error code */
 #define D3D11_ERROR_4E MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DIRECT3D11, 0x4e)
 
-static IMMDevice *dev = NULL;
+static IMMDeviceEnumerator *mme;
+static IMMDevice *dev;
 static const LARGE_INTEGER ullZero;
 
 static void test_uninitialized(IAudioClient *ac)
@@ -1012,10 +1013,66 @@ static void test_marshal(void)
 
 }
 
+static void test_render_loopback(void)
+{
+    IAudioCaptureClient *capture;
+    IAudioRenderClient *render;
+    WAVEFORMATEX *pwfx;
+    IMMDevice *device;
+    IAudioClient *ac;
+    HRESULT hr;
+
+    hr = IMMDeviceEnumerator_GetDefaultAudioEndpoint(mme, eRender, eMultimedia, &device);
+    ok(hr == S_OK || hr == E_NOTFOUND, "GetDefaultAudioEndpoint failed: %#lx.\n", hr);
+
+    if (hr != S_OK || !dev)
+    {
+        if (hr == E_NOTFOUND)
+            skip("No sound card available\n");
+        else
+            skip("GetDefaultAudioEndpoint returns 0x%08lx\n", hr);
+        return;
+    }
+
+    hr = IMMDevice_Activate(dev, &IID_IAudioClient, CLSCTX_INPROC_SERVER, NULL, (void**)&ac);
+    ok(hr == S_OK, "got %#lx.\n", hr);
+
+    hr = IAudioClient_GetMixFormat(ac, &pwfx);
+    ok(hr == S_OK, "got %#lx.\n", hr);
+
+    hr = IAudioClient_Initialize(ac, AUDCLNT_SHAREMODE_SHARED,
+            AUDCLNT_STREAMFLAGS_EVENTCALLBACK | AUDCLNT_STREAMFLAGS_LOOPBACK, 5000000, 0, pwfx, NULL);
+    ok(hr == AUDCLNT_E_WRONG_ENDPOINT_TYPE, "got %#lx.\n", hr);
+    IAudioClient_Release(ac);
+    CoTaskMemFree(pwfx);
+
+    hr = IMMDevice_Activate(device, &IID_IAudioClient, CLSCTX_INPROC_SERVER, NULL, (void**)&ac);
+    ok(hr == S_OK, "got %#lx.\n", hr);
+
+    hr = IAudioClient_GetMixFormat(ac, &pwfx);
+    ok(hr == S_OK, "got %#lx.\n", hr);
+
+    hr = IAudioClient_Initialize(ac, AUDCLNT_SHAREMODE_SHARED, AUDCLNT_STREAMFLAGS_LOOPBACK, 5000000, 0, pwfx, NULL);
+    todo_wine_if(hr == E_NOTIMPL) ok(hr == S_OK, "got %#lx.\n", hr);
+    if (FAILED(hr))
+        goto done;
+
+    hr = IAudioClient_GetService(ac, &IID_IAudioRenderClient, (void **)&render);
+    ok(hr == AUDCLNT_E_WRONG_ENDPOINT_TYPE, "got %#lx.\n", hr);
+
+    hr = IAudioClient_GetService(ac, &IID_IAudioCaptureClient, (void **)&capture);
+    ok(hr == S_OK, "got %#lx.\n", hr);
+    IAudioCaptureClient_Release(capture);
+
+done:
+    IAudioClient_Release(ac);
+    IMMDevice_Release(device);
+    CoTaskMemFree(pwfx);
+}
+
 START_TEST(capture)
 {
     HRESULT hr;
-    IMMDeviceEnumerator *mme = NULL;
 
     CoInitializeEx(NULL, COINIT_MULTITHREADED);
     hr = CoCreateInstance(&CLSID_MMDeviceEnumerator, NULL, CLSCTX_INPROC_SERVER, &IID_IMMDeviceEnumerator, (void**)&mme);
@@ -1042,6 +1099,7 @@ START_TEST(capture)
     test_simplevolume();
     test_volume_dependence();
     test_marshal();
+    test_render_loopback();
 
     IMMDevice_Release(dev);
 
-- 
GitLab


