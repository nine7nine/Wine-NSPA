--- a/dlls/ntdll/unix/thread.c	2024-07-15 19:50:20.161550345 -0500
+++ b/dlls/ntdll/unix/thread.c	2024-07-15 19:49:41.447334327 -0500
@@ -83,82 +83,56 @@ WINE_DECLARE_DEBUG_CHANNEL(threadname);
 static int thread_kapc_priority = -1;
 static int thread_p_priority = -1;
 
-/* gets the priority value from an environment variable */
-static int get_priority( const char *variable, int min, int max )
-{
-    const char *env;
-    int val;
-
-    env = getenv( variable );
+/* Gets the priority value from an environment variable */
+static int get_priority(const char *variable, int min, int max) {
+    const char *env = getenv(variable);
     if (!env) return -1;
 
-    val = atoi( env );
-    if (val >= min && val <= max) return val;
-    return -1;
+    int val = atoi(env);
+    return (val >= min && val <= max) ? val : -1;
 }
 
-static int fget_priority( const char *variable, int min, int max )
-{
-    const char *env;
-    int val;
-
-    env = getenv( variable );
-    if (!env) return -1;
-
-    val = atoi( env );
-    if (val >= min && val <= max) return val;
-    return -1;
-}
-
-static int priority;
-static int fpriority;
-
-int ntdll_set_sync_realtime (pthread_t pthread_id, int ntdll_rt_policy, int priority)
-{
-    // Get RT policy
+static int priority;
+static int fpriority;
+
+/* Sets the real-time priority for synchronization threads */
+int ntdll_set_sync_realtime(pthread_t pthread_id, int ntdll_rt_policy, int priority) {
     const char *policyStr = getenv("NTDLL_RT_POLICY");
-    int min, max, p_priority;
-    min = sched_get_priority_min( SCHED_FIFO );
-    max = sched_get_priority_max( SCHED_FIFO );
+    int min = sched_get_priority_min(SCHED_FIFO);
+    int max = sched_get_priority_max(SCHED_FIFO);
 
+    // Determine the scheduling policy
     if (policyStr) {
-        if (strcmp(policyStr, "RR")==0)
-            ntdll_rt_policy = SCHED_RR;
-        if (strcmp(policyStr, "FF")==0)
-            ntdll_rt_policy = SCHED_FIFO;
-        else if (strcmp(policyStr, "TS")==0)
-            ntdll_rt_policy = SCHED_OTHER;
-    }
-   
-    if ((p_priority = get_priority( "NTDLL_RT_PRIO", min, max -1)) != -1)
-    {
-        thread_p_priority = p_priority;
+        if (strcmp(policyStr, "RR") == 0) ntdll_rt_policy = SCHED_RR;
+        else if (strcmp(policyStr, "FF") == 0) ntdll_rt_policy = SCHED_FIFO;
+        else if (strcmp(policyStr, "TS") == 0) ntdll_rt_policy = SCHED_OTHER;
     }
-	struct sched_param param;	
-	param.sched_priority = thread_p_priority;
 
-	return pthread_setschedparam (pthread_id, ntdll_rt_policy|SCHED_RESET_ON_FORK, &param);
+    // Get the real-time priority
+    if ((thread_p_priority = get_priority("NTDLL_RT_PRIO", min, max - 1)) != -1) {
+        struct sched_param param;
+        param.sched_priority = thread_p_priority;
+        return pthread_setschedparam(pthread_id, ntdll_rt_policy | SCHED_RESET_ON_FORK, &param);
+    }
+    return -1; 
 }
 
-int ntdll_set_fsync_realtime (pthread_t pthread_id, int fifo, int fpriority)
-{
-    // RT policy is SCHED_FIFO
-    int min, max, kapc_priority;
-    min = sched_get_priority_min( SCHED_FIFO );
-    max = sched_get_priority_max( SCHED_FIFO );
+/* Sets the real-time priority for fsync threads */
+int ntdll_set_fsync_realtime(pthread_t pthread_id, int fifo, int fpriority) {
+    int min = sched_get_priority_min(SCHED_FIFO);
+    int max = sched_get_priority_max(SCHED_FIFO);
     fifo = SCHED_FIFO;
-   
-    if ((kapc_priority = fget_priority( "WINE_RT_PRIO", min, max -1)) != -1)
-    {
-        thread_kapc_priority = kapc_priority -2;
-    }
-	struct sched_param param;	
-	param.sched_priority = thread_kapc_priority;
-
-	return pthread_setschedparam (pthread_id, fifo|SCHED_RESET_ON_FORK, &param);
-}
 
-#endif
+    // Get the fsync priority
+    if ((thread_kapc_priority = get_priority("WINE_RT_PRIO", min, max - 1)) != -1) {
+        thread_kapc_priority -= 2;
+        struct sched_param param;
+        param.sched_priority = thread_kapc_priority;
+        return pthread_setschedparam(pthread_id, fifo | SCHED_RESET_ON_FORK, &param);
+    }
+    return -1;
+}
+#endif
 
 pthread_key_t teb_key = 0;
 
@@ -1510,43 +1480,42 @@ done:
     if (attr_list) update_attr_list( attr_list, &teb->ClientId, teb );
     
 #if NSPA_RT_SYNC
-    // give pthread_create a chance to call start_thread (pthread_info.entry), 
-    // which sets gets the tid via pthread_functions.init_current_teb
+    // Give pthread_create a chance to call start_thread (pthread_info.entry),
+    // which gets the tid via pthread_functions.init_current_teb
     // 
     // Catch all Synchronization Threads;
-    pthread_t validPIDThread = (thread_data->pthread_id);
-    pthread_t validIDXThread = (thread_data->fsync_apc_idx);
+    pthread_t validPIDThread = thread_data->pthread_id;
+    pthread_t validIDXThread = thread_data->fsync_apc_idx;
                                 
     if (validIDXThread || validPIDThread == 0) {
-        int i;
-        for (i = 0; i < 100; ++i) {
-            validIDXThread = (thread_data->fsync_apc_idx);
-            validPIDThread = (thread_data->pthread_id);
+        for (int i = 0; i < 100; ++i) {
+            validIDXThread = thread_data->fsync_apc_idx;
+            validPIDThread = thread_data->pthread_id;
                                
             if (validIDXThread || validPIDThread == 0)
                 usleep(300);
         }
     }
+    
     if (validPIDThread != 0) {
         // Fail on / filter out unsupported threads;
         if (handle == GetCurrentThread() && (validPIDThread != thread_data->pthread_id)) { 
             return status;
         }
 
-        // set RT for most threads (low RT priority => NTDLL_RT_PRIO priority)
+        // Set RT for most threads (low RT priority => NTDLL_RT_PRIO priority)
         pthread_attr_setinheritsched(&pthread_attr, PTHREAD_EXPLICIT_SCHED);
-        ntdll_set_sync_realtime(validPIDThread, ntdll_rt_policy|SCHED_RESET_ON_FORK, priority);
-    }
-    else if (validIDXThread != 0) {
+        ntdll_set_sync_realtime(validPIDThread, ntdll_rt_policy | SCHED_RESET_ON_FORK, priority);
+    } else if (validIDXThread != 0) {
         // Fail on / filter out unsupported threads;
         if (handle == GetCurrentThread() && (validIDXThread != thread_data->fsync_apc_idx)) { 
             return status;
         }
 
-        // set RT for fsync threads (high RT Priority: Kernel APCs, threads, etc)
+        // Set RT for fsync threads (high RT Priority: Kernel APCs, threads, etc)
         pthread_attr_setinheritsched(&pthread_attr, PTHREAD_EXPLICIT_SCHED);
-        // hardcoded to SCHED_FIFO (=> WINE_RT_PRIO priority)
-        ntdll_set_fsync_realtime(validIDXThread, SCHED_FIFO|SCHED_RESET_ON_FORK, fpriority);
+        // Hardcoded to SCHED_FIFO (=> WINE_RT_PRIO priority)
+        ntdll_set_fsync_realtime(validIDXThread, SCHED_FIFO | SCHED_RESET_ON_FORK, fpriority);
     }
 #endif
     return STATUS_SUCCESS;

