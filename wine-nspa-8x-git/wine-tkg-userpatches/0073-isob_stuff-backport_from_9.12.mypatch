From 0e928ccaea0c03da28fca2d7356402c6c2357cc9 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 25 Jul 2022 19:13:31 -0500
Subject: [PATCH 1/5] ntdll: Remove the redundant filling of the IOSB in
 NtDeviceIoControlFile().

---
 dlls/ntdll/unix/file.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 429f8839ed2..e521dd44686 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -6120,7 +6120,6 @@ NTSTATUS WINAPI NtDeviceIoControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUT
     case FILE_DEVICE_BEEP:
     case FILE_DEVICE_NETWORK:
         status = sock_ioctl( handle, event, apc, apc_context, io, code, in_buffer, in_size, out_buffer, out_size );
-        if (status != STATUS_NOT_SUPPORTED && status != STATUS_BAD_DEVICE_TYPE) return status;
         break;
     case FILE_DEVICE_DISK:
     case FILE_DEVICE_CD_ROM:
@@ -6143,8 +6142,6 @@ NTSTATUS WINAPI NtDeviceIoControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUT
     if (status == STATUS_NOT_SUPPORTED || status == STATUS_BAD_DEVICE_TYPE)
         return server_ioctl_file( handle, event, apc, apc_context, io, code,
                                   in_buffer, in_size, out_buffer, out_size );
-
-    if (status != STATUS_PENDING && !NT_ERROR(status)) io->Status = status;
     return status;
 }
 
-- 
GitLab


From 5f76f07bff03dc80453cf742be1fe23781c12d92 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 24 Jun 2022 20:36:30 -0500
Subject: [PATCH 2/5] ntdll: Do not fill the IOSB or signal completion on
 failure in cdrom_DeviceIoControl().

Synchronous NT_ERROR conditions should not touch the IOSB or signal completion.
---
 dlls/ntdll/unix/cdrom.c | 29 +++++++++++------------------
 1 file changed, 11 insertions(+), 18 deletions(-)

diff --git a/dlls/ntdll/unix/cdrom.c b/dlls/ntdll/unix/cdrom.c
index 45b61d54d05..427e559968f 100644
--- a/dlls/ntdll/unix/cdrom.c
+++ b/dlls/ntdll/unix/cdrom.c
@@ -2822,18 +2822,13 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
 
     TRACE( "%p %s %p %d %p %d %p\n", device, iocodex(code), in_buffer, in_size, out_buffer, out_size, io );
 
-    io->Information = 0;
-
     if ((status = server_get_unix_fd( device, 0, &fd, &needs_close, NULL, NULL )))
-    {
-        if (status == STATUS_BAD_DEVICE_TYPE) return status;  /* no associated fd */
-        goto error;
-    }
+        return status;
 
     if ((status = CDROM_Open(fd, &dev)))
     {
         if (needs_close) close( fd );
-        goto error;
+        return status;
     }
 
 #ifdef __APPLE__
@@ -2847,16 +2842,13 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
          * Also for some reason it wants the fd to be closed before we even
          * open the parent if we're trying to eject the disk.
          */
-        if ((status = get_parent_device( fd, name, sizeof(name) ))) goto error;
+        if ((status = get_parent_device( fd, name, sizeof(name) ))) return status;
         if (code == IOCTL_STORAGE_EJECT_MEDIA)
             NtClose( device );
         if (needs_close) close( fd );
         TRACE("opening parent %s\n", name );
         if ((fd = open( name, O_RDONLY )) == -1)
-        {
-            status = errno_to_status( errno );
-            goto error;
-        }
+            return errno_to_status( errno );
         needs_close = 1;
     }
 #endif
@@ -3117,13 +3109,14 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
         break;
 
     default:
-        if (needs_close) close( fd );
-        return STATUS_NOT_SUPPORTED;
+        status = STATUS_NOT_SUPPORTED;
     }
     if (needs_close) close( fd );
- error:
-    io->Status = status;
-    io->Information = sz;
-    if (event) NtSetEvent(event, NULL);
+    if (!NT_ERROR(status))
+    {
+        io->Status = status;
+        io->Information = sz;
+        if (event) NtSetEvent(event, NULL);
+    }
     return status;
 }
-- 
GitLab


From 98b99b65690bbe7779ed01352f757c41dd9e8a34 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 24 Jun 2022 20:37:32 -0500
Subject: [PATCH 3/5] ntdll: Do not fill the IOSB or signal completion on
 failure in serial_DeviceIoControl().

We should never fill the IOSB or signal completion for NT_ERROR conditions.
---
 dlls/ntdll/unix/serial.c | 20 +++++++++++---------
 1 file changed, 11 insertions(+), 9 deletions(-)

diff --git a/dlls/ntdll/unix/serial.c b/dlls/ntdll/unix/serial.c
index ea9931d891a..a8abee6eeb6 100644
--- a/dlls/ntdll/unix/serial.c
+++ b/dlls/ntdll/unix/serial.c
@@ -1261,14 +1261,12 @@ NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE ap
         return STATUS_NOT_SUPPORTED;
     }
 
-    io->Information = 0;
-
-    if ((status = server_get_unix_fd( device, access, &fd, &needs_close, &type, NULL ))) goto error;
+    if ((status = server_get_unix_fd( device, access, &fd, &needs_close, &type, NULL )))
+        return status;
     if (type != FD_TYPE_SERIAL)
     {
         if (needs_close) close( fd );
-        status = STATUS_OBJECT_TYPE_MISMATCH;
-        goto error;
+        return STATUS_OBJECT_TYPE_MISMATCH;
     }
 
     switch (code)
@@ -1455,11 +1453,15 @@ NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE ap
         status = STATUS_INVALID_PARAMETER;
         break;
     }
+
     if (needs_close) close( fd );
- error:
-    io->Status = status;
-    io->Information = sz;
-    if (event) NtSetEvent(event, NULL);
+
+    if (!NT_ERROR(status))
+    {
+        io->Status = status;
+        io->Information = sz;
+        if (event) NtSetEvent(event, NULL);
+    }
     return status;
 }
 
-- 
GitLab


From 86be09ac0bc87f081a1e8abc7f43ed3e98ffb9c2 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Fri, 24 Jun 2022 20:38:02 -0500
Subject: [PATCH 4/5] ntdll: Do not fill the IOSB or signal completion on
 failure in tape_DeviceIoControl().

We should never fill the IOSB or signal completion for NT_ERROR conditions.
---
 dlls/ntdll/unix/tape.c | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/dlls/ntdll/unix/tape.c b/dlls/ntdll/unix/tape.c
index 48807dbca7a..f513e558898 100644
--- a/dlls/ntdll/unix/tape.c
+++ b/dlls/ntdll/unix/tape.c
@@ -528,9 +528,8 @@ NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc,
     TRACE( "%p %s %p %d %p %d %p\n", device, io2str(code),
            in_buffer, in_size, out_buffer, out_size, io );
 
-    io->Information = 0;
-
-    if ((status = server_get_unix_fd( device, 0, &fd, &needs_close, NULL, NULL ))) goto error;
+    if ((status = server_get_unix_fd( device, 0, &fd, &needs_close, NULL, NULL )))
+        return status;
 
     switch (code)
     {
@@ -580,9 +579,11 @@ NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc,
 
     if (needs_close) close( fd );
 
-error:
-    io->Status = status;
-    io->Information = sz;
-    if (event) NtSetEvent( event, NULL );
+    if (!NT_ERROR(status))
+    {
+        io->Status = status;
+        io->Information = sz;
+        if (event) NtSetEvent( event, NULL );
+    }
     return status;
 }
-- 
GitLab


From 1dee9881e2dfe6a31692aa96aa97dabc8c9de9e2 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2024 22:26:38 -0500
Subject: [PATCH 5/5] ntdll: Do not fill the IOSB in NtFsControlFile() on
 failure.

---
 dlls/ntdll/unix/file.c | 5 +----
 1 file changed, 1 insertion(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index e521dd44686..c128e8aa369 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -6247,7 +6245,6 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
         int fd, needs_close;
         struct stat st;
 
-        io->Information = 0;
         if (out_size >= sizeof(*info))
         {
             status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL );
@@ -6273,7 +6270,7 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
                                   in_buffer, in_size, out_buffer, out_size );
     }
 
-    if (status != STATUS_PENDING) io->Status = status;
+    if (!NT_ERROR(status) && status != STATUS_PENDING) io->Status = status;
     return status;
 }
 
-- 
GitLab

From 62df7633e5328ff94295ceabe5fa45e48f34ceb7 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2024 22:20:29 -0500
Subject: [PATCH 1/3] ntdll: Do not set io->Status at the end of sock_ioctl().

The only cases this affects are Wine-internal sockopt ioctls, and ws2_32 does not read back the IOSB status for those.
---
 dlls/ntdll/unix/socket.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/socket.c b/dlls/ntdll/unix/socket.c
index 587faf51ccf..78f24a081c3 100644
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -1485,6 +1485,10 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
     TRACE( "handle %p, code %#x, in_buffer %p, in_size %u, out_buffer %p, out_size %u\n",
            handle, code, in_buffer, in_size, out_buffer, out_size );
 
+    /* many of the below internal codes return success but don't completely
+     * fill the iosb or signal completion; such sockopts are only called
+     * synchronously by ws2_32 */
+
     switch (code)
     {
         case IOCTL_AFD_BIND:
@@ -2528,7 +2532,5 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
 
     if (needs_close) close( fd );
 
-    if (status != STATUS_PENDING && !NT_ERROR(status)) io->Status = status;
-
     return status;
 }
-- 
GitLab


From 5493ff11fa4f6bd9d3d6db74f6d2e4f723a28853 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 28 May 2024 19:39:23 -0500
Subject: [PATCH 2/3] ntdll: Factor filling the IOSB into
 set_async_direct_result().

---
 dlls/ntdll/unix/serial.c       |  6 ++----
 dlls/ntdll/unix/socket.c       | 26 +++-----------------------
 dlls/ntdll/unix/sync.c         |  9 ++++++++-
 dlls/ntdll/unix/unix_private.h |  3 ++-
 4 files changed, 15 insertions(+), 29 deletions(-)

diff --git a/dlls/ntdll/unix/serial.c b/dlls/ntdll/unix/serial.c
index cc3929c7a0b..8637dfbd447 100644
--- a/dlls/ntdll/unix/serial.c
+++ b/dlls/ntdll/unix/serial.c
@@ -1202,15 +1202,13 @@ static NTSTATUS wait_on( HANDLE handle, int fd, HANDLE event, PIO_APC_ROUTINE ap
         if (events)
         {
             status = STATUS_SUCCESS;
-            io->Status = STATUS_SUCCESS;
-            io->Information = sizeof(events);
             *out_buffer = events;
-            set_async_direct_result( &wait_handle, STATUS_SUCCESS, sizeof(events), FALSE );
+            set_async_direct_result( &wait_handle, io, STATUS_SUCCESS, sizeof(events), FALSE );
         }
         else
         {
             status = STATUS_PENDING;
-            set_async_direct_result( &wait_handle, STATUS_PENDING, 0, TRUE );
+            set_async_direct_result( &wait_handle, io, STATUS_PENDING, 0, TRUE );
         }
     }
 
diff --git a/dlls/ntdll/unix/socket.c b/dlls/ntdll/unix/socket.c
index 78f24a081c3..b10d51f3c60 100644
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -875,12 +875,7 @@ static NTSTATUS sock_recv( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, voi
         status = try_recv( fd, async, &information );
         if (status == STATUS_DEVICE_NOT_READY && (force_async || !nonblocking))
             status = STATUS_PENDING;
-        if (!NT_ERROR(status) && status != STATUS_PENDING)
-        {
-            io->Status = status;
-            io->Information = information;
-        }
-        set_async_direct_result( &wait_handle, status, information, FALSE );
+        set_async_direct_result( &wait_handle, io, status, information, FALSE );
     }
 
     if (status != STATUS_PENDING)
@@ -1125,8 +1120,6 @@ static NTSTATUS sock_send( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, voi
 
     if (status == STATUS_ALERTED)
     {
-        ULONG_PTR information;
-
         status = try_send( fd, async );
         if (status == STATUS_DEVICE_NOT_READY && (force_async || !nonblocking))
             status = STATUS_PENDING;
@@ -1138,14 +1131,7 @@ static NTSTATUS sock_send( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, voi
         if (status == STATUS_DEVICE_NOT_READY && async->sent_len)
             status = STATUS_SUCCESS;
 
-        information = async->sent_len;
-        if (!NT_ERROR(status) && status != STATUS_PENDING)
-        {
-            io->Status = status;
-            io->Information = information;
-        }
-
-        set_async_direct_result( &wait_handle, status, information, FALSE );
+        set_async_direct_result( &wait_handle, io, status, async->sent_len, FALSE );
     }
 
     if (status != STATUS_PENDING)
@@ -1401,13 +1387,7 @@ static NTSTATUS sock_transmit( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc,
             status = STATUS_PENDING;
 
         information = async->head_cursor + async->file_cursor + async->tail_cursor;
-        if (!NT_ERROR(status) && status != STATUS_PENDING)
-        {
-            io->Status = status;
-            io->Information = information;
-        }
-
-        set_async_direct_result( &wait_handle, status, information, TRUE );
+        set_async_direct_result( &wait_handle, io, status, information, TRUE );
     }
 
     if (status != STATUS_PENDING)
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 4b2d7c1ccbc..326e6e7734e 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -2669,13 +2669,20 @@ NTSTATUS WINAPI NtWaitForAlertByThreadId( const void *address, const LARGE_INTEG
 
 /* Notify direct completion of async and close the wait handle if it is no longer needed.
  */
-void set_async_direct_result( HANDLE *async_handle, NTSTATUS status, ULONG_PTR information, BOOL mark_pending )
+void set_async_direct_result( HANDLE *async_handle, IO_STATUS_BLOCK *io,
+                              NTSTATUS status, ULONG_PTR information, BOOL mark_pending )
 {
     unsigned int ret;
 
     /* if we got STATUS_ALERTED, we must have a valid async handle */
     assert( *async_handle );
 
+    if (!NT_ERROR(status) && status != STATUS_PENDING)
+    {
+        io->Status = status;
+        io->Information = information;
+    }
+
     SERVER_START_REQ( set_async_direct_result )
     {
         req->handle       = wine_server_obj_handle( *async_handle );
-- 
GitLab

From 7e3293107f11037bab6e96266b7f4016f4e5c427 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2024 22:03:34 -0500
Subject: [PATCH] ntdll: Move complete_async() to file.c and use it in
 NtWriteFileGather().

---
 dlls/ntdll/unix/file.c         | 27 ++++++++++++++++-----------
 dlls/ntdll/unix/socket.c       | 28 ++++++++--------------------
 dlls/ntdll/unix/unix_private.h |  3 ++-
 3 files changed, 26 insertions(+), 32 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index c128e8aa3695..c9a0b023d233 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -5470,7 +5470,7 @@ static unsigned int register_async_file_read( HANDLE handle, HANDLE event,
     return status;
 }
 
-void add_completion( HANDLE handle, ULONG_PTR value, NTSTATUS status, ULONG info, BOOL async )
+static void add_completion( HANDLE handle, ULONG_PTR value, NTSTATUS status, ULONG info, BOOL async )
 {
     SERVER_START_REQ( add_fd_completion )
     {
@@ -5484,6 +5484,20 @@ void add_completion( HANDLE handle, ULONG_PTR value, NTSTATUS status, ULONG info
     SERVER_END_REQ;
 }
 
+/* complete async file I/O, signaling completion in all ways necessary */
+void file_complete_async( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                          IO_STATUS_BLOCK *io, NTSTATUS status, ULONG_PTR information )
+{
+    ULONG_PTR iosb_ptr = iosb_client_ptr(io);
+
+    io->Status = status;
+    io->Information = information;
+    if (event) NtSetEvent( event, NULL );
+    if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc, (ULONG_PTR)apc_user, iosb_ptr, 0 );
+    else if (apc_user) add_completion( handle, (ULONG_PTR)apc_user, status, information, FALSE );
+}
+
+
 static unsigned int set_pending_write( HANDLE device )
 {
     unsigned int status;
@@ -6074,24 +6085,18 @@ NTSTATUS WINAPI NtWriteFileGather( HANDLE file, HANDLE event, PIO_APC_ROUTINE ap
         }
     }
 
-    send_completion = cvalue != 0;
-
  done:
     if (needs_close) close( unix_handle );
     if (status == STATUS_SUCCESS)
     {
-        io->Status = status;
-        io->Information = total;
+        file_complete_async( file, event, apc, apc_user, io, status, total );
         TRACE("= SUCCESS (%u)\n", total);
-        if (event) NtSetEvent( event, NULL );
-        if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc, (ULONG_PTR)apc_user, iosb_ptr, 0 );
     }
     else
     {
         TRACE("= 0x%08x\n", status);
         if (status != STATUS_PENDING && event) NtResetEvent( event, NULL );
     }
-    if (send_completion) add_completion( file, cvalue, status, total, FALSE );
     return status;
 }
 
diff --git a/dlls/ntdll/unix/socket.c b/dlls/ntdll/unix/socket.c
index 123e318058b1..587faf51ccfa 100644
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -1439,19 +1419,6 @@ static NTSTATUS sock_transmit( HANDLE ha
     return status;
 }
 
-static void complete_async( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                            IO_STATUS_BLOCK *io, NTSTATUS status, ULONG_PTR information )
-{
-    ULONG_PTR iosb_ptr = iosb_client_ptr(io);
-
-    io->Status = status;
-    io->Information = information;
-    if (event) NtSetEvent( event, NULL );
-    if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc, (ULONG_PTR)apc_user, iosb_ptr, 0 );
-    if (apc_user) add_completion( handle, (ULONG_PTR)apc_user, status, information, FALSE );
-}
-
-
 static NTSTATUS do_getsockopt( HANDLE handle, IO_STATUS_BLOCK *io, int level,
                                int option, void *out_buffer, ULONG out_size )
 {
@@ -1577,7 +1548,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HAND
             }
             SERVER_END_REQ;
 
-            complete_async( handle, event, apc, apc_user, io, status, 0 );
+            file_complete_async( handle, event, apc, apc_user, io, status, 0 );
             return status;
         }
 
@@ -1724,7 +1695,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HAND
                 return STATUS_BUFFER_TOO_SMALL;
 
             status = *(NTSTATUS *)in_buffer;
-            complete_async( handle, event, apc, apc_user, io, status, 0 );
+            file_complete_async( handle, event, apc, apc_user, io, status, 0 );
             return status;
         }
 
@@ -1750,7 +1721,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HAND
                 {
                     *(int *)out_buffer = 0;
                     if (needs_close) close( fd );
-                    complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
+                    file_complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
                     return STATUS_SUCCESS;
                 }
             }
@@ -1763,7 +1734,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HAND
             }
             *(int *)out_buffer = value;
             if (needs_close) close( fd );
-            complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
+            file_complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
             return STATUS_SUCCESS;
         }
 
@@ -1802,7 +1773,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HAND
                 *(int *)out_buffer = !value;
             }
             if (needs_close) close( fd );
-            complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
+            file_complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
             return STATUS_SUCCESS;
         }
 
@@ -1829,7 +1800,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HAND
             if (out_size < ret_size)
             {
                 freeifaddrs( ifaddrs );
-                complete_async( handle, event, apc, apc_user, io, STATUS_BUFFER_TOO_SMALL, 0 );
+                file_complete_async( handle, event, apc, apc_user, io, STATUS_BUFFER_TOO_SMALL, 0 );
                 return STATUS_PENDING;
             }
 
@@ -1879,7 +1850,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HAND
             }
 
             freeifaddrs( ifaddrs );
-            complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, ret_size );
+            file_complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, ret_size );
             return STATUS_PENDING;
 #else
             FIXME( "Interface list queries are currently not supported on this platform.\n" );
@@ -1934,7 +1905,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HAND
             }
 
             if (needs_close) close( fd );
-            complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
+            file_complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
             return STATUS_SUCCESS;
         }
 

From d140164d7689c4c51964a3de8c4332d8a8332a70 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Mon, 27 May 2024 22:33:41 -0500
Subject: [PATCH] ntdll: Use file_complete_async() in tape_DeviceIoControl().

Thereby also handling completion and APCs.
---
 dlls/ntdll/unix/tape.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/tape.c b/dlls/ntdll/unix/tape.c
index f513e5588985..366096bbf4fb 100644
--- a/dlls/ntdll/unix/tape.c
+++ b/dlls/ntdll/unix/tape.c
@@ -580,10 +580,6 @@ NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc,
     if (needs_close) close( fd );
 
     if (!NT_ERROR(status))
-    {
-        io->Status = status;
-        io->Information = sz;
-        if (event) NtSetEvent( event, NULL );
-    }
+        file_complete_async( device, event, apc, apc_user, io, status, sz );
     return status;
 }

From c133f14fe6d6eeaeb2f1b0c770c32b7bb24aa6ff Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 28 May 2024 18:22:03 -0500
Subject: [PATCH] ntdll: Use file_complete_async() in cdrom_DeviceIoControl().

Thereby also handling completion and APCs.
---
 dlls/ntdll/unix/cdrom.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/cdrom.c b/dlls/ntdll/unix/cdrom.c
index 427e559968f6..c92ccc1185d6 100644
--- a/dlls/ntdll/unix/cdrom.c
+++ b/dlls/ntdll/unix/cdrom.c
@@ -3113,10 +3113,6 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
     }
     if (needs_close) close( fd );
     if (!NT_ERROR(status))
-    {
-        io->Status = status;
-        io->Information = sz;
-        if (event) NtSetEvent(event, NULL);
-    }
+        file_complete_async( device, event, apc, apc_user, io, status, sz );
     return status;
 }

From 0a42bd290de25d6ff4eb9bf895b74a9003833fa4 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Tue, 28 May 2024 18:50:44 -0500
Subject: [PATCH] ntdll: Use file_complete_async() in serial_DeviceIoControl().

Thereby also handling completion and APCs.
---
 dlls/ntdll/unix/serial.c | 6 +-----
 1 file changed, 1 insertion(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/serial.c b/dlls/ntdll/unix/serial.c
index a8abee6eeb63..cc3929c7a0b0 100644
--- a/dlls/ntdll/unix/serial.c
+++ b/dlls/ntdll/unix/serial.c
@@ -1457,11 +1457,7 @@ NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE ap
     if (needs_close) close( fd );
 
     if (!NT_ERROR(status))
-    {
-        io->Status = status;
-        io->Information = sz;
-        if (event) NtSetEvent(event, NULL);
-    }
+        file_complete_async( device, event, apc, apc_user, io, status, sz );
     return status;
 }
 

From 0db0f6180d3837212b59b53a90757a389df2d611 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2024 22:30:16 -0500
Subject: [PATCH] ntdll: Use file_complete_async() in NtFsControlFile().

---
 dlls/ntdll/unix/file.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index c9a0b023d233..b8fb4f19e136 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -6182,6 +6182,7 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
                                  IO_STATUS_BLOCK *io, ULONG code, void *in_buffer, ULONG in_size,
                                  void *out_buffer, ULONG out_size )
 {
+    ULONG_PTR size = 0;
     NTSTATUS status;
 
     TRACE( "(%p,%p,%p,%p,%p,0x%08x,%p,0x%08x,%p,0x%08x)\n",
@@ -6225,7 +6226,7 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
             buffer->StartingVcn.QuadPart        = 1;
             buffer->Extents[0].NextVcn.QuadPart = 0;
             buffer->Extents[0].Lcn.QuadPart     = 0;
-            io->Information = sizeof(RETRIEVAL_POINTERS_BUFFER);
+            size = sizeof(RETRIEVAL_POINTERS_BUFFER);
             status = STATUS_SUCCESS;
         }
         else
@@ -6259,7 +6260,7 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
             memset( info, 0, sizeof(*info) );
             memcpy( info->ObjectId, &st.st_dev, sizeof(st.st_dev) );
             memcpy( info->ObjectId + 8, &st.st_ino, sizeof(st.st_ino) );
-            io->Information = sizeof(*info);
+            size = sizeof(*info);
         }
         else status = STATUS_BUFFER_TOO_SMALL;
         break;
@@ -6267,7 +6268,6 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
 
     case FSCTL_SET_SPARSE:
         TRACE("FSCTL_SET_SPARSE: Ignoring request\n");
-        io->Information = 0;
         status = STATUS_SUCCESS;
         break;
     default:
@@ -6275,7 +6275,8 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
                                   in_buffer, in_size, out_buffer, out_size );
     }
 
-    if (!NT_ERROR(status) && status != STATUS_PENDING) io->Status = status;
+    if (!NT_ERROR(status) && status != STATUS_PENDING)
+        file_complete_async( handle, event, apc, apc_context, io, status, size );
     return status;
 }
 


From 0c4743e9c151731b6461619f82f8533624324608 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2024 23:14:48 -0500
Subject: [PATCH 3/3] ntdll: Move set_async_direct_result() to file.c.

Similar helpers are in file.c, and sync.c has nothing to do with file I/O otherwise.
---
 dlls/ntdll/unix/file.c | 31 +++++++++++++++++++++++++++++++
 dlls/ntdll/unix/sync.c | 34 ----------------------------------
 2 files changed, 31 insertions(+), 34 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index b8fb4f19e13..2ce38b34158 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -5484,6 +5484,37 @@ static void add_completion( HANDLE handle, ULONG_PTR value, NTSTATUS status, ULO
     SERVER_END_REQ;
 }
 
+/* notify direct completion of async and close the wait handle if it is no longer needed */
+void set_async_direct_result( HANDLE *async_handle, IO_STATUS_BLOCK *io,
+                              NTSTATUS status, ULONG_PTR information, BOOL mark_pending )
+{
+    unsigned int ret;
+
+    /* if we got STATUS_ALERTED, we must have a valid async handle */
+    assert( *async_handle );
+
+    if (!NT_ERROR(status) && status != STATUS_PENDING)
+    {
+        io->Status = status;
+        io->Information = information;
+    }
+
+    SERVER_START_REQ( set_async_direct_result )
+    {
+        req->handle       = wine_server_obj_handle( *async_handle );
+        req->status       = status;
+        req->information  = information;
+        req->mark_pending = mark_pending;
+        ret = wine_server_call( req );
+        if (ret == STATUS_SUCCESS)
+            *async_handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+
+    if (ret != STATUS_SUCCESS)
+        ERR( "cannot report I/O result back to server: %#x\n", ret );
+}
+
 /* complete async file I/O, signaling completion in all ways necessary */
 void file_complete_async( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
                           IO_STATUS_BLOCK *io, NTSTATUS status, ULONG_PTR information )
-- 
GitLab

--- a/dlls/ntdll/unix/sync.c	2024-07-04 21:03:06.929695664 -0500
+++ b/dlls/ntdll/unix/sync.c	2024-07-04 21:02:52.126620154 -0500
@@ -3103,41 +3103,6 @@ NTSTATUS WINAPI NtWaitForAlertByThreadId
 
 #endif
 
-/* Notify direct completion of async and close the wait handle if it is no longer needed.
- * This function is a no-op (returns status as-is) if the supplied handle is NULL.
- */
-void set_async_direct_result( HANDLE *async_handle, IO_STATUS_BLOCK *io,
-                              NTSTATUS status, ULONG_PTR information, BOOL mark_pending )
-{
-    unsigned int ret;
-
-    /* if we got STATUS_ALERTED, we must have a valid async handle */
-    assert( *async_handle );
-
-    if (!NT_ERROR(status) && status != STATUS_PENDING)
-    {
-        io->Status = status;
-        io->Information = information;
-    }
-
-    SERVER_START_REQ( set_async_direct_result )
-    {
-        req->handle       = wine_server_obj_handle( *async_handle );
-        req->status       = status;
-        req->information  = information;
-        req->mark_pending = mark_pending;
-        ret = wine_server_call( req );
-        if (ret == STATUS_SUCCESS)
-            *async_handle = wine_server_ptr_handle( reply->handle );
-    }
-    SERVER_END_REQ;
-
-    if (ret != STATUS_SUCCESS)
-        ERR( "cannot report I/O result back to server: %08x\n", ret );
-
-    return;
-}
-
 /***********************************************************************
  *           NtCreateTransaction (NTDLL.@)
  */

From d215435c78d136575cdddc599306e8d221552f73 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sat, 25 Jun 2022 15:45:55 -0500
Subject: [PATCH 1/6] ntdll: Introduce a sync_ioctl() helper.

---
 dlls/ntdll/unix/file.c         | 37 +++++++++++++++++-----------------
 dlls/ntdll/unix/process.c      |  4 +---
 dlls/ntdll/unix/unix_private.h |  2 ++
 3 files changed, 22 insertions(+), 21 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 2ce38b34158..87afc20c48d 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -2268,7 +2268,6 @@ static NTSTATUS get_mountmgr_fs_info( HANDLE handle, int fd, struct mountmgr_uni
     OBJECT_ATTRIBUTES attr;
     UNICODE_STRING string;
     char *unix_name;
-    IO_STATUS_BLOCK io = {{0}};
     HANDLE mountmgr;
     unsigned int status;
     int letter;
@@ -2294,8 +2293,7 @@ static NTSTATUS get_mountmgr_fs_info( HANDLE handle, int fd, struct mountmgr_uni
                                       FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_SYNCHRONOUS_IO_NONALERT );
     if (status) return status;
 
-    status = NtDeviceIoControlFile( mountmgr, NULL, NULL, NULL, &io, IOCTL_MOUNTMGR_QUERY_UNIX_DRIVE,
-                                    drive, sizeof(*drive), drive, size );
+    status = sync_ioctl( mountmgr, IOCTL_MOUNTMGR_QUERY_UNIX_DRIVE, drive, sizeof(*drive), drive, size );
     NtClose( mountmgr );
     if (status == STATUS_BUFFER_OVERFLOW) status = STATUS_SUCCESS;
     else if (status) WARN("failed to retrieve filesystem type from mountmgr, status %#x\n", status);
@@ -5321,8 +5319,6 @@ struct io_timeouts
 static unsigned int get_io_timeouts( HANDLE handle, enum server_fd_type type, ULONG count, BOOL is_read,
                                      struct io_timeouts *timeouts )
 {
-    unsigned int status = STATUS_SUCCESS;
-
     timeouts->interval = timeouts->total = -1;
 
     switch(type)
@@ -5331,11 +5327,9 @@ static unsigned int get_io_timeouts( HANDLE handle, enum server_fd_type type, UL
     {
         /* GetCommTimeouts */
         SERIAL_TIMEOUTS st;
-        IO_STATUS_BLOCK io = {{0}};
 
-        status = NtDeviceIoControlFile( handle, NULL, NULL, NULL, &io,
-                                        IOCTL_SERIAL_GET_TIMEOUTS, NULL, 0, &st, sizeof(st) );
-        if (status) break;
+        if (sync_ioctl( handle, IOCTL_SERIAL_GET_TIMEOUTS, NULL, 0, &st, sizeof(st) ))
+            break;
 
         if (is_read)
         {
@@ -5418,14 +5411,13 @@ static NTSTATUS get_io_avail_mode( HANDLE handle, enum server_fd_type type, BOOL
     {
         /* GetCommTimeouts */
         SERIAL_TIMEOUTS st;
-        IO_STATUS_BLOCK io = {{0}};
 
-        status = NtDeviceIoControlFile( handle, NULL, NULL, NULL, &io,
-                                        IOCTL_SERIAL_GET_TIMEOUTS, NULL, 0, &st, sizeof(st) );
-        if (status) break;
-        *avail_mode = (!st.ReadTotalTimeoutMultiplier &&
-                       !st.ReadTotalTimeoutConstant &&
-                       st.ReadIntervalTimeout == MAXDWORD);
+        if (!(status = sync_ioctl( handle, IOCTL_SERIAL_GET_TIMEOUTS, NULL, 0, &st, sizeof(st) )))
+        {
+            *avail_mode = (!st.ReadTotalTimeoutMultiplier &&
+                           !st.ReadTotalTimeoutConstant &&
+                           st.ReadIntervalTimeout == MAXDWORD);
+        }
         break;
     }
     case FD_TYPE_MAILSLOT:
@@ -6182,6 +6174,15 @@ NTSTATUS WINAPI NtDeviceIoControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUT
 }
 
 
+/* helper for internal ioctl calls */
+NTSTATUS sync_ioctl( HANDLE file, ULONG code, void *in_buffer, ULONG in_size, void *out_buffer, ULONG out_size )
+{
+    IO_STATUS_BLOCK io;
+
+    return NtDeviceIoControlFile( file, NULL, NULL, NULL, &io, code, in_buffer, in_size, out_buffer, out_size );
+}
+
+
 /* Tell Valgrind to ignore any holes in structs we will be passing to the
  * server */
 static void ignore_server_ioctl_struct_holes( ULONG code, const void *in_buffer, ULONG in_size )
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index cc2d820e723..1815b46b0fc 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -413,9 +413,7 @@ static void set_stdio_fd( int stdin_fd, int stdout_fd )
  */
 static BOOL is_unix_console_handle( HANDLE handle )
 {
-    IO_STATUS_BLOCK io = {{0}};
-    return !NtDeviceIoControlFile( handle, NULL, NULL, NULL, &io, IOCTL_CONDRV_IS_UNIX,
-                                   NULL, 0, NULL, 0 );
+    return !sync_ioctl( handle, IOCTL_CONDRV_IS_UNIX, NULL, 0, NULL, 0 );
 }
 
 
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index c00b0e4b602..232f97490a1 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -312,6 +312,8 @@ extern NTSTATUS set_thread_wow64_context( HANDLE handle, const void *ctx, ULONG
 extern void fill_vm_counters( VM_COUNTERS_EX *pvmi, int unix_pid );
 extern NTSTATUS open_hkcu_key( const char *path, HANDLE *key );
 
+extern NTSTATUS sync_ioctl( HANDLE file, ULONG code, void *in_buffer, ULONG in_size,
+                            void *out_buffer, ULONG out_size );
 extern NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
                                        IO_STATUS_BLOCK *io, UINT code, void *in_buffer,
                                        UINT in_size, void *out_buffer, UINT out_size );
-- 
GitLab


From fee260cef756657c1019db67ab21380f36033074 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Sat, 25 Jun 2022 15:49:31 -0500
Subject: [PATCH 2/6] ntdll: Handle WoW64 file handles in sync_ioctl().

---
 dlls/ntdll/unix/file.c         |  3 +++
 dlls/ntdll/unix/unix_private.h | 16 +++++++++++-----
 2 files changed, 14 insertions(+), 5 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 87afc20c48d..8415478c046 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -6177,8 +6177,11 @@ NTSTATUS WINAPI NtDeviceIoControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUT
 /* helper for internal ioctl calls */
 NTSTATUS sync_ioctl( HANDLE file, ULONG code, void *in_buffer, ULONG in_size, void *out_buffer, ULONG out_size )
 {
+    IO_STATUS_BLOCK32 io32;
     IO_STATUS_BLOCK io;
 
+    /* the 32-bit iosb is filled for overlapped file handles */
+    io.Pointer = &io32;
     return NtDeviceIoControlFile( file, NULL, NULL, NULL, &io, code, in_buffer, in_size, out_buffer, out_size );
 }
 
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 232f97490a1..2e0477e42e0 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -31,6 +31,16 @@
 
 struct msghdr;
 
+typedef struct
+{
+    union
+    {
+        NTSTATUS Status;
+        ULONG Pointer;
+    };
+    ULONG Information;
+} IO_STATUS_BLOCK32;
+
 #ifdef __i386__
 static const WORD current_machine = IMAGE_FILE_MACHINE_I386;
 #elif defined(__x86_64__)
@@ -462,11 +472,7 @@ static inline void set_async_iosb( client_ptr_t iosb, NTSTATUS status, ULONG_PTR
 
     if (in_wow64_call())
     {
-        struct iosb32
-        {
-            NTSTATUS Status;
-            ULONG    Information;
-        } *io = wine_server_get_ptr( iosb );
+        IO_STATUS_BLOCK32 *io = wine_server_get_ptr( iosb );
         io->Information = info;
         WriteRelease( &io->Status, status );
     }
-- 
GitLab


From e51aa91b751eb04905383d6e580947d6ddf489c9 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2024 23:22:25 -0500
Subject: [PATCH 3/6] ntdll: Always fill the 32-bit iosb for overlapped
 handles, for server I/O.

---
 dlls/ntdll/tests/wow64.c | 22 +++++++++-------------
 dlls/ntdll/unix/file.c   | 31 +++++++++++++++++++------------
 2 files changed, 28 insertions(+), 25 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 8415478c046..4f0fe685d88 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -5186,6 +5186,22 @@ static BOOL async_write_proc( void *user, ULONG_PTR *info, unsigned int *status
     return TRUE;
 }
 
+static void set_sync_iosb( IO_STATUS_BLOCK *io, NTSTATUS status, ULONG_PTR info, unsigned int options )
+{
+    if (in_wow64_call() && !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)))
+    {
+        IO_STATUS_BLOCK32 *io32 = io->Pointer;
+
+        io32->Status = status;
+        io32->Information = info;
+    }
+    else
+    {
+        io->Status = status;
+        io->Information = info;
+    }
+}
+
 /* do a read call through the server */
 static unsigned int server_read_file( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_context,
                                       IO_STATUS_BLOCK *io, void *buffer, ULONG size,
@@ -5211,10 +5227,7 @@ static unsigned int server_read_file( HANDLE handle, HANDLE event, PIO_APC_ROUTI
         wait_handle = wine_server_ptr_handle( reply->wait );
         options     = reply->options;
         if (wait_handle && status != STATUS_PENDING)
-        {
-            io->Status      = status;
-            io->Information = wine_server_reply_size( reply );
-        }
+            set_sync_iosb( io, status, wine_server_reply_size( reply ), options );
     }
     SERVER_END_REQ;
 
@@ -5249,10 +5262,7 @@ static unsigned int server_write_file( HANDLE handle, HANDLE event, PIO_APC_ROUT
         wait_handle = wine_server_ptr_handle( reply->wait );
         options     = reply->options;
         if (wait_handle && status != STATUS_PENDING)
-        {
-            io->Status      = status;
-            io->Information = reply->size;
-        }
+            set_sync_iosb( io, status, reply->size, options );
     }
     SERVER_END_REQ;
 
@@ -5290,10 +5300,7 @@ static NTSTATUS server_ioctl_file( HANDLE handle, HANDLE event,
         wait_handle = wine_server_ptr_handle( reply->wait );
         options     = reply->options;
         if (wait_handle && status != STATUS_PENDING)
-        {
-            io->Status      = status;
-            io->Information = wine_server_reply_size( reply );
-        }
+            set_sync_iosb( io, status, wine_server_reply_size( reply ), options );
     }
     SERVER_END_REQ;
 
-- 
GitLab


From 193fc028d202b5b3c4331675cd355f9d9ec481dd Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2024 23:24:02 -0500
Subject: [PATCH 4/6] ntdll: Always fill the 32-bit iosb for overlapped
 handles, in file_complete_async().

---
 dlls/ntdll/unix/cdrom.c        |  5 +++--
 dlls/ntdll/unix/file.c         | 16 +++++++++++-----
 dlls/ntdll/unix/serial.c       |  5 +++--
 dlls/ntdll/unix/socket.c       | 35 +++++++++++++++++++++++-----------
 dlls/ntdll/unix/tape.c         |  5 +++--
 dlls/ntdll/unix/unix_private.h |  2 +-
 6 files changed, 45 insertions(+), 23 deletions(-)

diff --git a/dlls/ntdll/unix/cdrom.c b/dlls/ntdll/unix/cdrom.c
index c92ccc1185d..9e651414e9a 100644
--- a/dlls/ntdll/unix/cdrom.c
+++ b/dlls/ntdll/unix/cdrom.c
@@ -2819,10 +2819,11 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
     DWORD       sz = 0;
     NTSTATUS    status = STATUS_SUCCESS;
     int fd, needs_close, dev = 0;
+    unsigned int options;
 
     TRACE( "%p %s %p %d %p %d %p\n", device, iocodex(code), in_buffer, in_size, out_buffer, out_size, io );
 
-    if ((status = server_get_unix_fd( device, 0, &fd, &needs_close, NULL, NULL )))
+    if ((status = server_get_unix_fd( device, 0, &fd, &needs_close, NULL, &options )))
         return status;
 
     if ((status = CDROM_Open(fd, &dev)))
@@ -3113,6 +3114,6 @@ NTSTATUS cdrom_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc
     }
     if (needs_close) close( fd );
     if (!NT_ERROR(status))
-        file_complete_async( device, event, apc, apc_user, io, status, sz );
+        file_complete_async( device, options, event, apc, apc_user, io, status, sz );
     return status;
 }
diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 4f0fe685d88..2ab04040258 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -5515,13 +5515,12 @@ void set_async_direct_result( HANDLE *async_handle, IO_STATUS_BLOCK *io,
 }
 
 /* complete async file I/O, signaling completion in all ways necessary */
-void file_complete_async( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+void file_complete_async( HANDLE handle, unsigned int options, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
                           IO_STATUS_BLOCK *io, NTSTATUS status, ULONG_PTR information )
 {
     ULONG_PTR iosb_ptr = iosb_client_ptr(io);
 
-    io->Status = status;
-    io->Information = information;
+    set_sync_iosb( io, status, information, options );
     if (event) NtSetEvent( event, NULL );
     if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc, (ULONG_PTR)apc_user, iosb_ptr, 0 );
     else if (apc_user) add_completion( handle, (ULONG_PTR)apc_user, status, information, FALSE );
@@ -6119,7 +6118,7 @@ NTSTATUS WINAPI NtWriteFileGather( HANDLE file, HANDLE event, PIO_APC_ROUTINE ap
     if (needs_close) close( unix_handle );
     if (status == STATUS_SUCCESS)
     {
-        file_complete_async( file, event, apc, apc_user, io, status, total );
+        file_complete_async( file, options, event, apc, apc_user, io, status, total );
         TRACE("= SUCCESS (%u)\n", total);
     }
     else
@@ -6224,6 +6223,8 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
                                  IO_STATUS_BLOCK *io, ULONG code, void *in_buffer, ULONG in_size,
                                  void *out_buffer, ULONG out_size )
 {
+    unsigned int options;
+    int fd, needs_close;
     ULONG_PTR size = 0;
     NTSTATUS status;
 
@@ -6233,6 +6234,11 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
 
     if (!io) return STATUS_INVALID_PARAMETER;
 
+    status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, &options );
+    if (status && status != STATUS_BAD_DEVICE_TYPE)
+        return status;
+    if (needs_close) close( fd );
+
     ignore_server_ioctl_struct_holes( code, in_buffer, in_size );
 
     switch (code)
@@ -6318,7 +6324,7 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
     }
 
     if (!NT_ERROR(status) && status != STATUS_PENDING)
-        file_complete_async( handle, event, apc, apc_context, io, status, size );
+        file_complete_async( handle, options, event, apc, apc_context, io, status, size );
     return status;
 }
 
diff --git a/dlls/ntdll/unix/serial.c b/dlls/ntdll/unix/serial.c
index 8637dfbd447..89b12980df7 100644
--- a/dlls/ntdll/unix/serial.c
+++ b/dlls/ntdll/unix/serial.c
@@ -1245,6 +1245,7 @@ NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE ap
     NTSTATUS status = STATUS_SUCCESS;
     int fd = -1, needs_close = 0;
     enum server_fd_type type;
+    unsigned int options;
 
     TRACE("%p %s %p %d %p %d %p\n",
           device, iocode2str(code), in_buffer, in_size, out_buffer, out_size, io);
@@ -1259,7 +1260,7 @@ NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE ap
         return STATUS_NOT_SUPPORTED;
     }
 
-    if ((status = server_get_unix_fd( device, access, &fd, &needs_close, &type, NULL )))
+    if ((status = server_get_unix_fd( device, access, &fd, &needs_close, &type, &options )))
         return status;
     if (type != FD_TYPE_SERIAL)
     {
@@ -1455,7 +1456,7 @@ NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE ap
     if (needs_close) close( fd );
 
     if (!NT_ERROR(status))
-        file_complete_async( device, event, apc, apc_user, io, status, sz );
+        file_complete_async( device, options, event, apc, apc_user, io, status, sz );
     return status;
 }
 
diff --git a/dlls/ntdll/unix/socket.c b/dlls/ntdll/unix/socket.c
index b10d51f3c60..269197e41f2 100644
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -1460,6 +1460,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
                      UINT code, void *in_buffer, UINT in_size, void *out_buffer, UINT out_size )
 {
     int fd, needs_close = FALSE;
+    unsigned int options;
     NTSTATUS status;
 
     TRACE( "handle %p, code %#x, in_buffer %p, in_size %u, out_buffer %p, out_size %u\n",
@@ -1525,6 +1526,10 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
                 break;
             }
 
+            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, &options )))
+                return status;
+            if (needs_close) close( fd );
+
             SERVER_START_REQ( socket_get_events )
             {
                 req->handle = wine_server_obj_handle( handle );
@@ -1535,7 +1540,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
             }
             SERVER_END_REQ;
 
-            file_complete_async( handle, event, apc, apc_user, io, status, 0 );
+            file_complete_async( handle, options, event, apc, apc_user, io, status, 0 );
             return status;
         }
 
@@ -1681,8 +1686,12 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
             if (in_size != sizeof(NTSTATUS))
                 return STATUS_BUFFER_TOO_SMALL;
 
+            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, &options )))
+                return status;
+            if (needs_close) close( fd );
+
             status = *(NTSTATUS *)in_buffer;
-            file_complete_async( handle, event, apc, apc_user, io, status, 0 );
+            file_complete_async( handle, options, event, apc, apc_user, io, status, 0 );
             return status;
         }
 
@@ -1696,7 +1705,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
                 break;
             }
 
-            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
+            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, &options )))
                 return status;
 
 #ifdef linux
@@ -1708,7 +1717,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
                 {
                     *(int *)out_buffer = 0;
                     if (needs_close) close( fd );
-                    file_complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
+                    file_complete_async( handle, options, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
                     return STATUS_SUCCESS;
                 }
             }
@@ -1721,7 +1730,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
             }
             *(int *)out_buffer = value;
             if (needs_close) close( fd );
-            file_complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
+            file_complete_async( handle, options, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
             return STATUS_SUCCESS;
         }
 
@@ -1730,7 +1739,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
             int value, ret;
             socklen_t len = sizeof(value);
 
-            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
+            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, &options )))
                 return status;
 
             if (out_size < sizeof(int))
@@ -1760,7 +1769,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
                 *(int *)out_buffer = !value;
             }
             if (needs_close) close( fd );
-            file_complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
+            file_complete_async( handle, options, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
             return STATUS_SUCCESS;
         }
 
@@ -1772,6 +1781,10 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
             unsigned int count = 0;
             ULONG ret_size;
 
+            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, &options )))
+                return status;
+            if (needs_close) close( fd );
+
             if (getifaddrs( &ifaddrs ) < 0)
             {
                 status = sock_errno_to_status( errno );
@@ -1787,7 +1800,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
             if (out_size < ret_size)
             {
                 freeifaddrs( ifaddrs );
-                file_complete_async( handle, event, apc, apc_user, io, STATUS_BUFFER_TOO_SMALL, 0 );
+                file_complete_async( handle, options, event, apc, apc_user, io, STATUS_BUFFER_TOO_SMALL, 0 );
                 return STATUS_PENDING;
             }
 
@@ -1837,7 +1850,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
             }
 
             freeifaddrs( ifaddrs );
-            file_complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, ret_size );
+            file_complete_async( handle, options, event, apc, apc_user, io, STATUS_SUCCESS, ret_size );
             return STATUS_PENDING;
 #else
             FIXME( "Interface list queries are currently not supported on this platform.\n" );
@@ -1855,7 +1868,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
                 return STATUS_BUFFER_TOO_SMALL;
             keepalive = !!k->onoff;
 
-            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
+            if ((status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, &options )))
                 return status;
 
             if (setsockopt( fd, SOL_SOCKET, SO_KEEPALIVE, &keepalive, sizeof(int) ) < 0)
@@ -1892,7 +1905,7 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
             }
 
             if (needs_close) close( fd );
-            file_complete_async( handle, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
+            file_complete_async( handle, options, event, apc, apc_user, io, STATUS_SUCCESS, 0 );
             return STATUS_SUCCESS;
         }
 
diff --git a/dlls/ntdll/unix/tape.c b/dlls/ntdll/unix/tape.c
index 366096bbf4f..366e12c35a0 100644
--- a/dlls/ntdll/unix/tape.c
+++ b/dlls/ntdll/unix/tape.c
@@ -523,12 +523,13 @@ NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc,
 {
     DWORD sz = 0;
     NTSTATUS status = STATUS_INVALID_PARAMETER;
+    unsigned int options;
     int fd, needs_close;
 
     TRACE( "%p %s %p %d %p %d %p\n", device, io2str(code),
            in_buffer, in_size, out_buffer, out_size, io );
 
-    if ((status = server_get_unix_fd( device, 0, &fd, &needs_close, NULL, NULL )))
+    if ((status = server_get_unix_fd( device, 0, &fd, &needs_close, NULL, &options )))
         return status;
 
     switch (code)
@@ -580,6 +581,6 @@ NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc,
     if (needs_close) close( fd );
 
     if (!NT_ERROR(status))
-        file_complete_async( device, event, apc, apc_user, io, status, sz );
+        file_complete_async( device, options, event, apc, apc_user, io, status, sz );
     return status;
 }
-- 
GitLab


From 5125f9d5affb7d838e479b6e11f6344d54943a8c Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2024 23:24:27 -0500
Subject: [PATCH 5/6] ntdll: Always fill the 32-bit iosb for overlapped
 handles, in set_async_direct_result().

---
 dlls/ntdll/unix/file.c         | 7 ++-----
 dlls/ntdll/unix/serial.c       | 4 ++--
 dlls/ntdll/unix/socket.c       | 6 +++---
 dlls/ntdll/unix/unix_private.h | 2 +-
 4 files changed, 8 insertions(+), 11 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 2ab04040258..cb3fa75597f 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -5484,7 +5484,7 @@ static void add_completion( HANDLE handle, ULONG_PTR value, NTSTATUS status, ULO
 }
 
 /* notify direct completion of async and close the wait handle if it is no longer needed */
-void set_async_direct_result( HANDLE *async_handle, IO_STATUS_BLOCK *io,
+void set_async_direct_result( HANDLE *async_handle, unsigned int options, IO_STATUS_BLOCK *io,
                               NTSTATUS status, ULONG_PTR information, BOOL mark_pending )
 {
     unsigned int ret;
@@ -5493,10 +5493,7 @@ void set_async_direct_result( HANDLE *async_handle, IO_STATUS_BLOCK *io,
     assert( *async_handle );
 
     if (!NT_ERROR(status) && status != STATUS_PENDING)
-    {
-        io->Status = status;
-        io->Information = information;
-    }
+        set_sync_iosb( io, status, information, options );
 
     SERVER_START_REQ( set_async_direct_result )
     {
diff --git a/dlls/ntdll/unix/serial.c b/dlls/ntdll/unix/serial.c
index 89b12980df7..c47adaf2054 100644
--- a/dlls/ntdll/unix/serial.c
+++ b/dlls/ntdll/unix/serial.c
@@ -1203,12 +1203,12 @@ static NTSTATUS wait_on( HANDLE handle, int fd, HANDLE event, PIO_APC_ROUTINE ap
         {
             status = STATUS_SUCCESS;
             *out_buffer = events;
-            set_async_direct_result( &wait_handle, io, STATUS_SUCCESS, sizeof(events), FALSE );
+            set_async_direct_result( &wait_handle, options, io, STATUS_SUCCESS, sizeof(events), FALSE );
         }
         else
         {
             status = STATUS_PENDING;
-            set_async_direct_result( &wait_handle, io, STATUS_PENDING, 0, TRUE );
+            set_async_direct_result( &wait_handle, options, io, STATUS_PENDING, 0, TRUE );
         }
     }
 
diff --git a/dlls/ntdll/unix/socket.c b/dlls/ntdll/unix/socket.c
index 269197e41f2..a2b7b9fd051 100644
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -875,7 +875,7 @@ static NTSTATUS sock_recv( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, voi
         status = try_recv( fd, async, &information );
         if (status == STATUS_DEVICE_NOT_READY && (force_async || !nonblocking))
             status = STATUS_PENDING;
-        set_async_direct_result( &wait_handle, io, status, information, FALSE );
+        set_async_direct_result( &wait_handle, options, io, status, information, FALSE );
     }
 
     if (status != STATUS_PENDING)
@@ -1131,7 +1131,7 @@ static NTSTATUS sock_send( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, voi
         if (status == STATUS_DEVICE_NOT_READY && async->sent_len)
             status = STATUS_SUCCESS;
 
-        set_async_direct_result( &wait_handle, io, status, async->sent_len, FALSE );
+        set_async_direct_result( &wait_handle, options, io, status, async->sent_len, FALSE );
     }
 
     if (status != STATUS_PENDING)
@@ -1387,7 +1387,7 @@ static NTSTATUS sock_transmit( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc,
             status = STATUS_PENDING;
 
         information = async->head_cursor + async->file_cursor + async->tail_cursor;
-        set_async_direct_result( &wait_handle, io, status, information, TRUE );
+        set_async_direct_result( &wait_handle, options, io, status, information, TRUE );
     }
 
     if (status != STATUS_PENDING)
-- 
GitLab


From be0d882e89cc3403ff0c1db4188ec2861de36298 Mon Sep 17 00:00:00 2001
From: Elizabeth Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2024 23:24:42 -0500
Subject: [PATCH 6/6] ntdll: Always fill the 32-bit iosb for overlapped
 handles, for regular read/write.

---
 dlls/ntdll/unix/file.c | 9 +++------
 1 file changed, 3 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index cb3fa75597f..15fdf2cb021 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -5721,8 +5721,7 @@ err:
     if (needs_close) close( unix_handle );
     if (status == STATUS_SUCCESS || (status == STATUS_END_OF_FILE && (!async_read || type == FD_TYPE_FILE)))
     {
-        io->Status = status;
-        io->Information = total;
+        set_sync_iosb( io, status, total, options );
         TRACE("= SUCCESS (%u)\n", total);
         if (event) NtSetEvent( event, NULL );
         if (apc && (!status || async_read)) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
@@ -5802,8 +5801,7 @@ NTSTATUS WINAPI NtReadFileScatter( HANDLE file, HANDLE event, PIO_APC_ROUTINE ap
     send_completion = cvalue != 0;
 
     if (needs_close) close( unix_handle );
-    io->Status = status;
-    io->Information = total;
+    set_sync_iosb( io, status, total, options );
     TRACE("= 0x%08x (%u)\n", status, total);
     if (event) NtSetEvent( event, NULL );
     if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc, (ULONG_PTR)apc_user, iosb_ptr, 0 );
@@ -6031,8 +6029,7 @@ err:
 
     if (status == STATUS_SUCCESS)
     {
-        io->Status = status;
-        io->Information = total;
+        set_sync_iosb( io, status, total, options );
         TRACE("= SUCCESS (%u)\n", total);
         if (event) NtSetEvent( event, NULL );
         if (apc) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc, (ULONG_PTR)apc_user, iosb_ptr, 0 );
-- 
GitLab

diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 41c7ab4ff2c..6cd88a5acc0 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -354,9 +354,9 @@ extern NTSTATUS open_unix_file( HANDLE *
 extern NTSTATUS get_device_info( int fd, struct _FILE_FS_DEVICE_INFORMATION *info ) DECLSPEC_HIDDEN;
 extern void init_files(void) DECLSPEC_HIDDEN;
 extern void init_cpu_info(void) DECLSPEC_HIDDEN;
-extern void add_completion( HANDLE handle, ULONG_PTR value, NTSTATUS status, ULONG info, BOOL async ) DECLSPEC_HIDDEN;
-extern void set_async_direct_result( HANDLE *async_handle, NTSTATUS status, ULONG_PTR information, BOOL mark_pending ) DECLSPEC_HIDDEN;
 extern struct cpu_topology_override *get_cpu_topology_override(void) DECLSPEC_HIDDEN;
+extern void file_complete_async( HANDLE handle, unsigned int options, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user, IO_STATUS_BLOCK *io, NTSTATUS status, ULONG_PTR information ) DECLSPEC_HIDDEN;
+extern void set_async_direct_result( HANDLE *async_handle, unsigned int options, IO_STATUS_BLOCK *io, NTSTATUS status, ULONG_PTR information, BOOL mark_pending ) DECLSPEC_HIDDEN;
 
 extern NTSTATUS unixcall_wine_dbg_write( void *args ) DECLSPEC_HIDDEN;
 extern NTSTATUS unixcall_wine_get_tsc_calibration( void *args ) DECLSPEC_HIDDEN;
