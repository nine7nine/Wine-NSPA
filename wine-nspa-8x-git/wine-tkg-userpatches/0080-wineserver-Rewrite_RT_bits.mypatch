--- a/server/thread.c	2024-07-15 16:11:06.764687510 -0500
+++ b/server/thread.c	2024-07-15 16:10:49.520612507 -0500
@@ -28,6 +28,7 @@
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <stddef.h>
 #include <string.h>
 #include <sys/types.h>
 #include <sys/mman.h>
@@ -913,89 +914,47 @@ affinity_t get_thread_affinity( struct t
 #define THREAD_PRIORITY_REALTIME_LOWEST -7
 
 #if defined(HAVE_SCHED_SETSCHEDULER) || defined(HAVE_SETPRIORITY) 
-static int get_unix_priority( int priority_class, int priority )
-{
-    int min, max, base_priority;
-
-    min = sched_get_priority_min( SCHED_FIFO );
-    max = sched_get_priority_max( SCHED_FIFO );
-
-    // RT priority for threads must be below kernel-mode APC, TIME_CRITICAL threads and Wineserver.
-    if ((base_priority = get_priority( "WINE_RT_PRIO", min, max )) != -1)
-    {
-        thread_base_priority = base_priority - 3;
-    }
-    switch (priority_class) {
-    case PROCESS_PRIOCLASS_IDLE:
-        switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 15;
-        case THREAD_PRIORITY_LOWEST: return 10;
-        case THREAD_PRIORITY_BELOW_NORMAL: return 8;
-        case THREAD_PRIORITY_NORMAL: return 6;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return 4;
-        case THREAD_PRIORITY_HIGHEST: return 2;
-        case THREAD_PRIORITY_TIME_CRITICAL: return -15;
-        }
-    case PROCESS_PRIOCLASS_BELOW_NORMAL:
-        switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 15;
-        case THREAD_PRIORITY_LOWEST: return 8;
-        case THREAD_PRIORITY_BELOW_NORMAL: return 6;
-        case THREAD_PRIORITY_NORMAL: return 4;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return 2;
-        case THREAD_PRIORITY_HIGHEST: return 0;
-        case THREAD_PRIORITY_TIME_CRITICAL: return -15;
-        }
-    case PROCESS_PRIOCLASS_NORMAL:
-        switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 15;
-        case THREAD_PRIORITY_LOWEST: return 4;
-        case THREAD_PRIORITY_BELOW_NORMAL: return 2;
-        case THREAD_PRIORITY_NORMAL: return 0;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return -2;
-        case THREAD_PRIORITY_HIGHEST: return -4;
-        case THREAD_PRIORITY_TIME_CRITICAL: return -15;
-        }
-    case PROCESS_PRIOCLASS_ABOVE_NORMAL:
-        switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 15;
-        case THREAD_PRIORITY_LOWEST: return 0;
-        case THREAD_PRIORITY_BELOW_NORMAL: return -2;
-        case THREAD_PRIORITY_NORMAL: return -4;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return -6;
-        case THREAD_PRIORITY_HIGHEST: return -8;
-        case THREAD_PRIORITY_TIME_CRITICAL: return -15;
-        }
-    case PROCESS_PRIOCLASS_HIGH:
-        switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 15;
-        case THREAD_PRIORITY_LOWEST: return -2;
-        case THREAD_PRIORITY_BELOW_NORMAL: return -4;
-        case THREAD_PRIORITY_NORMAL: return -6;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return -8;
-        case THREAD_PRIORITY_HIGHEST: return -10;
-        case THREAD_PRIORITY_TIME_CRITICAL: return -15;
-        }
-    case PROCESS_PRIOCLASS_REALTIME:
-        switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 0;
-        case -7: return 0;
-        case -5: return 0;
-        case -4: return 0;
-        case -3: return 0;
-        case THREAD_PRIORITY_LOWEST: return -10 + thread_base_priority;
-        case THREAD_PRIORITY_BELOW_NORMAL: return -8 + thread_base_priority;
-        case THREAD_PRIORITY_NORMAL: return -6 + thread_base_priority;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return -4 + thread_base_priority;
-        case THREAD_PRIORITY_HIGHEST: return -2 + thread_base_priority;
-        case 3: return -1 + thread_base_priority;
-        case 4: return -1 + thread_base_priority;
-        case 5: return -1 + thread_base_priority;
-        case 6: return -1 + thread_base_priority;  
-        case THREAD_PRIORITY_TIME_CRITICAL: return thread_base_priority;
-        }
+static int get_unix_priority(int priority_class, int priority) {
+    int min = sched_get_priority_min(SCHED_FIFO);
+    int max = sched_get_priority_max(SCHED_FIFO);
+    int base_priority = get_priority("WINE_RT_PRIO", min, max);
+    int get_priority(const char *variable, int min, int max);
+
+    // Priority mappings based on process priority class
+    int priority_map[6][7] = {
+        // PROCESS_PRIOCLASS_IDLE
+        { 15, 10, 8, 6, 4, 2, -15 },
+        // PROCESS_PRIOCLASS_BELOW_NORMAL
+        { 15, 8, 6, 4, 2, 0, -15 },
+        // PROCESS_PRIOCLASS_NORMAL
+        { 15, 4, 2, 0, -2, -4, -15 },
+        // PROCESS_PRIOCLASS_ABOVE_NORMAL
+        { 15, 0, -2, -4, -6, -8, -15 },
+        // PROCESS_PRIOCLASS_HIGH
+        { 15, -2, -4, -6, -8, -10, -15 },
+        // PROCESS_PRIOCLASS_REALTIME
+        { 0, -10, -8, -6, -4, -2, thread_base_priority }
+    };
+
+    // Map priority to array index
+    int priority_index = -1;
+    switch (priority) {
+        case THREAD_PRIORITY_IDLE:           priority_index = 0; break;
+        case THREAD_PRIORITY_LOWEST:         priority_index = 1; break;
+        case THREAD_PRIORITY_BELOW_NORMAL:    priority_index = 2; break;
+        case THREAD_PRIORITY_NORMAL:          priority_index = 3; break;
+        case THREAD_PRIORITY_ABOVE_NORMAL:    priority_index = 4; break;
+        case THREAD_PRIORITY_HIGHEST:        priority_index = 5; break;
+        case THREAD_PRIORITY_TIME_CRITICAL:  priority_index = 6; break;
+        default: return 0; // Handle unexpected priority values
+    }
+
+    // Ensure the priority class is within bounds
+    if (priority_class < 0 || priority_class >= sizeof(priority_map) / sizeof(priority_map[0])) {
+        return 0;
     }
-    return 0;
+
+    return priority_map[priority_class][priority_index];
 }
 #endif
 

--- a/server/scheduler.c	2024-07-15 16:20:18.690055480 -0500
+++ b/server/scheduler.c	2024-07-15 16:20:09.814017747 -0500
@@ -26,6 +26,7 @@
 #include <assert.h>
 #include <stdio.h>
 #include <stdarg.h>
+#include <stddef.h>
 #ifdef HAVE_SYS_RESOURCE_H
 # include <sys/resource.h>
 #endif
@@ -121,42 +122,43 @@ void init_scheduler( void )
 }
 
 /* sets the scheduler priority of a windows thread */
-void set_scheduler_priority( struct thread *thread )
+void set_scheduler_priority( struct thread *thread )
 {
     if (thread_base_priority == -1 || thread->unix_tid == -1 || thread->fsync_idx == -1) return;
 
-    wine_rt_policy = get_scheduler_policy( "WINE_RT_POLICY" );
+    wine_rt_policy = get_scheduler_policy( "WINE_RT_POLICY" );
     if (wine_rt_policy == -1) wine_rt_policy = SCHED_OTHER; // Default policy if not set
 
     struct sched_param param = {0};
-    
-    if (thread->priority >= THREAD_PRIORITY_TIME_CRITICAL && PROCESS_PRIOCLASS_REALTIME)
-    {
-        wine_rt_policy = SCHED_FIFO;
-        param.sched_priority = thread_base_priority -2;
-    }
-    else if (thread->priority >= THREAD_PRIORITY_HIGHEST && PROCESS_PRIOCLASS_REALTIME)
-    {
-        param.sched_priority = thread_base_priority -4;
-    }
-    else if (thread->priority >= THREAD_PRIORITY_ABOVE_NORMAL && PROCESS_PRIOCLASS_REALTIME)
-    {
-        param.sched_priority = thread_base_priority -6;
-    }
-    else if (thread->priority >= THREAD_PRIORITY_NORMAL && PROCESS_PRIOCLASS_REALTIME)
-    {
-        param.sched_priority = thread_base_priority -8;
-    }
-    else if (thread->priority >= THREAD_PRIORITY_BELOW_NORMAL && PROCESS_PRIOCLASS_REALTIME)
-    {
-        param.sched_priority = thread_base_priority -10;
-    }
-    else if (thread->priority >= THREAD_PRIORITY_LOWEST && PROCESS_PRIOCLASS_REALTIME)
-    {
-        param.sched_priority = thread_base_priority -12;
-    }
-    else if (thread->priority >= THREAD_PRIORITY_IDLE && PROCESS_PRIOCLASS_REALTIME)
-    {
+
+    // Priority adjustment mappings
+    const int priority_adjustments[] = {
+        -2,  // THREAD_PRIORITY_TIME_CRITICAL
+        -4,  // THREAD_PRIORITY_HIGHEST
+        -6,  // THREAD_PRIORITY_ABOVE_NORMAL
+        -8,  // THREAD_PRIORITY_NORMAL
+        -10, // THREAD_PRIORITY_BELOW_NORMAL
+        -12, // THREAD_PRIORITY_LOWEST
+        0    // THREAD_PRIORITY_IDLE
+    };
+
+    // Determine the priority adjustment index
+    int priority_index = 6; // Default to THREAD_PRIORITY_IDLE adjustment
+    // NOTE: PROCESS_PRIOCLASS_REALTIME can be grabbed here (Surprisingly && Necessary!)
+    if (thread->priority >= THREAD_PRIORITY_TIME_CRITICAL && PROCESS_PRIOCLASS_REALTIME) priority_index = 0;
+    else if (thread->priority >= THREAD_PRIORITY_HIGHEST && PROCESS_PRIOCLASS_REALTIME) priority_index = 1;
+    else if (thread->priority >= THREAD_PRIORITY_ABOVE_NORMAL && PROCESS_PRIOCLASS_REALTIME) priority_index = 2;
+    else if (thread->priority >= THREAD_PRIORITY_NORMAL && PROCESS_PRIOCLASS_REALTIME) priority_index = 3;
+    else if (thread->priority >= THREAD_PRIORITY_BELOW_NORMAL && PROCESS_PRIOCLASS_REALTIME) priority_index = 4;
+    else if (thread->priority >= THREAD_PRIORITY_LOWEST && PROCESS_PRIOCLASS_REALTIME) priority_index = 5;
+
+    // Adjust the scheduler parameters based on priority
+    if (priority_index < 6) { // Not THREAD_PRIORITY_IDLE
+        param.sched_priority = thread_base_priority + priority_adjustments[priority_index];
+        if (thread->priority >= THREAD_PRIORITY_TIME_CRITICAL) {
+            wine_rt_policy = SCHED_FIFO;
+        }
+    } else { // THREAD_PRIORITY_IDLE
         wine_rt_policy = SCHED_OTHER;
     }
 
