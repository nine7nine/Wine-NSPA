diff -Npur a/dlls/win32u/dce.c b/dlls/win32u/dce.c
--- a/dlls/win32u/dce.c	2024-01-16 15:55:47.000000000 -0500
+++ b/dlls/win32u/dce.c	2024-07-02 11:33:32.000000000 -0500
@@ -373,6 +373,238 @@ BOOL create_dib_surface( HDC hdc, const
     return TRUE;
 }
 
+struct shm_window_surface
+{
+    struct window_surface header;
+    pthread_mutex_t mutex;
+    RECT        bounds;
+    HANDLE      section;
+    HWND        hwnd;
+    HWND        parent;
+    BITMAPINFO *info;
+};
+
+static struct shm_window_surface *get_shm_surface( struct window_surface *surface )
+{
+    return CONTAINING_RECORD(surface, struct shm_window_surface, header);
+}
+
+static void shm_surface_lock( struct window_surface *window_surface )
+{
+    struct shm_window_surface *surface = get_shm_surface( window_surface );
+    pthread_mutex_lock( &surface->mutex );
+}
+
+static void shm_surface_unlock( struct window_surface *window_surface )
+{
+    struct shm_window_surface *surface = get_shm_surface( window_surface );
+    pthread_mutex_unlock( &surface->mutex );
+}
+
+static void *shm_surface_get_bitmap_info( struct window_surface *window_surface,
+                                          BITMAPINFO *info )
+{
+    struct shm_window_surface *surface = get_shm_surface( window_surface );
+    TRACE( "%p\n", surface );
+    *info = *surface->info;
+    return surface->info + 1;
+}
+
+static RECT *shm_surface_get_bounds( struct window_surface *window_surface )
+{
+    struct shm_window_surface *surface = get_shm_surface( window_surface );
+    return &surface->bounds;
+}
+
+static void shm_surface_set_region( struct window_surface *window_surface, HRGN region )
+{
+    struct shm_window_surface *surface = get_shm_surface( window_surface );
+    FIXME( "(%p %p)\n", surface, region );
+}
+
+static void shm_surface_flush( struct window_surface *window_surface )
+{
+    struct shm_window_surface *surface = get_shm_surface( window_surface );
+
+    TRACE("%p\n", surface);
+
+    window_surface->funcs->lock( window_surface );
+
+    if (!IsRectEmpty( &surface->bounds ))
+    {
+        struct flush_shm_surface_params params;
+        params.section = HandleToLong( surface->section );
+        params.hwnd = HandleToLong( surface->hwnd );
+        params.bounds = surface->bounds;
+
+        if (send_message_timeout( surface->parent, WM_WINE_FLUSHSHMSURFACE, 0, (LPARAM)&params,
+                                  SMTO_ABORTIFHUNG | SMTO_BLOCK, 500, FALSE ))
+            reset_bounds( &surface->bounds );
+    }
+
+    window_surface->funcs->unlock( window_surface );
+}
+
+static void shm_surface_destroy( struct window_surface *window_surface )
+{
+    struct shm_window_surface *surface = get_shm_surface( window_surface );
+
+    TRACE( "freeing %p\n", surface );
+    if (surface->info) NtUnmapViewOfSection( GetCurrentProcess(), surface->info );
+    if (surface->section) NtClose( surface->section );
+    free( surface );
+}
+
+static const struct window_surface_funcs shm_surface_funcs =
+{
+    shm_surface_lock,
+    shm_surface_unlock,
+    shm_surface_get_bitmap_info,
+    shm_surface_get_bounds,
+    shm_surface_set_region,
+    shm_surface_flush,
+    shm_surface_destroy,
+};
+
+struct window_surface *create_shm_surface( HWND window, HWND parent, const RECT *visible_rect,
+                                           struct window_surface *old_surface )
+{
+    OBJECT_ATTRIBUTES attr = { .Length = sizeof(OBJECT_ATTRIBUTES) };
+    struct shm_window_surface *surface;
+    LARGE_INTEGER section_size;
+    pthread_mutexattr_t pthread_attr;
+    HANDLE parent_process;
+    CLIENT_ID cid;
+    SIZE_T view_size = 0;
+    BITMAPINFO info;
+    HANDLE mapping;
+    unsigned int status;
+    DWORD pid;
+    RECT r;
+
+    TRACE( "hwnd %p parent %p\n", window, parent );
+
+    r = *visible_rect;
+    OffsetRect( &r, -r.left, -r.top );
+    if (IsRectEmpty( &r )) return NULL;
+
+    if (old_surface && old_surface->funcs == &shm_surface_funcs)
+    {
+        surface = get_shm_surface( old_surface );
+        if (EqualRect( &surface->header.rect, &r ))
+        {
+            TRACE( "reusing surface %p\n", surface );
+            window_surface_add_ref( old_surface );
+            return old_surface;
+        }
+    }
+
+    surface = calloc( 1, sizeof(*surface) );
+    if (!surface) return NULL;
+
+    TRACE( "crating surface %p for visible_rect %s of window %p\n", surface,
+           wine_dbgstr_rect(visible_rect), window );
+
+    surface->header.funcs = &shm_surface_funcs;
+    surface->header.ref   = 1;
+    surface->header.rect  = r;
+    surface->hwnd         = window;
+    surface->parent       = parent;
+
+    pthread_mutexattr_init( &pthread_attr );
+    pthread_mutexattr_settype( &pthread_attr, PTHREAD_MUTEX_RECURSIVE );
+    pthread_mutex_init( &surface->mutex, &pthread_attr );
+    pthread_mutexattr_destroy( &pthread_attr );
+
+    reset_bounds( &surface->bounds );
+
+    info.bmiHeader.biSize        = sizeof(info.bmiHeader);
+    info.bmiHeader.biWidth       = r.right;
+    info.bmiHeader.biHeight      = -r.bottom;
+    info.bmiHeader.biPlanes      = 1;
+    info.bmiHeader.biBitCount    = 32;
+    info.bmiHeader.biSizeImage   = get_dib_image_size( &info );
+    info.bmiHeader.biCompression = BI_RGB;
+    info.bmiHeader.biClrUsed     = 0;
+
+    section_size.QuadPart = sizeof(info) + info.bmiHeader.biSizeImage;
+    status = NtCreateSection( &mapping,
+                              GENERIC_READ | SECTION_MAP_READ | SECTION_MAP_WRITE,
+                              NULL, &section_size, PAGE_READWRITE, SEC_COMMIT, 0 );
+    if (status)
+    {
+        ERR( "NtCreateSection failed: %x\n", status );
+        window_surface_release( &surface->header );
+        return NULL;
+    }
+
+    status = NtMapViewOfSection( mapping, GetCurrentProcess(), (void**)&surface->info, 0, 0, NULL,
+                                 &view_size, ViewShare, 0, PAGE_READWRITE );
+    if (status)
+    {
+        ERR( "NtMapViewOfSection failed: %x\n", status );
+        shm_surface_destroy( &surface->header );
+        NtClose( mapping );
+        return NULL;
+    }
+
+    get_window_thread( parent, &pid );
+    cid.UniqueProcess = ULongToHandle(pid);
+    cid.UniqueThread  = 0;
+    status = NtOpenProcess( &parent_process, PROCESS_DUP_HANDLE, &attr, &cid );
+    if (status)
+    {
+        ERR( "NtDuplicateObject failed: %x\n", status );
+        window_surface_release( &surface->header );
+        NtClose( mapping );
+        return NULL;
+    }
+
+    status = NtDuplicateObject( GetCurrentProcess(), mapping, parent_process,
+                                &surface->section, FILE_MAP_READ, FALSE, 0 );
+    NtClose( parent_process );
+    NtClose( mapping );
+    if (status)
+    {
+        ERR( "NtDuplicateObject failed: %x\n", status );
+        window_surface_release( &surface->header );
+        return NULL;
+    }
+
+    *surface->info = info;
+    return &surface->header;
+}
+
+void process_surface_message( struct flush_shm_surface_params *params )
+{
+    HANDLE mapping = LongToHandle( params->section );
+    HWND hwnd = LongToHandle( params->hwnd );
+    BITMAPINFO *info = NULL;
+    SIZE_T view_size = 0;
+    unsigned int height;
+    unsigned int status;
+    HDC hdc;
+
+    TRACE( "Flushing %p window surface %s\n", hwnd, wine_dbgstr_rect( &params->bounds ));
+
+    status = NtMapViewOfSection( mapping, GetCurrentProcess(), (void**)&info,
+                                 0, 0, NULL, &view_size, ViewShare, 0, PAGE_READONLY );
+    if (!info)
+    {
+        ERR( "NtMapViewOfSection failed: %x\n", status );
+        return;
+    }
+    height = abs( info->bmiHeader.biHeight );
+
+    hdc = NtUserGetDCEx( hwnd, NULL, DCX_CLIPSIBLINGS );
+    NtGdiSetDIBitsToDeviceInternal( hdc, params->bounds.left, params->bounds.top,
+                                    params->bounds.right - params->bounds.left, params->bounds.bottom - params->bounds.top,
+                                    params->bounds.left, height - params->bounds.bottom, 0, height,
+                                    info + 1, info, DIB_RGB_COLORS, 0, 0, FALSE, NULL);
+    NtUserReleaseDC( hwnd, hdc );
+    NtUnmapViewOfSection( GetCurrentProcess(), info );
+}
+
 /*******************************************************************
  *           register_window_surface
  *
diff -Npur a/dlls/win32u/defwnd.c b/dlls/win32u/defwnd.c
--- a/dlls/win32u/defwnd.c	2024-01-16 15:55:47.000000000 -0500
+++ b/dlls/win32u/defwnd.c	2024-07-02 11:33:32.000000000 -0500
@@ -924,6 +924,11 @@ static void sys_command_size_move( HWND
                                     orig_rect.bottom - orig_rect.top,
                                     hittest == HTCAPTION ? SWP_NOSIZE : 0 );
         }
+
+        /* CrossOver Hack 10879 */
+        if (hittest != HTCAPTION)
+            NtUserRedrawWindow( hwnd, NULL, NULL,
+                                RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN );
     }
 
     if (is_iconic(hwnd) && !moved && (style & WS_SYSMENU))
diff -Npur a/dlls/win32u/message.c b/dlls/win32u/message.c
--- a/dlls/win32u/message.c	2024-01-16 15:55:47.000000000 -0500
+++ b/dlls/win32u/message.c	2024-07-02 11:33:32.000000000 -0500
@@ -872,6 +872,9 @@ static BOOL unpack_message( HWND hwnd, U
         memcpy( &ps->hook, &h_extra, sizeof(h_extra) );
         break;
     }
+    case WM_WINE_FLUSHSHMSURFACE:
+        minsize = sizeof(struct flush_shm_surface_params);
+        break;
     case CB_GETCOMBOBOXINFO:
     {
         COMBOBOXINFO cbi = { sizeof(COMBOBOXINFO) };
@@ -1241,6 +1244,9 @@ static size_t pack_message( HWND hwnd, U
         push_data( data, (LPVOID)h_extra->lparam, sizeof(MSLLHOOKSTRUCT) );
         return 0;
     }
+    case WM_WINE_FLUSHSHMSURFACE:
+        push_data( data, (struct flush_shm_surface_params *)lparam, sizeof(struct flush_shm_surface_params) );
+        return 0;
     case WM_NCPAINT:
         if (wparam <= 1) return 0;
         FIXME( "WM_NCPAINT hdc packing not supported yet\n" );
@@ -2122,6 +2128,9 @@ static LRESULT handle_internal_message(
     case WM_WINE_UPDATEWINDOWSTATE:
         update_window_state( hwnd );
         return 0;
+    case WM_WINE_FLUSHSHMSURFACE:
+        process_surface_message( (struct flush_shm_surface_params *)lparam );
+        return 1;
     default:
         if (msg >= WM_WINE_FIRST_DRIVER_MSG && msg <= WM_WINE_LAST_DRIVER_MSG)
             return user_driver->pWindowMessage( hwnd, msg, wparam, lparam );
@@ -2914,6 +2923,15 @@ static int peek_message( MSG *msg, HWND
                 info.msg.wParam = result.wparam;
                 info.msg.lParam = result.lparam;
             }
+            /* CXHACK 19488 */
+            if (info.msg.message == WM_PAINT &&
+                    flags == (PM_REMOVE | PM_QS_INPUT | PM_QS_POSTMESSAGE | PM_QS_PAINT | PM_QS_SENDMESSAGE) &&
+                    (get_window_long( info.msg.hwnd, GWL_EXSTYLE ) & WS_EX_COMPOSITED ))
+            {
+                send_message( info.msg.hwnd, info.msg.message, info.msg.wParam, info.msg.lParam );
+                flags &= ~PM_QS_PAINT;
+                continue;
+            }
             *msg = info.msg;
             msg->pt = point_phys_to_win_dpi( info.msg.hwnd, info.msg.pt );
             thread_info->client_info.message_pos   = MAKELONG( msg->pt.x, msg->pt.y );
diff -Npur a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
--- a/dlls/win32u/win32u_private.h	2024-01-16 15:55:47.000000000 -0500
+++ b/dlls/win32u/win32u_private.h	2024-07-02 11:33:32.000000000 -0500
@@ -58,6 +58,9 @@ extern void move_window_bits_parent( HWN
                                      const RECT *valid_rects ) DECLSPEC_HIDDEN;
 extern void register_window_surface( struct window_surface *old,
                                      struct window_surface *new ) DECLSPEC_HIDDEN;
+extern struct window_surface *create_shm_surface( HWND hwnd, HWND parent, const RECT *visible_rect,
+                                                  struct window_surface *old_surface );
+extern void process_surface_message( struct flush_shm_surface_params *params );
 
 /* defwnd.c */
 extern LRESULT default_window_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
diff -Npur a/dlls/win32u/window.c b/dlls/win32u/window.c
--- a/dlls/win32u/window.c	2024-01-16 15:55:47.000000000 -0500
+++ b/dlls/win32u/window.c	2024-07-02 11:33:32.000000000 -0500
@@ -1777,7 +1777,7 @@ static BOOL apply_window_pos( HWND hwnd,
 {
     WND *win;
     HWND surface_win = 0, parent = NtUserGetAncestor( hwnd, GA_PARENT );
-    BOOL ret, needs_update = FALSE;
+    BOOL ret, needs_update = FALSE, dummy_shm_surface = FALSE;
     RECT visible_rect, old_visible_rect, old_window_rect, old_client_rect, extra_rects[3];
     struct window_surface *old_surface, *new_surface = NULL;
 
@@ -1786,6 +1786,18 @@ static BOOL apply_window_pos( HWND hwnd,
         new_surface = &dummy_surface;  /* provide a default surface for top-level windows */
         window_surface_add_ref( new_surface );
     }
+    else if (!(swp_flags & SWP_HIDEWINDOW))
+    {
+        win = get_win_ptr( parent );
+        if (win == OBJ_OTHER_PROCESS)
+        {
+            /* provide a default shm surface for windows with parents in other process */
+            new_surface = &dummy_surface;
+            window_surface_add_ref( new_surface );
+            dummy_shm_surface = TRUE;
+        }
+        else if (win && win != WND_DESKTOP) release_win_ptr( win );
+    }
     visible_rect = *window_rect;
     if (!(ret = user_driver->pWindowPosChanging( hwnd, insert_after, swp_flags,
                                                  window_rect, client_rect, &visible_rect, &new_surface )))
@@ -1820,6 +1832,13 @@ static BOOL apply_window_pos( HWND hwnd,
     old_visible_rect = win->visible_rect;
     old_client_rect = win->client_rect;
     old_surface = win->surface;
+
+    if (dummy_shm_surface && new_surface == &dummy_surface)
+    {
+        window_surface_release( new_surface );
+        new_surface = create_shm_surface( hwnd, parent, &visible_rect, old_surface );
+    }
+
     if (old_surface != new_surface) swp_flags |= SWP_FRAMECHANGED;  /* force refreshing non-client area */
     if (new_surface == &dummy_surface) swp_flags |= SWP_NOREDRAW;
     else if (old_surface == &dummy_surface)
diff -Npur a/include/ntuser.h b/include/ntuser.h
--- a/include/ntuser.h	2024-01-16 15:55:47.000000000 -0500
+++ b/include/ntuser.h	2024-07-02 11:33:33.000000000 -0500
@@ -476,6 +476,13 @@ enum associate_input_context_result
     AICR_FAILED,
 };
 
+struct flush_shm_surface_params
+{
+    RECT bounds;
+    ULONG section;
+    ULONG hwnd;
+};
+
 /* internal messages codes */
 enum wine_internal_message
 {
@@ -489,6 +496,7 @@ enum wine_internal_message
     WM_WINE_KEYBOARD_LL_HOOK,
     WM_WINE_MOUSE_LL_HOOK,
     WM_WINE_UPDATEWINDOWSTATE,
+    WM_WINE_FLUSHSHMSURFACE,
     WM_WINE_FIRST_DRIVER_MSG = 0x80001000,  /* range of messages reserved for the USER driver */
     WM_WINE_CLIPCURSOR = 0x80001ff0, /* internal driver notification messages */
     WM_WINE_SETCURSOR,
