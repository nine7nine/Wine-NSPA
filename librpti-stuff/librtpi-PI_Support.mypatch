diff -Npur a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
--- a/dlls/ntdll/Makefile.in	2024-05-01 15:47:14.064107889 -0500
+++ b/dlls/ntdll/Makefile.in	2024-05-01 15:50:04.364920233 -0500
@@ -4,7 +4,7 @@ UNIXLIB   = ntdll.so
 IMPORTLIB = ntdll
 IMPORTS   = $(MUSL_PE_LIBS) winecrt0
 UNIX_CFLAGS  = $(UNWIND_CFLAGS)
-UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS) -lm
+UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS) -lm -lrtpi
 
 EXTRADLLFLAGS = -nodefaultlibs
 i386_EXTRADLLFLAGS = -Wl,--image-base,0x7bc00000
diff -Npur a/dlls/ntdll/unix/cdrom.c b/dlls/ntdll/unix/cdrom.c
--- a/dlls/ntdll/unix/cdrom.c	2024-05-01 15:46:46.786972951 -0500
+++ b/dlls/ntdll/unix/cdrom.c	2024-05-01 15:50:02.236910365 -0500
@@ -290,7 +290,7 @@ struct cdrom_cache {
 #define MAX_CACHE_ENTRIES       5
 static struct cdrom_cache cdrom_cache[MAX_CACHE_ENTRIES];
 
-static pthread_mutex_t cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t cache_mutex = PI_MUTEX_INIT(0);
 
 /* Proposed media change function: not really needed at this time */
 /* This is a 1 or 0 type of function */
diff -Npur a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
--- a/dlls/ntdll/unix/esync.c	2024-05-01 15:47:17.773126123 -0500
+++ b/dlls/ntdll/unix/esync.c	2024-05-01 15:50:02.233910351 -0500
@@ -104,7 +104,7 @@ static void **shm_addrs;
 static int shm_addrs_size;  /* length of the allocated shm_addrs array */
 static long pagesize;
 
-static pthread_mutex_t shm_addrs_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t shm_addrs_mutex = PI_MUTEX_INIT(0);
 
 static void *get_shm( unsigned int idx )
 {
@@ -112,7 +112,7 @@ static void *get_shm( unsigned int idx )
     int offset = (idx * 8) % pagesize;
     void *ret;
 
-    pthread_mutex_lock( &shm_addrs_mutex );
+    pi_mutex_lock( &shm_addrs_mutex );
 
     if (entry >= shm_addrs_size)
     {
@@ -138,7 +138,7 @@ static void *get_shm( unsigned int idx )
 
     ret = (void *)((unsigned long)shm_addrs[entry] + offset);
 
-    pthread_mutex_unlock( &shm_addrs_mutex );
+    pi_mutex_unlock( &shm_addrs_mutex );
 
     return ret;
 }
diff -Npur a/dlls/ntdll/unix/esync.h b/dlls/ntdll/unix/esync.h
--- a/dlls/ntdll/unix/esync.h	2024-05-01 15:47:06.417070209 -0500
+++ b/dlls/ntdll/unix/esync.h	2024-05-01 15:50:02.232910346 -0500
@@ -56,6 +56,6 @@ extern NTSTATUS esync_signal_and_wait( H
  *
  * If we weren't trying to avoid touching the code I'd rename the mutex to
  * "server_fd_mutex" or something similar. */
-extern pthread_mutex_t fd_cache_mutex;
+extern pi_mutex_t fd_cache_mutex;
 
 extern int receive_fd( obj_handle_t *handle ) DECLSPEC_HIDDEN;
diff -Npur a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
--- a/dlls/ntdll/unix/file.c	2024-05-01 15:47:17.792126216 -0500
+++ b/dlls/ntdll/unix/file.c	2024-05-01 15:50:02.231910341 -0500
@@ -249,8 +249,8 @@ static mode_t start_umask;
 /* at some point we may want to allow Winelib apps to set this */
 static const BOOL is_case_sensitive = FALSE;
 
-static pthread_mutex_t dir_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t mnt_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t dir_mutex = PI_MUTEX_INIT(0);
+static pi_mutex_t mnt_mutex = PI_MUTEX_INIT(0);
 
 #ifndef HAVE_RENAMEAT2
 int renameat2( int olddirfd, const char *oldpath, int newdirfd, const char *newpath,
@@ -2328,7 +2328,7 @@ static unsigned int server_open_file_obj
 /* retrieve device/inode number for all the drives */
 static unsigned int get_drives_info( struct file_identity info[MAX_DOS_DRIVES] )
 {
-    static pthread_mutex_t cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+    static pi_mutex_t cache_mutex = PI_MUTEX_INIT(0);
     static struct file_identity cache[MAX_DOS_DRIVES];
     static time_t last_update;
     static unsigned int nb_drives;
@@ -6570,8 +6570,8 @@ static unsigned int set_pending_write( H
     return status;
 }
 
-static pthread_mutex_t async_file_read_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t async_file_read_cond = PTHREAD_COND_INITIALIZER;
+static pi_mutex_t async_file_read_mutex = PI_MUTEX_INIT(0);
+static pi_cond_t async_file_read_cond = PI_COND_INIT(0);
 
 struct async_file_read_job
 {
@@ -6611,12 +6611,12 @@ static void *async_file_read_thread(void
     ULONG total;
     int result;
 
-    pthread_mutex_lock( &async_file_read_mutex );
+    pi_mutex_lock( &async_file_read_mutex );
     while (1)
     {
         while (!(entry = list_head( &async_file_read_queue )))
         {
-            pthread_cond_wait( &async_file_read_cond, &async_file_read_mutex );
+            pi_cond_wait( &async_file_read_cond, &async_file_read_mutex );
             continue;
         }
 
@@ -6627,14 +6627,14 @@ static void *async_file_read_thread(void
 
         if ( job->cancelled )
         {
-            pthread_mutex_unlock( &async_file_read_mutex );
+            pi_mutex_unlock( &async_file_read_mutex );
             status = STATUS_CANCELLED;
             goto done;
         }
 
         job->next = async_file_read_running;
         async_file_read_running = job;
-        pthread_mutex_unlock( &async_file_read_mutex );
+        pi_mutex_unlock( &async_file_read_mutex );
 
         if (!buffer_length)
         {
@@ -6671,7 +6671,7 @@ done:
             async_file_complete_io( job, status, total );
         }
 
-        pthread_mutex_lock( &async_file_read_mutex );
+        pi_mutex_lock( &async_file_read_mutex );
 
         if (status != STATUS_CANCELLED)
         {
@@ -6723,7 +6723,7 @@ static NTSTATUS queue_async_file_read( H
 
     NtResetEvent( event, NULL );
 
-    pthread_mutex_lock( &async_file_read_mutex );
+    pi_mutex_lock( &async_file_read_mutex );
 
     if (async_file_read_free)
     {
@@ -6734,7 +6734,7 @@ static NTSTATUS queue_async_file_read( H
     {
         if (!(job = malloc( sizeof(*job) )))
         {
-            pthread_mutex_unlock( &async_file_read_mutex );
+            pi_mutex_unlock( &async_file_read_mutex );
             return STATUS_NO_MEMORY;
         }
     }
@@ -6752,8 +6752,8 @@ static NTSTATUS queue_async_file_read( H
 
     list_add_tail( &async_file_read_queue, &job->queue_entry );
 
-    pthread_cond_signal( &async_file_read_cond );
-    pthread_mutex_unlock( &async_file_read_mutex );
+    pi_cond_signal( &async_file_read_cond, &async_file_read_mutex );
+    pi_mutex_unlock( &async_file_read_mutex );
 
     return STATUS_PENDING;
 }
@@ -6766,7 +6766,7 @@ static NTSTATUS cancel_async_file_read(
 
     TRACE( "handle %p, io %p.\n", handle, io );
 
-    pthread_mutex_lock( &async_file_read_mutex );
+    pi_mutex_lock( &async_file_read_mutex );
     job = async_file_read_running;
     while (job)
     {
@@ -6791,7 +6791,7 @@ static NTSTATUS cancel_async_file_read(
         }
     }
 
-    pthread_mutex_unlock( &async_file_read_mutex );
+    pi_mutex_unlock( &async_file_read_mutex );
     return count ? STATUS_SUCCESS : STATUS_NOT_FOUND;
 }
 
diff -Npur a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
--- a/dlls/ntdll/unix/fsync.h	2024-05-01 15:47:17.729125907 -0500
+++ b/dlls/ntdll/unix/fsync.h	2024-05-01 15:50:02.232910346 -0500
@@ -51,4 +51,4 @@ extern NTSTATUS fsync_signal_and_wait( H
 /* We have to synchronize on the fd cache mutex so that fsync_close(), close_handle() sequence 
  * called from NtClose() doesn't race with get_fsync_idx(), add_to_list() sequence called
  * from get_object(). */
-extern pthread_mutex_t fd_cache_mutex;
+extern pi_mutex_t fd_cache_mutex;
diff -Npur a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
--- a/dlls/ntdll/unix/server.c	2024-05-01 15:47:17.784126177 -0500
+++ b/dlls/ntdll/unix/server.c	2024-05-01 15:50:02.225910314 -0500
@@ -131,7 +131,7 @@ sigset_t server_block_set;  /* signals t
 static int fd_socket = -1;  /* socket to exchange file descriptors with the server */
 static int initial_cwd = -1;
 static pid_t server_pid;
-pthread_mutex_t fd_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+pi_mutex_t fd_cache_mutex = PI_MUTEX_INIT(0);
 
 /* atomically exchange a 64-bit value */
 static inline LONG64 interlocked_xchg64( LONG64 *dest, LONG64 val )
@@ -460,7 +460,7 @@ NTSTATUS unixcall_wine_server_call( void
 /***********************************************************************
  *           server_enter_uninterrupted_section
  */
-void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset )
+void server_enter_uninterrupted_section( pi_mutex_t *mutex, sigset_t *sigset )
 {
     pthread_sigmask( SIG_BLOCK, &server_block_set, sigset );
     mutex_lock( mutex );
@@ -470,7 +470,7 @@ void server_enter_uninterrupted_section(
 /***********************************************************************
  *           server_leave_uninterrupted_section
  */
-void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset )
+void server_leave_uninterrupted_section( pi_mutex_t *mutex, sigset_t *sigset )
 {
     mutex_unlock( mutex );
     pthread_sigmask( SIG_SETMASK, sigset, NULL );
diff -Npur a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
--- a/dlls/ntdll/unix/signal_arm64.c	2024-05-01 15:47:07.602076056 -0500
+++ b/dlls/ntdll/unix/signal_arm64.c	2024-05-01 15:50:02.224910309 -0500
@@ -28,6 +28,7 @@
 
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <stdarg.h>
diff -Npur a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
--- a/dlls/ntdll/unix/signal_arm.c	2024-05-01 15:47:07.602076056 -0500
+++ b/dlls/ntdll/unix/signal_arm.c	2024-05-01 15:50:02.228910328 -0500
@@ -29,6 +29,7 @@
 
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <stdarg.h>
diff -Npur a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
--- a/dlls/ntdll/unix/signal_i386.c	2024-05-01 15:47:17.564125096 -0500
+++ b/dlls/ntdll/unix/signal_i386.c	2024-05-01 15:50:02.239910379 -0500
@@ -2132,7 +2132,7 @@ struct ldt_copy
 } __wine_ldt_copy;
 
 static WORD gdt_fs_sel;
-static pthread_mutex_t ldt_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t ldt_mutex = PI_MUTEX_INIT(0);
 static const LDT_ENTRY null_entry;
 
 static inline void *ldt_get_base( LDT_ENTRY ent )
diff -Npur a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
--- a/dlls/ntdll/unix/signal_x86_64.c	2024-05-01 15:47:17.564125096 -0500
+++ b/dlls/ntdll/unix/signal_x86_64.c	2024-05-01 15:50:02.240910383 -0500
@@ -29,6 +29,7 @@
 #include <assert.h>
 #include <errno.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <stdarg.h>
@@ -2366,7 +2367,7 @@ struct ldt_copy
     unsigned char flags[LDT_SIZE];
 } __wine_ldt_copy;
 
-static pthread_mutex_t ldt_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t ldt_mutex = PI_MUTEX_INIT(0);
 
 static inline void *ldt_get_base( LDT_ENTRY ent )
 {
diff -Npur a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
--- a/dlls/ntdll/unix/system.c	2024-05-01 15:47:17.509124826 -0500
+++ b/dlls/ntdll/unix/system.c	2024-05-01 15:50:02.234910355 -0500
@@ -244,7 +244,7 @@ static struct
 }
 cpu_override;
 
-static pthread_mutex_t timezone_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t timezone_mutex = PI_MUTEX_INIT(0);
 
 /*******************************************************************************
  * Architecture specific feature detection for CPUs
@@ -2469,7 +2469,7 @@ static time_t find_dst_change(time_t sta
 
 static void get_timezone_info( RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzi )
 {
-    static pthread_mutex_t tz_mutex = PTHREAD_MUTEX_INITIALIZER;
+    static pi_mutex_t tz_mutex = PI_MUTEX_INIT(0);
     static RTL_DYNAMIC_TIME_ZONE_INFORMATION cached_tzi;
     static int current_year = -1, current_bias = 65535;
     struct tm *tm;
@@ -2790,7 +2790,7 @@ NTSTATUS WINAPI NtQuerySystemInformation
         sti.BootTime.QuadPart = server_start_time;
 
         utc = time( NULL );
-        pthread_mutex_lock( &timezone_mutex );
+        pi_mutex_lock( &timezone_mutex );
         if (utc != last_utc)
         {
             last_utc = utc;
@@ -2801,7 +2801,7 @@ NTSTATUS WINAPI NtQuerySystemInformation
             last_bias *= TICKSPERSEC;
         }
         sti.TimeZoneBias.QuadPart = last_bias;
-        pthread_mutex_unlock( &timezone_mutex );
+        pi_mutex_unlock( &timezone_mutex );
 
         NtQuerySystemTime( &sti.SystemTime );
 
diff -Npur a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
--- a/dlls/ntdll/unix/thread.c	2024-05-01 15:47:17.621125376 -0500
+++ b/dlls/ntdll/unix/thread.c	2024-05-01 15:50:02.236910365 -0500
@@ -33,6 +33,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <sys/types.h>
 #include <unistd.h>
diff -Npur a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
--- a/dlls/ntdll/unix/unix_private.h	2024-05-01 15:47:17.770126108 -0500
+++ b/dlls/ntdll/unix/unix_private.h	2024-05-01 15:50:02.232910346 -0500
@@ -22,6 +22,7 @@
 #define __NTDLL_UNIX_PRIVATE_H
 
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include "unixlib.h"
 #include "wine/unixlib.h"
@@ -212,8 +213,8 @@ extern NTSTATUS load_start_exe( WCHAR **
 extern void start_server( BOOL debug ) DECLSPEC_HIDDEN;
 
 extern unsigned int server_call_unlocked( void *req_ptr ) DECLSPEC_HIDDEN;
-extern void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
-extern void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
+extern void server_enter_uninterrupted_section( pi_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
+extern void server_leave_uninterrupted_section( pi_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
 extern unsigned int server_select( const select_op_t *select_op, data_size_t size, UINT flags,
                                    timeout_t abs_timeout, context_t *context, user_apc_t *user_apc ) DECLSPEC_HIDDEN;
 extern unsigned int server_wait( const select_op_t *select_op, data_size_t size, UINT flags,
@@ -403,14 +404,14 @@ static inline BOOL is_inside_signal_stac
             (char *)ptr < (char *)get_signal_stack() + signal_stack_size);
 }
 
-static inline void mutex_lock( pthread_mutex_t *mutex )
+static inline void mutex_lock( pi_mutex_t *mutex )
 {
-    if (!process_exiting) pthread_mutex_lock( mutex );
+    if (!process_exiting) pi_mutex_lock( mutex );
 }
 
-static inline void mutex_unlock( pthread_mutex_t *mutex )
+static inline void mutex_unlock( pi_mutex_t *mutex )
 {
-    if (!process_exiting) pthread_mutex_unlock( mutex );
+    if (!process_exiting) pi_mutex_unlock( mutex );
 }
 
 static inline async_data_t server_async( HANDLE handle, struct async_fileio *user, HANDLE event,
diff -Npur a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
--- a/dlls/ntdll/unix/virtual.c	2024-05-01 15:47:17.510124831 -0500
+++ b/dlls/ntdll/unix/virtual.c	2024-05-01 15:50:02.227910323 -0500
@@ -161,7 +161,7 @@ static const BYTE VIRTUAL_Win32Flags[16]
 };
 
 static struct wine_rb_tree views_tree;
-static pthread_mutex_t virtual_mutex;
+static pi_mutex_t virtual_mutex;
 
 static const UINT page_shift = 12;
 static const UINT_PTR page_mask = 0xfff;
@@ -248,7 +248,7 @@ static pthread_once_t membarrier_init_on
 #endif
 #if defined(__i386__) || defined(__x86_64__)
 static void *dontneed_page;
-static pthread_mutex_t dontneed_page_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t dontneed_page_mutex = PI_MUTEX_INIT(0);
 #endif
 #endif
 
@@ -3322,12 +3322,8 @@ void virtual_init(void)
     const char *preload = getenv( "WINEPRELOADRESERVE" );
     size_t size;
     int i;
-    pthread_mutexattr_t attr;
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &virtual_mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
+    pi_mutex_init( &virtual_mutex, 0 );
 
     if (preload_info && *preload_info)
         for (i = 0; (*preload_info)[i].size; i++)
@@ -6412,7 +6407,7 @@ static int try_madvise( void )
     int ret = 0;
     char *mem;
 
-    pthread_mutex_lock(&dontneed_page_mutex);
+    pi_mutex_lock(&dontneed_page_mutex);
     /* Credits to Avi Kivity (scylladb) and Aliaksei Kandratsenka (gperftools) for this trick,
      * see https://github.com/scylladb/seastar/commit/77a58e4dc020233f66fccb8d9e8f7a8b7f9210c4 */
     mem = dontneed_page;
@@ -6431,7 +6426,7 @@ static int try_madvise( void )
     *mem = 3;
     ret = !madvise( mem, page_size, MADV_DONTNEED );
 failed:
-    pthread_mutex_unlock(&dontneed_page_mutex);
+    pi_mutex_unlock(&dontneed_page_mutex);
     return ret;
 }
 #else
@@ -6441,10 +6436,10 @@ static int try_madvise( void ) { return
 
 static NTSTATUS do_apc_memorybarrier( void )
 {
-    static pthread_mutex_t apc_memorybarrier_mutex = PTHREAD_MUTEX_INITIALIZER;
+    static pi_mutex_t apc_memorybarrier_mutex = PI_MUTEX_INIT(0);
     NTSTATUS status;
 
-    pthread_mutex_lock( &apc_memorybarrier_mutex );
+    pi_mutex_lock( &apc_memorybarrier_mutex );
 
     do
     {
@@ -6465,7 +6460,7 @@ static NTSTATUS do_apc_memorybarrier( vo
     }
     while (status);
 
-    pthread_mutex_unlock( &apc_memorybarrier_mutex );
+    pi_mutex_unlock( &apc_memorybarrier_mutex );
     return STATUS_SUCCESS;
 }
 
diff -Npur a/dlls/opengl32/unix_wgl.c b/dlls/opengl32/unix_wgl.c
--- a/dlls/opengl32/unix_wgl.c	2024-05-01 15:46:47.007974050 -0500
+++ b/dlls/opengl32/unix_wgl.c	2024-05-01 15:50:03.269915156 -0500
@@ -28,6 +28,7 @@
 #include <stdlib.h>
 
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -50,7 +51,7 @@ static BOOL is_wow64(void)
     return !!NtCurrentTeb()->WowTebOffset;
 }
 
-static pthread_mutex_t wgl_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t wgl_lock = PI_MUTEX_INIT(0);
 
 /* handle management */
 
@@ -958,27 +959,27 @@ static void wrap_glDebugMessageCallbackA
 NTSTATUS wgl_wglCopyContext( void *args )
 {
     struct wglCopyContext_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglCopyContext( params->hglrcSrc, params->hglrcDst, params->mask );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS wgl_wglCreateContext( void *args )
 {
     struct wglCreateContext_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglCreateContext( params->hDc );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS wgl_wglDeleteContext( void *args )
 {
     struct wglDeleteContext_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglDeleteContext( params->teb, params->oldContext );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
@@ -992,18 +993,18 @@ NTSTATUS wgl_wglGetProcAddress( void *ar
 NTSTATUS wgl_wglMakeCurrent( void *args )
 {
     struct wglMakeCurrent_params *params = args;
-    if (params->newContext) pthread_mutex_lock( &wgl_lock );
+    if (params->newContext) pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglMakeCurrent( params->teb, params->hDc, params->newContext );
-    if (params->newContext) pthread_mutex_unlock( &wgl_lock );
+    if (params->newContext) pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS wgl_wglShareLists( void *args )
 {
     struct wglShareLists_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglShareLists( params->hrcSrvShare, params->hrcSrvSource );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
@@ -1052,90 +1053,90 @@ NTSTATUS ext_glGetStringi( void *args )
 NTSTATUS ext_wglBindTexImageARB( void *args )
 {
     struct wglBindTexImageARB_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglBindTexImageARB( params->hPbuffer, params->iBuffer );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS ext_wglCreateContextAttribsARB( void *args )
 {
     struct wglCreateContextAttribsARB_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglCreateContextAttribsARB( params->hDC, params->hShareContext, params->attribList );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS ext_wglCreatePbufferARB( void *args )
 {
     struct wglCreatePbufferARB_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglCreatePbufferARB( params->hDC, params->iPixelFormat, params->iWidth, params->iHeight, params->piAttribList );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS ext_wglDestroyPbufferARB( void *args )
 {
     struct wglDestroyPbufferARB_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglDestroyPbufferARB( params->hPbuffer );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS ext_wglGetPbufferDCARB( void *args )
 {
     struct wglGetPbufferDCARB_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglGetPbufferDCARB( params->hPbuffer );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS ext_wglMakeContextCurrentARB( void *args )
 {
     struct wglMakeContextCurrentARB_params *params = args;
-    if (params->hglrc) pthread_mutex_lock( &wgl_lock );
+    if (params->hglrc) pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglMakeContextCurrentARB( params->teb, params->hDrawDC, params->hReadDC, params->hglrc );
-    if (params->hglrc) pthread_mutex_unlock( &wgl_lock );
+    if (params->hglrc) pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS ext_wglQueryPbufferARB( void *args )
 {
     struct wglQueryPbufferARB_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglQueryPbufferARB( params->hPbuffer, params->iAttribute, params->piValue );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS ext_wglReleasePbufferDCARB( void *args )
 {
     struct wglReleasePbufferDCARB_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglReleasePbufferDCARB( params->hPbuffer, params->hDC );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS ext_wglReleaseTexImageARB( void *args )
 {
     struct wglReleaseTexImageARB_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglReleaseTexImageARB( params->hPbuffer, params->iBuffer );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
 NTSTATUS ext_wglSetPbufferAttribARB( void *args )
 {
     struct wglSetPbufferAttribARB_params *params = args;
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
     params->ret = wrap_wglSetPbufferAttribARB( params->hPbuffer, params->piAttribList );
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return STATUS_SUCCESS;
 }
 
@@ -1197,7 +1198,7 @@ static PTR32 find_wow64_string( const ch
     void *tmp;
     SIZE_T i;
 
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
 
     for (i = 0; i < wow64_strings_count; i++) if (wow64_strings[i].str == str) break;
     if (i == wow64_strings_count && (tmp = realloc( wow64_strings, (i + 1) * sizeof(*wow64_strings) )))
@@ -1216,7 +1217,7 @@ static PTR32 find_wow64_string( const ch
         wow64_strings[i].wow64_str = wow64_str;
     }
 
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
 
     return wow64_str;
 }
@@ -1605,7 +1606,7 @@ NTSTATUS wow64_ext_glClientWaitSync( voi
     } *params32 = args;
     NTSTATUS status;
 
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
 
     if (!(handle = get_handle_ptr( ULongToPtr(params32->sync), HANDLE_GLSYNC )))
         status = STATUS_INVALID_HANDLE;
@@ -1622,7 +1623,7 @@ NTSTATUS wow64_ext_glClientWaitSync( voi
         params32->ret = params.ret;
     }
 
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return status;
 }
 
@@ -1636,7 +1637,7 @@ NTSTATUS wow64_ext_glDeleteSync( void *a
     } *params32 = args;
     NTSTATUS status;
 
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
 
     if (!(handle = get_handle_ptr( ULongToPtr(params32->sync), HANDLE_GLSYNC )))
         status = STATUS_INVALID_HANDLE;
@@ -1651,7 +1652,7 @@ NTSTATUS wow64_ext_glDeleteSync( void *a
         free_handle_ptr( handle );
     }
 
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return status;
 }
 
@@ -1674,7 +1675,7 @@ NTSTATUS wow64_ext_glFenceSync( void *ar
 
     if ((status = ext_glFenceSync( &params ))) return status;
 
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
 
     if (!(params32->ret = (UINT_PTR)alloc_handle( HANDLE_GLSYNC, NULL, params.ret )))
     {
@@ -1688,7 +1689,7 @@ NTSTATUS wow64_ext_glFenceSync( void *ar
         status = STATUS_NO_MEMORY;
     }
 
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return status;
 }
 
@@ -1706,7 +1707,7 @@ NTSTATUS wow64_ext_glGetSynciv( void *ar
     } *params32 = args;
     NTSTATUS status;
 
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
 
     if (!(handle = get_handle_ptr( ULongToPtr(params32->sync), HANDLE_GLSYNC )))
         status = STATUS_INVALID_HANDLE;
@@ -1724,7 +1725,7 @@ NTSTATUS wow64_ext_glGetSynciv( void *ar
         status = ext_glGetSynciv( &params );
     }
 
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return status;
 }
 
@@ -1739,7 +1740,7 @@ NTSTATUS wow64_ext_glIsSync( void *args
     } *params32 = args;
     NTSTATUS status;
 
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
 
     if (!(handle = get_handle_ptr( ULongToPtr(params32->sync), HANDLE_GLSYNC )))
         status = STATUS_INVALID_HANDLE;
@@ -1754,7 +1755,7 @@ NTSTATUS wow64_ext_glIsSync( void *args
         params32->ret = params.ret;
     }
 
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return status;
 }
 
@@ -1770,7 +1771,7 @@ NTSTATUS wow64_ext_glWaitSync( void *arg
     } *params32 = args;
     NTSTATUS status;
 
-    pthread_mutex_lock( &wgl_lock );
+    pi_mutex_lock( &wgl_lock );
 
     if (!(handle = get_handle_ptr( ULongToPtr(params32->sync), HANDLE_GLSYNC )))
         status = STATUS_INVALID_HANDLE;
@@ -1786,7 +1787,7 @@ NTSTATUS wow64_ext_glWaitSync( void *arg
         status = ext_glWaitSync( &params );
     }
 
-    pthread_mutex_unlock( &wgl_lock );
+    pi_mutex_unlock( &wgl_lock );
     return status;
 }
 
diff -Npur a/dlls/win32u/alloc.c b/dlls/win32u/alloc.c
--- a/dlls/win32u/alloc.c	2024-05-01 15:47:17.458124575 -0500
+++ b/dlls/win32u/alloc.c	2024-05-01 15:50:03.424915875 -0500
@@ -27,6 +27,7 @@
 #include <string.h>
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -46,7 +47,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(gdi);
 #define MEM_CACHE_THRESHOLD ( 8UL << 20)   /* 8MB */
 #endif
 
-static pthread_mutex_t mem_cache_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t mem_cache_lock = PI_MUTEX_INIT(0);
 static void **mem_cache_buckets[MEM_CACHE_NR_BUCKETS];
 static SIZE_T mem_cache_total_size;
 
@@ -96,7 +97,7 @@ void *alloc_gdi_cache_memory( SIZE_T siz
         real_size = get_bucket_chunk_size( i );
         assert(real_size >= size);
 
-        pthread_mutex_lock( &mem_cache_lock );
+        pi_mutex_lock( &mem_cache_lock );
 
         real_bucket_i = i;
         while (!(mem = bucket_pop_chunk( real_bucket_i )))
@@ -104,7 +105,7 @@ void *alloc_gdi_cache_memory( SIZE_T siz
             if (++real_bucket_i >= MEM_CACHE_NR_BUCKETS) break;
         }
 
-        pthread_mutex_unlock( &mem_cache_lock );
+        pi_mutex_unlock( &mem_cache_lock );
 
         if (mem)
         {
@@ -141,7 +142,7 @@ void free_gdi_cache_memory( void *mem, S
     {
         real_size = get_bucket_chunk_size( i );
 
-        pthread_mutex_lock( &mem_cache_lock );
+        pi_mutex_lock( &mem_cache_lock );
 
         free_bucket_i = 0;
         while (real_size > MEM_CACHE_THRESHOLD - mem_cache_total_size)
@@ -165,7 +166,7 @@ void free_gdi_cache_memory( void *mem, S
             TRACE("discard memory %p (%lu)\n", mem, real_size);
         }
 
-        pthread_mutex_unlock( &mem_cache_lock );
+        pi_mutex_unlock( &mem_cache_lock );
     }
 
     if (mem)
diff -Npur a/dlls/win32u/class.c b/dlls/win32u/class.c
--- a/dlls/win32u/class.c	2024-05-01 15:46:47.240975209 -0500
+++ b/dlls/win32u/class.c	2024-05-01 15:50:03.416915838 -0500
@@ -25,6 +25,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 #include <assert.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -79,7 +80,7 @@ typedef struct tagWINDOWPROC
 
 static WINDOWPROC winproc_array[MAX_WINPROCS];
 static UINT winproc_used = NB_BUILTIN_WINPROCS;
-static pthread_mutex_t winproc_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t winproc_lock = PI_MUTEX_INIT(0);
 
 static struct list class_list = LIST_INIT( class_list );
 
@@ -132,7 +133,7 @@ static inline WINDOWPROC *alloc_winproc_
     if (!func) return NULL;
     if ((proc = get_winproc_ptr( func ))) return proc;
 
-    pthread_mutex_lock( &winproc_lock );
+    pi_mutex_lock( &winproc_lock );
 
     /* check if we already have a winproc for that function */
     if (!(proc = find_winproc( func, ansi )))
@@ -150,7 +151,7 @@ static inline WINDOWPROC *alloc_winproc_
     }
     else TRACE_(win)( "reusing %p for %p\n", proc_to_handle(proc), func );
 
-    pthread_mutex_unlock( &winproc_lock );
+    pi_mutex_unlock( &winproc_lock );
     return proc;
 }
 
diff -Npur a/dlls/win32u/clipboard.c b/dlls/win32u/clipboard.c
--- a/dlls/win32u/clipboard.c	2024-05-01 15:46:40.686942567 -0500
+++ b/dlls/win32u/clipboard.c	2024-05-01 15:50:03.412915819 -0500
@@ -28,6 +28,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "win32u_private.h"
@@ -38,7 +39,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
-static pthread_mutex_t clipboard_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t clipboard_mutex = PI_MUTEX_INIT(0);
 
 struct cached_format
 {
@@ -179,7 +180,7 @@ BOOL WINAPI NtUserOpenClipboard( HWND hw
 
     user_driver->pUpdateClipboard();
 
-    pthread_mutex_lock( &clipboard_mutex );
+    pi_mutex_lock( &clipboard_mutex );
 
     SERVER_START_REQ( open_clipboard )
     {
@@ -191,7 +192,7 @@ BOOL WINAPI NtUserOpenClipboard( HWND hw
 
     if (ret && !is_current_process_window( owner )) invalidate_memory_formats( &free_list );
 
-    pthread_mutex_unlock( &clipboard_mutex );
+    pi_mutex_unlock( &clipboard_mutex );
     free_cached_formats( &free_list );
     return ret;
 }
@@ -235,7 +236,7 @@ BOOL WINAPI NtUserEmptyClipboard(void)
     if (owner)
         send_message_timeout( owner, WM_DESTROYCLIPBOARD, 0, 0, SMTO_ABORTIFHUNG, 5000, FALSE );
 
-    pthread_mutex_lock( &clipboard_mutex );
+    pi_mutex_lock( &clipboard_mutex );
 
     SERVER_START_REQ( empty_clipboard )
     {
@@ -249,7 +250,7 @@ BOOL WINAPI NtUserEmptyClipboard(void)
         list_move_tail( &free_list, &cached_formats );
     }
 
-    pthread_mutex_unlock( &clipboard_mutex );
+    pi_mutex_unlock( &clipboard_mutex );
     free_cached_formats( &free_list );
     return ret;
 }
@@ -579,12 +580,12 @@ NTSTATUS WINAPI NtUserSetClipboardData(
 
     if (params->cache_only)
     {
-        pthread_mutex_lock( &clipboard_mutex );
+        pi_mutex_lock( &clipboard_mutex );
         if ((cache = get_cached_format( format )) && cache->seqno == params->seqno)
             cache->handle = data;
         else
             status = STATUS_UNSUCCESSFUL;
-        pthread_mutex_unlock( &clipboard_mutex );
+        pi_mutex_unlock( &clipboard_mutex );
         return status;
     }
 
@@ -606,7 +607,7 @@ NTSTATUS WINAPI NtUserSetClipboardData(
     }
     NtQueryDefaultLocale( TRUE, &lcid );
 
-    pthread_mutex_lock( &clipboard_mutex );
+    pi_mutex_lock( &clipboard_mutex );
 
     SERVER_START_REQ( set_clipboard_data )
     {
@@ -628,7 +629,7 @@ NTSTATUS WINAPI NtUserSetClipboardData(
     }
     else free( cache );
 
-    pthread_mutex_unlock( &clipboard_mutex );
+    pi_mutex_unlock( &clipboard_mutex );
     if (prev) free_cached_data( prev );
 
 done:
@@ -649,7 +650,7 @@ HANDLE WINAPI NtUserGetClipboardData( UI
 
     for (;;)
     {
-        pthread_mutex_lock( &clipboard_mutex );
+        pi_mutex_lock( &clipboard_mutex );
 
         if (!params->data_only) cache = get_cached_format( format );
 
@@ -680,7 +681,7 @@ HANDLE WINAPI NtUserGetClipboardData( UI
                 if (cache->handle && data_seqno == cache->seqno)  /* we can reuse the cached data */
                 {
                     HANDLE ret = cache->handle;
-                    pthread_mutex_unlock( &clipboard_mutex );
+                    pi_mutex_unlock( &clipboard_mutex );
                     TRACE( "%s returning %p\n", debugstr_format( format ), ret );
                     return ret;
                 }
@@ -692,14 +693,14 @@ HANDLE WINAPI NtUserGetClipboardData( UI
 
             if (params->data_only)
             {
-                pthread_mutex_unlock( &clipboard_mutex );
+                pi_mutex_unlock( &clipboard_mutex );
                 return params->data;
             }
 
             /* allocate new cache entry */
             if (!(cache = malloc( sizeof(*cache) )))
             {
-                pthread_mutex_unlock( &clipboard_mutex );
+                pi_mutex_unlock( &clipboard_mutex );
                 return 0;
             }
 
@@ -708,12 +709,12 @@ HANDLE WINAPI NtUserGetClipboardData( UI
             cache->handle = NULL;
             params->seqno = cache->seqno;
             list_add_tail( &cached_formats, &cache->entry );
-            pthread_mutex_unlock( &clipboard_mutex );
+            pi_mutex_unlock( &clipboard_mutex );
             TRACE( "%s needs unmarshaling\n", debugstr_format( format ) );
             params->data_size = ~0;
             return 0;
         }
-        pthread_mutex_unlock( &clipboard_mutex );
+        pi_mutex_unlock( &clipboard_mutex );
 
         if (status == STATUS_BUFFER_OVERFLOW)
         {
diff -Npur a/dlls/win32u/dc.c b/dlls/win32u/dc.c
--- a/dlls/win32u/dc.c	2024-05-01 15:46:47.240975209 -0500
+++ b/dlls/win32u/dc.c	2024-05-01 15:50:03.413915824 -0500
@@ -27,6 +27,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -43,7 +44,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dc);
 
-static pthread_mutex_t dc_attr_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t dc_attr_lock = PI_MUTEX_INIT(0);
 
 struct dc_attr_bucket
 {
@@ -90,7 +91,7 @@ static DC_ATTR *alloc_dc_attr(void)
     struct dc_attr_bucket *bucket;
     DC_ATTR *dc_attr = NULL;
 
-    pthread_mutex_lock( &dc_attr_lock );
+    pi_mutex_lock( &dc_attr_lock );
 
     LIST_FOR_EACH_ENTRY( bucket, &dc_attr_buckets, struct dc_attr_bucket, entry )
     {
@@ -125,7 +126,7 @@ static DC_ATTR *alloc_dc_attr(void)
 
     if (dc_attr) memset( dc_attr, 0, sizeof( *dc_attr ));
 
-    pthread_mutex_unlock( &dc_attr_lock );
+    pi_mutex_unlock( &dc_attr_lock );
 
     return dc_attr;
 }
@@ -135,7 +136,7 @@ static void free_dc_attr( DC_ATTR *dc_at
 {
     struct dc_attr_bucket *bucket;
 
-    pthread_mutex_lock( &dc_attr_lock );
+    pi_mutex_lock( &dc_attr_lock );
 
     LIST_FOR_EACH_ENTRY( bucket, &dc_attr_buckets, struct dc_attr_bucket, entry )
     {
@@ -145,7 +146,7 @@ static void free_dc_attr( DC_ATTR *dc_at
         break;
     }
 
-    pthread_mutex_unlock( &dc_attr_lock );
+    pi_mutex_unlock( &dc_attr_lock );
 }
 
 
diff -Npur a/dlls/win32u/dce.c b/dlls/win32u/dce.c
--- a/dlls/win32u/dce.c	2024-05-01 15:47:17.671125622 -0500
+++ b/dlls/win32u/dce.c	2024-05-01 15:50:03.421915861 -0500
@@ -25,6 +25,7 @@
 
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "ntgdi_private.h"
@@ -50,7 +51,7 @@ static struct list dce_list = LIST_INIT(
 #define DCE_CACHE_SIZE 64
 
 static struct list window_surfaces = LIST_INIT( window_surfaces );
-static pthread_mutex_t surfaces_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t surfaces_lock = PI_MUTEX_INIT(0);
 
 /*******************************************************************
  * Dummy window surface for windows that shouldn't get painted.
@@ -125,7 +126,7 @@ struct window_surface dummy_surface = {
 struct offscreen_window_surface
 {
     struct window_surface header;
-    pthread_mutex_t mutex;
+    pi_mutex_t mutex;
     RECT bounds;
     char *bits;
     BITMAPINFO info;
@@ -142,13 +143,13 @@ static struct offscreen_window_surface *
 static void offscreen_window_surface_lock( struct window_surface *base )
 {
     struct offscreen_window_surface *impl = impl_from_window_surface( base );
-    pthread_mutex_lock( &impl->mutex );
+    pi_mutex_lock( &impl->mutex );
 }
 
 static void offscreen_window_surface_unlock( struct window_surface *base )
 {
     struct offscreen_window_surface *impl = impl_from_window_surface( base );
-    pthread_mutex_unlock( &impl->mutex );
+    pi_mutex_unlock( &impl->mutex );
 }
 
 static RECT *offscreen_window_surface_get_bounds( struct window_surface *base )
@@ -198,7 +199,6 @@ void create_offscreen_window_surface( co
     struct offscreen_window_surface *impl;
     SIZE_T size;
     RECT surface_rect = *visible_rect;
-    pthread_mutexattr_t attr;
 
     TRACE( "visible_rect %s, surface %p.\n", wine_dbgstr_rect( visible_rect ), surface );
 
@@ -224,10 +224,7 @@ void create_offscreen_window_surface( co
     impl->header.ref = 1;
     impl->header.rect = surface_rect;
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &impl->mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
+    pi_mutex_init( &impl->mutex, 0 );
 
     reset_bounds( &impl->bounds );
 
@@ -383,10 +379,10 @@ void register_window_surface( struct win
     if (old == &dummy_surface) old = NULL;
     if (new == &dummy_surface) new = NULL;
     if (old == new) return;
-    pthread_mutex_lock( &surfaces_lock );
+    pi_mutex_lock( &surfaces_lock );
     if (old) list_remove( &old->entry );
     if (new) list_add_tail( &window_surfaces, &new->entry );
-    pthread_mutex_unlock( &surfaces_lock );
+    pi_mutex_unlock( &surfaces_lock );
 }
 
 /*******************************************************************
@@ -400,7 +396,7 @@ void flush_window_surfaces( BOOL idle )
     DWORD now;
     struct window_surface *surface;
 
-    pthread_mutex_lock( &surfaces_lock );
+    pi_mutex_lock( &surfaces_lock );
     now = NtGetTickCount();
     if (idle) last_idle = now;
     /* if not idle, we only flush if there's evidence that the app never goes idle */
@@ -409,7 +405,7 @@ void flush_window_surfaces( BOOL idle )
     LIST_FOR_EACH_ENTRY( surface, &window_surfaces, struct window_surface, entry )
         surface->funcs->flush( surface );
 done:
-    pthread_mutex_unlock( &surfaces_lock );
+    pi_mutex_unlock( &surfaces_lock );
 }
 
 /***********************************************************************
diff -Npur a/dlls/win32u/dibdrv/graphics.c b/dlls/win32u/dibdrv/graphics.c
--- a/dlls/win32u/dibdrv/graphics.c	2024-05-01 15:47:07.134073747 -0500
+++ b/dlls/win32u/dibdrv/graphics.c	2024-05-01 15:50:03.420915856 -0500
@@ -24,6 +24,7 @@
 
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include "ntgdi_private.h"
 #include "dibdrv.h"
 
@@ -60,7 +61,7 @@ struct cached_font
 
 static struct list font_cache = LIST_INIT( font_cache );
 
-static pthread_mutex_t font_cache_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t font_cache_lock = PI_MUTEX_INIT(0);
 
 
 static BOOL brush_rect( dibdrv_physdev *pdev, dib_brush *brush, const RECT *rect, HRGN clip )
@@ -649,7 +650,7 @@ static struct cached_font *add_cached_fo
     font.aa_flags = aa_flags;
     font.hash = font_cache_hash( &font );
 
-    pthread_mutex_lock( &font_cache_lock );
+    pi_mutex_lock( &font_cache_lock );
     LIST_FOR_EACH_ENTRY( ptr, &font_cache, struct cached_font, entry )
     {
         if (!font_cache_cmp( &font, ptr ))
@@ -682,7 +683,7 @@ static struct cached_font *add_cached_fo
     }
     else if (!(ptr = malloc( sizeof(*ptr) )))
     {
-        pthread_mutex_unlock( &font_cache_lock );
+        pi_mutex_unlock( &font_cache_lock );
         return NULL;
     }
 
@@ -691,7 +692,7 @@ static struct cached_font *add_cached_fo
     memset( ptr->glyphs, 0, sizeof(ptr->glyphs) );
 done:
     list_add_head( &font_cache, &ptr->entry );
-    pthread_mutex_unlock( &font_cache_lock );
+    pi_mutex_unlock( &font_cache_lock );
     TRACE( "%d %s -> %p\n", (int)ptr->lf.lfHeight, debugstr_w(ptr->lf.lfFaceName), ptr );
     return ptr;
 }
diff -Npur a/dlls/win32u/driver.c b/dlls/win32u/driver.c
--- a/dlls/win32u/driver.c	2024-05-01 15:47:10.227088997 -0500
+++ b/dlls/win32u/driver.c	2024-05-01 15:50:03.406915791 -0500
@@ -25,6 +25,7 @@
 
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -55,7 +56,7 @@ static struct user_driver_funcs null_use
 static struct list d3dkmt_adapters = LIST_INIT( d3dkmt_adapters );
 static struct list d3dkmt_devices = LIST_INIT( d3dkmt_devices );
 
-static pthread_mutex_t driver_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t driver_lock = PI_MUTEX_INIT(0);
 static WCHAR driver_load_error[80];
 
 static INT nulldrv_AbortDoc( PHYSDEV dev )
@@ -1417,7 +1418,7 @@ NTSTATUS WINAPI NtGdiDdDDICloseAdapter(
     if (get_display_driver()->pD3DKMTCloseAdapter)
         get_display_driver()->pD3DKMTCloseAdapter( desc );
 
-    pthread_mutex_lock( &driver_lock );
+    pi_mutex_lock( &driver_lock );
     LIST_FOR_EACH_ENTRY( adapter, &d3dkmt_adapters, struct d3dkmt_adapter, entry )
     {
         if (adapter->handle == desc->hAdapter)
@@ -1428,7 +1429,7 @@ NTSTATUS WINAPI NtGdiDdDDICloseAdapter(
             break;
         }
     }
-    pthread_mutex_unlock( &driver_lock );
+    pi_mutex_unlock( &driver_lock );
 
     return status;
 }
@@ -1463,10 +1464,10 @@ NTSTATUS WINAPI NtGdiDdDDIOpenAdapterFro
 
     if (!(adapter = malloc( sizeof( *adapter ) ))) return STATUS_NO_MEMORY;
 
-    pthread_mutex_lock( &driver_lock );
+    pi_mutex_lock( &driver_lock );
     desc->hAdapter = adapter->handle = ++handle_start;
     list_add_tail( &d3dkmt_adapters, &adapter->entry );
-    pthread_mutex_unlock( &driver_lock );
+    pi_mutex_unlock( &driver_lock );
 
     if (get_display_driver()->pD3DKMTOpenAdapterFromLuid)
         get_display_driver()->pD3DKMTOpenAdapterFromLuid( desc );
@@ -1489,7 +1490,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateDevice(
     if (!desc)
         return STATUS_INVALID_PARAMETER;
 
-    pthread_mutex_lock( &driver_lock );
+    pi_mutex_lock( &driver_lock );
     LIST_FOR_EACH_ENTRY( adapter, &d3dkmt_adapters, struct d3dkmt_adapter, entry )
     {
         if (adapter->handle == desc->hAdapter)
@@ -1498,7 +1499,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateDevice(
             break;
         }
     }
-    pthread_mutex_unlock( &driver_lock );
+    pi_mutex_unlock( &driver_lock );
 
     if (!found)
         return STATUS_INVALID_PARAMETER;
@@ -1510,10 +1511,10 @@ NTSTATUS WINAPI NtGdiDdDDICreateDevice(
     if (!device)
         return STATUS_NO_MEMORY;
 
-    pthread_mutex_lock( &driver_lock );
+    pi_mutex_lock( &driver_lock );
     device->handle = ++handle_start;
     list_add_tail( &d3dkmt_devices, &device->entry );
-    pthread_mutex_unlock( &driver_lock );
+    pi_mutex_unlock( &driver_lock );
 
     desc->hDevice = device->handle;
     return STATUS_SUCCESS;
@@ -1533,7 +1534,7 @@ NTSTATUS WINAPI NtGdiDdDDIDestroyDevice(
     if (!desc || !desc->hDevice)
         return STATUS_INVALID_PARAMETER;
 
-    pthread_mutex_lock( &driver_lock );
+    pi_mutex_lock( &driver_lock );
     LIST_FOR_EACH_ENTRY( device, &d3dkmt_devices, struct d3dkmt_device, entry )
     {
         if (device->handle == desc->hDevice)
@@ -1547,7 +1548,7 @@ NTSTATUS WINAPI NtGdiDdDDIDestroyDevice(
             break;
         }
     }
-    pthread_mutex_unlock( &driver_lock );
+    pi_mutex_unlock( &driver_lock );
 
     return status;
 }
diff -Npur a/dlls/win32u/font.c b/dlls/win32u/font.c
--- a/dlls/win32u/font.c	2024-05-01 15:47:17.465124610 -0500
+++ b/dlls/win32u/font.c	2024-05-01 15:50:03.408915801 -0500
@@ -30,6 +30,7 @@
 #include <string.h>
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -466,7 +467,7 @@ static const struct nls_update_font_list
     }
 };
 
-static pthread_mutex_t font_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t font_lock = PI_MUTEX_INIT(0);
 
 pthread_once_t font_list_init_once = PTHREAD_ONCE_INIT;
 DWORD font_list_init_disposition;
@@ -1068,7 +1069,7 @@ static int remove_font( const WCHAR *fil
     struct gdi_font_face *face, *face_next;
     int count = 0;
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     WINE_RB_FOR_EACH_ENTRY_DESTRUCTOR( family, family_next, &family_name_tree, struct gdi_font_family, name_entry )
     {
         family->refcount++;
@@ -1085,7 +1086,7 @@ static int remove_font( const WCHAR *fil
 	}
         release_family( family );
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return count;
 }
 
@@ -2975,7 +2976,7 @@ static void release_gdi_font( struct gdi
     TRACE( "font %p\n", font );
 
     /* add it to the unused list */
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     if (!--font->refcount)
     {
         list_add_head( &unused_gdi_font_list, &font->unused_entry );
@@ -2989,7 +2990,7 @@ static void release_gdi_font( struct gdi
         }
         else unused_font_count++;
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
 }
 
 static void add_font_list(HKEY hkey, const struct nls_update_font_list *fl, int dpi)
@@ -3530,9 +3531,9 @@ static BOOL enum_face_charsets( const st
                elf.elfLogFont.lfCharSet, type, debugstr_w(elf.elfScript),
                elf.elfLogFont.lfItalic, (int)elf.elfLogFont.lfWeight, (int)ntm.ntmTm.ntmFlags );
         /* release section before callback (FIXME) */
-        pthread_mutex_unlock( &font_lock );
+        pi_mutex_unlock( &font_lock );
         if (!proc( &elf.elfLogFont, (TEXTMETRICW *)&ntm, type, lparam )) return FALSE;
-        pthread_mutex_lock( &font_lock );
+        pi_mutex_lock( &font_lock );
     }
     return TRUE;
 }
@@ -3553,7 +3554,7 @@ static BOOL font_EnumFonts( PHYSDEV dev,
 
     count = create_enum_charset_list( charset, enum_charsets );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
 
     if (lf && lf->lfFaceName[0])
     {
@@ -3589,7 +3590,7 @@ static BOOL font_EnumFonts( PHYSDEV dev,
                 return FALSE; /* enum_face_charsets() unlocked font_lock */
 	}
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -3937,13 +3938,13 @@ static BOOL font_GetCharABCWidths( PHYSD
 
     TRACE( "%p, %u, %u, %p\n", physdev->font, first, count, buffer );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     for (i = 0; i < count; i++)
     {
         c = chars ? chars[i] : first + i;
         get_glyph_outline( physdev->font, c, GGO_METRICS, NULL, &buffer[i], 0, NULL, NULL );
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -3964,11 +3965,11 @@ static BOOL font_GetCharABCWidthsI( PHYS
 
     TRACE( "%p, %u, %u, %p\n", physdev->font, first, count, buffer );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     for (c = 0; c < count; c++, buffer++)
         get_glyph_outline( physdev->font, gi ? gi[c] : first + c, GGO_METRICS | GGO_GLYPH_INDEX,
                            NULL, buffer, 0, NULL, NULL );
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -3990,7 +3991,7 @@ static BOOL font_GetCharWidth( PHYSDEV d
 
     TRACE( "%p, %d, %d, %p\n", physdev->font, first, count, buffer );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     for (i = 0; i < count; i++)
     {
         c = chars ? chars[i] : i + first;
@@ -3999,7 +4000,7 @@ static BOOL font_GetCharWidth( PHYSDEV d
         else
             buffer[i] = abc.abcA + abc.abcB + abc.abcC;
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -4124,7 +4125,7 @@ static DWORD font_GetGlyphIndices( PHYSD
         got_default = TRUE;
     }
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
 
     for (i = 0; i < count; i++)
     {
@@ -4153,7 +4154,7 @@ static DWORD font_GetGlyphIndices( PHYSD
         else gi[i] = get_GSUB_vert_glyph( physdev->font, glyph );
     }
 
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return count;
 }
 
@@ -4172,9 +4173,9 @@ static DWORD font_GetGlyphOutline( PHYSD
         dev = GET_NEXT_PHYSDEV( dev, pGetGlyphOutline );
         return dev->funcs->pGetGlyphOutline( dev, glyph, format, gm, buflen, buf, mat );
     }
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     ret = get_glyph_outline( physdev->font, glyph, format, gm, NULL, buflen, buf, mat );
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return ret;
 }
 
@@ -4192,11 +4193,11 @@ static DWORD font_GetKerningPairs( PHYSD
         return dev->funcs->pGetKerningPairs( dev, count, pairs );
     }
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     if (physdev->font->kern_count == -1)
         physdev->font->kern_count = font_funcs->get_kerning_pairs( physdev->font,
                                                                    &physdev->font->kern_pairs );
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
 
     if (count && pairs)
     {
@@ -4289,7 +4290,7 @@ static UINT font_GetOutlineTextMetrics(
 
     if (!physdev->font->scalable) return 0;
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     if (font_funcs->set_outline_text_metrics( physdev->font ))
     {
 	ret = physdev->font->otm.otmSize;
@@ -4311,7 +4312,7 @@ static UINT font_GetOutlineTextMetrics(
             scale_outline_font_metrics( physdev->font, metrics );
         }
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return ret;
 }
 
@@ -4350,14 +4351,14 @@ static BOOL font_GetTextExtentExPoint( P
 
     TRACE( "%p, %s, %d\n", physdev->font, debugstr_wn(str, count), count );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     for (i = pos = 0; i < count; i++)
     {
         get_glyph_outline( physdev->font, str[i], GGO_METRICS, NULL, &abc, 0, NULL, NULL );
         pos += abc.abcA + abc.abcB + abc.abcC;
         dxs[i] = pos;
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -4379,7 +4380,7 @@ static BOOL font_GetTextExtentExPointI(
 
     TRACE( "%p, %p, %d\n", physdev->font, indices, count );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     for (i = pos = 0; i < count; i++)
     {
         get_glyph_outline( physdev->font, indices[i], GGO_METRICS | GGO_GLYPH_INDEX,
@@ -4387,7 +4388,7 @@ static BOOL font_GetTextExtentExPointI(
         pos += abc.abcA + abc.abcB + abc.abcC;
         dxs[i] = pos;
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -4476,7 +4477,7 @@ static BOOL font_GetTextMetrics( PHYSDEV
         return dev->funcs->pGetTextMetrics( dev, metrics );
     }
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     if (font_funcs->set_outline_text_metrics( physdev->font ) ||
         font_funcs->set_bitmap_text_metrics( physdev->font ))
     {
@@ -4484,7 +4485,7 @@ static BOOL font_GetTextMetrics( PHYSDEV
         scale_font_metrics( physdev->font, metrics );
         ret = TRUE;
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return ret;
 }
 
@@ -4683,7 +4684,7 @@ static HFONT font_SelectFont( PHYSDEV de
         }
         TRACE( "DC transform %f %f %f %f\n", dcmat.eM11, dcmat.eM12, dcmat.eM21, dcmat.eM22 );
 
-        pthread_mutex_lock( &font_lock );
+        pi_mutex_lock( &font_lock );
 
         font = select_font( &lf, dcmat, can_use_bitmap );
 
@@ -4700,7 +4701,7 @@ static HFONT font_SelectFont( PHYSDEV de
             *aa_flags = font_funcs->get_aa_flags( font, *aa_flags, antialias_fakes );
         }
         TRACE( "%p %s %d aa %x\n", hfont, debugstr_w(lf.lfFaceName), (int)lf.lfHeight, *aa_flags );
-        pthread_mutex_unlock( &font_lock );
+        pi_mutex_unlock( &font_lock );
     }
     physdev->font = font;
     if (prev) release_gdi_font( prev );
@@ -6466,16 +6467,16 @@ static int add_system_font_resource( con
 
     /* try in %WINDIR%/fonts, needed for Fotobuch Designer */
     get_fonts_win_dir_path( file, path );
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     ret = font_funcs->add_font( path, flags );
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     /* try in datadir/fonts (or builddir/fonts), needed for Magic the Gathering Online */
     if (!ret)
     {
         get_fonts_data_dir_path( file, path );
-        pthread_mutex_lock( &font_lock );
+        pi_mutex_lock( &font_lock );
         ret = font_funcs->add_font( path, flags );
-        pthread_mutex_unlock( &font_lock );
+        pi_mutex_unlock( &font_lock );
     }
     return ret;
 }
@@ -6503,9 +6504,9 @@ static int add_font_resource( LPCWSTR fi
         DWORD addfont_flags = ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_RESOURCE;
 
         if (!(flags & FR_PRIVATE)) addfont_flags |= ADDFONT_ADD_TO_CACHE;
-        pthread_mutex_lock( &font_lock );
+        pi_mutex_lock( &font_lock );
         ret = font_funcs->add_font( file, addfont_flags );
-        pthread_mutex_unlock( &font_lock );
+        pi_mutex_unlock( &font_lock );
     }
     else if (!wcschr( file, '\\' ))
         ret = add_system_font_resource( file, ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_RESOURCE );
@@ -6925,9 +6926,9 @@ HANDLE WINAPI NtGdiAddFontMemResourceEx(
     if (!(copy = malloc( size ))) return NULL;
     memcpy( copy, ptr, size );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     num_fonts = font_funcs->add_mem_font( copy, size, ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_RESOURCE );
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
 
     if (!num_fonts)
     {
@@ -7068,7 +7069,7 @@ BOOL WINAPI NtGdiGetFontFileData( DWORD
 
     pthread_once( &font_list_init_once, font_list_init );
     if (!font_funcs) return FALSE;
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     if ((font = get_font_from_handle( instance_id )))
     {
         if (font->ttc_item_offset) tag = MS_TTCF_TAG;
@@ -7078,7 +7079,7 @@ BOOL WINAPI NtGdiGetFontFileData( DWORD
         else
             RtlSetLastWin32Error( ERROR_INVALID_PARAMETER );
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return ret;
 }
 
@@ -7093,7 +7094,7 @@ BOOL WINAPI NtGdiGetFontFileInfo( DWORD
     BOOL ret = FALSE;
 
     pthread_once( &font_list_init_once, font_list_init );
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
 
     if ((font = get_font_from_handle( instance_id )))
     {
@@ -7108,7 +7109,7 @@ BOOL WINAPI NtGdiGetFontFileInfo( DWORD
         else RtlSetLastWin32Error( ERROR_INSUFFICIENT_BUFFER );
     }
 
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     if (needed) *needed = required_size;
     return ret;
 }
diff -Npur a/dlls/win32u/gdiobj.c b/dlls/win32u/gdiobj.c
--- a/dlls/win32u/gdiobj.c	2024-05-01 15:46:40.692942597 -0500
+++ b/dlls/win32u/gdiobj.c	2024-05-01 15:50:03.417915842 -0500
@@ -27,6 +27,7 @@
 #include <stdarg.h>
 #include <stdio.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -88,7 +89,7 @@ static const LOGBRUSH DkGrayBrush = { BS
 
 static const LOGBRUSH DCBrush = { BS_SOLID, RGB(255,255,255), 0 };
 
-static pthread_mutex_t gdi_lock;
+static pi_mutex_t gdi_lock;
 
 
 /****************************************************************************
@@ -454,9 +455,9 @@ void make_gdi_object_system( HGDIOBJ han
 {
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle ))) entry_obj( entry )->system = !!set;
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 }
 
 /******************************************************************************
@@ -492,9 +493,9 @@ UINT GDI_get_ref_count( HGDIOBJ handle )
     GDI_HANDLE_ENTRY *entry;
     UINT ret = 0;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle ))) ret = entry_obj( entry )->selcount;
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
     return ret;
 }
 
@@ -508,10 +509,10 @@ HGDIOBJ GDI_inc_ref_count( HGDIOBJ handl
 {
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle ))) entry_obj( entry )->selcount++;
     else handle = 0;
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
     return handle;
 }
 
@@ -525,7 +526,7 @@ BOOL GDI_dec_ref_count( HGDIOBJ handle )
 {
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle )))
     {
         assert( entry_obj( entry )->selcount );
@@ -533,13 +534,13 @@ BOOL GDI_dec_ref_count( HGDIOBJ handle )
         {
             /* handle delayed DeleteObject*/
             entry_obj( entry )->deleted = 0;
-            pthread_mutex_unlock( &gdi_lock );
+            pi_mutex_unlock( &gdi_lock );
             TRACE( "executing delayed DeleteObject for %p\n", handle );
             NtGdiDeleteObjectApp( handle );
             return TRUE;
         }
     }
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
     return entry != NULL;
 }
 
@@ -696,7 +697,7 @@ static void dump_gdi_objects( void )
 
     TRACE( "%u objects:\n", GDI_MAX_HANDLE_COUNT );
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     for (entry = gdi_shared->Handles; entry < next_unused; entry++)
     {
         if (!entry->Type)
@@ -707,7 +708,7 @@ static void dump_gdi_objects( void )
                    gdi_obj_type( entry->ExtType << NTGDI_HANDLE_TYPE_SHIFT ),
                    entry_obj( entry )->selcount, entry_obj( entry )->deleted );
     }
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 }
 
 /***********************************************************************
@@ -722,7 +723,7 @@ HGDIOBJ alloc_gdi_handle( struct gdi_obj
 
     assert( type );  /* type 0 is reserved to mark free entries */
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
 
     entry = next_free;
     if (entry)
@@ -731,7 +732,7 @@ HGDIOBJ alloc_gdi_handle( struct gdi_obj
         entry = next_unused++;
     else
     {
-        pthread_mutex_unlock( &gdi_lock );
+        pi_mutex_unlock( &gdi_lock );
         ERR( "out of GDI object handles, expect a crash\n" );
         if (TRACE_ON(gdi)) dump_gdi_objects();
         return 0;
@@ -745,7 +746,7 @@ HGDIOBJ alloc_gdi_handle( struct gdi_obj
     entry->Type    = entry->ExtType & 0x1f;
     if (++entry->Generation == 0xff) entry->Generation = 1;
     ret = entry_to_handle( entry );
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
     TRACE( "allocated %s %p %u/%u\n", gdi_obj_type(type), ret,
            (int)InterlockedIncrement( &debug_count ), GDI_MAX_HANDLE_COUNT );
     return ret;
@@ -762,7 +763,7 @@ void *free_gdi_handle( HGDIOBJ handle )
     void *object = NULL;
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle )))
     {
         TRACE( "freed %s %p %u/%u\n", gdi_obj_type( entry->ExtType << NTGDI_HANDLE_TYPE_SHIFT ),
@@ -772,7 +773,7 @@ void *free_gdi_handle( HGDIOBJ handle )
         entry->Object = (UINT_PTR)next_free;
         next_free = entry;
     }
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
     return object;
 }
 
@@ -800,7 +801,7 @@ void *get_any_obj_ptr( HGDIOBJ handle, D
     void *ptr = NULL;
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
 
     if ((entry = handle_entry( handle )))
     {
@@ -808,7 +809,7 @@ void *get_any_obj_ptr( HGDIOBJ handle, D
         *type = entry->ExtType << NTGDI_HANDLE_TYPE_SHIFT;
     }
 
-    if (!ptr) pthread_mutex_unlock( &gdi_lock );
+    if (!ptr) pi_mutex_unlock( &gdi_lock );
     return ptr;
 }
 
@@ -837,7 +838,7 @@ void *GDI_GetObjPtr( HGDIOBJ handle, DWO
  */
 void GDI_ReleaseObj( HGDIOBJ handle )
 {
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 }
 
 
@@ -861,10 +862,10 @@ BOOL WINAPI NtGdiDeleteObjectApp( HGDIOB
     const struct gdi_obj_funcs *funcs = NULL;
     struct gdi_obj_header *header;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if (!(entry = handle_entry( obj )))
     {
-        pthread_mutex_unlock( &gdi_lock );
+        pi_mutex_unlock( &gdi_lock );
         return FALSE;
     }
 
@@ -872,7 +873,7 @@ BOOL WINAPI NtGdiDeleteObjectApp( HGDIOB
     if (header->system)
     {
 	TRACE("Preserving system object %p\n", obj);
-        pthread_mutex_unlock( &gdi_lock );
+        pi_mutex_unlock( &gdi_lock );
 	return TRUE;
     }
 
@@ -885,7 +886,7 @@ BOOL WINAPI NtGdiDeleteObjectApp( HGDIOB
     }
     else funcs = header->funcs;
 
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 
     TRACE("%p\n", obj );
 
@@ -932,13 +933,13 @@ INT WINAPI NtGdiExtGetObjectW( HGDIOBJ h
 
     TRACE("%p %d %p\n", handle, count, buffer );
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle )))
     {
         funcs = entry_obj( entry )->funcs;
         handle = entry_to_handle( entry );  /* make it a full handle */
     }
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 
     if (funcs && funcs->pGetObjectW)
     {
@@ -987,13 +988,13 @@ BOOL WINAPI NtGdiUnrealizeObject( HGDIOB
     const struct gdi_obj_funcs *funcs = NULL;
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( obj )))
     {
         funcs = entry_obj( entry )->funcs;
         obj = entry_to_handle( entry );  /* make it a full handle */
     }
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 
     if (funcs && funcs->pUnrealizeObject) return funcs->pUnrealizeObject( obj );
     return funcs != NULL;
@@ -1029,13 +1030,9 @@ BOOL WINAPI NtGdiSetColorAdjustment( HDC
 
 void gdi_init(void)
 {
-    pthread_mutexattr_t attr;
     unsigned int dpi;
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &gdi_lock, &attr );
-    pthread_mutexattr_destroy( &attr );
+    pi_mutex_init( &gdi_lock, 0 );
 
     NtQuerySystemInformation( SystemBasicInformation, &system_info, sizeof(system_info), NULL );
     init_gdi_shared();
diff -Npur a/dlls/win32u/imm.c b/dlls/win32u/imm.c
--- a/dlls/win32u/imm.c	2024-05-01 15:46:47.244975229 -0500
+++ b/dlls/win32u/imm.c	2024-05-01 15:50:03.424915875 -0500
@@ -25,6 +25,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "win32u_private.h"
@@ -52,7 +53,7 @@ struct imm_thread_data
 };
 
 static struct list thread_data_list = LIST_INIT( thread_data_list );
-static pthread_mutex_t imm_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t imm_mutex = PI_MUTEX_INIT(0);
 static BOOL disable_ime;
 
 static struct imc *get_imc_ptr( HIMC handle )
@@ -252,9 +253,9 @@ static struct imm_thread_data *get_imm_t
         if (!(data = calloc( 1, sizeof( *data )))) return NULL;
         data->thread_id = GetCurrentThreadId();
 
-        pthread_mutex_lock( &imm_mutex );
+        pi_mutex_lock( &imm_mutex );
         list_add_tail( &thread_data_list, &data->entry );
-        pthread_mutex_unlock( &imm_mutex );
+        pi_mutex_unlock( &imm_mutex );
 
         thread_info->imm_thread_data = data;
     }
@@ -325,7 +326,7 @@ BOOL WINAPI NtUserDisableThreadIme( DWOR
     {
         disable_ime = TRUE;
 
-        pthread_mutex_lock( &imm_mutex );
+        pi_mutex_lock( &imm_mutex );
         LIST_FOR_EACH_ENTRY( thread_data, &thread_data_list, struct imm_thread_data, entry )
         {
             if (thread_data->thread_id == GetCurrentThreadId()) continue;
@@ -333,7 +334,7 @@ BOOL WINAPI NtUserDisableThreadIme( DWOR
             NtUserMessageCall( thread_data->default_hwnd, WM_WINE_DESTROYWINDOW, 0, 0,
                                0, NtUserSendNotifyMessage, FALSE );
         }
-        pthread_mutex_unlock( &imm_mutex );
+        pi_mutex_unlock( &imm_mutex );
     }
     else if (!thread_id || thread_id == GetCurrentThreadId())
     {
@@ -361,14 +362,14 @@ HWND get_default_ime_window( HWND hwnd )
 
         if (!(thread_id = get_window_thread( hwnd, NULL ))) return 0;
 
-        pthread_mutex_lock( &imm_mutex );
+        pi_mutex_lock( &imm_mutex );
         LIST_FOR_EACH_ENTRY( thread_data, &thread_data_list, struct imm_thread_data, entry )
         {
             if (thread_data->thread_id != thread_id) continue;
             ret = thread_data->default_hwnd;
             break;
         }
-        pthread_mutex_unlock( &imm_mutex );
+        pi_mutex_unlock( &imm_mutex );
     }
     else if ((thread_data = get_user_thread_info()->imm_thread_data))
     {
@@ -385,9 +386,9 @@ void cleanup_imm_thread(void)
 
     if (thread_info->imm_thread_data)
     {
-        pthread_mutex_lock( &imm_mutex );
+        pi_mutex_lock( &imm_mutex );
         list_remove( &thread_info->imm_thread_data->entry );
-        pthread_mutex_unlock( &imm_mutex );
+        pi_mutex_unlock( &imm_mutex );
         free( thread_info->imm_thread_data );
         thread_info->imm_thread_data = NULL;
     }
diff -Npur a/dlls/win32u/Makefile.in b/dlls/win32u/Makefile.in
--- a/dlls/win32u/Makefile.in	2024-05-01 15:47:17.458124575 -0500
+++ b/dlls/win32u/Makefile.in	2024-05-01 15:50:04.409920442 -0500
@@ -4,7 +4,7 @@ UNIXLIB   = win32u.so
 IMPORTLIB = win32u
 IMPORTS   = ntdll winecrt0
 UNIX_CFLAGS  = $(FREETYPE_CFLAGS) $(FONTCONFIG_CFLAGS)
-UNIX_LIBS    = $(CARBON_LIBS) $(APPKIT_LIBS) $(PTHREAD_LIBS) -lm
+UNIX_LIBS    = $(CARBON_LIBS) $(APPKIT_LIBS) $(PTHREAD_LIBS) -lm -lrtpi
 
 EXTRADLLFLAGS = -nodefaultlibs -Wb,--syscall-table,1
 
diff -Npur a/dlls/win32u/rawinput.c b/dlls/win32u/rawinput.c
--- a/dlls/win32u/rawinput.c	2024-05-01 15:47:09.632086065 -0500
+++ b/dlls/win32u/rawinput.c	2024-05-01 15:50:03.424915875 -0500
@@ -25,6 +25,7 @@
 
 #include <stdbool.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "win32u_private.h"
 #include "ntuser_private.h"
@@ -208,7 +209,7 @@ struct device
 static RAWINPUTDEVICE *registered_devices;
 static unsigned int registered_device_count;
 static struct list devices = LIST_INIT( devices );
-static pthread_mutex_t rawinput_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t rawinput_mutex = PI_MUTEX_INIT(0);
 
 static struct device *add_device( HKEY key, DWORD type )
 {
@@ -458,7 +459,7 @@ BOOL rawinput_device_get_usages( HANDLE
 {
     struct device *device;
 
-    pthread_mutex_lock( &rawinput_mutex );
+    pi_mutex_lock( &rawinput_mutex );
 
     if (!(device = find_device_from_handle( handle )) || device->info.dwType != RIM_TYPEHID)
         *usage_page = *usage = 0;
@@ -468,7 +469,7 @@ BOOL rawinput_device_get_usages( HANDLE
         *usage = device->info.hid.usUsage;
     }
 
-    pthread_mutex_unlock( &rawinput_mutex );
+    pi_mutex_unlock( &rawinput_mutex );
 
     return *usage_page || *usage;
 }
@@ -496,7 +497,7 @@ UINT WINAPI NtUserGetRawInputDeviceList(
         return ~0u;
     }
 
-    pthread_mutex_lock( &rawinput_mutex );
+    pi_mutex_lock( &rawinput_mutex );
 
     if (ticks - last_check > 2000)
     {
@@ -512,7 +513,7 @@ UINT WINAPI NtUserGetRawInputDeviceList(
         device_list++;
     }
 
-    pthread_mutex_unlock( &rawinput_mutex );
+    pi_mutex_unlock( &rawinput_mutex );
 
     if (!device_list)
     {
@@ -554,11 +555,11 @@ UINT WINAPI NtUserGetRawInputDeviceInfo(
         return ~0u;
     }
 
-    pthread_mutex_lock( &rawinput_mutex );
+    pi_mutex_lock( &rawinput_mutex );
 
     if (!(device = find_device_from_handle( handle )))
     {
-        pthread_mutex_unlock( &rawinput_mutex );
+        pi_mutex_unlock( &rawinput_mutex );
         RtlSetLastWin32Error( ERROR_INVALID_HANDLE );
         return ~0u;
     }
@@ -591,7 +592,7 @@ UINT WINAPI NtUserGetRawInputDeviceInfo(
         break;
     }
 
-    pthread_mutex_unlock( &rawinput_mutex );
+    pi_mutex_unlock( &rawinput_mutex );
 
     if (!data)
         return 0;
@@ -780,9 +781,9 @@ BOOL process_rawinput_message( MSG *msg,
 
     if (msg->message == WM_INPUT_DEVICE_CHANGE)
     {
-        pthread_mutex_lock( &rawinput_mutex );
+        pi_mutex_lock( &rawinput_mutex );
         rawinput_update_device_list();
-        pthread_mutex_unlock( &rawinput_mutex );
+        pi_mutex_unlock( &rawinput_mutex );
     }
     else
     {
@@ -866,18 +867,18 @@ BOOL WINAPI NtUserRegisterRawInputDevice
             FIXME( "Unhandled flags %#x for device %u.\n", (int)devices[i].dwFlags, i );
     }
 
-    pthread_mutex_lock( &rawinput_mutex );
+    pi_mutex_lock( &rawinput_mutex );
 
     if (!registered_device_count && !device_count)
     {
-        pthread_mutex_unlock( &rawinput_mutex );
+        pi_mutex_unlock( &rawinput_mutex );
         return TRUE;
     }
 
     size = (SIZE_T)device_size * (registered_device_count + device_count);
     if (!(new_registered_devices = realloc( registered_devices, size )))
     {
-        pthread_mutex_unlock( &rawinput_mutex );
+        pi_mutex_unlock( &rawinput_mutex );
         RtlSetLastWin32Error( ERROR_OUTOFMEMORY );
         return FALSE;
     }
@@ -888,7 +889,7 @@ BOOL WINAPI NtUserRegisterRawInputDevice
     if (!(device_count = registered_device_count)) server_devices = NULL;
     else if (!(server_devices = malloc( device_count * sizeof(*server_devices) )))
     {
-        pthread_mutex_unlock( &rawinput_mutex );
+        pi_mutex_unlock( &rawinput_mutex );
         RtlSetLastWin32Error( ERROR_OUTOFMEMORY );
         return FALSE;
     }
@@ -910,7 +911,7 @@ BOOL WINAPI NtUserRegisterRawInputDevice
 
     free( server_devices );
 
-    pthread_mutex_unlock( &rawinput_mutex );
+    pi_mutex_unlock( &rawinput_mutex );
 
     return ret;
 }
@@ -930,14 +931,14 @@ UINT WINAPI NtUserGetRegisteredRawInputD
         return ~0u;
     }
 
-    pthread_mutex_lock( &rawinput_mutex );
+    pi_mutex_lock( &rawinput_mutex );
 
     capacity = *device_count * device_size;
     *device_count = registered_device_count;
     size = (SIZE_T)device_size * *device_count;
     if (devices && capacity >= size) memcpy( devices, registered_devices, size );
 
-    pthread_mutex_unlock( &rawinput_mutex );
+    pi_mutex_unlock( &rawinput_mutex );
 
     if (!devices) return 0;
 
diff -Npur a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
--- a/dlls/win32u/sysparams.c	2024-05-01 15:47:16.129118044 -0500
+++ b/dlls/win32u/sysparams.c	2024-05-01 15:50:03.411915814 -0500
@@ -25,6 +25,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 #include <assert.h>
 
 #include "ntstatus.h"
@@ -278,7 +279,7 @@ struct monitor
 static struct list adapters = LIST_INIT(adapters);
 static struct list monitors = LIST_INIT(monitors);
 static INT64 last_query_display_time;
-static pthread_mutex_t display_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t display_lock = PI_MUTEX_INIT(0);
 
 BOOL enable_thunk_lock = FALSE;
 
@@ -414,21 +415,21 @@ static RECT work_area;
 static DWORD process_layout = ~0u;
 
 static HDC display_dc;
-static pthread_mutex_t display_dc_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t display_dc_lock = PI_MUTEX_INIT(0);
 
-static pthread_mutex_t user_mutex;
+static pi_mutex_t user_mutex;
 static unsigned int user_lock_thread, user_lock_rec;
 
 void user_lock(void)
 {
-    pthread_mutex_lock( &user_mutex );
+    pi_mutex_lock( &user_mutex );
     if (!user_lock_rec++) user_lock_thread = GetCurrentThreadId();
 }
 
 void user_unlock(void)
 {
     if (!--user_lock_rec) user_lock_thread = 0;
-    pthread_mutex_unlock( &user_mutex );
+    pi_mutex_unlock( &user_mutex );
 }
 
 void user_check_not_lock(void)
@@ -1247,7 +1248,7 @@ static void add_gpu( const struct gdi_gp
 
     if (!ctx->mutex)
     {
-        pthread_mutex_lock( &display_lock );
+        pi_mutex_lock( &display_lock );
         ctx->mutex = get_display_device_init_mutex();
         prepare_devices();
     }
@@ -1650,7 +1651,7 @@ static void release_display_manager_ctx(
 {
     if (ctx->mutex)
     {
-        pthread_mutex_unlock( &display_lock );
+        pi_mutex_unlock( &display_lock );
         release_display_device_init_mutex( ctx->mutex );
         ctx->mutex = 0;
     }
@@ -1706,7 +1707,7 @@ static BOOL update_display_cache_from_re
 
     if (key.LastWriteTime.QuadPart <= last_query_display_time) return TRUE;
 
-    pthread_mutex_lock( &display_lock );
+    pi_mutex_lock( &display_lock );
     mutex = get_display_device_init_mutex();
 
     clear_display_devices();
@@ -1752,7 +1753,7 @@ static BOOL update_display_cache_from_re
 
     if ((ret = !list_empty( &adapters ) && !list_empty( &monitors )))
         last_query_display_time = key.LastWriteTime.QuadPart;
-    pthread_mutex_unlock( &display_lock );
+    pi_mutex_unlock( &display_lock );
     release_display_device_init_mutex( mutex );
     return ret;
 }
@@ -2033,10 +2034,10 @@ BOOL update_display_cache( BOOL force )
     if (NtUserGetObjectInformation( winstation, UOI_NAME, name, sizeof(name), NULL )
         && !wcscmp( name, wine_service_station_name ))
     {
-        pthread_mutex_lock( &display_lock );
+        pi_mutex_lock( &display_lock );
         clear_display_devices();
         list_add_tail( &monitors, &virtual_monitor.entry );
-        pthread_mutex_unlock( &display_lock );
+        pi_mutex_unlock( &display_lock );
         return TRUE;
     }
 
@@ -2076,25 +2077,25 @@ BOOL update_display_cache( BOOL force )
 static BOOL lock_display_devices(void)
 {
     if (!update_display_cache( FALSE )) return FALSE;
-    pthread_mutex_lock( &display_lock );
+    pi_mutex_lock( &display_lock );
     return TRUE;
 }
 
 static void unlock_display_devices(void)
 {
-    pthread_mutex_unlock( &display_lock );
+    pi_mutex_unlock( &display_lock );
 }
 
 static HDC get_display_dc(void)
 {
-    pthread_mutex_lock( &display_dc_lock );
+    pi_mutex_lock( &display_dc_lock );
     if (!display_dc)
     {
         HDC dc;
 
-        pthread_mutex_unlock( &display_dc_lock );
+        pi_mutex_unlock( &display_dc_lock );
         dc = NtGdiOpenDCW( NULL, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
-        pthread_mutex_lock( &display_dc_lock );
+        pi_mutex_lock( &display_dc_lock );
         if (display_dc)
             NtGdiDeleteObjectApp( dc );
         else
@@ -2105,7 +2106,7 @@ static HDC get_display_dc(void)
 
 static void release_display_dc( HDC hdc )
 {
-    pthread_mutex_unlock( &display_dc_lock );
+    pi_mutex_unlock( &display_dc_lock );
 }
 
 /**********************************************************************
@@ -4639,7 +4640,6 @@ void sysparams_init(void)
     WCHAR buffer[MAX_PATH+16], *p, *appname;
     DWORD i, dispos, dpi_scaling;
     WCHAR layout[KL_NAMELENGTH];
-    pthread_mutexattr_t attr;
     HKEY hkey, appkey = 0;
     DWORD len;
 
@@ -4652,10 +4652,7 @@ void sysparams_init(void)
         {'K','e','y','b','o','a','r','d',' ','L','a','y','o','u','t','\\','P','r','e','l','o','a','d'};
     static const WCHAR x11driverW[] = {'\\','X','1','1',' ','D','r','i','v','e','r',0};
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &user_mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
+    pi_mutex_init( &user_mutex, 0 );
 
     if ((hkey = reg_create_key( hkcu_key, kl_preloadW, sizeof(kl_preloadW), 0, NULL )))
     {
diff -Npur a/dlls/winealsa.drv/alsa.c b/dlls/winealsa.drv/alsa.c
--- a/dlls/winealsa.drv/alsa.c	2024-05-01 15:46:47.261975313 -0500
+++ b/dlls/winealsa.drv/alsa.c	2024-05-01 15:50:02.361910944 -0500
@@ -26,6 +26,7 @@
 #include <stdarg.h>
 #include <stdio.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include <alsa/asoundlib.h>
 
@@ -79,7 +80,7 @@ struct alsa_stream
     LONG32 getbuf_last; /* <0 when using tmp_buffer */
     float *vols;
 
-    pthread_mutex_t lock;
+    pi_mutex_t lock;
 };
 
 #define EXTRA_SAFE_RT 40000
@@ -209,12 +210,12 @@ static int muldiv( int a, int b, int c )
 
 static void alsa_lock(struct alsa_stream *stream)
 {
-    pthread_mutex_lock(&stream->lock);
+    pi_mutex_lock(&stream->lock);
 }
 
 static void alsa_unlock(struct alsa_stream *stream)
 {
-    pthread_mutex_unlock(&stream->lock);
+    pi_mutex_unlock(&stream->lock);
 }
 
 static NTSTATUS alsa_unlock_result(struct alsa_stream *stream,
@@ -1036,7 +1037,7 @@ static NTSTATUS alsa_create_stream(void
     stream->share = params->share;
     stream->flags = params->flags;
 
-    pthread_mutex_init(&stream->lock, NULL);
+    pi_mutex_init(&stream->lock, 0);
 
     TRACE("ALSA period: %lu frames\n", stream->alsa_period_frames);
     TRACE("ALSA buffer: %lu frames\n", stream->alsa_bufsize_frames);
@@ -1091,7 +1092,7 @@ static NTSTATUS alsa_release_stream(void
     free(stream->hw_params);
     free(stream->fmt);
     free(stream->vols);
-    pthread_mutex_destroy(&stream->lock);
+    pi_mutex_destroy(&stream->lock);
     free(stream);
 
     params->result = S_OK;
diff -Npur a/dlls/winealsa.drv/alsamidi.c b/dlls/winealsa.drv/alsamidi.c
--- a/dlls/winealsa.drv/alsamidi.c	2024-05-01 15:46:47.261975313 -0500
+++ b/dlls/winealsa.drv/alsamidi.c	2024-05-01 15:50:02.362910949 -0500
@@ -33,6 +33,7 @@
 #include <stdint.h>
 #include <unistd.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <time.h>
 #include <alsa/asoundlib.h>
 
@@ -76,8 +77,8 @@ struct midi_src
     int                 port_in;
 };
 
-static pthread_mutex_t seq_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t in_buffer_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t seq_mutex = PI_MUTEX_INIT(0);
+static pi_mutex_t in_buffer_mutex = PI_MUTEX_INIT(0);
 
 static unsigned int num_dests, num_srcs;
 static struct midi_dest dests[MAX_MIDIOUTDRV];
@@ -90,9 +91,9 @@ static unsigned int num_midi_in_started;
 static int rec_cancel_pipe[2];
 static pthread_t rec_thread_id;
 
-static pthread_mutex_t notify_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t notify_read_cond = PTHREAD_COND_INITIALIZER;
-static pthread_cond_t notify_write_cond = PTHREAD_COND_INITIALIZER;
+static pi_mutex_t notify_mutex = PI_MUTEX_INIT(0);
+static pi_cond_t notify_read_cond = PI_COND_INIT(0);
+static pi_cond_t notify_write_cond = PI_COND_INIT(0);
 static BOOL notify_quit;
 #define NOTIFY_BUFFER_SIZE 64 + 1 /* + 1 for the sentinel */
 static struct notify_context notify_buffer[NOTIFY_BUFFER_SIZE];
@@ -100,22 +101,22 @@ static struct notify_context *notify_rea
 
 static void seq_lock(void)
 {
-    pthread_mutex_lock(&seq_mutex);
+    pi_mutex_lock(&seq_mutex);
 }
 
 static void seq_unlock(void)
 {
-    pthread_mutex_unlock(&seq_mutex);
+    pi_mutex_unlock(&seq_mutex);
 }
 
 static void in_buffer_lock(void)
 {
-    pthread_mutex_lock(&in_buffer_mutex);
+    pi_mutex_lock(&in_buffer_mutex);
 }
 
 static void in_buffer_unlock(void)
 {
-    pthread_mutex_unlock(&in_buffer_mutex);
+    pi_mutex_unlock(&in_buffer_mutex);
 }
 
 static uint64_t get_time_msec(void)
@@ -188,19 +189,19 @@ static BOOL notify_buffer_remove(struct
 
 static void notify_post(struct notify_context *notify)
 {
-    pthread_mutex_lock(&notify_mutex);
+    pi_mutex_lock(&notify_mutex);
 
     if (notify)
     {
         while (notify_buffer_full())
-            pthread_cond_wait(&notify_write_cond, &notify_mutex);
+            pi_cond_wait(&notify_write_cond, &notify_mutex);
 
         notify_buffer_add(notify);
     }
     else notify_quit = TRUE;
-    pthread_cond_signal(&notify_read_cond);
+    pi_cond_signal(&notify_read_cond, &notify_mutex);
 
-    pthread_mutex_unlock(&notify_mutex);
+    pi_mutex_unlock(&notify_mutex);
 }
 
 static snd_seq_t *seq_open(int *port_in_ret)
@@ -1506,18 +1507,18 @@ NTSTATUS alsa_midi_notify_wait(void *arg
 {
     struct midi_notify_wait_params *params = args;
 
-    pthread_mutex_lock(&notify_mutex);
+    pi_mutex_lock(&notify_mutex);
 
     while (!notify_quit && notify_buffer_empty())
-        pthread_cond_wait(&notify_read_cond, &notify_mutex);
+        pi_cond_wait(&notify_read_cond, &notify_mutex);
 
     *params->quit = notify_quit;
     if (!notify_quit)
     {
         notify_buffer_remove(params->notify);
-        pthread_cond_signal(&notify_write_cond);
+        pi_cond_signal(&notify_write_cond, &notify_mutex);
     }
-    pthread_mutex_unlock(&notify_mutex);
+    pi_mutex_unlock(&notify_mutex);
 
     return STATUS_SUCCESS;
 }
diff -Npur a/dlls/winealsa.drv/Makefile.in b/dlls/winealsa.drv/Makefile.in
--- a/dlls/winealsa.drv/Makefile.in	2024-05-01 15:46:47.260975308 -0500
+++ b/dlls/winealsa.drv/Makefile.in	2024-05-01 15:50:04.368920252 -0500
@@ -2,7 +2,7 @@ MODULE    = winealsa.drv
 UNIXLIB   = winealsa.so
 IMPORTS   = uuid ole32 advapi32
 DELAYIMPORTS = winmm
-UNIX_LIBS    = $(ALSA_LIBS) $(PTHREAD_LIBS)
+UNIX_LIBS    = $(ALSA_LIBS) $(PTHREAD_LIBS) -lrtpi
 
 C_SRCS = \
 	alsa.c \
diff -Npur a/dlls/wineandroid.drv/android.h b/dlls/wineandroid.drv/android.h
--- a/dlls/wineandroid.drv/android.h	2024-05-01 15:46:47.261975313 -0500
+++ b/dlls/wineandroid.drv/android.h	2024-05-01 15:50:01.979909172 -0500
@@ -25,6 +25,7 @@
 #include <stdarg.h>
 #include <stdlib.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <jni.h>
 #include <android/log.h>
 #include <android/input.h>
@@ -53,7 +54,7 @@ DECL_FUNCPTR( ANativeWindow_release );
  * OpenGL driver
  */
 
-extern pthread_mutex_t drawable_mutex DECLSPEC_HIDDEN;
+extern pi_mutex_t drawable_mutex DECLSPEC_HIDDEN;
 extern void update_gl_drawable( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void destroy_gl_drawable( HWND hwnd ) DECLSPEC_HIDDEN;
 extern struct opengl_funcs *get_wgl_driver( UINT version ) DECLSPEC_HIDDEN;
@@ -82,7 +83,7 @@ extern int ioctl_set_cursor( int id, int
  * USER driver
  */
 
-extern pthread_mutex_t win_data_mutex DECLSPEC_HIDDEN;
+extern pi_mutex_t win_data_mutex DECLSPEC_HIDDEN;
 extern INT ANDROID_GetKeyNameText( LONG lparam, LPWSTR buffer, INT size ) DECLSPEC_HIDDEN;
 extern UINT ANDROID_MapVirtualKeyEx( UINT code, UINT maptype, HKL hkl ) DECLSPEC_HIDDEN;
 extern SHORT ANDROID_VkKeyScanEx( WCHAR ch, HKL hkl ) DECLSPEC_HIDDEN;
diff -Npur a/dlls/wineandroid.drv/init.c b/dlls/wineandroid.drv/init.c
--- a/dlls/wineandroid.drv/init.c	2024-05-01 15:46:47.262975318 -0500
+++ b/dlls/wineandroid.drv/init.c	2024-05-01 15:50:01.980909177 -0500
@@ -561,7 +561,6 @@ unsigned short *p_java_gdt_sel = NULL;
 static HRESULT android_init( void *arg )
 {
     struct init_params *params = arg;
-    pthread_mutexattr_t attr;
     jclass class;
     jobject object;
     JNIEnv *jni_env;
@@ -578,11 +577,8 @@ static HRESULT android_init( void *arg )
 
     load_hardware_libs();
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &drawable_mutex, &attr );
-    pthread_mutex_init( &win_data_mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
+    pi_mutex_init(drawable_mutex, 0);
+    pi_mutex_init(win_data_mutex, 0);
 
     register_window_callback = params->register_window_callback;
 
diff -Npur a/dlls/wineandroid.drv/Makefile.in b/dlls/wineandroid.drv/Makefile.in
--- a/dlls/wineandroid.drv/Makefile.in	2024-05-01 15:46:47.261975313 -0500
+++ b/dlls/wineandroid.drv/Makefile.in	2024-05-01 15:50:04.355920192 -0500
@@ -1,7 +1,7 @@
 MODULE    = wineandroid.drv
 UNIXLIB   = wineandroid.so
 IMPORTS   = ntoskrnl
-UNIX_LIBS = -lwin32u $(PTHREAD_LIBS)
+UNIX_LIBS = -lwin32u $(PTHREAD_LIBS) -lrtpi
 
 SOURCES = \
 	build.gradle.in \
diff -Npur a/dlls/wineandroid.drv/opengl.c b/dlls/wineandroid.drv/opengl.c
--- a/dlls/wineandroid.drv/opengl.c	2024-05-01 15:46:47.263975323 -0500
+++ b/dlls/wineandroid.drv/opengl.c	2024-05-01 15:50:01.980909177 -0500
@@ -109,7 +109,7 @@ static struct list gl_drawables = LIST_I
 static void (*pglFinish)(void);
 static void (*pglFlush)(void);
 
-pthread_mutex_t drawable_mutex;
+pi_mutex_t drawable_mutex;
 
 static inline BOOL is_onscreen_pixel_format( int format )
 {
@@ -127,7 +127,7 @@ static struct gl_drawable *create_gl_dra
     gl->window = create_ioctl_window( hwnd, TRUE, 1.0f );
     gl->surface = 0;
     gl->pbuffer = p_eglCreatePbufferSurface( display, pixel_formats[gl->format - 1].config, attribs );
-    pthread_mutex_lock( &drawable_mutex );
+    pi_mutex_lock( &drawable_mutex );
     list_add_head( &gl_drawables, &gl->entry );
     return gl;
 }
@@ -136,26 +136,26 @@ static struct gl_drawable *get_gl_drawab
 {
     struct gl_drawable *gl;
 
-    pthread_mutex_lock( &drawable_mutex );
+    pi_mutex_lock( &drawable_mutex );
     LIST_FOR_EACH_ENTRY( gl, &gl_drawables, struct gl_drawable, entry )
     {
         if (hwnd && gl->hwnd == hwnd) return gl;
         if (hdc && gl->hdc == hdc) return gl;
     }
-    pthread_mutex_unlock( &drawable_mutex );
+    pi_mutex_unlock( &drawable_mutex );
     return NULL;
 }
 
 static void release_gl_drawable( struct gl_drawable *gl )
 {
-    if (gl) pthread_mutex_unlock( &drawable_mutex );
+    if (gl) pi_mutex_unlock( &drawable_mutex );
 }
 
 void destroy_gl_drawable( HWND hwnd )
 {
     struct gl_drawable *gl;
 
-    pthread_mutex_lock( &drawable_mutex );
+    pi_mutex_lock( &drawable_mutex );
     LIST_FOR_EACH_ENTRY( gl, &gl_drawables, struct gl_drawable, entry )
     {
         if (gl->hwnd != hwnd) continue;
@@ -166,7 +166,7 @@ void destroy_gl_drawable( HWND hwnd )
         free( gl );
         break;
     }
-    pthread_mutex_unlock( &drawable_mutex );
+    pi_mutex_unlock( &drawable_mutex );
 }
 
 static BOOL refresh_context( struct wgl_context *ctx )
@@ -442,9 +442,9 @@ static struct wgl_context *android_wglCr
  */
 static BOOL android_wglDeleteContext( struct wgl_context *ctx )
 {
-    pthread_mutex_lock( &drawable_mutex );
+    pi_mutex_lock( &drawable_mutex );
     list_remove( &ctx->entry );
-    pthread_mutex_unlock( &drawable_mutex );
+    pi_mutex_unlock( &drawable_mutex );
     p_eglDestroyContext( display, ctx->context );
     free( ctx );
     return TRUE;
diff -Npur a/dlls/wineandroid.drv/window.c b/dlls/wineandroid.drv/window.c
--- a/dlls/wineandroid.drv/window.c	2024-05-01 15:47:09.586085838 -0500
+++ b/dlls/wineandroid.drv/window.c	2024-05-01 15:50:01.981909182 -0500
@@ -61,7 +61,7 @@ struct android_win_data
 
 #define SWP_AGG_NOPOSCHANGE (SWP_NOSIZE | SWP_NOMOVE | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE | SWP_NOZORDER)
 
-pthread_mutex_t win_data_mutex;
+pi_mutex_t win_data_mutex;
 
 static struct android_win_data *win_data_context[32768];
 
@@ -124,7 +124,7 @@ static struct android_win_data *alloc_wi
         data->hwnd = hwnd;
         data->window = create_ioctl_window( hwnd, FALSE,
                                             (float)get_win_monitor_dpi( hwnd ) / NtUserGetDpiForWindow( hwnd ));
-        pthread_mutex_lock( &win_data_mutex );
+        pi_mutex_lock( &win_data_mutex );
         win_data_context[context_idx(hwnd)] = data;
     }
     return data;
@@ -137,7 +137,7 @@ static struct android_win_data *alloc_wi
 static void free_win_data( struct android_win_data *data )
 {
     win_data_context[context_idx( data->hwnd )] = NULL;
-    pthread_mutex_unlock( &win_data_mutex );
+    pi_mutex_unlock( &win_data_mutex );
     if (data->window) release_ioctl_window( data->window );
     free( data );
 }
@@ -153,9 +153,9 @@ static struct android_win_data *get_win_
     struct android_win_data *data;
 
     if (!hwnd) return NULL;
-    pthread_mutex_lock( &win_data_mutex );
+    pi_mutex_lock( &win_data_mutex );
     if ((data = win_data_context[context_idx(hwnd)]) && data->hwnd == hwnd) return data;
-    pthread_mutex_unlock( &win_data_mutex );
+    pi_mutex_unlock( &win_data_mutex );
     return NULL;
 }
 
@@ -167,7 +167,7 @@ static struct android_win_data *get_win_
  */
 static void release_win_data( struct android_win_data *data )
 {
-    if (data) pthread_mutex_unlock( &win_data_mutex );
+    if (data) pi_mutex_unlock( &win_data_mutex );
 }
 
 
@@ -581,7 +581,7 @@ struct android_window_surface
     BYTE                  alpha;
     COLORREF              color_key;
     void                 *bits;
-    pthread_mutex_t       mutex;
+    pi_mutex_t       mutex;
     BITMAPINFO            info;   /* variable size, must be last */
 };
 
@@ -654,7 +654,7 @@ static void android_surface_lock( struct
 {
     struct android_window_surface *surface = get_android_surface( window_surface );
 
-    pthread_mutex_lock( &surface->mutex );
+    pi_mutex_lock( &surface->mutex );
 }
 
 /***********************************************************************
@@ -664,7 +664,7 @@ static void android_surface_unlock( stru
 {
     struct android_window_surface *surface = get_android_surface( window_surface );
 
-    pthread_mutex_unlock( &surface->mutex );
+    pi_mutex_unlock( &surface->mutex );
 }
 
 /***********************************************************************
@@ -902,7 +902,6 @@ static struct window_surface *create_sur
 {
     struct android_window_surface *surface;
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
-    pthread_mutexattr_t attr;
 
     surface = calloc( 1, FIELD_OFFSET( struct android_window_surface, info.bmiColors[3] ));
     if (!surface) return NULL;
@@ -912,10 +911,7 @@ static struct window_surface *create_sur
     surface->info.bmiHeader.biPlanes      = 1;
     surface->info.bmiHeader.biSizeImage   = get_dib_image_size( &surface->info );
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &surface->mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
+    pi_mutex_init( &surface->mutex, 0 );
 
     surface->header.funcs = &android_surface_funcs;
     surface->header.rect  = *rect;
diff -Npur a/dlls/winebus.sys/bus_iohid.c b/dlls/winebus.sys/bus_iohid.c
--- a/dlls/winebus.sys/bus_iohid.c	2024-05-01 15:46:47.263975323 -0500
+++ b/dlls/winebus.sys/bus_iohid.c	2024-05-01 15:50:03.132914521 -0500
@@ -84,6 +84,7 @@
 #endif /* __APPLE__ */
 
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -100,7 +101,7 @@
 WINE_DEFAULT_DEBUG_CHANNEL(hid);
 #ifdef __APPLE__
 
-static pthread_mutex_t iohid_cs = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t iohid_cs = PI_MUTEX_INIT(0);
 
 static IOHIDManagerRef hid_manager;
 static CFRunLoopRef run_loop;
@@ -177,9 +178,9 @@ static void iohid_device_stop(struct uni
 
     IOHIDDeviceRegisterInputReportCallback(impl->device, NULL, 0, NULL, NULL);
 
-    pthread_mutex_lock(&iohid_cs);
+    pi_mutex_lock(&iohid_cs);
     list_remove(&impl->unix_device.entry);
-    pthread_mutex_unlock(&iohid_cs);
+    pi_mutex_unlock(&iohid_cs);
 }
 
 static NTSTATUS iohid_device_get_report_descriptor(struct unix_device *iface, BYTE *buffer,
@@ -399,9 +400,9 @@ NTSTATUS iohid_bus_wait(void *args)
     do
     {
         if (bus_event_queue_pop(&event_queue, result)) return STATUS_PENDING;
-        pthread_mutex_lock(&iohid_cs);
+        pi_mutex_lock(&iohid_cs);
         ret = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, TRUE);
-        pthread_mutex_unlock(&iohid_cs);
+        pi_mutex_unlock(&iohid_cs);
     } while (ret != kCFRunLoopRunStopped);
 
     TRACE("IOHID main loop exiting\n");
diff -Npur a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
--- a/dlls/winebus.sys/bus_sdl.c	2024-05-01 15:46:47.263975323 -0500
+++ b/dlls/winebus.sys/bus_sdl.c	2024-05-01 15:50:03.131914516 -0500
@@ -37,6 +37,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -60,7 +61,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(hid);
 
 #ifdef SONAME_LIBSDL2
 
-static pthread_mutex_t sdl_cs = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t sdl_cs = PI_MUTEX_INIT(0);
 static struct sdl_bus_options options;
 
 static void *sdl_handle = NULL;
@@ -443,13 +444,13 @@ static NTSTATUS sdl_device_start(struct
     struct sdl_device *impl = impl_from_unix_device(iface);
     NTSTATUS status;
 
-    pthread_mutex_lock(&sdl_cs);
+    pi_mutex_lock(&sdl_cs);
 
     if (impl->sdl_controller) status = build_controller_report_descriptor(iface);
     else status = build_joystick_report_descriptor(iface);
     impl->started = !status;
 
-    pthread_mutex_unlock(&sdl_cs);
+    pi_mutex_unlock(&sdl_cs);
 
     return status;
 }
@@ -462,10 +463,10 @@ static void sdl_device_stop(struct unix_
     if (impl->sdl_controller) pSDL_GameControllerClose(impl->sdl_controller);
     if (impl->sdl_haptic) pSDL_HapticClose(impl->sdl_haptic);
 
-    pthread_mutex_lock(&sdl_cs);
+    pi_mutex_lock(&sdl_cs);
     impl->started = FALSE;
     list_remove(&impl->unix_device.entry);
-    pthread_mutex_unlock(&sdl_cs);
+    pi_mutex_unlock(&sdl_cs);
 }
 
 static NTSTATUS sdl_device_haptics_start(struct unix_device *iface, UINT duration_ms,
@@ -812,10 +813,10 @@ static void check_all_devices_effects_st
     if (ticks - last_ticks < 10) return;
     last_ticks = ticks;
 
-    pthread_mutex_lock(&sdl_cs);
+    pi_mutex_lock(&sdl_cs);
     LIST_FOR_EACH_ENTRY(impl, &device_list, struct sdl_device, unix_device.entry)
         check_device_effects_state(impl);
-    pthread_mutex_unlock(&sdl_cs);
+    pi_mutex_unlock(&sdl_cs);
 }
 
 static BOOL set_report_from_joystick_event(struct sdl_device *impl, SDL_Event *event)
@@ -1021,7 +1022,7 @@ static void process_device_event(SDL_Eve
 
     TRACE("Received action %x\n", event->type);
 
-    pthread_mutex_lock(&sdl_cs);
+    pi_mutex_lock(&sdl_cs);
 
     if (event->type == SDL_JOYDEVICEADDED)
         sdl_add_device(((SDL_JoyDeviceEvent *)event)->which);
@@ -1061,7 +1062,7 @@ static void process_device_event(SDL_Eve
         else set_report_from_controller_event(impl, event);
     }
 
-    pthread_mutex_unlock(&sdl_cs);
+    pi_mutex_unlock(&sdl_cs);
 }
 
 NTSTATUS sdl_bus_init(void *args)
diff -Npur a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
--- a/dlls/winebus.sys/bus_udev.c	2024-05-01 15:46:47.264975328 -0500
+++ b/dlls/winebus.sys/bus_udev.c	2024-05-01 15:50:03.131914516 -0500
@@ -61,6 +61,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -92,7 +93,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(hid);
 
 #ifdef HAVE_UDEV
 
-static pthread_mutex_t udev_cs = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t udev_cs = PI_MUTEX_INIT(0);
 
 static struct udev *udev_context = NULL;
 static struct udev_monitor *udev_monitor;
@@ -279,9 +280,9 @@ static void hidraw_device_destroy(struct
 
 static NTSTATUS hidraw_device_start(struct unix_device *iface)
 {
-    pthread_mutex_lock(&udev_cs);
+    pi_mutex_lock(&udev_cs);
     start_polling_device(iface);
-    pthread_mutex_unlock(&udev_cs);
+    pi_mutex_unlock(&udev_cs);
     return STATUS_SUCCESS;
 }
 
@@ -289,10 +290,10 @@ static void hidraw_device_stop(struct un
 {
     struct hidraw_device *impl = hidraw_impl_from_unix_device(iface);
 
-    pthread_mutex_lock(&udev_cs);
+    pi_mutex_lock(&udev_cs);
     stop_polling_device(iface);
     list_remove(&impl->base.unix_device.entry);
-    pthread_mutex_unlock(&udev_cs);
+    pi_mutex_unlock(&udev_cs);
 }
 
 static NTSTATUS hidraw_device_get_report_descriptor(struct unix_device *iface, BYTE *buffer,
@@ -834,9 +835,9 @@ static NTSTATUS lnxev_device_start(struc
     if ((status = build_report_descriptor(iface, impl->base.udev_device)))
         return status;
 
-    pthread_mutex_lock(&udev_cs);
+    pi_mutex_lock(&udev_cs);
     start_polling_device(iface);
-    pthread_mutex_unlock(&udev_cs);
+    pi_mutex_unlock(&udev_cs);
     return STATUS_SUCCESS;
 }
 
@@ -844,10 +845,10 @@ static void lnxev_device_stop(struct uni
 {
     struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
 
-    pthread_mutex_lock(&udev_cs);
+    pi_mutex_lock(&udev_cs);
     stop_polling_device(iface);
     list_remove(&impl->base.unix_device.entry);
-    pthread_mutex_unlock(&udev_cs);
+    pi_mutex_unlock(&udev_cs);
 }
 
 static void lnxev_device_read_report(struct unix_device *iface)
@@ -1820,16 +1821,16 @@ NTSTATUS udev_bus_wait(void *args)
     {
         if (bus_event_queue_pop(&event_queue, result)) return STATUS_PENDING;
 
-        pthread_mutex_lock(&udev_cs);
+        pi_mutex_lock(&udev_cs);
         while (close_count--) close(close_fds[close_count]);
         memcpy(pfd, poll_fds, poll_count * sizeof(*pfd));
         count = poll_count;
         close_count = 0;
-        pthread_mutex_unlock(&udev_cs);
+        pi_mutex_unlock(&udev_cs);
 
         while (poll(pfd, count, -1) <= 0) {}
 
-        pthread_mutex_lock(&udev_cs);
+        pi_mutex_lock(&udev_cs);
         if (pfd[0].revents)
         {
             if (udev_monitor) process_monitor_event(udev_monitor);
@@ -1844,7 +1845,7 @@ NTSTATUS udev_bus_wait(void *args)
             impl = find_device_from_fd(pfd[i].fd);
             if (impl) impl->read_report(&impl->unix_device);
         }
-        pthread_mutex_unlock(&udev_cs);
+        pi_mutex_unlock(&udev_cs);
     }
 
     TRACE("UDEV main loop exiting\n");
diff -Npur a/dlls/winebus.sys/Makefile.in b/dlls/winebus.sys/Makefile.in
--- a/dlls/winebus.sys/Makefile.in	2024-05-01 15:46:47.263975323 -0500
+++ b/dlls/winebus.sys/Makefile.in	2024-05-01 15:50:04.397920386 -0500
@@ -1,7 +1,7 @@
 MODULE    = winebus.sys
 UNIXLIB   = winebus.so
 IMPORTS   = ntoskrnl hidparse
-UNIX_LIBS    = $(IOKIT_LIBS) $(UDEV_LIBS) $(PTHREAD_LIBS) $(INOTIFY_LIBS)
+UNIX_LIBS    = $(IOKIT_LIBS) $(UDEV_LIBS) $(PTHREAD_LIBS) $(INOTIFY_LIBS) -lrtpi
 UNIX_CFLAGS  = $(UDEV_CFLAGS) $(SDL2_CFLAGS)
 
 EXTRADLLFLAGS = -Wl,--subsystem,native
diff -Npur a/dlls/winecoreaudio.drv/coremidi.c b/dlls/winecoreaudio.drv/coremidi.c
--- a/dlls/winecoreaudio.drv/coremidi.c	2024-05-01 15:46:40.724942756 -0500
+++ b/dlls/winecoreaudio.drv/coremidi.c	2024-05-01 15:50:02.665912355 -0500
@@ -73,6 +73,7 @@
 #undef STDMETHODCALLTYPE
 
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -126,11 +127,11 @@ static UINT num_dests, num_srcs;
 static struct midi_dest *dests;
 static struct midi_src *srcs;
 
-static pthread_mutex_t midi_in_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t midi_in_mutex = PI_MUTEX_INIT(0);
 
 #define NOTIFY_BUFFER_SIZE 64 + 1 /* + 1 for the sentinel */
-static pthread_mutex_t notify_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t notify_cond = PTHREAD_COND_INITIALIZER;
+static pi_mutex_t notify_mutex = PI_MUTEX_INIT(0);
+static pi_cond_t notify_cond = PI_COND_INIT(0);
 static BOOL notify_quit;
 static struct notify_context notify_buffer[NOTIFY_BUFFER_SIZE];
 static struct notify_context *notify_read, *notify_write;
@@ -139,8 +140,8 @@ static struct notify_context *notify_rea
 
 static void midi_in_lock(BOOL lock)
 {
-    if (lock) pthread_mutex_lock(&midi_in_mutex);
-    else pthread_mutex_unlock(&midi_in_mutex);
+    if (lock) pi_mutex_lock(&midi_in_mutex);
+    else pi_mutex_unlock(&midi_in_mutex);
 }
 
 static void set_in_notify(struct notify_context *notify, struct midi_src *src, WORD dev_id, WORD msg,
@@ -197,13 +198,13 @@ static BOOL notify_buffer_remove(struct
 
 static void notify_post(struct notify_context *notify)
 {
-    pthread_mutex_lock(&notify_mutex);
+    pi_mutex_lock(&notify_mutex);
 
     if (notify) notify_buffer_add(notify);
     else notify_quit = TRUE;
-    pthread_cond_signal(&notify_cond);
+    pi_cond_signal(&notify_cond, &notify_mutex);
 
-    pthread_mutex_unlock(&notify_mutex);
+    pi_mutex_unlock(&notify_mutex);
 }
 
 /*
@@ -315,10 +316,10 @@ NTSTATUS unix_midi_init(void *args)
     OSStatus sc;
     UINT i;
 
-    pthread_mutex_lock(&notify_mutex);
+    pi_mutex_lock(&notify_mutex);
     notify_quit = FALSE;
     notify_read = notify_write = notify_buffer;
-    pthread_mutex_unlock(&notify_mutex);
+    pi_mutex_unlock(&notify_mutex);
 
     sc = MIDIClientCreate(name, NULL /* FIXME use notify proc */, NULL, &midi_client);
     CFRelease(name);
@@ -1233,15 +1234,15 @@ NTSTATUS unix_midi_notify_wait(void *arg
 {
     struct midi_notify_wait_params *params = args;
 
-    pthread_mutex_lock(&notify_mutex);
+    pi_mutex_lock(&notify_mutex);
 
     while (!notify_quit && notify_buffer_empty())
-        pthread_cond_wait(&notify_cond, &notify_mutex);
+        pi_cond_wait(&notify_cond, &notify_mutex);
 
     *params->quit = notify_quit;
     if (!notify_quit) notify_buffer_remove(params->notify);
 
-    pthread_mutex_unlock(&notify_mutex);
+    pi_mutex_unlock(&notify_mutex);
 
     return STATUS_SUCCESS;
 }
diff -Npur a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
--- a/dlls/winegstreamer/Makefile.in	2024-05-01 15:46:47.289975453 -0500
+++ b/dlls/winegstreamer/Makefile.in	2024-05-01 15:50:04.389920349 -0500
@@ -4,7 +4,7 @@ IMPORTLIB = winegstreamer
 IMPORTS   = strmbase ole32 oleaut32 msdmo
 DELAYIMPORTS = mfplat mf
 UNIX_CFLAGS  = $(GSTREAMER_CFLAGS)
-UNIX_LIBS    = $(GSTREAMER_LIBS) $(PTHREAD_LIBS)
+UNIX_LIBS    = $(GSTREAMER_LIBS) $(PTHREAD_LIBS) -lrtpi
 
 C_SRCS = \
 	aac_decoder.c \
diff -Npur a/dlls/winegstreamer/wg_allocator.c b/dlls/winegstreamer/wg_allocator.c
--- a/dlls/winegstreamer/wg_allocator.c	2024-05-01 15:46:40.749942881 -0500
+++ b/dlls/winegstreamer/wg_allocator.c	2024-05-01 15:50:03.017913987 -0500
@@ -52,8 +52,8 @@ typedef struct
 {
     GstAllocator parent;
 
-    pthread_mutex_t mutex;
-    pthread_cond_t release_cond;
+    pi_mutex_t mutex;
+    pi_cond_t release_cond;
     struct list memory_list;
 
     struct wg_sample *next_sample;
@@ -89,7 +89,7 @@ static void release_memory_sample(WgAllo
     while (sample->refcount > 1)
     {
         GST_WARNING("Waiting for sample %p to be unmapped", sample);
-        pthread_cond_wait(&allocator->release_cond, &allocator->mutex);
+        pi_cond_wait(&allocator->release_cond, &allocator->mutex);
     }
     InterlockedDecrement(&sample->refcount);
 
@@ -113,7 +113,7 @@ static gpointer wg_allocator_map(GstMemo
 
     GST_LOG("memory %p, info %p, maxsize %#zx", memory, info, maxsize);
 
-    pthread_mutex_lock(&allocator->mutex);
+    pi_mutex_lock(&allocator->mutex);
 
     if (!memory->sample)
         info->data = get_unix_memory_data(memory);
@@ -125,7 +125,7 @@ static gpointer wg_allocator_map(GstMemo
     if (info->flags & GST_MAP_WRITE)
         memory->written = max(memory->written, maxsize);
 
-    pthread_mutex_unlock(&allocator->mutex);
+    pi_mutex_unlock(&allocator->mutex);
 
     GST_INFO("Mapped memory %p to %p", memory, info->data);
     return info->data;
@@ -141,15 +141,15 @@ static void wg_allocator_unmap(GstMemory
 
     GST_LOG("memory %p, info %p", memory, info);
 
-    pthread_mutex_lock(&allocator->mutex);
+    pi_mutex_lock(&allocator->mutex);
 
     if (memory->sample && info->data == wg_sample_data(memory->sample))
     {
         InterlockedDecrement(&memory->sample->refcount);
-        pthread_cond_signal(&allocator->release_cond);
+        pi_cond_signal(&allocator->release_cond, &allocator->mutex);
     }
 
-    pthread_mutex_unlock(&allocator->mutex);
+    pi_mutex_unlock(&allocator->mutex);
 }
 
 static void wg_allocator_init(WgAllocator *allocator)
@@ -163,8 +163,7 @@ static void wg_allocator_init(WgAllocato
 
     GST_OBJECT_FLAG_SET(allocator, GST_ALLOCATOR_FLAG_CUSTOM_ALLOC);
 
-    pthread_mutex_init(&allocator->mutex, NULL);
-    pthread_cond_init(&allocator->release_cond, NULL);
+    pi_cond_init(&allocator->release_cond, 0);
     list_init(&allocator->memory_list);
 }
 
@@ -174,7 +173,7 @@ static void wg_allocator_finalize(GObjec
 
     GST_LOG("allocator %p", allocator);
 
-    pthread_cond_destroy(&allocator->release_cond);
+    pi_cond_destroy(&allocator->release_cond);
     pthread_mutex_destroy(&allocator->mutex);
 
     G_OBJECT_CLASS(wg_allocator_parent_class)->finalize(object);
@@ -193,7 +192,7 @@ static GstMemory *wg_allocator_alloc(Gst
             NULL, size, 0, 0, size);
     memory->alloc_params = *params;
 
-    pthread_mutex_lock(&allocator->mutex);
+    pi_mutex_lock(&allocator->mutex);
 
     memory->sample = allocator->next_sample;
     allocator->next_sample = NULL;
@@ -203,7 +202,7 @@ static GstMemory *wg_allocator_alloc(Gst
 
     list_add_tail(&allocator->memory_list, &memory->entry);
 
-    pthread_mutex_unlock(&allocator->mutex);
+    pi_mutex_unlock(&allocator->mutex);
 
     GST_INFO("Allocated memory %p, sample %p", memory, memory->sample);
     return (GstMemory *)memory;
@@ -216,7 +215,7 @@ static void wg_allocator_free(GstAllocat
 
     GST_LOG("allocator %p, memory %p", allocator, memory);
 
-    pthread_mutex_lock(&allocator->mutex);
+    pi_mutex_lock(&allocator->mutex);
 
     if (memory->sample)
         InterlockedDecrement(&memory->sample->refcount);
@@ -224,7 +223,7 @@ static void wg_allocator_free(GstAllocat
 
     list_remove(&memory->entry);
 
-    pthread_mutex_unlock(&allocator->mutex);
+    pi_mutex_unlock(&allocator->mutex);
 
     if (memory->unix_memory)
     {
@@ -263,10 +262,10 @@ void wg_allocator_destroy(GstAllocator *
 
     GST_LOG("allocator %p", allocator);
 
-    pthread_mutex_lock(&allocator->mutex);
+    pi_mutex_lock(&allocator->mutex);
     LIST_FOR_EACH_ENTRY(memory, &allocator->memory_list, WgMemory, entry)
         release_memory_sample(allocator, memory, true);
-    pthread_mutex_unlock(&allocator->mutex);
+    pi_mutex_unlock(&allocator->mutex);
 
     g_object_unref(allocator);
 
@@ -294,10 +293,10 @@ void wg_allocator_provide_sample(GstAllo
     if (sample)
         InterlockedIncrement(&sample->refcount);
 
-    pthread_mutex_lock(&allocator->mutex);
+    pi_mutex_lock(&allocator->mutex);
     previous = allocator->next_sample;
     allocator->next_sample = sample;
-    pthread_mutex_unlock(&allocator->mutex);
+    pi_mutex_unlock(&allocator->mutex);
 
     if (previous)
         InterlockedDecrement(&previous->refcount);
@@ -311,10 +310,10 @@ void wg_allocator_release_sample(GstAllo
 
     GST_LOG("allocator %p, sample %p, discard_data %u", allocator, sample, discard_data);
 
-    pthread_mutex_lock(&allocator->mutex);
+    pi_mutex_lock(&allocator->mutex);
     if ((memory = find_sample_memory(allocator, sample)))
         release_memory_sample(allocator, memory, discard_data);
     else if (sample->refcount)
         GST_ERROR("Couldn't find memory for sample %p", sample);
-    pthread_mutex_unlock(&allocator->mutex);
+    pi_mutex_unlock(&allocator->mutex);
 }
diff -Npur a/dlls/winegstreamer/wg_parser.c b/dlls/winegstreamer/wg_parser.c
--- a/dlls/winegstreamer/wg_parser.c	2024-05-01 15:46:47.292975468 -0500
+++ b/dlls/winegstreamer/wg_parser.c	2024-05-01 15:50:03.018913992 -0500
@@ -75,13 +75,13 @@ struct wg_parser
 
     pthread_t push_thread;
 
-    pthread_mutex_t mutex;
+    pi_mutex_t mutex;
 
-    pthread_cond_t init_cond;
+    pi_cond_t init_cond;
     bool no_more_pads, has_duration, error;
     bool err_on, warn_on;
 
-    pthread_cond_t read_cond, read_done_cond;
+    pi_cond_t read_cond, read_done_cond;
     struct
     {
         GstBuffer *buffer;
@@ -109,7 +109,7 @@ struct wg_parser_stream
     GstSegment segment;
     struct wg_format preferred_format, current_format, codec_format;
 
-    pthread_cond_t event_cond, event_empty_cond;
+    pi_cond_t event_cond, event_empty_cond;
     GstBuffer *buffer;
     GstMapInfo map_info;
 
@@ -157,21 +157,21 @@ static NTSTATUS wg_parser_get_next_read_
     struct wg_parser_get_next_read_offset_params *params = args;
     struct wg_parser *parser = get_parser(params->parser);
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
 
     while (parser->sink_connected && !parser->read_request.size)
-        pthread_cond_wait(&parser->read_cond, &parser->mutex);
+        pi_cond_wait(&parser->read_cond, &parser->mutex);
 
     if (!parser->sink_connected)
     {
-        pthread_mutex_unlock(&parser->mutex);
+        pi_mutex_unlock(&parser->mutex);
         return VFW_E_WRONG_STATE;
     }
 
     params->offset = parser->read_request.offset;
     params->size = parser->read_request.size;
 
-    pthread_mutex_unlock(&parser->mutex);
+    pi_mutex_unlock(&parser->mutex);
     return S_OK;
 }
 
@@ -182,7 +182,7 @@ static NTSTATUS wg_parser_push_data(void
     const void *data = params->data;
     uint32_t size = params->size;
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
 
     if (data)
     {
@@ -212,8 +212,8 @@ static NTSTATUS wg_parser_push_data(void
     parser->read_request.done = true;
     parser->read_request.size = 0;
 
-    pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&parser->read_done_cond);
+    pi_mutex_unlock(&parser->mutex);
+    pi_cond_signal(&parser->read_done_cond, &parser->mutex);
 
     return S_OK;
 }
@@ -244,12 +244,12 @@ static NTSTATUS wg_parser_stream_enable(
     const struct wg_format *format = params->format;
     struct wg_parser *parser = stream->parser;
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
 
     stream->current_format = *format;
     stream->enabled = true;
 
-    pthread_mutex_unlock(&parser->mutex);
+    pi_mutex_unlock(&parser->mutex);
 
     if (format->major_type == WG_MAJOR_TYPE_VIDEO)
     {
@@ -267,11 +267,11 @@ static NTSTATUS wg_parser_stream_disable
     struct wg_parser_stream *stream = get_stream(*(wg_parser_stream_t *)args);
     struct wg_parser *parser = stream->parser;
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
     stream->enabled = false;
     stream->current_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
-    pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&stream->event_empty_cond);
+    pi_mutex_unlock(&parser->mutex);
+    pi_cond_signal(&stream->event_empty_cond, &parser->mutex);
     return S_OK;
 }
 
@@ -283,7 +283,7 @@ static GstBuffer *wait_parser_stream_buf
      * must return the buffer. */
 
     while (stream->enabled && !(buffer = stream->buffer) && !stream->eos)
-        pthread_cond_wait(&stream->event_cond, &parser->mutex);
+        pi_cond_wait(&stream->event_cond, &parser->mutex);
 
     return buffer;
 }
@@ -297,7 +297,7 @@ static NTSTATUS wg_parser_stream_get_buf
     GstBuffer *buffer;
     unsigned int i;
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
 
     if (stream)
         buffer = wait_parser_stream_buffer(parser, stream);
@@ -337,7 +337,7 @@ static NTSTATUS wg_parser_stream_get_buf
 
     if (!buffer)
     {
-        pthread_mutex_unlock(&parser->mutex);
+        pi_mutex_unlock(&parser->mutex);
         return S_FALSE;
     }
 
@@ -356,7 +356,7 @@ static NTSTATUS wg_parser_stream_get_buf
     wg_buffer->size = gst_buffer_get_size(buffer);
     wg_buffer->stream = stream->number;
 
-    pthread_mutex_unlock(&parser->mutex);
+    pi_mutex_unlock(&parser->mutex);
     return S_OK;
 }
 
@@ -368,11 +368,11 @@ static NTSTATUS wg_parser_stream_copy_bu
     uint32_t offset = params->offset;
     uint32_t size = params->size;
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
 
     if (!stream->buffer)
     {
-        pthread_mutex_unlock(&parser->mutex);
+        pi_mutex_unlock(&parser->mutex);
         return VFW_E_WRONG_STATE;
     }
 
@@ -380,7 +380,7 @@ static NTSTATUS wg_parser_stream_copy_bu
     assert(offset + size <= stream->map_info.size);
     memcpy(params->data, stream->map_info.data + offset, size);
 
-    pthread_mutex_unlock(&parser->mutex);
+    pi_mutex_unlock(&parser->mutex);
     return S_OK;
 }
 
@@ -389,7 +389,7 @@ static NTSTATUS wg_parser_stream_release
     struct wg_parser_stream *stream = get_stream(*(wg_parser_stream_t *)args);
     struct wg_parser *parser = stream->parser;
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
 
     assert(stream->buffer);
 
@@ -397,8 +397,8 @@ static NTSTATUS wg_parser_stream_release
     gst_buffer_unref(stream->buffer);
     stream->buffer = NULL;
 
-    pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&stream->event_empty_cond);
+    pi_mutex_unlock(&parser->mutex);
+    pi_cond_signal(&stream->event_empty_cond, &parser->mutex);
 
     return S_OK;
 }
@@ -539,10 +539,10 @@ static void no_more_pads_cb(GstElement *
 
     GST_DEBUG("parser %p.", parser);
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
     parser->no_more_pads = true;
-    pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&parser->init_cond);
+    pi_mutex_unlock(&parser->mutex);
+    pi_cond_signal(&parser->init_cond, &parser->mutex);
 }
 
 static gboolean sink_event_cb(GstPad *pad, GstObject *parent, GstEvent *event)
@@ -555,7 +555,7 @@ static gboolean sink_event_cb(GstPad *pa
     switch (event->type)
     {
         case GST_EVENT_SEGMENT:
-            pthread_mutex_lock(&parser->mutex);
+            pi_mutex_lock(&parser->mutex);
             if (stream->enabled)
             {
                 const GstSegment *segment;
@@ -564,33 +564,33 @@ static gboolean sink_event_cb(GstPad *pa
 
                 if (segment->format != GST_FORMAT_TIME)
                 {
-                    pthread_mutex_unlock(&parser->mutex);
+                    pi_mutex_unlock(&parser->mutex);
                     GST_FIXME("Unhandled format \"%s\".", gst_format_get_name(segment->format));
                     break;
                 }
 
                 gst_segment_copy_into(segment, &stream->segment);
             }
-            pthread_mutex_unlock(&parser->mutex);
+            pi_mutex_unlock(&parser->mutex);
             break;
 
         case GST_EVENT_EOS:
-            pthread_mutex_lock(&parser->mutex);
+            pi_mutex_lock(&parser->mutex);
             stream->eos = true;
             if (stream->enabled)
-                pthread_cond_signal(&stream->event_cond);
+                pi_cond_signal(&stream->event_cond, &parser->mutex);
             else
-                pthread_cond_signal(&parser->init_cond);
-            pthread_mutex_unlock(&parser->mutex);
+                pi_cond_signal(&parser->init_cond, &parser->mutex);
+            pi_mutex_unlock(&parser->mutex);
             break;
 
         case GST_EVENT_FLUSH_START:
-            pthread_mutex_lock(&parser->mutex);
+            pi_mutex_lock(&parser->mutex);
 
             if (stream->enabled)
             {
                 stream->flushing = true;
-                pthread_cond_signal(&stream->event_empty_cond);
+                pi_cond_signal(&stream->event_empty_cond, &parser->mutex);
 
                 if (stream->buffer)
                 {
@@ -600,7 +600,7 @@ static gboolean sink_event_cb(GstPad *pa
                 }
             }
 
-            pthread_mutex_unlock(&parser->mutex);
+            pi_mutex_unlock(&parser->mutex);
             break;
 
         case GST_EVENT_FLUSH_STOP:
@@ -612,13 +612,13 @@ static gboolean sink_event_cb(GstPad *pa
             if (reset_time)
                 gst_segment_init(&stream->segment, GST_FORMAT_UNDEFINED);
 
-            pthread_mutex_lock(&parser->mutex);
+            pi_mutex_lock(&parser->mutex);
 
             stream->eos = false;
             if (stream->enabled)
                 stream->flushing = false;
 
-            pthread_mutex_unlock(&parser->mutex);
+            pi_mutex_unlock(&parser->mutex);
             break;
         }
 
@@ -627,19 +627,19 @@ static gboolean sink_event_cb(GstPad *pa
             GstCaps *caps;
 
             gst_event_parse_caps(event, &caps);
-            pthread_mutex_lock(&parser->mutex);
+            pi_mutex_lock(&parser->mutex);
             wg_format_from_caps(&stream->preferred_format, caps);
             stream->has_caps = true;
-            pthread_mutex_unlock(&parser->mutex);
-            pthread_cond_signal(&parser->init_cond);
+            pi_mutex_unlock(&parser->mutex);
+            pi_cond_signal(&parser->init_cond, &parser->mutex);
             break;
         }
 
         case GST_EVENT_TAG:
-            pthread_mutex_lock(&parser->mutex);
+            pi_mutex_lock(&parser->mutex);
             stream->has_tags = true;
-            pthread_cond_signal(&parser->init_cond);
-            pthread_mutex_unlock(&parser->mutex);
+            pi_cond_signal(&parser->init_cond, &parser->mutex);
+            pi_mutex_unlock(&parser->mutex);
             break;
 
         default:
@@ -656,30 +656,30 @@ static GstFlowReturn sink_chain_cb(GstPa
 
     GST_LOG("stream %p, buffer %p.", stream, buffer);
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
 
     if (!stream->has_buffer)
     {
         stream->has_buffer = true;
-        pthread_cond_signal(&parser->init_cond);
+        pi_cond_signal(&parser->init_cond, &parser->mutex);
     }
 
     /* Allow this buffer to be flushed by GStreamer. We are effectively
      * implementing a queue object here. */
 
     while (stream->enabled && !stream->flushing && stream->buffer)
-        pthread_cond_wait(&stream->event_empty_cond, &parser->mutex);
+        pi_cond_wait(&stream->event_empty_cond, &parser->mutex);
 
     if (!stream->enabled)
     {
-        pthread_mutex_unlock(&parser->mutex);
+        pi_mutex_unlock(&parser->mutex);
         gst_buffer_unref(buffer);
         return GST_FLOW_OK;
     }
 
     if (stream->flushing)
     {
-        pthread_mutex_unlock(&parser->mutex);
+        pi_mutex_unlock(&parser->mutex);
         GST_DEBUG("Stream is flushing; discarding buffer.");
         gst_buffer_unref(buffer);
         return GST_FLOW_FLUSHING;
@@ -687,7 +687,7 @@ static GstFlowReturn sink_chain_cb(GstPa
 
     if (!gst_buffer_map(buffer, &stream->map_info, GST_MAP_READ))
     {
-        pthread_mutex_unlock(&parser->mutex);
+        pi_mutex_unlock(&parser->mutex);
         GST_ERROR("Failed to map buffer.\n");
         gst_buffer_unref(buffer);
         return GST_FLOW_ERROR;
@@ -695,8 +695,8 @@ static GstFlowReturn sink_chain_cb(GstPa
 
     stream->buffer = buffer;
 
-    pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&stream->event_cond);
+    pi_mutex_unlock(&parser->mutex);
+    pi_cond_signal(&stream->event_cond, &parser->mutex);
 
     /* The chain callback is given a reference to the buffer. Transfer that
      * reference to the stream object, which will release it in
@@ -723,9 +723,9 @@ static gboolean sink_query_cb(GstPad *pa
 
             gst_query_parse_caps(query, &filter);
 
-            pthread_mutex_lock(&parser->mutex);
+            pi_mutex_lock(&parser->mutex);
             caps = wg_format_to_caps(&stream->current_format);
-            pthread_mutex_unlock(&parser->mutex);
+            pi_mutex_unlock(&parser->mutex);
 
             if (!caps)
                 return FALSE;
@@ -757,11 +757,11 @@ static gboolean sink_query_cb(GstPad *pa
             gboolean ret = TRUE;
             GstCaps *caps;
 
-            pthread_mutex_lock(&parser->mutex);
+            pi_mutex_lock(&parser->mutex);
 
             if (stream->current_format.major_type == WG_MAJOR_TYPE_UNKNOWN)
             {
-                pthread_mutex_unlock(&parser->mutex);
+                pi_mutex_unlock(&parser->mutex);
                 gst_query_set_accept_caps_result(query, TRUE);
                 return TRUE;
             }
@@ -770,7 +770,7 @@ static gboolean sink_query_cb(GstPad *pa
             wg_format_from_caps(&format, caps);
             ret = wg_format_compare(&format, &stream->current_format);
 
-            pthread_mutex_unlock(&parser->mutex);
+            pi_mutex_unlock(&parser->mutex);
 
             if (!ret && gst_debug_category_get_threshold(GST_CAT_DEFAULT) >= GST_LEVEL_WARNING)
             {
@@ -805,8 +805,8 @@ static struct wg_parser_stream *create_s
     stream->number = parser->stream_count;
     stream->no_more_pads = true;
     stream->current_format.major_type = WG_MAJOR_TYPE_UNKNOWN;
-    pthread_cond_init(&stream->event_cond, NULL);
-    pthread_cond_init(&stream->event_empty_cond, NULL);
+    pi_cond_init(&stream->event_cond, 0);
+    pi_cond_init(&stream->event_empty_cond, 0);
 
     sprintf(pad_name, "qz_sink_%u", parser->stream_count);
     stream->my_sink = gst_pad_new(pad_name, GST_PAD_SINK);
@@ -832,8 +832,8 @@ static void free_stream(struct wg_parser
         stream->buffer = NULL;
     }
 
-    pthread_cond_destroy(&stream->event_cond);
-    pthread_cond_destroy(&stream->event_empty_cond);
+    pi_cond_destroy(&stream->event_cond);
+    pi_cond_destroy(&stream->event_empty_cond);
 
     for (i = 0; i < ARRAY_SIZE(stream->tags); ++i)
     {
@@ -915,10 +915,10 @@ static void stream_decodebin_no_more_pad
 
     GST_DEBUG("stream %p, parser %p, element %p.", stream, parser, element);
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
     stream->no_more_pads = true;
-    pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&parser->init_cond);
+    pi_mutex_unlock(&parser->mutex);
+    pi_cond_signal(&parser->init_cond, &parser->mutex);
 }
 
 static void stream_decodebin_pad_added_cb(GstElement *element, GstPad *pad, gpointer user)
@@ -950,9 +950,9 @@ static bool stream_decodebin_create(stru
     g_signal_connect(stream->decodebin, "autoplug-select", G_CALLBACK(autoplug_select_cb), stream);
     g_signal_connect(stream->decodebin, "no-more-pads", G_CALLBACK(stream_decodebin_no_more_pads_cb), stream);
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
     stream->no_more_pads = false;
-    pthread_mutex_unlock(&parser->mutex);
+    pi_mutex_unlock(&parser->mutex);
     gst_element_sync_state_with_parent(stream->decodebin);
 
     GST_LOG("Created stream decodebin %p for %u.", stream->decodebin, stream->number);
@@ -1044,26 +1044,26 @@ static GstFlowReturn issue_read_request(
 {
     GstFlowReturn ret;
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
 
     assert(!parser->read_request.size);
     parser->read_request.buffer = *buffer;
     parser->read_request.offset = offset;
     parser->read_request.size = size;
     parser->read_request.done = false;
-    pthread_cond_signal(&parser->read_cond);
+    pi_cond_signal(&parser->read_cond, &parser->mutex);
 
     /* Note that we don't unblock this wait on GST_EVENT_FLUSH_START. We expect
      * the upstream pin to flush if necessary. We should never be blocked on
      * read_thread() not running. */
 
     while (!parser->read_request.done)
-        pthread_cond_wait(&parser->read_done_cond, &parser->mutex);
+        pi_cond_wait(&parser->read_done_cond, &parser->mutex);
 
     *buffer = parser->read_request.buffer;
     ret = parser->read_request.ret;
 
-    pthread_mutex_unlock(&parser->mutex);
+    pi_mutex_unlock(&parser->mutex);
 
     GST_LOG("Request returned %s.", gst_flow_get_name(ret));
 
@@ -1363,10 +1363,10 @@ static GstBusSyncReply bus_handler_cb(Gs
         }
         g_error_free(err);
         g_free(dbg_info);
-        pthread_mutex_lock(&parser->mutex);
+        pi_mutex_lock(&parser->mutex);
         parser->error = true;
-        pthread_mutex_unlock(&parser->mutex);
-        pthread_cond_signal(&parser->init_cond);
+        pi_mutex_unlock(&parser->mutex);
+        pi_cond_signal(&parser->init_cond, &parser->mutex);
         break;
 
     case GST_MESSAGE_WARNING:
@@ -1381,10 +1381,10 @@ static GstBusSyncReply bus_handler_cb(Gs
         break;
 
     case GST_MESSAGE_DURATION_CHANGED:
-        pthread_mutex_lock(&parser->mutex);
+        pi_mutex_lock(&parser->mutex);
         parser->has_duration = true;
-        pthread_mutex_unlock(&parser->mutex);
-        pthread_cond_signal(&parser->init_cond);
+        pi_mutex_unlock(&parser->mutex);
+        pi_cond_signal(&parser->init_cond, &parser->mutex);
         break;
 
     default:
@@ -1585,13 +1585,13 @@ static NTSTATUS wg_parser_connect(void *
         goto out;
     }
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
 
     while (!parser_no_more_pads(parser) && !parser->error)
-        pthread_cond_wait(&parser->init_cond, &parser->mutex);
+        pi_cond_wait(&parser->init_cond, &parser->mutex);
     if (parser->error)
     {
-        pthread_mutex_unlock(&parser->mutex);
+        pi_mutex_unlock(&parser->mutex);
         goto out;
     }
 
@@ -1602,7 +1602,7 @@ static NTSTATUS wg_parser_connect(void *
 
         /* If we received a buffer, waiting for tags or caps does not make sense anymore. */
         while ((!stream->has_caps || !stream->has_tags) && !parser->error && !stream->has_buffer)
-            pthread_cond_wait(&parser->init_cond, &parser->mutex);
+            pi_cond_wait(&parser->init_cond, &parser->mutex);
 
         /* GStreamer doesn't actually provide any guarantees about when duration
          * is available, even for seekable streams. It's basically built for
@@ -1632,7 +1632,7 @@ static NTSTATUS wg_parser_connect(void *
         {
             if (parser->error)
             {
-                pthread_mutex_unlock(&parser->mutex);
+                pi_mutex_unlock(&parser->mutex);
                 goto out;
             }
             if (gst_pad_peer_query_duration(stream->my_sink, GST_FORMAT_TIME, &duration))
@@ -1655,13 +1655,13 @@ static NTSTATUS wg_parser_connect(void *
              * the query succeeds. */
             if (parser->has_duration)
             {
-                pthread_mutex_unlock(&parser->mutex);
+                pi_mutex_unlock(&parser->mutex);
                 g_usleep(10000);
-                pthread_mutex_lock(&parser->mutex);
+                pi_mutex_lock(&parser->mutex);
             }
             else
             {
-                pthread_cond_wait(&parser->init_cond, &parser->mutex);
+                pi_cond_wait(&parser->init_cond, &parser->mutex);
             }
         }
 
@@ -1675,7 +1675,7 @@ static NTSTATUS wg_parser_connect(void *
         stream->enabled = true;
     }
 
-    pthread_mutex_unlock(&parser->mutex);
+    pi_mutex_unlock(&parser->mutex);
 
     parser->next_offset = 0;
     return S_OK;
@@ -1702,10 +1702,10 @@ out:
     g_free(parser->sink_caps);
     parser->sink_caps = NULL;
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
     parser->sink_connected = false;
-    pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&parser->read_cond);
+    pi_mutex_unlock(&parser->mutex);
+    pi_cond_signal(&parser->read_cond, &parser->mutex);
 
     return E_FAIL;
 }
@@ -1716,22 +1716,22 @@ static NTSTATUS wg_parser_disconnect(voi
     unsigned int i;
 
     /* Unblock all of our streams. */
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
     for (i = 0; i < parser->stream_count; ++i)
     {
         parser->streams[i]->flushing = true;
-        pthread_cond_signal(&parser->streams[i]->event_empty_cond);
+        pi_cond_signal(&parser->streams[i]->event_empty_cond, &parser->mutex);
     }
-    pthread_mutex_unlock(&parser->mutex);
+    pi_mutex_unlock(&parser->mutex);
 
     gst_element_set_state(parser->container, GST_STATE_NULL);
     gst_object_unref(parser->my_src);
     parser->my_src = NULL;
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
     parser->sink_connected = false;
-    pthread_mutex_unlock(&parser->mutex);
-    pthread_cond_signal(&parser->read_cond);
+    pi_mutex_unlock(&parser->mutex);
+    pi_cond_signal(&parser->read_cond, &parser->mutex);
 
     for (i = 0; i < parser->stream_count; ++i)
         free_stream(parser->streams[i]);
@@ -1775,9 +1775,9 @@ static BOOL decodebin_parser_init_gst(st
     g_signal_connect(element, "autoplug-select", G_CALLBACK(autoplug_select_cb), parser);
     g_signal_connect(element, "no-more-pads", G_CALLBACK(no_more_pads_cb), parser);
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
     parser->no_more_pads = false;
-    pthread_mutex_unlock(&parser->mutex);
+    pi_mutex_unlock(&parser->mutex);
 
     if (!link_src_to_element(parser->my_src, element))
         return FALSE;
@@ -1798,9 +1798,9 @@ static BOOL avi_parser_init_gst(struct w
     g_signal_connect(element, "pad-removed", G_CALLBACK(pad_removed_cb), parser);
     g_signal_connect(element, "no-more-pads", G_CALLBACK(no_more_pads_cb), parser);
 
-    pthread_mutex_lock(&parser->mutex);
+    pi_mutex_lock(&parser->mutex);
     parser->no_more_pads = false;
-    pthread_mutex_unlock(&parser->mutex);
+    pi_mutex_unlock(&parser->mutex);
 
     if (!link_src_to_element(parser->my_src, element))
         return FALSE;
@@ -1874,10 +1874,10 @@ static NTSTATUS wg_parser_create(void *a
     if (!(parser = calloc(1, sizeof(*parser))))
         return E_OUTOFMEMORY;
 
-    pthread_mutex_init(&parser->mutex, NULL);
-    pthread_cond_init(&parser->init_cond, NULL);
-    pthread_cond_init(&parser->read_cond, NULL);
-    pthread_cond_init(&parser->read_done_cond, NULL);
+    pi_mutex_init(&parser->mutex, 0);
+    pi_cond_init(&parser->init_cond, 0);
+    pi_cond_init(&parser->read_cond, 0);
+    pi_cond_init(&parser->read_done_cond, 0);
     parser->init_gst = init_funcs[params->type];
     parser->err_on = params->err_on;
     parser->warn_on = params->warn_on;
@@ -1896,10 +1896,10 @@ static NTSTATUS wg_parser_destroy(void *
         gst_object_unref(parser->bus);
     }
 
-    pthread_mutex_destroy(&parser->mutex);
-    pthread_cond_destroy(&parser->init_cond);
-    pthread_cond_destroy(&parser->read_cond);
-    pthread_cond_destroy(&parser->read_done_cond);
+    pi_mutex_destroy(&parser->mutex);
+    pi_cond_destroy(&parser->init_cond);
+    pi_cond_destroy(&parser->read_cond);
+    pi_cond_destroy(&parser->read_done_cond);
 
     free(parser);
     return S_OK;
diff -Npur a/dlls/winemac.drv/cocoa_window.h b/dlls/winemac.drv/cocoa_window.h
--- a/dlls/winemac.drv/cocoa_window.h	2024-05-01 15:46:47.294975478 -0500
+++ b/dlls/winemac.drv/cocoa_window.h	2024-05-01 15:50:03.075914256 -0500
@@ -45,7 +45,7 @@
     WineEventQueue* queue;
 
     void* surface;
-    pthread_mutex_t* surface_mutex;
+    pi_mutex_t* surface_mutex;
 
     CGDirectDisplayID _lastDisplayID;
     NSTimeInterval _lastDisplayTime;
diff -Npur a/dlls/winemac.drv/gdi.c b/dlls/winemac.drv/gdi.c
--- a/dlls/winemac.drv/gdi.c	2024-05-01 15:46:47.296975487 -0500
+++ b/dlls/winemac.drv/gdi.c	2024-05-01 15:50:03.073914247 -0500
@@ -51,7 +51,7 @@ static int device_data_valid;   /* do th
 
 int retina_on = FALSE;
 
-static pthread_mutex_t device_data_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t device_data_mutex = PI_MUTEX_INIT(0);
 
 static const struct user_driver_funcs macdrv_funcs;
 
@@ -86,7 +86,7 @@ CGRect macdrv_get_desktop_rect(void)
 {
     CGRect ret;
 
-    pthread_mutex_lock(&device_data_mutex);
+    pi_mutex_lock(&device_data_mutex);
 
     if (!device_data_valid)
     {
@@ -95,7 +95,7 @@ CGRect macdrv_get_desktop_rect(void)
     }
     ret = desktop_rect;
 
-    pthread_mutex_unlock(&device_data_mutex);
+    pi_mutex_unlock(&device_data_mutex);
 
     TRACE("%s\n", wine_dbgstr_cgrect(ret));
 
@@ -147,9 +147,9 @@ static void device_init(void)
 
 void macdrv_reset_device_metrics(void)
 {
-    pthread_mutex_lock(&device_data_mutex);
+    pi_mutex_lock(&device_data_mutex);
     device_data_valid = FALSE;
-    pthread_mutex_unlock(&device_data_mutex);
+    pi_mutex_unlock(&device_data_mutex);
 }
 
 
@@ -157,9 +157,9 @@ static MACDRV_PDEVICE *create_mac_physde
 {
     MACDRV_PDEVICE *physDev;
 
-    pthread_mutex_lock(&device_data_mutex);
+    pi_mutex_lock(&device_data_mutex);
     if (!device_data_valid) device_init();
-    pthread_mutex_unlock(&device_data_mutex);
+    pi_mutex_unlock(&device_data_mutex);
 
     if (!(physDev = calloc(1, sizeof(*physDev)))) return NULL;
 
@@ -222,7 +222,7 @@ static INT macdrv_GetDeviceCaps(PHYSDEV
 {
     INT ret;
 
-    pthread_mutex_lock(&device_data_mutex);
+    pi_mutex_lock(&device_data_mutex);
 
     if (!device_data_valid) device_init();
 
@@ -240,7 +240,7 @@ static INT macdrv_GetDeviceCaps(PHYSDEV
     case HORZRES:
     case VERTRES:
     default:
-        pthread_mutex_unlock(&device_data_mutex);
+        pi_mutex_unlock(&device_data_mutex);
         dev = GET_NEXT_PHYSDEV( dev, pGetDeviceCaps );
         ret = dev->funcs->pGetDeviceCaps( dev, cap );
         if ((cap == HORZRES || cap == VERTRES) && retina_on)
@@ -250,7 +250,7 @@ static INT macdrv_GetDeviceCaps(PHYSDEV
 
     TRACE("cap %d -> %d\n", cap, ret);
 
-    pthread_mutex_unlock(&device_data_mutex);
+    pi_mutex_unlock(&device_data_mutex);
     return ret;
 }
 
diff -Npur a/dlls/winemac.drv/keyboard.c b/dlls/winemac.drv/keyboard.c
--- a/dlls/winemac.drv/keyboard.c	2024-05-01 15:47:09.586085838 -0500
+++ b/dlls/winemac.drv/keyboard.c	2024-05-01 15:50:03.077914266 -0500
@@ -440,7 +440,7 @@ struct layout
     BOOL enabled; /* is the input source enabled - ie displayed in the input source selector UI */
 };
 
-static pthread_mutex_t layout_list_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t layout_list_mutex = PI_MUTEX_INIT(0);
 
 int macdrv_layout_list_needs_update = TRUE;
 
@@ -637,13 +637,13 @@ HKL macdrv_get_hkl_from_source(TISInputS
     struct layout *layout;
     HKL ret = 0;
 
-    pthread_mutex_lock(&layout_list_mutex);
+    pi_mutex_lock(&layout_list_mutex);
 
     update_layout_list();
     layout = get_layout_from_source(input);
     if (layout) ret = layout->hkl;
 
-    pthread_mutex_unlock(&layout_list_mutex);
+    pi_mutex_unlock(&layout_list_mutex);
 
     return ret;
 }
@@ -1260,7 +1260,7 @@ BOOL macdrv_ActivateKeyboardLayout(HKL h
     if (hkl == thread_data->active_keyboard_layout)
         return TRUE;
 
-    pthread_mutex_lock(&layout_list_mutex);
+    pi_mutex_lock(&layout_list_mutex);
     update_layout_list();
 
     LIST_FOR_EACH_ENTRY(layout, &layout_list, struct layout, entry)
@@ -1283,7 +1283,7 @@ BOOL macdrv_ActivateKeyboardLayout(HKL h
             break;
         }
     }
-    pthread_mutex_unlock(&layout_list_mutex);
+    pi_mutex_unlock(&layout_list_mutex);
 
     return ret;
 }
@@ -1397,7 +1397,7 @@ UINT macdrv_GetKeyboardLayoutList(INT si
 
     TRACE("%d, %p\n", size, list);
 
-    pthread_mutex_lock(&layout_list_mutex);
+    pi_mutex_lock(&layout_list_mutex);
 
     update_layout_list();
 
@@ -1412,7 +1412,7 @@ UINT macdrv_GetKeyboardLayoutList(INT si
         }
         count++;
     }
-    pthread_mutex_unlock(&layout_list_mutex);
+    pi_mutex_unlock(&layout_list_mutex);
 
     TRACE("returning %d\n", count);
     return count;
diff -Npur a/dlls/winemac.drv/macdrv_cocoa.h b/dlls/winemac.drv/macdrv_cocoa.h
--- a/dlls/winemac.drv/macdrv_cocoa.h	2024-05-01 15:46:47.297975492 -0500
+++ b/dlls/winemac.drv/macdrv_cocoa.h	2024-05-01 15:50:03.077914266 -0500
@@ -85,6 +85,7 @@
 #undef UnionRect
 
 #include <pthread.h>
+#include <rtpi.h>
 
 
 #ifndef DECLSPEC_HIDDEN
@@ -565,7 +566,7 @@ extern void macdrv_hide_cocoa_window(mac
 extern void macdrv_set_cocoa_window_frame(macdrv_window w, const CGRect* new_frame) DECLSPEC_HIDDEN;
 extern void macdrv_get_cocoa_window_frame(macdrv_window w, CGRect* out_frame) DECLSPEC_HIDDEN;
 extern void macdrv_set_cocoa_parent_window(macdrv_window w, macdrv_window parent) DECLSPEC_HIDDEN;
-extern void macdrv_set_window_surface(macdrv_window w, void *surface, pthread_mutex_t *mutex) DECLSPEC_HIDDEN;
+extern void macdrv_set_window_surface(macdrv_window w, void *surface, pi_mutex_t *mutex) DECLSPEC_HIDDEN;
 extern CGImageRef create_surface_image(void *window_surface, CGRect *rect, int copy_data, int color_keyed,
         CGFloat key_red, CGFloat key_green, CGFloat key_blue) DECLSPEC_HIDDEN;
 extern int get_surface_blit_rects(void *window_surface, const CGRect **rects, int *count) DECLSPEC_HIDDEN;
diff -Npur a/dlls/winemac.drv/mouse.c b/dlls/winemac.drv/mouse.c
--- a/dlls/winemac.drv/mouse.c	2024-05-01 15:47:09.586085838 -0500
+++ b/dlls/winemac.drv/mouse.c	2024-05-01 15:50:03.078914270 -0500
@@ -33,7 +33,7 @@
 WINE_DEFAULT_DEBUG_CHANNEL(cursor);
 
 
-static pthread_mutex_t cursor_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t cursor_cache_mutex = PI_MUTEX_INIT(0);
 static CFMutableDictionaryRef cursor_cache;
 
 
@@ -648,10 +648,10 @@ void macdrv_DestroyCursorIcon(HCURSOR cu
 {
     TRACE("cursor %p\n", cursor);
 
-    pthread_mutex_lock(&cursor_cache_mutex);
+    pi_mutex_lock(&cursor_cache_mutex);
     if (cursor_cache)
         CFDictionaryRemoveValue(cursor_cache, cursor);
-    pthread_mutex_unlock(&cursor_cache_mutex);
+    pi_mutex_unlock(&cursor_cache_mutex);
 }
 
 
@@ -756,7 +756,7 @@ void macdrv_SetCursor(HWND hwnd, HCURSOR
     {
         ICONINFOEXW info;
 
-        pthread_mutex_lock(&cursor_cache_mutex);
+        pi_mutex_lock(&cursor_cache_mutex);
         if (cursor_cache)
         {
             CFTypeRef cached_cursor = CFDictionaryGetValue(cursor_cache, cursor);
@@ -768,7 +768,7 @@ void macdrv_SetCursor(HWND hwnd, HCURSOR
                     cursor_frames = CFRetain(cached_cursor);
             }
         }
-        pthread_mutex_unlock(&cursor_cache_mutex);
+        pi_mutex_unlock(&cursor_cache_mutex);
         if (cursor_name || cursor_frames)
             goto done;
 
@@ -815,13 +815,13 @@ void macdrv_SetCursor(HWND hwnd, HCURSOR
 
         if (cursor_name || cursor_frames)
         {
-            pthread_mutex_lock(&cursor_cache_mutex);
+            pi_mutex_lock(&cursor_cache_mutex);
             if (!cursor_cache)
                 cursor_cache = CFDictionaryCreateMutable(NULL, 0, NULL,
                                                          &kCFTypeDictionaryValueCallBacks);
             CFDictionarySetValue(cursor_cache, cursor,
                                  cursor_name ? (CFTypeRef)cursor_name : (CFTypeRef)cursor_frames);
-            pthread_mutex_unlock(&cursor_cache_mutex);
+            pi_mutex_unlock(&cursor_cache_mutex);
         }
         else
             cursor_name = CFRetain(CFSTR("arrowCursor"));
diff -Npur a/dlls/winemac.drv/opengl.c b/dlls/winemac.drv/opengl.c
--- a/dlls/winemac.drv/opengl.c	2024-05-01 15:47:10.154088637 -0500
+++ b/dlls/winemac.drv/opengl.c	2024-05-01 15:50:03.076914261 -0500
@@ -81,7 +81,7 @@ struct wgl_context
 };
 
 static struct list context_list = LIST_INIT(context_list);
-static pthread_mutex_t context_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t context_mutex = PI_MUTEX_INIT(0);
 
 
 struct wgl_pbuffer
@@ -95,7 +95,7 @@ struct wgl_pbuffer
 };
 
 static CFMutableDictionaryRef dc_pbuffers;
-static pthread_mutex_t dc_pbuffers_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t dc_pbuffers_mutex = PI_MUTEX_INIT(0);
 
 
 static struct opengl_funcs opengl_funcs;
@@ -1350,7 +1350,7 @@ static int get_dc_pixel_format(HWND hwnd
     {
         struct wgl_pbuffer *pbuffer;
 
-        pthread_mutex_lock(&dc_pbuffers_mutex);
+        pi_mutex_lock(&dc_pbuffers_mutex);
         pbuffer = (struct wgl_pbuffer*)CFDictionaryGetValue(dc_pbuffers, hdc);
         if (pbuffer)
             format = pbuffer->format;
@@ -1359,7 +1359,7 @@ static int get_dc_pixel_format(HWND hwnd
             WARN("no window or pbuffer for DC %p\n", hdc);
             format = 0;
         }
-        pthread_mutex_unlock(&dc_pbuffers_mutex);
+        pi_mutex_unlock(&dc_pbuffers_mutex);
     }
 
     return format;
@@ -1603,13 +1603,13 @@ static void mark_contexts_for_moved_view
 {
     struct wgl_context *context;
 
-    pthread_mutex_lock(&context_mutex);
+    pi_mutex_lock(&context_mutex);
     LIST_FOR_EACH_ENTRY(context, &context_list, struct wgl_context, entry)
     {
         if (context->draw_view == view)
             InterlockedExchange(&context->view_moved, TRUE);
     }
-    pthread_mutex_unlock(&context_mutex);
+    pi_mutex_unlock(&context_mutex);
 }
 
 
@@ -2876,9 +2876,9 @@ static struct wgl_context *macdrv_wglCre
         return NULL;
     }
 
-    pthread_mutex_lock(&context_mutex);
+    pi_mutex_lock(&context_mutex);
     list_add_tail(&context_list, &context->entry);
-    pthread_mutex_unlock(&context_mutex);
+    pi_mutex_unlock(&context_mutex);
 
     return context;
 }
@@ -3081,7 +3081,7 @@ static HDC macdrv_wglGetPbufferDCARB(str
     hdc = NtGdiOpenDCW(NULL, NULL, NULL, 0, TRUE, NULL, NULL, NULL);
     if (!hdc) return 0;
 
-    pthread_mutex_lock(&dc_pbuffers_mutex);
+    pi_mutex_lock(&dc_pbuffers_mutex);
     prev = (struct wgl_pbuffer*)CFDictionaryGetValue(dc_pbuffers, hdc);
     if (prev)
     {
@@ -3089,7 +3089,7 @@ static HDC macdrv_wglGetPbufferDCARB(str
         free(prev);
     }
     CFDictionarySetValue(dc_pbuffers, hdc, pbuffer);
-    pthread_mutex_unlock(&dc_pbuffers_mutex);
+    pi_mutex_unlock(&dc_pbuffers_mutex);
 
     TRACE("pbuffer %p -> hdc %p\n", pbuffer, hdc);
     return hdc;
@@ -3529,14 +3529,14 @@ static BOOL macdrv_wglMakeContextCurrent
     {
         struct wgl_pbuffer *pbuffer;
 
-        pthread_mutex_lock(&dc_pbuffers_mutex);
+        pi_mutex_lock(&dc_pbuffers_mutex);
         pbuffer = (struct wgl_pbuffer*)CFDictionaryGetValue(dc_pbuffers, draw_hdc);
         if (pbuffer)
         {
             if (context->format != pbuffer->format)
             {
                 WARN("mismatched pixel format draw_hdc %p %u context %p %u\n", draw_hdc, pbuffer->format, context, context->format);
-                pthread_mutex_unlock(&dc_pbuffers_mutex);
+                pi_mutex_unlock(&dc_pbuffers_mutex);
                 RtlSetLastWin32Error(ERROR_INVALID_PIXEL_FORMAT);
                 return FALSE;
             }
@@ -3547,7 +3547,7 @@ static BOOL macdrv_wglMakeContextCurrent
         else
         {
             WARN("no window or pbuffer for DC\n");
-            pthread_mutex_unlock(&dc_pbuffers_mutex);
+            pi_mutex_unlock(&dc_pbuffers_mutex);
             RtlSetLastWin32Error(ERROR_INVALID_HANDLE);
             return FALSE;
         }
@@ -3555,7 +3555,7 @@ static BOOL macdrv_wglMakeContextCurrent
         context->draw_hwnd = NULL;
         context->draw_view = NULL;
         context->draw_pbuffer = pbuffer;
-        pthread_mutex_unlock(&dc_pbuffers_mutex);
+        pi_mutex_unlock(&dc_pbuffers_mutex);
     }
 
     context->read_view = NULL;
@@ -3577,9 +3577,9 @@ static BOOL macdrv_wglMakeContextCurrent
         }
         else
         {
-            pthread_mutex_lock(&dc_pbuffers_mutex);
+            pi_mutex_lock(&dc_pbuffers_mutex);
             context->read_pbuffer = (struct wgl_pbuffer*)CFDictionaryGetValue(dc_pbuffers, read_hdc);
-            pthread_mutex_unlock(&dc_pbuffers_mutex);
+            pi_mutex_unlock(&dc_pbuffers_mutex);
         }
     }
 
@@ -3924,7 +3924,7 @@ static int macdrv_wglReleasePbufferDCARB
 
     TRACE("pbuffer %p hdc %p\n", pbuffer, hdc);
 
-    pthread_mutex_lock(&dc_pbuffers_mutex);
+    pi_mutex_lock(&dc_pbuffers_mutex);
 
     prev = (struct wgl_pbuffer*)CFDictionaryGetValue(dc_pbuffers, hdc);
     if (prev)
@@ -3937,7 +3937,7 @@ static int macdrv_wglReleasePbufferDCARB
     }
     else hdc = 0;
 
-    pthread_mutex_unlock(&dc_pbuffers_mutex);
+    pi_mutex_unlock(&dc_pbuffers_mutex);
 
     return hdc && NtGdiDeleteObjectApp(hdc);
 }
@@ -4100,13 +4100,13 @@ static BOOL macdrv_wglSwapIntervalEXT(in
     {
         struct wgl_context *ctx;
 
-        pthread_mutex_lock(&context_mutex);
+        pi_mutex_lock(&context_mutex);
         LIST_FOR_EACH_ENTRY(ctx, &context_list, struct wgl_context, entry)
         {
             if (ctx != context && ctx->draw_hwnd == context->draw_hwnd)
                 InterlockedExchange(&context->update_swap_interval, TRUE);
         }
-        pthread_mutex_unlock(&context_mutex);
+        pi_mutex_unlock(&context_mutex);
     }
 
     return TRUE;
@@ -4405,9 +4405,9 @@ static BOOL macdrv_wglDeleteContext(stru
 {
     TRACE("deleting context %p/%p/%p\n", context, context->context, context->cglcontext);
 
-    pthread_mutex_lock(&context_mutex);
+    pi_mutex_lock(&context_mutex);
     list_remove(&context->entry);
-    pthread_mutex_unlock(&context_mutex);
+    pi_mutex_unlock(&context_mutex);
 
     macdrv_dispose_opengl_context(context->context);
     free(context);
@@ -4574,9 +4574,9 @@ static BOOL macdrv_wglSwapBuffers(HDC hd
     {
         struct wgl_pbuffer *pbuffer;
 
-        pthread_mutex_lock(&dc_pbuffers_mutex);
+        pi_mutex_lock(&dc_pbuffers_mutex);
         pbuffer = (struct wgl_pbuffer*)CFDictionaryGetValue(dc_pbuffers, hdc);
-        pthread_mutex_unlock(&dc_pbuffers_mutex);
+        pi_mutex_unlock(&dc_pbuffers_mutex);
 
         if (!pbuffer)
         {
diff -Npur a/dlls/winemac.drv/surface.c b/dlls/winemac.drv/surface.c
--- a/dlls/winemac.drv/surface.c	2024-05-01 15:46:47.299975502 -0500
+++ b/dlls/winemac.drv/surface.c	2024-05-01 15:50:03.074914252 -0500
@@ -70,7 +70,7 @@ struct macdrv_window_surface
     BOOL                    use_alpha;
     RGNDATA                *blit_data;
     BYTE                   *bits;
-    pthread_mutex_t         mutex;
+    pi_mutex_t         mutex;
     BITMAPINFO              info;   /* variable size, must be last */
 };
 
@@ -104,7 +104,7 @@ static void macdrv_surface_lock(struct w
 {
     struct macdrv_window_surface *surface = get_mac_surface(window_surface);
 
-    pthread_mutex_lock(&surface->mutex);
+    pi_mutex_lock(&surface->mutex);
 }
 
 /***********************************************************************
@@ -114,7 +114,7 @@ static void macdrv_surface_unlock(struct
 {
     struct macdrv_window_surface *surface = get_mac_surface(window_surface);
 
-    pthread_mutex_unlock(&surface->mutex);
+    pi_mutex_unlock(&surface->mutex);
 }
 
 /***********************************************************************
@@ -215,7 +215,7 @@ static void macdrv_surface_destroy(struc
     if (surface->drawn) NtGdiDeleteObjectApp(surface->drawn);
     free(surface->blit_data);
     free(surface->bits);
-    pthread_mutex_destroy(&surface->mutex);
+    pi_mutex_destroy(&surface->mutex);
     free(surface);
 }
 
@@ -246,20 +246,16 @@ struct window_surface *create_surface(ma
     struct macdrv_window_surface *old_mac_surface = get_mac_surface(old_surface);
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
     DWORD *colors;
-    pthread_mutexattr_t attr;
     int err;
     DWORD window_background;
 
     surface = calloc(1, FIELD_OFFSET(struct macdrv_window_surface, info.bmiColors[3]));
     if (!surface) return NULL;
 
-    err = pthread_mutexattr_init(&attr);
     if (!err)
     {
-        err = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
         if (!err)
-            err = pthread_mutex_init(&surface->mutex, &attr);
-        pthread_mutexattr_destroy(&attr);
+            err = pi_mutex_init(&surface->mutex, 0);
     }
     if (err)
     {
diff -Npur a/dlls/winemac.drv/window.c b/dlls/winemac.drv/window.c
--- a/dlls/winemac.drv/window.c	2024-05-01 15:46:47.300975507 -0500
+++ b/dlls/winemac.drv/window.c	2024-05-01 15:50:03.078914270 -0500
@@ -40,7 +40,7 @@
 WINE_DEFAULT_DEBUG_CHANNEL(macdrv);
 
 
-static pthread_mutex_t win_data_mutex;
+static pi_mutex_t win_data_mutex;
 static CFMutableDictionaryRef win_datas;
 
 static unsigned int activate_on_focus_time;
@@ -251,7 +251,7 @@ static struct macdrv_win_data *alloc_win
         data->hwnd = hwnd;
         data->color_key = CLR_INVALID;
         data->swap_interval = 1;
-        pthread_mutex_lock(&win_data_mutex);
+        pi_mutex_lock(&win_data_mutex);
         if (!win_datas)
             win_datas = CFDictionaryCreateMutable(NULL, 0, NULL, NULL);
         CFDictionarySetValue(win_datas, hwnd, data);
@@ -270,10 +270,10 @@ struct macdrv_win_data *get_win_data(HWN
     struct macdrv_win_data *data;
 
     if (!hwnd) return NULL;
-    pthread_mutex_lock(&win_data_mutex);
+    pi_mutex_lock(&win_data_mutex);
     if (win_datas && (data = (struct macdrv_win_data*)CFDictionaryGetValue(win_datas, hwnd)))
         return data;
-    pthread_mutex_unlock(&win_data_mutex);
+    pi_mutex_unlock(&win_data_mutex);
     return NULL;
 }
 
@@ -285,7 +285,7 @@ struct macdrv_win_data *get_win_data(HWN
  */
 void release_win_data(struct macdrv_win_data *data)
 {
-    if (data) pthread_mutex_unlock(&win_data_mutex);
+    if (data) pi_mutex_unlock(&win_data_mutex);
 }
 
 
@@ -2756,10 +2756,6 @@ BOOL query_min_max_info(HWND hwnd)
  */
 void init_win_context(void)
 {
-    pthread_mutexattr_t attr;
 
-    pthread_mutexattr_init(&attr);
-    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
-    pthread_mutex_init(&win_data_mutex, &attr);
-    pthread_mutexattr_destroy(&attr);
+    pi_mutex_init(&win_data_mutex, 0);
 }
diff -Npur a/dlls/wineoss.drv/Makefile.in b/dlls/wineoss.drv/Makefile.in
--- a/dlls/wineoss.drv/Makefile.in	2024-05-01 15:46:47.300975507 -0500
+++ b/dlls/wineoss.drv/Makefile.in	2024-05-01 15:50:04.417920479 -0500
@@ -2,7 +2,7 @@ MODULE    = wineoss.drv
 UNIXLIB   = wineoss.so
 IMPORTS   = uuid ole32 user32 advapi32
 DELAYIMPORTS = winmm
-UNIX_LIBS    = $(OSS4_LIBS) $(PTHREAD_LIBS)
+UNIX_LIBS    = $(OSS4_LIBS) $(PTHREAD_LIBS) -lrtpi
 UNIX_CFLAGS  = $(OSS4_CFLAGS)
 
 C_SRCS = \
diff -Npur a/dlls/wineoss.drv/oss.c b/dlls/wineoss.drv/oss.c
--- a/dlls/wineoss.drv/oss.c	2024-05-01 15:46:47.300975507 -0500
+++ b/dlls/wineoss.drv/oss.c	2024-05-01 15:50:03.526916348 -0500
@@ -32,6 +32,7 @@
 #include <errno.h>
 #include <sys/soundcard.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -64,7 +65,7 @@ struct oss_stream
     BYTE *local_buffer, *tmp_buffer;
     INT32 getbuf_last; /* <0 when using tmp_buffer */
 
-    pthread_mutex_t lock;
+    pi_mutex_t lock;
 };
 
 WINE_DEFAULT_DEBUG_CHANNEL(oss);
@@ -105,12 +106,12 @@ static int muldiv( int a, int b, int c )
 
 static void oss_lock(struct oss_stream *stream)
 {
-    pthread_mutex_lock(&stream->lock);
+    pi_mutex_lock(&stream->lock);
 }
 
 static void oss_unlock(struct oss_stream *stream)
 {
-    pthread_mutex_unlock(&stream->lock);
+    pi_mutex_unlock(&stream->lock);
 }
 
 static NTSTATUS oss_unlock_result(struct oss_stream *stream,
@@ -613,7 +614,7 @@ static NTSTATUS oss_create_stream(void *
     }
 
     stream->flow = params->flow;
-    pthread_mutex_init(&stream->lock, NULL);
+    pi_mutex_init(&stream->lock, 0);
 
     stream->fd = open_device(params->device, params->flow);
     if(stream->fd < 0){
@@ -677,7 +678,7 @@ exit:
             size = 0;
             NtFreeVirtualMemory(GetCurrentProcess(), (void **)&stream->local_buffer, &size, MEM_RELEASE);
         }
-        pthread_mutex_destroy(&stream->lock);
+        pi_mutex_destroy(&stream->lock);
         free(stream->fmt);
         free(stream);
     }else{
@@ -710,7 +711,7 @@ static NTSTATUS oss_release_stream(void
         NtFreeVirtualMemory(GetCurrentProcess(), (void **)&stream->tmp_buffer, &size, MEM_RELEASE);
     }
     free(stream->fmt);
-    pthread_mutex_destroy(&stream->lock);
+    pi_mutex_destroy(&stream->lock);
     free(stream);
 
     params->result = S_OK;
diff -Npur a/dlls/wineoss.drv/ossmidi.c b/dlls/wineoss.drv/ossmidi.c
--- a/dlls/wineoss.drv/ossmidi.c	2024-05-01 15:46:47.300975507 -0500
+++ b/dlls/wineoss.drv/ossmidi.c	2024-05-01 15:50:03.527916352 -0500
@@ -41,6 +41,7 @@
 #include <sys/ioctl.h>
 #include <sys/soundcard.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -79,7 +80,7 @@ struct midi_src
     int                 fd;
 };
 
-static pthread_mutex_t in_buffer_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t in_buffer_mutex = PI_MUTEX_INIT(0);
 
 static unsigned int num_dests, num_srcs, num_synths, seq_refs;
 static struct midi_dest dests[MAX_MIDIOUTDRV];
@@ -90,9 +91,9 @@ static unsigned int num_midi_in_started;
 static int rec_cancel_pipe[2];
 static pthread_t rec_thread_id;
 
-static pthread_mutex_t notify_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t notify_read_cond = PTHREAD_COND_INITIALIZER;
-static pthread_cond_t notify_write_cond = PTHREAD_COND_INITIALIZER;
+static pi_mutex_t notify_mutex = PI_MUTEX_INIT(0);
+static pi_cond_t notify_read_cond = PI_COND_INIT(0);
+static pi_cond_t notify_write_cond = PI_COND_INIT(0);
 static BOOL notify_quit;
 #define NOTIFY_BUFFER_SIZE 64 + 1 /* + 1 for the sentinel */
 static struct notify_context notify_buffer[NOTIFY_BUFFER_SIZE];
@@ -171,12 +172,12 @@ static int oss_to_win_device_type(int ty
 
 static void in_buffer_lock(void)
 {
-    pthread_mutex_lock(&in_buffer_mutex);
+    pi_mutex_lock(&in_buffer_mutex);
 }
 
 static void in_buffer_unlock(void)
 {
-    pthread_mutex_unlock(&in_buffer_mutex);
+    pi_mutex_unlock(&in_buffer_mutex);
 }
 
 static uint64_t get_time_msec(void)
@@ -235,19 +236,19 @@ static BOOL notify_buffer_remove(struct
 
 static void notify_post(struct notify_context *notify)
 {
-    pthread_mutex_lock(&notify_mutex);
+    pi_mutex_lock(&notify_mutex);
 
     if (notify)
     {
         while (notify_buffer_full())
-            pthread_cond_wait(&notify_write_cond, &notify_mutex);
+            pi_cond_wait(&notify_write_cond, &notify_mutex);
 
         notify_buffer_add(notify);
     }
     else notify_quit = TRUE;
-    pthread_cond_signal(&notify_read_cond);
+    pi_cond_signal(&notify_read_cond, &notify_mutex);
 
-    pthread_mutex_unlock(&notify_mutex);
+    pi_mutex_unlock(&notify_mutex);
 }
 
 static void set_in_notify(struct notify_context *notify, struct midi_src *src, WORD dev_id, WORD msg,
@@ -1806,18 +1807,18 @@ NTSTATUS oss_midi_notify_wait(void *args
 {
     struct midi_notify_wait_params *params = args;
 
-    pthread_mutex_lock(&notify_mutex);
+    pi_mutex_lock(&notify_mutex);
 
     while (!notify_quit && notify_buffer_empty())
-        pthread_cond_wait(&notify_read_cond, &notify_mutex);
+        pi_cond_wait(&notify_read_cond, &notify_mutex);
 
     *params->quit = notify_quit;
     if (!notify_quit)
     {
         notify_buffer_remove(params->notify);
-        pthread_cond_signal(&notify_write_cond);
+        pi_cond_signal(&notify_write_cond, &notify_mutex);
     }
-    pthread_mutex_unlock(&notify_mutex);
+    pi_mutex_unlock(&notify_mutex);
 
     return STATUS_SUCCESS;
 }
diff -Npur a/dlls/winepulse.drv/Makefile.in b/dlls/winepulse.drv/Makefile.in
--- a/dlls/winepulse.drv/Makefile.in	2024-05-01 15:46:47.302975517 -0500
+++ b/dlls/winepulse.drv/Makefile.in	2024-05-01 15:50:04.414920465 -0500
@@ -1,7 +1,7 @@
 MODULE    = winepulse.drv
 UNIXLIB   = winepulse.so
 IMPORTS   = dxguid uuid winmm user32 advapi32 ole32
-UNIX_LIBS    = $(PULSE_LIBS) $(PTHREAD_LIBS) -lm
+UNIX_LIBS    = $(PULSE_LIBS) $(PTHREAD_LIBS) -lm -lrtpi
 UNIX_CFLAGS  = $(PULSE_CFLAGS)
 
 C_SRCS = \
diff -Npur a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
--- a/dlls/winepulse.drv/pulse.c	2024-05-01 15:47:10.215088938 -0500
+++ b/dlls/winepulse.drv/pulse.c	2024-05-01 15:50:03.487916167 -0500
@@ -25,6 +25,7 @@
 
 #include <stdarg.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <math.h>
 #include <poll.h>
 
@@ -116,8 +117,8 @@ static struct list g_phys_sources = LIST
 static const REFERENCE_TIME MinimumPeriod = 30000;
 static const REFERENCE_TIME DefaultPeriod = 100000;
 
-static pthread_mutex_t pulse_mutex;
-static pthread_cond_t pulse_cond = PTHREAD_COND_INITIALIZER;
+static pi_mutex_t pulse_mutex;
+static pi_cond_t pulse_cond = PI_COND_INIT(0);
 
 static ULONG_PTR zero_bits = 0;
 
@@ -128,22 +129,22 @@ static NTSTATUS pulse_not_implemented(vo
 
 static void pulse_lock(void)
 {
-    pthread_mutex_lock(&pulse_mutex);
+    pi_mutex_lock(&pulse_mutex);
 }
 
 static void pulse_unlock(void)
 {
-    pthread_mutex_unlock(&pulse_mutex);
+    pi_mutex_unlock(&pulse_mutex);
 }
 
 static int pulse_cond_wait(void)
 {
-    return pthread_cond_wait(&pulse_cond, &pulse_mutex);
+    return pi_cond_wait(&pulse_cond, &pulse_mutex);
 }
 
 static void pulse_broadcast(void)
 {
-    pthread_cond_broadcast(&pulse_cond);
+    pi_cond_broadcast(&pulse_cond, &pulse_mutex);
 }
 
 static struct pulse_stream *handle_get_stream(stream_handle h)
@@ -217,8 +218,8 @@ static char *wstr_to_str(const WCHAR *ws
  * but that cannot be used because it uses pthread_create directly
  *
  * pa_threaded_mainloop_(un)lock -> pthread_mutex_(un)lock
- * pa_threaded_mainloop_signal -> pthread_cond_broadcast
- * pa_threaded_mainloop_wait -> pthread_cond_wait
+ * pa_threaded_mainloop_signal -> pi_cond_broadcast
+ * pa_threaded_mainloop_wait -> pi_cond_wait
  */
 static int pulse_poll_func(struct pollfd *ufds, unsigned long nfds, int timeout, void *userdata)
 {
 -231,13 +232,10 @@ static int pulse_poll_func(struct pollfd
 
 static NTSTATUS pulse_process_attach(void *args)
 {
-    pthread_mutexattr_t attr;
 
-    pthread_mutexattr_init(&attr);
-    pthread_mutexattr_setprotocol(&attr, PTHREAD_PRIO_INHERIT);
 
-    if (pthread_mutex_init(&pulse_mutex, &attr) != 0)
-        pthread_mutex_init(&pulse_mutex, NULL);
+    if (pi_mutex_init(&pulse_mutex, NULL) != 0)
+        pi_mutex_init(&pulse_mutex, 0);
 
 #ifdef _WIN64
     if (NtCurrentTeb()->WowTebOffset)
diff -Npur a/dlls/wineusb.sys/Makefile.in b/dlls/wineusb.sys/Makefile.in
--- a/dlls/wineusb.sys/Makefile.in	2024-05-01 15:46:47.303975522 -0500
+++ b/dlls/wineusb.sys/Makefile.in	2024-05-01 15:50:04.389920349 -0500
@@ -1,7 +1,7 @@
 MODULE    = wineusb.sys
 UNIXLIB   = wineusb.so
 IMPORTS   = ntoskrnl
-UNIX_LIBS    = $(USB_LIBS) $(PTHREAD_LIBS)
+UNIX_LIBS    = $(USB_LIBS) $(PTHREAD_LIBS) -lrtpi
 UNIX_CFLAGS  = $(USB_CFLAGS)
 
 EXTRADLLFLAGS = -Wl,--subsystem,native
diff -Npur a/dlls/wineusb.sys/unixlib.c b/dlls/wineusb.sys/unixlib.c
--- a/dlls/wineusb.sys/unixlib.c	2024-05-01 15:46:47.303975522 -0500
+++ b/dlls/wineusb.sys/unixlib.c	2024-05-01 15:50:03.023914015 -0500
@@ -27,6 +27,7 @@
 #include <stdlib.h>
 #include <libusb.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
@@ -56,7 +57,7 @@ static volatile bool thread_shutdown;
 static struct usb_event *usb_events;
 static size_t usb_event_count, usb_events_capacity;
 
-static pthread_mutex_t device_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t device_mutex = PI_MUTEX_INIT(0);
 
 static struct list device_list = LIST_INIT(device_list);
 
@@ -130,9 +131,9 @@ static void add_usb_device(libusb_device
     }
     unix_device->refcount = 1;
 
-    pthread_mutex_lock(&device_mutex);
+    pi_mutex_lock(&device_mutex);
     list_add_tail(&device_list, &unix_device->entry);
-    pthread_mutex_unlock(&device_mutex);
+    pi_mutex_unlock(&device_mutex);
 
     usb_event.type = USB_EVENT_ADD_DEVICE;
     usb_event.u.added_device.device = unix_device;
@@ -199,9 +200,9 @@ static void add_usb_device(libusb_device
                 unix_iface->refcount = 1;
                 unix_iface->handle = unix_device->handle;
                 unix_iface->parent = unix_device;
-                pthread_mutex_lock(&device_mutex);
+                pi_mutex_lock(&device_mutex);
                 list_add_tail(&device_list, &unix_iface->entry);
-                pthread_mutex_unlock(&device_mutex);
+                pi_mutex_unlock(&device_mutex);
 
                 usb_event.u.added_device.device = unix_iface;
                 usb_event.u.added_device.class = iface_desc->bInterfaceClass;
@@ -603,17 +604,17 @@ static NTSTATUS usb_cancel_transfer(void
 
 static void decref_device(struct unix_device *device)
 {
-    pthread_mutex_lock(&device_mutex);
+    pi_mutex_lock(&device_mutex);
 
     if (--device->refcount)
     {
-        pthread_mutex_unlock(&device_mutex);
+        pi_mutex_unlock(&device_mutex);
         return;
     }
 
     list_remove(&device->entry);
 
-    pthread_mutex_unlock(&device_mutex);
+    pi_mutex_unlock(&device_mutex);
 
     if (device->parent)
         decref_device(device->parent);
diff -Npur a/dlls/winevulkan/Makefile.in b/dlls/winevulkan/Makefile.in
--- a/dlls/winevulkan/Makefile.in	2024-05-01 15:46:47.304975527 -0500
+++ b/dlls/winevulkan/Makefile.in	2024-05-01 15:50:04.353920182 -0500
@@ -2,7 +2,7 @@ MODULE    = winevulkan.dll
 UNIXLIB   = winevulkan.so
 IMPORTLIB = winevulkan
 IMPORTS   = user32 gdi32 advapi32 setupapi win32u
-UNIX_LIBS = -lwin32u $(PTHREAD_LIBS)
+UNIX_LIBS = -lwin32u $(PTHREAD_LIBS) -lrtpi
 
 C_SRCS = \
 	loader.c \
diff -Npur a/dlls/winevulkan/vulkan_private.h b/dlls/winevulkan/vulkan_private.h
--- a/dlls/winevulkan/vulkan_private.h	2024-05-01 15:46:47.308975547 -0500
+++ b/dlls/winevulkan/vulkan_private.h	2024-05-01 15:50:01.897908792 -0500
@@ -24,6 +24,7 @@
 #define VK_NO_PROTOTYPES
 
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "vulkan_loader.h"
 #include "vulkan_thunks.h"
diff -Npur a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
--- a/dlls/winewayland.drv/display.c	2024-05-01 15:46:47.321975612 -0500
+++ b/dlls/winewayland.drv/display.c	2024-05-01 15:50:03.717917234 -0500
@@ -298,7 +298,7 @@ BOOL WAYLAND_UpdateDisplayDevices(const
 
     wl_array_init(&output_info_array);
 
-    pthread_mutex_lock(&process_wayland.output_mutex);
+    pi_mutex_lock(&process_wayland.output_mutex);
 
     wl_list_for_each(output, &process_wayland.output_list, link)
     {
@@ -323,7 +323,7 @@ BOOL WAYLAND_UpdateDisplayDevices(const
 
     wl_array_release(&output_info_array);
 
-    pthread_mutex_unlock(&process_wayland.output_mutex);
+    pi_mutex_unlock(&process_wayland.output_mutex);
 
     return TRUE;
 }
diff -Npur a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
--- a/dlls/winewayland.drv/Makefile.in	2024-05-01 15:46:47.320975607 -0500
+++ b/dlls/winewayland.drv/Makefile.in	2024-05-01 15:50:04.424920512 -0500
@@ -1,7 +1,7 @@
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 UNIX_CFLAGS = $(WAYLAND_CLIENT_CFLAGS)
-UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS) -lm
+UNIX_LIBS = -lwin32u $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS) -lm -lrtpi
 
 SOURCES = \
 	display.c \
diff -Npur a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
--- a/dlls/winewayland.drv/wayland.c	2024-05-01 15:46:47.321975612 -0500
+++ b/dlls/winewayland.drv/wayland.c	2024-05-01 15:50:03.718917238 -0500
@@ -34,10 +34,10 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 struct wayland process_wayland =
 {
-    .seat.mutex = PTHREAD_MUTEX_INITIALIZER,
-    .pointer.mutex = PTHREAD_MUTEX_INITIALIZER,
+    .seat.mutex = PI_MUTEX_INIT(0),
+    .pointer.mutex = PI_MUTEX_INIT(0),
     .output_list = {&process_wayland.output_list, &process_wayland.output_list},
-    .output_mutex = PTHREAD_MUTEX_INITIALIZER
+    .output_mutex = PI_MUTEX_INIT(0)
 };
 
 /**********************************************************************
@@ -131,12 +131,12 @@ static void registry_handle_global(void
             WARN("Only a single seat is currently supported, ignoring additional seats.\n");
             return;
         }
-        pthread_mutex_lock(&seat->mutex);
+        pi_mutex_lock(&seat->mutex);
         seat->wl_seat = wl_registry_bind(registry, id, &wl_seat_interface,
                                          version < 5 ? version : 5);
         seat->global_id = id;
         wl_seat_add_listener(seat->wl_seat, &seat_listener, NULL);
-        pthread_mutex_unlock(&seat->mutex);
+        pi_mutex_unlock(&seat->mutex);
     }
 }
 
@@ -163,11 +163,11 @@ static void registry_handle_global_remov
     {
         TRACE("removing seat\n");
         if (process_wayland.pointer.wl_pointer) wayland_pointer_deinit();
-        pthread_mutex_lock(&seat->mutex);
+        pi_mutex_lock(&seat->mutex);
         wl_seat_release(seat->wl_seat);
         seat->wl_seat = NULL;
         seat->global_id = 0;
-        pthread_mutex_unlock(&seat->mutex);
+        pi_mutex_unlock(&seat->mutex);
     }
 }
 
diff -Npur a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
--- a/dlls/winewayland.drv/waylanddrv.h	2024-05-01 15:46:47.321975612 -0500
+++ b/dlls/winewayland.drv/waylanddrv.h	2024-05-01 15:50:03.717917234 -0500
@@ -26,6 +26,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 #include <wayland-client.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
@@ -79,14 +80,14 @@ struct wayland_pointer
     uint32_t enter_serial;
     uint32_t button_serial;
     struct wayland_cursor cursor;
-    pthread_mutex_t mutex;
+    pi_mutex_t mutex;
 };
 
 struct wayland_seat
 {
     struct wl_seat *wl_seat;
     uint32_t global_id;
-    pthread_mutex_t mutex;
+    pi_mutex_t mutex;
 };
 
 struct wayland
@@ -103,7 +104,7 @@ struct wayland
     struct wayland_pointer pointer;
     struct wl_list output_list;
     /* Protects the output_list and the wayland_output.current states. */
-    pthread_mutex_t output_mutex;
+    pi_mutex_t output_mutex;
 };
 
 struct wayland_output_mode
@@ -154,7 +155,7 @@ struct wayland_surface
     struct wl_surface *wl_surface;
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
-    pthread_mutex_t mutex;
+    pi_mutex_t mutex;
     struct wayland_surface_config pending, requested, processing, current;
     struct wayland_shm_buffer *latest_window_buffer;
     BOOL resizing;
diff -Npur a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
--- a/dlls/winewayland.drv/wayland_output.c	2024-05-01 15:46:47.321975612 -0500
+++ b/dlls/winewayland.drv/wayland_output.c	2024-05-01 15:50:03.657916955 -0500
@@ -132,7 +132,7 @@ static void wayland_output_done(struct w
     struct wayland_output_mode *mode;
 
     /* Update current state from pending state. */
-    pthread_mutex_lock(&process_wayland.output_mutex);
+    pi_mutex_lock(&process_wayland.output_mutex);
 
     if (output->pending_flags & WAYLAND_OUTPUT_CHANGED_MODES)
     {
@@ -175,7 +175,7 @@ static void wayland_output_done(struct w
         output->current.logical_h = output->current.current_mode->height;
     }
 
-    pthread_mutex_unlock(&process_wayland.output_mutex);
+    pi_mutex_unlock(&process_wayland.output_mutex);
 
     TRACE("name=%s logical=%d,%d+%dx%d\n",
           output->current.name, output->current.logical_x, output->current.logical_y,
@@ -339,9 +339,9 @@ BOOL wayland_output_create(uint32_t id,
     if (process_wayland.zxdg_output_manager_v1)
         wayland_output_use_xdg_extension(output);
 
-    pthread_mutex_lock(&process_wayland.output_mutex);
+    pi_mutex_lock(&process_wayland.output_mutex);
     wl_list_insert(process_wayland.output_list.prev, &output->link);
-    pthread_mutex_unlock(&process_wayland.output_mutex);
+    pi_mutex_unlock(&process_wayland.output_mutex);
 
     return TRUE;
 
@@ -363,9 +363,9 @@ static void wayland_output_state_deinit(
  */
 void wayland_output_destroy(struct wayland_output *output)
 {
-    pthread_mutex_lock(&process_wayland.output_mutex);
+    pi_mutex_lock(&process_wayland.output_mutex);
     wl_list_remove(&output->link);
-    pthread_mutex_unlock(&process_wayland.output_mutex);
+    pi_mutex_unlock(&process_wayland.output_mutex);
 
     wayland_output_state_deinit(&output->pending);
     wayland_output_state_deinit(&output->current);
diff -Npur a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
--- a/dlls/winewayland.drv/wayland_pointer.c	2024-05-01 15:46:47.321975612 -0500
+++ b/dlls/winewayland.drv/wayland_pointer.c	2024-05-01 15:50:03.658916960 -0500
@@ -39,9 +39,9 @@ static HWND wayland_pointer_get_focused_
     struct wayland_pointer *pointer = &process_wayland.pointer;
     HWND hwnd;
 
-    pthread_mutex_lock(&pointer->mutex);
+    pi_mutex_lock(&pointer->mutex);
     hwnd = pointer->focused_hwnd;
-    pthread_mutex_unlock(&pointer->mutex);
+    pi_mutex_unlock(&pointer->mutex);
 
     return hwnd;
 }
@@ -92,7 +92,7 @@ static void pointer_handle_enter(void *d
 
     TRACE("hwnd=%p\n", hwnd);
 
-    pthread_mutex_lock(&pointer->mutex);
+    pi_mutex_lock(&pointer->mutex);
     pointer->focused_hwnd = hwnd;
     pointer->enter_serial = serial;
     /* The cursor is undefined at every enter, so we set it again with
@@ -102,7 +102,7 @@ static void pointer_handle_enter(void *d
                           pointer->cursor.wl_surface,
                           pointer->cursor.hotspot_x,
                           pointer->cursor.hotspot_y);
-    pthread_mutex_unlock(&pointer->mutex);
+    pi_mutex_unlock(&pointer->mutex);
 
     /* Handle the enter as a motion, to account for cases where the
      * window first appears beneath the pointer and won't get a separate
@@ -119,10 +119,10 @@ static void pointer_handle_leave(void *d
 
     TRACE("hwnd=%p\n", wl_surface_get_user_data(wl_surface));
 
-    pthread_mutex_lock(&pointer->mutex);
+    pi_mutex_lock(&pointer->mutex);
     pointer->focused_hwnd = NULL;
     pointer->enter_serial = 0;
-    pthread_mutex_unlock(&pointer->mutex);
+    pi_mutex_unlock(&pointer->mutex);
 }
 
 static void pointer_handle_button(void *data, struct wl_pointer *wl_pointer,
@@ -147,10 +147,10 @@ static void pointer_handle_button(void *
 
     if (state == WL_POINTER_BUTTON_STATE_RELEASED) input.mi.dwFlags <<= 1;
 
-    pthread_mutex_lock(&pointer->mutex);
+    pi_mutex_lock(&pointer->mutex);
     pointer->button_serial = state == WL_POINTER_BUTTON_STATE_PRESSED ?
                              serial : 0;
-    pthread_mutex_unlock(&pointer->mutex);
+    pi_mutex_unlock(&pointer->mutex);
 
     TRACE("hwnd=%p button=%#x state=%u\n", hwnd, button, state);
 
@@ -221,11 +221,11 @@ void wayland_pointer_init(struct wl_poin
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
-    pthread_mutex_lock(&pointer->mutex);
+    pi_mutex_lock(&pointer->mutex);
     pointer->wl_pointer = wl_pointer;
     pointer->focused_hwnd = NULL;
     pointer->enter_serial = 0;
-    pthread_mutex_unlock(&pointer->mutex);
+    pi_mutex_unlock(&pointer->mutex);
     wl_pointer_add_listener(pointer->wl_pointer, &pointer_listener, NULL);
 }
 
@@ -233,12 +233,12 @@ void wayland_pointer_deinit(void)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
 
-    pthread_mutex_lock(&pointer->mutex);
+    pi_mutex_lock(&pointer->mutex);
     wl_pointer_release(pointer->wl_pointer);
     pointer->wl_pointer = NULL;
     pointer->focused_hwnd = NULL;
     pointer->enter_serial = 0;
-    pthread_mutex_unlock(&pointer->mutex);
+    pi_mutex_unlock(&pointer->mutex);
 }
 
 /***********************************************************************
@@ -501,7 +501,7 @@ void WAYLAND_SetCursor(HWND hwnd, HCURSO
 
     TRACE("hwnd=%p hcursor=%p\n", hwnd, hcursor);
 
-    pthread_mutex_lock(&pointer->mutex);
+    pi_mutex_lock(&pointer->mutex);
     if (pointer->focused_hwnd == hwnd)
     {
         wayland_pointer_update_cursor(hcursor);
@@ -512,5 +512,5 @@ void WAYLAND_SetCursor(HWND hwnd, HCURSO
                               pointer->cursor.hotspot_y);
         wl_display_flush(process_wayland.wl_display);
     }
-    pthread_mutex_unlock(&pointer->mutex);
+    pi_mutex_unlock(&pointer->mutex);
 }
diff -Npur a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
--- a/dlls/winewayland.drv/wayland_surface.c	2024-05-01 15:46:47.321975612 -0500
+++ b/dlls/winewayland.drv/wayland_surface.c	2024-05-01 15:50:03.657916955 -0500
@@ -59,7 +59,7 @@ static void xdg_surface_handle_configure
         if (should_post) NtUserPostMessage(hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
     }
 
-    pthread_mutex_unlock(&surface->mutex);
+    pi_mutex_unlock(&surface->mutex);
 
     /* Flush the window surface in case there is content that we weren't
      * able to flush before due to the lack of the initial configure. */
@@ -116,7 +116,7 @@ static void xdg_toplevel_handle_configur
         surface->pending.state = config_state;
     }
 
-    pthread_mutex_unlock(&surface->mutex);
+    pi_mutex_unlock(&surface->mutex);
 }
 
 static void xdg_toplevel_handle_close(void *data, struct xdg_toplevel *xdg_toplevel)
@@ -148,7 +148,7 @@ struct wayland_surface *wayland_surface_
 
     TRACE("surface=%p\n", surface);
 
-    pthread_mutex_init(&surface->mutex, NULL);
+    pi_mutex_init(&surface->mutex, 0);
 
     surface->hwnd = hwnd;
     surface->wl_surface = wl_compositor_create_surface(process_wayland.wl_compositor);
@@ -173,15 +172,15 @@ err:
  */
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
-    pthread_mutex_lock(&process_wayland.pointer.mutex);
+    pi_mutex_lock(&process_wayland.pointer.mutex);
     if (process_wayland.pointer.focused_hwnd == surface->hwnd)
     {
         process_wayland.pointer.focused_hwnd = NULL;
         process_wayland.pointer.enter_serial = 0;
     }
-    pthread_mutex_unlock(&process_wayland.pointer.mutex);
+    pi_mutex_unlock(&process_wayland.pointer.mutex);
 
-    pthread_mutex_lock(&surface->mutex);
+    pi_mutex_lock(&surface->mutex);
 
     if (surface->xdg_toplevel)
     {
@@ -201,7 +200,7 @@ void wayland_surface_destroy(struct wayl
         surface->wl_surface = NULL;
     }
 
-    pthread_mutex_unlock(&surface->mutex);
+    pi_mutex_unlock(&surface->mutex);
 
     if (surface->latest_window_buffer)
         wayland_shm_buffer_unref(surface->latest_window_buffer);
 
     wl_display_flush(process_wayland.wl_display);
 
-    pthread_mutex_destroy(&surface->mutex);
+    pi_mutex_destroy(&surface->mutex);
 
     free(surface);
 }
diff -Npur a/dlls/winewayland.drv/window.c b//dlls/winewayland.drv/window.c
--- a/dlls/winewayland.drv/window.c	2024-05-03 17:21:02.453903952 -0500
+++ b//dlls/winewayland.drv/window.c	2024-05-03 17:26:09.308544408 -0500
@@ -59,7 +59,7 @@ static int wayland_win_data_cmp_rb(const
     return 0;
 }
 
-static pthread_mutex_t win_data_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t win_data_mutex = PI_MUTEX_INIT(0);
 static struct rb_tree win_data_rb = { wayland_win_data_cmp_rb };
 
 /***********************************************************************
@@ -84,7 +84,7 @@ static struct wayland_win_data *wayland_
     data->hwnd = hwnd;
     data->window_rect = *window_rect;
 
-    pthread_mutex_lock(&win_data_mutex);
+    pi_mutex_lock(&win_data_mutex);
 
     /* Check that another thread hasn't already created the wayland_win_data. */
     if ((rb_entry = rb_get(&win_data_rb, hwnd)))
@@ -109,7 +109,7 @@ static void wayland_win_data_destroy(str
 
     rb_remove(&win_data_rb, &data->entry);
 
-    pthread_mutex_unlock(&win_data_mutex);
+    pi_mutex_unlock(&win_data_mutex);
 
     if (data->window_surface)
     {
@@ -129,12 +129,12 @@ static struct wayland_win_data *wayland_
 {
     struct rb_entry *rb_entry;
 
-    pthread_mutex_lock(&win_data_mutex);
+    pi_mutex_lock(&win_data_mutex);
 
     if ((rb_entry = rb_get(&win_data_rb, hwnd)))
         return RB_ENTRY_VALUE(rb_entry, struct wayland_win_data, entry);
 
-    pthread_mutex_unlock(&win_data_mutex);
+    pi_mutex_unlock(&win_data_mutex);
 
     return NULL;
 }
@@ -147,7 +147,7 @@ static struct wayland_win_data *wayland_
 static void wayland_win_data_release(struct wayland_win_data *data)
 {
     assert(data);
-    pthread_mutex_unlock(&win_data_mutex);
+    pi_mutex_unlock(&win_data_mutex);
 }
 
 static void wayland_win_data_get_config(struct wayland_win_data *data,
@@ -201,7 +201,7 @@ static void wayland_win_data_update_wayl
     visible = (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE) == WS_VISIBLE;
     xdg_visible = surface->xdg_toplevel != NULL;
 
-    pthread_mutex_lock(&surface->mutex);
+    pi_mutex_lock(&surface->mutex);
 
     if (visible != xdg_visible)
     {
@@ -215,7 +215,7 @@ static void wayland_win_data_update_wayl
 
     wayland_win_data_get_config(data, &surface->window);
 
-    pthread_mutex_unlock(&surface->mutex);
+    pi_mutex_unlock(&surface->mutex);
 
     if (data->window_surface)
         wayland_window_surface_update_wayland_surface(data->window_surface, surface);
@@ -230,7 +230,7 @@ static void wayland_win_data_update_wayl
     struct wayland_surface *surface = data->wayland_surface;
     BOOL processing_config;
 
-    pthread_mutex_lock(&surface->mutex);
+    pi_mutex_lock(&surface->mutex);
 
     if (!surface->xdg_toplevel) goto out;
 
@@ -276,7 +276,7 @@ static void wayland_win_data_update_wayl
     }
 
 out:
-    pthread_mutex_unlock(&surface->mutex);
+    pi_mutex_unlock(&surface->mutex);
     wl_display_flush(process_wayland.wl_display);
 }
 
@@ -396,14 +396,14 @@ static void wayland_configure_window(HWN
     if (!surface->xdg_toplevel)
     {
         TRACE("missing xdg_toplevel, returning\n");
-        pthread_mutex_unlock(&surface->mutex);
+        pi_mutex_unlock(&surface->mutex);
         return;
     }
 
     if (!surface->requested.serial)
     {
         TRACE("requested configure event already handled, returning\n");
-        pthread_mutex_unlock(&surface->mutex);
+        pi_mutex_unlock(&surface->mutex);
         return;
     }
 
@@ -449,7 +449,7 @@ static void wayland_configure_window(HWN
         flags |= SWP_NOSIZE;
     }
 
-    pthread_mutex_unlock(&surface->mutex);
+    pi_mutex_unlock(&surface->mutex);
 
     TRACE("processing=%dx%d,%#x\n", width, height, state);
 
@@ -542,18 +542,18 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WP
     TRACE("cmd=%lx hwnd=%p, %lx, %lx\n",
           (long)command, hwnd, (long)wparam, lparam);
 
-    pthread_mutex_lock(&process_wayland.pointer.mutex);
+    pi_mutex_lock(&process_wayland.pointer.mutex);
     if (process_wayland.pointer.focused_hwnd == hwnd)
         button_serial = process_wayland.pointer.button_serial;
     else
         button_serial = 0;
-    pthread_mutex_unlock(&process_wayland.pointer.mutex);
+    pi_mutex_unlock(&process_wayland.pointer.mutex);
 
     if (command == SC_MOVE || command == SC_SIZE)
     {
         if ((surface = wayland_surface_lock_hwnd(hwnd)))
         {
-            pthread_mutex_lock(&process_wayland.seat.mutex);
+            pi_mutex_lock(&process_wayland.seat.mutex);
             wl_seat = process_wayland.seat.wl_seat;
             if (wl_seat && surface->xdg_toplevel && button_serial)
             {
@@ -567,8 +567,8 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WP
                                         hittest_to_resize_edge(wparam & 0x0f));
                 }
             }
-            pthread_mutex_unlock(&process_wayland.seat.mutex);
-            pthread_mutex_unlock(&surface->mutex);
+            pi_mutex_unlock(&process_wayland.seat.mutex);
+            pi_mutex_unlock(&surface->mutex);
             ret = 0;
         }
     }
@@ -604,7 +604,7 @@ struct wayland_surface *wayland_surface_
 
     if (!data) return NULL;
 
-    if ((surface = data->wayland_surface)) pthread_mutex_lock(&surface->mutex);
+    if ((surface = data->wayland_surface)) pi_mutex_lock(&surface->mutex);
 
     wayland_win_data_release(data);
 
diff -Npur a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
--- a/dlls/winewayland.drv/window_surface.c	2024-05-01 15:46:40.779943031 -0500
+++ b/dlls/winewayland.drv/window_surface.c	2024-05-01 15:50:03.657916955 -0500
@@ -48,7 +48,7 @@ struct wayland_window_surface
     struct wayland_buffer_queue *wayland_buffer_queue;
     RECT bounds;
     void *bits;
-    pthread_mutex_t mutex;
+    pi_mutex_t mutex;
     BITMAPINFO info;
 };
 
@@ -225,7 +225,7 @@ static void wayland_buffer_queue_add_dam
 static void wayland_window_surface_lock(struct window_surface *window_surface)
 {
     struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
-    pthread_mutex_lock(&wws->mutex);
+    pi_mutex_lock(&wws->mutex);
 }
 
 /***********************************************************************
@@ -234,7 +234,7 @@ static void wayland_window_surface_lock(
 static void wayland_window_surface_unlock(struct window_surface *window_surface)
 {
     struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
-    pthread_mutex_unlock(&wws->mutex);
+    pi_mutex_unlock(&wws->mutex);
 }
 
 /***********************************************************************
@@ -443,7 +443,7 @@ static void wayland_window_surface_flush
 
     wayland_window_surface_copy_to_buffer(wws, shm_buffer, copy_from_window_region);
 
-    pthread_mutex_lock(&wws->wayland_surface->mutex);
+    pi_mutex_lock(&wws->wayland_surface->mutex);
     if (wayland_surface_reconfigure(wws->wayland_surface))
     {
         wayland_surface_attach_shm(wws->wayland_surface, shm_buffer,
@@ -455,7 +455,7 @@ static void wayland_window_surface_flush
     {
         TRACE("Wayland surface not configured yet, not flushing\n");
     }
-    pthread_mutex_unlock(&wws->wayland_surface->mutex);
+    pi_mutex_unlock(&wws->wayland_surface->mutex);
     wl_display_flush(process_wayland.wl_display);
 
     NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
@@ -481,7 +481,7 @@ static void wayland_window_surface_destr
 
     TRACE("surface=%p\n", wws);
 
-    pthread_mutex_destroy(&wws->mutex);
+    pi_mutex_destroy(&wws->mutex);
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
     free(wws->bits);
@@ -507,7 +507,6 @@ struct window_surface *wayland_window_su
     struct wayland_window_surface *wws;
     int width = rect->right - rect->left;
     int height = rect->bottom - rect->top;
-    pthread_mutexattr_t mutexattr;
 
     TRACE("hwnd %p rect %s\n", hwnd, wine_dbgstr_rect(rect));
 
@@ -522,10 +521,7 @@ struct window_surface *wayland_window_su
     wws->info.bmiHeader.biPlanes = 1;
     wws->info.bmiHeader.biSizeImage = width * height * 4;
 
-    pthread_mutexattr_init(&mutexattr);
-    pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_RECURSIVE);
-    pthread_mutex_init(&wws->mutex, &mutexattr);
-    pthread_mutexattr_destroy(&mutexattr);
+    pi_mutex_init(&wws->mutex, 0);
 
     wws->header.funcs = &wayland_window_surface_funcs;
     wws->header.rect = *rect;
diff -Npur a/dlls/winex11.drv/bitblt.c b/dlls/winex11.drv/bitblt.c
--- a/dlls/winex11.drv/bitblt.c	2024-05-01 15:47:09.381084828 -0500
+++ b/dlls/winex11.drv/bitblt.c	2024-05-01 15:50:03.103914386 -0500
@@ -1588,7 +1588,7 @@ struct x11drv_window_surface
 #ifdef HAVE_LIBXXSHM
     XShmSegmentInfo       shminfo;
 #endif
-    pthread_mutex_t       mutex;
+    pi_mutex_t       mutex;
     BITMAPINFO            info;   /* variable size, must be last */
 };
 
@@ -1880,7 +1880,7 @@ static void x11drv_surface_lock( struct
 {
     struct x11drv_window_surface *surface = get_x11_surface( window_surface );
 
-    pthread_mutex_lock( &surface->mutex );
+    pi_mutex_lock( &surface->mutex );
 }
 
 /***********************************************************************
@@ -1890,7 +1890,7 @@ static void x11drv_surface_unlock( struc
 {
     struct x11drv_window_surface *surface = get_x11_surface( window_surface );
 
-    pthread_mutex_unlock( &surface->mutex );
+    pi_mutex_unlock( &surface->mutex );
 }
 
 /***********************************************************************
diff -Npur a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
--- a/dlls/winex11.drv/display.c	2024-05-01 15:46:47.322975617 -0500
+++ b/dlls/winex11.drv/display.c	2024-05-01 15:50:03.100914372 -0500
@@ -50,7 +50,7 @@ static const unsigned int depths_24[]  =
 static const unsigned int depths_32[]  = {8, 16, 32};
 const unsigned int *depths;
 
-static pthread_mutex_t settings_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t settings_mutex = PI_MUTEX_INIT(0);
 
 void X11DRV_Settings_SetHandler(const struct x11drv_settings_handler *new_handler)
 {
@@ -159,13 +159,13 @@ static void set_display_depth(x11drv_set
 {
     struct x11drv_display_depth *display_depth;
 
-    pthread_mutex_lock( &settings_mutex );
+    pi_mutex_lock( &settings_mutex );
     LIST_FOR_EACH_ENTRY(display_depth, &x11drv_display_depth_list, struct x11drv_display_depth, entry)
     {
         if (display_depth->display_id.id == display_id.id)
         {
             display_depth->depth = depth;
-            pthread_mutex_unlock( &settings_mutex );
+            pi_mutex_unlock( &settings_mutex );
             return;
         }
     }
@@ -174,14 +174,14 @@ static void set_display_depth(x11drv_set
     if (!display_depth)
     {
         ERR("Failed to allocate memory.\n");
-        pthread_mutex_unlock( &settings_mutex );
+        pi_mutex_unlock( &settings_mutex );
         return;
     }
 
     display_depth->display_id = display_id;
     display_depth->depth = depth;
     list_add_head(&x11drv_display_depth_list, &display_depth->entry);
-    pthread_mutex_unlock( &settings_mutex );
+    pi_mutex_unlock( &settings_mutex );
 }
 
 static DWORD get_display_depth(x11drv_settings_id display_id)
@@ -189,17 +189,17 @@ static DWORD get_display_depth(x11drv_se
     struct x11drv_display_depth *display_depth;
     DWORD depth;
 
-    pthread_mutex_lock( &settings_mutex );
+    pi_mutex_lock( &settings_mutex );
     LIST_FOR_EACH_ENTRY(display_depth, &x11drv_display_depth_list, struct x11drv_display_depth, entry)
     {
         if (display_depth->display_id.id == display_id.id)
         {
             depth = display_depth->depth;
-            pthread_mutex_unlock( &settings_mutex );
+            pi_mutex_unlock( &settings_mutex );
             return depth;
         }
     }
-    pthread_mutex_unlock( &settings_mutex );
+    pi_mutex_unlock( &settings_mutex );
     return screen_bpp;
 }
 
diff -Npur a/dlls/winex11.drv/init.c b//dlls/winex11.drv/init.c
--- a/dlls/winex11.drv/init.c	2024-05-03 17:21:21.432768366 -0500
+++ b//dlls/winex11.drv/init.c	2024-05-03 17:26:07.951536704 -0500
@@ -50,14 +50,10 @@ static const struct user_driver_funcs x1
 static const struct gdi_dc_funcs *xrender_funcs;
 
 
-void init_recursive_mutex( pthread_mutex_t *mutex )
+void init_recursive_mutex( pi_mutex_t *mutex )
 {
-    pthread_mutexattr_t attr;
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
+    pi_mutex_init( mutex, 0 );
 }
 
 
diff -Npur a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
--- a/dlls/winex11.drv/keyboard.c	2024-05-01 15:47:10.313089421 -0500
+++ b/dlls/winex11.drv/keyboard.c	2024-05-01 15:50:03.100914372 -0500
@@ -106,7 +106,7 @@ static WORD keyc2scan[256] =
 
 static int NumLockMask, ScrollLockMask, AltGrMask; /* mask in the XKeyEvent state */
 
-static pthread_mutex_t kbd_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t kbd_mutex = PI_MUTEX_INIT(0);
 
 static char KEYBOARD_MapDeadKeysym(KeySym keysym);
 
@@ -1291,7 +1291,7 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEv
 
     memset(keys, 0, sizeof(keys));
 
-    pthread_mutex_lock( &kbd_mutex );
+    pi_mutex_lock( &kbd_mutex );
 
     /* the minimum keycode is always greater or equal to 8, so we can
      * skip the first 8 values, hence start at 1
@@ -1352,7 +1352,7 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEv
         }
     }
 
-    pthread_mutex_unlock( &kbd_mutex );
+    pi_mutex_unlock( &kbd_mutex );
     if (!changed) return FALSE;
 
     update_key_state( keystate, VK_CONTROL, (keystate[VK_LCONTROL] | keystate[VK_RCONTROL]) & 0x80 );
@@ -1471,7 +1471,7 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent
         return TRUE;
     }
 
-    pthread_mutex_lock( &kbd_mutex );
+    pi_mutex_lock( &kbd_mutex );
 
     /* If XKB extensions are used, the state mask for AltGr will use the group
        index instead of the modifier mask. The group index is set in bits
@@ -1506,7 +1506,7 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent
     TRACE_(key)("keycode %u converted to vkey 0x%X scan %04x\n",
                 event->keycode, vkey, scan);
 
-    pthread_mutex_unlock( &kbd_mutex );
+    pi_mutex_unlock( &kbd_mutex );
 
     if (!vkey) return FALSE;
 
@@ -1668,7 +1668,7 @@ void X11DRV_InitKeyboard( Display *displ
     };
     int vkey_range, kbd_layout;
 
-    pthread_mutex_lock( &kbd_mutex );
+    pi_mutex_lock( &kbd_mutex );
     XDisplayKeycodes(display, &min_keycode, &max_keycode);
     XFree( XGetKeyboardMapping( display, min_keycode, max_keycode + 1 - min_keycode, &keysyms_per_keycode ) );
 
@@ -1902,7 +1902,7 @@ void X11DRV_InitKeyboard( Display *displ
 	keyc2scan[keyc]=scan++;
       }
 
-    pthread_mutex_unlock( &kbd_mutex );
+    pi_mutex_unlock( &kbd_mutex );
 }
 
 
@@ -1999,13 +1999,13 @@ SHORT X11DRV_VkKeyScanEx( WCHAR wChar, H
     TRACE("'%c'(%lx): got keycode %u\n", cChar, keysym, keycode);
     if (!keycode) return -1;
 
-    pthread_mutex_lock( &kbd_mutex );
+    pi_mutex_lock( &kbd_mutex );
 
     /* keycode -> (keyc2vkey) vkey */
     ret = keyc2vkey[keycode];
     if (!ret)
     {
-        pthread_mutex_unlock( &kbd_mutex );
+        pi_mutex_unlock( &kbd_mutex );
         TRACE("keycode for '%c' not found, returning -1\n", cChar);
         return -1;
     }
@@ -2013,7 +2013,7 @@ SHORT X11DRV_VkKeyScanEx( WCHAR wChar, H
     for (index = 0; index < 4; index++) /* find shift state */
         if (XkbKeycodeToKeysym( display, keycode, 0, index ) == keysym) break;
 
-    pthread_mutex_unlock( &kbd_mutex );
+    pi_mutex_unlock( &kbd_mutex );
 
     switch (index)
     {
@@ -2048,7 +2048,7 @@ UINT X11DRV_MapVirtualKeyEx( UINT wCode,
 
     TRACE("wCode=0x%x, wMapType=%d, hkl %p\n", wCode, wMapType, hkl);
 
-    pthread_mutex_lock( &kbd_mutex );
+    pi_mutex_lock( &kbd_mutex );
 
     switch(wMapType)
     {
@@ -2174,7 +2174,7 @@ UINT X11DRV_MapVirtualKeyEx( UINT wCode,
             break;
     }
 
-    pthread_mutex_unlock( &kbd_mutex );
+    pi_mutex_unlock( &kbd_mutex );
     TRACE( "returning 0x%x.\n", ret );
     return ret;
 }
@@ -2251,7 +2251,7 @@ INT X11DRV_GetKeyNameText( LONG lParam,
 
   /* let's do scancode -> keycode -> keysym -> String */
 
-  pthread_mutex_lock( &kbd_mutex );
+  pi_mutex_lock( &kbd_mutex );
 
   for (keyi=min_keycode; keyi<=max_keycode; keyi++)
       if ((keyc2scan[keyi]) == scanCode)
@@ -2269,7 +2269,7 @@ INT X11DRV_GetKeyNameText( LONG lParam,
           char* idx = strrchr(name, '_');
           if (idx && (idx[1] == 'r' || idx[1] == 'R' || idx[1] == 'l' || idx[1] == 'L') && !idx[2])
           {
-              pthread_mutex_unlock( &kbd_mutex );
+              pi_mutex_unlock( &kbd_mutex );
               TRACE("found scan=%04x keyc=%u keysym=%lx modified_string=%s\n",
                     scanCode, keyc, keys, debugstr_an(name,idx-name));
               rc = ntdll_umbstowcs( name, idx - name + 1, lpBuffer, nSize );
@@ -2281,7 +2281,7 @@ INT X11DRV_GetKeyNameText( LONG lParam,
 
       if (name)
       {
-          pthread_mutex_unlock( &kbd_mutex );
+          pi_mutex_unlock( &kbd_mutex );
           TRACE("found scan=%04x keyc=%u keysym=%04x vkey=%04x string=%s\n",
                 scanCode, keyc, (int)keys, vkey, debugstr_a(name));
           rc = ntdll_umbstowcs( name, strlen(name) + 1, lpBuffer, nSize );
@@ -2293,7 +2293,7 @@ INT X11DRV_GetKeyNameText( LONG lParam,
 
   /* Finally issue WARN for unknown keys   */
 
-  pthread_mutex_unlock( &kbd_mutex );
+  pi_mutex_unlock( &kbd_mutex );
   WARN("(%08x,%p,%d): unsupported key, vkey=%04X, ansi=%04x\n",(int)lParam,lpBuffer,nSize,vkey,ansi);
   *lpBuffer = 0;
   return 0;
@@ -2436,7 +2436,7 @@ INT X11DRV_ToUnicodeEx( UINT virtKey, UI
     e.window = X11DRV_get_whole_window( focus );
     xic = X11DRV_get_ic( focus );
 
-    pthread_mutex_lock( &kbd_mutex );
+    pi_mutex_lock( &kbd_mutex );
 
     if (lpKeyState[VK_SHIFT] & 0x80)
     {
@@ -2507,7 +2507,7 @@ INT X11DRV_ToUnicodeEx( UINT virtKey, UI
     if (!e.keycode && virtKey != VK_NONAME)
       {
 	WARN_(key)("Unknown virtual key %X !!!\n", virtKey);
-        pthread_mutex_unlock( &kbd_mutex );
+        pi_mutex_unlock( &kbd_mutex );
 	return 0;
       }
     else TRACE_(key)("Found keycode %u\n",e.keycode);
@@ -2528,7 +2528,7 @@ INT X11DRV_ToUnicodeEx( UINT virtKey, UI
             if (lpChar == NULL)
             {
                 ERR_(key)("Failed to allocate memory!\n");
-                pthread_mutex_unlock( &kbd_mutex );
+                pi_mutex_unlock( &kbd_mutex );
                 return 0;
             }
             ret = XmbLookupString(xic, &e, lpChar, ret, &keysym, &status);
@@ -2680,7 +2680,7 @@ found:
     if (buf != lpChar)
         free( lpChar );
 
-    pthread_mutex_unlock( &kbd_mutex );
+    pi_mutex_unlock( &kbd_mutex );
 
     /* Null-terminate the buffer, if there's room.  MSDN clearly states that the
        caller must not assume this is done, but some programs (e.g. Audiosurf) do. */
diff -Npur a/dlls/winex11.drv/Makefile.in b/dlls/winex11.drv/Makefile.in
--- a/dlls/winex11.drv/Makefile.in	2024-05-01 15:46:47.322975617 -0500
+++ b/dlls/winex11.drv/Makefile.in	2024-05-01 15:50:04.396920382 -0500
@@ -3,7 +3,7 @@ UNIXLIB   = winex11.so
 IMPORTS   = uuid user32 gdi32 win32u
 DELAYIMPORTS = comctl32 ole32 shell32 imm32
 UNIX_CFLAGS  = $(X_CFLAGS)
-UNIX_LIBS    = -lwin32u $(X_LIBS) $(X_EXTRA_LIBS) $(PTHREAD_LIBS) -lm
+UNIX_LIBS    = -lwin32u $(X_LIBS) $(X_EXTRA_LIBS) $(PTHREAD_LIBS) -lm -lrtpi
 
 C_SRCS = \
 	bitblt.c \
diff -Npur a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
--- a/dlls/winex11.drv/opengl.c	2024-05-01 15:47:17.683125681 -0500
+++ b/dlls/winex11.drv/opengl.c	2024-05-01 15:50:03.100914372 -0500
@@ -278,7 +278,7 @@ static enum glx_swap_control_method swap
 static BOOL has_swap_control_tear = FALSE;
 static BOOL has_swap_method = FALSE;
 
-static pthread_mutex_t context_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t context_mutex = PI_MUTEX_INIT(0);
 
 static const BOOL is_win64 = sizeof(void *) > sizeof(int);
 
@@ -1197,7 +1197,7 @@ static void mark_drawable_dirty( struct
 {
     struct wgl_context *ctx;
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     LIST_FOR_EACH_ENTRY( ctx, &context_list, struct wgl_context, entry )
     {
         if (old == ctx->drawables[0] || old == ctx->new_drawables[0])
@@ -1211,7 +1211,7 @@ static void mark_drawable_dirty( struct
             ctx->new_drawables[1] = grab_gl_drawable( new );
         }
     }
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
 }
 
 /* Given the current context, make sure its drawable is sync'd */
@@ -1220,7 +1220,7 @@ static inline void sync_context(struct w
     BOOL refresh = FALSE;
     struct gl_drawable *old[2] = { NULL };
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     if (context->new_drawables[0])
     {
         old[0] = context->drawables[0];
@@ -1245,7 +1245,7 @@ static inline void sync_context(struct w
         release_gl_drawable( old[0] );
         release_gl_drawable( old[1] );
     }
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
 }
 
 static BOOL set_swap_interval(GLXDrawable drawable, int interval)
@@ -1289,14 +1289,14 @@ static struct gl_drawable *get_gl_drawab
 {
     struct gl_drawable *gl;
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     if (hwnd && !XFindContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char **)&gl ))
         gl = grab_gl_drawable( gl );
     else if (hdc && !XFindContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char **)&gl ))
         gl = grab_gl_drawable( gl );
     else
         gl = NULL;
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
     return gl;
 }
 
@@ -1394,14 +1394,14 @@ static struct gl_drawable *create_gl_dra
         return NULL;
     }
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     if (!XFindContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char **)&prev ))
     {
         gl->swap_interval = prev->swap_interval;
         release_gl_drawable( prev );
     }
     XSaveContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char *)grab_gl_drawable(gl) );
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
     return gl;
 }
 
@@ -1551,13 +1551,13 @@ void destroy_gl_drawable( HWND hwnd )
 {
     struct gl_drawable *gl;
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     if (!XFindContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char **)&gl ))
     {
         XDeleteContext( gdi_display, (XID)hwnd, gl_hwnd_context );
         release_gl_drawable( gl );
     }
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
 }
 
 
@@ -1785,9 +1785,9 @@ static struct wgl_context *glxdrv_wglCre
         ret->hdc = hdc;
         ret->fmt = gl->format;
         ret->ctx = create_glxcontext(gdi_display, ret, NULL);
-        pthread_mutex_lock( &context_mutex );
+        pi_mutex_lock( &context_mutex );
         list_add_head( &context_list, &ret->entry );
-        pthread_mutex_unlock( &context_mutex );
+        pi_mutex_unlock( &context_mutex );
     }
     release_gl_drawable( gl );
     TRACE( "%p -> %p\n", hdc, ret );
@@ -1803,7 +1803,7 @@ static BOOL glxdrv_wglDeleteContext(stru
 
     TRACE("(%p)\n", ctx);
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     list_remove( &ctx->entry );
     LIST_FOR_EACH_ENTRY( pb, &pbuffer_list, struct wgl_pbuffer, entry )
     {
@@ -1812,7 +1812,7 @@ static BOOL glxdrv_wglDeleteContext(stru
             pb->prev_context = pb->tmp_context = NULL;
         }
     }
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
 
     if (ctx->ctx) pglXDestroyContext( gdi_display, ctx->ctx );
     release_gl_drawable( ctx->drawables[0] );
@@ -1877,7 +1877,7 @@ static BOOL glxdrv_wglMakeCurrent(HDC hd
         TRACE("hdc %p drawable %lx fmt %p ctx %p %s\n", hdc, gl->drawable, gl->format, ctx->ctx,
               debugstr_fbconfig( gl->format->fbconfig ));
 
-        pthread_mutex_lock( &context_mutex );
+        pi_mutex_lock( &context_mutex );
         ret = pglXMakeCurrent(gdi_display, gl->drawable, ctx->ctx);
         if (ret)
         {
@@ -1886,10 +1886,10 @@ static BOOL glxdrv_wglMakeCurrent(HDC hd
             ctx->hdc = hdc;
             set_context_drawables( ctx, gl, gl );
             ctx->refresh_drawables = FALSE;
-            pthread_mutex_unlock( &context_mutex );
+            pi_mutex_unlock( &context_mutex );
             goto done;
         }
-        pthread_mutex_unlock( &context_mutex );
+        pi_mutex_unlock( &context_mutex );
     }
     RtlSetLastWin32Error( ERROR_INVALID_HANDLE );
 
@@ -1922,7 +1922,7 @@ static BOOL X11DRV_wglMakeContextCurrent
     {
         read_gl = get_gl_drawable( NtUserWindowFromDC( read_hdc ), read_hdc );
 
-        pthread_mutex_lock( &context_mutex );
+        pi_mutex_lock( &context_mutex );
         ret = pglXMakeContextCurrent(gdi_display, draw_gl->drawable,
                                      read_gl ? read_gl->drawable : 0, ctx->ctx);
         if (ret)
@@ -1932,10 +1932,10 @@ static BOOL X11DRV_wglMakeContextCurrent
             set_context_drawables( ctx, draw_gl, read_gl );
             ctx->refresh_drawables = FALSE;
             NtCurrentTeb()->glContext = ctx;
-            pthread_mutex_unlock( &context_mutex );
+            pi_mutex_unlock( &context_mutex );
             goto done;
         }
-        pthread_mutex_unlock( &context_mutex );
+        pi_mutex_unlock( &context_mutex );
     }
     RtlSetLastWin32Error( ERROR_INVALID_HANDLE );
 done:
@@ -2142,9 +2142,9 @@ static struct wgl_context *X11DRV_wglCre
         }
         else
         {
-            pthread_mutex_lock( &context_mutex );
+            pi_mutex_lock( &context_mutex );
             list_add_head( &context_list, &ret->entry );
-            pthread_mutex_unlock( &context_mutex );
+            pi_mutex_unlock( &context_mutex );
         }
     }
 
@@ -2348,9 +2348,9 @@ static struct wgl_pbuffer *X11DRV_wglCre
         RtlSetLastWin32Error(ERROR_NO_SYSTEM_RESOURCES);
         goto create_failed; /* unexpected error */
     }
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     list_add_head( &pbuffer_list, &object->entry );
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
     TRACE("->(%p)\n", object);
     return object;
 
@@ -2369,9 +2369,9 @@ static BOOL X11DRV_wglDestroyPbufferARB(
 {
     TRACE("(%p)\n", object);
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     list_remove( &object->entry );
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
     release_gl_drawable( object->gl );
     if (object->tmp_context)
         pglXDestroyContext(gdi_display, object->tmp_context);
@@ -2393,12 +2393,12 @@ static HDC X11DRV_wglGetPbufferDCARB( st
     hdc = NtGdiOpenDCW( NULL, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
     if (!hdc) return 0;
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     if (!XFindContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char **)&prev ))
         release_gl_drawable( prev );
     grab_gl_drawable( object->gl );
     XSaveContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char *)object->gl );
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
 
     escape.code = X11DRV_SET_DRAWABLE;
     escape.drawable = object->gl->drawable;
@@ -2510,7 +2510,7 @@ static int X11DRV_wglReleasePbufferDCARB
 
     TRACE("(%p, %p)\n", object, hdc);
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
 
     if (!XFindContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char **)&gl ))
     {
@@ -2519,7 +2519,7 @@ static int X11DRV_wglReleasePbufferDCARB
     }
     else hdc = 0;
 
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
 
     return hdc && NtGdiDeleteObjectApp(hdc);
 }
@@ -3154,7 +3154,7 @@ static BOOL X11DRV_wglSwapIntervalEXT(in
         return FALSE;
     }
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     ret = set_swap_interval(gl->drawable, interval);
     gl->refresh_swap_interval = FALSE;
     if (ret)
@@ -3162,7 +3162,7 @@ static BOOL X11DRV_wglSwapIntervalEXT(in
     else
         RtlSetLastWin32Error(ERROR_DC_NOT_FOUND);
 
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
     release_gl_drawable(gl);
 
     return ret;
@@ -3380,13 +3380,13 @@ static BOOL glxdrv_wglSwapBuffers( HDC h
         return FALSE;
     }
 
-    pthread_mutex_lock( &context_mutex );
+    pi_mutex_lock( &context_mutex );
     if (gl->refresh_swap_interval)
     {
         set_swap_interval(gl->drawable, gl->swap_interval);
         gl->refresh_swap_interval = FALSE;
     }
-    pthread_mutex_unlock( &context_mutex );
+    pi_mutex_unlock( &context_mutex );
 
     switch (gl->type)
     {
diff -Npur a/dlls/winex11.drv/palette.c b/dlls/winex11.drv/palette.c
--- a/dlls/winex11.drv/palette.c	2024-05-01 15:46:40.783943051 -0500
+++ b/dlls/winex11.drv/palette.c	2024-05-01 15:50:03.101914377 -0500
@@ -73,7 +73,7 @@ static unsigned char X11DRV_PALETTE_free
 
 static XContext palette_context;  /* X context to associate a color mapping to a palette */
 
-static pthread_mutex_t palette_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t palette_mutex = PI_MUTEX_INIT(0);
 
 /**********************************************************************/
 
@@ -780,7 +780,7 @@ BOOL X11DRV_IsSolidColor( COLORREF color
 
     if (X11DRV_PALETTE_PaletteFlags & X11DRV_PALETTE_VIRTUAL) return TRUE;  /* no palette */
 
-    pthread_mutex_lock( &palette_mutex );
+    pi_mutex_lock( &palette_mutex );
     for (i = 0; i < palette_size ; i++, pEntry++)
     {
         if( i < COLOR_gapStart || i > COLOR_gapEnd )
@@ -788,11 +788,11 @@ BOOL X11DRV_IsSolidColor( COLORREF color
                 (GetGValue(color) == pEntry->peGreen) &&
                 (GetBValue(color) == pEntry->peBlue))
             {
-                pthread_mutex_unlock( &palette_mutex );
+                pi_mutex_unlock( &palette_mutex );
                 return TRUE;
             }
     }
-    pthread_mutex_unlock( &palette_mutex );
+    pi_mutex_unlock( &palette_mutex );
     return FALSE;
 }
 
@@ -835,9 +835,9 @@ COLORREF X11DRV_PALETTE_ToLogical(X11DRV
     if ((default_visual.depth <= 8) && (pixel < 256) &&
         !(X11DRV_PALETTE_PaletteFlags & (X11DRV_PALETTE_VIRTUAL | X11DRV_PALETTE_FIXED)) ) {
         COLORREF ret;
-        pthread_mutex_lock( &palette_mutex );
+        pi_mutex_lock( &palette_mutex );
         ret = *(COLORREF *)(COLOR_sysPal + (X11DRV_PALETTE_XPixelToPalette ? X11DRV_PALETTE_XPixelToPalette[pixel]: pixel)) & 0x00ffffff;
-        pthread_mutex_unlock( &palette_mutex );
+        pi_mutex_unlock( &palette_mutex );
         return ret;
     }
 
@@ -1008,10 +1008,10 @@ int X11DRV_PALETTE_ToPhysical( X11DRV_PD
                 return (((color >> 16) & 0xff) +
                         ((color >> 8) & 0xff) + (color & 0xff) > 255*3/2) ? 1 : 0;
 
-            pthread_mutex_lock( &palette_mutex );
+            pi_mutex_lock( &palette_mutex );
             index = X11DRV_SysPaletteLookupPixel( color & 0xffffff, FALSE);
             if (X11DRV_PALETTE_PaletteToXPixel) index = X11DRV_PALETTE_PaletteToXPixel[index];
-            pthread_mutex_unlock( &palette_mutex );
+            pi_mutex_unlock( &palette_mutex );
         }
     }
     return index;
@@ -1074,11 +1074,11 @@ static int X11DRV_PALETTE_LookupPixel(Co
         if (!mapping)
             WARN("Palette %p is not realized\n", hPal);
 
-        pthread_mutex_lock( &palette_mutex );
+        pi_mutex_lock( &palette_mutex );
         index = X11DRV_SysPaletteLookupPixel( color, FALSE);
         if (X11DRV_PALETTE_PaletteToXPixel)
             index = X11DRV_PALETTE_PaletteToXPixel[index];
-        pthread_mutex_unlock( &palette_mutex );
+        pi_mutex_unlock( &palette_mutex );
         return index;
     }
 }
@@ -1217,7 +1217,7 @@ UINT X11DRV_RealizePalette( PHYSDEV dev,
 
     /* reset dynamic system palette entries */
 
-    pthread_mutex_lock( &palette_mutex );
+    pi_mutex_lock( &palette_mutex );
     if( primary && X11DRV_PALETTE_firstFree != -1)
          X11DRV_PALETTE_FormatSystemPalette();
 
@@ -1290,7 +1290,7 @@ UINT X11DRV_RealizePalette( PHYSDEV dev,
         TRACE("entry %i %s -> pixel %i\n", i, debugstr_color(*(COLORREF *)&entries[i]), index);
 
     }
-    pthread_mutex_unlock( &palette_mutex );
+    pi_mutex_unlock( &palette_mutex );
     return iRemapped;
 }
 
@@ -1327,7 +1327,7 @@ UINT X11DRV_GetSystemPaletteEntries( PHY
     if (start >= palette_size) return 0;
     if (start + count >= palette_size) count = palette_size - start;
 
-    pthread_mutex_lock( &palette_mutex );
+    pi_mutex_lock( &palette_mutex );
     for (i = 0; i < count; i++)
     {
         entries[i].peRed   = COLOR_sysPal[start + i].peRed;
@@ -1336,7 +1336,7 @@ UINT X11DRV_GetSystemPaletteEntries( PHY
         entries[i].peFlags = 0;
         TRACE("\tidx(%02x) -> %s\n", start + i, debugstr_color(*(COLORREF *)(entries + i)) );
     }
-    pthread_mutex_unlock( &palette_mutex );
+    pi_mutex_unlock( &palette_mutex );
     return count;
 }
 
@@ -1374,9 +1374,9 @@ COLORREF X11DRV_GetNearestColor( PHYSDEV
         color = RGB( entry.peRed,  entry.peGreen, entry.peBlue );
     }
     color &= 0x00ffffff;
-    pthread_mutex_lock( &palette_mutex );
+    pi_mutex_lock( &palette_mutex );
     nearest = (0x00ffffff & *(COLORREF*)(COLOR_sysPal + X11DRV_SysPaletteLookupPixel(color, FALSE)));
-    pthread_mutex_unlock( &palette_mutex );
+    pi_mutex_unlock( &palette_mutex );
 
     TRACE("(%s): returning %s\n", debugstr_color(color), debugstr_color(nearest) );
     return nearest;
@@ -1398,7 +1398,7 @@ UINT X11DRV_RealizeDefaultPalette( PHYSD
         PALETTEENTRY entries[NB_RESERVED_COLORS];
 
         get_palette_entries( GetStockObject(DEFAULT_PALETTE), 0, NB_RESERVED_COLORS, entries );
-        pthread_mutex_lock( &palette_mutex );
+        pi_mutex_lock( &palette_mutex );
         for( i = 0; i < NB_RESERVED_COLORS; i++ )
         {
             index = X11DRV_PALETTE_LookupSystemXPixel( RGB(entries[i].peRed,
@@ -1411,7 +1411,7 @@ UINT X11DRV_RealizeDefaultPalette( PHYSD
                 ret++;
             }
         }
-        pthread_mutex_unlock( &palette_mutex );
+        pi_mutex_unlock( &palette_mutex );
     }
     return ret;
 }
diff -Npur a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
--- a/dlls/winex11.drv/vulkan.c	2024-05-01 15:47:14.783111426 -0500
+++ b/dlls/winex11.drv/vulkan.c	2024-05-01 15:50:03.096914354 -0500
@@ -50,7 +50,7 @@ WINE_DECLARE_DEBUG_CHANNEL(fps);
 #define SONAME_LIBVULKAN ""
 #endif
 
-static pthread_mutex_t vulkan_mutex;
+static pi_mutex_t vulkan_mutex;
 
 static XContext vulkan_swapchain_context;
 
@@ -235,9 +235,9 @@ static void wine_vk_surface_release(stru
 
     if (surface->entry.next)
     {
-        pthread_mutex_lock(&vulkan_mutex);
+        pi_mutex_lock(&vulkan_mutex);
         list_remove(&surface->entry);
-        pthread_mutex_unlock(&vulkan_mutex);
+        pi_mutex_unlock(&vulkan_mutex);
     }
 
     if (surface->window)
@@ -262,14 +262,14 @@ void wine_vk_surface_destroy(struct wine
 void destroy_vk_surface(HWND hwnd)
 {
     struct wine_vk_surface *surface, *next;
-    pthread_mutex_lock(&vulkan_mutex);
+    pi_mutex_lock(&vulkan_mutex);
     LIST_FOR_EACH_ENTRY_SAFE(surface, next, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd)
             continue;
         wine_vk_surface_destroy(surface);
     }
-    pthread_mutex_unlock(&vulkan_mutex);
+    pi_mutex_unlock(&vulkan_mutex);
 }
 
 static BOOL wine_vk_surface_set_offscreen(struct wine_vk_surface *surface, BOOL offscreen)
@@ -300,13 +300,13 @@ static BOOL wine_vk_surface_set_offscree
 void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *changes)
 {
     struct wine_vk_surface *surface;
-    pthread_mutex_lock(&vulkan_mutex);
+    pi_mutex_lock(&vulkan_mutex);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
         if (surface->window != active) XConfigureWindow(gdi_display, surface->window, mask, changes);
     }
-    pthread_mutex_unlock(&vulkan_mutex);
+    pi_mutex_unlock(&vulkan_mutex);
 }
 
 void sync_vk_surface(HWND hwnd, BOOL known_child)
@@ -314,7 +314,7 @@ void sync_vk_surface(HWND hwnd, BOOL kno
     struct wine_vk_surface *surface;
     DWORD surface_with_swapchain_count = 0;
 
-    pthread_mutex_lock(&vulkan_mutex);
+    pi_mutex_lock(&vulkan_mutex);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
@@ -328,7 +328,7 @@ void sync_vk_surface(HWND hwnd, BOOL kno
         if (surface_with_swapchain_count > 1) wine_vk_surface_set_offscreen(surface, TRUE);
         else wine_vk_surface_set_offscreen(surface, known_child);
     }
-    pthread_mutex_unlock(&vulkan_mutex);
+    pi_mutex_unlock(&vulkan_mutex);
 }
 
 Window wine_vk_active_surface(HWND hwnd)
@@ -337,7 +337,7 @@ Window wine_vk_active_surface(HWND hwnd)
     DWORD surface_with_swapchain_count = 0;
     Window window;
 
-    pthread_mutex_lock(&vulkan_mutex);
+    pi_mutex_lock(&vulkan_mutex);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
@@ -353,7 +353,7 @@ Window wine_vk_active_surface(HWND hwnd)
         else wine_vk_surface_set_offscreen(active, active->known_child);
         window = active->window;
     }
-    pthread_mutex_unlock(&vulkan_mutex);
+    pi_mutex_unlock(&vulkan_mutex);
 
     return window;
 }
@@ -363,14 +363,14 @@ void vulkan_thread_detach(void)
     struct wine_vk_surface *surface, *next;
     DWORD thread_id = GetCurrentThreadId();
 
-    pthread_mutex_lock(&vulkan_mutex);
+    pi_mutex_lock(&vulkan_mutex);
     LIST_FOR_EACH_ENTRY_SAFE(surface, next, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd_thread_id != thread_id)
             continue;
         wine_vk_surface_destroy(surface);
     }
-    pthread_mutex_unlock(&vulkan_mutex);
+    pi_mutex_unlock(&vulkan_mutex);
 }
 
 static VkResult X11DRV_vkCreateInstance(const VkInstanceCreateInfo *create_info,
@@ -412,13 +412,13 @@ static VkResult X11DRV_vkAcquireNextImag
     BOOL wait_fence = FALSE;
     HDC hdc = 0;
 
-    pthread_mutex_lock(&vulkan_mutex);
+    pi_mutex_lock(&vulkan_mutex);
     if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface))
     {
         wine_vk_surface_grab(surface);
         hdc = surface->hdc;
     }
-    pthread_mutex_unlock(&vulkan_mutex);
+    pi_mutex_unlock(&vulkan_mutex);
 
     if (!surface || !surface->offscreen)
         wait_fence = FALSE;
@@ -488,7 +488,7 @@ static VkResult X11DRV_vkCreateSwapchain
         create_info_host.presentMode = VK_PRESENT_MODE_FIFO_KHR;
     x11_surface->present_mode = create_info->presentMode;
 
-    pthread_mutex_lock(&vulkan_mutex);
+    pi_mutex_lock(&vulkan_mutex);
     LIST_FOR_EACH_ENTRY(other, &surface_list, struct wine_vk_surface, entry)
     {
         if (other->hwnd != x11_surface->hwnd) continue;
@@ -503,7 +503,7 @@ static VkResult X11DRV_vkCreateSwapchain
         x11_surface->swapchain_count++;
         XSaveContext(gdi_display, (XID)(*swapchain), vulkan_swapchain_context, (char *)wine_vk_surface_grab(x11_surface));
     }
-    pthread_mutex_unlock(&vulkan_mutex);
+    pi_mutex_unlock(&vulkan_mutex);
     return result;
 }
 
@@ -573,9 +573,9 @@ static VkResult X11DRV_vkCreateWin32Surf
         goto err;
     }
 
-    pthread_mutex_lock(&vulkan_mutex);
+    pi_mutex_lock(&vulkan_mutex);
     list_add_tail(&surface_list, &x11_surface->entry);
-    pthread_mutex_unlock(&vulkan_mutex);
+    pi_mutex_unlock(&vulkan_mutex);
 
     *surface = (uintptr_t)x11_surface;
 
@@ -630,14 +630,14 @@ static void X11DRV_vkDestroySwapchainKHR
 
     pvkDestroySwapchainKHR(device, swapchain, NULL /* allocator */);
 
-    pthread_mutex_lock(&vulkan_mutex);
+    pi_mutex_lock(&vulkan_mutex);
     if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface))
     {
         surface->swapchain_count--;
         wine_vk_surface_release(surface);
     }
     XDeleteContext(gdi_display, (XID)swapchain, vulkan_swapchain_context);
-    pthread_mutex_unlock(&vulkan_mutex);
+    pi_mutex_unlock(&vulkan_mutex);
 }
 
 static VkResult X11DRV_vkEnumerateInstanceExtensionProperties(const char *layer_name,
diff -Npur a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
--- a/dlls/winex11.drv/window.c	2024-05-01 15:47:17.679125661 -0500
+++ b/dlls/winex11.drv/window.c	2024-05-01 15:50:03.104914391 -0500
@@ -110,7 +110,7 @@ static const WCHAR whole_window_prop[] =
 static const WCHAR clip_window_prop[] =
     {'_','_','w','i','n','e','_','x','1','1','_','c','l','i','p','_','w','i','n','d','o','w',0};
 
-static pthread_mutex_t win_data_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t win_data_mutex = PI_MUTEX_INIT(0);
 
 
 /***********************************************************************
@@ -246,7 +246,7 @@ static struct x11drv_win_data *alloc_win
         data->display = display;
         data->vis = default_visual;
         data->hwnd = hwnd;
-        pthread_mutex_lock( &win_data_mutex );
+        pi_mutex_lock( &win_data_mutex );
         XSaveContext( gdi_display, (XID)hwnd, win_data_context, (char *)data );
     }
     return data;
@@ -2101,10 +2101,10 @@ struct x11drv_win_data *get_win_data( HW
     char *data;
 
     if (!hwnd) return NULL;
-    pthread_mutex_lock( &win_data_mutex );
+    pi_mutex_lock( &win_data_mutex );
     if (!XFindContext( gdi_display, (XID)hwnd, win_data_context, &data ))
         return (struct x11drv_win_data *)data;
-    pthread_mutex_unlock( &win_data_mutex );
+    pi_mutex_unlock( &win_data_mutex );
     return NULL;
 }
 
@@ -2116,7 +2116,7 @@ struct x11drv_win_data *get_win_data( HW
  */
 void release_win_data( struct x11drv_win_data *data )
 {
-    if (data) pthread_mutex_unlock( &win_data_mutex );
+    if (data) pi_mutex_unlock( &win_data_mutex );
 }
 
 
diff -Npur a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
--- a/dlls/winex11.drv/x11drv.h	2024-05-01 15:47:14.781111416 -0500
+++ b/dlls/winex11.drv/x11drv.h	2024-05-01 15:50:03.097914358 -0500
@@ -30,6 +30,7 @@
 #include <stdarg.h>
 #include <stdlib.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <X11/Xlib.h>
 #include <X11/Xresource.h>
 #include <X11/Xutil.h>
@@ -723,7 +724,7 @@ extern RECT get_host_primary_monitor_rec
 extern RECT get_work_area( const RECT *monitor_rect ) DECLSPEC_HIDDEN;
 extern BOOL xinerama_get_fullscreen_monitors( const RECT *rect, long *indices ) DECLSPEC_HIDDEN;
 extern void xinerama_init( unsigned int width, unsigned int height ) DECLSPEC_HIDDEN;
-extern void init_recursive_mutex( pthread_mutex_t *mutex ) DECLSPEC_HIDDEN;
+extern void init_recursive_mutex( pi_mutex_t *mutex ) DECLSPEC_HIDDEN;
 
 /* keyboard.c */
 
diff -Npur a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
--- a/dlls/winex11.drv/x11drv_main.c	2024-05-01 15:47:17.683125681 -0500
+++ b/dlls/winex11.drv/x11drv_main.c	2024-05-01 15:50:03.101914377 -0500
@@ -104,8 +104,8 @@ static int (*old_error_handler)( Display
 static BOOL use_xim = TRUE;
 static WCHAR input_style[20];
 
-static pthread_mutex_t d3dkmt_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t error_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t d3dkmt_mutex = PI_MUTEX_INIT(0);
+static pi_mutex_t error_mutex = PI_MUTEX_INIT(0);
 
 struct x11_d3dkmt_adapter
 {
@@ -269,7 +269,7 @@ static inline BOOL ignore_error( Display
  */
 void X11DRV_expect_error( Display *display, x11drv_error_callback callback, void *arg )
 {
-    pthread_mutex_lock( &error_mutex );
+    pi_mutex_lock( &error_mutex );
     XLockDisplay( display );
     err_callback         = callback;
     err_callback_display = display;
@@ -290,7 +290,7 @@ int X11DRV_check_error(void)
     int res = err_callback_result;
     err_callback = NULL;
     XUnlockDisplay( err_callback_display );
-    pthread_mutex_unlock( &error_mutex );
+    pi_mutex_unlock( &error_mutex );
     return res;
 }
 
@@ -1052,7 +1052,7 @@ NTSTATUS X11DRV_D3DKMTCloseAdapter( cons
     if (!vulkan_funcs)
         return STATUS_UNSUCCESSFUL;
 
-    pthread_mutex_lock(&d3dkmt_mutex);
+    pi_mutex_lock(&d3dkmt_mutex);
     LIST_FOR_EACH_ENTRY(adapter, &x11_d3dkmt_adapters, struct x11_d3dkmt_adapter, entry)
     {
         if (adapter->handle == desc->hAdapter)
@@ -1068,7 +1068,7 @@ NTSTATUS X11DRV_D3DKMTCloseAdapter( cons
         vulkan_funcs->p_vkDestroyInstance(d3dkmt_vk_instance, NULL);
         d3dkmt_vk_instance = NULL;
     }
-    pthread_mutex_unlock(&d3dkmt_mutex);
+    pi_mutex_unlock(&d3dkmt_mutex);
     return STATUS_SUCCESS;
 }
 
@@ -1084,7 +1084,7 @@ NTSTATUS X11DRV_D3DKMTSetVidPnSourceOwne
 
     TRACE("(%p)\n", desc);
 
-    pthread_mutex_lock( &d3dkmt_mutex );
+    pi_mutex_lock( &d3dkmt_mutex );
 
     /* Check parameters */
     for (i = 0; i < desc->VidPnSourceCount; ++i)
@@ -1183,7 +1183,7 @@ NTSTATUS X11DRV_D3DKMTSetVidPnSourceOwne
     }
 
 done:
-    pthread_mutex_unlock( &d3dkmt_mutex );
+    pi_mutex_unlock( &d3dkmt_mutex );
     return status;
 }
 
@@ -1199,16 +1199,16 @@ NTSTATUS X11DRV_D3DKMTCheckVidPnExclusiv
     if (!desc || !desc->hAdapter)
         return STATUS_INVALID_PARAMETER;
 
-    pthread_mutex_lock( &d3dkmt_mutex );
+    pi_mutex_lock( &d3dkmt_mutex );
     LIST_FOR_EACH_ENTRY( source, &d3dkmt_vidpn_sources, struct d3dkmt_vidpn_source, entry )
     {
         if (source->id == desc->VidPnSourceId && source->type == D3DKMT_VIDPNSOURCEOWNER_EXCLUSIVE)
         {
-            pthread_mutex_unlock( &d3dkmt_mutex );
+            pi_mutex_unlock( &d3dkmt_mutex );
             return STATUS_GRAPHICS_PRESENT_OCCLUDED;
         }
     }
-    pthread_mutex_unlock( &d3dkmt_mutex );
+    pi_mutex_unlock( &d3dkmt_mutex );
     return STATUS_SUCCESS;
 }
 
@@ -1376,7 +1376,7 @@ NTSTATUS X11DRV_D3DKMTOpenAdapterFromLui
         return STATUS_UNSUCCESSFUL;
     }
 
-    pthread_mutex_lock(&d3dkmt_mutex);
+    pi_mutex_lock(&d3dkmt_mutex);
 
     if (!d3dkmt_vk_instance)
     {
@@ -1451,7 +1451,7 @@ done:
         vulkan_funcs->p_vkDestroyInstance(d3dkmt_vk_instance, NULL);
         d3dkmt_vk_instance = NULL;
     }
-    pthread_mutex_unlock(&d3dkmt_mutex);
+    pi_mutex_unlock(&d3dkmt_mutex);
     free(vk_physical_devices);
     return status;
 }
@@ -1477,7 +1477,7 @@ NTSTATUS X11DRV_D3DKMTQueryVideoMemoryIn
         return STATUS_UNSUCCESSFUL;
     }
 
-    pthread_mutex_lock(&d3dkmt_mutex);
+    pi_mutex_lock(&d3dkmt_mutex);
     LIST_FOR_EACH_ENTRY(adapter, &x11_d3dkmt_adapters, struct x11_d3dkmt_adapter, entry)
     {
         if (adapter->handle != desc->hAdapter)
@@ -1511,7 +1511,7 @@ NTSTATUS X11DRV_D3DKMTQueryVideoMemoryIn
         break;
     }
 done:
-    pthread_mutex_unlock(&d3dkmt_mutex);
+    pi_mutex_unlock(&d3dkmt_mutex);
     return status;
 }
 
diff -Npur a/dlls/winex11.drv/xim.c b/dlls/winex11.drv/xim.c
--- a/dlls/winex11.drv/xim.c	2024-05-01 15:47:10.406089879 -0500
+++ b/dlls/winex11.drv/xim.c	2024-05-01 15:50:03.099914368 -0500
@@ -55,7 +55,7 @@ struct ime_update
     WCHAR buffer[];
 };
 
-static pthread_mutex_t ime_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t ime_mutex = PI_MUTEX_INIT(0);
 static struct list ime_updates = LIST_INIT(ime_updates);
 static DWORD ime_update_count;
 static WCHAR *ime_comp_buf;
@@ -101,10 +101,10 @@ static void post_ime_update( HWND hwnd,
     update->comp_str = comp_str ? memcpy( update->buffer, comp_str, comp_len * sizeof(WCHAR) ) : NULL;
     update->result_str = result_str ? memcpy( update->buffer + comp_len, result_str, result_len * sizeof(WCHAR) ) : NULL;
 
-    pthread_mutex_lock( &ime_mutex );
+    pi_mutex_lock( &ime_mutex );
     id = update->id = ++ime_update_count;
     list_add_tail( &ime_updates, &update->entry );
-    pthread_mutex_unlock( &ime_mutex );
+    pi_mutex_unlock( &ime_mutex );
 
     NtUserPostMessage( hwnd, WM_IME_NOTIFY, IMN_WINE_SET_COMP_STRING, id );
 }
@@ -595,9 +595,9 @@ void xim_set_focus( HWND hwnd, BOOL focu
     if (focus) XSetICFocus( xic );
     else XUnsetICFocus( xic );
 
-    pthread_mutex_lock( &ime_mutex );
+    pi_mutex_lock( &ime_mutex );
     list_move_tail( &updates, &ime_updates );
-    pthread_mutex_unlock( &ime_mutex );
+    pi_mutex_unlock( &ime_mutex );
 
     LIST_FOR_EACH_ENTRY_SAFE( update, next, &updates, struct ime_update, entry ) free( update );
 }
@@ -625,11 +625,11 @@ UINT X11DRV_ImeToAsciiEx( UINT vkey, UIN
 
     TRACE( "vkey %#x, lparam %#x, state %p, compstr %p, himc %p\n", vkey, lparam, state, compstr, himc );
 
-    pthread_mutex_lock( &ime_mutex );
+    pi_mutex_lock( &ime_mutex );
 
     if (!(update = find_ime_update( lparam )))
     {
-        pthread_mutex_unlock( &ime_mutex );
+        pi_mutex_unlock( &ime_mutex );
         return 0;
     }
 
@@ -653,12 +653,12 @@ UINT X11DRV_ImeToAsciiEx( UINT vkey, UIN
     if (compstr->dwSize < needed)
     {
         compstr->dwSize = needed;
-        pthread_mutex_unlock( &ime_mutex );
+        pi_mutex_unlock( &ime_mutex );
         return STATUS_BUFFER_TOO_SMALL;
     }
 
     list_remove( &update->entry );
-    pthread_mutex_unlock( &ime_mutex );
+    pi_mutex_unlock( &ime_mutex );
 
     memset( compstr, 0, sizeof(*compstr) );
     compstr->dwSize = sizeof(*compstr);
diff -Npur a/dlls/winex11.drv/xinerama.c b/dlls/winex11.drv/xinerama.c
--- a/dlls/winex11.drv/xinerama.c	2024-05-01 15:46:47.328975647 -0500
+++ b/dlls/winex11.drv/xinerama.c	2024-05-01 15:50:03.096914354 -0500
@@ -45,7 +45,7 @@ static MONITORINFOEXW default_monitor =
     { '\\','\\','.','\\','D','I','S','P','L','A','Y','1',0 }   /* szDevice */
 };
 
-static pthread_mutex_t xinerama_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t xinerama_mutex = PI_MUTEX_INIT(0);
 static MONITORINFOEXW *monitors;
 static int nb_monitors;
 
@@ -131,7 +131,7 @@ BOOL xinerama_get_fullscreen_monitors( c
     POINT offset;
     INT i;
 
-    pthread_mutex_lock( &xinerama_mutex );
+    pi_mutex_lock( &xinerama_mutex );
     if (nb_monitors == 1)
     {
         memset( indices, 0, sizeof(*indices) * 4 );
@@ -184,7 +184,7 @@ BOOL xinerama_get_fullscreen_monitors( c
         ret = TRUE;
 
 done:
-    pthread_mutex_unlock( &xinerama_mutex );
+    pi_mutex_unlock( &xinerama_mutex );
     if (ret)
         TRACE( "fullscreen monitors: %ld,%ld,%ld,%ld.\n", indices[0], indices[1], indices[2], indices[3] );
     return ret;
@@ -225,11 +225,11 @@ static BOOL xinerama_get_adapters( ULONG
         return FALSE;
 
     /* Being lazy, actual adapter count may be less */
-    pthread_mutex_lock( &xinerama_mutex );
+    pi_mutex_lock( &xinerama_mutex );
     adapters = calloc( nb_monitors, sizeof(*adapters) );
     if (!adapters)
     {
-        pthread_mutex_unlock( &xinerama_mutex );
+        pi_mutex_unlock( &xinerama_mutex );
         return FALSE;
     }
 
@@ -276,7 +276,7 @@ static BOOL xinerama_get_adapters( ULONG
 
     *new_adapters = adapters;
     *count = index;
-    pthread_mutex_unlock( &xinerama_mutex );
+    pi_mutex_unlock( &xinerama_mutex );
     return TRUE;
 }
 
@@ -293,7 +293,7 @@ static BOOL xinerama_get_monitors( ULONG
     INT index = 0;
     INT i;
 
-    pthread_mutex_lock( &xinerama_mutex );
+    pi_mutex_lock( &xinerama_mutex );
 
     for (i = first; i < nb_monitors; i++)
     {
@@ -306,7 +306,7 @@ static BOOL xinerama_get_monitors( ULONG
     monitor = calloc( monitor_count, sizeof(*monitor) );
     if (!monitor)
     {
-        pthread_mutex_unlock( &xinerama_mutex );
+        pi_mutex_unlock( &xinerama_mutex );
         return FALSE;
     }
 
@@ -331,7 +331,7 @@ static BOOL xinerama_get_monitors( ULONG
 
     *new_monitors = monitor;
     *count = monitor_count;
-    pthread_mutex_unlock( &xinerama_mutex );
+    pi_mutex_unlock( &xinerama_mutex );
     return TRUE;
 }
 
@@ -350,7 +350,7 @@ void xinerama_init( unsigned int width,
     if (is_virtual_desktop())
         return;
 
-    pthread_mutex_lock( &xinerama_mutex );
+    pi_mutex_lock( &xinerama_mutex );
 
     SetRect( &rect, 0, 0, width, height );
     if (!query_screens())
@@ -375,7 +375,7 @@ void xinerama_init( unsigned int width,
                (monitors[i].dwFlags & MONITORINFOF_PRIMARY) ? " (primary)" : "" );
     }
 
-    pthread_mutex_unlock( &xinerama_mutex );
+    pi_mutex_unlock( &xinerama_mutex );
 
     handler.name = "Xinerama";
     handler.priority = 100;
diff -Npur a/dlls/winex11.drv/xrandr.c b/dlls/winex11.drv/xrandr.c
--- a/dlls/winex11.drv/xrandr.c	2024-05-01 15:46:47.328975647 -0500
+++ b/dlls/winex11.drv/xrandr.c	2024-05-01 15:50:03.102914382 -0500
@@ -330,15 +330,15 @@ static struct current_mode
 } *current_modes;
 static int current_mode_count;
 
-static pthread_mutex_t xrandr_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t xrandr_mutex = PI_MUTEX_INIT(0);
 
 static void xrandr14_invalidate_current_mode_cache(void)
 {
-    pthread_mutex_lock( &xrandr_mutex );
+    pi_mutex_lock( &xrandr_mutex );
     free( current_modes);
     current_modes = NULL;
     current_mode_count = 0;
-    pthread_mutex_unlock( &xrandr_mutex );
+    pi_mutex_unlock( &xrandr_mutex );
 }
 
 static XRRScreenResources *xrandr_get_screen_resources(void)
@@ -1225,12 +1225,12 @@ static BOOL xrandr14_get_id( const WCHAR
         return FALSE;
 
     /* Update cache */
-    pthread_mutex_lock( &xrandr_mutex );
+    pi_mutex_lock( &xrandr_mutex );
     if (!current_modes)
     {
         if (!xrandr14_get_gpus( &gpus, &gpu_count, FALSE ))
         {
-            pthread_mutex_unlock( &xrandr_mutex );
+            pi_mutex_unlock( &xrandr_mutex );
             return FALSE;
         }
 
@@ -1267,12 +1267,12 @@ static BOOL xrandr14_get_id( const WCHAR
 
     if (display_idx >= current_mode_count)
     {
-        pthread_mutex_unlock( &xrandr_mutex );
+        pi_mutex_unlock( &xrandr_mutex );
         return FALSE;
     }
 
     id->id = current_modes[display_idx].id;
-    pthread_mutex_unlock( &xrandr_mutex );
+    pi_mutex_unlock( &xrandr_mutex );
     return TRUE;
 }
 
@@ -1433,7 +1433,7 @@ static BOOL xrandr14_get_current_mode( x
     RECT primary;
     INT mode_idx;
 
-    pthread_mutex_lock( &xrandr_mutex );
+    pi_mutex_lock( &xrandr_mutex );
     for (mode_idx = 0; mode_idx < current_mode_count; ++mode_idx)
     {
         if (current_modes[mode_idx].id != id.id)
@@ -1446,7 +1446,7 @@ static BOOL xrandr14_get_current_mode( x
         }
 
         memcpy( mode, &current_modes[mode_idx].mode, sizeof(*mode) );
-        pthread_mutex_unlock( &xrandr_mutex );
+        pi_mutex_unlock( &xrandr_mutex );
         return TRUE;
     }
 
@@ -1517,7 +1517,7 @@ done:
         mode_ptr->mode.dmDriverExtra = 0;
         mode_ptr->loaded = TRUE;
     }
-    pthread_mutex_unlock( &xrandr_mutex );
+    pi_mutex_unlock( &xrandr_mutex );
     if (crtc_info)
         pXRRFreeCrtcInfo( crtc_info );
     if (output_info)
diff -Npur a/dlls/winex11.drv/xrender.c b/dlls/winex11.drv/xrender.c
--- a/dlls/winex11.drv/xrender.c	2024-05-01 15:46:47.329975652 -0500
+++ b/dlls/winex11.drv/xrender.c	2024-05-01 15:50:03.101914377 -0500
@@ -193,7 +193,7 @@ MAKE_FUNCPTR(XRenderQueryExtension)
 
 #undef MAKE_FUNCPTR
 
-static pthread_mutex_t xrender_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t xrender_mutex = PI_MUTEX_INIT(0);
 
 #define MS_MAKE_TAG( _x1, _x2, _x3, _x4 ) \
           ( ( (ULONG)_x4 << 24 ) |     \
@@ -561,7 +561,7 @@ static Picture get_no_alpha_mask(void)
     static Pixmap pixmap;
     static Picture pict;
 
-    pthread_mutex_lock( &xrender_mutex );
+    pi_mutex_lock( &xrender_mutex );
     if (!pict)
     {
         XRenderPictureAttributes pa;
@@ -576,7 +576,7 @@ static Picture get_no_alpha_mask(void)
         col.alpha = 0;
         pXRenderFillRectangle( gdi_display, PictOpSrc, pict, &col, 0, 0, 1, 1 );
     }
-    pthread_mutex_unlock( &xrender_mutex );
+    pi_mutex_unlock( &xrender_mutex );
     return pict;
 }
 
@@ -866,11 +866,11 @@ static HFONT xrenderdrv_SelectFont( PHYS
 
     lfsz_calc_hash(&lfsz);
 
-    pthread_mutex_lock( &xrender_mutex );
+    pi_mutex_lock( &xrender_mutex );
     if (physdev->cache_index != -1)
         dec_ref_cache( physdev->cache_index );
     physdev->cache_index = GetCacheEntry( &lfsz );
-    pthread_mutex_unlock( &xrender_mutex );
+    pi_mutex_unlock( &xrender_mutex );
     return ret;
 }
 
@@ -958,9 +958,9 @@ static BOOL xrenderdrv_DeleteDC( PHYSDEV
 
     free_xrender_picture( physdev );
 
-    pthread_mutex_lock( &xrender_mutex );
+    pi_mutex_lock( &xrender_mutex );
     if (physdev->cache_index != -1) dec_ref_cache( physdev->cache_index );
-    pthread_mutex_unlock( &xrender_mutex );
+    pi_mutex_unlock( &xrender_mutex );
 
     free( physdev );
     return TRUE;
@@ -1328,7 +1328,7 @@ static BOOL xrenderdrv_ExtTextOut( PHYSD
 
     if(count == 0) return TRUE;
 
-    pthread_mutex_lock( &xrender_mutex );
+    pi_mutex_lock( &xrender_mutex );
 
     entry = glyphsetCache + physdev->cache_index;
     formatEntry = entry->format[type][aa_type_from_flags( physdev->aa_flags )];
@@ -1345,7 +1345,7 @@ static BOOL xrenderdrv_ExtTextOut( PHYSD
     if (!formatEntry)
     {
         WARN("could not upload requested glyphs\n");
-        pthread_mutex_unlock( &xrender_mutex );
+        pi_mutex_unlock( &xrender_mutex );
         return FALSE;
     }
 
@@ -1416,7 +1416,7 @@ static BOOL xrenderdrv_ExtTextOut( PHYSD
                             0, 0, 0, 0, elts, count);
     free( elts );
 
-    pthread_mutex_unlock( &xrender_mutex );
+    pi_mutex_unlock( &xrender_mutex );
     add_device_bounds( physdev->x11dev, &bounds );
     return TRUE;
 }
@@ -1533,7 +1533,7 @@ static void xrender_mono_blit( Picture s
      * contains a 1x1 picture for tiling. The source data effectively acts as an alpha channel to
      * the tile data.
      */
-    pthread_mutex_lock( &xrender_mutex );
+    pi_mutex_lock( &xrender_mutex );
     color = *bg;
     color.alpha = 0xffff;  /* tile pict needs 100% alpha */
     tile_pict = get_tile_pict( dst_format, &color );
@@ -1557,7 +1557,7 @@ static void xrender_mono_blit( Picture s
     }
     pXRenderComposite(gdi_display, PictOpOver, tile_pict, src_pict, dst_pict,
                       0, 0, x_offset, y_offset, x_dst, y_dst, width_dst, height_dst );
-    pthread_mutex_unlock( &xrender_mutex );
+    pi_mutex_unlock( &xrender_mutex );
 
     /* force the alpha channel for background pixels, it has been set to 100% by the tile */
     if (bg->alpha != 0xffff && (dst_format == WXR_FORMAT_A8R8G8B8 || dst_format == WXR_FORMAT_B8G8R8A8))
@@ -1895,7 +1895,7 @@ static DWORD xrenderdrv_BlendImage( PHYS
 
         dst_pict = get_xrender_picture( physdev, 0, &dst->visrect );
 
-        pthread_mutex_lock( &xrender_mutex );
+        pi_mutex_lock( &xrender_mutex );
         mask_pict = get_mask_pict( func.SourceConstantAlpha * 257 );
 
         xrender_blit( PictOpOver, src_pict, mask_pict, dst_pict,
@@ -1907,7 +1907,7 @@ static DWORD xrenderdrv_BlendImage( PHYS
         pXRenderFreePicture( gdi_display, src_pict );
         XFreePixmap( gdi_display, src_pixmap );
 
-        pthread_mutex_unlock( &xrender_mutex );
+        pi_mutex_unlock( &xrender_mutex );
         add_device_bounds( physdev->x11dev, &dst->visrect );
     }
     return ret;
@@ -1984,7 +1984,7 @@ static BOOL xrenderdrv_AlphaBlend( PHYSD
 
     if (tmp_pict) src_pict = tmp_pict;
 
-    pthread_mutex_lock( &xrender_mutex );
+    pi_mutex_lock( &xrender_mutex );
     mask_pict = get_mask_pict( blendfn.SourceConstantAlpha * 257 );
 
     xrender_blit( PictOpOver, src_pict, mask_pict, dst_pict,
@@ -1998,7 +1998,7 @@ static BOOL xrenderdrv_AlphaBlend( PHYSD
     if (tmp_pict) pXRenderFreePicture( gdi_display, tmp_pict );
     if (tmp_pixmap) XFreePixmap( gdi_display, tmp_pixmap );
 
-    pthread_mutex_unlock( &xrender_mutex );
+    pi_mutex_unlock( &xrender_mutex );
     add_device_bounds( physdev_dst->x11dev, &dst->visrect );
     return TRUE;
 }
diff -Npur a/dlls/ws2_32/Makefile.in b/dlls/ws2_32/Makefile.in
--- a/dlls/ws2_32/Makefile.in	2024-05-01 15:46:47.352975766 -0500
+++ b/dlls/ws2_32/Makefile.in	2024-05-01 15:50:04.424920512 -0500
@@ -3,7 +3,7 @@ MODULE    = ws2_32.dll
 UNIXLIB   = ws2_32.so
 IMPORTLIB = ws2_32
 DELAYIMPORTS = dnsapi advapi32 iphlpapi user32
-UNIX_LIBS    = $(PTHREAD_LIBS)
+UNIX_LIBS    = $(PTHREAD_LIBS) -lrtpi
 
 C_SRCS = \
 	async.c \
diff -Npur a/dlls/ws2_32/unixlib.c b/dlls/ws2_32/unixlib.c
--- a/dlls/ws2_32/unixlib.c	2024-05-01 15:46:47.357975791 -0500
+++ b/dlls/ws2_32/unixlib.c	2024-05-01 15:50:03.652916932 -0500
@@ -29,6 +29,7 @@
 #include "config.h"
 #include <errno.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <stdarg.h>
 #include <unistd.h>
 #include <sys/types.h>
@@ -106,7 +107,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(winsock);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 #ifndef HAVE_LINUX_GETHOSTBYNAME_R_6
-static pthread_mutex_t host_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t host_mutex = PI_MUTEX_INIT(0);
 #endif
 
 #define MAP(x) {WS_ ## x, x}
@@ -921,18 +922,18 @@ static NTSTATUS unix_gethostbyaddr( void
         return ret;
     }
 #else
-    pthread_mutex_lock( &host_mutex );
+    pi_mutex_lock( &host_mutex );
 
     if (!(unix_host = gethostbyaddr( addr, params->len, unix_family )))
     {
         ret = (h_errno < 0 ? errno_from_unix( errno ) : host_errno_from_unix( h_errno ));
-        pthread_mutex_unlock( &host_mutex );
+        pi_mutex_unlock( &host_mutex );
         return ret;
     }
 
     ret = hostent_from_unix( unix_host, params->host, params->size );
 
-    pthread_mutex_unlock( &host_mutex );
+    pi_mutex_unlock( &host_mutex );
     return ret;
 #endif
 }
@@ -1020,19 +1021,19 @@ static NTSTATUS unix_gethostbyname( void
     struct hostent *unix_host;
     int ret;
 
-    pthread_mutex_lock( &host_mutex );
+    pi_mutex_lock( &host_mutex );
 
     if (!(unix_host = gethostbyname( params->name )))
     {
         ret = (h_errno < 0 ? errno_from_unix( errno ) : host_errno_from_unix( h_errno ));
-        pthread_mutex_unlock( &host_mutex );
+        pi_mutex_unlock( &host_mutex );
         return ret;
     }
 
     sort_addrs_hashed( unix_host );
     ret = hostent_from_unix( unix_host, params->host, params->size );
 
-    pthread_mutex_unlock( &host_mutex );
+    pi_mutex_unlock( &host_mutex );
     return ret;
 }
 #endif
diff -Npur a/libs/fluidsynth/src/utils/fluid_sys.c b/libs/fluidsynth/src/utils/fluid_sys.c
--- a/libs/fluidsynth/src/utils/fluid_sys.c	2024-05-01 15:46:47.417976089 -0500
+++ b/libs/fluidsynth/src/utils/fluid_sys.c	2024-05-01 15:50:01.345906230 -0500
@@ -34,6 +34,7 @@
 // Do not include pthread on windows. It includes winsock.h, which collides with ws2tcpip.h from fluid_sys.h
 // It isn't need on Windows anyway.
 #include <pthread.h>
+#include <rtpi.h>
 #endif
 
 /* WIN32 HACK - Flag used to differentiate between a file descriptor and a socket.
diff -Npur a/libs/lcms2/src/lcms2_internal.h b//libs/lcms2/src/lcms2_internal.h
--- a/libs/lcms2/src/lcms2_internal.h	2024-05-03 17:21:02.527903386 -0500
+++ b//libs/lcms2/src/lcms2_internal.h	2024-05-03 17:26:05.890524822 -0500
@@ -321,39 +321,40 @@ cmsINLINE int _cmsLeaveCriticalSectionPr
 
 // Rest of the wide world
 #include <pthread.h>
+#include <rtpi.h>
 
-#define CMS_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
-typedef pthread_mutex_t _cmsMutex;
+#define CMS_MUTEX_INITIALIZER PI_MUTEX_INIT(0)
+typedef pi_mutex_t _cmsMutex;
 
 
 cmsINLINE int _cmsLockPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_lock(m);
+    return pi_mutex_lock(m);
 }
 
 cmsINLINE int _cmsUnlockPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_unlock(m);
+    return pi_mutex_unlock(m);
 }
 
 cmsINLINE int _cmsInitMutexPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_init(m, NULL);
+    return pi_mutex_init(m, 0);
 }
 
 cmsINLINE int _cmsDestroyMutexPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_destroy(m);
+    return pi_mutex_destroy(m);
 }
 
 cmsINLINE int _cmsEnterCriticalSectionPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_lock(m);
+    return pi_mutex_lock(m);
 }
 
 cmsINLINE int _cmsLeaveCriticalSectionPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_unlock(m);
+    return pi_mutex_unlock(m);
 }
 
 #endif
diff -Npur a/libs/ldap/include/ldap_int_thread.h b/libs/ldap/include/ldap_int_thread.h
--- a/libs/ldap/include/ldap_int_thread.h	2024-05-01 15:46:41.020944233 -0500
+++ b/libs/ldap/include/ldap_int_thread.h	2024-05-01 15:50:01.458906755 -0500
@@ -34,6 +34,7 @@ LDAP_END_DECL
  **********************************/
 
 #include <pthread.h>
+#include <rtpi.h>
 #ifdef HAVE_SCHED_H
 #include <sched.h>
 #endif
@@ -41,8 +42,8 @@ LDAP_END_DECL
 LDAP_BEGIN_DECL
 
 typedef pthread_t		ldap_int_thread_t;
-typedef pthread_mutex_t		ldap_int_thread_mutex_t;
-typedef pthread_cond_t		ldap_int_thread_cond_t;
+typedef pi_mutex_t		ldap_int_thread_mutex_t;
+typedef pi_cond_t		ldap_int_thread_cond_t;
 typedef pthread_key_t		ldap_int_thread_key_t;
 
 #define ldap_int_thread_equal(a, b)	pthread_equal((a), (b))
@@ -69,7 +70,7 @@ typedef pthread_rwlock_t ldap_int_thread
 #endif
 
 #ifndef LDAP_INT_MUTEX_NULL
-#define LDAP_INT_MUTEX_NULL	PTHREAD_MUTEX_INITIALIZER
+#define LDAP_INT_MUTEX_NULL	PI_MUTEX_INIT(0)
 #define LDAP_INT_MUTEX_FIRSTCREATE(m)	((void) 0)
 #endif
 
diff -Npur a/libs/vkd3d/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h	2024-05-01 15:47:09.793086858 -0500
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h	2024-05-01 15:50:01.658907683 -0500
@@ -288,6 +288,7 @@ static inline void *vkd3d_atomic_exchang
 #else  /* _WIN32 */
 
 #include <pthread.h>
+#include <rtpi.h>
 
 union vkd3d_thread_handle
 {
@@ -297,12 +298,12 @@ union vkd3d_thread_handle
 
 struct vkd3d_mutex
 {
-    pthread_mutex_t lock;
+    pi_mutex_t lock;
 };
 
 struct vkd3d_cond
 {
-    pthread_cond_t cond;
+    pi_cond_t cond;
 };
 
 
@@ -310,7 +311,7 @@ static inline void vkd3d_mutex_init(stru
 {
     int ret;
 
-    ret = pthread_mutex_init(&lock->lock, NULL);
+    ret = pi_mutex_init(&lock->lock, 0);
     if (ret)
         ERR("Could not initialize the mutex, error %d.\n", ret);
 }
@@ -319,7 +319,7 @@ static inline void vkd3d_mutex_lock(stru
 {
     int ret;
 
-    ret = pthread_mutex_lock(&lock->lock);
+    ret = pi_mutex_lock(&lock->lock);
     if (ret)
         ERR("Could not lock the mutex, error %d.\n", ret);
 }
@@ -328,7 +328,7 @@ static inline void vkd3d_mutex_unlock(st
 {
     int ret;
 
-    ret = pthread_mutex_unlock(&lock->lock);
+    ret = pi_mutex_unlock(&lock->lock);
     if (ret)
         ERR("Could not unlock the mutex, error %d.\n", ret);
 }
@@ -337,7 +338,7 @@ static inline void vkd3d_mutex_destroy(s
 {
     int ret;
 
-    ret = pthread_mutex_destroy(&lock->lock);
+    ret = pi_mutex_destroy(&lock->lock);
     if (ret)
         ERR("Could not destroy the mutex, error %d.\n", ret);
 }
@@ -346,7 +346,7 @@ static inline void vkd3d_cond_init(struc
 {
     int ret;
 
-    ret = pthread_cond_init(&cond->cond, NULL);
+    ret = pi_cond_init(&cond->cond, 0);
     if (ret)
         ERR("Could not initialize the condition variable, error %d.\n", ret);
 }
@@ -355,7 +355,7 @@ static inline void vkd3d_cond_signal(str
 {
     int ret;
 
-    ret = pthread_cond_signal(&cond->cond);
+    ret = pi_cond_signal(&cond->cond, &lock->lock);
     if (ret)
         ERR("Could not signal the condition variable, error %d.\n", ret);
 }
@@ -364,7 +364,7 @@ static inline void vkd3d_cond_broadcast(
 {
     int ret;
 
-    ret = pthread_cond_broadcast(&cond->cond);
+    ret = pi_cond_broadcast(&cond->cond, &lock->lock);
     if (ret)
         ERR("Could not broadcast the condition variable, error %d.\n", ret);
 }
@@ -373,7 +373,7 @@ static inline void vkd3d_cond_wait(struc
 {
     int ret;
 
-    ret = pthread_cond_wait(&cond->cond, &lock->lock);
+    ret = pi_cond_wait(&cond->cond, &lock->lock, &lock->lock);
     if (ret)
         ERR("Could not wait on the condition variable, error %d.\n", ret);
 }
@@ -382,7 +382,7 @@ static inline void vkd3d_cond_destroy(st
 {
     int ret;
 
-    ret = pthread_cond_destroy(&cond->cond);
+    ret = pi_cond_destroy(&cond->cond);
     if (ret)
         ERR("Could not destroy the condition variable, error %d.\n", ret);
 }
diff -Npur a/libs/vkd3d/libs/vkd3d-common/debug.c b/libs/vkd3d/libs/vkd3d-common/debug.c
--- a/libs/vkd3d/libs/vkd3d-common/debug.c	2024-05-01 15:46:47.446976234 -0500
+++ b/libs/vkd3d/libs/vkd3d-common/debug.c	2024-05-01 15:50:01.661907697 -0500
@@ -34,6 +34,7 @@
 #include <unistd.h>
 #ifdef HAVE_PTHREAD_H
 #include <pthread.h>
+#include <rtpi.h>
 #endif
 
 #include "vkd3d_memory.h"
diff -Npur a/libs/xml2/include/private/threads.h b/libs/xml2/include/private/threads.h
--- a/libs/xml2/include/private/threads.h	2024-05-01 15:46:41.078944522 -0500
+++ b/libs/xml2/include/private/threads.h	2024-05-01 15:50:01.422906588 -0500
@@ -6,6 +6,7 @@
 #ifdef LIBXML_THREAD_ENABLED
   #ifdef HAVE_PTHREAD_H
     #include <pthread.h>
+#include <rtpi.h>
     #define HAVE_POSIX_THREADS
   #elif defined(_WIN32)
     #define WIN32_LEAN_AND_MEAN
@@ -22,7 +23,7 @@
  */
 struct _xmlMutex {
 #ifdef HAVE_POSIX_THREADS
-    pthread_mutex_t lock;
+    pi_mutex_t lock;
 #elif defined HAVE_WIN32_THREADS
     CRITICAL_SECTION cs;
 #else
diff -Npur a/libs/xml2/threads.c b//libs/xml2/threads.c
--- a/libs/xml2/threads.c	2024-05-03 17:20:59.207929109 -0500
+++ b//libs/xml2/threads.c	2024-05-03 17:26:05.474522395 -0500
@@ -64,18 +64,18 @@
 #pragma weak pthread_setspecific
 #pragma weak pthread_key_create
 #pragma weak pthread_key_delete
-#pragma weak pthread_mutex_init
-#pragma weak pthread_mutex_destroy
-#pragma weak pthread_mutex_lock
-#pragma weak pthread_mutex_unlock
-#pragma weak pthread_cond_init
-#pragma weak pthread_cond_destroy
-#pragma weak pthread_cond_wait
+#pragma weak pi_mutex_init
+#pragma weak pi_mutex_destroy
+#pragma weak pi_mutex_lock
+#pragma weak pi_mutex_unlock
+#pragma weak pi_cond_init
+#pragma weak pi_cond_destroy
+#pragma weak pi_cond_wait
 #pragma weak pthread_equal
 #pragma weak pthread_self
 #pragma weak pthread_key_create
 #pragma weak pthread_key_delete
-#pragma weak pthread_cond_signal
+#pragma weak pi_cond_signal
 
 #define XML_PTHREAD_WEAK
 #define XML_IS_THREADED() libxml_is_threaded
@@ -101,11 +100,11 @@ static int libxml_is_threaded = -1;
  */
 struct _xmlRMutex {
 #ifdef HAVE_POSIX_THREADS
-    pthread_mutex_t lock;
+    pi_mutex_t lock;
     unsigned int held;
     unsigned int waiters;
     pthread_t tid;
-    pthread_cond_t cv;
+    pi_cond_t cv;
 #elif defined HAVE_WIN32_THREADS
     CRITICAL_SECTION cs;
 #else
@@ -122,7 +121,7 @@ struct _xmlRMutex {
 #ifdef HAVE_POSIX_THREADS
 static pthread_key_t globalkey;
 static pthread_t mainthread;
-static pthread_mutex_t global_init_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t global_init_lock = PI_MUTEX_INIT(0);
 #elif defined HAVE_WIN32_THREADS
 #if defined(HAVE_COMPILER_TLS)
 static __declspec(thread) xmlGlobalState tlstate;
@@ -147,7 +147,7 @@ xmlInitMutex(xmlMutexPtr mutex)
 {
 #ifdef HAVE_POSIX_THREADS
     if (XML_IS_NEVER_THREADED() == 0)
-        pthread_mutex_init(&mutex->lock, NULL);
+        pi_mutex_init(&mutex->lock, 0);
 #elif defined HAVE_WIN32_THREADS
     InitializeCriticalSection(&mutex->cs);
 #else
@@ -185,7 +185,7 @@ xmlCleanupMutex(xmlMutexPtr mutex)
 {
 #ifdef HAVE_POSIX_THREADS
     if (XML_IS_NEVER_THREADED() == 0)
-        pthread_mutex_destroy(&mutex->lock);
+        pi_mutex_destroy(&mutex->lock);
 #elif defined HAVE_WIN32_THREADS
     DeleteCriticalSection(&mutex->cs);
 #else
@@ -226,7 +226,7 @@ xmlMutexLock(xmlMutexPtr tok)
      * lock is held.
      */
     if (XML_IS_THREADED() != 0)
-        pthread_mutex_lock(&tok->lock);
+        pi_mutex_lock(&tok->lock);
 #elif defined HAVE_WIN32_THREADS
     EnterCriticalSection(&tok->cs);
 #endif
@@ -246,7 +244,7 @@ xmlMutexUnlock(xmlMutexPtr tok)
         return;
 #ifdef HAVE_POSIX_THREADS
     if (XML_IS_THREADED() != 0)
-        pthread_mutex_unlock(&tok->lock);
+        pi_mutex_unlock(&tok->lock);
 #elif defined HAVE_WIN32_THREADS
     LeaveCriticalSection(&tok->cs);
 #endif
@@ -271,10 +271,10 @@ xmlNewRMutex(void)
         return (NULL);
 #ifdef HAVE_POSIX_THREADS
     if (XML_IS_NEVER_THREADED() == 0) {
-        pthread_mutex_init(&tok->lock, NULL);
+        pi_mutex_init(&tok->lock, 0);
         tok->held = 0;
         tok->waiters = 0;
-        pthread_cond_init(&tok->cv, NULL);
+        pi_cond_init(&tok->cv, 0);
     }
 #elif defined HAVE_WIN32_THREADS
     InitializeCriticalSection(&tok->cs);
@@ -296,8 +296,8 @@ xmlFreeRMutex(xmlRMutexPtr tok ATTRIBUTE
         return;
 #ifdef HAVE_POSIX_THREADS
     if (XML_IS_NEVER_THREADED() == 0) {
-        pthread_mutex_destroy(&tok->lock);
-        pthread_cond_destroy(&tok->cv);
+        pi_mutex_destroy(&tok->lock);
+        pi_cond_destroy(&tok->cv);
     }
 #elif defined HAVE_WIN32_THREADS
     DeleteCriticalSection(&tok->cs);
@@ -320,22 +317,22 @@ xmlRMutexLock(xmlRMutexPtr tok)
     if (XML_IS_THREADED() == 0)
         return;
 
-    pthread_mutex_lock(&tok->lock);
+    pi_mutex_lock(&tok->lock);
     if (tok->held) {
         if (pthread_equal(tok->tid, pthread_self())) {
             tok->held++;
-            pthread_mutex_unlock(&tok->lock);
+            pi_mutex_unlock(&tok->lock);
             return;
         } else {
             tok->waiters++;
             while (tok->held)
-                pthread_cond_wait(&tok->cv, &tok->lock);
+                pi_cond_wait(&tok->cv, &tok->lock);
             tok->waiters--;
         }
     }
     tok->tid = pthread_self();
     tok->held = 1;
-    pthread_mutex_unlock(&tok->lock);
+    pi_mutex_unlock(&tok->lock);
 #elif defined HAVE_WIN32_THREADS
     EnterCriticalSection(&tok->cs);
 #endif
@@ -356,14 +353,14 @@ xmlRMutexUnlock(xmlRMutexPtr tok ATTRIBU
     if (XML_IS_THREADED() == 0)
         return;
 
-    pthread_mutex_lock(&tok->lock);
+    pi_mutex_lock(&tok->lock);
     tok->held--;
     if (tok->held == 0) {
         if (tok->waiters)
-            pthread_cond_signal(&tok->cv);
+            pi_cond_signal(&tok->cv, &tok->lock);
         memset(&tok->tid, 0, sizeof(tok->tid));
     }
-    pthread_mutex_unlock(&tok->lock);
+    pi_mutex_unlock(&tok->lock);
 #elif defined HAVE_WIN32_THREADS
     LeaveCriticalSection(&tok->cs);
 #endif
@@ -381,14 +378,14 @@ __xmlGlobalInitMutexLock(void)
     /* Make sure the global init lock is initialized and then lock it. */
 #ifdef HAVE_POSIX_THREADS
 #ifdef XML_PTHREAD_WEAK
-    if (pthread_mutex_lock == NULL)
+    if (pi_mutex_lock == NULL)
         return;
 #else
     if (XML_IS_THREADED() == 0)
         return;
 #endif
     /* The mutex is statically initialized, so we just lock it. */
-    pthread_mutex_lock(&global_init_lock);
+    pi_mutex_lock(&global_init_lock);
 #elif defined HAVE_WIN32_THREADS
     LPCRITICAL_SECTION cs;
 
@@ -430,13 +427,13 @@ __xmlGlobalInitMutexUnlock(void)
 {
 #ifdef HAVE_POSIX_THREADS
 #ifdef XML_PTHREAD_WEAK
-    if (pthread_mutex_lock == NULL)
+    if (pi_mutex_lock == NULL)
         return;
 #else
     if (XML_IS_THREADED() == 0)
         return;
 #endif
-    pthread_mutex_unlock(&global_init_lock);
+    pi_mutex_unlock(&global_init_lock);
 #elif defined HAVE_WIN32_THREADS
     if (global_init_lock != NULL) {
 	LeaveCriticalSection(global_init_lock);
@@@ -765,20 +765,20 @@ xmlInitThreadsInternal(void)
             (pthread_setspecific != NULL) &&
             (pthread_key_create != NULL) &&
             (pthread_key_delete != NULL) &&
-            (pthread_mutex_init != NULL) &&
-            (pthread_mutex_destroy != NULL) &&
-            (pthread_mutex_lock != NULL) &&
-            (pthread_mutex_unlock != NULL) &&
-            (pthread_cond_init != NULL) &&
-            (pthread_cond_destroy != NULL) &&
-            (pthread_cond_wait != NULL) &&
+            (pi_mutex_init != NULL) &&
+            (pi_mutex_destroy != NULL) &&
+            (pi_mutex_lock != NULL) &&
+            (pi_mutex_unlock != NULL) &&
+            (pi_cond_init != NULL) &&
+            (pi_cond_destroy != NULL) &&
+            (pi_cond_wait != NULL) &&
             /*
              * pthread_equal can be inline, resuting in -Waddress warnings.
              * Let's assume it's available if all the other functions are.
              */
             /* (pthread_equal != NULL) && */
             (pthread_self != NULL) &&
-            (pthread_cond_signal != NULL);
+            (pi_cond_signal != NULL);
     if (libxml_is_threaded == 0)
         return;
 #endif /* XML_PTHREAD_WEAK */
diff -Npur a/loader/main.c b/loader/main.c
--- a/loader/main.c	2024-05-01 15:46:47.510976552 -0500
+++ b/loader/main.c	2024-05-01 15:50:04.260919751 -0500
@@ -22,6 +22,7 @@
 
 #include <fcntl.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff -Npur a/loader/Makefile.in b/loader/Makefile.in
--- a/loader/Makefile.in	2024-05-01 15:46:41.131944786 -0500
+++ b/loader/Makefile.in	2024-05-01 15:50:04.431920544 -0500
@@ -20,11 +20,11 @@ main_EXTRADEFS = -DDLLDIR=\"${dlldir}\"
 
 wine_OBJS = main.o
 wine_DEPS = $(WINELOADER_DEPENDS)
-wine_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS)
+wine_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS) -lrtpi
 
 wine64_OBJS = main.o
 wine64_DEPS = $(WINELOADER_DEPENDS)
-wine64_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS)
+wine64_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS) -lrtpi
 
 wine_preloader_OBJS = preloader.o preloader_mac.o
 wine_preloader_DEPS = $(WINELOADER_DEPENDS)
diff -Npur a/server/fd.c b/server/fd.c
--- a/server/fd.c	2024-05-01 15:47:17.805126280 -0500
+++ b/server/fd.c	2024-05-01 15:50:01.672907748 -0500
@@ -27,6 +27,7 @@
 #include <fcntl.h>
 #include <limits.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <stdarg.h>
 #include <stdio.h>
@@ -412,7 +413,7 @@ static void set_user_shared_data_time(ti
  
 #undef ATOMIC_STORE
 
-pthread_mutex_t global_lock = PTHREAD_MUTEX_INITIALIZER;
+pi_mutex_t global_lock = PI_MUTEX_INIT(0);
 int poll_exit_pipe[2];
 struct fd *poll_exit_fd;
 
@@ -595,7 +596,7 @@ static inline void main_loop_epoll(void)
 
     if (epoll_fd == -1) return;
 
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
     while (active_users)
     {
         unsigned long generation;
@@ -606,9 +607,9 @@ static inline void main_loop_epoll(void)
         if (epoll_fd == -1) break;  /* an error occurred with epoll */
 
         generation = poll_generation;
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
         ret = epoll_wait( epoll_fd, events, ARRAY_SIZE( events ), timeout );
-        pthread_mutex_lock( &global_lock );
+        pi_mutex_lock( &global_lock );
         set_current_time();
 
         /* put the events into the pollfd array first, like poll does */
@@ -627,7 +628,7 @@ static inline void main_loop_epoll(void)
             if (pollfd[user].revents) fd_poll_event( poll_users[user], pollfd[user].revents );
         }
     }
-    pthread_mutex_unlock( &global_lock );
+    pi_mutex_unlock( &global_lock );
 }
 
 #elif defined(HAVE_KQUEUE)
@@ -698,7 +699,7 @@ static inline void main_loop_epoll(void)
 
     if (kqueue_fd == -1) return;
 
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
     while (active_users)
     {
         unsigned long generation;
@@ -709,7 +710,7 @@ static inline void main_loop_epoll(void)
         if (kqueue_fd == -1) break;  /* an error occurred with kqueue */
 
         generation = poll_generation;
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
         if (timeout != -1)
         {
             struct timespec ts;
@@ -719,7 +720,7 @@ static inline void main_loop_epoll(void)
             ret = kevent( kqueue_fd, NULL, 0, events, ARRAY_SIZE( events ), &ts );
         }
         else ret = kevent( kqueue_fd, NULL, 0, events, ARRAY_SIZE( events ), NULL );
-        pthread_mutex_lock( &global_lock );
+        pi_mutex_lock( &global_lock );
 
         set_current_time();
 
@@ -749,7 +750,7 @@ static inline void main_loop_epoll(void)
             pollfd[user].revents = 0;
         }
     }
-    pthread_mutex_unlock( &global_lock );
+    pi_mutex_unlock( &global_lock );
 }
 
 #elif defined(USE_EVENT_PORTS)
@@ -810,7 +811,7 @@ static inline void main_loop_epoll(void)
 
     if (port_fd == -1) return;
 
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
     while (active_users)
     {
         unsigned long generation;
@@ -822,7 +823,7 @@ static inline void main_loop_epoll(void)
         if (port_fd == -1) break;  /* an error occurred with event completion */
 
         generation = poll_generation;
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
         if (timeout != -1)
         {
             struct timespec ts;
@@ -832,7 +833,7 @@ static inline void main_loop_epoll(void)
             ret = port_getn( port_fd, events, ARRAY_SIZE( events ), &nget, &ts );
         }
         else ret = port_getn( port_fd, events, ARRAY_SIZE( events ), &nget, NULL );
-        pthread_mutex_lock( &global_lock );
+        pi_mutex_lock( &global_lock );
 
 	if (ret == -1) break;  /* an error occurred with event completion */
 
@@ -858,7 +859,7 @@ static inline void main_loop_epoll(void)
             }
         }
     }
-    pthread_mutex_unlock( &global_lock );
+    pi_mutex_unlock( &global_lock );
 }
 
 #else /* HAVE_KQUEUE */
@@ -1064,7 +1065,7 @@ void main_loop(void)
     main_loop_epoll();
     /* fall through to normal poll loop */
 
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
     while (active_users)
     {
         unsigned long generation;
@@ -1074,9 +1075,9 @@ void main_loop(void)
         if (!active_users) break;  /* last user removed by a timeout */
 
         generation = poll_generation;
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
         ret = poll( pollfd, nb_users, timeout );
-        pthread_mutex_lock( &global_lock );
+        pi_mutex_lock( &global_lock );
         set_current_time();
 
         if (ret > 0)
@@ -1091,7 +1092,7 @@ void main_loop(void)
                 }
             }
         }
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
     }
 }
 
diff -Npur a/server/file.h b/server/file.h
--- a/server/file.h	2024-05-01 15:47:17.512124841 -0500
+++ b/server/file.h	2024-05-01 15:50:01.672907748 -0500
@@ -22,6 +22,7 @@
 #define __WINE_SERVER_FILE_H
 
 #include <pthread.h>
+#include <rtpi.h>
 #include <sys/types.h>
 
 #include "object.h"
@@ -80,7 +81,7 @@ struct fd_ops
 
 /* file descriptor functions */
 
-extern pthread_mutex_t global_lock;
+extern pi_mutex_t global_lock;
 extern unsigned long poll_generation;
 
 extern struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *user,
diff -Npur a/server/Makefile.in b/server/Makefile.in
--- a/server/Makefile.in	2024-05-01 15:47:17.308123838 -0500
+++ b/server/Makefile.in	2024-05-01 15:50:04.327920062 -0500
@@ -50,6 +50,6 @@ SOURCES = \
 	wineserver.man.in \
 	winstation.c
 
-UNIX_LIBS = $(LDEXECFLAGS) $(RT_LIBS) $(INOTIFY_LIBS) $(PROCSTAT_LIBS) $(DBUS_LIBS) $(PTHREAD_LIBS)
+UNIX_LIBS = $(LDEXECFLAGS) $(RT_LIBS) $(INOTIFY_LIBS) $(PROCSTAT_LIBS) $(DBUS_LIBS) $(PTHREAD_LIBS) -lrtpi
 
 unicode_EXTRADEFS = -DNLSDIR="\"${nlsdir}\"" -DBIN_TO_NLSDIR=\"`${MAKEDEP} -R ${bindir} ${nlsdir}`\"
diff -Npur a/server/scheduler.c b/server/scheduler.c
--- a/server/scheduler.c	2024-05-01 15:47:17.206123337 -0500
+++ b/server/scheduler.c	2024-05-01 15:50:01.690907831 -0500
@@ -45,6 +45,7 @@
 #include "thread.h"
 #include <unistd.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #if defined(__linux__) && defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_SCHED_H)
 
diff -Npur a/server/thread.c b/server/thread.c
--- a/server/thread.c	2024-05-01 15:47:17.785126182 -0500
+++ b/server/thread.c	2024-05-01 15:50:01.699907873 -0500
@@ -24,6 +24,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <stdarg.h>
 #include <stdio.h>
@@ -407,10 +408,10 @@ static void *request_shm_thread(void *pa
     volatile struct request_shm *request_shm;
     unsigned long generation = 0;
 
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
     request_shm_fd = thread->request_shm_fd;
     request_shm = thread->request_shm;
-    pthread_mutex_unlock( &global_lock );
+    pi_mutex_unlock( &global_lock );
 
     for (;;)
     {
@@ -425,7 +426,7 @@ static void *request_shm_thread(void *pa
             syscall( __NR_futex, &request_shm->futex, FUTEX_WAIT, val, NULL, NULL, 0 );
         }
 
-        pthread_mutex_lock( &global_lock );
+        pi_mutex_lock( &global_lock );
         generation = poll_generation;
 
         val = request_shm->futex;
@@ -447,19 +448,19 @@ static void *request_shm_thread(void *pa
         val = __sync_val_compare_and_swap( &request_shm->futex, 1, 0 );
         if (val != 1 && val != -1)
             fatal_protocol_error( thread, "unknown futex state %d\n", val );
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
         syscall( __NR_futex, &request_shm->futex, FUTEX_WAKE, 1, NULL, NULL, 0 );
         if (poll_generation != generation)
             force_exit_poll();
     }
 
 done:
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
 done_locked:
     if (request_shm_fd != -1) close( request_shm_fd );
     if (request_shm) munmap( (void*)request_shm, REQUEST_SHM_SIZE );
     release_object( thread );
-    pthread_mutex_unlock( &global_lock );
+    pi_mutex_unlock( &global_lock );
    if (poll_generation != generation)
         force_exit_poll();
     return NULL;


// Fixups

--- a/dlls/winegstreamer/wg_parser.c	2024-05-01 17:03:12.373850865 -0500
+++ b/dlls/winegstreamer/wg_parser.c	2024-05-01 17:02:12.685654900 -0500
@@ -29,6 +29,7 @@
 #include <assert.h>
 #include <stdarg.h>
 #include <stdio.h>
+#include <rtpi.h>
 
 #include <gst/gst.h>
 #include <gst/video/video.h>
--- a/dlls/winegstreamer/wg_allocator.c	2024-05-01 17:06:37.603538212 -0500
+++ b/dlls/winegstreamer/wg_allocator.c	2024-05-01 17:05:51.186381160 -0500
@@ -26,6 +26,7 @@
 
 #include <assert.h>
 #include <stdarg.h>
+#include <rtpi.h>
 
 #include <gst/gst.h>
 #include <gst/video/video.h>

--- a/dlls/opengl32/Makefile.in	2024-05-01 17:44:00.990968006 -0500
+++ b/dlls/opengl32/Makefile.in	2024-05-01 17:43:43.993902574 -0500
@@ -4,7 +4,7 @@ EXTRADEFS = -D_OPENGL32_
 IMPORTLIB = opengl32
 IMPORTS   = user32 gdi32 advapi32 win32u
 DELAYIMPORTS = glu32
-UNIX_LIBS    = -lwin32u
+UNIX_LIBS    = -lwin32u -lrtpi
 
 EXTRADLLFLAGS = -Wl,--image-base,0x7a800000
 
--- a/dlls/winegstreamer/wg_allocator.c	2024-05-03 18:08:15.219558038 -0500
+++ b/dlls/winegstreamer/wg_allocator.c	2024-05-03 18:07:50.952489372 -0500
@@ -164,6 +164,7 @@ static void wg_allocator_init(WgAllocato
 
     GST_OBJECT_FLAG_SET(allocator, GST_ALLOCATOR_FLAG_CUSTOM_ALLOC);
 
+    pi_mutex_init(&allocator->mutex, 0);
     pi_cond_init(&allocator->release_cond, 0);
     list_init(&allocator->memory_list);
 }
@@ -175,7 +176,7 @@ static void wg_allocator_finalize(GObjec
     GST_LOG("allocator %p", allocator);
 
     pi_cond_destroy(&allocator->release_cond);
-    pthread_mutex_destroy(&allocator->mutex);
+    pi_mutex_destroy(&allocator->mutex);
 
     G_OBJECT_CLASS(wg_allocator_parent_class)->finalize(object);
 }

--- a/dlls/winewayland.drv/wayland_surface.c	2024-05-03 18:22:08.851550035 -0500
+++ b/dlls/winewayland.drv/wayland_surface.c	2024-05-03 18:21:56.065522609 -0500
@@ -208,7 +208,7 @@ void wayland_surface_destroy(struct wayl
 
     wl_display_flush(process_wayland.wl_display);
 
-    pthread_mutex_destroy(&surface->mutex);
+    pi_mutex_destroy(&surface->mutex);
 
     free(surface);
 }

