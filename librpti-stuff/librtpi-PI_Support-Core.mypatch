diff -Npur a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
--- a/dlls/ntdll/Makefile.in	2024-05-01 15:47:14.064107889 -0500
+++ b/dlls/ntdll/Makefile.in	2024-05-01 15:50:04.364920233 -0500
@@ -4,7 +4,7 @@ UNIXLIB   = ntdll.so
 IMPORTLIB = ntdll
 IMPORTS   = $(MUSL_PE_LIBS) winecrt0
 UNIX_CFLAGS  = $(UNWIND_CFLAGS)
-UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS) -lm
+UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS) -lm -lrtpi
 
 EXTRADLLFLAGS = -nodefaultlibs
 i386_EXTRADLLFLAGS = -Wl,--image-base,0x7bc00000
diff -Npur a/dlls/ntdll/unix/cdrom.c b/dlls/ntdll/unix/cdrom.c
--- a/dlls/ntdll/unix/cdrom.c	2024-05-01 15:46:46.786972951 -0500
+++ b/dlls/ntdll/unix/cdrom.c	2024-05-01 15:50:02.236910365 -0500
@@ -290,7 +290,7 @@ struct cdrom_cache {
 #define MAX_CACHE_ENTRIES       5
 static struct cdrom_cache cdrom_cache[MAX_CACHE_ENTRIES];
 
-static pthread_mutex_t cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t cache_mutex = PI_MUTEX_INIT(0);
 
 /* Proposed media change function: not really needed at this time */
 /* This is a 1 or 0 type of function */
diff -Npur a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
--- a/dlls/ntdll/unix/esync.c	2024-05-01 15:47:17.773126123 -0500
+++ b/dlls/ntdll/unix/esync.c	2024-05-01 15:50:02.233910351 -0500
@@ -104,7 +104,7 @@ static void **shm_addrs;
 static int shm_addrs_size;  /* length of the allocated shm_addrs array */
 static long pagesize;
 
-static pthread_mutex_t shm_addrs_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t shm_addrs_mutex = PI_MUTEX_INIT(0);
 
 static void *get_shm( unsigned int idx )
 {
@@ -112,7 +112,7 @@ static void *get_shm( unsigned int idx )
     int offset = (idx * 8) % pagesize;
     void *ret;
 
-    pthread_mutex_lock( &shm_addrs_mutex );
+    pi_mutex_lock( &shm_addrs_mutex );
 
     if (entry >= shm_addrs_size)
     {
@@ -138,7 +138,7 @@ static void *get_shm( unsigned int idx )
 
     ret = (void *)((unsigned long)shm_addrs[entry] + offset);
 
-    pthread_mutex_unlock( &shm_addrs_mutex );
+    pi_mutex_unlock( &shm_addrs_mutex );
 
     return ret;
 }
diff -Npur a/dlls/ntdll/unix/esync.h b/dlls/ntdll/unix/esync.h
--- a/dlls/ntdll/unix/esync.h	2024-05-01 15:47:06.417070209 -0500
+++ b/dlls/ntdll/unix/esync.h	2024-05-01 15:50:02.232910346 -0500
@@ -56,6 +56,6 @@ extern NTSTATUS esync_signal_and_wait( H
  *
  * If we weren't trying to avoid touching the code I'd rename the mutex to
  * "server_fd_mutex" or something similar. */
-extern pthread_mutex_t fd_cache_mutex;
+extern pi_mutex_t fd_cache_mutex;
 
 extern int receive_fd( obj_handle_t *handle ) DECLSPEC_HIDDEN;
diff -Npur a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
--- a/dlls/ntdll/unix/file.c	2024-05-01 15:47:17.792126216 -0500
+++ b/dlls/ntdll/unix/file.c	2024-05-01 15:50:02.231910341 -0500
@@ -249,8 +249,8 @@ static mode_t start_umask;
 /* at some point we may want to allow Winelib apps to set this */
 static const BOOL is_case_sensitive = FALSE;
 
-static pthread_mutex_t dir_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t mnt_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t dir_mutex = PI_MUTEX_INIT(0);
+static pi_mutex_t mnt_mutex = PI_MUTEX_INIT(0);
 
 #ifndef HAVE_RENAMEAT2
 int renameat2( int olddirfd, const char *oldpath, int newdirfd, const char *newpath,
@@ -2328,7 +2328,7 @@ static unsigned int server_open_file_obj
 /* retrieve device/inode number for all the drives */
 static unsigned int get_drives_info( struct file_identity info[MAX_DOS_DRIVES] )
 {
-    static pthread_mutex_t cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+    static pi_mutex_t cache_mutex = PI_MUTEX_INIT(0);
     static struct file_identity cache[MAX_DOS_DRIVES];
     static time_t last_update;
     static unsigned int nb_drives;
@@ -6570,8 +6570,8 @@ static unsigned int set_pending_write( H
     return status;
 }
 
-static pthread_mutex_t async_file_read_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t async_file_read_cond = PTHREAD_COND_INITIALIZER;
+static pi_mutex_t async_file_read_mutex = PI_MUTEX_INIT(0);
+static pi_cond_t async_file_read_cond = PI_COND_INIT(0);
 
 struct async_file_read_job
 {
@@ -6611,12 +6611,12 @@ static void *async_file_read_thread(void
     ULONG total;
     int result;
 
-    pthread_mutex_lock( &async_file_read_mutex );
+    pi_mutex_lock( &async_file_read_mutex );
     while (1)
     {
         while (!(entry = list_head( &async_file_read_queue )))
         {
-            pthread_cond_wait( &async_file_read_cond, &async_file_read_mutex );
+            pi_cond_wait( &async_file_read_cond, &async_file_read_mutex );
             continue;
         }
 
@@ -6627,14 +6627,14 @@ static void *async_file_read_thread(void
 
         if ( job->cancelled )
         {
-            pthread_mutex_unlock( &async_file_read_mutex );
+            pi_mutex_unlock( &async_file_read_mutex );
             status = STATUS_CANCELLED;
             goto done;
         }
 
         job->next = async_file_read_running;
         async_file_read_running = job;
-        pthread_mutex_unlock( &async_file_read_mutex );
+        pi_mutex_unlock( &async_file_read_mutex );
 
         if (!buffer_length)
         {
@@ -6671,7 +6671,7 @@ done:
             async_file_complete_io( job, status, total );
         }
 
-        pthread_mutex_lock( &async_file_read_mutex );
+        pi_mutex_lock( &async_file_read_mutex );
 
         if (status != STATUS_CANCELLED)
         {
@@ -6723,7 +6723,7 @@ static NTSTATUS queue_async_file_read( H
 
     NtResetEvent( event, NULL );
 
-    pthread_mutex_lock( &async_file_read_mutex );
+    pi_mutex_lock( &async_file_read_mutex );
 
     if (async_file_read_free)
     {
@@ -6734,7 +6734,7 @@ static NTSTATUS queue_async_file_read( H
     {
         if (!(job = malloc( sizeof(*job) )))
         {
-            pthread_mutex_unlock( &async_file_read_mutex );
+            pi_mutex_unlock( &async_file_read_mutex );
             return STATUS_NO_MEMORY;
         }
     }
@@ -6752,8 +6752,8 @@ static NTSTATUS queue_async_file_read( H
 
     list_add_tail( &async_file_read_queue, &job->queue_entry );
 
-    pthread_cond_signal( &async_file_read_cond );
-    pthread_mutex_unlock( &async_file_read_mutex );
+    pi_cond_signal( &async_file_read_cond, &async_file_read_mutex );
+    pi_mutex_unlock( &async_file_read_mutex );
 
     return STATUS_PENDING;
 }
@@ -6766,7 +6766,7 @@ static NTSTATUS cancel_async_file_read(
 
     TRACE( "handle %p, io %p.\n", handle, io );
 
-    pthread_mutex_lock( &async_file_read_mutex );
+    pi_mutex_lock( &async_file_read_mutex );
     job = async_file_read_running;
     while (job)
     {
@@ -6791,7 +6791,7 @@ static NTSTATUS cancel_async_file_read(
         }
     }
 
-    pthread_mutex_unlock( &async_file_read_mutex );
+    pi_mutex_unlock( &async_file_read_mutex );
     return count ? STATUS_SUCCESS : STATUS_NOT_FOUND;
 }
 
diff -Npur a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
--- a/dlls/ntdll/unix/fsync.h	2024-05-01 15:47:17.729125907 -0500
+++ b/dlls/ntdll/unix/fsync.h	2024-05-01 15:50:02.232910346 -0500
@@ -51,4 +51,4 @@ extern NTSTATUS fsync_signal_and_wait( H
 /* We have to synchronize on the fd cache mutex so that fsync_close(), close_handle() sequence 
  * called from NtClose() doesn't race with get_fsync_idx(), add_to_list() sequence called
  * from get_object(). */
-extern pthread_mutex_t fd_cache_mutex;
+extern pi_mutex_t fd_cache_mutex;
diff -Npur a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
--- a/dlls/ntdll/unix/server.c	2024-05-01 15:47:17.784126177 -0500
+++ b/dlls/ntdll/unix/server.c	2024-05-01 15:50:02.225910314 -0500
@@ -131,7 +131,7 @@ sigset_t server_block_set;  /* signals t
 static int fd_socket = -1;  /* socket to exchange file descriptors with the server */
 static int initial_cwd = -1;
 static pid_t server_pid;
-pthread_mutex_t fd_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+pi_mutex_t fd_cache_mutex = PI_MUTEX_INIT(0);
 
 /* atomically exchange a 64-bit value */
 static inline LONG64 interlocked_xchg64( LONG64 *dest, LONG64 val )
@@ -460,7 +460,7 @@ NTSTATUS unixcall_wine_server_call( void
 /***********************************************************************
  *           server_enter_uninterrupted_section
  */
-void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset )
+void server_enter_uninterrupted_section( pi_mutex_t *mutex, sigset_t *sigset )
 {
     pthread_sigmask( SIG_BLOCK, &server_block_set, sigset );
     mutex_lock( mutex );
@@ -470,7 +470,7 @@ void server_enter_uninterrupted_section(
 /***********************************************************************
  *           server_leave_uninterrupted_section
  */
-void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset )
+void server_leave_uninterrupted_section( pi_mutex_t *mutex, sigset_t *sigset )
 {
     mutex_unlock( mutex );
     pthread_sigmask( SIG_SETMASK, sigset, NULL );
diff -Npur a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
--- a/dlls/ntdll/unix/signal_arm64.c	2024-05-01 15:47:07.602076056 -0500
+++ b/dlls/ntdll/unix/signal_arm64.c	2024-05-01 15:50:02.224910309 -0500
@@ -28,6 +28,7 @@
 
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <stdarg.h>
diff -Npur a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
--- a/dlls/ntdll/unix/signal_arm.c	2024-05-01 15:47:07.602076056 -0500
+++ b/dlls/ntdll/unix/signal_arm.c	2024-05-01 15:50:02.228910328 -0500
@@ -29,6 +29,7 @@
 
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <stdarg.h>
diff -Npur a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
--- a/dlls/ntdll/unix/signal_i386.c	2024-05-01 15:47:17.564125096 -0500
+++ b/dlls/ntdll/unix/signal_i386.c	2024-05-01 15:50:02.239910379 -0500
@@ -2132,7 +2132,7 @@ struct ldt_copy
 } __wine_ldt_copy;
 
 static WORD gdt_fs_sel;
-static pthread_mutex_t ldt_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t ldt_mutex = PI_MUTEX_INIT(0);
 static const LDT_ENTRY null_entry;
 
 static inline void *ldt_get_base( LDT_ENTRY ent )
diff -Npur a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
--- a/dlls/ntdll/unix/signal_x86_64.c	2024-05-01 15:47:17.564125096 -0500
+++ b/dlls/ntdll/unix/signal_x86_64.c	2024-05-01 15:50:02.240910383 -0500
@@ -29,6 +29,7 @@
 #include <assert.h>
 #include <errno.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <stdlib.h>
 #include <stdarg.h>
@@ -2366,7 +2367,7 @@ struct ldt_copy
     unsigned char flags[LDT_SIZE];
 } __wine_ldt_copy;
 
-static pthread_mutex_t ldt_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t ldt_mutex = PI_MUTEX_INIT(0);
 
 static inline void *ldt_get_base( LDT_ENTRY ent )
 {
diff -Npur a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
--- a/dlls/ntdll/unix/system.c	2024-05-01 15:47:17.509124826 -0500
+++ b/dlls/ntdll/unix/system.c	2024-05-01 15:50:02.234910355 -0500
@@ -244,7 +244,7 @@ static struct
 }
 cpu_override;
 
-static pthread_mutex_t timezone_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t timezone_mutex = PI_MUTEX_INIT(0);
 
 /*******************************************************************************
  * Architecture specific feature detection for CPUs
@@ -2469,7 +2469,7 @@ static time_t find_dst_change(time_t sta
 
 static void get_timezone_info( RTL_DYNAMIC_TIME_ZONE_INFORMATION *tzi )
 {
-    static pthread_mutex_t tz_mutex = PTHREAD_MUTEX_INITIALIZER;
+    static pi_mutex_t tz_mutex = PI_MUTEX_INIT(0);
     static RTL_DYNAMIC_TIME_ZONE_INFORMATION cached_tzi;
     static int current_year = -1, current_bias = 65535;
     struct tm *tm;
@@ -2790,7 +2790,7 @@ NTSTATUS WINAPI NtQuerySystemInformation
         sti.BootTime.QuadPart = server_start_time;
 
         utc = time( NULL );
-        pthread_mutex_lock( &timezone_mutex );
+        pi_mutex_lock( &timezone_mutex );
         if (utc != last_utc)
         {
             last_utc = utc;
@@ -2801,7 +2801,7 @@ NTSTATUS WINAPI NtQuerySystemInformation
             last_bias *= TICKSPERSEC;
         }
         sti.TimeZoneBias.QuadPart = last_bias;
-        pthread_mutex_unlock( &timezone_mutex );
+        pi_mutex_unlock( &timezone_mutex );
 
         NtQuerySystemTime( &sti.SystemTime );
 
diff -Npur a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
--- a/dlls/ntdll/unix/thread.c	2024-05-01 15:47:17.621125376 -0500
+++ b/dlls/ntdll/unix/thread.c	2024-05-01 15:50:02.236910365 -0500
@@ -33,6 +33,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <sys/types.h>
 #include <unistd.h>
diff -Npur a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
--- a/dlls/ntdll/unix/unix_private.h	2024-05-01 15:47:17.770126108 -0500
+++ b/dlls/ntdll/unix/unix_private.h	2024-05-01 15:50:02.232910346 -0500
@@ -22,6 +22,7 @@
 #define __NTDLL_UNIX_PRIVATE_H
 
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include "unixlib.h"
 #include "wine/unixlib.h"
@@ -212,8 +213,8 @@ extern NTSTATUS load_start_exe( WCHAR **
 extern void start_server( BOOL debug ) DECLSPEC_HIDDEN;
 
 extern unsigned int server_call_unlocked( void *req_ptr ) DECLSPEC_HIDDEN;
-extern void server_enter_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
-extern void server_leave_uninterrupted_section( pthread_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
+extern void server_enter_uninterrupted_section( pi_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
+extern void server_leave_uninterrupted_section( pi_mutex_t *mutex, sigset_t *sigset ) DECLSPEC_HIDDEN;
 extern unsigned int server_select( const select_op_t *select_op, data_size_t size, UINT flags,
                                    timeout_t abs_timeout, context_t *context, user_apc_t *user_apc ) DECLSPEC_HIDDEN;
 extern unsigned int server_wait( const select_op_t *select_op, data_size_t size, UINT flags,
@@ -403,14 +404,14 @@ static inline BOOL is_inside_signal_stac
             (char *)ptr < (char *)get_signal_stack() + signal_stack_size);
 }
 
-static inline void mutex_lock( pthread_mutex_t *mutex )
+static inline void mutex_lock( pi_mutex_t *mutex )
 {
-    if (!process_exiting) pthread_mutex_lock( mutex );
+    if (!process_exiting) pi_mutex_lock( mutex );
 }
 
-static inline void mutex_unlock( pthread_mutex_t *mutex )
+static inline void mutex_unlock( pi_mutex_t *mutex )
 {
-    if (!process_exiting) pthread_mutex_unlock( mutex );
+    if (!process_exiting) pi_mutex_unlock( mutex );
 }
 
 static inline async_data_t server_async( HANDLE handle, struct async_fileio *user, HANDLE event,
diff -Npur a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
--- a/dlls/ntdll/unix/virtual.c	2024-05-01 15:47:17.510124831 -0500
+++ b/dlls/ntdll/unix/virtual.c	2024-05-01 15:50:02.227910323 -0500
@@ -161,7 +161,7 @@ static const BYTE VIRTUAL_Win32Flags[16]
 };
 
 static struct wine_rb_tree views_tree;
-static pthread_mutex_t virtual_mutex;
+static pi_mutex_t virtual_mutex;
 
 static const UINT page_shift = 12;
 static const UINT_PTR page_mask = 0xfff;
@@ -248,7 +248,7 @@ static pthread_once_t membarrier_init_on
 #endif
 #if defined(__i386__) || defined(__x86_64__)
 static void *dontneed_page;
-static pthread_mutex_t dontneed_page_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t dontneed_page_mutex = PI_MUTEX_INIT(0);
 #endif
 #endif
 
@@ -3322,12 +3322,7 @@ void virtual_init(void)
     const char *preload = getenv( "WINEPRELOADRESERVE" );
     size_t size;
     int i;
-    pthread_mutexattr_t attr;
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &virtual_mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
 
     if (preload_info && *preload_info)
         for (i = 0; (*preload_info)[i].size; i++)
@@ -6412,7 +6407,7 @@ static int try_madvise( void )
     int ret = 0;
     char *mem;
 
-    pthread_mutex_lock(&dontneed_page_mutex);
+    pi_mutex_lock(&dontneed_page_mutex);
     /* Credits to Avi Kivity (scylladb) and Aliaksei Kandratsenka (gperftools) for this trick,
      * see https://github.com/scylladb/seastar/commit/77a58e4dc020233f66fccb8d9e8f7a8b7f9210c4 */
     mem = dontneed_page;
@@ -6431,7 +6426,7 @@ static int try_madvise( void )
     *mem = 3;
     ret = !madvise( mem, page_size, MADV_DONTNEED );
 failed:
-    pthread_mutex_unlock(&dontneed_page_mutex);
+    pi_mutex_unlock(&dontneed_page_mutex);
     return ret;
 }
 #else
@@ -6441,10 +6436,10 @@ static int try_madvise( void ) { return
 
 static NTSTATUS do_apc_memorybarrier( void )
 {
-    static pthread_mutex_t apc_memorybarrier_mutex = PTHREAD_MUTEX_INITIALIZER;
+    static pi_mutex_t apc_memorybarrier_mutex = PI_MUTEX_INIT(0);
     NTSTATUS status;
 
-    pthread_mutex_lock( &apc_memorybarrier_mutex );
+    pi_mutex_lock( &apc_memorybarrier_mutex );
 
     do
     {
@@ -6465,7 +6460,7 @@ static NTSTATUS do_apc_memorybarrier( vo
     }
     while (status);
 
-    pthread_mutex_unlock( &apc_memorybarrier_mutex );
+    pi_mutex_unlock( &apc_memorybarrier_mutex );
     return STATUS_SUCCESS;
 }
 
diff -Npur a/dlls/win32u/alloc.c b/dlls/win32u/alloc.c
--- a/dlls/win32u/alloc.c	2024-05-01 15:47:17.458124575 -0500
+++ b/dlls/win32u/alloc.c	2024-05-01 15:50:03.424915875 -0500
@@ -27,6 +27,7 @@
 #include <string.h>
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -46,7 +47,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(gdi);
 #define MEM_CACHE_THRESHOLD ( 8UL << 20)   /* 8MB */
 #endif
 
-static pthread_mutex_t mem_cache_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t mem_cache_lock = PI_MUTEX_INIT(0);
 static void **mem_cache_buckets[MEM_CACHE_NR_BUCKETS];
 static SIZE_T mem_cache_total_size;
 
@@ -96,7 +97,7 @@ void *alloc_gdi_cache_memory( SIZE_T siz
         real_size = get_bucket_chunk_size( i );
         assert(real_size >= size);
 
-        pthread_mutex_lock( &mem_cache_lock );
+        pi_mutex_lock( &mem_cache_lock );
 
         real_bucket_i = i;
         while (!(mem = bucket_pop_chunk( real_bucket_i )))
@@ -104,7 +105,7 @@ void *alloc_gdi_cache_memory( SIZE_T siz
             if (++real_bucket_i >= MEM_CACHE_NR_BUCKETS) break;
         }
 
-        pthread_mutex_unlock( &mem_cache_lock );
+        pi_mutex_unlock( &mem_cache_lock );
 
         if (mem)
         {
@@ -141,7 +142,7 @@ void free_gdi_cache_memory( void *mem, S
     {
         real_size = get_bucket_chunk_size( i );
 
-        pthread_mutex_lock( &mem_cache_lock );
+        pi_mutex_lock( &mem_cache_lock );
 
         free_bucket_i = 0;
         while (real_size > MEM_CACHE_THRESHOLD - mem_cache_total_size)
@@ -165,7 +166,7 @@ void free_gdi_cache_memory( void *mem, S
             TRACE("discard memory %p (%lu)\n", mem, real_size);
         }
 
-        pthread_mutex_unlock( &mem_cache_lock );
+        pi_mutex_unlock( &mem_cache_lock );
     }
 
     if (mem)
diff -Npur a/dlls/win32u/class.c b/dlls/win32u/class.c
--- a/dlls/win32u/class.c	2024-05-01 15:46:47.240975209 -0500
+++ b/dlls/win32u/class.c	2024-05-01 15:50:03.416915838 -0500
@@ -25,6 +25,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 #include <assert.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -79,7 +80,7 @@ typedef struct tagWINDOWPROC
 
 static WINDOWPROC winproc_array[MAX_WINPROCS];
 static UINT winproc_used = NB_BUILTIN_WINPROCS;
-static pthread_mutex_t winproc_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t winproc_lock = PI_MUTEX_INIT(0);
 
 static struct list class_list = LIST_INIT( class_list );
 
@@ -132,7 +133,7 @@ static inline WINDOWPROC *alloc_winproc_
     if (!func) return NULL;
     if ((proc = get_winproc_ptr( func ))) return proc;
 
-    pthread_mutex_lock( &winproc_lock );
+    pi_mutex_lock( &winproc_lock );
 
     /* check if we already have a winproc for that function */
     if (!(proc = find_winproc( func, ansi )))
@@ -150,7 +151,7 @@ static inline WINDOWPROC *alloc_winproc_
     }
     else TRACE_(win)( "reusing %p for %p\n", proc_to_handle(proc), func );
 
-    pthread_mutex_unlock( &winproc_lock );
+    pi_mutex_unlock( &winproc_lock );
     return proc;
 }
 
diff -Npur a/dlls/win32u/clipboard.c b/dlls/win32u/clipboard.c
--- a/dlls/win32u/clipboard.c	2024-05-01 15:46:40.686942567 -0500
+++ b/dlls/win32u/clipboard.c	2024-05-01 15:50:03.412915819 -0500
@@ -28,6 +28,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "win32u_private.h"
@@ -38,7 +39,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
-static pthread_mutex_t clipboard_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t clipboard_mutex = PI_MUTEX_INIT(0);
 
 struct cached_format
 {
@@ -179,7 +180,7 @@ BOOL WINAPI NtUserOpenClipboard( HWND hw
 
     user_driver->pUpdateClipboard();
 
-    pthread_mutex_lock( &clipboard_mutex );
+    pi_mutex_lock( &clipboard_mutex );
 
     SERVER_START_REQ( open_clipboard )
     {
@@ -191,7 +192,7 @@ BOOL WINAPI NtUserOpenClipboard( HWND hw
 
     if (ret && !is_current_process_window( owner )) invalidate_memory_formats( &free_list );
 
-    pthread_mutex_unlock( &clipboard_mutex );
+    pi_mutex_unlock( &clipboard_mutex );
     free_cached_formats( &free_list );
     return ret;
 }
@@ -235,7 +236,7 @@ BOOL WINAPI NtUserEmptyClipboard(void)
     if (owner)
         send_message_timeout( owner, WM_DESTROYCLIPBOARD, 0, 0, SMTO_ABORTIFHUNG, 5000, FALSE );
 
-    pthread_mutex_lock( &clipboard_mutex );
+    pi_mutex_lock( &clipboard_mutex );
 
     SERVER_START_REQ( empty_clipboard )
     {
@@ -249,7 +250,7 @@ BOOL WINAPI NtUserEmptyClipboard(void)
         list_move_tail( &free_list, &cached_formats );
     }
 
-    pthread_mutex_unlock( &clipboard_mutex );
+    pi_mutex_unlock( &clipboard_mutex );
     free_cached_formats( &free_list );
     return ret;
 }
@@ -579,12 +580,12 @@ NTSTATUS WINAPI NtUserSetClipboardData(
 
     if (params->cache_only)
     {
-        pthread_mutex_lock( &clipboard_mutex );
+        pi_mutex_lock( &clipboard_mutex );
         if ((cache = get_cached_format( format )) && cache->seqno == params->seqno)
             cache->handle = data;
         else
             status = STATUS_UNSUCCESSFUL;
-        pthread_mutex_unlock( &clipboard_mutex );
+        pi_mutex_unlock( &clipboard_mutex );
         return status;
     }
 
@@ -606,7 +607,7 @@ NTSTATUS WINAPI NtUserSetClipboardData(
     }
     NtQueryDefaultLocale( TRUE, &lcid );
 
-    pthread_mutex_lock( &clipboard_mutex );
+    pi_mutex_lock( &clipboard_mutex );
 
     SERVER_START_REQ( set_clipboard_data )
     {
@@ -628,7 +629,7 @@ NTSTATUS WINAPI NtUserSetClipboardData(
     }
     else free( cache );
 
-    pthread_mutex_unlock( &clipboard_mutex );
+    pi_mutex_unlock( &clipboard_mutex );
     if (prev) free_cached_data( prev );
 
 done:
@@ -649,7 +650,7 @@ HANDLE WINAPI NtUserGetClipboardData( UI
 
     for (;;)
     {
-        pthread_mutex_lock( &clipboard_mutex );
+        pi_mutex_lock( &clipboard_mutex );
 
         if (!params->data_only) cache = get_cached_format( format );
 
@@ -680,7 +681,7 @@ HANDLE WINAPI NtUserGetClipboardData( UI
                 if (cache->handle && data_seqno == cache->seqno)  /* we can reuse the cached data */
                 {
                     HANDLE ret = cache->handle;
-                    pthread_mutex_unlock( &clipboard_mutex );
+                    pi_mutex_unlock( &clipboard_mutex );
                     TRACE( "%s returning %p\n", debugstr_format( format ), ret );
                     return ret;
                 }
@@ -692,14 +693,14 @@ HANDLE WINAPI NtUserGetClipboardData( UI
 
             if (params->data_only)
             {
-                pthread_mutex_unlock( &clipboard_mutex );
+                pi_mutex_unlock( &clipboard_mutex );
                 return params->data;
             }
 
             /* allocate new cache entry */
             if (!(cache = malloc( sizeof(*cache) )))
             {
-                pthread_mutex_unlock( &clipboard_mutex );
+                pi_mutex_unlock( &clipboard_mutex );
                 return 0;
             }
 
@@ -708,12 +709,12 @@ HANDLE WINAPI NtUserGetClipboardData( UI
             cache->handle = NULL;
             params->seqno = cache->seqno;
             list_add_tail( &cached_formats, &cache->entry );
-            pthread_mutex_unlock( &clipboard_mutex );
+            pi_mutex_unlock( &clipboard_mutex );
             TRACE( "%s needs unmarshaling\n", debugstr_format( format ) );
             params->data_size = ~0;
             return 0;
         }
-        pthread_mutex_unlock( &clipboard_mutex );
+        pi_mutex_unlock( &clipboard_mutex );
 
         if (status == STATUS_BUFFER_OVERFLOW)
         {
diff -Npur a/dlls/win32u/dc.c b/dlls/win32u/dc.c
--- a/dlls/win32u/dc.c	2024-05-01 15:46:47.240975209 -0500
+++ b/dlls/win32u/dc.c	2024-05-01 15:50:03.413915824 -0500
@@ -27,6 +27,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -43,7 +44,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dc);
 
-static pthread_mutex_t dc_attr_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t dc_attr_lock = PI_MUTEX_INIT(0);
 
 struct dc_attr_bucket
 {
@@ -90,7 +91,7 @@ static DC_ATTR *alloc_dc_attr(void)
     struct dc_attr_bucket *bucket;
     DC_ATTR *dc_attr = NULL;
 
-    pthread_mutex_lock( &dc_attr_lock );
+    pi_mutex_lock( &dc_attr_lock );
 
     LIST_FOR_EACH_ENTRY( bucket, &dc_attr_buckets, struct dc_attr_bucket, entry )
     {
@@ -125,7 +126,7 @@ static DC_ATTR *alloc_dc_attr(void)
 
     if (dc_attr) memset( dc_attr, 0, sizeof( *dc_attr ));
 
-    pthread_mutex_unlock( &dc_attr_lock );
+    pi_mutex_unlock( &dc_attr_lock );
 
     return dc_attr;
 }
@@ -135,7 +136,7 @@ static void free_dc_attr( DC_ATTR *dc_at
 {
     struct dc_attr_bucket *bucket;
 
-    pthread_mutex_lock( &dc_attr_lock );
+    pi_mutex_lock( &dc_attr_lock );
 
     LIST_FOR_EACH_ENTRY( bucket, &dc_attr_buckets, struct dc_attr_bucket, entry )
     {
@@ -145,7 +146,7 @@ static void free_dc_attr( DC_ATTR *dc_at
         break;
     }
 
-    pthread_mutex_unlock( &dc_attr_lock );
+    pi_mutex_unlock( &dc_attr_lock );
 }
 
 
diff -Npur a/dlls/win32u/dce.c b/dlls/win32u/dce.c
--- a/dlls/win32u/dce.c	2024-05-01 15:47:17.671125622 -0500
+++ b/dlls/win32u/dce.c	2024-05-01 15:50:03.421915861 -0500
@@ -25,6 +25,7 @@
 
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "ntgdi_private.h"
@@ -50,7 +51,7 @@ static struct list dce_list = LIST_INIT(
 #define DCE_CACHE_SIZE 64
 
 static struct list window_surfaces = LIST_INIT( window_surfaces );
-static pthread_mutex_t surfaces_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t surfaces_lock = PI_MUTEX_INIT(0);
 
 /*******************************************************************
  * Dummy window surface for windows that shouldn't get painted.
@@ -125,7 +126,7 @@ struct window_surface dummy_surface = {
 struct offscreen_window_surface
 {
     struct window_surface header;
-    pthread_mutex_t mutex;
+    pi_mutex_t mutex;
     RECT bounds;
     char *bits;
     BITMAPINFO info;
@@ -142,13 +143,13 @@ static struct offscreen_window_surface *
 static void offscreen_window_surface_lock( struct window_surface *base )
 {
     struct offscreen_window_surface *impl = impl_from_window_surface( base );
-    pthread_mutex_lock( &impl->mutex );
+    pi_mutex_lock( &impl->mutex );
 }
 
 static void offscreen_window_surface_unlock( struct window_surface *base )
 {
     struct offscreen_window_surface *impl = impl_from_window_surface( base );
-    pthread_mutex_unlock( &impl->mutex );
+    pi_mutex_unlock( &impl->mutex );
 }
 
 static RECT *offscreen_window_surface_get_bounds( struct window_surface *base )
@@ -198,7 +199,6 @@ void create_offscreen_window_surface( co
     struct offscreen_window_surface *impl;
     SIZE_T size;
     RECT surface_rect = *visible_rect;
-    pthread_mutexattr_t attr;
 
     TRACE( "visible_rect %s, surface %p.\n", wine_dbgstr_rect( visible_rect ), surface );
 
@@ -224,10 +224,6 @@ void create_offscreen_window_surface( co
     impl->header.ref = 1;
     impl->header.rect = surface_rect;
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &impl->mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
 
     reset_bounds( &impl->bounds );
 
@@ -383,10 +379,10 @@ void register_window_surface( struct win
     if (old == &dummy_surface) old = NULL;
     if (new == &dummy_surface) new = NULL;
     if (old == new) return;
-    pthread_mutex_lock( &surfaces_lock );
+    pi_mutex_lock( &surfaces_lock );
     if (old) list_remove( &old->entry );
     if (new) list_add_tail( &window_surfaces, &new->entry );
-    pthread_mutex_unlock( &surfaces_lock );
+    pi_mutex_unlock( &surfaces_lock );
 }
 
 /*******************************************************************
@@ -400,7 +396,7 @@ void flush_window_surfaces( BOOL idle )
     DWORD now;
     struct window_surface *surface;
 
-    pthread_mutex_lock( &surfaces_lock );
+    pi_mutex_lock( &surfaces_lock );
     now = NtGetTickCount();
     if (idle) last_idle = now;
     /* if not idle, we only flush if there's evidence that the app never goes idle */
@@ -409,7 +405,7 @@ void flush_window_surfaces( BOOL idle )
     LIST_FOR_EACH_ENTRY( surface, &window_surfaces, struct window_surface, entry )
         surface->funcs->flush( surface );
 done:
-    pthread_mutex_unlock( &surfaces_lock );
+    pi_mutex_unlock( &surfaces_lock );
 }
 
 /***********************************************************************
diff -Npur a/dlls/win32u/dibdrv/graphics.c b/dlls/win32u/dibdrv/graphics.c
--- a/dlls/win32u/dibdrv/graphics.c	2024-05-01 15:47:07.134073747 -0500
+++ b/dlls/win32u/dibdrv/graphics.c	2024-05-01 15:50:03.420915856 -0500
@@ -24,6 +24,7 @@
 
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include "ntgdi_private.h"
 #include "dibdrv.h"
 
@@ -60,7 +61,7 @@ struct cached_font
 
 static struct list font_cache = LIST_INIT( font_cache );
 
-static pthread_mutex_t font_cache_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t font_cache_lock = PI_MUTEX_INIT(0);
 
 
 static BOOL brush_rect( dibdrv_physdev *pdev, dib_brush *brush, const RECT *rect, HRGN clip )
@@ -649,7 +650,7 @@ static struct cached_font *add_cached_fo
     font.aa_flags = aa_flags;
     font.hash = font_cache_hash( &font );
 
-    pthread_mutex_lock( &font_cache_lock );
+    pi_mutex_lock( &font_cache_lock );
     LIST_FOR_EACH_ENTRY( ptr, &font_cache, struct cached_font, entry )
     {
         if (!font_cache_cmp( &font, ptr ))
@@ -682,7 +683,7 @@ static struct cached_font *add_cached_fo
     }
     else if (!(ptr = malloc( sizeof(*ptr) )))
     {
-        pthread_mutex_unlock( &font_cache_lock );
+        pi_mutex_unlock( &font_cache_lock );
         return NULL;
     }
 
@@ -691,7 +692,7 @@ static struct cached_font *add_cached_fo
     memset( ptr->glyphs, 0, sizeof(ptr->glyphs) );
 done:
     list_add_head( &font_cache, &ptr->entry );
-    pthread_mutex_unlock( &font_cache_lock );
+    pi_mutex_unlock( &font_cache_lock );
     TRACE( "%d %s -> %p\n", (int)ptr->lf.lfHeight, debugstr_w(ptr->lf.lfFaceName), ptr );
     return ptr;
 }
diff -Npur a/dlls/win32u/driver.c b/dlls/win32u/driver.c
--- a/dlls/win32u/driver.c	2024-05-01 15:47:10.227088997 -0500
+++ b/dlls/win32u/driver.c	2024-05-01 15:50:03.406915791 -0500
@@ -25,6 +25,7 @@
 
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -55,7 +56,7 @@ static struct user_driver_funcs null_use
 static struct list d3dkmt_adapters = LIST_INIT( d3dkmt_adapters );
 static struct list d3dkmt_devices = LIST_INIT( d3dkmt_devices );
 
-static pthread_mutex_t driver_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t driver_lock = PI_MUTEX_INIT(0);
 static WCHAR driver_load_error[80];
 
 static INT nulldrv_AbortDoc( PHYSDEV dev )
@@ -1417,7 +1418,7 @@ NTSTATUS WINAPI NtGdiDdDDICloseAdapter(
     if (get_display_driver()->pD3DKMTCloseAdapter)
         get_display_driver()->pD3DKMTCloseAdapter( desc );
 
-    pthread_mutex_lock( &driver_lock );
+    pi_mutex_lock( &driver_lock );
     LIST_FOR_EACH_ENTRY( adapter, &d3dkmt_adapters, struct d3dkmt_adapter, entry )
     {
         if (adapter->handle == desc->hAdapter)
@@ -1428,7 +1429,7 @@ NTSTATUS WINAPI NtGdiDdDDICloseAdapter(
             break;
         }
     }
-    pthread_mutex_unlock( &driver_lock );
+    pi_mutex_unlock( &driver_lock );
 
     return status;
 }
@@ -1463,10 +1464,10 @@ NTSTATUS WINAPI NtGdiDdDDIOpenAdapterFro
 
     if (!(adapter = malloc( sizeof( *adapter ) ))) return STATUS_NO_MEMORY;
 
-    pthread_mutex_lock( &driver_lock );
+    pi_mutex_lock( &driver_lock );
     desc->hAdapter = adapter->handle = ++handle_start;
     list_add_tail( &d3dkmt_adapters, &adapter->entry );
-    pthread_mutex_unlock( &driver_lock );
+    pi_mutex_unlock( &driver_lock );
 
     if (get_display_driver()->pD3DKMTOpenAdapterFromLuid)
         get_display_driver()->pD3DKMTOpenAdapterFromLuid( desc );
@@ -1489,7 +1490,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateDevice(
     if (!desc)
         return STATUS_INVALID_PARAMETER;
 
-    pthread_mutex_lock( &driver_lock );
+    pi_mutex_lock( &driver_lock );
     LIST_FOR_EACH_ENTRY( adapter, &d3dkmt_adapters, struct d3dkmt_adapter, entry )
     {
         if (adapter->handle == desc->hAdapter)
@@ -1498,7 +1499,7 @@ NTSTATUS WINAPI NtGdiDdDDICreateDevice(
             break;
         }
     }
-    pthread_mutex_unlock( &driver_lock );
+    pi_mutex_unlock( &driver_lock );
 
     if (!found)
         return STATUS_INVALID_PARAMETER;
@@ -1510,10 +1511,10 @@ NTSTATUS WINAPI NtGdiDdDDICreateDevice(
     if (!device)
         return STATUS_NO_MEMORY;
 
-    pthread_mutex_lock( &driver_lock );
+    pi_mutex_lock( &driver_lock );
     device->handle = ++handle_start;
     list_add_tail( &d3dkmt_devices, &device->entry );
-    pthread_mutex_unlock( &driver_lock );
+    pi_mutex_unlock( &driver_lock );
 
     desc->hDevice = device->handle;
     return STATUS_SUCCESS;
@@ -1533,7 +1534,7 @@ NTSTATUS WINAPI NtGdiDdDDIDestroyDevice(
     if (!desc || !desc->hDevice)
         return STATUS_INVALID_PARAMETER;
 
-    pthread_mutex_lock( &driver_lock );
+    pi_mutex_lock( &driver_lock );
     LIST_FOR_EACH_ENTRY( device, &d3dkmt_devices, struct d3dkmt_device, entry )
     {
         if (device->handle == desc->hDevice)
@@ -1547,7 +1548,7 @@ NTSTATUS WINAPI NtGdiDdDDIDestroyDevice(
             break;
         }
     }
-    pthread_mutex_unlock( &driver_lock );
+    pi_mutex_unlock( &driver_lock );
 
     return status;
 }
diff -Npur a/dlls/win32u/font.c b/dlls/win32u/font.c
--- a/dlls/win32u/font.c	2024-05-01 15:47:17.465124610 -0500
+++ b/dlls/win32u/font.c	2024-05-01 15:50:03.408915801 -0500
@@ -30,6 +30,7 @@
 #include <string.h>
 #include <assert.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -466,7 +467,7 @@ static const struct nls_update_font_list
     }
 };
 
-static pthread_mutex_t font_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t font_lock = PI_MUTEX_INIT(0);
 
 pthread_once_t font_list_init_once = PTHREAD_ONCE_INIT;
 DWORD font_list_init_disposition;
@@ -1068,7 +1069,7 @@ static int remove_font( const WCHAR *fil
     struct gdi_font_face *face, *face_next;
     int count = 0;
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     WINE_RB_FOR_EACH_ENTRY_DESTRUCTOR( family, family_next, &family_name_tree, struct gdi_font_family, name_entry )
     {
         family->refcount++;
@@ -1085,7 +1086,7 @@ static int remove_font( const WCHAR *fil
 	}
         release_family( family );
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return count;
 }
 
@@ -2975,7 +2976,7 @@ static void release_gdi_font( struct gdi
     TRACE( "font %p\n", font );
 
     /* add it to the unused list */
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     if (!--font->refcount)
     {
         list_add_head( &unused_gdi_font_list, &font->unused_entry );
@@ -2989,7 +2990,7 @@ static void release_gdi_font( struct gdi
         }
         else unused_font_count++;
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
 }
 
 static void add_font_list(HKEY hkey, const struct nls_update_font_list *fl, int dpi)
@@ -3530,9 +3531,9 @@ static BOOL enum_face_charsets( const st
                elf.elfLogFont.lfCharSet, type, debugstr_w(elf.elfScript),
                elf.elfLogFont.lfItalic, (int)elf.elfLogFont.lfWeight, (int)ntm.ntmTm.ntmFlags );
         /* release section before callback (FIXME) */
-        pthread_mutex_unlock( &font_lock );
+        pi_mutex_unlock( &font_lock );
         if (!proc( &elf.elfLogFont, (TEXTMETRICW *)&ntm, type, lparam )) return FALSE;
-        pthread_mutex_lock( &font_lock );
+        pi_mutex_lock( &font_lock );
     }
     return TRUE;
 }
@@ -3553,7 +3554,7 @@ static BOOL font_EnumFonts( PHYSDEV dev,
 
     count = create_enum_charset_list( charset, enum_charsets );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
 
     if (lf && lf->lfFaceName[0])
     {
@@ -3589,7 +3590,7 @@ static BOOL font_EnumFonts( PHYSDEV dev,
                 return FALSE; /* enum_face_charsets() unlocked font_lock */
 	}
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -3937,13 +3938,13 @@ static BOOL font_GetCharABCWidths( PHYSD
 
     TRACE( "%p, %u, %u, %p\n", physdev->font, first, count, buffer );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     for (i = 0; i < count; i++)
     {
         c = chars ? chars[i] : first + i;
         get_glyph_outline( physdev->font, c, GGO_METRICS, NULL, &buffer[i], 0, NULL, NULL );
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -3964,11 +3965,11 @@ static BOOL font_GetCharABCWidthsI( PHYS
 
     TRACE( "%p, %u, %u, %p\n", physdev->font, first, count, buffer );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     for (c = 0; c < count; c++, buffer++)
         get_glyph_outline( physdev->font, gi ? gi[c] : first + c, GGO_METRICS | GGO_GLYPH_INDEX,
                            NULL, buffer, 0, NULL, NULL );
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -3990,7 +3991,7 @@ static BOOL font_GetCharWidth( PHYSDEV d
 
     TRACE( "%p, %d, %d, %p\n", physdev->font, first, count, buffer );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     for (i = 0; i < count; i++)
     {
         c = chars ? chars[i] : i + first;
@@ -3999,7 +4000,7 @@ static BOOL font_GetCharWidth( PHYSDEV d
         else
             buffer[i] = abc.abcA + abc.abcB + abc.abcC;
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -4124,7 +4125,7 @@ static DWORD font_GetGlyphIndices( PHYSD
         got_default = TRUE;
     }
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
 
     for (i = 0; i < count; i++)
     {
@@ -4153,7 +4154,7 @@ static DWORD font_GetGlyphIndices( PHYSD
         else gi[i] = get_GSUB_vert_glyph( physdev->font, glyph );
     }
 
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return count;
 }
 
@@ -4172,9 +4173,9 @@ static DWORD font_GetGlyphOutline( PHYSD
         dev = GET_NEXT_PHYSDEV( dev, pGetGlyphOutline );
         return dev->funcs->pGetGlyphOutline( dev, glyph, format, gm, buflen, buf, mat );
     }
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     ret = get_glyph_outline( physdev->font, glyph, format, gm, NULL, buflen, buf, mat );
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return ret;
 }
 
@@ -4192,11 +4193,11 @@ static DWORD font_GetKerningPairs( PHYSD
         return dev->funcs->pGetKerningPairs( dev, count, pairs );
     }
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     if (physdev->font->kern_count == -1)
         physdev->font->kern_count = font_funcs->get_kerning_pairs( physdev->font,
                                                                    &physdev->font->kern_pairs );
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
 
     if (count && pairs)
     {
@@ -4289,7 +4290,7 @@ static UINT font_GetOutlineTextMetrics(
 
     if (!physdev->font->scalable) return 0;
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     if (font_funcs->set_outline_text_metrics( physdev->font ))
     {
 	ret = physdev->font->otm.otmSize;
@@ -4311,7 +4312,7 @@ static UINT font_GetOutlineTextMetrics(
             scale_outline_font_metrics( physdev->font, metrics );
         }
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return ret;
 }
 
@@ -4350,14 +4351,14 @@ static BOOL font_GetTextExtentExPoint( P
 
     TRACE( "%p, %s, %d\n", physdev->font, debugstr_wn(str, count), count );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     for (i = pos = 0; i < count; i++)
     {
         get_glyph_outline( physdev->font, str[i], GGO_METRICS, NULL, &abc, 0, NULL, NULL );
         pos += abc.abcA + abc.abcB + abc.abcC;
         dxs[i] = pos;
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -4379,7 +4380,7 @@ static BOOL font_GetTextExtentExPointI(
 
     TRACE( "%p, %p, %d\n", physdev->font, indices, count );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     for (i = pos = 0; i < count; i++)
     {
         get_glyph_outline( physdev->font, indices[i], GGO_METRICS | GGO_GLYPH_INDEX,
@@ -4387,7 +4388,7 @@ static BOOL font_GetTextExtentExPointI(
         pos += abc.abcA + abc.abcB + abc.abcC;
         dxs[i] = pos;
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return TRUE;
 }
 
@@ -4476,7 +4477,7 @@ static BOOL font_GetTextMetrics( PHYSDEV
         return dev->funcs->pGetTextMetrics( dev, metrics );
     }
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     if (font_funcs->set_outline_text_metrics( physdev->font ) ||
         font_funcs->set_bitmap_text_metrics( physdev->font ))
     {
@@ -4484,7 +4485,7 @@ static BOOL font_GetTextMetrics( PHYSDEV
         scale_font_metrics( physdev->font, metrics );
         ret = TRUE;
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return ret;
 }
 
@@ -4683,7 +4684,7 @@ static HFONT font_SelectFont( PHYSDEV de
         }
         TRACE( "DC transform %f %f %f %f\n", dcmat.eM11, dcmat.eM12, dcmat.eM21, dcmat.eM22 );
 
-        pthread_mutex_lock( &font_lock );
+        pi_mutex_lock( &font_lock );
 
         font = select_font( &lf, dcmat, can_use_bitmap );
 
@@ -4700,7 +4701,7 @@ static HFONT font_SelectFont( PHYSDEV de
             *aa_flags = font_funcs->get_aa_flags( font, *aa_flags, antialias_fakes );
         }
         TRACE( "%p %s %d aa %x\n", hfont, debugstr_w(lf.lfFaceName), (int)lf.lfHeight, *aa_flags );
-        pthread_mutex_unlock( &font_lock );
+        pi_mutex_unlock( &font_lock );
     }
     physdev->font = font;
     if (prev) release_gdi_font( prev );
@@ -6466,16 +6467,16 @@ static int add_system_font_resource( con
 
     /* try in %WINDIR%/fonts, needed for Fotobuch Designer */
     get_fonts_win_dir_path( file, path );
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     ret = font_funcs->add_font( path, flags );
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     /* try in datadir/fonts (or builddir/fonts), needed for Magic the Gathering Online */
     if (!ret)
     {
         get_fonts_data_dir_path( file, path );
-        pthread_mutex_lock( &font_lock );
+        pi_mutex_lock( &font_lock );
         ret = font_funcs->add_font( path, flags );
-        pthread_mutex_unlock( &font_lock );
+        pi_mutex_unlock( &font_lock );
     }
     return ret;
 }
@@ -6503,9 +6504,9 @@ static int add_font_resource( LPCWSTR fi
         DWORD addfont_flags = ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_RESOURCE;
 
         if (!(flags & FR_PRIVATE)) addfont_flags |= ADDFONT_ADD_TO_CACHE;
-        pthread_mutex_lock( &font_lock );
+        pi_mutex_lock( &font_lock );
         ret = font_funcs->add_font( file, addfont_flags );
-        pthread_mutex_unlock( &font_lock );
+        pi_mutex_unlock( &font_lock );
     }
     else if (!wcschr( file, '\\' ))
         ret = add_system_font_resource( file, ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_RESOURCE );
@@ -6925,9 +6926,9 @@ HANDLE WINAPI NtGdiAddFontMemResourceEx(
     if (!(copy = malloc( size ))) return NULL;
     memcpy( copy, ptr, size );
 
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     num_fonts = font_funcs->add_mem_font( copy, size, ADDFONT_ALLOW_BITMAP | ADDFONT_ADD_RESOURCE );
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
 
     if (!num_fonts)
     {
@@ -7068,7 +7069,7 @@ BOOL WINAPI NtGdiGetFontFileData( DWORD
 
     pthread_once( &font_list_init_once, font_list_init );
     if (!font_funcs) return FALSE;
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
     if ((font = get_font_from_handle( instance_id )))
     {
         if (font->ttc_item_offset) tag = MS_TTCF_TAG;
@@ -7078,7 +7079,7 @@ BOOL WINAPI NtGdiGetFontFileData( DWORD
         else
             RtlSetLastWin32Error( ERROR_INVALID_PARAMETER );
     }
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     return ret;
 }
 
@@ -7093,7 +7094,7 @@ BOOL WINAPI NtGdiGetFontFileInfo( DWORD
     BOOL ret = FALSE;
 
     pthread_once( &font_list_init_once, font_list_init );
-    pthread_mutex_lock( &font_lock );
+    pi_mutex_lock( &font_lock );
 
     if ((font = get_font_from_handle( instance_id )))
     {
@@ -7108,7 +7109,7 @@ BOOL WINAPI NtGdiGetFontFileInfo( DWORD
         else RtlSetLastWin32Error( ERROR_INSUFFICIENT_BUFFER );
     }
 
-    pthread_mutex_unlock( &font_lock );
+    pi_mutex_unlock( &font_lock );
     if (needed) *needed = required_size;
     return ret;
 }
diff -Npur a/dlls/win32u/gdiobj.c b/dlls/win32u/gdiobj.c
--- a/dlls/win32u/gdiobj.c	2024-05-01 15:46:40.692942597 -0500
+++ b/dlls/win32u/gdiobj.c	2024-05-01 15:50:03.417915842 -0500
@@ -27,6 +27,7 @@
 #include <stdarg.h>
 #include <stdio.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -88,7 +89,7 @@ static const LOGBRUSH DkGrayBrush = { BS
 
 static const LOGBRUSH DCBrush = { BS_SOLID, RGB(255,255,255), 0 };
 
-static pthread_mutex_t gdi_lock;
+static pi_mutex_t gdi_lock;
 
 
 /****************************************************************************
@@ -454,9 +455,9 @@ void make_gdi_object_system( HGDIOBJ han
 {
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle ))) entry_obj( entry )->system = !!set;
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 }
 
 /******************************************************************************
@@ -492,9 +493,9 @@ UINT GDI_get_ref_count( HGDIOBJ handle )
     GDI_HANDLE_ENTRY *entry;
     UINT ret = 0;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle ))) ret = entry_obj( entry )->selcount;
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
     return ret;
 }
 
@@ -508,10 +509,10 @@ HGDIOBJ GDI_inc_ref_count( HGDIOBJ handl
 {
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle ))) entry_obj( entry )->selcount++;
     else handle = 0;
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
     return handle;
 }
 
@@ -525,7 +526,7 @@ BOOL GDI_dec_ref_count( HGDIOBJ handle )
 {
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle )))
     {
         assert( entry_obj( entry )->selcount );
@@ -533,13 +534,13 @@ BOOL GDI_dec_ref_count( HGDIOBJ handle )
         {
             /* handle delayed DeleteObject*/
             entry_obj( entry )->deleted = 0;
-            pthread_mutex_unlock( &gdi_lock );
+            pi_mutex_unlock( &gdi_lock );
             TRACE( "executing delayed DeleteObject for %p\n", handle );
             NtGdiDeleteObjectApp( handle );
             return TRUE;
         }
     }
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
     return entry != NULL;
 }
 
@@ -696,7 +697,7 @@ static void dump_gdi_objects( void )
 
     TRACE( "%u objects:\n", GDI_MAX_HANDLE_COUNT );
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     for (entry = gdi_shared->Handles; entry < next_unused; entry++)
     {
         if (!entry->Type)
@@ -707,7 +708,7 @@ static void dump_gdi_objects( void )
                    gdi_obj_type( entry->ExtType << NTGDI_HANDLE_TYPE_SHIFT ),
                    entry_obj( entry )->selcount, entry_obj( entry )->deleted );
     }
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 }
 
 /***********************************************************************
@@ -722,7 +723,7 @@ HGDIOBJ alloc_gdi_handle( struct gdi_obj
 
     assert( type );  /* type 0 is reserved to mark free entries */
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
 
     entry = next_free;
     if (entry)
@@ -731,7 +732,7 @@ HGDIOBJ alloc_gdi_handle( struct gdi_obj
         entry = next_unused++;
     else
     {
-        pthread_mutex_unlock( &gdi_lock );
+        pi_mutex_unlock( &gdi_lock );
         ERR( "out of GDI object handles, expect a crash\n" );
         if (TRACE_ON(gdi)) dump_gdi_objects();
         return 0;
@@ -745,7 +746,7 @@ HGDIOBJ alloc_gdi_handle( struct gdi_obj
     entry->Type    = entry->ExtType & 0x1f;
     if (++entry->Generation == 0xff) entry->Generation = 1;
     ret = entry_to_handle( entry );
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
     TRACE( "allocated %s %p %u/%u\n", gdi_obj_type(type), ret,
            (int)InterlockedIncrement( &debug_count ), GDI_MAX_HANDLE_COUNT );
     return ret;
@@ -762,7 +763,7 @@ void *free_gdi_handle( HGDIOBJ handle )
     void *object = NULL;
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle )))
     {
         TRACE( "freed %s %p %u/%u\n", gdi_obj_type( entry->ExtType << NTGDI_HANDLE_TYPE_SHIFT ),
@@ -772,7 +773,7 @@ void *free_gdi_handle( HGDIOBJ handle )
         entry->Object = (UINT_PTR)next_free;
         next_free = entry;
     }
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
     return object;
 }
 
@@ -800,7 +801,7 @@ void *get_any_obj_ptr( HGDIOBJ handle, D
     void *ptr = NULL;
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
 
     if ((entry = handle_entry( handle )))
     {
@@ -808,7 +809,7 @@ void *get_any_obj_ptr( HGDIOBJ handle, D
         *type = entry->ExtType << NTGDI_HANDLE_TYPE_SHIFT;
     }
 
-    if (!ptr) pthread_mutex_unlock( &gdi_lock );
+    if (!ptr) pi_mutex_unlock( &gdi_lock );
     return ptr;
 }
 
@@ -837,7 +838,7 @@ void *GDI_GetObjPtr( HGDIOBJ handle, DWO
  */
 void GDI_ReleaseObj( HGDIOBJ handle )
 {
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 }
 
 
@@ -861,10 +862,10 @@ BOOL WINAPI NtGdiDeleteObjectApp( HGDIOB
     const struct gdi_obj_funcs *funcs = NULL;
     struct gdi_obj_header *header;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if (!(entry = handle_entry( obj )))
     {
-        pthread_mutex_unlock( &gdi_lock );
+        pi_mutex_unlock( &gdi_lock );
         return FALSE;
     }
 
@@ -872,7 +873,7 @@ BOOL WINAPI NtGdiDeleteObjectApp( HGDIOB
     if (header->system)
     {
 	TRACE("Preserving system object %p\n", obj);
-        pthread_mutex_unlock( &gdi_lock );
+        pi_mutex_unlock( &gdi_lock );
 	return TRUE;
     }
 
@@ -885,7 +886,7 @@ BOOL WINAPI NtGdiDeleteObjectApp( HGDIOB
     }
     else funcs = header->funcs;
 
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 
     TRACE("%p\n", obj );
 
@@ -932,13 +933,13 @@ INT WINAPI NtGdiExtGetObjectW( HGDIOBJ h
 
     TRACE("%p %d %p\n", handle, count, buffer );
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( handle )))
     {
         funcs = entry_obj( entry )->funcs;
         handle = entry_to_handle( entry );  /* make it a full handle */
     }
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 
     if (funcs && funcs->pGetObjectW)
     {
@@ -987,13 +988,13 @@ BOOL WINAPI NtGdiUnrealizeObject( HGDIOB
     const struct gdi_obj_funcs *funcs = NULL;
     GDI_HANDLE_ENTRY *entry;
 
-    pthread_mutex_lock( &gdi_lock );
+    pi_mutex_lock( &gdi_lock );
     if ((entry = handle_entry( obj )))
     {
         funcs = entry_obj( entry )->funcs;
         obj = entry_to_handle( entry );  /* make it a full handle */
     }
-    pthread_mutex_unlock( &gdi_lock );
+    pi_mutex_unlock( &gdi_lock );
 
     if (funcs && funcs->pUnrealizeObject) return funcs->pUnrealizeObject( obj );
     return funcs != NULL;
@@ -1029,13 +1030,8 @@ BOOL WINAPI NtGdiSetColorAdjustment( HDC
 
 void gdi_init(void)
 {
-    pthread_mutexattr_t attr;
     unsigned int dpi;
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &gdi_lock, &attr );
-    pthread_mutexattr_destroy( &attr );
 
     NtQuerySystemInformation( SystemBasicInformation, &system_info, sizeof(system_info), NULL );
     init_gdi_shared();
diff -Npur a/dlls/win32u/imm.c b/dlls/win32u/imm.c
--- a/dlls/win32u/imm.c	2024-05-01 15:46:47.244975229 -0500
+++ b/dlls/win32u/imm.c	2024-05-01 15:50:03.424915875 -0500
@@ -25,6 +25,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "win32u_private.h"
@@ -52,7 +53,7 @@ struct imm_thread_data
 };
 
 static struct list thread_data_list = LIST_INIT( thread_data_list );
-static pthread_mutex_t imm_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t imm_mutex = PI_MUTEX_INIT(0);
 static BOOL disable_ime;
 
 static struct imc *get_imc_ptr( HIMC handle )
@@ -252,9 +253,9 @@ static struct imm_thread_data *get_imm_t
         if (!(data = calloc( 1, sizeof( *data )))) return NULL;
         data->thread_id = GetCurrentThreadId();
 
-        pthread_mutex_lock( &imm_mutex );
+        pi_mutex_lock( &imm_mutex );
         list_add_tail( &thread_data_list, &data->entry );
-        pthread_mutex_unlock( &imm_mutex );
+        pi_mutex_unlock( &imm_mutex );
 
         thread_info->imm_thread_data = data;
     }
@@ -325,7 +326,7 @@ BOOL WINAPI NtUserDisableThreadIme( DWOR
     {
         disable_ime = TRUE;
 
-        pthread_mutex_lock( &imm_mutex );
+        pi_mutex_lock( &imm_mutex );
         LIST_FOR_EACH_ENTRY( thread_data, &thread_data_list, struct imm_thread_data, entry )
         {
             if (thread_data->thread_id == GetCurrentThreadId()) continue;
@@ -333,7 +334,7 @@ BOOL WINAPI NtUserDisableThreadIme( DWOR
             NtUserMessageCall( thread_data->default_hwnd, WM_WINE_DESTROYWINDOW, 0, 0,
                                0, NtUserSendNotifyMessage, FALSE );
         }
-        pthread_mutex_unlock( &imm_mutex );
+        pi_mutex_unlock( &imm_mutex );
     }
     else if (!thread_id || thread_id == GetCurrentThreadId())
     {
@@ -361,14 +362,14 @@ HWND get_default_ime_window( HWND hwnd )
 
         if (!(thread_id = get_window_thread( hwnd, NULL ))) return 0;
 
-        pthread_mutex_lock( &imm_mutex );
+        pi_mutex_lock( &imm_mutex );
         LIST_FOR_EACH_ENTRY( thread_data, &thread_data_list, struct imm_thread_data, entry )
         {
             if (thread_data->thread_id != thread_id) continue;
             ret = thread_data->default_hwnd;
             break;
         }
-        pthread_mutex_unlock( &imm_mutex );
+        pi_mutex_unlock( &imm_mutex );
     }
     else if ((thread_data = get_user_thread_info()->imm_thread_data))
     {
@@ -385,9 +386,9 @@ void cleanup_imm_thread(void)
 
     if (thread_info->imm_thread_data)
     {
-        pthread_mutex_lock( &imm_mutex );
+        pi_mutex_lock( &imm_mutex );
         list_remove( &thread_info->imm_thread_data->entry );
-        pthread_mutex_unlock( &imm_mutex );
+        pi_mutex_unlock( &imm_mutex );
         free( thread_info->imm_thread_data );
         thread_info->imm_thread_data = NULL;
     }
diff -Npur a/dlls/win32u/Makefile.in b/dlls/win32u/Makefile.in
--- a/dlls/win32u/Makefile.in	2024-05-01 15:47:17.458124575 -0500
+++ b/dlls/win32u/Makefile.in	2024-05-01 15:50:04.409920442 -0500
@@ -4,7 +4,7 @@ UNIXLIB   = win32u.so
 IMPORTLIB = win32u
 IMPORTS   = ntdll winecrt0
 UNIX_CFLAGS  = $(FREETYPE_CFLAGS) $(FONTCONFIG_CFLAGS)
-UNIX_LIBS    = $(CARBON_LIBS) $(APPKIT_LIBS) $(PTHREAD_LIBS) -lm
+UNIX_LIBS    = $(CARBON_LIBS) $(APPKIT_LIBS) $(PTHREAD_LIBS) -lm -lrtpi
 
 EXTRADLLFLAGS = -nodefaultlibs -Wb,--syscall-table,1
 
diff -Npur a/dlls/win32u/rawinput.c b/dlls/win32u/rawinput.c
--- a/dlls/win32u/rawinput.c	2024-05-01 15:47:09.632086065 -0500
+++ b/dlls/win32u/rawinput.c	2024-05-01 15:50:03.424915875 -0500
@@ -25,6 +25,7 @@
 
 #include <stdbool.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "win32u_private.h"
 #include "ntuser_private.h"
@@ -208,7 +209,7 @@ struct device
 static RAWINPUTDEVICE *registered_devices;
 static unsigned int registered_device_count;
 static struct list devices = LIST_INIT( devices );
-static pthread_mutex_t rawinput_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t rawinput_mutex = PI_MUTEX_INIT(0);
 
 static struct device *add_device( HKEY key, DWORD type )
 {
@@ -458,7 +459,7 @@ BOOL rawinput_device_get_usages( HANDLE
 {
     struct device *device;
 
-    pthread_mutex_lock( &rawinput_mutex );
+    pi_mutex_lock( &rawinput_mutex );
 
     if (!(device = find_device_from_handle( handle )) || device->info.dwType != RIM_TYPEHID)
         *usage_page = *usage = 0;
@@ -468,7 +469,7 @@ BOOL rawinput_device_get_usages( HANDLE
         *usage = device->info.hid.usUsage;
     }
 
-    pthread_mutex_unlock( &rawinput_mutex );
+    pi_mutex_unlock( &rawinput_mutex );
 
     return *usage_page || *usage;
 }
@@ -496,7 +497,7 @@ UINT WINAPI NtUserGetRawInputDeviceList(
         return ~0u;
     }
 
-    pthread_mutex_lock( &rawinput_mutex );
+    pi_mutex_lock( &rawinput_mutex );
 
     if (ticks - last_check > 2000)
     {
@@ -512,7 +513,7 @@ UINT WINAPI NtUserGetRawInputDeviceList(
         device_list++;
     }
 
-    pthread_mutex_unlock( &rawinput_mutex );
+    pi_mutex_unlock( &rawinput_mutex );
 
     if (!device_list)
     {
@@ -554,11 +555,11 @@ UINT WINAPI NtUserGetRawInputDeviceInfo(
         return ~0u;
     }
 
-    pthread_mutex_lock( &rawinput_mutex );
+    pi_mutex_lock( &rawinput_mutex );
 
     if (!(device = find_device_from_handle( handle )))
     {
-        pthread_mutex_unlock( &rawinput_mutex );
+        pi_mutex_unlock( &rawinput_mutex );
         RtlSetLastWin32Error( ERROR_INVALID_HANDLE );
         return ~0u;
     }
@@ -591,7 +592,7 @@ UINT WINAPI NtUserGetRawInputDeviceInfo(
         break;
     }
 
-    pthread_mutex_unlock( &rawinput_mutex );
+    pi_mutex_unlock( &rawinput_mutex );
 
     if (!data)
         return 0;
@@ -780,9 +781,9 @@ BOOL process_rawinput_message( MSG *msg,
 
     if (msg->message == WM_INPUT_DEVICE_CHANGE)
     {
-        pthread_mutex_lock( &rawinput_mutex );
+        pi_mutex_lock( &rawinput_mutex );
         rawinput_update_device_list();
-        pthread_mutex_unlock( &rawinput_mutex );
+        pi_mutex_unlock( &rawinput_mutex );
     }
     else
     {
@@ -866,18 +867,18 @@ BOOL WINAPI NtUserRegisterRawInputDevice
             FIXME( "Unhandled flags %#x for device %u.\n", (int)devices[i].dwFlags, i );
     }
 
-    pthread_mutex_lock( &rawinput_mutex );
+    pi_mutex_lock( &rawinput_mutex );
 
     if (!registered_device_count && !device_count)
     {
-        pthread_mutex_unlock( &rawinput_mutex );
+        pi_mutex_unlock( &rawinput_mutex );
         return TRUE;
     }
 
     size = (SIZE_T)device_size * (registered_device_count + device_count);
     if (!(new_registered_devices = realloc( registered_devices, size )))
     {
-        pthread_mutex_unlock( &rawinput_mutex );
+        pi_mutex_unlock( &rawinput_mutex );
         RtlSetLastWin32Error( ERROR_OUTOFMEMORY );
         return FALSE;
     }
@@ -888,7 +889,7 @@ BOOL WINAPI NtUserRegisterRawInputDevice
     if (!(device_count = registered_device_count)) server_devices = NULL;
     else if (!(server_devices = malloc( device_count * sizeof(*server_devices) )))
     {
-        pthread_mutex_unlock( &rawinput_mutex );
+        pi_mutex_unlock( &rawinput_mutex );
         RtlSetLastWin32Error( ERROR_OUTOFMEMORY );
         return FALSE;
     }
@@ -910,7 +911,7 @@ BOOL WINAPI NtUserRegisterRawInputDevice
 
     free( server_devices );
 
-    pthread_mutex_unlock( &rawinput_mutex );
+    pi_mutex_unlock( &rawinput_mutex );
 
     return ret;
 }
@@ -930,14 +931,14 @@ UINT WINAPI NtUserGetRegisteredRawInputD
         return ~0u;
     }
 
-    pthread_mutex_lock( &rawinput_mutex );
+    pi_mutex_lock( &rawinput_mutex );
 
     capacity = *device_count * device_size;
     *device_count = registered_device_count;
     size = (SIZE_T)device_size * *device_count;
     if (devices && capacity >= size) memcpy( devices, registered_devices, size );
 
-    pthread_mutex_unlock( &rawinput_mutex );
+    pi_mutex_unlock( &rawinput_mutex );
 
     if (!devices) return 0;
 
diff -Npur a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
--- a/dlls/win32u/sysparams.c	2024-05-01 15:47:16.129118044 -0500
+++ b/dlls/win32u/sysparams.c	2024-05-01 15:50:03.411915814 -0500
@@ -25,6 +25,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 #include <assert.h>
 
 #include "ntstatus.h"
@@ -278,7 +279,7 @@ struct monitor
 static struct list adapters = LIST_INIT(adapters);
 static struct list monitors = LIST_INIT(monitors);
 static INT64 last_query_display_time;
-static pthread_mutex_t display_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t display_lock = PI_MUTEX_INIT(0);
 
 BOOL enable_thunk_lock = FALSE;
 
@@ -414,21 +415,21 @@ static RECT work_area;
 static DWORD process_layout = ~0u;
 
 static HDC display_dc;
-static pthread_mutex_t display_dc_lock = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t display_dc_lock = PI_MUTEX_INIT(0);
 
-static pthread_mutex_t user_mutex;
+static pi_mutex_t user_mutex;
 static unsigned int user_lock_thread, user_lock_rec;
 
 void user_lock(void)
 {
-    pthread_mutex_lock( &user_mutex );
+    pi_mutex_lock( &user_mutex );
     if (!user_lock_rec++) user_lock_thread = GetCurrentThreadId();
 }
 
 void user_unlock(void)
 {
     if (!--user_lock_rec) user_lock_thread = 0;
-    pthread_mutex_unlock( &user_mutex );
+    pi_mutex_unlock( &user_mutex );
 }
 
 void user_check_not_lock(void)
@@ -1248,7 +1249,7 @@ static void add_gpu( const struct gdi_gp
     if (!ctx->mutex)
     {
         ctx->mutex = get_display_device_init_mutex();
-        pthread_mutex_lock( &display_lock );
+        pi_mutex_lock( &display_lock );
         prepare_devices();
     }
 
@@ -1650,7 +1651,7 @@ static void release_display_manager_ctx(
 {
     if (ctx->mutex)
     {
-        pthread_mutex_unlock( &display_lock );
+        pi_mutex_unlock( &display_lock );
         release_display_device_init_mutex( ctx->mutex );
         ctx->mutex = 0;
     }
@@ -1707,7 +1708,7 @@ static BOOL update_display_cache_from_re
     if (key.LastWriteTime.QuadPart <= last_query_display_time) return TRUE;
 
     mutex = get_display_device_init_mutex();
-    pthread_mutex_lock( &display_lock );
+    pi_mutex_lock( &display_lock );
 
     clear_display_devices();
 
@@ -1752,7 +1753,7 @@ static BOOL update_display_cache_from_re
 
     if ((ret = !list_empty( &adapters ) && !list_empty( &monitors )))
         last_query_display_time = key.LastWriteTime.QuadPart;
-    pthread_mutex_unlock( &display_lock );
+    pi_mutex_unlock( &display_lock );
     release_display_device_init_mutex( mutex );
     return ret;
 }
@@ -2033,10 +2034,10 @@ BOOL update_display_cache( BOOL force )
     if (NtUserGetObjectInformation( winstation, UOI_NAME, name, sizeof(name), NULL )
         && !wcscmp( name, wine_service_station_name ))
     {
-        pthread_mutex_lock( &display_lock );
+        pi_mutex_lock( &display_lock );
         clear_display_devices();
         list_add_tail( &monitors, &virtual_monitor.entry );
-        pthread_mutex_unlock( &display_lock );
+        pi_mutex_unlock( &display_lock );
         return TRUE;
     }
 
@@ -2076,25 +2077,25 @@ BOOL update_display_cache( BOOL force )
 static BOOL lock_display_devices(void)
 {
     if (!update_display_cache( FALSE )) return FALSE;
-    pthread_mutex_lock( &display_lock );
+    pi_mutex_lock( &display_lock );
     return TRUE;
 }
 
 static void unlock_display_devices(void)
 {
-    pthread_mutex_unlock( &display_lock );
+    pi_mutex_unlock( &display_lock );
 }
 
 static HDC get_display_dc(void)
 {
-    pthread_mutex_lock( &display_dc_lock );
+    pi_mutex_lock( &display_dc_lock );
     if (!display_dc)
     {
         HDC dc;
 
-        pthread_mutex_unlock( &display_dc_lock );
+        pi_mutex_unlock( &display_dc_lock );
         dc = NtGdiOpenDCW( NULL, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
-        pthread_mutex_lock( &display_dc_lock );
+        pi_mutex_lock( &display_dc_lock );
         if (display_dc)
             NtGdiDeleteObjectApp( dc );
         else
@@ -2105,7 +2106,7 @@ static HDC get_display_dc(void)
 
 static void release_display_dc( HDC hdc )
 {
-    pthread_mutex_unlock( &display_dc_lock );
+    pi_mutex_unlock( &display_dc_lock );
 }
 
 /**********************************************************************
@@ -4639,7 +4640,6 @@ void sysparams_init(void)
     WCHAR buffer[MAX_PATH+16], *p, *appname;
     DWORD i, dispos, dpi_scaling;
     WCHAR layout[KL_NAMELENGTH];
-    pthread_mutexattr_t attr;
     HKEY hkey, appkey = 0;
     DWORD len;
 
@@ -4652,10 +4652,6 @@ void sysparams_init(void)
         {'K','e','y','b','o','a','r','d',' ','L','a','y','o','u','t','\\','P','r','e','l','o','a','d'};
     static const WCHAR x11driverW[] = {'\\','X','1','1',' ','D','r','i','v','e','r',0};
 
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &user_mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
 
     if ((hkey = reg_create_key( hkcu_key, kl_preloadW, sizeof(kl_preloadW), 0, NULL )))
     {
diff -Npur a/dlls/winealsa.drv/alsa.c b/dlls/winealsa.drv/alsa.c
--- a/dlls/winealsa.drv/alsa.c	2024-05-01 15:46:47.261975313 -0500
+++ b/dlls/winealsa.drv/alsa.c	2024-05-01 15:50:02.361910944 -0500
@@ -26,6 +26,7 @@
 #include <stdarg.h>
 #include <stdio.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #include <alsa/asoundlib.h>
 
@@ -79,7 +80,7 @@ struct alsa_stream
     LONG32 getbuf_last; /* <0 when using tmp_buffer */
     float *vols;
 
-    pthread_mutex_t lock;
+    pi_mutex_t lock;
 };
 
 #define EXTRA_SAFE_RT 40000
@@ -209,12 +210,12 @@ static int muldiv( int a, int b, int c )
 
 static void alsa_lock(struct alsa_stream *stream)
 {
-    pthread_mutex_lock(&stream->lock);
+    pi_mutex_lock(&stream->lock);
 }
 
 static void alsa_unlock(struct alsa_stream *stream)
 {
-    pthread_mutex_unlock(&stream->lock);
+    pi_mutex_unlock(&stream->lock);
 }
 
 static NTSTATUS alsa_unlock_result(struct alsa_stream *stream,
@@ -1036,7 +1037,6 @@ static NTSTATUS alsa_create_stream(void
     stream->share = params->share;
     stream->flags = params->flags;
 
-    pthread_mutex_init(&stream->lock, NULL);
 
     TRACE("ALSA period: %lu frames\n", stream->alsa_period_frames);
     TRACE("ALSA buffer: %lu frames\n", stream->alsa_bufsize_frames);
diff -Npur a/dlls/winealsa.drv/alsamidi.c b/dlls/winealsa.drv/alsamidi.c
--- a/dlls/winealsa.drv/alsamidi.c	2024-05-01 15:46:47.261975313 -0500
+++ b/dlls/winealsa.drv/alsamidi.c	2024-05-01 15:50:02.362910949 -0500
@@ -33,6 +33,7 @@
 #include <stdint.h>
 #include <unistd.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <time.h>
 #include <alsa/asoundlib.h>
 
@@ -76,8 +77,8 @@ struct midi_src
     int                 port_in;
 };
 
-static pthread_mutex_t seq_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t in_buffer_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t seq_mutex = PI_MUTEX_INIT(0);
+static pi_mutex_t in_buffer_mutex = PI_MUTEX_INIT(0);
 
 static unsigned int num_dests, num_srcs;
 static struct midi_dest dests[MAX_MIDIOUTDRV];
@@ -90,9 +91,9 @@ static unsigned int num_midi_in_started;
 static int rec_cancel_pipe[2];
 static pthread_t rec_thread_id;
 
-static pthread_mutex_t notify_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t notify_read_cond = PTHREAD_COND_INITIALIZER;
-static pthread_cond_t notify_write_cond = PTHREAD_COND_INITIALIZER;
+static pi_mutex_t notify_mutex = PI_MUTEX_INIT(0);
+static pi_cond_t notify_read_cond = PI_COND_INIT(0);
+static pi_cond_t notify_write_cond = PI_COND_INIT(0);
 static BOOL notify_quit;
 #define NOTIFY_BUFFER_SIZE 64 + 1 /* + 1 for the sentinel */
 static struct notify_context notify_buffer[NOTIFY_BUFFER_SIZE];
@@ -100,22 +101,22 @@ static struct notify_context *notify_rea
 
 static void seq_lock(void)
 {
-    pthread_mutex_lock(&seq_mutex);
+    pi_mutex_lock(&seq_mutex);
 }
 
 static void seq_unlock(void)
 {
-    pthread_mutex_unlock(&seq_mutex);
+    pi_mutex_unlock(&seq_mutex);
 }
 
 static void in_buffer_lock(void)
 {
-    pthread_mutex_lock(&in_buffer_mutex);
+    pi_mutex_lock(&in_buffer_mutex);
 }
 
 static void in_buffer_unlock(void)
 {
-    pthread_mutex_unlock(&in_buffer_mutex);
+    pi_mutex_unlock(&in_buffer_mutex);
 }
 
 static uint64_t get_time_msec(void)
@@ -188,19 +189,19 @@ static BOOL notify_buffer_remove(struct
 
 static void notify_post(struct notify_context *notify)
 {
-    pthread_mutex_lock(&notify_mutex);
+    pi_mutex_lock(&notify_mutex);
 
     if (notify)
     {
         while (notify_buffer_full())
-            pthread_cond_wait(&notify_write_cond, &notify_mutex);
+            pi_cond_wait(&notify_write_cond, &notify_mutex);
 
         notify_buffer_add(notify);
     }
     else notify_quit = TRUE;
-    pthread_cond_signal(&notify_read_cond);
+    pi_cond_signal(&notify_read_cond, &notify_mutex);
 
-    pthread_mutex_unlock(&notify_mutex);
+    pi_mutex_unlock(&notify_mutex);
 }
 
 static snd_seq_t *seq_open(int *port_in_ret)
@@ -1506,18 +1507,18 @@ NTSTATUS alsa_midi_notify_wait(void *arg
 {
     struct midi_notify_wait_params *params = args;
 
-    pthread_mutex_lock(&notify_mutex);
+    pi_mutex_lock(&notify_mutex);
 
     while (!notify_quit && notify_buffer_empty())
-        pthread_cond_wait(&notify_read_cond, &notify_mutex);
+        pi_cond_wait(&notify_read_cond, &notify_mutex);
 
     *params->quit = notify_quit;
     if (!notify_quit)
     {
         notify_buffer_remove(params->notify);
-        pthread_cond_signal(&notify_write_cond);
+        pi_cond_signal(&notify_write_cond, &notify_mutex);
     }
-    pthread_mutex_unlock(&notify_mutex);
+    pi_mutex_unlock(&notify_mutex);
 
     return STATUS_SUCCESS;
 }
diff -Npur a/dlls/winealsa.drv/Makefile.in b/dlls/winealsa.drv/Makefile.in
--- a/dlls/winealsa.drv/Makefile.in	2024-05-01 15:46:47.260975308 -0500
+++ b/dlls/winealsa.drv/Makefile.in	2024-05-01 15:50:04.368920252 -0500
@@ -2,7 +2,7 @@ MODULE    = winealsa.drv
 UNIXLIB   = winealsa.so
 IMPORTS   = uuid ole32 advapi32
 DELAYIMPORTS = winmm
-UNIX_LIBS    = $(ALSA_LIBS) $(PTHREAD_LIBS)
+UNIX_LIBS    = $(ALSA_LIBS) $(PTHREAD_LIBS) -lrtpi
 
 C_SRCS = \
 	alsa.c \
diff -Npur a/dlls/winebus.sys/bus_iohid.c b/dlls/winebus.sys/bus_iohid.c
--- a/dlls/winebus.sys/bus_iohid.c	2024-05-01 15:46:47.263975323 -0500
+++ b/dlls/winebus.sys/bus_iohid.c	2024-05-01 15:50:03.132914521 -0500
@@ -84,6 +84,7 @@
 #endif /* __APPLE__ */
 
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -100,7 +101,7 @@
 WINE_DEFAULT_DEBUG_CHANNEL(hid);
 #ifdef __APPLE__
 
-static pthread_mutex_t iohid_cs = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t iohid_cs = PI_MUTEX_INIT(0);
 
 static IOHIDManagerRef hid_manager;
 static CFRunLoopRef run_loop;
@@ -177,9 +178,9 @@ static void iohid_device_stop(struct uni
 
     IOHIDDeviceRegisterInputReportCallback(impl->device, NULL, 0, NULL, NULL);
 
-    pthread_mutex_lock(&iohid_cs);
+    pi_mutex_lock(&iohid_cs);
     list_remove(&impl->unix_device.entry);
-    pthread_mutex_unlock(&iohid_cs);
+    pi_mutex_unlock(&iohid_cs);
 }
 
 static NTSTATUS iohid_device_get_report_descriptor(struct unix_device *iface, BYTE *buffer,
@@ -399,9 +400,9 @@ NTSTATUS iohid_bus_wait(void *args)
     do
     {
         if (bus_event_queue_pop(&event_queue, result)) return STATUS_PENDING;
-        pthread_mutex_lock(&iohid_cs);
+        pi_mutex_lock(&iohid_cs);
         ret = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, TRUE);
-        pthread_mutex_unlock(&iohid_cs);
+        pi_mutex_unlock(&iohid_cs);
     } while (ret != kCFRunLoopRunStopped);
 
     TRACE("IOHID main loop exiting\n");
diff -Npur a/dlls/winebus.sys/bus_sdl.c b/dlls/winebus.sys/bus_sdl.c
--- a/dlls/winebus.sys/bus_sdl.c	2024-05-01 15:46:47.263975323 -0500
+++ b/dlls/winebus.sys/bus_sdl.c	2024-05-01 15:50:03.131914516 -0500
@@ -37,6 +37,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -60,7 +61,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(hid);
 
 #ifdef SONAME_LIBSDL2
 
-static pthread_mutex_t sdl_cs = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t sdl_cs = PI_MUTEX_INIT(0);
 static struct sdl_bus_options options;
 
 static void *sdl_handle = NULL;
@@ -443,13 +444,13 @@ static NTSTATUS sdl_device_start(struct
     struct sdl_device *impl = impl_from_unix_device(iface);
     NTSTATUS status;
 
-    pthread_mutex_lock(&sdl_cs);
+    pi_mutex_lock(&sdl_cs);
 
     if (impl->sdl_controller) status = build_controller_report_descriptor(iface);
     else status = build_joystick_report_descriptor(iface);
     impl->started = !status;
 
-    pthread_mutex_unlock(&sdl_cs);
+    pi_mutex_unlock(&sdl_cs);
 
     return status;
 }
@@ -462,10 +463,10 @@ static void sdl_device_stop(struct unix_
     if (impl->sdl_controller) pSDL_GameControllerClose(impl->sdl_controller);
     if (impl->sdl_haptic) pSDL_HapticClose(impl->sdl_haptic);
 
-    pthread_mutex_lock(&sdl_cs);
+    pi_mutex_lock(&sdl_cs);
     impl->started = FALSE;
     list_remove(&impl->unix_device.entry);
-    pthread_mutex_unlock(&sdl_cs);
+    pi_mutex_unlock(&sdl_cs);
 }
 
 static NTSTATUS sdl_device_haptics_start(struct unix_device *iface, UINT duration_ms,
@@ -812,10 +813,10 @@ static void check_all_devices_effects_st
     if (ticks - last_ticks < 10) return;
     last_ticks = ticks;
 
-    pthread_mutex_lock(&sdl_cs);
+    pi_mutex_lock(&sdl_cs);
     LIST_FOR_EACH_ENTRY(impl, &device_list, struct sdl_device, unix_device.entry)
         check_device_effects_state(impl);
-    pthread_mutex_unlock(&sdl_cs);
+    pi_mutex_unlock(&sdl_cs);
 }
 
 static BOOL set_report_from_joystick_event(struct sdl_device *impl, SDL_Event *event)
@@ -1021,7 +1022,7 @@ static void process_device_event(SDL_Eve
 
     TRACE("Received action %x\n", event->type);
 
-    pthread_mutex_lock(&sdl_cs);
+    pi_mutex_lock(&sdl_cs);
 
     if (event->type == SDL_JOYDEVICEADDED)
         sdl_add_device(((SDL_JoyDeviceEvent *)event)->which);
@@ -1061,7 +1062,7 @@ static void process_device_event(SDL_Eve
         else set_report_from_controller_event(impl, event);
     }
 
-    pthread_mutex_unlock(&sdl_cs);
+    pi_mutex_unlock(&sdl_cs);
 }
 
 NTSTATUS sdl_bus_init(void *args)
diff -Npur a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
--- a/dlls/winebus.sys/bus_udev.c	2024-05-01 15:46:47.264975328 -0500
+++ b/dlls/winebus.sys/bus_udev.c	2024-05-01 15:50:03.131914516 -0500
@@ -61,6 +61,7 @@
 #endif
 
 #include <pthread.h>
+#include <rtpi.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -92,7 +93,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(hid);
 
 #ifdef HAVE_UDEV
 
-static pthread_mutex_t udev_cs = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t udev_cs = PI_MUTEX_INIT(0);
 
 static struct udev *udev_context = NULL;
 static struct udev_monitor *udev_monitor;
@@ -279,9 +280,9 @@ static void hidraw_device_destroy(struct
 
 static NTSTATUS hidraw_device_start(struct unix_device *iface)
 {
-    pthread_mutex_lock(&udev_cs);
+    pi_mutex_lock(&udev_cs);
     start_polling_device(iface);
-    pthread_mutex_unlock(&udev_cs);
+    pi_mutex_unlock(&udev_cs);
     return STATUS_SUCCESS;
 }
 
@@ -289,10 +290,10 @@ static void hidraw_device_stop(struct un
 {
     struct hidraw_device *impl = hidraw_impl_from_unix_device(iface);
 
-    pthread_mutex_lock(&udev_cs);
+    pi_mutex_lock(&udev_cs);
     stop_polling_device(iface);
     list_remove(&impl->base.unix_device.entry);
-    pthread_mutex_unlock(&udev_cs);
+    pi_mutex_unlock(&udev_cs);
 }
 
 static NTSTATUS hidraw_device_get_report_descriptor(struct unix_device *iface, BYTE *buffer,
@@ -834,9 +835,9 @@ static NTSTATUS lnxev_device_start(struc
     if ((status = build_report_descriptor(iface, impl->base.udev_device)))
         return status;
 
-    pthread_mutex_lock(&udev_cs);
+    pi_mutex_lock(&udev_cs);
     start_polling_device(iface);
-    pthread_mutex_unlock(&udev_cs);
+    pi_mutex_unlock(&udev_cs);
     return STATUS_SUCCESS;
 }
 
@@ -844,10 +845,10 @@ static void lnxev_device_stop(struct uni
 {
     struct lnxev_device *impl = lnxev_impl_from_unix_device(iface);
 
-    pthread_mutex_lock(&udev_cs);
+    pi_mutex_lock(&udev_cs);
     stop_polling_device(iface);
     list_remove(&impl->base.unix_device.entry);
-    pthread_mutex_unlock(&udev_cs);
+    pi_mutex_unlock(&udev_cs);
 }
 
 static void lnxev_device_read_report(struct unix_device *iface)
@@ -1820,16 +1821,16 @@ NTSTATUS udev_bus_wait(void *args)
     {
         if (bus_event_queue_pop(&event_queue, result)) return STATUS_PENDING;
 
-        pthread_mutex_lock(&udev_cs);
+        pi_mutex_lock(&udev_cs);
         while (close_count--) close(close_fds[close_count]);
         memcpy(pfd, poll_fds, poll_count * sizeof(*pfd));
         count = poll_count;
         close_count = 0;
-        pthread_mutex_unlock(&udev_cs);
+        pi_mutex_unlock(&udev_cs);
 
         while (poll(pfd, count, -1) <= 0) {}
 
-        pthread_mutex_lock(&udev_cs);
+        pi_mutex_lock(&udev_cs);
         if (pfd[0].revents)
         {
             if (udev_monitor) process_monitor_event(udev_monitor);
@@ -1844,7 +1845,7 @@ NTSTATUS udev_bus_wait(void *args)
             impl = find_device_from_fd(pfd[i].fd);
             if (impl) impl->read_report(&impl->unix_device);
         }
-        pthread_mutex_unlock(&udev_cs);
+        pi_mutex_unlock(&udev_cs);
     }
 
     TRACE("UDEV main loop exiting\n");
diff -Npur a/dlls/winebus.sys/Makefile.in b/dlls/winebus.sys/Makefile.in
--- a/dlls/winebus.sys/Makefile.in	2024-05-01 15:46:47.263975323 -0500
+++ b/dlls/winebus.sys/Makefile.in	2024-05-01 15:50:04.397920386 -0500
@@ -1,7 +1,7 @@
 MODULE    = winebus.sys
 UNIXLIB   = winebus.so
 IMPORTS   = ntoskrnl hidparse
-UNIX_LIBS    = $(IOKIT_LIBS) $(UDEV_LIBS) $(PTHREAD_LIBS) $(INOTIFY_LIBS)
+UNIX_LIBS    = $(IOKIT_LIBS) $(UDEV_LIBS) $(PTHREAD_LIBS) $(INOTIFY_LIBS) -lrtpi
 UNIX_CFLAGS  = $(UDEV_CFLAGS) $(SDL2_CFLAGS)
 
 EXTRADLLFLAGS = -Wl,--subsystem,native
diff -Npur a/dlls/wineusb.sys/Makefile.in b/dlls/wineusb.sys/Makefile.in
--- a/dlls/wineusb.sys/Makefile.in	2024-05-01 15:46:47.303975522 -0500
+++ b/dlls/wineusb.sys/Makefile.in	2024-05-01 15:50:04.389920349 -0500
@@ -1,7 +1,7 @@
 MODULE    = wineusb.sys
 UNIXLIB   = wineusb.so
 IMPORTS   = ntoskrnl
-UNIX_LIBS    = $(USB_LIBS) $(PTHREAD_LIBS)
+UNIX_LIBS    = $(USB_LIBS) $(PTHREAD_LIBS) -lrtpi
 UNIX_CFLAGS  = $(USB_CFLAGS)
 
 EXTRADLLFLAGS = -Wl,--subsystem,native
diff -Npur a/dlls/wineusb.sys/unixlib.c b/dlls/wineusb.sys/unixlib.c
--- a/dlls/wineusb.sys/unixlib.c	2024-05-01 15:46:47.303975522 -0500
+++ b/dlls/wineusb.sys/unixlib.c	2024-05-01 15:50:03.023914015 -0500
@@ -27,6 +27,7 @@
 #include <stdlib.h>
 #include <libusb.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
@@ -56,7 +57,7 @@ static volatile bool thread_shutdown;
 static struct usb_event *usb_events;
 static size_t usb_event_count, usb_events_capacity;
 
-static pthread_mutex_t device_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t device_mutex = PI_MUTEX_INIT(0);
 
 static struct list device_list = LIST_INIT(device_list);
 
@@ -130,9 +131,9 @@ static void add_usb_device(libusb_device
     }
     unix_device->refcount = 1;
 
-    pthread_mutex_lock(&device_mutex);
+    pi_mutex_lock(&device_mutex);
     list_add_tail(&device_list, &unix_device->entry);
-    pthread_mutex_unlock(&device_mutex);
+    pi_mutex_unlock(&device_mutex);
 
     usb_event.type = USB_EVENT_ADD_DEVICE;
     usb_event.u.added_device.device = unix_device;
@@ -199,9 +200,9 @@ static void add_usb_device(libusb_device
                 unix_iface->refcount = 1;
                 unix_iface->handle = unix_device->handle;
                 unix_iface->parent = unix_device;
-                pthread_mutex_lock(&device_mutex);
+                pi_mutex_lock(&device_mutex);
                 list_add_tail(&device_list, &unix_iface->entry);
-                pthread_mutex_unlock(&device_mutex);
+                pi_mutex_unlock(&device_mutex);
 
                 usb_event.u.added_device.device = unix_iface;
                 usb_event.u.added_device.class = iface_desc->bInterfaceClass;
@@ -603,17 +604,17 @@ static NTSTATUS usb_cancel_transfer(void
 
 static void decref_device(struct unix_device *device)
 {
-    pthread_mutex_lock(&device_mutex);
+    pi_mutex_lock(&device_mutex);
 
     if (--device->refcount)
     {
-        pthread_mutex_unlock(&device_mutex);
+        pi_mutex_unlock(&device_mutex);
         return;
     }
 
     list_remove(&device->entry);
 
-    pthread_mutex_unlock(&device_mutex);
+    pi_mutex_unlock(&device_mutex);
 
     if (device->parent)
         decref_device(device->parent);
diff -Npur a/dlls/ws2_32/Makefile.in b/dlls/ws2_32/Makefile.in
--- a/dlls/ws2_32/Makefile.in	2024-05-01 15:46:47.352975766 -0500
+++ b/dlls/ws2_32/Makefile.in	2024-05-01 15:50:04.424920512 -0500
@@ -3,7 +3,7 @@ MODULE    = ws2_32.dll
 UNIXLIB   = ws2_32.so
 IMPORTLIB = ws2_32
 DELAYIMPORTS = dnsapi advapi32 iphlpapi user32
-UNIX_LIBS    = $(PTHREAD_LIBS)
+UNIX_LIBS    = $(PTHREAD_LIBS) -lrtpi
 
 C_SRCS = \
 	async.c \
diff -Npur a/dlls/ws2_32/unixlib.c b/dlls/ws2_32/unixlib.c
--- a/dlls/ws2_32/unixlib.c	2024-05-01 15:46:47.357975791 -0500
+++ b/dlls/ws2_32/unixlib.c	2024-05-01 15:50:03.652916932 -0500
@@ -29,6 +29,7 @@
 #include "config.h"
 #include <errno.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <stdarg.h>
 #include <unistd.h>
 #include <sys/types.h>
@@ -106,7 +107,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(winsock);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 #ifndef HAVE_LINUX_GETHOSTBYNAME_R_6
-static pthread_mutex_t host_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pi_mutex_t host_mutex = PI_MUTEX_INIT(0);
 #endif
 
 #define MAP(x) {WS_ ## x, x}
@@ -921,18 +922,18 @@ static NTSTATUS unix_gethostbyaddr( void
         return ret;
     }
 #else
-    pthread_mutex_lock( &host_mutex );
+    pi_mutex_lock( &host_mutex );
 
     if (!(unix_host = gethostbyaddr( addr, params->len, unix_family )))
     {
         ret = (h_errno < 0 ? errno_from_unix( errno ) : host_errno_from_unix( h_errno ));
-        pthread_mutex_unlock( &host_mutex );
+        pi_mutex_unlock( &host_mutex );
         return ret;
     }
 
     ret = hostent_from_unix( unix_host, params->host, params->size );
 
-    pthread_mutex_unlock( &host_mutex );
+    pi_mutex_unlock( &host_mutex );
     return ret;
 #endif
 }
@@ -1020,19 +1021,19 @@ static NTSTATUS unix_gethostbyname( void
     struct hostent *unix_host;
     int ret;
 
-    pthread_mutex_lock( &host_mutex );
+    pi_mutex_lock( &host_mutex );
 
     if (!(unix_host = gethostbyname( params->name )))
     {
         ret = (h_errno < 0 ? errno_from_unix( errno ) : host_errno_from_unix( h_errno ));
-        pthread_mutex_unlock( &host_mutex );
+        pi_mutex_unlock( &host_mutex );
         return ret;
     }
 
     sort_addrs_hashed( unix_host );
     ret = hostent_from_unix( unix_host, params->host, params->size );
 
-    pthread_mutex_unlock( &host_mutex );
+    pi_mutex_unlock( &host_mutex );
     return ret;
 }
 #endif
diff -Npur a/libs/fluidsynth/src/utils/fluid_sys.c b/libs/fluidsynth/src/utils/fluid_sys.c
--- a/libs/fluidsynth/src/utils/fluid_sys.c	2024-05-01 15:46:47.417976089 -0500
+++ b/libs/fluidsynth/src/utils/fluid_sys.c	2024-05-01 15:50:01.345906230 -0500
@@ -34,6 +34,7 @@
 // Do not include pthread on windows. It includes winsock.h, which collides with ws2tcpip.h from fluid_sys.h
 // It isn't need on Windows anyway.
 #include <pthread.h>
+#include <rtpi.h>
 #endif
 
 /* WIN32 HACK - Flag used to differentiate between a file descriptor and a socket.
diff -Npur a/libs/lcms2/src/lcms2_internal.h b/libs/lcms2/src/lcms2_internal.h
--- a/libs/lcms2/src/lcms2_internal.h	2024-05-01 15:46:47.427976139 -0500
+++ b/libs/lcms2/src/lcms2_internal.h	2024-05-01 15:50:01.635907576 -0500
@@ -321,24 +321,24 @@ cmsINLINE int _cmsLeaveCriticalSectionPr
 
 // Rest of the wide world
 #include <pthread.h>
+#include <rtpi.h>
 
-#define CMS_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
-typedef pthread_mutex_t _cmsMutex;
+#define CMS_MUTEX_INITIALIZER PI_MUTEX_INIT(0)
+typedef pi_mutex_t _cmsMutex;
 
 
 cmsINLINE int _cmsLockPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_lock(m);
+    return pi_mutex_lock(m);
 }
 
 cmsINLINE int _cmsUnlockPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_unlock(m);
+    return pi_mutex_unlock(m);
 }
 
 cmsINLINE int _cmsInitMutexPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_init(m, NULL);
 }
 
 cmsINLINE int _cmsDestroyMutexPrimitive(_cmsMutex *m)
@@ -348,12 +348,12 @@ cmsINLINE int _cmsDestroyMutexPrimitive(
 
 cmsINLINE int _cmsEnterCriticalSectionPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_lock(m);
+    return pi_mutex_lock(m);
 }
 
 cmsINLINE int _cmsLeaveCriticalSectionPrimitive(_cmsMutex *m)
 {
-    return pthread_mutex_unlock(m);
+    return pi_mutex_unlock(m);
 }
 
 #endif
diff -Npur a/loader/main.c b/loader/main.c
--- a/loader/main.c	2024-05-01 15:46:47.510976552 -0500
+++ b/loader/main.c	2024-05-01 15:50:04.260919751 -0500
@@ -22,6 +22,7 @@
 
 #include <fcntl.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff -Npur a/loader/Makefile.in b/loader/Makefile.in
--- a/loader/Makefile.in	2024-05-01 15:46:41.131944786 -0500
+++ b/loader/Makefile.in	2024-05-01 15:50:04.431920544 -0500
@@ -20,11 +20,11 @@ main_EXTRADEFS = -DDLLDIR=\"${dlldir}\"
 
 wine_OBJS = main.o
 wine_DEPS = $(WINELOADER_DEPENDS)
-wine_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS)
+wine_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS) -lrtpi
 
 wine64_OBJS = main.o
 wine64_DEPS = $(WINELOADER_DEPENDS)
-wine64_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS)
+wine64_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS) -lrtpi
 
 wine_preloader_OBJS = preloader.o preloader_mac.o
 wine_preloader_DEPS = $(WINELOADER_DEPENDS)
diff -Npur a/server/fd.c b/server/fd.c
--- a/server/fd.c	2024-05-01 15:47:17.805126280 -0500
+++ b/server/fd.c	2024-05-01 15:50:01.672907748 -0500
@@ -27,6 +27,7 @@
 #include <fcntl.h>
 #include <limits.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <stdarg.h>
 #include <stdio.h>
@@ -412,7 +413,7 @@ static void set_user_shared_data_time(ti
  
 #undef ATOMIC_STORE
 
-pthread_mutex_t global_lock = PTHREAD_MUTEX_INITIALIZER;
+pi_mutex_t global_lock = PI_MUTEX_INIT(0);
 int poll_exit_pipe[2];
 struct fd *poll_exit_fd;
 
@@ -595,7 +596,7 @@ static inline void main_loop_epoll(void)
 
     if (epoll_fd == -1) return;
 
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
     while (active_users)
     {
         unsigned long generation;
@@ -606,9 +607,9 @@ static inline void main_loop_epoll(void)
         if (epoll_fd == -1) break;  /* an error occurred with epoll */
 
         generation = poll_generation;
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
         ret = epoll_wait( epoll_fd, events, ARRAY_SIZE( events ), timeout );
-        pthread_mutex_lock( &global_lock );
+        pi_mutex_lock( &global_lock );
         set_current_time();
 
         /* put the events into the pollfd array first, like poll does */
@@ -627,7 +628,7 @@ static inline void main_loop_epoll(void)
             if (pollfd[user].revents) fd_poll_event( poll_users[user], pollfd[user].revents );
         }
     }
-    pthread_mutex_unlock( &global_lock );
+    pi_mutex_unlock( &global_lock );
 }
 
 #elif defined(HAVE_KQUEUE)
@@ -698,7 +699,7 @@ static inline void main_loop_epoll(void)
 
     if (kqueue_fd == -1) return;
 
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
     while (active_users)
     {
         unsigned long generation;
@@ -709,7 +710,7 @@ static inline void main_loop_epoll(void)
         if (kqueue_fd == -1) break;  /* an error occurred with kqueue */
 
         generation = poll_generation;
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
         if (timeout != -1)
         {
             struct timespec ts;
@@ -719,7 +720,7 @@ static inline void main_loop_epoll(void)
             ret = kevent( kqueue_fd, NULL, 0, events, ARRAY_SIZE( events ), &ts );
         }
         else ret = kevent( kqueue_fd, NULL, 0, events, ARRAY_SIZE( events ), NULL );
-        pthread_mutex_lock( &global_lock );
+        pi_mutex_lock( &global_lock );
 
         set_current_time();
 
@@ -749,7 +750,7 @@ static inline void main_loop_epoll(void)
             pollfd[user].revents = 0;
         }
     }
-    pthread_mutex_unlock( &global_lock );
+    pi_mutex_unlock( &global_lock );
 }
 
 #elif defined(USE_EVENT_PORTS)
@@ -810,7 +811,7 @@ static inline void main_loop_epoll(void)
 
     if (port_fd == -1) return;
 
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
     while (active_users)
     {
         unsigned long generation;
@@ -822,7 +823,7 @@ static inline void main_loop_epoll(void)
         if (port_fd == -1) break;  /* an error occurred with event completion */
 
         generation = poll_generation;
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
         if (timeout != -1)
         {
             struct timespec ts;
@@ -832,7 +833,7 @@ static inline void main_loop_epoll(void)
             ret = port_getn( port_fd, events, ARRAY_SIZE( events ), &nget, &ts );
         }
         else ret = port_getn( port_fd, events, ARRAY_SIZE( events ), &nget, NULL );
-        pthread_mutex_lock( &global_lock );
+        pi_mutex_lock( &global_lock );
 
 	if (ret == -1) break;  /* an error occurred with event completion */
 
@@ -858,7 +859,7 @@ static inline void main_loop_epoll(void)
             }
         }
     }
-    pthread_mutex_unlock( &global_lock );
+    pi_mutex_unlock( &global_lock );
 }
 
 #else /* HAVE_KQUEUE */
@@ -1064,7 +1065,7 @@ void main_loop(void)
     main_loop_epoll();
     /* fall through to normal poll loop */
 
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
     while (active_users)
     {
         unsigned long generation;
@@ -1074,9 +1075,9 @@ void main_loop(void)
         if (!active_users) break;  /* last user removed by a timeout */
 
         generation = poll_generation;
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
         ret = poll( pollfd, nb_users, timeout );
-        pthread_mutex_lock( &global_lock );
+        pi_mutex_lock( &global_lock );
         set_current_time();
 
         if (ret > 0)
@@ -1091,7 +1092,7 @@ void main_loop(void)
                 }
             }
         }
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
     }
 }
 
diff -Npur a/server/file.h b/server/file.h
--- a/server/file.h	2024-05-01 15:47:17.512124841 -0500
+++ b/server/file.h	2024-05-01 15:50:01.672907748 -0500
@@ -22,6 +22,7 @@
 #define __WINE_SERVER_FILE_H
 
 #include <pthread.h>
+#include <rtpi.h>
 #include <sys/types.h>
 
 #include "object.h"
@@ -80,7 +81,7 @@ struct fd_ops
 
 /* file descriptor functions */
 
-extern pthread_mutex_t global_lock;
+extern pi_mutex_t global_lock;
 extern unsigned long poll_generation;
 
 extern struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *user,
diff -Npur a/server/Makefile.in b/server/Makefile.in
--- a/server/Makefile.in	2024-05-01 15:47:17.308123838 -0500
+++ b/server/Makefile.in	2024-05-01 15:50:04.327920062 -0500
@@ -50,6 +50,6 @@ SOURCES = \
 	wineserver.man.in \
 	winstation.c
 
-UNIX_LIBS = $(LDEXECFLAGS) $(RT_LIBS) $(INOTIFY_LIBS) $(PROCSTAT_LIBS) $(DBUS_LIBS) $(PTHREAD_LIBS)
+UNIX_LIBS = $(LDEXECFLAGS) $(RT_LIBS) $(INOTIFY_LIBS) $(PROCSTAT_LIBS) $(DBUS_LIBS) $(PTHREAD_LIBS) -lrtpi
 
 unicode_EXTRADEFS = -DNLSDIR="\"${nlsdir}\"" -DBIN_TO_NLSDIR=\"`${MAKEDEP} -R ${bindir} ${nlsdir}`\"
diff -Npur a/server/scheduler.c b/server/scheduler.c
--- a/server/scheduler.c	2024-05-01 15:47:17.206123337 -0500
+++ b/server/scheduler.c	2024-05-01 15:50:01.690907831 -0500
@@ -45,6 +45,7 @@
 #include "thread.h"
 #include <unistd.h>
 #include <pthread.h>
+#include <rtpi.h>
 
 #if defined(__linux__) && defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_SCHED_H)
 
diff -Npur a/server/thread.c b/server/thread.c
--- a/server/thread.c	2024-05-01 15:47:17.785126182 -0500
+++ b/server/thread.c	2024-05-01 15:50:01.699907873 -0500
@@ -24,6 +24,7 @@
 #include <errno.h>
 #include <fcntl.h>
 #include <pthread.h>
+#include <rtpi.h>
 #include <signal.h>
 #include <stdarg.h>
 #include <stdio.h>
@@ -407,10 +408,10 @@ static void *request_shm_thread(void *pa
     volatile struct request_shm *request_shm;
     unsigned long generation = 0;
 
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
     request_shm_fd = thread->request_shm_fd;
     request_shm = thread->request_shm;
-    pthread_mutex_unlock( &global_lock );
+    pi_mutex_unlock( &global_lock );
 
     for (;;)
     {
@@ -425,7 +426,7 @@ static void *request_shm_thread(void *pa
             syscall( __NR_futex, &request_shm->futex, FUTEX_WAIT, val, NULL, NULL, 0 );
         }
 
-        pthread_mutex_lock( &global_lock );
+        pi_mutex_lock( &global_lock );
         generation = poll_generation;
 
         val = request_shm->futex;
@@ -447,19 +448,19 @@ static void *request_shm_thread(void *pa
         val = __sync_val_compare_and_swap( &request_shm->futex, 1, 0 );
         if (val != 1 && val != -1)
             fatal_protocol_error( thread, "unknown futex state %d\n", val );
-        pthread_mutex_unlock( &global_lock );
+        pi_mutex_unlock( &global_lock );
         syscall( __NR_futex, &request_shm->futex, FUTEX_WAKE, 1, NULL, NULL, 0 );
         if (poll_generation != generation)
             force_exit_poll();
     }
 
 done:
-    pthread_mutex_lock( &global_lock );
+    pi_mutex_lock( &global_lock );
 done_locked:
     if (request_shm_fd != -1) close( request_shm_fd );
     if (request_shm) munmap( (void*)request_shm, REQUEST_SHM_SIZE );
     release_object( thread );
-    pthread_mutex_unlock( &global_lock );
+    pi_mutex_unlock( &global_lock );
    if (poll_generation != generation)
         force_exit_poll();
     return NULL;


// Fixups

--- a/dlls/winealsa.drv/alsa.c.	2024-05-01 16:51:33.861572155 -0500
+++ b/dlls/winealsa.drv/alsa.c	2024-05-01 16:51:22.943532013 -0500
@@ -1091,7 +1091,7 @@ static NTSTATUS alsa_release_stream(void
     free(stream->hw_params);
     free(stream->fmt);
     free(stream->vols);
-    pthread_mutex_destroy(&stream->lock);
+    pi_mutex_destroy(&stream->lock);
     free(stream);
 
     params->result = S_OK;

