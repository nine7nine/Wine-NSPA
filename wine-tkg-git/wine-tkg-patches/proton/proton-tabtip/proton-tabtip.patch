From 7440c4f31475e7c6d4676d99e9fc9006165c55b3 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 13 Dec 2021 10:57:27 -0500
Subject: [PATCH] uiautomationcore: Add more UI Automation interface
 definitions.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 include/uiautomationclient.idl | 1336 ++++++++++++++++++++++++++++++++
 include/uiautomationcore.idl   |  136 ++++
 2 files changed, 1472 insertions(+)

diff --git a/include/uiautomationclient.idl b/include/uiautomationclient.idl
index 917d3456ebf..0079f5316b9 100644
--- a/include/uiautomationclient.idl
+++ b/include/uiautomationclient.idl
@@ -19,6 +19,37 @@
 #define DO_NO_IMPORTS
 import "uiautomationcore.idl";

+cpp_quote( "#ifndef _INC_UIAUTOMATIONCOREAPI" )
+
+enum TreeScope {
+    TreeScope_Element     = 0x01,
+    TreeScope_Children    = 0x02,
+    TreeScope_Descendants = 0x04,
+    TreeScope_Parent      = 0x08,
+    TreeScope_Ancestors   = 0x10,
+    TreeScope_SubTree     = TreeScope_Element | TreeScope_Children | TreeScope_Descendants,
+};
+
+enum PropertyConditionFlags {
+    PropertyConditionFlags_None       = 0x00,
+    PropertyConditionFlags_IgnoreCase = 0x01,
+};
+
+enum AutomationElementMode {
+    AutomationElementMode_None = 0x00,
+    AutomationElementMode_Full = 0x01,
+};
+
+cpp_quote( "#endif" )
+
+struct ExtendedProperty
+{
+    BSTR PropertyName;
+    BSTR PropertyValue;
+};
+
+typedef HWND UIA_HWND;
+
 [
     uuid(944de083-8fb8-45cf-bcb7-c477acb2f897),
     lcid(0),
@@ -70,6 +101,49 @@ library UIAutomationClient {
     }
     */

+    /* FIXME: Uncomment when properly supported in widl
+    [dllname("<no entry points>")]
+    module UIA_EventIds
+    {
+    */
+        const long UIA_ToolTipOpenedEventId = 20000;
+        const long UIA_ToolTipClosedEventId = 20001;
+        const long UIA_StructureChangedEventId = 20002;
+        const long UIA_MenuOpenedEventId = 20003;
+        const long UIA_AutomationPropertyChangedEventId = 20004;
+        const long UIA_AutomationFocusChangedEventId = 20005;
+        const long UIA_AsyncContentLoadedEventId = 20006;
+        const long UIA_MenuClosedEventId = 20007;
+        const long UIA_LayoutInvalidatedEventId = 20008;
+        const long UIA_Invoke_InvokedEventId = 20009;
+        const long UIA_SelectionItem_ElementAddedToSelectionEventId = 20010;
+        const long UIA_SelectionItem_ElementRemovedFromSelectionEventId = 20011;
+        const long UIA_SelectionItem_ElementSelectedEventId= 20012;
+        const long UIA_Selection_InvalidatedEventId = 20013;
+        const long UIA_Text_TextSelectionChangedEventId = 20014;
+        const long UIA_Text_TextChangedEventId = 20015;
+        const long UIA_Window_WindowOpenedEventId = 20016;
+        const long UIA_Window_WindowClosedEventId = 20017;
+        const long UIA_MenuModeStartEventId = 20018;
+        const long UIA_MenuModeEndEventId = 20019;
+        const long UIA_InputReachedTargetEventId = 20020;
+        const long UIA_InputReachedOtherElementEventId = 20021;
+        const long UIA_InputDiscardedEventId = 20022;
+        const long UIA_SystemAlertEventId = 20023;
+        const long UIA_LiveRegionChangedEventId = 20024;
+        const long UIA_HostedFragmentRootsInvalidatedEventId = 20025;
+        const long UIA_Drag_DragStartEventId = 20026;
+        const long UIA_Drag_DragCancelEventId = 20027;
+        const long UIA_Drag_DragCompleteEventId = 20028;
+        const long UIA_DropTarget_DragEnterEventId = 20029;
+        const long UIA_DropTarget_DragLeaveEventId = 20030;
+        const long UIA_DropTarget_DroppedEventId = 20031;
+        const long UIA_TextEdit_TextChangedEventId = 20032;
+        const long UIA_TextEdit_ConversionTargetChangedEventId = 20033;
+    /*
+    };
+    */
+
     /* FIXME: Uncomment when properly supported in widl
     [dllname("<no entry points>")]
     module UIA_PropertyIds
@@ -253,4 +327,1266 @@ library UIAutomationClient {
     /*
     }
     */
+
+    /* FIXME: Uncomment when properly supported in widl
+    [dllname("<no entry points>")]
+    module UIA_ControlTypeIds
+    {
+    */
+        const long UIA_ButtonControlTypeId = 50000;
+        const long UIA_CalendarControlTypeId = 50001;
+        const long UIA_CheckBoxControlTypeId = 50002;
+        const long UIA_ComboBoxControlTypeId = 50003;
+        const long UIA_EditControlTypeId = 50004;
+        const long UIA_HyperlinkControlTypeId = 50005;
+        const long UIA_ImageControlTypeId = 50006;
+        const long UIA_ListItemControlTypeId = 50007;
+        const long UIA_ListControlTypeId = 50008;
+        const long UIA_MenuControlTypeId = 50009;
+        const long UIA_MenuBarControlTypeId = 50010;
+        const long UIA_MenuItemControlTypeId = 50011;
+        const long UIA_ProgressBarControlTypeId = 50012;
+        const long UIA_RadioButtonControlTypeId = 50013;
+        const long UIA_ScrollBarControlTypeId = 50014;
+        const long UIA_SliderControlTypeId = 50015;
+        const long UIA_SpinnerControlTypeId = 50016;
+        const long UIA_StatusBarControlTypeId = 50017;
+        const long UIA_TabControlTypeId = 50018;
+        const long UIA_TabItemControlTypeId = 50019;
+        const long UIA_TextControlTypeId = 50020;
+        const long UIA_ToolBarControlTypeId = 50021;
+        const long UIA_ToolTipControlTypeId = 50022;
+        const long UIA_TreeControlTypeId = 50023;
+        const long UIA_TreeItemControlTypeId = 50024;
+        const long UIA_CustomControlTypeId = 50025;
+        const long UIA_GroupControlTypeId = 50026;
+        const long UIA_ThumbControlTypeId = 50027;
+        const long UIA_DataGridControlTypeId = 50028;
+        const long UIA_DataItemControlTypeId = 50029;
+        const long UIA_DocumentControlTypeId = 50030;
+        const long UIA_SplitButtonControlTypeId = 50031;
+        const long UIA_WindowControlTypeId = 50032;
+        const long UIA_PaneControlTypeId = 50033;
+        const long UIA_HeaderControlTypeId = 50034;
+        const long UIA_HeaderItemControlTypeId = 50035;
+        const long UIA_TableControlTypeId = 50036;
+        const long UIA_TitleBarControlTypeId = 50037;
+        const long UIA_SeparatorControlTypeId = 50038;
+        const long UIA_SemanticZoomControlTypeId = 50039;
+        const long UIA_AppBarControlTypeId = 50040;
+    /*
+    };
+    */
+    interface IUIAutomationElement;
+    interface IUIAutomationElementArray;
+
+    [
+        object,
+        uuid(352ffba8-0973-437c-a61f-f64cafd81df9),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationCondition : IUnknown { }
+
+    [
+        object,
+        uuid(1b4e1f2e-75eb-4d0b-8952-5a69988e2307),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationBoolCondition : IUIAutomationCondition {
+        [propget]HRESULT BooleanValue([out, retval]BOOL *boolVal);
+    }
+
+    [
+        object,
+        uuid(99ebf2cb-5578-4267-9ad4-afd6ea77e94b),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationPropertyCondition : IUIAutomationCondition {
+        [propget]HRESULT PropertyId([out, retval]PROPERTYID *propertyId);
+        [propget]HRESULT PropertyValue([out, retval]VARIANT *propertyValue);
+        [propget]HRESULT PropertyConditionFlags([out, retval]enum PropertyConditionFlags *flags);
+    }
+
+    [
+        object,
+        uuid(a7d0af36-b912-45fe-9855-091ddc174aec),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationAndCondition : IUIAutomationCondition {
+        [propget]HRESULT ChildCount(int *childCount);
+
+        HRESULT GetChildrenAsNativeArray([out, size_is( ,*childArrayCount)]IUIAutomationCondition ***childArray,
+                                         [out]int *childArrayCount);
+
+        HRESULT GetChildren([out, retval]SAFEARRAY(IUIAutomationCondition) *childArray);
+    }
+
+    [
+        object,
+        uuid(8753f032-3db1-47b5-a1fc-6e34a266c712),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationOrCondition : IUIAutomationCondition {
+        [propget]HRESULT ChildCount([out, retval]int *childCount);
+
+        HRESULT GetChildrenAsNativeArray([out, size_is( ,*childArrayCount)]IUIAutomationCondition ***childArray,
+                                         [out]int *childArrayCount);
+
+        HRESULT GetChildren([out, retval]SAFEARRAY(IUIAutomationCondition) *childArray);
+    }
+
+    [
+        object,
+        uuid(f528b657-847b-498c-8896-d52b565407a1),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationNotCondition : IUIAutomationCondition {
+        HRESULT GetChild([out, retval]IUIAutomationCondition **condition);
+    }
+
+    [
+        object,
+        uuid(b32a92b5-bc25-4078-9c08-d7ee95c48e03),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationCacheRequest : IUnknown {
+        HRESULT AddProperty([in]PROPERTYID propertyId);
+        HRESULT AddPattern([in]PATTERNID patternId);
+        HRESULT Clone([out, retval]IUIAutomationCacheRequest **clonedRequest);
+
+        [propget]HRESULT TreeScope([out, retval]enum TreeScope *scope);
+        [propput]HRESULT TreeScope([in]enum TreeScope scope);
+        [propget]HRESULT TreeFilter([out, retval]IUIAutomationCondition **filter);
+        [propput]HRESULT TreeFilter([in]IUIAutomationCondition *filter);
+        [propget]HRESULT AutomationElementMode([out, retval]enum AutomationElementMode *mode);
+        [propput]HRESULT AutomationElementMode([in]enum AutomationElementMode mode);
+    }
+
+    [
+        object,
+        uuid(4042c624-389c-4afc-a630-9df854a541fc),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTreeWalker : IUnknown {
+        HRESULT GetParentElement([in]IUIAutomationElement *element,
+                                 [out, retval]IUIAutomationElement **parent);
+
+        HRESULT GetFirstChildElement([in]IUIAutomationElement *element,
+                                     [out, retval]IUIAutomationElement **first);
+
+        HRESULT GetLastChildElement([in]IUIAutomationElement *element,
+                                    [out, retval]IUIAutomationElement **last);
+
+        HRESULT GetNextSiblingElement([in]IUIAutomationElement *element,
+                                      [out, retval]IUIAutomationElement **next);
+
+        HRESULT GetPreviousSiblingElement([in]IUIAutomationElement *element,
+                                          [out, retval]IUIAutomationElement **previous);
+
+        HRESULT NormalizeElement([in]IUIAutomationElement *element,
+                                 [out, retval]IUIAutomationElement **normalized);
+
+        HRESULT GetParentElementBuildCache([in]IUIAutomationElement *element,
+                                           [in]IUIAutomationCacheRequest *cacheRequest,
+                                           [out, retval]IUIAutomationElement **parent);
+
+        HRESULT GetFirstChildElementBuildCache([in]IUIAutomationElement *element,
+                                               [in]IUIAutomationCacheRequest *cacheRequest,
+                                               [out, retval]IUIAutomationElement **first);
+
+        HRESULT GetLastChildElementBuildCache([in]IUIAutomationElement *element,
+                                              [in]IUIAutomationCacheRequest *cacheRequest,
+                                              [out, retval]IUIAutomationElement **last);
+
+        HRESULT GetNextSiblingElementBuildCache([in]IUIAutomationElement *element,
+                                                [in]IUIAutomationCacheRequest *cacheRequest,
+                                                [out, retval]IUIAutomationElement **next);
+
+        HRESULT GetPreviousSiblingElementBuildCache([in]IUIAutomationElement *element,
+                                                    [in]IUIAutomationCacheRequest *cacheRequest,
+                                                    [out, retval]IUIAutomationElement **previous);
+
+        HRESULT NormalizeElementBuildCache([in]IUIAutomationElement *element,
+                                           [in]IUIAutomationCacheRequest *cacheRequest,
+                                           [out, retval]IUIAutomationElement **normalized);
+
+        [propget]HRESULT Condition([out, retval]IUIAutomationCondition **condition);
+    }
+
+    [
+        object,
+        uuid(146c3c17-f12e-4e22-8c27-f894b9b79c69),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IUIAutomationEventHandler : IUnknown {
+        HRESULT HandleAutomationEvent([in]IUIAutomationElement *sender,
+                                      [in]EVENTID eventId);
+    }
+
+    [
+        object,
+        uuid(40cd37d4-c756-4b0c-8c6f-bddfeeb13b50),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IUIAutomationPropertyChangedEventHandler : IUnknown {
+        HRESULT HandlePropertyChangedEvent([in]IUIAutomationElement *sender,
+                                           [in]PROPERTYID propertyId,
+                                           [in]VARIANT newValue);
+    }
+
+    [
+        object,
+        uuid(e81d1b4e-11c5-42f8-9754-e7036c79f054),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IUIAutomationStructureChangedEventHandler : IUnknown {
+        HRESULT HandleStructureChangedEvent([in]IUIAutomationElement *sender,
+                                            [in]enum StructureChangeType changeType,
+                                            [in]SAFEARRAY(int) runtimeId);
+    }
+
+    [
+        object,
+        uuid(c270f6b5-5c69-4290-9745-7a7f97169468),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IUIAutomationFocusChangedEventHandler : IUnknown {
+        HRESULT HandleFocusChangedEvent([in]IUIAutomationElement *sender);
+    }
+
+    [
+        object,
+        uuid(92FAA680-E704-4156-931A-E32D5BB38F3F),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IUIAutomationTextEditTextChangedEventHandler : IUnknown {
+        HRESULT HandleTextEditTextChangedEvent([in]IUIAutomationElement *sender,
+                                               [in]enum TextEditChangeType textEditChangeType,
+                                               [in]SAFEARRAY(BSTR) eventStrings);
+    }
+
+    [
+        object,
+        uuid(58EDCA55-2C3E-4980-B1B9-56C17F27A2A0),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IUIAutomationChangesEventHandler : IUnknown {
+        HRESULT HandleChangesEvent([in]IUIAutomationElement *sender,
+                                   [in, size_is(changesCount)]struct UiaChangeInfo *uiaChanges,
+                                   [in]int changesCount);
+    }
+
+    [
+        object,
+        uuid(fb377fbe-8ea6-46d5-9c73-6499642d3059),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationInvokePattern : IUnknown {
+        HRESULT Invoke();
+    }
+
+    [
+        object,
+        uuid(fde5ef97-1464-48f6-90bf-43d0948e86ec),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationDockPattern : IUnknown {
+        HRESULT SetDockPosition([in]enum DockPosition dockPos);
+
+        [propget]HRESULT CurrentDockPosition([out, retval]enum DockPosition *retVal);
+        [propget]HRESULT CachedDockPosition([out, retval]enum DockPosition *retVal);
+    }
+
+    [
+        object,
+        uuid(619be086-1f4e-4ee4-bafa-210128738730),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationExpandCollapsePattern : IUnknown {
+        HRESULT Expand();
+        HRESULT Collapse();
+
+        [propget]HRESULT CurrentExpandCollapseState([out, retval]enum ExpandCollapseState *retVal);
+        [propget]HRESULT CachedExpandCollapseState([out, retval]enum ExpandCollapseState *retVal);
+    }
+
+    [
+        object,
+        uuid(414c3cdc-856b-4f5b-8538-3131c6302550),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationGridPattern : IUnknown {
+        HRESULT GetItem([in]int row,
+                        [in]int column,
+                        [out, retval]IUIAutomationElement **element);
+
+        [propget]HRESULT CurrentRowCount([out, retval]int *retVal);
+        [propget]HRESULT CurrentColumnCount([out, retval]int *retVal);
+        [propget]HRESULT CachedRowCount([out, retval]int *retVal);
+        [propget]HRESULT CachedColumnCount([out, retval]int *retVal);
+    }
+
+    [
+        object,
+        uuid(78f8ef57-66c3-4e09-bd7c-e79b2004894d),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationGridItemPattern : IUnknown {
+        [propget]HRESULT CurrentContainingGrid([out, retval]IUIAutomationElement **retVal);
+        [propget]HRESULT CurrentRow([out, retval]int *retVal);
+        [propget]HRESULT CurrentColumn([out, retval]int *retVal);
+        [propget]HRESULT CurrentRowSpan([out, retval]int *retVal);
+        [propget]HRESULT CurrentColumnSpan([out, retval]int *retVal);
+        [propget]HRESULT CachedContainingGrid([out, retval]IUIAutomationElement **retVal);
+        [propget]HRESULT CachedRow([out, retval]int *retVal);
+        [propget]HRESULT CachedColumn([out, retval]int *retVal);
+        [propget]HRESULT CachedRowSpan([out, retval]int *retVal);
+        [propget]HRESULT CachedColumnSpan([out, retval]int *retVal);
+    }
+
+    [
+        object,
+        uuid(8d253c91-1dc5-4bb5-b18f-ade16fa495e8),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationMultipleViewPattern : IUnknown {
+        HRESULT GetViewName([in]int view,
+                            [out, retval]BSTR *name);
+
+        HRESULT SetCurrentView([in]int view);
+
+        [propget]HRESULT CurrentCurrentView([out, retval]int *retVal);
+
+        HRESULT GetCurrentSupportedViews([out, retval]SAFEARRAY(int) *retVal);
+
+        [propget]HRESULT CachedCurrentView([out, retval]int *retVal);
+
+        HRESULT GetCachedSupportedViews([out, retval]SAFEARRAY(int) *retVal);
+    }
+
+    [
+        object,
+        uuid(71c284b3-c14d-4d14-981e-19751b0d756d),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationObjectModelPattern : IUnknown {
+        HRESULT GetUnderlyingObjectModel([out, retval]IUnknown **retVal);
+    }
+
+    [
+        object,
+        uuid(59213f4f-7346-49e5-b120-80555987a148),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationRangeValuePattern : IUnknown {
+        HRESULT SetValue([in]double val);
+
+        [propget]HRESULT CurrentValue([out, retval]double *retVal);
+        [propget]HRESULT CurrentIsReadOnly([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentMaximum([out, retval]double *retVal);
+        [propget]HRESULT CurrentMinimum([out, retval]double *retVal);
+        [propget]HRESULT CurrentLargeChange([out, retval]double *retVal);
+        [propget]HRESULT CurrentSmallChange([out, retval]double *retVal);
+        [propget]HRESULT CachedValue([out, retval]double *retVal);
+        [propget]HRESULT CachedIsReadOnly([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedMaximum([out, retval]double *retVal);
+        [propget]HRESULT CachedMinimum([out, retval]double *retVal);
+        [propget]HRESULT CachedLargeChange([out, retval]double *retVal);
+        [propget]HRESULT CachedSmallChange([out, retval]double *retVal);
+    }
+
+    [
+        object,
+        uuid(88f4d42a-e881-459d-a77c-73bbbb7e02dc),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationScrollPattern : IUnknown {
+        HRESULT Scroll([in]enum ScrollAmount horizontalAmount,
+                       [in]enum ScrollAmount verticalAmount);
+
+        HRESULT SetScrollPercent([in]double horizontalPercent,
+                                 [in]double verticalPercent);
+
+        [propget]HRESULT CurrentHorizontalScrollPercent ([out, retval]double *retVal);
+        [propget]HRESULT CurrentVerticalScrollPercent ([out, retval]double *retVal);
+        [propget]HRESULT CurrentHorizontalViewSize ([out, retval]double *retVal);
+        [propget]HRESULT CurrentVerticalViewSize ([out, retval]double *retVal);
+        [propget]HRESULT CurrentHorizontallyScrollable ([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentVerticallyScrollable ([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedHorizontalScrollPercent ([out, retval]double *retVal);
+        [propget]HRESULT CachedVerticalScrollPercent ([out, retval]double *retVal);
+        [propget]HRESULT CachedHorizontalViewSize ([out, retval]double *retVal);
+        [propget]HRESULT CachedVerticalViewSize([out, retval]double *retVal);
+        [propget]HRESULT CachedHorizontallyScrollable([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedVerticallyScrollable([out, retval]BOOL *retVal);
+    }
+
+    [
+        object,
+        uuid(b488300f-d015-4f19-9c29-bb595e3645ef),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationScrollItemPattern : IUnknown {
+        HRESULT ScrollIntoView();
+    }
+
+    [
+        object,
+        uuid(5ed5202e-b2ac-47a6-b638-4b0bf140d78e),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationSelectionPattern : IUnknown {
+        HRESULT GetCurrentSelection([out, retval]IUIAutomationElementArray **retVal);
+
+        [propget]HRESULT CurrentCanSelectMultiple([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentIsSelectionRequired([out, retval]BOOL *retVal);
+
+        HRESULT GetCachedSelection([out, retval]IUIAutomationElementArray **retVal);
+
+        [propget]HRESULT CachedCanSelectMultiple([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedIsSelectionRequired([out, retval]BOOL *retVal);
+    }
+
+    [
+        object,
+        uuid(a8efa66a-0fda-421a-9194-38021f3578ea),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationSelectionItemPattern : IUnknown {
+        HRESULT Select();
+        HRESULT AddToSelection();
+        HRESULT RemoveFromSelection();
+
+        [propget]HRESULT CurrentIsSelected([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentSelectionContainer([out, retval]IUIAutomationElement **retVal);
+        [propget]HRESULT CachedIsSelected([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedSelectionContainer([out, retval]IUIAutomationElement **retVal);
+    }
+
+    [
+        object,
+        uuid(2233be0b-afb7-448b-9fda-3b378aa5eae1),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationSynchronizedInputPattern : IUnknown {
+        HRESULT StartListening([in]enum SynchronizedInputType inputType);
+        HRESULT Cancel();
+    }
+
+    [
+        object,
+        uuid(620e691c-ea96-4710-a850-754b24ce2417),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTablePattern : IUnknown {
+        HRESULT GetCurrentRowHeaders([out, retval]IUIAutomationElementArray **retVal);
+        HRESULT GetCurrentColumnHeaders([out, retval]IUIAutomationElementArray **retVal);
+
+        [propget]HRESULT CurrentRowOrColumnMajor([out, retval]enum RowOrColumnMajor *retVal);
+
+        HRESULT GetCachedRowHeaders([out, retval]IUIAutomationElementArray **retVal);
+        HRESULT GetCachedColumnHeaders([out, retval]IUIAutomationElementArray **retVal);
+
+        [propget]HRESULT CachedRowOrColumnMajor([out, retval]enum RowOrColumnMajor *retVal);
+    }
+
+    [
+        object,
+        uuid(0b964eb3-ef2e-4464-9c79-61d61737a27e),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTableItemPattern : IUnknown {
+        HRESULT GetCurrentRowHeaderItems([out, retval]IUIAutomationElementArray **retVal);
+        HRESULT GetCurrentColumnHeaderItems([out, retval]IUIAutomationElementArray **retVal);
+        HRESULT GetCachedRowHeaderItems([out, retval]IUIAutomationElementArray **retVal);
+        HRESULT GetCachedColumnHeaderItems([out, retval]IUIAutomationElementArray **retVal);
+    }
+
+    [
+        object,
+        uuid(94cf8058-9b8d-4ab9-8bfd-4cd0a33c8c70),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTogglePattern : IUnknown {
+        HRESULT Toggle();
+
+        [propget]HRESULT CurrentToggleState([out, retval]enum ToggleState *retVal);
+        [propget]HRESULT CachedToggleState([out, retval]enum ToggleState *retVal);
+    }
+
+    [
+        object,
+        uuid(a9b55844-a55d-4ef0-926d-569c16ff89bb),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTransformPattern : IUnknown {
+        HRESULT Move([in]double x, [in]double y);
+        HRESULT Resize([in]double width, [in]double height);
+        HRESULT Rotate([in]double degrees);
+
+        [propget]HRESULT CurrentCanMove([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentCanResize([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentCanRotate([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedCanMove([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedCanResize([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedCanRotate([out, retval]BOOL *retVal);
+    }
+
+    [
+        object,
+        uuid(a94cd8b1-0844-4cd6-9d2d-640537ab39e9),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationValuePattern : IUnknown {
+        HRESULT SetValue([in]BSTR val);
+
+        [propget]HRESULT CurrentValue([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentIsReadOnly([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedValue([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedIsReadOnly([out, retval]BOOL *retVal);
+    }
+
+    [
+        object,
+        uuid(0faef453-9208-43ef-bbb2-3b485177864f),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationWindowPattern : IUnknown {
+        HRESULT Close();
+        HRESULT WaitForInputIdle([in]int milliseconds,
+                                 [out, retval]BOOL *success);
+        HRESULT SetWindowVisualState([in]enum WindowVisualState state);
+
+        [propget]HRESULT CurrentCanMaximize([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentCanMinimize([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentIsModal([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentIsTopmost([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentWindowVisualState([out, retval]enum WindowVisualState *retVal);
+        [propget]HRESULT CurrentWindowInteractionState([out, retval]enum WindowInteractionState *retVal);
+        [propget]HRESULT CachedCanMaximize([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedCanMinimize([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedIsModal([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedIsTopmost([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedWindowVisualState([out, retval]enum WindowVisualState *retVal);
+        [propget]HRESULT CachedWindowInteractionState([out, retval]enum WindowInteractionState *retVal);
+    }
+
+    [
+        object,
+        uuid(a543cc6a-f4ae-494b-8239-c814481187a8),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextRange : IUnknown {
+        HRESULT Clone([out, retval]IUIAutomationTextRange **clonedRange);
+        HRESULT Compare([in]IUIAutomationTextRange *range, [out, retval]BOOL *areSame);
+        HRESULT CompareEndpoints([in]enum TextPatternRangeEndpoint srcEndPoint,
+                                 [in]IUIAutomationTextRange *range,
+                                 [in]enum TextPatternRangeEndpoint targetEndPoint,
+                                 [out, retval]int *compValue);
+        HRESULT ExpandToEnclosingUnit([in]enum TextUnit textUnit);
+
+        HRESULT FindAttribute([in]TEXTATTRIBUTEID attr,
+                              [in]VARIANT val,
+                              [in]BOOL backward,
+                              [out, retval]IUIAutomationTextRange **found);
+
+        HRESULT FindText([in]BSTR text,
+                         [in]BOOL backward,
+                         [in]BOOL ignoreCase,
+                         [out, retval]IUIAutomationTextRange **found);
+
+        HRESULT GetAttributeValue([in]TEXTATTRIBUTEID attr,
+                                  [out, retval]VARIANT *value);
+
+        HRESULT GetBoundingRectangles([out, retval]SAFEARRAY(double) *boundingRects);
+        HRESULT GetEnclosingElement([out, retval]IUIAutomationElement **enclosingElement);
+
+        HRESULT GetText([in]int maxLength,
+                        [out, retval]BSTR *text);
+
+        HRESULT Move([in]enum TextUnit unit,
+                     [in]int count,
+                     [out, retval]int *moved);
+
+        HRESULT MoveEndpointByUnit([in]enum TextPatternRangeEndpoint endpoint,
+                                   [in]enum TextUnit unit,
+                                   [in]int count,
+                                   [out, retval]int *moved);
+
+        HRESULT MoveEndpointByRange([in]enum TextPatternRangeEndpoint srcEndPoint,
+                                    [in]IUIAutomationTextRange *range,
+                                    [in]enum TextPatternRangeEndpoint targetEndPoint);
+
+        HRESULT Select();
+        HRESULT AddToSelection();
+        HRESULT RemoveFromSelection();
+        HRESULT ScrollIntoView([in]BOOL alignToTop);
+        HRESULT GetChildren([out, retval]IUIAutomationElementArray **children);
+    }
+
+    [
+        object,
+        uuid(BB9B40E0-5E04-46BD-9BE0-4B601B9AFAD4),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextRange2 : IUIAutomationTextRange {
+        HRESULT ShowContextMenu();
+    }
+
+    [
+        object,
+        uuid(ce4ae76a-e717-4c98-81ea-47371d028eb6),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextRangeArray : IUnknown {
+        [propget]HRESULT Length([out, retval]int *length);
+
+        HRESULT GetElement([in]int index,
+                           [out, retval]IUIAutomationTextRange **element);
+    }
+
+    [
+        object,
+        uuid(32eba289-3583-42c9-9c59-3b6d9a1e9b6a),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextPattern : IUnknown {
+        HRESULT RangeFromPoint([in]POINT pt,
+                               [out, retval]IUIAutomationTextRange **range);
+
+        HRESULT RangeFromChild([in]IUIAutomationElement *child,
+                               [out, retval]IUIAutomationTextRange **range);
+
+        HRESULT GetSelection([out, retval]IUIAutomationTextRangeArray **ranges);
+        HRESULT GetVisibleRanges([out, retval]IUIAutomationTextRangeArray **ranges);
+
+        [propget]HRESULT DocumentRange([out, retval]IUIAutomationTextRange **range);
+        [propget]HRESULT SupportedTextSelection([out, retval]enum SupportedTextSelection *supportedTextSelection);
+    }
+
+    [
+        object,
+        uuid(506a921a-fcc9-409f-b23b-37eb74106872),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextPattern2 : IUIAutomationTextPattern {
+        HRESULT RangeFromAnnotation([in]IUIAutomationElement *annotation,
+                                    [out, retval]IUIAutomationTextRange **range);
+
+        HRESULT GetCaretRange([out]BOOL *isActive,
+                              [out, retval]IUIAutomationTextRange **range);
+    }
+
+    [
+        object,
+        uuid(17E21576-996C-4870-99D9-BFF323380C06),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextEditPattern : IUIAutomationTextPattern {
+        HRESULT GetActiveComposition([out, retval]IUIAutomationTextRange **range);
+        HRESULT GetConversionTarget([out, retval]IUIAutomationTextRange **range);
+    }
+
+    [
+        object,
+        uuid(01EA217A-1766-47ED-A6CC-ACF492854B1F),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationCustomNavigationPattern : IUnknown {
+        HRESULT Navigate([in]enum NavigateDirection direction,
+                         [out, retval]IUIAutomationElement **pRetVal);
+    }
+
+    [
+        object,
+        uuid(828055ad-355b-4435-86d5-3b51c14a9b1b),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationLegacyIAccessiblePattern: IUnknown {
+        HRESULT Select (long flagsSelect);
+        HRESULT DoDefaultAction();
+        HRESULT SetValue(LPCWSTR szValue);
+
+        [propget]HRESULT CurrentChildId([out, retval]int *pRetVal);
+        [propget]HRESULT CurrentName([out, retval]BSTR *pszName);
+        [propget]HRESULT CurrentValue([out, retval]BSTR *pszValue);
+        [propget]HRESULT CurrentDescription([out, retval]BSTR *pszDescription);
+        [propget]HRESULT CurrentRole([out, retval]DWORD *pdwRole);
+        [propget]HRESULT CurrentState([out, retval]DWORD *pdwState);
+        [propget]HRESULT CurrentHelp([out, retval]BSTR *pszHelp);
+        [propget]HRESULT CurrentKeyboardShortcut([out, retval]BSTR *pszKeyboardShortcut);
+
+        HRESULT GetCurrentSelection([out, retval]IUIAutomationElementArray **pvarSelectedChildren);
+
+        [propget]HRESULT CurrentDefaultAction([out, retval]BSTR *pszDefaultAction);
+        [propget]HRESULT CachedChildId([out, retval]int *pRetVal);
+        [propget]HRESULT CachedName([out, retval]BSTR *pszName);
+        [propget]HRESULT CachedValue([out, retval]BSTR *pszValue);
+        [propget]HRESULT CachedDescription([out, retval]BSTR *pszDescription);
+        [propget]HRESULT CachedRole([out, retval]DWORD *pdwRole);
+        [propget]HRESULT CachedState([out, retval]DWORD *pdwState);
+        [propget]HRESULT CachedHelp([out, retval]BSTR *pszHelp);
+        [propget]HRESULT CachedKeyboardShortcut([out, retval]BSTR *pszKeyboardShortcut);
+
+        HRESULT GetCachedSelection([out, retval]IUIAutomationElementArray **pvarSelectedChildren);
+
+        [propget]HRESULT CachedDefaultAction([out, retval]BSTR *pszDefaultAction);
+
+        HRESULT GetIAccessible([out, retval]IAccessible **ppAccessible);
+    };
+
+    [
+        object,
+        uuid(c690fdb2-27a8-423c-812d-429773c9084e),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationItemContainerPattern : IUnknown {
+        HRESULT FindItemByProperty([in]IUIAutomationElement *pStartAfter,
+                                   [in]PROPERTYID propertyId,
+                                   [in]VARIANT value,
+                                   [out, retval]IUIAutomationElement **pFound);
+    };
+
+    [
+        object,
+        uuid(6ba3d7a6-04cf-4f11-8793-a8d1cde9969f),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationVirtualizedItemPattern : IUnknown {
+        HRESULT Realize();
+    };
+
+    [
+        object,
+        uuid(9a175b21-339e-41b1-8e8b-623f6b681098),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationAnnotationPattern : IUnknown {
+        [propget]HRESULT CurrentAnnotationTypeId([out, retval]int *retVal);
+        [propget]HRESULT CurrentAnnotationTypeName([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentAuthor([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentDateTime([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentTarget([out, retval]IUIAutomationElement **retVal);
+        [propget]HRESULT CachedAnnotationTypeId([out, retval]int *retVal);
+        [propget]HRESULT CachedAnnotationTypeName([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedAuthor([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedDateTime([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedTarget([out, retval]IUIAutomationElement **retVal);
+    };
+
+    [
+        object,
+        uuid(85b5f0a2-bd79-484a-ad2b-388c9838d5fb),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationStylesPattern : IUnknown {
+        [propget]HRESULT CurrentStyleId([out, retval]int *retVal);
+        [propget]HRESULT CurrentStyleName([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentFillColor([out, retval]int *retVal);
+        [propget]HRESULT CurrentFillPatternStyle([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentShape([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentFillPatternColor([out, retval]int *retVal);
+        [propget]HRESULT CurrentExtendedProperties([out, retval]BSTR *retVal);
+
+        HRESULT GetCurrentExtendedPropertiesAsArray([out, size_is( , *propertyCount)]struct ExtendedProperty **propertyArray,
+                                                    [out]int *propertyCount);
+
+        [propget]HRESULT CachedStyleId([out, retval]int *retVal);
+        [propget]HRESULT CachedStyleName([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedFillColor([out, retval]int *retVal);
+        [propget]HRESULT CachedFillPatternStyle([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedShape([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedFillPatternColor([out, retval]int *retVal);
+        [propget]HRESULT CachedExtendedProperties([out, retval]BSTR *retVal);
+
+        HRESULT GetCachedExtendedPropertiesAsArray([out, size_is( , *propertyCount)]struct ExtendedProperty **propertyArray,
+                                                   [out]int *propertyCount);
+    };
+
+    [
+        object,
+        uuid(7517a7c8-faae-4de9-9f08-29b91e8595c1),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationSpreadsheetPattern : IUnknown {
+        HRESULT GetItemByName([in]BSTR name,
+                              [out, retval]IUIAutomationElement **element);
+    };
+
+    [
+        object,
+        uuid(7d4fb86c-8d34-40e1-8e83-62c15204e335),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationSpreadsheetItemPattern : IUnknown {
+        [propget]HRESULT CurrentFormula([out, retval]BSTR *retVal);
+
+        HRESULT GetCurrentAnnotationObjects([out, retval]IUIAutomationElementArray **retVal);
+        HRESULT GetCurrentAnnotationTypes([out, retval]SAFEARRAY(int) *retVal);
+
+        [propget]HRESULT CachedFormula([out, retval]BSTR *retVal);
+
+        HRESULT GetCachedAnnotationObjects([out, retval]IUIAutomationElementArray **retVal);
+        HRESULT GetCachedAnnotationTypes([out, retval]SAFEARRAY(int) *retVal);
+    };
+
+    [
+        object,
+        uuid(6d74d017-6ecb-4381-b38b-3c17a48ff1c2),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTransformPattern2 : IUIAutomationTransformPattern {
+        HRESULT Zoom([in]double zoomValue);
+        HRESULT ZoomByUnit([in]enum ZoomUnit zoomUnit);
+
+        [propget]HRESULT CurrentCanZoom([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedCanZoom([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentZoomLevel([out, retval]double *retVal);
+        [propget]HRESULT CachedZoomLevel([out, retval]double *retVal);
+        [propget]HRESULT CurrentZoomMinimum([out, retval]double *retVal);
+        [propget]HRESULT CachedZoomMinimum([out, retval]double *retVal);
+        [propget]HRESULT CurrentZoomMaximum([out, retval]double *retVal);
+        [propget]HRESULT CachedZoomMaximum([out, retval]double *retVal);
+    }
+
+    [
+        object,
+        uuid(6552b038-ae05-40c8-abfd-aa08352aab86),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationTextChildPattern : IUnknown {
+        [propget]HRESULT TextContainer([out, retval]IUIAutomationElement **container);
+        [propget]HRESULT TextRange([out, retval]IUIAutomationTextRange **range);
+    }
+
+    [
+        object,
+        uuid(1dc7b570-1f54-4bad-bcda-d36a722fb7bd),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationDragPattern : IUnknown {
+        [propget]HRESULT CurrentIsGrabbed([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedIsGrabbed([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentDropEffect([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedDropEffect([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentDropEffects([out, retval]SAFEARRAY(BSTR) *retVal);
+        [propget]HRESULT CachedDropEffects([out, retval]SAFEARRAY(BSTR) *retVal);
+
+        HRESULT GetCurrentGrabbedItems([out, retval]IUIAutomationElementArray **retVal);
+        HRESULT GetCachedGrabbedItems([out, retval]IUIAutomationElementArray **retVal);
+    }
+
+    [
+        object,
+        uuid(69a095f7-eee4-430e-a46b-fb73b1ae39a5),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationDropTargetPattern : IUnknown {
+        [propget]HRESULT CurrentDropTargetEffect([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedDropTargetEffect([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentDropTargetEffects([out, retval]SAFEARRAY(BSTR) *retVal);
+        [propget]HRESULT CachedDropTargetEffects([out, retval]SAFEARRAY(BSTR) *retVal);
+    }
+
+    [
+        object,
+        uuid(d22108aa-8ac5-49a5-837b-37bbb3d7591e),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationElement : IUnknown {
+        HRESULT SetFocus();
+        HRESULT GetRuntimeId([out, retval]SAFEARRAY(int) *runtimeId);
+
+        HRESULT FindFirst([in]enum TreeScope scope,
+                          [in]IUIAutomationCondition *condition,
+                          [out, retval]IUIAutomationElement **found);
+
+        HRESULT FindAll([in]enum TreeScope scope,
+                        [in]IUIAutomationCondition *condition,
+                        [out, retval]IUIAutomationElementArray **found);
+
+        HRESULT FindFirstBuildCache([in]enum TreeScope scope,
+                                    [in]IUIAutomationCondition *condition,
+                                    [in]IUIAutomationCacheRequest *cacheRequest,
+                                    [out, retval]IUIAutomationElement **found);
+
+        HRESULT FindAllBuildCache([in]enum TreeScope scope,
+                                  [in]IUIAutomationCondition *condition,
+                                  [in]IUIAutomationCacheRequest *cacheRequest,
+                                  [out, retval]IUIAutomationElementArray **found);
+
+        HRESULT BuildUpdatedCache([in]IUIAutomationCacheRequest *cacheRequest,
+                                  [out, retval]IUIAutomationElement **updatedElement);
+
+        HRESULT GetCurrentPropertyValue([in]PROPERTYID propertyId,
+                                        [out, retval]VARIANT *retVal);
+
+        HRESULT GetCurrentPropertyValueEx([in]PROPERTYID propertyId,
+                                          [in]BOOL ignoreDefaultValue,
+                                          [out, retval]VARIANT *retVal);
+
+        HRESULT GetCachedPropertyValue([in]PROPERTYID propertyId,
+                                       [out, retval]VARIANT *retVal);
+
+        HRESULT GetCachedPropertyValueEx([in]PROPERTYID propertyId,
+                                         [in]BOOL ignoreDefaultValue,
+                                         [out, retval]VARIANT *retVal);
+
+        HRESULT GetCurrentPatternAs([in]PATTERNID patternId,
+                                    [in]REFIID riid,
+                                    [out, iid_is(riid), retval]void **patternObject);
+
+        HRESULT GetCachedPatternAs([in]PATTERNID patternId,
+                                   [in]REFIID riid,
+                                   [out, iid_is(riid), retval]void **patternObject);
+
+        HRESULT GetCurrentPattern([in]PATTERNID patternId,
+                                  [out, retval]IUnknown **patternObject);
+
+        HRESULT GetCachedPattern([in]PATTERNID patternId,
+                                 [out, retval]IUnknown **patternObject);
+
+        HRESULT GetCachedParent([out, retval]IUIAutomationElement **parent);
+        HRESULT GetCachedChildren([out, retval]IUIAutomationElementArray **children);
+
+        [propget]HRESULT CurrentProcessId([out, retval]int *retVal);
+        [propget]HRESULT CurrentControlType([out, retval]CONTROLTYPEID *retVal);
+        [propget]HRESULT CurrentLocalizedControlType([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentName([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentAcceleratorKey([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentAccessKey([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentHasKeyboardFocus([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentIsKeyboardFocusable([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentIsEnabled([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentAutomationId([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentClassName([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentHelpText([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentCulture([out, retval]int *retVal);
+        [propget]HRESULT CurrentIsControlElement([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentIsContentElement([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentIsPassword([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentNativeWindowHandle([out, retval]UIA_HWND *retVal);
+        [propget]HRESULT CurrentItemType([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentIsOffscreen([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentOrientation([out, retval]enum OrientationType *retVal);
+        [propget]HRESULT CurrentFrameworkId([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentIsRequiredForForm([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentItemStatus([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentBoundingRectangle([out, retval]RECT *retVal);
+        [propget]HRESULT CurrentLabeledBy([out, retval]IUIAutomationElement **retVal);
+        [propget]HRESULT CurrentAriaRole([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentAriaProperties([out, retval]BSTR *retVal);
+        [propget]HRESULT CurrentIsDataValidForForm([out, retval]BOOL *retVal);
+        [propget]HRESULT CurrentControllerFor([out, retval]IUIAutomationElementArray **retVal);
+        [propget]HRESULT CurrentDescribedBy([out, retval]IUIAutomationElementArray **retVal);
+        [propget]HRESULT CurrentFlowsTo([out, retval]IUIAutomationElementArray **retVal);
+        [propget]HRESULT CurrentProviderDescription([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedProcessId([out, retval]int *retVal);
+        [propget]HRESULT CachedControlType([out, retval]CONTROLTYPEID *retVal);
+        [propget]HRESULT CachedLocalizedControlType([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedName([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedAcceleratorKey([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedAccessKey([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedHasKeyboardFocus([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedIsKeyboardFocusable([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedIsEnabled([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedAutomationId([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedClassName([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedHelpText([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedCulture([out, retval]int *retVal);
+        [propget]HRESULT CachedIsControlElement([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedIsContentElement([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedIsPassword([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedNativeWindowHandle([out, retval]UIA_HWND *retVal);
+        [propget]HRESULT CachedItemType([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedIsOffscreen([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedOrientation([out, retval]enum OrientationType *retVal);
+        [propget]HRESULT CachedFrameworkId([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedIsRequiredForForm([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedItemStatus([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedBoundingRectangle([out, retval]RECT *retVal);
+        [propget]HRESULT CachedLabeledBy([out, retval]IUIAutomationElement **retVal);
+        [propget]HRESULT CachedAriaRole([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedAriaProperties([out, retval]BSTR *retVal);
+        [propget]HRESULT CachedIsDataValidForForm([out, retval]BOOL *retVal);
+        [propget]HRESULT CachedControllerFor([out, retval]IUIAutomationElementArray **retVal);
+        [propget]HRESULT CachedDescribedBy([out, retval]IUIAutomationElementArray **retVal);
+        [propget]HRESULT CachedFlowsTo([out, retval]IUIAutomationElementArray **retVal);
+        [propget]HRESULT CachedProviderDescription([out, retval]BSTR *retVal);
+
+        HRESULT GetClickablePoint([out]POINT *clickable,
+                                  [out, retval]BOOL *gotClickable);
+    }
+
+    [
+        object,
+        uuid(14314595-b4bc-4055-95f2-58f2e42c9855),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationElementArray : IUnknown {
+        [propget]HRESULT Length([out, retval]int *length);
+
+        HRESULT GetElement([in]int index,
+                           [out, retval]IUIAutomationElement **element);
+    }
+
+    [
+        object,
+        uuid(85b94ecd-849d-42b6-b94d-d6db23fdf5a4),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationProxyFactory : IUnknown {
+        HRESULT CreateProvider([in]UIA_HWND hwnd,
+                               [in]LONG idObject,
+                               [in]LONG idChild,
+                               [out, retval]IRawElementProviderSimple **provider);
+
+        [propget]HRESULT ProxyFactoryId([out, retval]BSTR *factoryId);
+    }
+
+    [
+        object,
+        uuid(d50e472e-b64b-490c-bca1-d30696f9f289),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationProxyFactoryEntry : IUnknown {
+        [propget]HRESULT ProxyFactory([out, retval]IUIAutomationProxyFactory **factory);
+        [propget]HRESULT ClassName([out, retval]BSTR *className);
+        [propget]HRESULT ImageName([out, retval]BSTR *imageName);
+        [propget]HRESULT AllowSubstringMatch([out, retval]BOOL *allowSubstringMatch);
+        [propget]HRESULT CanCheckBaseClass([out, retval]BOOL *canCheckBaseClass);
+        [propget]HRESULT NeedsAdviseEvents([out, retval]BOOL *adviseEvents);
+        [propput]HRESULT ClassName([in]LPCWSTR className);
+        [propput]HRESULT ImageName([in]LPCWSTR imageName);
+        [propput]HRESULT AllowSubstringMatch([in]BOOL allowSubstringMatch);
+        [propput]HRESULT CanCheckBaseClass([in]BOOL canCheckBaseClass);
+        [propput]HRESULT NeedsAdviseEvents([in]BOOL adviseEvents);
+
+        HRESULT SetWinEventsForAutomationEvent([in]EVENTID eventId,
+                                               [in]PROPERTYID propertyId,
+                                               [in]SAFEARRAY(UINT) winEvents);
+
+        HRESULT GetWinEventsForAutomationEvent([in]EVENTID eventId,
+                                               [in]PROPERTYID propertyId,
+                                               [out, retval]SAFEARRAY(UINT) *winEvents);
+    }
+
+    [
+        object,
+        uuid(09e31e18-872d-4873-93d1-1e541ec133fd),
+        pointer_default(unique)
+    ]
+    interface IUIAutomationProxyFactoryMapping : IUnknown {
+        [propget]HRESULT Count([out, retval]UINT *count);
+
+        HRESULT GetTable([out, retval]SAFEARRAY(VARIANT) *table);
+        HRESULT GetEntry([in]UINT index,
+                         [out, retval]IUIAutomationProxyFactoryEntry **entry);
+
+        HRESULT SetTable([in]SAFEARRAY(IUIAutomationProxyFactoryEntry)factoryList);
+
+        HRESULT InsertEntries(UINT before,
+                              [in]SAFEARRAY(IUIAutomationProxyFactoryEntry) factoryList);
+
+        HRESULT InsertEntry(UINT before,
+                            IUIAutomationProxyFactoryEntry *factory);
+
+        HRESULT RemoveEntry(UINT index);
+        HRESULT ClearTable();
+        HRESULT RestoreDefaultTable();
+    }
+
+    [
+        object,
+        uuid(30cbe57d-d9d0-452a-ab13-7ac5ac4825ee),
+        pointer_default(unique)
+    ]
+    interface IUIAutomation : IUnknown {
+        HRESULT CompareElements([in]IUIAutomationElement *el1,
+                                [in]IUIAutomationElement *el2,
+                                [out, retval]BOOL *areSame);
+
+        HRESULT CompareRuntimeIds([in]SAFEARRAY(int) runtimeId1,
+                                  [in]SAFEARRAY(int) runtimeId2,
+                                  [out, retval]BOOL *areSame);
+
+        HRESULT GetRootElement([out, retval]IUIAutomationElement **root);
+
+        HRESULT ElementFromHandle([in]UIA_HWND hwnd,
+                                  [out, retval]IUIAutomationElement **element);
+
+        HRESULT ElementFromPoint([in]POINT pt,
+                                 [out, retval]IUIAutomationElement **element);
+
+        HRESULT GetFocusedElement([out, retval]IUIAutomationElement **element);
+
+        HRESULT GetRootElementBuildCache([in]IUIAutomationCacheRequest *cacheRequest,
+                                         [out, retval]IUIAutomationElement **root);
+
+        HRESULT ElementFromHandleBuildCache([in]UIA_HWND hwnd,
+                                            [in]IUIAutomationCacheRequest *cacheRequest,
+                                            [out, retval]IUIAutomationElement **element);
+
+        HRESULT ElementFromPointBuildCache([in]POINT pt,
+                                           [in]IUIAutomationCacheRequest *cacheRequest,
+                                           [out, retval]IUIAutomationElement **element);
+
+        HRESULT GetFocusedElementBuildCache([in]IUIAutomationCacheRequest *cacheRequest,
+                                            [out, retval]IUIAutomationElement **element);
+
+        HRESULT CreateTreeWalker([in]IUIAutomationCondition *pCondition,
+                                 [out, retval]IUIAutomationTreeWalker **walker);
+
+        [propget]HRESULT ControlViewWalker([out, retval]IUIAutomationTreeWalker **walker);
+        [propget]HRESULT ContentViewWalker([out, retval]IUIAutomationTreeWalker **walker);
+        [propget]HRESULT RawViewWalker([out, retval]IUIAutomationTreeWalker **walker);
+        [propget]HRESULT RawViewCondition([out, retval]IUIAutomationCondition **condition);
+        [propget]HRESULT ControlViewCondition([out, retval]IUIAutomationCondition **condition);
+        [propget]HRESULT ContentViewCondition([out, retval]IUIAutomationCondition **condition);
+
+        HRESULT CreateCacheRequest([out, retval]IUIAutomationCacheRequest **cacheRequest);
+        HRESULT CreateTrueCondition([out, retval]IUIAutomationCondition **newCondition);
+        HRESULT CreateFalseCondition([out, retval]IUIAutomationCondition **newCondition);
+
+        HRESULT CreatePropertyCondition([in]PROPERTYID propertyId,
+                                        [in]VARIANT value,
+                                        [out, retval]IUIAutomationCondition **newCondition);
+
+        HRESULT CreatePropertyConditionEx([in]PROPERTYID propertyId,
+                                          [in]VARIANT value,
+                                          [in]enum PropertyConditionFlags flags,
+                                          [out, retval]IUIAutomationCondition **newCondition);
+
+        HRESULT CreateAndCondition([in]IUIAutomationCondition *condition1,
+                                   [in]IUIAutomationCondition *condition2,
+                                   [out, retval]IUIAutomationCondition **newCondition);
+
+        HRESULT CreateAndConditionFromArray([in]SAFEARRAY(IUIAutomationCondition) conditions,
+                                            [out, retval]IUIAutomationCondition **newCondition);
+
+        HRESULT CreateAndConditionFromNativeArray([in, size_is(conditionCount)]IUIAutomationCondition **conditions,
+                                                  [in]int conditionCount,
+                                                  [out, retval]IUIAutomationCondition **newCondition);
+
+        HRESULT CreateOrCondition([in]IUIAutomationCondition *condition1,
+                                  [in]IUIAutomationCondition *condition2,
+                                  [out, retval]IUIAutomationCondition **newCondition);
+
+        HRESULT CreateOrConditionFromArray([in]SAFEARRAY(IUIAutomationCondition) conditions,
+                                           [out, retval]IUIAutomationCondition **newCondition);
+
+        HRESULT CreateOrConditionFromNativeArray([in, size_is(conditionCount)]IUIAutomationCondition **conditions,
+                                                 [in]int conditionCount,
+                                                 [out, retval]IUIAutomationCondition **newCondition);
+
+        HRESULT CreateNotCondition([in]IUIAutomationCondition *condition,
+                                   [out, retval]IUIAutomationCondition **newCondition);
+
+        HRESULT AddAutomationEventHandler([in]EVENTID eventId,
+                                          [in]IUIAutomationElement *element,
+                                          [in]enum TreeScope scope,
+                                          [in]IUIAutomationCacheRequest *cacheRequest,
+                                          [in]IUIAutomationEventHandler *handler);
+
+        HRESULT RemoveAutomationEventHandler([in]EVENTID eventId,
+                                             [in]IUIAutomationElement *element,
+                                             [in]IUIAutomationEventHandler *handler);
+
+        HRESULT AddPropertyChangedEventHandlerNativeArray([in]IUIAutomationElement *element,
+                                                          [in]enum TreeScope scope,
+                                                          [in]IUIAutomationCacheRequest *cacheRequest,
+                                                          [in]IUIAutomationPropertyChangedEventHandler *handler,
+                                                          [in, size_is(propertyCount)]PROPERTYID *propertyArray,
+                                                          [in]int propertyCount);
+
+        HRESULT AddPropertyChangedEventHandler([in]IUIAutomationElement *element,
+                                               [in]enum TreeScope scope,
+                                               [in]IUIAutomationCacheRequest *cacheRequest,
+                                               [in]IUIAutomationPropertyChangedEventHandler *handler,
+                                               [in]SAFEARRAY(PROPERTYID) propertyArray);
+
+        HRESULT RemovePropertyChangedEventHandler([in]IUIAutomationElement *element,
+                                                  [in]IUIAutomationPropertyChangedEventHandler *handler);
+
+        HRESULT AddStructureChangedEventHandler([in]IUIAutomationElement *element,
+                                                [in]enum TreeScope scope,
+                                                [in]IUIAutomationCacheRequest *cacheRequest,
+                                                [in]IUIAutomationStructureChangedEventHandler *handler);
+
+        HRESULT RemoveStructureChangedEventHandler([in]IUIAutomationElement *element,
+                                                   [in]IUIAutomationStructureChangedEventHandler *handler);
+
+        HRESULT AddFocusChangedEventHandler([in]IUIAutomationCacheRequest *cacheRequest,
+                                            [in]IUIAutomationFocusChangedEventHandler *handler);
+
+        HRESULT RemoveFocusChangedEventHandler([in]IUIAutomationFocusChangedEventHandler *handler);
+        HRESULT RemoveAllEventHandlers();
+
+        HRESULT IntNativeArrayToSafeArray([in, size_is(arrayCount)]int *array,
+            [in]int arrayCount,
+            [out, retval]SAFEARRAY(int) *safeArray);
+
+        HRESULT IntSafeArrayToNativeArray([in]SAFEARRAY(int) intArray,
+                                          [out, size_is( ,*arrayCount)]int **array,
+                                          [out, retval]int *arrayCount);
+
+        HRESULT RectToVariant([in]RECT rc,
+                              [out, retval]VARIANT *var);
+
+        HRESULT VariantToRect([in]VARIANT var,
+                              [out, retval]RECT *rc);
+
+        HRESULT SafeArrayToRectNativeArray([in]SAFEARRAY(double) rects,
+                                           [out, size_is( ,*rectArrayCount)]RECT **rectArray,
+                                           [out, retval]int *rectArrayCount);
+
+        HRESULT CreateProxyFactoryEntry([in]IUIAutomationProxyFactory *factory,
+                                        [out, retval]IUIAutomationProxyFactoryEntry **factoryEntry);
+
+        [propget]HRESULT ProxyFactoryMapping([out, retval]IUIAutomationProxyFactoryMapping **factoryMapping);
+
+        HRESULT GetPropertyProgrammaticName([in]PROPERTYID property,
+                                            [out, retval]BSTR *name);
+
+        HRESULT GetPatternProgrammaticName([in]PATTERNID pattern,
+                                           [out, retval]BSTR *name);
+
+        HRESULT PollForPotentialSupportedPatterns([in]IUIAutomationElement *pElement,
+                                                  [out]SAFEARRAY(int) *patternIds,
+                                                  [out]SAFEARRAY(BSTR) *patternNames);
+
+        HRESULT PollForPotentialSupportedProperties([in]IUIAutomationElement *pElement,
+                                                    [out]SAFEARRAY(int) *propertyIds,
+                                                    [out]SAFEARRAY(BSTR) *propertyNames);
+
+        HRESULT CheckNotSupported([in]VARIANT value,
+                                  [out, retval]BOOL *isNotSupported);
+
+        [propget]HRESULT ReservedNotSupportedValue([out, retval]IUnknown **notSupportedValue);
+        [propget]HRESULT ReservedMixedAttributeValue([out, retval]IUnknown **mixedAttributeValue);
+
+        HRESULT ElementFromIAccessible([in]IAccessible *accessible,
+                                       [in]int childId,
+                                       [out, retval]IUIAutomationElement **element);
+
+        HRESULT ElementFromIAccessibleBuildCache([in]IAccessible *accessible,
+                                                 [in]int childId,
+                                                 [in]IUIAutomationCacheRequest *cacheRequest,
+                                                 [out, retval]IUIAutomationElement **element);
+    }
+
+    [
+        uuid(ff48dba4-60ef-4201-aa87-54103eef594e),
+        version(1.0),
+    ]
+    coclass CUIAutomation
+    {
+        [default]interface IUIAutomation;
+    }
 }
diff --git a/include/uiautomationcore.idl b/include/uiautomationcore.idl
index 170b0c76de1..10838945b67 100644
--- a/include/uiautomationcore.idl
+++ b/include/uiautomationcore.idl
@@ -40,6 +40,118 @@ enum ProviderOptions {
     ProviderOptions_UseClientCoordinates   = 0x0100,
 };

+enum StructureChangeType {
+    StructureChangeType_ChildAdded          = 0x0000,
+    StructureChangeType_ChildRemoved        = 0x0001,
+    StructureChangeType_ChildrenInvalidated = 0x0002,
+    StructureChangeType_ChildrenBulkAdded   = 0x0003,
+    StructureChangeType_ChildrenBulkRemoved = 0x0004,
+    StructureChangeType_ChildrenReordered   = 0x0005,
+};
+
+enum TextEditChangeType {
+    TextEditChangeType_None                 = 0x0000,
+    TextEditChangeType_AutoCorrect          = 0x0001,
+    TextEditChangeType_Composition          = 0x0002,
+    TextEditChangeType_CompositionFinalized = 0x0003,
+    TextEditChangeType_AutoComplete         = 0x0004,
+};
+
+enum OrientationType {
+    OrientationType_None       = 0x0000,
+    OrientationType_Horizontal = 0x0001,
+    OrientationType_Vertical   = 0x0002,
+};
+
+enum DockPosition
+{
+    DockPosition_Top    = 0x0000,
+    DockPosition_Left   = 0x0001,
+    DockPosition_Bottom = 0x0002,
+    DockPosition_Right  = 0x0003,
+    DockPosition_Fill   = 0x0004,
+    DockPosition_None   = 0x0005,
+};
+
+enum ExpandCollapseState {
+    ExpandCollapseState_Collapsed         = 0x0000,
+    ExpandCollapseState_Expanded          = 0x0001,
+    ExpandCollapseState_PartiallyExpanded = 0x0002,
+    ExpandCollapseState_LeafNode          = 0x0003,
+};
+
+enum ScrollAmount {
+    ScrollAmount_LargeDecrement = 0x0000,
+    ScrollAmount_SmallDecrement = 0x0001,
+    ScrollAmount_NoAmount       = 0x0002,
+    ScrollAmount_LargeIncrement = 0x0003,
+    ScrollAmount_SmallIncrement = 0x0004,
+};
+
+enum RowOrColumnMajor {
+    RowOrColumnMajor_RowMajor      = 0x0000,
+    RowOrColumnMajor_ColumnMajor   = 0x0001,
+    RowOrColumnMajor_Indeterminate = 0x0002,
+};
+
+enum ToggleState {
+    ToggleState_Off           = 0x0000,
+    ToggleState_On            = 0x0001,
+    ToggleState_Indeterminate = 0x0002,
+};
+
+enum WindowVisualState {
+    WindowVisualState_Normal    = 0x0000,
+    WindowVisualState_Maximized = 0x0001,
+    WindowVisualState_Minimized = 0x0002,
+};
+
+enum SynchronizedInputType {
+    SynchronizedInputType_KeyUp          = 0x0001,
+    SynchronizedInputType_KeyDown        = 0x0002,
+    SynchronizedInputType_LeftMouseUp    = 0x0004,
+    SynchronizedInputType_LeftMouseDown  = 0x0008,
+    SynchronizedInputType_RightMouseUp   = 0x0010,
+    SynchronizedInputType_RightMouseDown = 0x0020,
+};
+
+enum WindowInteractionState {
+    WindowInteractionState_Running                 = 0x0000,
+    WindowInteractionState_Closing                 = 0x0001,
+    WindowInteractionState_ReadyForUserInteraction = 0x0002,
+    WindowInteractionState_BlockedByModalWindow    = 0x0003,
+    WindowInteractionState_NotResponding           = 0x0004,
+};
+
+enum TextUnit {
+    TextUnit_Character = 0x0000,
+    TextUnit_Format    = 0x0001,
+    TextUnit_Word      = 0x0002,
+    TextUnit_Line      = 0x0003,
+    TextUnit_Paragraph = 0x0004,
+    TextUnit_Page      = 0x0005,
+    TextUnit_Document  = 0x0006,
+};
+
+enum TextPatternRangeEndpoint {
+    TextPatternRangeEndpoint_Start = 0x0000,
+    TextPatternRangeEndpoint_End   = 0x0001,
+};
+
+enum SupportedTextSelection {
+    SupportedTextSelection_None     = 0x0000,
+    SupportedTextSelection_Single   = 0x0001,
+    SupportedTextSelection_Multiple = 0x0002,
+};
+
+enum ZoomUnit {
+    ZoomUnit_NoAmount       = 0x0000,
+    ZoomUnit_LargeDecrement = 0x0001,
+    ZoomUnit_SmallDecrement = 0x0002,
+    ZoomUnit_LargeIncrement = 0x0003,
+    ZoomUnit_SmallIncrement = 0x0004,
+};
+
 typedef int PROPERTYID;
 typedef int PATTERNID;
 typedef int EVENTID;
@@ -53,6 +165,17 @@ struct UiaRect {
     double height;
 };

+struct UiaPoint {
+    double x;
+    double y;
+};
+
+struct UiaChangeInfo {
+    int uiaId;
+    VARIANT payload;
+    VARIANT extraInfo;
+};
+
 [
     version(1.0),
     uuid(930299ce-9965-4dec-b0f4-a54848d4b667),
@@ -136,6 +259,19 @@ library UIA
         [propget] HRESULT FragmentRoot([out, retval] IRawElementProviderFragmentRoot **pRetVal);
     }

+    [
+        object,
+        uuid(a407b27b-0f6d-4427-9292-473c7bf93258),
+        pointer_default(unique)
+    ]
+    interface IRawElementProviderAdviseEvents : IUnknown {
+        HRESULT AdviseEventAdded([in]EVENTID eventId,
+                                 [in]SAFEARRAY(PROPERTYID) propertyIDs);
+
+        HRESULT AdviseEventRemoved([in]EVENTID eventId,
+                                   [in]SAFEARRAY(PROPERTYID) propertyIDs);
+    }
+
     [
         object,
         uuid(620ce2a5-ab8f-40a9-86cb-de3c75599b58),
From e74f8e12b158decc0e644d1ea893356033840d8d Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Thu, 22 Jul 2021 14:42:12 -0400
Subject: [PATCH] uiautomationcore: Add stub IUIAutomation interface.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/Makefile.in           |   5 +-
 dlls/uiautomationcore/uia_classes.idl       |  21 +
 dlls/uiautomationcore/uia_client.c          | 618 ++++++++++++++++++++
 dlls/uiautomationcore/uia_main.c            | 146 ++++-
 dlls/uiautomationcore/uia_private.h         |  21 +
 dlls/uiautomationcore/uiautomationcore.spec |   2 +-
 include/uiautomationclient.idl              |   3 +
 7 files changed, 812 insertions(+), 4 deletions(-)
 create mode 100644 dlls/uiautomationcore/uia_classes.idl
 create mode 100644 dlls/uiautomationcore/uia_client.c
 create mode 100644 dlls/uiautomationcore/uia_private.h

diff --git a/dlls/uiautomationcore/Makefile.in b/dlls/uiautomationcore/Makefile.in
index f0973fdec4c..91611fc11c1 100644
--- a/dlls/uiautomationcore/Makefile.in
+++ b/dlls/uiautomationcore/Makefile.in
@@ -5,4 +5,7 @@ IMPORTS   = uuid ole32 oleaut32 user32
 EXTRADLLFLAGS = -Wb,--prefer-native

 C_SRCS = \
-	uia_main.c
+	uia_main.c \
+	uia_client.c
+
+IDL_SRCS = uia_classes.idl
diff --git a/dlls/uiautomationcore/uia_classes.idl b/dlls/uiautomationcore/uia_classes.idl
new file mode 100644
index 00000000000..174c41cee2a
--- /dev/null
+++ b/dlls/uiautomationcore/uia_classes.idl
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2021 Connor Mcadams for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep regtypelib
+
+#include "uiautomationclient.idl"
diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
new file mode 100644
index 00000000000..e63702e26fa
--- /dev/null
+++ b/dlls/uiautomationcore/uia_client.c
@@ -0,0 +1,618 @@
+/*
+ * Copyright 2021 Connor Mcadams for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+#include "uia_private.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(uiautomation);
+
+struct uia_data {
+    IUIAutomation IUIAutomation_iface;
+    LONG ref;
+};
+
+static inline struct uia_data *impl_from_IUIAutomation(IUIAutomation *iface)
+{
+    return CONTAINING_RECORD(iface, struct uia_data, IUIAutomation_iface);
+}
+
+static HRESULT WINAPI uia_QueryInterface(IUIAutomation *iface, REFIID riid,
+        void **ppvObject)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), ppvObject);
+
+    if (IsEqualIID(riid, &IID_IUIAutomation) ||
+            IsEqualIID(riid, &IID_IUnknown))
+        *ppvObject = iface;
+    else
+    {
+        WARN("no interface: %s\n", debugstr_guid(riid));
+        *ppvObject = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUIAutomation_AddRef(iface);
+
+    return S_OK;
+}
+
+static ULONG WINAPI uia_AddRef(IUIAutomation *iface)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref = %u\n", This, ref);
+    return ref;
+}
+
+static FORCEINLINE ULONG WINAPI uia_Release(IUIAutomation *iface)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref = %u\n", This, ref);
+
+    if(!ref)
+        heap_free(This);
+
+    return ref;
+}
+
+/*
+ * IUIAutomation methods.
+ */
+static HRESULT WINAPI uia_CompareElements(IUIAutomation *iface,
+        IUIAutomationElement *el1, IUIAutomationElement *el2, BOOL *areSame)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CompareRuntimeIds(IUIAutomation *iface,
+        SAFEARRAY *runtimeId1, SAFEARRAY *runtimeId2, BOOL *areSame)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_GetRootElement(IUIAutomation *iface,
+        IUIAutomationElement **root)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_ElementFromHandle(IUIAutomation *iface, UIA_HWND hwnd,
+        IUIAutomationElement **element)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_ElementFromPoint(IUIAutomation *iface, POINT pt,
+        IUIAutomationElement **element)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_GetFocusedElement(IUIAutomation *iface,
+        IUIAutomationElement **element)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_GetRootElementBuildCache(IUIAutomation *iface,
+        IUIAutomationCacheRequest *cacheRequest,IUIAutomationElement **root)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_ElementFromHandleBuildCache(IUIAutomation *iface,
+        UIA_HWND hwnd, IUIAutomationCacheRequest *cacheRequest,
+        IUIAutomationElement **root)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_ElementFromPointBuildCache(IUIAutomation *iface, POINT pt,
+        IUIAutomationCacheRequest *cacheRequest, IUIAutomationElement **element)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_GetFocusedElementBuildCache(IUIAutomation *iface,
+        IUIAutomationCacheRequest *cacheRequest, IUIAutomationElement **element)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateTreeWalker(IUIAutomation *iface,
+        IUIAutomationCondition *pCondition, IUIAutomationTreeWalker **walker)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_ControlViewWalker(IUIAutomation *iface,
+        IUIAutomationTreeWalker **walker)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_ContentViewWalker(IUIAutomation *iface,
+        IUIAutomationTreeWalker **walker)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_RawViewWalker(IUIAutomation *iface,
+        IUIAutomationTreeWalker **walker)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_RawViewCondition(IUIAutomation *iface,
+        IUIAutomationCondition **condition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_ControlViewCondition(IUIAutomation *iface,
+        IUIAutomationCondition **condition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_ContentViewCondition(IUIAutomation *iface,
+        IUIAutomationCondition **condition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateCacheRequest(IUIAutomation *iface,
+        IUIAutomationCacheRequest **cacheRequest)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateTrueCondition(IUIAutomation *iface,
+        IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateFalseCondition(IUIAutomation *iface,
+        IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreatePropertyCondition(IUIAutomation *iface,
+        PROPERTYID propertyId, VARIANT value, IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreatePropertyConditionEx(IUIAutomation *iface,
+        PROPERTYID propertyId, VARIANT value, enum PropertyConditionFlags flags,
+        IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateAndCondition(IUIAutomation *iface,
+        IUIAutomationCondition *condition1, IUIAutomationCondition *condition2,
+        IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateAndConditionFromArray(IUIAutomation *iface,
+        SAFEARRAY *conditions, IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateAndConditionFromNativeArray(IUIAutomation *iface,
+        IUIAutomationCondition **conditions, int conditionCount,
+        IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateOrCondition(IUIAutomation *iface,
+        IUIAutomationCondition *condition1, IUIAutomationCondition *condition2,
+        IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateOrConditionFromArray(IUIAutomation *iface,
+        SAFEARRAY *conditions, IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateOrConditionFromNativeArray(IUIAutomation *iface,
+        IUIAutomationCondition **conditions, int conditionCount,
+        IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateNotCondition(IUIAutomation *iface,
+        IUIAutomationCondition *condition, IUIAutomationCondition **newCondition)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_AddAutomationEventHandler(IUIAutomation *iface,
+        EVENTID eventId, IUIAutomationElement *element, enum TreeScope scope,
+        IUIAutomationCacheRequest *cacheRequest, IUIAutomationEventHandler *handler)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_RemoveAutomationEventHandler(IUIAutomation *iface,
+        EVENTID eventId, IUIAutomationElement *element,
+        IUIAutomationEventHandler *handler)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_AddPropertyChangedEventHandlerNativeArray(IUIAutomation *iface,
+        IUIAutomationElement *element, enum TreeScope scope,
+        IUIAutomationCacheRequest *cacheRequest,
+        IUIAutomationPropertyChangedEventHandler *handler,
+        PROPERTYID *propertyArray, int propertyCount)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_AddPropertyChangedEventHandler(IUIAutomation *iface,
+        IUIAutomationElement *element, enum TreeScope scope,
+        IUIAutomationCacheRequest *cacheRequest,
+        IUIAutomationPropertyChangedEventHandler *handler,
+        SAFEARRAY *propertyArray)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_RemovePropertyChangedEventHandler(IUIAutomation *iface,
+        IUIAutomationElement *element,
+        IUIAutomationPropertyChangedEventHandler *handler)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_AddStructureChangedEventHandler(IUIAutomation *iface,
+        IUIAutomationElement *element, enum TreeScope scope,
+        IUIAutomationCacheRequest *cacheRequest,
+        IUIAutomationStructureChangedEventHandler *handler)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_RemoveStructureChangedEventHandler(IUIAutomation *iface,
+        IUIAutomationElement *element, IUIAutomationStructureChangedEventHandler *handler)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_AddFocusChangedEventHandler(IUIAutomation *iface,
+        IUIAutomationCacheRequest *cacheRequest,
+        IUIAutomationFocusChangedEventHandler *handler)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_RemoveFocusChangedEventHandler(IUIAutomation *iface,
+        IUIAutomationFocusChangedEventHandler *handler)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_RemoveAllEventHandlers(IUIAutomation *iface)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_IntNativeArrayToSafeArray(IUIAutomation *iface,
+        int *array, int arrayCount, SAFEARRAY **safeArray)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_IntSafeArrayToNativeArray(IUIAutomation *iface,
+        SAFEARRAY *intArray, int **array, int *arrayCount)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_RectToVariant(IUIAutomation *iface, RECT rc,
+        VARIANT *var)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_VariantToRect(IUIAutomation *iface, VARIANT var,
+        RECT *rc)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_SafeArrayToRectNativeArray(IUIAutomation *iface,
+        SAFEARRAY *rects, RECT **rectArray, int *rectArrayCount)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CreateProxyFactoryEntry(IUIAutomation *iface,
+        IUIAutomationProxyFactory *factory, IUIAutomationProxyFactoryEntry **factoryEntry)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_get_ProxyFactoryMapping(IUIAutomation *iface,
+        IUIAutomationProxyFactoryMapping **factoryMapping)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_GetPropertyProgrammaticName(IUIAutomation *iface,
+        PROPERTYID property,BSTR *name)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_GetPatternProgrammaticName(IUIAutomation *iface,
+        PATTERNID pattern, BSTR *name)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_PollForPotentialSupportedPatterns(IUIAutomation *iface,
+        IUIAutomationElement *pElement, SAFEARRAY **patternIds,
+        SAFEARRAY **patternNames)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_PollForPotentialSupportedProperties(IUIAutomation *iface,
+        IUIAutomationElement *pElement, SAFEARRAY **propertyIds,
+        SAFEARRAY **propertyNames)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_CheckNotSupported(IUIAutomation *iface, VARIANT value,
+        BOOL *isNotSupported)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_get_ReservedNotSupportedValue(IUIAutomation *iface,
+        IUnknown **notSupportedValue)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_get_ReservedMixedAttributeValue(IUIAutomation *iface,
+        IUnknown **mixedAttributeValue)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_ElementFromIAccessible(IUIAutomation *iface,
+        IAccessible *accessible, int childId, IUIAutomationElement **element)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_ElementFromIAccessibleBuildCache(IUIAutomation *iface,
+        IAccessible *accessible, int childId,
+        IUIAutomationCacheRequest *cacheRequest, IUIAutomationElement **element)
+{
+    struct uia_data *This = impl_from_IUIAutomation(iface);
+    FIXME("This %p\n", This);
+    return E_NOTIMPL;
+}
+
+static const IUIAutomationVtbl uia_vtbl = {
+    uia_QueryInterface,
+    uia_AddRef,
+    uia_Release,
+    uia_CompareElements,
+    uia_CompareRuntimeIds,
+    uia_GetRootElement,
+    uia_ElementFromHandle,
+    uia_ElementFromPoint,
+    uia_GetFocusedElement,
+    uia_GetRootElementBuildCache,
+    uia_ElementFromHandleBuildCache,
+    uia_ElementFromPointBuildCache,
+    uia_GetFocusedElementBuildCache,
+    uia_CreateTreeWalker,
+    uia_ControlViewWalker,
+    uia_ContentViewWalker,
+    uia_RawViewWalker,
+    uia_RawViewCondition,
+    uia_ControlViewCondition,
+    uia_ContentViewCondition,
+    uia_CreateCacheRequest,
+    uia_CreateTrueCondition,
+    uia_CreateFalseCondition,
+    uia_CreatePropertyCondition,
+    uia_CreatePropertyConditionEx,
+    uia_CreateAndCondition,
+    uia_CreateAndConditionFromArray,
+    uia_CreateAndConditionFromNativeArray,
+    uia_CreateOrCondition,
+    uia_CreateOrConditionFromArray,
+    uia_CreateOrConditionFromNativeArray,
+    uia_CreateNotCondition,
+    uia_AddAutomationEventHandler,
+    uia_RemoveAutomationEventHandler,
+    uia_AddPropertyChangedEventHandlerNativeArray,
+    uia_AddPropertyChangedEventHandler,
+    uia_RemovePropertyChangedEventHandler,
+    uia_AddStructureChangedEventHandler,
+    uia_RemoveStructureChangedEventHandler,
+    uia_AddFocusChangedEventHandler,
+    uia_RemoveFocusChangedEventHandler,
+    uia_RemoveAllEventHandlers,
+    uia_IntNativeArrayToSafeArray,
+    uia_IntSafeArrayToNativeArray,
+    uia_RectToVariant,
+    uia_VariantToRect,
+    uia_SafeArrayToRectNativeArray,
+    uia_CreateProxyFactoryEntry,
+    uia_get_ProxyFactoryMapping,
+    uia_GetPropertyProgrammaticName,
+    uia_GetPatternProgrammaticName,
+    uia_PollForPotentialSupportedPatterns,
+    uia_PollForPotentialSupportedProperties,
+    uia_CheckNotSupported,
+    uia_get_ReservedNotSupportedValue,
+    uia_get_ReservedMixedAttributeValue,
+    uia_ElementFromIAccessible,
+    uia_ElementFromIAccessibleBuildCache,
+};
+
+HRESULT create_uia_iface(IUIAutomation **iface)
+{
+    struct uia_data *uia;
+
+    uia = heap_alloc_zero(sizeof(*uia));
+    if (!uia)
+        return E_OUTOFMEMORY;
+
+    uia->IUIAutomation_iface.lpVtbl = &uia_vtbl;
+    uia->ref = 1;
+    *iface = &uia->IUIAutomation_iface;
+
+    return S_OK;
+}
diff --git a/dlls/uiautomationcore/uia_main.c b/dlls/uiautomationcore/uia_main.c
index f1cf06ed4f5..95dfc359043 100644
--- a/dlls/uiautomationcore/uia_main.c
+++ b/dlls/uiautomationcore/uia_main.c
@@ -17,9 +17,11 @@
  */

 #define COBJMACROS
+#include <initguid.h>

-#include "initguid.h"
-#include "uiautomation.h"
+#include "uia_private.h"
+#include "ole2.h"
+#include "rpcproxy.h"

 #include "wine/debug.h"
 #include "wine/heap.h"
@@ -367,3 +369,143 @@ HRESULT WINAPI UiaDisconnectProvider(IRawElementProviderSimple *provider)
     FIXME("(%p): stub\n", provider);
     return E_NOTIMPL;
 }
+
+/* UIAutomation ClassFactory */
+struct uia_cf {
+    IClassFactory IClassFactory_iface;
+    LONG ref;
+};
+
+static struct uia_cf *impl_from_IClassFactory(IClassFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct uia_cf, IClassFactory_iface);
+}
+
+static HRESULT WINAPI uia_cf_QueryInterface(IClassFactory *iface, REFIID riid, void **ppobj)
+{
+    if(IsEqualGUID(riid, &IID_IUnknown)
+            || IsEqualGUID(riid, &IID_IClassFactory))
+    {
+        IClassFactory_AddRef(iface);
+        *ppobj = iface;
+        return S_OK;
+    }
+
+    *ppobj = NULL;
+    WARN("(%p)->(%s, %p): interface not found\n", iface, debugstr_guid(riid), ppobj);
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI uia_cf_AddRef(IClassFactory *iface)
+{
+    struct uia_cf *This = impl_from_IClassFactory(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p)->(): Refcount now %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI uia_cf_Release(IClassFactory *iface)
+{
+    struct uia_cf *This = impl_from_IClassFactory(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p)->(): Refcount now %u\n", This, ref);
+    if (!ref)
+        HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI uia_cf_CreateInstance(IClassFactory *iface, IUnknown *pOuter,
+                                               REFIID riid, void **ppobj)
+{
+    struct uia_cf *This = impl_from_IClassFactory(iface);
+
+    TRACE("(%p)->(%p,%s,%p)\n", This, pOuter, debugstr_guid(riid), ppobj);
+
+    *ppobj = NULL;
+
+    if(pOuter)
+        return CLASS_E_NOAGGREGATION;
+
+    if (!IsEqualGUID(riid, &IID_IUIAutomation))
+        return E_NOINTERFACE;
+
+    return create_uia_iface((IUIAutomation **)ppobj);
+}
+
+static HRESULT WINAPI uia_cf_LockServer(IClassFactory *iface, BOOL dolock)
+{
+    struct uia_cf *This = impl_from_IClassFactory(iface);
+    FIXME("(%p)->(%d): stub!\n", This, dolock);
+    return S_OK;
+}
+
+static const IClassFactoryVtbl uia_cf_Vtbl =
+{
+    uia_cf_QueryInterface,
+    uia_cf_AddRef,
+    uia_cf_Release,
+    uia_cf_CreateInstance,
+    uia_cf_LockServer
+};
+
+static inline HRESULT make_uia_factory(REFIID riid, void **ppv)
+{
+    HRESULT hr;
+    struct uia_cf *ret = HeapAlloc(GetProcessHeap(), 0, sizeof(*ret));
+    ret->IClassFactory_iface.lpVtbl = &uia_cf_Vtbl;
+    ret->ref = 0;
+
+    hr = IClassFactory_QueryInterface(&ret->IClassFactory_iface, riid, ppv);
+    if(FAILED(hr))
+        HeapFree(GetProcessHeap(), 0, ret);
+
+    return hr;
+}
+
+HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
+{
+    TRACE("(%s, %s, %p)\n", debugstr_guid(rclsid), debugstr_guid(riid), ppv);
+
+    if (IsEqualGUID(rclsid, &CLSID_CUIAutomation))
+        return make_uia_factory(riid, ppv);
+
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+/******************************************************************
+ *              DllCanUnloadNow (uiautomationcore.@)
+ */
+HRESULT WINAPI DllCanUnloadNow(void)
+{
+    return S_FALSE;
+}
+
+/***********************************************************************
+ *          DllRegisterServer (uiautomationcore.@)
+ */
+HRESULT WINAPI DllRegisterServer(void)
+{
+    return __wine_register_resources();
+}
+
+/***********************************************************************
+ *          DllUnregisterServer (uiautomationcore.@)
+ */
+HRESULT WINAPI DllUnregisterServer(void)
+{
+    return __wine_unregister_resources();
+}
+
+BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, void *reserved)
+{
+    TRACE("%p,%u,%p\n", hinst, reason, reserved);
+
+    switch (reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls(hinst);
+        break;
+    }
+
+    return TRUE;
+}
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
new file mode 100644
index 00000000000..4b41ff94568
--- /dev/null
+++ b/dlls/uiautomationcore/uia_private.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2021 Connor McAdams for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "uiautomation.h"
+
+HRESULT create_uia_iface(IUIAutomation **) DECLSPEC_HIDDEN;
diff --git a/dlls/uiautomationcore/uiautomationcore.spec b/dlls/uiautomationcore/uiautomationcore.spec
index 82071bd2317..93d4e130799 100644
--- a/dlls/uiautomationcore/uiautomationcore.spec
+++ b/dlls/uiautomationcore/uiautomationcore.spec
@@ -1,5 +1,5 @@
 @ stdcall -private DllCanUnloadNow()
-@ stub DllGetClassObject
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
 @ stdcall -private DllRegisterServer()
 @ stdcall -private DllUnregisterServer()
 @ stub DockPattern_SetDockPosition
diff --git a/include/uiautomationclient.idl b/include/uiautomationclient.idl
index 0079f5316b9..d459aaed361 100644
--- a/include/uiautomationclient.idl
+++ b/include/uiautomationclient.idl
@@ -1583,6 +1583,9 @@ library UIAutomationClient {

     [
         uuid(ff48dba4-60ef-4201-aa87-54103eef594e),
+#ifdef __WIDL__
+        threading(both),
+#endif
         version(1.0),
     ]
     coclass CUIAutomation
From f0c9965ed2679f536c6f72900326a46bb1d26ee4 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Wed, 16 Jun 2021 18:27:05 -0400
Subject: [PATCH] uiautomationcore: Add stub IUIAutomationElement interface.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_client.c | 819 +++++++++++++++++++++++++++++
 1 file changed, 819 insertions(+)

diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index e63702e26fa..d2ec5d7ab67 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -29,6 +29,13 @@ struct uia_data {
     LONG ref;
 };

+struct uia_elem_data {
+    IUIAutomationElement IUIAutomationElement_iface;
+    LONG ref;
+};
+
+static inline struct uia_elem_data *impl_from_IUIAutomationElement(IUIAutomationElement *iface);
+
 static inline struct uia_data *impl_from_IUIAutomation(IUIAutomation *iface)
 {
     return CONTAINING_RECORD(iface, struct uia_data, IUIAutomation_iface);
@@ -616,3 +623,815 @@ HRESULT create_uia_iface(IUIAutomation **iface)

     return S_OK;
 }
+
+static inline struct uia_elem_data *impl_from_IUIAutomationElement(IUIAutomationElement *iface)
+{
+    return CONTAINING_RECORD(iface, struct uia_elem_data, IUIAutomationElement_iface);
+}
+
+static HRESULT WINAPI uia_elem_QueryInterface(IUIAutomationElement *iface, REFIID riid,
+        void **ppvObject)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), ppvObject);
+
+    if (IsEqualIID(riid, &IID_IUIAutomationElement) ||
+            IsEqualIID(riid, &IID_IUnknown))
+        *ppvObject = iface;
+    else
+    {
+        WARN("no interface: %s\n", debugstr_guid(riid));
+        *ppvObject = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUIAutomationElement_AddRef(iface);
+
+    return S_OK;
+}
+
+static ULONG WINAPI uia_elem_AddRef(IUIAutomationElement *iface)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref = %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI uia_elem_Release(IUIAutomationElement *iface)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref = %u\n", This, ref);
+
+    if(!ref)
+        heap_free(This);
+
+    return ref;
+}
+
+static HRESULT WINAPI uia_elem_SetFocus(IUIAutomationElement *iface)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetRuntimeId(IUIAutomationElement *iface,
+        SAFEARRAY **runtimeId)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_FindFirst(IUIAutomationElement *iface,
+        enum TreeScope scope, IUIAutomationCondition *condition,
+        IUIAutomationElement **found)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_FindAll(IUIAutomationElement *iface,
+        enum TreeScope scope, IUIAutomationCondition *condition,
+        IUIAutomationElementArray **found)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_FindFirstBuildCache(IUIAutomationElement *iface,
+        enum TreeScope scope, IUIAutomationCondition *condition,
+        IUIAutomationCacheRequest *cacheRequest,
+        IUIAutomationElement **found)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_FindAllBuildCache(IUIAutomationElement *iface,
+        enum TreeScope scope, IUIAutomationCondition *condition,
+        IUIAutomationCacheRequest *cacheRequest, IUIAutomationElementArray **found)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_BuildUpdatedCache(IUIAutomationElement *iface,
+        IUIAutomationCacheRequest *cacheRequest, IUIAutomationElement **updatedElement)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetCurrentPropertyValue(IUIAutomationElement *iface,
+        PROPERTYID propertyId, VARIANT *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetCurrentPropertyValueEx(IUIAutomationElement *iface,
+        PROPERTYID propertyId, BOOL ignoreDefaultValue, VARIANT *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetCachedPropertyValue(IUIAutomationElement *iface,
+        PROPERTYID propertyId, VARIANT *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetCachedPropertyValueEx(IUIAutomationElement *iface,
+        PROPERTYID propertyId, BOOL ignoreDefaultValue, VARIANT *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetCurrentPatternAs(IUIAutomationElement *iface,
+        PATTERNID patternId, REFIID riid, void **patternObject)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetCachedPatternAs(IUIAutomationElement *iface,
+        PATTERNID patternId, REFIID riid, void **patternObject)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetCurrentPattern(IUIAutomationElement *iface,
+        PATTERNID patternId, IUnknown **patternObject)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetCachedPattern(IUIAutomationElement *iface,
+        PATTERNID patternId, IUnknown **patternObject)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetCachedParent(IUIAutomationElement *iface,
+        IUIAutomationElement **parent)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetCachedChildren(IUIAutomationElement *iface,
+        IUIAutomationElementArray **children)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentProcessId(IUIAutomationElement *iface,
+        int *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentControlType(IUIAutomationElement *iface,
+        CONTROLTYPEID *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentLocalizedControlType(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentName(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentAcceleratorKey(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentAccessKey(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentHasKeyboardFocus(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentIsKeyboardFocusable(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentIsEnabled(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentAutomationId(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentClassName(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentHelpText(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentCulture(IUIAutomationElement *iface,
+        int *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentIsControlElement(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentIsContentElement(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentIsPassword(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentNativeWindowHandle(IUIAutomationElement *iface,
+        UIA_HWND *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentItemType(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentIsOffscreen(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentOrientation(IUIAutomationElement *iface,
+        enum OrientationType *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentFrameworkId(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentIsRequiredForForm(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentItemStatus(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentBoundingRectangle(IUIAutomationElement *iface,
+        RECT *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentLabeledBy(IUIAutomationElement *iface,
+        IUIAutomationElement **retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentAriaRole(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentAriaProperties(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentIsDataValidForForm(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentControllerFor(IUIAutomationElement *iface,
+        IUIAutomationElementArray **retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentDescribedBy(IUIAutomationElement *iface,
+        IUIAutomationElementArray **retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentFlowsTo(IUIAutomationElement *iface,
+        IUIAutomationElementArray **retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CurrentProviderDescription(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedProcessId(IUIAutomationElement *iface,
+        int *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedControlType(IUIAutomationElement *iface,
+        CONTROLTYPEID *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedLocalizedControlType(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedName(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedAcceleratorKey(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedAccessKey(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedHasKeyboardFocus(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedIsKeyboardFocusable(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedIsEnabled(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedAutomationId(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedClassName(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedHelpText(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedCulture(IUIAutomationElement *iface,
+        int *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedIsControlElement(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedIsContentElement(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedIsPassword(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedNativeWindowHandle(IUIAutomationElement *iface,
+        UIA_HWND *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedItemType(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedIsOffscreen(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedOrientation(IUIAutomationElement *iface,
+        enum OrientationType *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedFrameworkId(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedIsRequiredForForm(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedItemStatus(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedBoundingRectangle(IUIAutomationElement *iface,
+        RECT *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedLabeledBy(IUIAutomationElement *iface,
+        IUIAutomationElement **retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedAriaRole(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedAriaProperties(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedIsDataValidForForm(IUIAutomationElement *iface,
+        BOOL *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedControllerFor(IUIAutomationElement *iface,
+        IUIAutomationElementArray **retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedDescribedBy(IUIAutomationElement *iface,
+        IUIAutomationElementArray **retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedFlowsTo(IUIAutomationElement *iface,
+        IUIAutomationElementArray **retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_get_CachedProviderDescription(IUIAutomationElement *iface,
+        BSTR *retVal)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI uia_elem_GetClickablePoint(IUIAutomationElement *iface,
+        POINT *clickable, BOOL *gotClickable)
+{
+    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
+    FIXME("%p\n", This);
+    return E_NOTIMPL;
+}
+
+static const IUIAutomationElementVtbl uia_elem_vtbl = {
+    uia_elem_QueryInterface,
+    uia_elem_AddRef,
+    uia_elem_Release,
+    uia_elem_SetFocus,
+    uia_elem_GetRuntimeId,
+    uia_elem_FindFirst,
+    uia_elem_FindAll,
+    uia_elem_FindFirstBuildCache,
+    uia_elem_FindAllBuildCache,
+    uia_elem_BuildUpdatedCache,
+    uia_elem_GetCurrentPropertyValue,
+    uia_elem_GetCurrentPropertyValueEx,
+    uia_elem_GetCachedPropertyValue,
+    uia_elem_GetCachedPropertyValueEx,
+    uia_elem_GetCurrentPatternAs,
+    uia_elem_GetCachedPatternAs,
+    uia_elem_GetCurrentPattern,
+    uia_elem_GetCachedPattern,
+    uia_elem_GetCachedParent,
+    uia_elem_GetCachedChildren,
+    uia_elem_get_CurrentProcessId,
+    uia_elem_get_CurrentControlType,
+    uia_elem_get_CurrentLocalizedControlType,
+    uia_elem_get_CurrentName,
+    uia_elem_get_CurrentAcceleratorKey,
+    uia_elem_get_CurrentAccessKey,
+    uia_elem_get_CurrentHasKeyboardFocus,
+    uia_elem_get_CurrentIsKeyboardFocusable,
+    uia_elem_get_CurrentIsEnabled,
+    uia_elem_get_CurrentAutomationId,
+    uia_elem_get_CurrentClassName,
+    uia_elem_get_CurrentHelpText,
+    uia_elem_get_CurrentCulture,
+    uia_elem_get_CurrentIsControlElement,
+    uia_elem_get_CurrentIsContentElement,
+    uia_elem_get_CurrentIsPassword,
+    uia_elem_get_CurrentNativeWindowHandle,
+    uia_elem_get_CurrentItemType,
+    uia_elem_get_CurrentIsOffscreen,
+    uia_elem_get_CurrentOrientation,
+    uia_elem_get_CurrentFrameworkId,
+    uia_elem_get_CurrentIsRequiredForForm,
+    uia_elem_get_CurrentItemStatus,
+    uia_elem_get_CurrentBoundingRectangle,
+    uia_elem_get_CurrentLabeledBy,
+    uia_elem_get_CurrentAriaRole,
+    uia_elem_get_CurrentAriaProperties,
+    uia_elem_get_CurrentIsDataValidForForm,
+    uia_elem_get_CurrentControllerFor,
+    uia_elem_get_CurrentDescribedBy,
+    uia_elem_get_CurrentFlowsTo,
+    uia_elem_get_CurrentProviderDescription,
+    uia_elem_get_CachedProcessId,
+    uia_elem_get_CachedControlType,
+    uia_elem_get_CachedLocalizedControlType,
+    uia_elem_get_CachedName,
+    uia_elem_get_CachedAcceleratorKey,
+    uia_elem_get_CachedAccessKey,
+    uia_elem_get_CachedHasKeyboardFocus,
+    uia_elem_get_CachedIsKeyboardFocusable,
+    uia_elem_get_CachedIsEnabled,
+    uia_elem_get_CachedAutomationId,
+    uia_elem_get_CachedClassName,
+    uia_elem_get_CachedHelpText,
+    uia_elem_get_CachedCulture,
+    uia_elem_get_CachedIsControlElement,
+    uia_elem_get_CachedIsContentElement,
+    uia_elem_get_CachedIsPassword,
+    uia_elem_get_CachedNativeWindowHandle,
+    uia_elem_get_CachedItemType,
+    uia_elem_get_CachedIsOffscreen,
+    uia_elem_get_CachedOrientation,
+    uia_elem_get_CachedFrameworkId,
+    uia_elem_get_CachedIsRequiredForForm,
+    uia_elem_get_CachedItemStatus,
+    uia_elem_get_CachedBoundingRectangle,
+    uia_elem_get_CachedLabeledBy,
+    uia_elem_get_CachedAriaRole,
+    uia_elem_get_CachedAriaProperties,
+    uia_elem_get_CachedIsDataValidForForm,
+    uia_elem_get_CachedControllerFor,
+    uia_elem_get_CachedDescribedBy,
+    uia_elem_get_CachedFlowsTo,
+    uia_elem_get_CachedProviderDescription,
+    uia_elem_GetClickablePoint,
+};
+
+static HRESULT create_uia_elem_iface(IUIAutomationElement **iface)
+{
+    struct uia_elem_data *uia;
+
+    uia = heap_alloc_zero(sizeof(*uia));
+    if (!uia)
+        return E_OUTOFMEMORY;
+
+    uia->IUIAutomationElement_iface.lpVtbl = &uia_elem_vtbl;
+    uia->ref = 1;
+    *iface = &uia->IUIAutomationElement_iface;
+
+    return S_OK;
+}
From 1c5f1f46342c9ccbec2a1153574ad73d610a6961 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Fri, 16 Jul 2021 14:31:11 -0500
Subject: [PATCH] uiautomationcore: Implement UiaReturnRawElementProvider.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/Makefile.in          |  5 +++--
 dlls/uiautomationcore/uia_classes_core.idl | 21 +++++++++++++++++++++
 dlls/uiautomationcore/uia_main.c           | 11 +++++++++--
 dlls/uiautomationcore/uia_private.h        |  1 +
 include/uiautomationcore.idl               |  6 +++++-
 5 files changed, 39 insertions(+), 5 deletions(-)
 create mode 100644 dlls/uiautomationcore/uia_classes_core.idl

diff --git a/dlls/uiautomationcore/Makefile.in b/dlls/uiautomationcore/Makefile.in
index 91611fc11c1..216f083e03d 100644
--- a/dlls/uiautomationcore/Makefile.in
+++ b/dlls/uiautomationcore/Makefile.in
@@ -1,6 +1,6 @@
 MODULE = uiautomationcore.dll
 IMPORTLIB = uiautomationcore
-IMPORTS   = uuid ole32 oleaut32 user32
+IMPORTS   = uuid ole32 oleaut32 user32 oleacc rpcrt4

 EXTRADLLFLAGS = -Wb,--prefer-native

@@ -8,4 +8,5 @@ C_SRCS = \
 	uia_main.c \
 	uia_client.c

-IDL_SRCS = uia_classes.idl
+IDL_SRCS = uia_classes.idl \
+           uia_classes_core.idl
diff --git a/dlls/uiautomationcore/uia_classes_core.idl b/dlls/uiautomationcore/uia_classes_core.idl
new file mode 100644
index 00000000000..8e29d7aa228
--- /dev/null
+++ b/dlls/uiautomationcore/uia_classes_core.idl
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2021 Connor Mcadams for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep regtypelib
+
+#include "uiautomationcore.idl"
diff --git a/dlls/uiautomationcore/uia_main.c b/dlls/uiautomationcore/uia_main.c
index 95dfc359043..c8a3795ed1b 100644
--- a/dlls/uiautomationcore/uia_main.c
+++ b/dlls/uiautomationcore/uia_main.c
@@ -313,8 +313,15 @@ int WINAPI UiaLookupId(enum AutomationIdentifierType type, const GUID *guid)
 LRESULT WINAPI UiaReturnRawElementProvider(HWND hwnd, WPARAM wParam,
         LPARAM lParam, IRawElementProviderSimple *elprov)
 {
-    FIXME("(%p, %Ix, %Ix, %p) stub!\n", hwnd, wParam, lParam, elprov);
-    return 0;
+    TRACE("(%p, %Ix, %Ix, %p)\n", hwnd, wParam, lParam, elprov);
+
+    if (lParam != UiaRootObjectId)
+    {
+        FIXME("Unsupported object id %ld\n", lParam);
+        return 0;
+    }
+
+    return LresultFromObject(&IID_IRawElementProviderSimple, wParam, (IUnknown *)elprov);
 }

 /***********************************************************************
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
index 4b41ff94568..17ff04b5055 100644
--- a/dlls/uiautomationcore/uia_private.h
+++ b/dlls/uiautomationcore/uia_private.h
@@ -17,5 +17,6 @@
  */

 #include "uiautomation.h"
+#include "oleacc.h"

 HRESULT create_uia_iface(IUIAutomation **) DECLSPEC_HIDDEN;
diff --git a/include/uiautomationcore.idl b/include/uiautomationcore.idl
index 10838945b67..e10c2316ceb 100644
--- a/include/uiautomationcore.idl
+++ b/include/uiautomationcore.idl
@@ -179,6 +179,9 @@ struct UiaChangeInfo {
 [
     version(1.0),
     uuid(930299ce-9965-4dec-b0f4-a54848d4b667),
+#ifdef __WIDL__
+    id(2),
+#endif
     lcid(0),
     hidden
 ]
@@ -262,7 +265,8 @@ library UIA
     [
         object,
         uuid(a407b27b-0f6d-4427-9292-473c7bf93258),
-        pointer_default(unique)
+        pointer_default(unique),
+        oleautomation
     ]
     interface IRawElementProviderAdviseEvents : IUnknown {
         HRESULT AdviseEventAdded([in]EVENTID eventId,
From 15d6b2743a6b3484d88713c23daae6b4c0bbd7b1 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Fri, 16 Jul 2021 14:42:01 -0500
Subject: [PATCH] uiautomationcore: Implement IUIAutomation::ElementFromHandle.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_client.c  | 100 +++++++++++++++++++++++++++-
 dlls/uiautomationcore/uia_private.h |   5 ++
 2 files changed, 102 insertions(+), 3 deletions(-)

diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index d2ec5d7ab67..6a54ffb9ba2 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -18,6 +18,7 @@

 #define COBJMACROS
 #include "uia_private.h"
+#include "winuser.h"

 #include "wine/debug.h"
 #include "wine/heap.h"
@@ -32,6 +33,11 @@ struct uia_data {
 struct uia_elem_data {
     IUIAutomationElement IUIAutomationElement_iface;
     LONG ref;
+
+    IRawElementProviderSimple *elem_prov;
+
+    IAccessible *acc;
+    VARIANT child_id;
 };

 static inline struct uia_elem_data *impl_from_IUIAutomationElement(IUIAutomationElement *iface);
@@ -115,9 +121,54 @@ static HRESULT WINAPI uia_GetRootElement(IUIAutomation *iface,
 static HRESULT WINAPI uia_ElementFromHandle(IUIAutomation *iface, UIA_HWND hwnd,
         IUIAutomationElement **element)
 {
-    struct uia_data *This = impl_from_IUIAutomation(iface);
-    FIXME("This %p\n", This);
-    return E_NOTIMPL;
+    IUIAutomationElement *elem;
+    LRESULT lres;
+    HRESULT hr;
+
+    TRACE("iface %p, hwnd %p, element %p\n", iface, hwnd, element);
+
+    /* FIXME: Is this what actually gets returned? */
+    if (!IsWindow(hwnd))
+        return E_FAIL;
+
+    lres = SendMessageW(hwnd, WM_GETOBJECT, 0, UiaRootObjectId);
+    if (FAILED(lres))
+        return lres;
+
+    /*
+     * If lres is 0, this is probably not a UIA provider, but instead an
+     * MSAA server.
+     */
+    if (!lres)
+    {
+        IAccessible *acc;
+
+        hr = AccessibleObjectFromWindow((HWND)hwnd, OBJID_CLIENT,
+                &IID_IAccessible, (void **)&acc);
+        if (FAILED(hr))
+            return hr;
+
+        hr = create_uia_elem_from_msaa_acc(&elem, acc, CHILDID_SELF);
+        if (FAILED(hr))
+            return hr;
+    }
+    else
+    {
+        IRawElementProviderSimple *elem_prov;
+
+        hr = ObjectFromLresult(lres, &IID_IRawElementProviderSimple, 0,
+                (void **)&elem_prov);
+        if (FAILED(hr))
+            return hr;
+
+        hr = create_uia_elem_from_raw_provider(&elem, elem_prov);
+        if (FAILED(hr))
+            return hr;
+    }
+
+    *element = elem;
+
+    return S_OK;
 }

 static HRESULT WINAPI uia_ElementFromPoint(IUIAutomation *iface, POINT pt,
@@ -668,7 +719,14 @@ static ULONG WINAPI uia_elem_Release(IUIAutomationElement *iface)
     TRACE("(%p) ref = %u\n", This, ref);

     if(!ref)
+    {
+        if (This->elem_prov)
+            IRawElementProviderSimple_Release(This->elem_prov);
+        else if (This->acc)
+            IAccessible_Release(This->acc);
+
         heap_free(This);
+    }

     return ref;
 }
@@ -1435,3 +1493,39 @@ static HRESULT create_uia_elem_iface(IUIAutomationElement **iface)

     return S_OK;
 }
+
+HRESULT create_uia_elem_from_raw_provider(IUIAutomationElement **iface,
+        IRawElementProviderSimple *wrap)
+{
+    struct uia_elem_data *uia;
+    HRESULT hr;
+
+    hr = create_uia_elem_iface(iface);
+    if (FAILED(hr))
+        return hr;
+
+    uia = impl_from_IUIAutomationElement(*iface);
+    uia->elem_prov = wrap;
+    uia->acc = NULL;
+
+    return S_OK;
+}
+
+HRESULT create_uia_elem_from_msaa_acc(IUIAutomationElement **iface,
+        IAccessible *wrap, INT child_id)
+{
+    struct uia_elem_data *uia;
+    HRESULT hr;
+
+    hr = create_uia_elem_iface(iface);
+    if (FAILED(hr))
+        return hr;
+
+    uia = impl_from_IUIAutomationElement(*iface);
+    uia->elem_prov = NULL;
+    uia->acc = wrap;
+    V_VT(&uia->child_id) = VT_I4;
+    V_I4(&uia->child_id) = child_id;
+
+    return S_OK;
+}
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
index 17ff04b5055..5e60ecc1151 100644
--- a/dlls/uiautomationcore/uia_private.h
+++ b/dlls/uiautomationcore/uia_private.h
@@ -20,3 +20,8 @@
 #include "oleacc.h"

 HRESULT create_uia_iface(IUIAutomation **) DECLSPEC_HIDDEN;
+
+HRESULT create_uia_elem_from_raw_provider(IUIAutomationElement **,
+        IRawElementProviderSimple *) DECLSPEC_HIDDEN;
+HRESULT create_uia_elem_from_msaa_acc(IUIAutomationElement **,
+        IAccessible *, INT) DECLSPEC_HIDDEN;
From ee5da6ebbad53e9205b4a88d0953260eced3a77a Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 26 Jul 2021 10:47:48 -0400
Subject: [PATCH] uiautomationcore: Implement
 IUIAutomationElement::get_CurrentControlType.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_client.c | 174 +++++++++++++++++++++++++++--
 1 file changed, 166 insertions(+), 8 deletions(-)

diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index 6a54ffb9ba2..008aeae62c9 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -34,6 +34,8 @@ struct uia_elem_data {
     IUIAutomationElement IUIAutomationElement_iface;
     LONG ref;

+    BOOL elem_disconnected;
+
     IRawElementProviderSimple *elem_prov;

     IAccessible *acc;
@@ -675,6 +677,129 @@ HRESULT create_uia_iface(IUIAutomation **iface)
     return S_OK;
 }

+/*
+ * IUIAutomationElement helper functions.
+ */
+static BOOL uia_hresult_is_obj_disconnected(HRESULT hr)
+{
+    if ((hr == CO_E_OBJNOTCONNECTED) || (hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE)))
+        return TRUE;
+
+    return FALSE;
+}
+
+static INT uia_msaa_role_to_uia_control_type(INT role)
+{
+    switch (role)
+    {
+
+        case ROLE_SYSTEM_PUSHBUTTON: return UIA_ButtonControlTypeId;
+        case ROLE_SYSTEM_CLIENT: return UIA_CalendarControlTypeId;
+        case ROLE_SYSTEM_CHECKBUTTON: return UIA_CheckBoxControlTypeId;
+        case ROLE_SYSTEM_COMBOBOX: return UIA_ComboBoxControlTypeId;
+        case ROLE_SYSTEM_DOCUMENT: return UIA_DocumentControlTypeId;
+        case ROLE_SYSTEM_TEXT: return UIA_EditControlTypeId;
+        case ROLE_SYSTEM_GROUPING: return UIA_GroupControlTypeId;
+        case ROLE_SYSTEM_COLUMNHEADER: return UIA_HeaderItemControlTypeId;
+        case ROLE_SYSTEM_LINK: return UIA_HyperlinkControlTypeId;
+        case ROLE_SYSTEM_GRAPHIC: return UIA_ImageControlTypeId;
+        case ROLE_SYSTEM_LIST: return UIA_ListControlTypeId;
+        case ROLE_SYSTEM_LISTITEM: return UIA_ListItemControlTypeId;
+        case ROLE_SYSTEM_MENUPOPUP: return UIA_MenuControlTypeId;
+        case ROLE_SYSTEM_MENUBAR: return UIA_MenuBarControlTypeId;
+        case ROLE_SYSTEM_MENUITEM: return UIA_MenuItemControlTypeId;
+        case ROLE_SYSTEM_PANE: return UIA_PaneControlTypeId;
+        case ROLE_SYSTEM_PROGRESSBAR: return UIA_ProgressBarControlTypeId;
+        case ROLE_SYSTEM_RADIOBUTTON: return UIA_RadioButtonControlTypeId;
+        case ROLE_SYSTEM_SCROLLBAR: return UIA_ScrollBarControlTypeId;
+        case ROLE_SYSTEM_SEPARATOR: return UIA_SeparatorControlTypeId;
+        case ROLE_SYSTEM_SLIDER: return UIA_SliderControlTypeId;
+        case ROLE_SYSTEM_SPINBUTTON: return UIA_SpinnerControlTypeId;
+        case ROLE_SYSTEM_SPLITBUTTON: return UIA_SplitButtonControlTypeId;
+        case ROLE_SYSTEM_STATUSBAR: return UIA_StatusBarControlTypeId;
+        case ROLE_SYSTEM_PAGETABLIST: return UIA_TabControlTypeId;
+        case ROLE_SYSTEM_PAGETAB: return UIA_TabItemControlTypeId;
+        case ROLE_SYSTEM_TABLE: return UIA_TableControlTypeId;
+        case ROLE_SYSTEM_STATICTEXT: return UIA_TextControlTypeId;
+        case ROLE_SYSTEM_INDICATOR: return UIA_ThumbControlTypeId;
+        case ROLE_SYSTEM_TITLEBAR: return UIA_TitleBarControlTypeId;
+        case ROLE_SYSTEM_TOOLBAR: return UIA_ToolBarControlTypeId;
+        case ROLE_SYSTEM_TOOLTIP: return UIA_ToolTipControlTypeId;
+        case ROLE_SYSTEM_OUTLINE: return UIA_TreeControlTypeId;
+        case ROLE_SYSTEM_OUTLINEITEM: return UIA_TreeItemControlTypeId;
+        case ROLE_SYSTEM_WINDOW: return UIA_WindowControlTypeId;
+        default:
+            FIXME("Unhandled MSAA role %#x, defaulting to UIA_ButtonControlTypeId.\n",
+                    role);
+            break;
+    }
+
+    return UIA_ButtonControlTypeId;
+}
+
+static void uia_get_default_property_val(PROPERTYID propertyId, VARIANT *retVal)
+{
+    switch (propertyId)
+    {
+    case UIA_ControlTypePropertyId:
+        V_VT(retVal) = VT_I4;
+        V_I4(retVal) = UIA_CustomControlTypeId;
+        break;
+
+    default:
+        FIXME("Unimplemented default value for PropertyId %d!\n", propertyId);
+        V_VT(retVal) = VT_EMPTY;
+        break;
+    }
+}
+
+static HRESULT uia_get_uia_elem_prov_property_val(IRawElementProviderSimple *elem_prov,
+        PROPERTYID propertyId, BOOL *use_default, VARIANT *retVal)
+{
+    VARIANT res;
+    HRESULT hr;
+
+    VariantInit(&res);
+    *use_default = TRUE;
+    hr = IRawElementProviderSimple_GetPropertyValue(elem_prov, propertyId, &res);
+
+    /* VT_EMPTY means this PropertyId is unimplemented/unsupported. */
+    if (V_VT(&res) != VT_EMPTY && SUCCEEDED(hr))
+    {
+        *use_default = FALSE;
+        *retVal = res;
+    }
+
+    return hr;
+}
+
+static HRESULT uia_get_msaa_acc_property_val(IAccessible *acc,
+        VARIANT child_id, PROPERTYID propertyId, BOOL *use_default, VARIANT *retVal)
+{
+    HRESULT hr = S_OK;
+    VARIANT res;
+
+    *use_default = TRUE;
+    switch (propertyId)
+    {
+    case UIA_ControlTypePropertyId:
+        hr = IAccessible_get_accRole(acc, child_id, &res);
+        if (SUCCEEDED(hr))
+        {
+            V_VT(retVal) = VT_I4;
+            V_I4(retVal) = uia_msaa_role_to_uia_control_type(V_I4(&res));
+            *use_default = FALSE;
+        }
+        break;
+
+    default:
+        FIXME("UIA PropertyId %d unimplemented for IAccessible!\n", propertyId);
+        break;
+    }
+
+    return hr;
+}
+
 static inline struct uia_elem_data *impl_from_IUIAutomationElement(IUIAutomationElement *iface)
 {
     return CONTAINING_RECORD(iface, struct uia_elem_data, IUIAutomationElement_iface);
@@ -794,17 +919,39 @@ static HRESULT WINAPI uia_elem_BuildUpdatedCache(IUIAutomationElement *iface,
 static HRESULT WINAPI uia_elem_GetCurrentPropertyValue(IUIAutomationElement *iface,
         PROPERTYID propertyId, VARIANT *retVal)
 {
-    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
-    FIXME("%p\n", This);
-    return E_NOTIMPL;
+    return IUIAutomationElement_GetCurrentPropertyValueEx(iface, propertyId, FALSE, retVal);
 }

 static HRESULT WINAPI uia_elem_GetCurrentPropertyValueEx(IUIAutomationElement *iface,
         PROPERTYID propertyId, BOOL ignoreDefaultValue, VARIANT *retVal)
 {
     struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
-    FIXME("%p\n", This);
-    return E_NOTIMPL;
+    BOOL use_default;
+    HRESULT hr;
+
+    TRACE("%p, %d, %d, %p\n", iface, propertyId, ignoreDefaultValue, retVal);
+
+    VariantInit(retVal);
+    if (This->elem_disconnected)
+        return UIA_E_ELEMENTNOTAVAILABLE;
+
+    if (This->elem_prov)
+        hr = uia_get_uia_elem_prov_property_val(This->elem_prov,
+                propertyId, &use_default, retVal);
+    else
+        hr = uia_get_msaa_acc_property_val(This->acc,
+                This->child_id, propertyId, &use_default, retVal);
+
+    if (FAILED(hr) && uia_hresult_is_obj_disconnected(hr))
+    {
+        This->elem_disconnected = TRUE;
+        return UIA_E_ELEMENTNOTAVAILABLE;
+    }
+
+    if (SUCCEEDED(hr) && use_default && !ignoreDefaultValue)
+        uia_get_default_property_val(propertyId, retVal);
+
+    return hr;
 }

 static HRESULT WINAPI uia_elem_GetCachedPropertyValue(IUIAutomationElement *iface,
@@ -882,9 +1029,20 @@ static HRESULT WINAPI uia_elem_get_CurrentProcessId(IUIAutomationElement *iface,
 static HRESULT WINAPI uia_elem_get_CurrentControlType(IUIAutomationElement *iface,
         CONTROLTYPEID *retVal)
 {
-    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
-    FIXME("%p\n", This);
-    return E_NOTIMPL;
+    VARIANT res;
+    HRESULT hr;
+
+    TRACE("%p %p\n", iface, retVal);
+
+    hr = IUIAutomationElement_GetCurrentPropertyValue(iface,
+            UIA_ControlTypePropertyId, &res);
+    if (FAILED(hr))
+        return hr;
+
+    if (V_VT(&res) == VT_I4)
+        *retVal = V_I4(&res);
+
+    return S_OK;
 }

 static HRESULT WINAPI uia_elem_get_CurrentLocalizedControlType(IUIAutomationElement *iface,
From 219fb1e7927dd91e438171b760deca046fe68211 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 26 Jul 2021 11:10:26 -0400
Subject: [PATCH] uiautomationcore: Implement
 IUIAutomationElement::get_CurrentName.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_client.c | 37 +++++++++++++++++++++++++++---
 1 file changed, 34 insertions(+), 3 deletions(-)

diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index 008aeae62c9..af16eab42a7 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -746,6 +746,11 @@ static void uia_get_default_property_val(PROPERTYID propertyId, VARIANT *retVal)
         V_I4(retVal) = UIA_CustomControlTypeId;
         break;

+    case UIA_NamePropertyId:
+        V_VT(retVal) = VT_BSTR;
+        V_BSTR(retVal) = SysAllocString(L"");
+        break;
+
     default:
         FIXME("Unimplemented default value for PropertyId %d!\n", propertyId);
         V_VT(retVal) = VT_EMPTY;
@@ -792,6 +797,20 @@ static HRESULT uia_get_msaa_acc_property_val(IAccessible *acc,
         }
         break;

+    case UIA_NamePropertyId:
+    {
+        BSTR name;
+
+        hr = IAccessible_get_accName(acc, child_id, &name);
+        if (SUCCEEDED(hr) && name)
+        {
+            V_VT(retVal) = VT_BSTR;
+            V_BSTR(retVal) = name;
+            *use_default = FALSE;
+        }
+        break;
+    }
+
     default:
         FIXME("UIA PropertyId %d unimplemented for IAccessible!\n", propertyId);
         break;
@@ -1056,9 +1075,21 @@ static HRESULT WINAPI uia_elem_get_CurrentLocalizedControlType(IUIAutomationElem
 static HRESULT WINAPI uia_elem_get_CurrentName(IUIAutomationElement *iface,
         BSTR *retVal)
 {
-    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
-    FIXME("%p\n", This);
-    return E_NOTIMPL;
+    VARIANT res;
+    HRESULT hr;
+
+    TRACE("%p %p\n", iface, retVal);
+
+    *retVal = NULL;
+    hr = IUIAutomationElement_GetCurrentPropertyValue(iface,
+            UIA_NamePropertyId, &res);
+    if (FAILED(hr))
+        return hr;
+
+    if (V_VT(&res) == VT_BSTR)
+        *retVal = V_BSTR(&res);
+
+    return S_OK;
 }

 static HRESULT WINAPI uia_elem_get_CurrentAcceleratorKey(IUIAutomationElement *iface,
From 1a64f705f4e1dd05df9466dce3ca437333fe17d1 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 26 Jul 2021 11:20:30 -0400
Subject: [PATCH] uiautomationcore: Implement keyboard focus property IDs.

Implement MSAA mappings and default values for
UIA_IsKeyboardFocusablePropertyId and UIA_HasKeyboardFocusPropertyId.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_client.c | 34 ++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index af16eab42a7..250ce99e947 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -751,6 +751,12 @@ static void uia_get_default_property_val(PROPERTYID propertyId, VARIANT *retVal)
         V_BSTR(retVal) = SysAllocString(L"");
         break;

+    case UIA_IsKeyboardFocusablePropertyId:
+    case UIA_HasKeyboardFocusPropertyId:
+        V_VT(retVal) = VT_BOOL;
+        V_BOOL(retVal) = VARIANT_FALSE;
+        break;
+
     default:
         FIXME("Unimplemented default value for PropertyId %d!\n", propertyId);
         V_VT(retVal) = VT_EMPTY;
@@ -811,6 +817,34 @@ static HRESULT uia_get_msaa_acc_property_val(IAccessible *acc,
         break;
     }

+    case UIA_IsKeyboardFocusablePropertyId:
+        hr = IAccessible_get_accState(acc, child_id, &res);
+        if (SUCCEEDED(hr) && V_VT(&res) == VT_I4)
+        {
+            V_VT(retVal) = VT_BOOL;
+            if (V_I4(&res) & STATE_SYSTEM_FOCUSABLE)
+                V_BOOL(retVal) = VARIANT_TRUE;
+            else
+                V_BOOL(retVal) = VARIANT_FALSE;
+
+            *use_default = FALSE;
+        }
+        break;
+
+    case UIA_HasKeyboardFocusPropertyId:
+        hr = IAccessible_get_accState(acc, child_id, &res);
+        if (SUCCEEDED(hr) && V_VT(&res) == VT_I4)
+        {
+            V_VT(retVal) = VT_BOOL;
+            if (V_I4(&res) & STATE_SYSTEM_FOCUSED)
+                V_BOOL(retVal) = VARIANT_TRUE;
+            else
+                V_BOOL(retVal) = VARIANT_FALSE;
+
+            *use_default = FALSE;
+        }
+        break;
+
     default:
         FIXME("UIA PropertyId %d unimplemented for IAccessible!\n", propertyId);
         break;
From 7d36b3341ef0d87ea194e34c2a2f40b32f82add9 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 26 Jul 2021 12:43:14 -0400
Subject: [PATCH] uiautomationcore: uiautomationcore: Add automation event
 handler list.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/Makefile.in   |  3 +-
 dlls/uiautomationcore/uia_client.c  | 19 +++----
 dlls/uiautomationcore/uia_event.c   | 77 +++++++++++++++++++++++++++++
 dlls/uiautomationcore/uia_private.h | 45 +++++++++++++++++
 4 files changed, 134 insertions(+), 10 deletions(-)
 create mode 100644 dlls/uiautomationcore/uia_event.c

diff --git a/dlls/uiautomationcore/Makefile.in b/dlls/uiautomationcore/Makefile.in
index 216f083e03d..cbafa94782c 100644
--- a/dlls/uiautomationcore/Makefile.in
+++ b/dlls/uiautomationcore/Makefile.in
@@ -6,7 +6,8 @@ EXTRADLLFLAGS = -Wb,--prefer-native

 C_SRCS = \
 	uia_main.c \
-	uia_client.c
+	uia_client.c \
+	uia_event.c

 IDL_SRCS = uia_classes.idl \
            uia_classes_core.idl
diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index 250ce99e947..8c83e837b09 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -25,11 +25,6 @@

 WINE_DEFAULT_DEBUG_CHANNEL(uiautomation);

-struct uia_data {
-    IUIAutomation IUIAutomation_iface;
-    LONG ref;
-};
-
 struct uia_elem_data {
     IUIAutomationElement IUIAutomationElement_iface;
     LONG ref;
@@ -451,16 +446,22 @@ static HRESULT WINAPI uia_AddFocusChangedEventHandler(IUIAutomation *iface,
         IUIAutomationFocusChangedEventHandler *handler)
 {
     struct uia_data *This = impl_from_IUIAutomation(iface);
-    FIXME("This %p\n", This);
-    return E_NOTIMPL;
+
+    TRACE("%p %p %p\n", iface, cacheRequest, handler);
+    if (cacheRequest)
+        FIXME("Cache request unimplemented in event handler!\n");
+
+    return uia_evh_add_focus_event_handler(This, handler);
 }

 static HRESULT WINAPI uia_RemoveFocusChangedEventHandler(IUIAutomation *iface,
         IUIAutomationFocusChangedEventHandler *handler)
 {
     struct uia_data *This = impl_from_IUIAutomation(iface);
-    FIXME("This %p\n", This);
-    return E_NOTIMPL;
+
+    TRACE("iface %p, handler %p\n", iface, handler);
+
+    return uia_evh_remove_focus_event_handler(This, handler);
 }

 static HRESULT WINAPI uia_RemoveAllEventHandlers(IUIAutomation *iface)
diff --git a/dlls/uiautomationcore/uia_event.c b/dlls/uiautomationcore/uia_event.c
new file mode 100644
index 00000000000..0360b9d6b6d
--- /dev/null
+++ b/dlls/uiautomationcore/uia_event.c
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2021 Connor Mcadams for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+#include "uia_private.h"
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(uiautomation);
+
+static void uia_evh_add_event_handler(struct uia_data *data, struct uia_evh *evh)
+{
+    list_add_tail(&data->uia_evh_list, &evh->entry);
+}
+
+/*
+ * FIXME: Check if ref count is incremented/decremented when added/removed.
+ */
+HRESULT uia_evh_add_focus_event_handler(struct uia_data *data,
+        IUIAutomationFocusChangedEventHandler *handler)
+{
+    struct uia_evh *evh = heap_alloc_zero(sizeof(*evh));
+
+    TRACE("data %p, handler %p\n", data, handler);
+    if (!evh)
+        return E_OUTOFMEMORY;
+
+    evh->event_type = FOCUS_EVH;
+    evh->u.IUIAutomationFocusChangedEvh_iface = handler;
+
+    uia_evh_add_event_handler(data, evh);
+
+    return S_OK;
+}
+
+/*
+ * Figure out HRESULT value when removing an event handler that hasn't been
+ * added.
+ */
+HRESULT uia_evh_remove_focus_event_handler(struct uia_data *data,
+        IUIAutomationFocusChangedEventHandler *handler)
+{
+    struct list *evh_list = &data->uia_evh_list;
+    struct list *cursor, *cursor2;
+    struct uia_evh *evh;
+
+    LIST_FOR_EACH_SAFE(cursor, cursor2, evh_list)
+    {
+        evh = LIST_ENTRY(cursor, struct uia_evh, entry);
+        if (evh->event_type == FOCUS_EVH
+                && evh->u.IUIAutomationFocusChangedEvh_iface == handler)
+        {
+            list_remove(cursor);
+            IUIAutomationFocusChangedEventHandler_Release(handler);
+            heap_free(evh);
+            return S_OK;
+        }
+    }
+
+    return S_OK;
+}
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
index 5e60ecc1151..35f86ea8c85 100644
--- a/dlls/uiautomationcore/uia_private.h
+++ b/dlls/uiautomationcore/uia_private.h
@@ -19,9 +19,54 @@
 #include "uiautomation.h"
 #include "oleacc.h"

+#include "wine/list.h"
+
+/*
+ * EVH = Event Handler.
+ */
+enum {
+    BASIC_EVH,
+    CHANGES_EVH,
+    FOCUS_EVH,
+    PROPERTY_EVH,
+    STRUCTURE_EVH,
+    TEXT_EDIT_EVH,
+};
+
+struct uia_evh
+{
+    struct list entry;
+
+    UINT event_type;
+    union
+    {
+        IUIAutomationEventHandler                    *IUIAutomationEvh_iface;
+        IUIAutomationChangesEventHandler             *IUIAutomationChangesEvh_iface;
+        IUIAutomationFocusChangedEventHandler        *IUIAutomationFocusChangedEvh_iface;
+        IUIAutomationPropertyChangedEventHandler     *IUIAutomationPropertyChangedEvh_iface;
+        IUIAutomationStructureChangedEventHandler    *IUIAutomationStructureChangedEvh_iface;
+        IUIAutomationTextEditTextChangedEventHandler *IUIAutomationTextEditTextChangedEvh_iface;
+    } u;
+};
+
+struct uia_data {
+    IUIAutomation IUIAutomation_iface;
+    LONG ref;
+
+    struct list uia_evh_list;
+};
+
 HRESULT create_uia_iface(IUIAutomation **) DECLSPEC_HIDDEN;

 HRESULT create_uia_elem_from_raw_provider(IUIAutomationElement **,
         IRawElementProviderSimple *) DECLSPEC_HIDDEN;
 HRESULT create_uia_elem_from_msaa_acc(IUIAutomationElement **,
         IAccessible *, INT) DECLSPEC_HIDDEN;
+
+/*
+ * uia_event.c functions.
+ */
+HRESULT uia_evh_add_focus_event_handler(struct uia_data *data,
+        IUIAutomationFocusChangedEventHandler *handler) DECLSPEC_HIDDEN;
+HRESULT uia_evh_remove_focus_event_handler(struct uia_data *data,
+        IUIAutomationFocusChangedEventHandler *handler) DECLSPEC_HIDDEN;
From 64e2bbe7370bebe3d0bdc43f27f8d258dff87f7c Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Fri, 25 Jun 2021 13:11:57 -0400
Subject: [PATCH] uiautomationcore: Implement
 IUIAutomation::RemoveAllEventHandlers.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_client.c  |  6 ++--
 dlls/uiautomationcore/uia_event.c   | 46 +++++++++++++++++++++++++++++
 dlls/uiautomationcore/uia_private.h |  1 +
 3 files changed, 51 insertions(+), 2 deletions(-)

diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index 8c83e837b09..46c72f76ddf 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -467,8 +467,10 @@ static HRESULT WINAPI uia_RemoveFocusChangedEventHandler(IUIAutomation *iface,
 static HRESULT WINAPI uia_RemoveAllEventHandlers(IUIAutomation *iface)
 {
     struct uia_data *This = impl_from_IUIAutomation(iface);
-    FIXME("This %p\n", This);
-    return E_NOTIMPL;
+
+    TRACE("iface %p\n", iface);
+
+    return uia_evh_remove_all_event_handlers(This);
 }

 static HRESULT WINAPI uia_IntNativeArrayToSafeArray(IUIAutomation *iface,
diff --git a/dlls/uiautomationcore/uia_event.c b/dlls/uiautomationcore/uia_event.c
index 0360b9d6b6d..9e22b96ce0d 100644
--- a/dlls/uiautomationcore/uia_event.c
+++ b/dlls/uiautomationcore/uia_event.c
@@ -75,3 +75,49 @@ HRESULT uia_evh_remove_focus_event_handler(struct uia_data *data,

     return S_OK;
 }
+
+HRESULT uia_evh_remove_all_event_handlers(struct uia_data *data)
+{
+    struct list *evh_list = &data->uia_evh_list;
+    struct list *cursor, *cursor2;
+    struct uia_evh *evh;
+
+    LIST_FOR_EACH_SAFE(cursor, cursor2, evh_list)
+    {
+        evh = LIST_ENTRY(cursor, struct uia_evh, entry);
+        switch (evh->event_type)
+        {
+            case BASIC_EVH:
+                IUIAutomationEventHandler_Release(evh->u.IUIAutomationEvh_iface);
+                break;
+
+            case CHANGES_EVH:
+                IUIAutomationChangesEventHandler_Release(evh->u.IUIAutomationChangesEvh_iface);
+                break;
+
+            case FOCUS_EVH:
+                IUIAutomationFocusChangedEventHandler_Release(evh->u.IUIAutomationFocusChangedEvh_iface);
+                break;
+
+            case PROPERTY_EVH:
+                IUIAutomationPropertyChangedEventHandler_Release(evh->u.IUIAutomationPropertyChangedEvh_iface);
+                break;
+
+            case STRUCTURE_EVH:
+                IUIAutomationStructureChangedEventHandler_Release(evh->u.IUIAutomationStructureChangedEvh_iface);
+                break;
+
+            case TEXT_EDIT_EVH:
+                IUIAutomationTextEditTextChangedEventHandler_Release(evh->u.IUIAutomationTextEditTextChangedEvh_iface);
+                break;
+
+            default:
+                break;
+        }
+
+        list_remove(cursor);
+        heap_free(evh);
+    }
+
+    return S_OK;
+}
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
index 35f86ea8c85..2e9785f47ef 100644
--- a/dlls/uiautomationcore/uia_private.h
+++ b/dlls/uiautomationcore/uia_private.h
@@ -70,3 +70,4 @@ HRESULT uia_evh_add_focus_event_handler(struct uia_data *data,
         IUIAutomationFocusChangedEventHandler *handler) DECLSPEC_HIDDEN;
 HRESULT uia_evh_remove_focus_event_handler(struct uia_data *data,
         IUIAutomationFocusChangedEventHandler *handler) DECLSPEC_HIDDEN;
+HRESULT uia_evh_remove_all_event_handlers(struct uia_data *data) DECLSPEC_HIDDEN;
From 11fe3f6aed90bb4207c33077747bfb8d1d905c18 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Fri, 25 Jun 2021 16:37:30 -0400
Subject: [PATCH] uiautomationcore: Initial event thread implementation.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_event.c   | 153 +++++++++++++++++++++++++++-
 dlls/uiautomationcore/uia_private.h |  18 +++-
 2 files changed, 165 insertions(+), 6 deletions(-)

diff --git a/dlls/uiautomationcore/uia_event.c b/dlls/uiautomationcore/uia_event.c
index 9e22b96ce0d..a345730cda5 100644
--- a/dlls/uiautomationcore/uia_event.c
+++ b/dlls/uiautomationcore/uia_event.c
@@ -24,9 +24,141 @@

 WINE_DEFAULT_DEBUG_CHANNEL(uiautomation);

-static void uia_evh_add_event_handler(struct uia_data *data, struct uia_evh *evh)
+/*
+ * UI Automation Event Listener functions.
+ * The first time an event handler interface is added on the client side, the
+ * event listener thread is created. It is responsible for listening for
+ * events being raised by UIA providers and MSAA servers, and subsequently
+ * handling all relevant event handler interfaces.
+ */
+static HRESULT uia_event_listener_thread_initialize(struct uia_evl *evl)
 {
-    list_add_tail(&data->uia_evh_list, &evh->entry);
+    HRESULT hr;
+
+    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
+    if (FAILED(hr))
+        return hr;
+
+    return S_OK;
+}
+
+static void uia_event_listener_thread_exit(struct uia_evl *evl)
+{
+    struct uia_data *data = evl->data;
+
+    heap_free(evl);
+    data->evl = NULL;
+
+    CoUninitialize();
+}
+
+static DWORD WINAPI uia_event_listener_main(LPVOID lpParam)
+{
+    struct uia_evl *evl = (struct uia_evl*)lpParam;
+    MSG msg = { };
+
+    PeekMessageW(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);
+    SetEvent(evl->pump_initialized);
+
+    if (FAILED(uia_event_listener_thread_initialize(evl)))
+    {
+        ERR("UI Automation Event Listener thread failed to start!\n");
+        return 0;
+    }
+
+    WaitForSingleObject(evl->first_event, INFINITE);
+    TRACE("UI Automation Event listener thread started!\n");
+    /* From here, main loop, i.e monitor for messages. */
+    while (GetMessageW(&msg, NULL, 0, 0))
+    {
+        BOOL exit = FALSE;
+
+        if (msg.hwnd)
+        {
+            TranslateMessage(&msg);
+            DispatchMessageW(&msg);
+            continue;
+        }
+
+        EnterCriticalSection(&evl->ev_handler_cs);
+
+        if (list_empty(&evl->uia_evh_list))
+            exit = TRUE;
+
+        LeaveCriticalSection(&evl->ev_handler_cs);
+        TRACE("Event listener thread ran, exit %d\n", exit);
+        if (exit)
+            break;
+    }
+
+    uia_event_listener_thread_exit(evl);
+    TRACE("Event listener thread exited.\n");
+    return 0;
+}
+
+static HRESULT start_uia_event_listener(struct uia_data *data)
+{
+    struct uia_evl *evl;
+
+    evl = heap_alloc_zero(sizeof(*evl));
+    if (!evl)
+        return E_OUTOFMEMORY;
+
+    evl->data = data;
+    list_init(&evl->uia_evh_list);
+
+    /*
+     * Create an event handler to signal when the event listener threads
+     * message pump has been initialized.
+     */
+    evl->pump_initialized = CreateEventW(NULL, 0, 0, NULL);
+    evl->first_event = CreateEventW(NULL, 0, 0, NULL);
+    InitializeCriticalSection(&evl->ev_handler_cs);
+
+    evl->h_thread = CreateThread(NULL, 0, uia_event_listener_main, evl, 0, &evl->tid);
+
+    /* Wait for Window message queue creation. */
+    WaitForSingleObject(evl->pump_initialized, INFINITE);
+    PostThreadMessageW(evl->tid, WM_NULL, 0, 0);
+
+    data->evl = evl;
+
+    return S_OK;
+}
+
+static HRESULT uia_evh_add_event_handler(struct uia_data *data, struct uia_evh *evh)
+{
+    BOOL initialized = FALSE;
+
+    /*
+     * If this is the first event handler added, signified by the event listener
+     * being inactive, start it before adding the event.
+     */
+    if (!data->evl)
+    {
+        HRESULT hr;
+
+        hr = start_uia_event_listener(data);
+        if (FAILED(hr))
+            return hr;
+
+        initialized = TRUE;
+    }
+
+    EnterCriticalSection(&data->evl->ev_handler_cs);
+
+    list_add_tail(&data->evl->uia_evh_list, &evh->entry);
+
+    LeaveCriticalSection(&data->evl->ev_handler_cs);
+
+    if (initialized)
+        SetEvent(data->evl->first_event);
+    /*
+     * Awaken the thread by triggering GetMessage.
+     */
+    PostThreadMessageW(data->evl->tid, WM_NULL, 0, 0);
+
+    return S_OK;
 }

 /*
@@ -56,10 +188,12 @@ HRESULT uia_evh_add_focus_event_handler(struct uia_data *data,
 HRESULT uia_evh_remove_focus_event_handler(struct uia_data *data,
         IUIAutomationFocusChangedEventHandler *handler)
 {
-    struct list *evh_list = &data->uia_evh_list;
+    struct list *evh_list = &data->evl->uia_evh_list;
     struct list *cursor, *cursor2;
     struct uia_evh *evh;

+    EnterCriticalSection(&data->evl->ev_handler_cs);
+
     LIST_FOR_EACH_SAFE(cursor, cursor2, evh_list)
     {
         evh = LIST_ENTRY(cursor, struct uia_evh, entry);
@@ -69,19 +203,25 @@ HRESULT uia_evh_remove_focus_event_handler(struct uia_data *data,
             list_remove(cursor);
             IUIAutomationFocusChangedEventHandler_Release(handler);
             heap_free(evh);
-            return S_OK;
+            goto exit;
         }
     }

+exit:
+
+    LeaveCriticalSection(&data->evl->ev_handler_cs);
+    PostThreadMessageW(data->evl->tid, WM_NULL, 0, 0);
+
     return S_OK;
 }

 HRESULT uia_evh_remove_all_event_handlers(struct uia_data *data)
 {
-    struct list *evh_list = &data->uia_evh_list;
+    struct list *evh_list = &data->evl->uia_evh_list;
     struct list *cursor, *cursor2;
     struct uia_evh *evh;

+    EnterCriticalSection(&data->evl->ev_handler_cs);
     LIST_FOR_EACH_SAFE(cursor, cursor2, evh_list)
     {
         evh = LIST_ENTRY(cursor, struct uia_evh, entry);
@@ -119,5 +259,8 @@ HRESULT uia_evh_remove_all_event_handlers(struct uia_data *data)
         heap_free(evh);
     }

+    LeaveCriticalSection(&data->evl->ev_handler_cs);
+    PostThreadMessageW(data->evl->tid, WM_NULL, 0, 0);
+
     return S_OK;
 }
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
index 2e9785f47ef..d3fd1aeef01 100644
--- a/dlls/uiautomationcore/uia_private.h
+++ b/dlls/uiautomationcore/uia_private.h
@@ -49,11 +49,27 @@ struct uia_evh
     } u;
 };

+struct uia_data;
+
+/*
+ * EVL = Event listener.
+ */
+struct uia_evl
+{
+    HANDLE h_thread, pump_initialized, first_event;
+    CRITICAL_SECTION ev_handler_cs;
+    UINT tid;
+
+    struct uia_data *data;
+
+    struct list uia_evh_list;
+};
+
 struct uia_data {
     IUIAutomation IUIAutomation_iface;
     LONG ref;

-    struct list uia_evh_list;
+    struct uia_evl *evl;
 };

 HRESULT create_uia_iface(IUIAutomation **) DECLSPEC_HIDDEN;
From 7bc5a475386415100c3dadcf97a3cc2333e41185 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Tue, 29 Jun 2021 09:54:43 -0400
Subject: [PATCH] uiautomationcore: Add tls data to event listener.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_event.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/dlls/uiautomationcore/uia_event.c b/dlls/uiautomationcore/uia_event.c
index a345730cda5..4cfba8e572c 100644
--- a/dlls/uiautomationcore/uia_event.c
+++ b/dlls/uiautomationcore/uia_event.c
@@ -24,6 +24,8 @@

 WINE_DEFAULT_DEBUG_CHANNEL(uiautomation);

+DWORD tls_index = TLS_OUT_OF_INDEXES;
+
 /*
  * UI Automation Event Listener functions.
  * The first time an event handler interface is added on the client side, the
@@ -39,6 +41,9 @@ static HRESULT uia_event_listener_thread_initialize(struct uia_evl *evl)
     if (FAILED(hr))
         return hr;

+    if (!TlsSetValue(tls_index, (LPVOID)evl))
+        FIXME("Failed to set Tls index value!\n");
+
     return S_OK;
 }

@@ -48,6 +53,8 @@ static void uia_event_listener_thread_exit(struct uia_evl *evl)

     heap_free(evl);
     data->evl = NULL;
+    if (!TlsSetValue(tls_index, NULL))
+        FIXME("Failed to set Tls index value!\n");

     CoUninitialize();
 }
@@ -104,6 +111,9 @@ static HRESULT start_uia_event_listener(struct uia_data *data)
     if (!evl)
         return E_OUTOFMEMORY;

+    if (tls_index == TLS_OUT_OF_INDEXES)
+        tls_index = TlsAlloc();
+
     evl->data = data;
     list_init(&evl->uia_evh_list);

From 4041865db37749679c38d8d58d21182d905bfa6b Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Tue, 29 Jun 2021 10:55:05 -0400
Subject: [PATCH] uiautomationcore: Add WinEvent hooks.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_event.c   | 28 ++++++++++++++++++++++++++++
 dlls/uiautomationcore/uia_private.h |  3 +++
 2 files changed, 31 insertions(+)

diff --git a/dlls/uiautomationcore/uia_event.c b/dlls/uiautomationcore/uia_event.c
index 4cfba8e572c..03d9e59e1a7 100644
--- a/dlls/uiautomationcore/uia_event.c
+++ b/dlls/uiautomationcore/uia_event.c
@@ -26,6 +26,26 @@ WINE_DEFAULT_DEBUG_CHANNEL(uiautomation);

 DWORD tls_index = TLS_OUT_OF_INDEXES;

+/*
+ * Event hook callback for window creation events.
+ */
+void CALLBACK uia_evl_window_create_proc(HWINEVENTHOOK hWinEventHook, DWORD event,
+        HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread,
+        DWORD dwmsEventTime)
+{
+    return;
+}
+
+/*
+ * Event hook callback for MSAA object focus events.
+ */
+void CALLBACK uia_evl_msaa_obj_focus_proc(HWINEVENTHOOK hWinEventHook, DWORD event,
+        HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread,
+        DWORD dwmsEventTime)
+{
+    return;
+}
+
 /*
  * UI Automation Event Listener functions.
  * The first time an event handler interface is added on the client side, the
@@ -44,6 +64,11 @@ static HRESULT uia_event_listener_thread_initialize(struct uia_evl *evl)
     if (!TlsSetValue(tls_index, (LPVOID)evl))
         FIXME("Failed to set Tls index value!\n");

+    evl->object_focus_hook = SetWinEventHook(EVENT_OBJECT_FOCUS,
+            EVENT_OBJECT_FOCUS, 0, uia_evl_msaa_obj_focus_proc, 0, 0, WINEVENT_OUTOFCONTEXT);
+    evl->win_creation_hook = SetWinEventHook(EVENT_OBJECT_CREATE,
+            EVENT_OBJECT_CREATE, 0, uia_evl_window_create_proc, 0, 0, WINEVENT_OUTOFCONTEXT);
+
     return S_OK;
 }

@@ -51,6 +76,9 @@ static void uia_event_listener_thread_exit(struct uia_evl *evl)
 {
     struct uia_data *data = evl->data;

+    UnhookWinEvent(evl->object_focus_hook);
+    UnhookWinEvent(evl->win_creation_hook);
+
     heap_free(evl);
     data->evl = NULL;
     if (!TlsSetValue(tls_index, NULL))
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
index d3fd1aeef01..c832129f64b 100644
--- a/dlls/uiautomationcore/uia_private.h
+++ b/dlls/uiautomationcore/uia_private.h
@@ -60,6 +60,9 @@ struct uia_evl
     CRITICAL_SECTION ev_handler_cs;
     UINT tid;

+    HWINEVENTHOOK win_creation_hook;
+    HWINEVENTHOOK object_focus_hook;
+
     struct uia_data *data;

     struct list uia_evh_list;
From 5c1113a2e8b6b011fa5ecdeaa26879c60dd0b93a Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Tue, 29 Jun 2021 13:00:49 -0400
Subject: [PATCH] uiautomationcore: Add event message queue.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_event.c   | 187 +++++++++++++++++++++++++++-
 dlls/uiautomationcore/uia_private.h |  34 +++++
 2 files changed, 220 insertions(+), 1 deletion(-)

diff --git a/dlls/uiautomationcore/uia_event.c b/dlls/uiautomationcore/uia_event.c
index 03d9e59e1a7..f429523867d 100644
--- a/dlls/uiautomationcore/uia_event.c
+++ b/dlls/uiautomationcore/uia_event.c
@@ -26,6 +26,59 @@ WINE_DEFAULT_DEBUG_CHANNEL(uiautomation);

 DWORD tls_index = TLS_OUT_OF_INDEXES;

+static HRESULT uia_evm_add_msaa_event(struct uia_evl *evl, HWND hwnd,
+        LONG obj_id, LONG child_id, LONG event);
+
+static EVENTID uia_msaa_event_to_uia_event_id(LONG obj_id, LONG event)
+{
+    switch (event)
+    {
+    case EVENT_OBJECT_ACCELERATORCHANGE: return UIA_AcceleratorKeyPropertyId;
+    case EVENT_OBJECT_CREATE: return UIA_StructureChangedEventId; /* StructureChangeType_ChildAdded */
+    case EVENT_OBJECT_DESTROY: return UIA_StructureChangedEventId; /* StructureChangeType_ChildRemoved */
+    case EVENT_OBJECT_FOCUS: return UIA_AutomationFocusChangedEventId;
+    case EVENT_OBJECT_HELPCHANGE: return UIA_AutomationPropertyChangedEventId; /* UIA_HelpTextPropertyId change */
+    case EVENT_OBJECT_LOCATIONCHANGE: return UIA_AutomationPropertyChangedEventId; /* UIA_BoundingRectanglePropertyId change */
+    case EVENT_OBJECT_NAMECHANGE: return UIA_AutomationPropertyChangedEventId; /* UIA_NamePropertyId change */
+    case EVENT_OBJECT_PARENTCHANGE: return UIA_StructureChangedEventId; /* unsure of StructureChangeType, needs tests. */
+    case EVENT_OBJECT_REORDER: return UIA_StructureChangedEventId; /* StructureChangeType_ChildrenReordered? */
+    case EVENT_OBJECT_SELECTION: return	UIA_SelectionItem_ElementSelectedEventId;
+    case EVENT_OBJECT_SELECTIONADD: return UIA_SelectionItem_ElementAddedToSelectionEventId;
+    case EVENT_OBJECT_SELECTIONREMOVE: return UIA_SelectionItem_ElementRemovedFromSelectionEventId;
+    case EVENT_OBJECT_HIDE: return UIA_StructureChangedEventId; /* StructureChangeType_ChildRemoved */
+    case EVENT_OBJECT_SHOW: return UIA_StructureChangedEventId; /* StructureChangeType_ChildAdded */
+    case EVENT_OBJECT_STATECHANGE: return UIA_AutomationPropertyChangedEventId; /* Various property-changed events. */
+    case EVENT_OBJECT_VALUECHANGE: return UIA_AutomationPropertyChangedEventId; /* UIA_RangeValueValuePropertyId or UIA_ValueValuePropertyId */
+    case EVENT_SYSTEM_ALERT: return UIA_SystemAlertEventId;
+    case EVENT_SYSTEM_DIALOGEND: return UIA_Window_WindowClosedEventId;
+    case EVENT_SYSTEM_DIALOGSTART: return UIA_Window_WindowOpenedEventId;
+    case EVENT_SYSTEM_FOREGROUND: return UIA_AutomationFocusChangedEventId;
+    case EVENT_SYSTEM_MENUEND: return UIA_MenuModeEndEventId;
+    case EVENT_SYSTEM_MENUPOPUPEND: return UIA_MenuClosedEventId;
+    case EVENT_SYSTEM_MENUPOPUPSTART: return UIA_MenuOpenedEventId;
+    case EVENT_SYSTEM_MENUSTART: return UIA_MenuModeStartEventId;
+    case EVENT_SYSTEM_MINIMIZEEND: return UIA_AutomationPropertyChangedEventId; /* UIA_WindowWindowVisualStatePropertyId change */
+    case EVENT_SYSTEM_MINIMIZESTART: return UIA_AutomationPropertyChangedEventId; /* UIA_WindowWindowVisualStatePropertyId change */
+    case EVENT_SYSTEM_MOVESIZEEND: return UIA_AutomationPropertyChangedEventId; /* UIA_BoundingRectanglePropertyId change */
+    case EVENT_SYSTEM_MOVESIZESTART: return UIA_AutomationPropertyChangedEventId; /* UIA_BoundingRectanglePropertyId change */
+    case EVENT_SYSTEM_SCROLLINGEND:
+    case EVENT_SYSTEM_SCROLLINGSTART:
+    case 0x8015: /* FIXME: EVENT_OBJECT_CONTENTSCROLLED. Do we not have this defined? */
+        if (obj_id == OBJID_VSCROLL)
+            return UIA_AutomationPropertyChangedEventId; /* UIA_ScrollVerticalScrollPercentPropertyId change */
+        else if (obj_id == OBJID_HSCROLL)
+            return UIA_AutomationPropertyChangedEventId; /* UIA_ScrollHorizontalScrollPercentPropertyId change */
+        FIXME("Scroll events only supported on OBJID_VSCROLL/OBJID_HSCROLL!\n");
+        break;
+
+    default:
+        FIXME("Unimplemented mapping for MSAA event %#x to UIA event!\n", event);
+        break;
+    }
+
+    return 0;
+}
+
 /*
  * Event hook callback for window creation events.
  */
@@ -43,7 +96,93 @@ void CALLBACK uia_evl_msaa_obj_focus_proc(HWINEVENTHOOK hWinEventHook, DWORD eve
         HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread,
         DWORD dwmsEventTime)
 {
-    return;
+    struct uia_evl *evl;
+    HRESULT hr;
+
+    if (idObject != OBJID_CLIENT && idObject != OBJID_WINDOW)
+        return;
+
+    evl = (struct uia_evl *)TlsGetValue(tls_index);
+    hr = uia_evm_add_msaa_event(evl, hwnd, idObject, idChild, event);
+    if (FAILED(hr))
+        FIXME("Failed to add event to event message queue!\n");
+}
+
+static void uia_evl_check_evh_evm_match(struct uia_evl *evl, struct uia_evm *evm)
+{
+    struct list *evh_list = &evl->uia_evh_list;
+    struct list *cursor, *cursor2;
+    struct uia_evh *evh;
+
+    EnterCriticalSection(&evl->ev_handler_cs);
+
+    LIST_FOR_EACH_SAFE(cursor, cursor2, evh_list)
+    {
+        evh = LIST_ENTRY(cursor, struct uia_evh, entry);
+
+        switch (evh->event_type)
+        {
+            case FOCUS_EVH:
+            {
+                IUIAutomationFocusChangedEventHandler *handler = evh->u.IUIAutomationFocusChangedEvh_iface;
+
+                if (evm->event != UIA_AutomationFocusChangedEventId)
+                    break;
+
+                IUIAutomationFocusChangedEventHandler_HandleFocusChangedEvent(handler, evm->elem);
+                break;
+            }
+
+            default:
+                break;
+        }
+    }
+
+    LeaveCriticalSection(&evl->ev_handler_cs);
+}
+
+static void uia_evl_process_evm_queue(struct uia_evl *evl)
+{
+    struct list *evm_queue = &evl->uia_evm_queue;
+    struct list *cursor, *cursor2;
+    struct uia_evm *evm;
+    HRESULT hr;
+
+    if (list_empty(&evl->uia_evm_queue))
+        return;
+
+    LIST_FOR_EACH_SAFE(cursor, cursor2, evm_queue)
+    {
+        evm = LIST_ENTRY(cursor, struct uia_evm, entry);
+
+        if (evm->uia_evo == UIA_EVO_MSAA)
+        {
+            IAccessible *acc;
+            VARIANT child_id;
+
+            hr = AccessibleObjectFromEvent(evm->u.msaa_ev.hwnd, evm->u.msaa_ev.obj_id,
+                    evm->u.msaa_ev.child_id, &acc, &child_id);
+            if (FAILED(hr))
+                goto message_abort;
+
+            hr = create_uia_elem_from_msaa_acc(&evm->elem, acc, V_I4(&child_id));
+            if (FAILED(hr))
+                goto message_abort;
+        }
+        else
+        {
+            hr = create_uia_elem_from_raw_provider(&evm->elem, evm->u.uia_ev.elem_prov);
+            if (FAILED(hr))
+                goto message_abort;
+        }
+
+        uia_evl_check_evh_evm_match(evl, evm);
+        IUIAutomationElement_Release(evm->elem);
+
+message_abort:
+        list_remove(cursor);
+        heap_free(evm);
+    }
 }

 /*
@@ -79,6 +218,9 @@ static void uia_event_listener_thread_exit(struct uia_evl *evl)
     UnhookWinEvent(evl->object_focus_hook);
     UnhookWinEvent(evl->win_creation_hook);

+    DeleteCriticalSection(&evl->ev_handler_cs);
+    DeleteCriticalSection(&evl->evm_queue_cs);
+
     heap_free(evl);
     data->evl = NULL;
     if (!TlsSetValue(tls_index, NULL))
@@ -115,6 +257,8 @@ static DWORD WINAPI uia_event_listener_main(LPVOID lpParam)
             continue;
         }

+        uia_evl_process_evm_queue(evl);
+
         EnterCriticalSection(&evl->ev_handler_cs);

         if (list_empty(&evl->uia_evh_list))
@@ -144,6 +288,7 @@ static HRESULT start_uia_event_listener(struct uia_data *data)

     evl->data = data;
     list_init(&evl->uia_evh_list);
+    list_init(&evl->uia_evm_queue);

     /*
      * Create an event handler to signal when the event listener threads
@@ -152,6 +297,7 @@ static HRESULT start_uia_event_listener(struct uia_data *data)
     evl->pump_initialized = CreateEventW(NULL, 0, 0, NULL);
     evl->first_event = CreateEventW(NULL, 0, 0, NULL);
     InitializeCriticalSection(&evl->ev_handler_cs);
+    InitializeCriticalSection(&evl->evm_queue_cs);

     evl->h_thread = CreateThread(NULL, 0, uia_event_listener_main, evl, 0, &evl->tid);

@@ -302,3 +448,42 @@ HRESULT uia_evh_remove_all_event_handlers(struct uia_data *data)

     return S_OK;
 }
+
+/*
+ * uia_evm (Event Message) functions.
+ */
+
+/*
+ * Add an event message to the message queue.
+ */
+static HRESULT uia_evm_add_message_to_queue(struct uia_evl *evl, struct uia_evm *evm)
+{
+    EnterCriticalSection(&evl->evm_queue_cs);
+
+    list_add_tail(&evl->uia_evm_queue, &evm->entry);
+
+    LeaveCriticalSection(&evl->evm_queue_cs);
+    PostThreadMessageW(evl->tid, WM_NULL, 0, 0);
+
+    return S_OK;
+}
+
+static HRESULT uia_evm_add_msaa_event(struct uia_evl *evl, HWND hwnd,
+        LONG obj_id, LONG child_id, LONG event)
+{
+    struct uia_evm *evm = heap_alloc_zero(sizeof(*evm));
+
+    TRACE("evl %p, hwnd %p, obj_id %d, child_id %d, event_id %d\n", evl, hwnd, obj_id, child_id, event);
+    if (!evm)
+        return E_OUTOFMEMORY;
+
+    evm->uia_evo = UIA_EVO_MSAA;
+    evm->u.msaa_ev.hwnd = hwnd;
+    evm->u.msaa_ev.obj_id = obj_id;
+    evm->u.msaa_ev.child_id = child_id;
+    evm->event = uia_msaa_event_to_uia_event_id(obj_id, event);
+
+    uia_evm_add_message_to_queue(evl, evm);
+
+    return S_OK;
+}
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
index c832129f64b..e254ee38112 100644
--- a/dlls/uiautomationcore/uia_private.h
+++ b/dlls/uiautomationcore/uia_private.h
@@ -49,6 +49,38 @@ struct uia_evh
     } u;
 };

+/*
+ * EVM = Event message. Result of an event being raised, either with
+ * UiaRaiseAutomationEvent or an MSAA event with NotifyWinEvent.
+ */
+struct uia_evm
+{
+    struct list entry;
+
+    UINT event;
+    IUIAutomationElement *elem;
+
+    enum uia_event_origin
+    {
+        UIA_EVO_MSAA,
+        UIA_EVO_UIA,
+    } uia_evo;
+
+    union
+    {
+        struct
+        {
+            HWND hwnd;
+
+            LONG obj_id, child_id;
+        } msaa_ev;
+        struct
+        {
+            IRawElementProviderSimple *elem_prov;
+        } uia_ev;
+    } u;
+};
+
 struct uia_data;

 /*
@@ -58,6 +90,7 @@ struct uia_evl
 {
     HANDLE h_thread, pump_initialized, first_event;
     CRITICAL_SECTION ev_handler_cs;
+    CRITICAL_SECTION evm_queue_cs;
     UINT tid;

     HWINEVENTHOOK win_creation_hook;
@@ -66,6 +99,7 @@ struct uia_evl
     struct uia_data *data;

     struct list uia_evh_list;
+    struct list uia_evm_queue;
 };

 struct uia_data {
From 266b96c0381cef3551f37981e57726b9d6c64c83 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 26 Jul 2021 14:53:44 -0400
Subject: [PATCH] uiautomationcore: Add custom IUIAEvlConnection interface.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_event.c   | 128 ++++++++++++++++++++++++++++
 dlls/uiautomationcore/uia_private.h |  12 +++
 include/uiautomationcore.idl        |  17 ++++
 3 files changed, 157 insertions(+)

diff --git a/dlls/uiautomationcore/uia_event.c b/dlls/uiautomationcore/uia_event.c
index f429523867d..be637edeb2d 100644
--- a/dlls/uiautomationcore/uia_event.c
+++ b/dlls/uiautomationcore/uia_event.c
@@ -28,6 +28,107 @@ DWORD tls_index = TLS_OUT_OF_INDEXES;

 static HRESULT uia_evm_add_msaa_event(struct uia_evl *evl, HWND hwnd,
         LONG obj_id, LONG child_id, LONG event);
+static HRESULT uia_evm_add_uia_event(struct uia_evl *evl,
+        IRawElementProviderSimple *elem_prov, UINT event);
+
+/*
+ * Custom COM interface that is passed to UIA providers. Allows them to raise
+ * events to be sent to any clients with active event listener threads.
+ */
+static inline struct uia_evlc *impl_from_IUIAEvlConnection(IUIAEvlConnection *iface)
+{
+    return CONTAINING_RECORD(iface, struct uia_evlc, IUIAEvlConnection_iface);
+}
+
+static HRESULT WINAPI evlc_QueryInterface(IUIAEvlConnection *iface, REFIID riid,
+        void **ppvObject)
+{
+    struct uia_evlc *This = impl_from_IUIAEvlConnection(iface);
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), ppvObject);
+
+    if (IsEqualIID(riid, &IID_IUIAEvlConnection) ||
+            IsEqualIID(riid, &IID_IUnknown))
+        *ppvObject = iface;
+    else
+    {
+        WARN("no interface: %s\n", debugstr_guid(riid));
+        *ppvObject = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUIAEvlConnection_AddRef(iface);
+
+    return S_OK;
+}
+
+static ULONG WINAPI evlc_AddRef(IUIAEvlConnection *iface)
+{
+    struct uia_evlc *This = impl_from_IUIAEvlConnection(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref = %u\n", This, ref);
+    return ref;
+}
+
+static FORCEINLINE ULONG WINAPI evlc_Release(IUIAEvlConnection *iface)
+{
+    struct uia_evlc *This = impl_from_IUIAEvlConnection(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref = %u\n", This, ref);
+
+    if(!ref)
+        heap_free(This);
+
+    return ref;
+}
+
+static HRESULT WINAPI evlc_ProviderRaiseEvent(IUIAEvlConnection *iface,
+        LONG event_type, IRawElementProviderSimple *pRetVal)
+{
+    struct uia_evlc *This = impl_from_IUIAEvlConnection(iface);
+
+    TRACE("(%p)\n", This);
+
+    /* Do stuff here. */
+    IRawElementProviderSimple_AddRef(pRetVal);
+    uia_evm_add_uia_event(This->evl, pRetVal, event_type);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI evlc_CheckListenerStatus(IUIAEvlConnection *iface,
+        VARIANT *val)
+{
+    V_VT(val) = VT_BOOL;
+    V_BOOL(val) = VARIANT_TRUE;
+
+    return S_OK;
+}
+
+static const IUIAEvlConnectionVtbl uia_evlc_vtbl = {
+    evlc_QueryInterface,
+    evlc_AddRef,
+    evlc_Release,
+    evlc_ProviderRaiseEvent,
+    evlc_CheckListenerStatus,
+};
+
+static HRESULT create_uia_evlc_iface(IUIAEvlConnection **iface)
+{
+    struct uia_evlc *uia;
+
+    uia = heap_alloc_zero(sizeof(*uia));
+    if (!uia)
+        return E_OUTOFMEMORY;
+
+    uia->IUIAEvlConnection_iface.lpVtbl = &uia_evlc_vtbl;
+    uia->ref = 1;
+    *iface = &uia->IUIAEvlConnection_iface;
+
+    return S_OK;
+}

 static EVENTID uia_msaa_event_to_uia_event_id(LONG obj_id, LONG event)
 {
@@ -208,6 +309,12 @@ static HRESULT uia_event_listener_thread_initialize(struct uia_evl *evl)
     evl->win_creation_hook = SetWinEventHook(EVENT_OBJECT_CREATE,
             EVENT_OBJECT_CREATE, 0, uia_evl_window_create_proc, 0, 0, WINEVENT_OUTOFCONTEXT);

+    /*
+     * Create interface to be passed to providers so that they can signal
+     * events to active listeners.
+     */
+    create_uia_evlc_iface(&evl->evlc_iface);
+
     return S_OK;
 }

@@ -218,6 +325,9 @@ static void uia_event_listener_thread_exit(struct uia_evl *evl)
     UnhookWinEvent(evl->object_focus_hook);
     UnhookWinEvent(evl->win_creation_hook);

+    CoDisconnectObject((IUnknown *)evl->evlc_iface, 0);
+    IUIAEvlConnection_Release(evl->evlc_iface);
+
     DeleteCriticalSection(&evl->ev_handler_cs);
     DeleteCriticalSection(&evl->evm_queue_cs);

@@ -487,3 +597,21 @@ static HRESULT uia_evm_add_msaa_event(struct uia_evl *evl, HWND hwnd,

     return S_OK;
 }
+
+static HRESULT uia_evm_add_uia_event(struct uia_evl *evl,
+        IRawElementProviderSimple *elem_prov, UINT event)
+{
+    struct uia_evm *evm = heap_alloc_zero(sizeof(*evm));
+
+    TRACE("evl %p, elem_prov %p, event %#x\n", evl, elem_prov, event);
+    if (!evm)
+        return E_OUTOFMEMORY;
+
+    evm->uia_evo = UIA_EVO_UIA;
+    evm->u.uia_ev.elem_prov = elem_prov;
+    evm->event = event;
+
+    uia_evm_add_message_to_queue(evl, evm);
+
+    return S_OK;
+}
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
index e254ee38112..2f329206251 100644
--- a/dlls/uiautomationcore/uia_private.h
+++ b/dlls/uiautomationcore/uia_private.h
@@ -95,6 +95,7 @@ struct uia_evl

     HWINEVENTHOOK win_creation_hook;
     HWINEVENTHOOK object_focus_hook;
+    IUIAEvlConnection *evlc_iface;

     struct uia_data *data;

@@ -102,6 +103,17 @@ struct uia_evl
     struct list uia_evm_queue;
 };

+/*
+ * EVLC = Event listener connection.
+ */
+struct uia_evlc
+{
+    IUIAEvlConnection IUIAEvlConnection_iface;
+    LONG ref;
+
+    struct uia_evl *evl;
+};
+
 struct uia_data {
     IUIAutomation IUIAutomation_iface;
     LONG ref;
diff --git a/include/uiautomationcore.idl b/include/uiautomationcore.idl
index e10c2316ceb..7d33bde45a4 100644
--- a/include/uiautomationcore.idl
+++ b/include/uiautomationcore.idl
@@ -291,4 +291,21 @@ library UIA

         HRESULT GetFocus([out, retval] IRawElementProviderFragment **pRetVal);
     }
+
+#ifdef __WIDL__
+    [
+        object,
+        uuid(5d419260-d515-11eb-b8bc-0242ac130003),
+        oleautomation,
+        pointer_default(unique)
+    ]
+    interface IUIAEvlConnection : IUnknown
+    {
+        HRESULT ProviderRaiseEvent(
+                [in] long event,
+                [in] IRawElementProviderSimple *pRetVal);
+        HRESULT CheckListenerStatus(
+                [out, retval] VARIANT *val);
+    }
+#endif
 }
From bc57cedd3c832269380c75ea9fa2b15c644b9565 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 26 Jul 2021 15:04:37 -0400
Subject: [PATCH] uiautomationcore: Send UI Automation Providers an event
 listener interface.

Send UI Automation providers an IUIAEvlConnection interface so that they
can send raised events to active event listeners. Pass this interface by
modifying UiaReturnRawElementProvider's wParam value.

Signed-off-by: Connor McAdams <conmanx360@gmail.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_event.c | 115 +++++++++++++++++++++++++++++-
 dlls/uiautomationcore/uia_main.c  |  71 +++++++++++++++++-
 2 files changed, 183 insertions(+), 3 deletions(-)

diff --git a/dlls/uiautomationcore/uia_event.c b/dlls/uiautomationcore/uia_event.c
index be637edeb2d..fcb0907101c 100644
--- a/dlls/uiautomationcore/uia_event.c
+++ b/dlls/uiautomationcore/uia_event.c
@@ -31,6 +31,102 @@ static HRESULT uia_evm_add_msaa_event(struct uia_evl *evl, HWND hwnd,
 static HRESULT uia_evm_add_uia_event(struct uia_evl *evl,
         IRawElementProviderSimple *elem_prov, UINT event);

+/*
+ * FIXME: Need to keep track of each UIA provider window, and be able to
+ * dynamically use the IRawElementProviderAdviseEvents interface to add/remove
+ * events as they are added/removed. For now, we're just adding the
+ * UIA_AutomationFocusChangedEventId event if the fragment root exposes
+ * an IRawElementProviderAdviseEvents interface.
+ */
+static void uia_get_advise_events_iface(IRawElementProviderSimple *elprov)
+{
+    IRawElementProviderAdviseEvents *elem_events = NULL;
+    IRawElementProviderFragmentRoot *frag_root = NULL;
+    IRawElementProviderFragment *elem_frag = NULL;
+    HRESULT hr;
+
+    hr = IRawElementProviderSimple_QueryInterface(elprov, &IID_IRawElementProviderFragment, (void **)&elem_frag);
+    if (FAILED(hr) || !elem_frag)
+        return;
+
+    hr = IRawElementProviderFragment_get_FragmentRoot(elem_frag, &frag_root);
+    if (FAILED(hr) || !frag_root)
+        goto exit;
+
+    hr = IRawElementProviderFragmentRoot_QueryInterface(frag_root, &IID_IRawElementProviderAdviseEvents, (void **)&elem_events);
+    if (FAILED(hr) || !elem_events)
+        goto exit;
+
+    IRawElementProviderAdviseEvents_AdviseEventAdded(elem_events, UIA_AutomationFocusChangedEventId, NULL);
+
+exit:
+    if (elem_frag)
+        IRawElementProviderFragment_Release(elem_frag);
+    if (frag_root)
+        IRawElementProviderFragmentRoot_Release(frag_root);
+    if (elem_events)
+        IRawElementProviderAdviseEvents_Release(elem_events);
+}
+
+/*
+ * Check if a window responds to a request for a UI Automation object, and if
+ * it does, send it an event listener connection interface.
+ */
+static BOOL uia_evl_attempt_evlc_connect(HWND hwnd, IUIAEvlConnection *iface)
+{
+    IRawElementProviderSimple *elem_prov;
+    LRESULT lres;
+    HRESULT hr;
+
+    lres = SendMessageW(hwnd, WM_GETOBJECT, 0, UiaRootObjectId);
+    if (!lres || FAILED(lres))
+        return FALSE;
+
+    /*
+     * This confirms we have an actual UI Automation provider, release the
+     * returned raw element provider interface and send an evlc interface.
+     */
+    hr = ObjectFromLresult(lres, &IID_IRawElementProviderSimple, 0,
+            (void **)&elem_prov);
+    if (FAILED(hr))
+        return FALSE;
+
+    uia_get_advise_events_iface(elem_prov);
+    IRawElementProviderSimple_Release(elem_prov);
+
+    /* FIXME: Probably a less hacky way to do this. Revisit later. */
+    lres = LresultFromObject(&IID_IUIAEvlConnection, 0, (IUnknown *)iface);
+    PostMessageW(hwnd, WM_GETOBJECT, (WPARAM)lres, UiaRootObjectId);
+
+    return TRUE;
+}
+
+/*
+ * Attempt to send an evlc interface to a window if it's a UIA Provider.
+ * If it isn't, try to get an IAccessible from it so that if it has
+ * accessibility functionality, it gets activated.
+ */
+static void uia_evl_query_hwnd(HWND hwnd, struct uia_evl *evl)
+{
+    IAccessible *acc;
+    WCHAR buf[256];
+
+    /*
+     * FIXME: Ignore windows that are obviously created by Wine. Before I did
+     * this, there'd be random hangs. Might be a better solution.
+     */
+    if (GetClassNameW(hwnd, buf, ARRAY_SIZE(buf)) && (!lstrcmpW(buf, L"OleMainThreadWndClass") ||
+            !lstrcmpW(buf, L"IME")))
+        return;
+
+    if (uia_evl_attempt_evlc_connect(hwnd, evl->evlc_iface))
+        return;
+
+    AccessibleObjectFromWindow(hwnd, OBJID_CLIENT, &IID_IAccessible, (void **)&acc);
+    if (acc)
+        IAccessible_Release(acc);
+}
+
 /*
  * Custom COM interface that is passed to UIA providers. Allows them to raise
  * events to be sent to any clients with active event listener threads.
@@ -187,7 +283,11 @@ void CALLBACK uia_evl_window_create_proc(HWINEVENTHOOK hWinEventHook, DWORD even
         HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread,
         DWORD dwmsEventTime)
 {
-    return;
+    if (event == EVENT_OBJECT_CREATE && idObject == OBJID_WINDOW)
+    {
+        struct uia_evl *evl = (struct uia_evl *)TlsGetValue(tls_index);
+        uia_evl_query_hwnd(hwnd, evl);
+    }
 }

 /*
@@ -286,6 +386,17 @@ static void uia_evl_process_evm_queue(struct uia_evl *evl)
     }
 }

+/*
+ * Upon event listener creation, query each window on the desktop for
+ * accessibility data. Once started, new windows will be queried upon
+ * creation.
+ */
+static BOOL CALLBACK uia_evl_enumerate_windows(HWND hwnd, LPARAM lparam)
+{
+    uia_evl_query_hwnd(hwnd, (struct uia_evl *)lparam);
+    return TRUE;
+}
+
 /*
  * UI Automation Event Listener functions.
  * The first time an event handler interface is added on the client side, the
@@ -314,6 +425,8 @@ static HRESULT uia_event_listener_thread_initialize(struct uia_evl *evl)
      * events to active listeners.
      */
     create_uia_evlc_iface(&evl->evlc_iface);
+    impl_from_IUIAEvlConnection(evl->evlc_iface)->evl = evl;
+    EnumWindows(uia_evl_enumerate_windows, (LPARAM)evl);

     return S_OK;
 }
diff --git a/dlls/uiautomationcore/uia_main.c b/dlls/uiautomationcore/uia_main.c
index c8a3795ed1b..46ba4cbeacc 100644
--- a/dlls/uiautomationcore/uia_main.c
+++ b/dlls/uiautomationcore/uia_main.c
@@ -259,13 +259,51 @@ IRawElementProviderSimpleVtbl hwnd_host_provider_vtbl = {
     hwnd_host_provider_get_HostRawElementProvider,
 };

+struct uia_provider_evlc
+{
+    struct list entry;
+
+    IUIAEvlConnection *evlc_iface;
+};
+
+static struct list global_provider_evlc_list = LIST_INIT( global_provider_evlc_list );
+
+/*
+ * Check the current list of evlc's on the provider side to see if they are
+ * still active. If not, remove them from the list.
+ */
+static void prune_listener_list(void)
+{
+    struct uia_provider_evlc *evlc;
+    struct list *cursor, *cursor2;
+    VARIANT var;
+    HRESULT hr;
+
+    LIST_FOR_EACH_SAFE(cursor, cursor2, &global_provider_evlc_list)
+    {
+        evlc = LIST_ENTRY(cursor, struct uia_provider_evlc, entry);
+        hr = IUIAEvlConnection_CheckListenerStatus(evlc->evlc_iface, &var);
+        if (hr == CO_E_OBJNOTCONNECTED)
+        {
+            list_remove(cursor);
+            IUIAEvlConnection_Release(evlc->evlc_iface);
+            heap_free(evlc);
+        }
+    }
+}
+
 /***********************************************************************
  *          UiaClientsAreListening (uiautomationcore.@)
  */
 BOOL WINAPI UiaClientsAreListening(void)
 {
-    FIXME("()\n");
-    return FALSE;
+    TRACE("()\n");
+
+    prune_listener_list();
+    if (list_empty(&global_provider_evlc_list))
+        return FALSE;
+
+    return TRUE;
 }

 /***********************************************************************
@@ -321,6 +359,35 @@ LRESULT WINAPI UiaReturnRawElementProvider(HWND hwnd, WPARAM wParam,
         return 0;
     }

+    /*
+     * If a client send a WM_GETOBJECT message with a wParam value that isn't
+     * 0, it's attempting to send an IUIAEvlConnection interface so that the
+     * provider can signal events to the event listener.
+     */
+    if (wParam)
+    {
+        IUIAEvlConnection *evlc_iface;
+        VARIANT var;
+        HRESULT hr;
+
+        TRACE("Client sent IUIAEvlConnection interface!\n");
+        hr = ObjectFromLresult((LRESULT)wParam, &IID_IUIAEvlConnection, 0,
+                (void **)&evlc_iface);
+        hr = IUIAEvlConnection_CheckListenerStatus(evlc_iface, &var);
+        if (SUCCEEDED(hr))
+        {
+            struct uia_provider_evlc *uia = heap_alloc_zero(sizeof(*uia));
+            if (!uia)
+                return 0;
+
+            /* If success, add this to the providers listening clients list. */
+            uia->evlc_iface = evlc_iface;
+            list_add_tail(&global_provider_evlc_list, &uia->entry);
+        }
+
+        return 0;
+    }
+
     return LresultFromObject(&IID_IRawElementProviderSimple, wParam, (IUnknown *)elprov);
 }

From 4d476fc39a73a3c279976d52edb4e73f5cd676ad Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Wed, 30 Jun 2021 09:35:50 -0400
Subject: [PATCH] uiautomationcore: Implement UiaRaiseAutomationEvent.

Signed-off-by: Connor McAdams <conmanx360@gmail.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_main.c | 21 ++++++++++++++++++++-
 1 file changed, 20 insertions(+), 1 deletion(-)

diff --git a/dlls/uiautomationcore/uia_main.c b/dlls/uiautomationcore/uia_main.c
index 46ba4cbeacc..952a9d47a0d 100644
--- a/dlls/uiautomationcore/uia_main.c
+++ b/dlls/uiautomationcore/uia_main.c
@@ -396,7 +396,26 @@ LRESULT WINAPI UiaReturnRawElementProvider(HWND hwnd, WPARAM wParam,
  */
 HRESULT WINAPI UiaRaiseAutomationEvent(IRawElementProviderSimple *provider, EVENTID id)
 {
-    FIXME("(%p, %d): stub\n", provider, id);
+    struct uia_provider_evlc *evlc;
+    struct list *cursor, *cursor2;
+    HRESULT hr;
+
+    TRACE("(%p, %d)\n", provider, id);
+
+    LIST_FOR_EACH_SAFE(cursor, cursor2, &global_provider_evlc_list)
+    {
+        evlc = LIST_ENTRY(cursor, struct uia_provider_evlc, entry);
+        hr = IUIAEvlConnection_ProviderRaiseEvent(evlc->evlc_iface, id, provider);
+        TRACE("Event raised!\n");
+        if (hr == CO_E_OBJNOTCONNECTED)
+        {
+            TRACE("Evlc no longer active, removing.\n");
+            list_remove(cursor);
+            IUIAEvlConnection_Release(evlc->evlc_iface);
+            heap_free(evlc);
+        }
+    }
+
     return S_OK;
 }

From 0790c4220b451ab36c3412b2bf14cd9bb86979ad Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Tue, 1 Jun 2021 09:18:41 -0400
Subject: [PATCH] tabtip: Create tabtip.exe.

TabTIP: Tablet text input panel. This program watches for editable text
input fields gaining focus and runs an event handler when this occurs.

Signed-off-by: Connor McAdams <conmanx360@gmail.com>
CW-Bug-Id: #18351
---
 configure                   |   2 +
 configure.ac                |   1 +
 programs/tabtip/Makefile.in |   6 +
 programs/tabtip/tabtip.c    | 365 ++++++++++++++++++++++++++++++++++++
 4 files changed, 374 insertions(+)
 create mode 100644 programs/tabtip/Makefile.in
 create mode 100644 programs/tabtip/tabtip.c

diff --git a/configure b/configure
index e4cb2ec69e2..2c7c59e8996 100755
--- a/configure
+++ b/configure
@@ -1905,6 +1905,7 @@ enable_start
 enable_subst
 enable_svchost
 enable_systeminfo
+enable_tabtip
 enable_taskkill
 enable_tasklist
 enable_taskmgr
@@ -22688,6 +22689,7 @@ wine_fn_config_makefile programs/start enable_start
 wine_fn_config_makefile programs/subst enable_subst
 wine_fn_config_makefile programs/svchost enable_svchost
 wine_fn_config_makefile programs/systeminfo enable_systeminfo
+wine_fn_config_makefile programs/tabtip enable_tabtip
 wine_fn_config_makefile programs/taskkill enable_taskkill
 wine_fn_config_makefile programs/tasklist enable_tasklist
 wine_fn_config_makefile programs/taskmgr enable_taskmgr
diff --git a/configure.ac b/configure.ac
index b1044c175b0..b6d0e64c2b8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3651,6 +3651,7 @@ WINE_CONFIG_MAKEFILE(programs/start)
 WINE_CONFIG_MAKEFILE(programs/subst)
 WINE_CONFIG_MAKEFILE(programs/svchost)
 WINE_CONFIG_MAKEFILE(programs/systeminfo)
+WINE_CONFIG_MAKEFILE(programs/tabtip)
 WINE_CONFIG_MAKEFILE(programs/taskkill)
 WINE_CONFIG_MAKEFILE(programs/tasklist)
 WINE_CONFIG_MAKEFILE(programs/taskmgr)
diff --git a/programs/tabtip/Makefile.in b/programs/tabtip/Makefile.in
new file mode 100644
index 00000000000..846b813be69
--- /dev/null
+++ b/programs/tabtip/Makefile.in
@@ -0,0 +1,6 @@
+MODULE    = tabtip.exe
+IMPORTS   = uuid ole32 user32 oleacc uiautomationcore rpcrt4 shell32
+
+EXTRADLLFLAGS = -mconsole -municode -mno-cygwin
+
+C_SRCS = tabtip.c
diff --git a/programs/tabtip/tabtip.c b/programs/tabtip/tabtip.c
new file mode 100644
index 00000000000..18b8ae32ef8
--- /dev/null
+++ b/programs/tabtip/tabtip.c
@@ -0,0 +1,365 @@
+/*
+ * Copyright 2021 Connor McAdams
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "windows.h"
+#define COBJMACROS
+#include <initguid.h>
+#include "uiautomation.h"
+#include "ole2.h"
+#include "strsafe.h"
+#include "oleacc.h"
+#include "shellapi.h"
+#include <wchar.h>
+#include <winternl.h>
+
+#include "wine/debug.h"
+#ifndef UNICODE
+#define UNICODE
+#endif
+
+WINE_DEFAULT_DEBUG_CHANNEL(tabtip);
+
+extern HANDLE CDECL __wine_make_process_system(void);
+LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
+
+enum {
+    EVENT_PGM_EXIT,
+    EVENT_WINE_EXIT,
+    THREAD_EVENT_COUNT,
+};
+
+struct thread_data {
+    HANDLE events[THREAD_EVENT_COUNT];
+    HWND main_hwnd;
+};
+
+typedef struct {
+    IUIAutomationFocusChangedEventHandler IUIAutomationFocusChangedEventHandler_iface;
+    LONG ref;
+} event_data;
+
+DWORD last_keyup_event;
+BOOL keyboard_up;
+
+static const char *ct_id_str[] = {
+    "UIA_ButtonControlTypeId (50000)",
+    "UIA_CalendarControlTypeId (50001)",
+    "UIA_CheckBoxControlTypeId (50002)",
+    "UIA_ComboBoxControlTypeId (50003)",
+    "UIA_EditControlTypeId (50004)",
+    "UIA_HyperlinkControlTypeId (50005)",
+    "UIA_ImageControlTypeId (50006)",
+    "UIA_ListItemControlTypeId (50007)",
+    "UIA_ListControlTypeId (50008)",
+    "UIA_MenuControlTypeId (50009)",
+    "UIA_MenuBarControlTypeId (50010)",
+    "UIA_MenuItemControlTypeId (50011)",
+    "UIA_ProgressBarControlTypeId (50012)",
+    "UIA_RadioButtonControlTypeId (50013)",
+    "UIA_ScrollBarControlTypeId (50014)",
+    "UIA_SliderControlTypeId (50015)",
+    "UIA_SpinnerControlTypeId (50016)",
+    "UIA_StatusBarControlTypeId (50017)",
+    "UIA_TabControlTypeId (50018)",
+    "UIA_TabItemControlTypeId (50019)",
+    "UIA_TextControlTypeId (50020)",
+    "UIA_ToolBarControlTypeId (50021)",
+    "UIA_ToolTipControlTypeId (50022)",
+    "UIA_TreeControlTypeId (50023)",
+    "UIA_TreeItemControlTypeId (50024)",
+    "UIA_CustomControlTypeId (50025)",
+    "UIA_GroupControlTypeId (50026)",
+    "UIA_ThumbControlTypeId (50027)",
+    "UIA_DataGridControlTypeId (50028)",
+    "UIA_DataItemControlTypeId (50029)",
+    "UIA_DocumentControlTypeId (50030)",
+    "UIA_SplitButtonControlTypeId (50031)",
+    "UIA_WindowControlTypeId (50032)",
+    "UIA_PaneControlTypeId (50033)",
+    "UIA_HeaderControlTypeId (50034)",
+    "UIA_HeaderItemControlTypeId (50035)",
+    "UIA_TableControlTypeId (50036)",
+    "UIA_TitleBarControlTypeId (50037)",
+    "UIA_SeparatorControlTypeId (50038)",
+    "UIA_SemanticZoomControlTypeId (50039)",
+    "UIA_AppBarControlTypeId (50040)",
+};
+
+/*
+ * IUIAutomationFocusChangedEventHandler vtbl.
+ */
+static inline event_data *impl_from_uia_focus_event(IUIAutomationFocusChangedEventHandler *iface)
+{
+    return CONTAINING_RECORD(iface, event_data, IUIAutomationFocusChangedEventHandler_iface);
+}
+
+HRESULT WINAPI uia_focus_event_QueryInterface(IUIAutomationFocusChangedEventHandler *iface,
+        REFIID riid, void **ppv)
+{
+    event_data *This = impl_from_uia_focus_event(iface);
+
+    WINE_TRACE("This %p, %s\n", This, debugstr_guid( riid ));
+    if (IsEqualIID(riid, &IID_IUIAutomationFocusChangedEventHandler) ||
+            IsEqualIID(riid, &IID_IUnknown)) {
+        *ppv = iface;
+    } else {
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUIAutomationFocusChangedEventHandler_AddRef(iface);
+    return S_OK;
+}
+
+ULONG WINAPI uia_focus_event_AddRef(IUIAutomationFocusChangedEventHandler* iface)
+{
+    event_data *This = impl_from_uia_focus_event(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+
+    WINE_TRACE("This %p, ref %d\n", This, ref);
+
+    return ref;
+}
+
+ULONG WINAPI uia_focus_event_Release(IUIAutomationFocusChangedEventHandler* iface)
+{
+    event_data *This = impl_from_uia_focus_event(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+
+    WINE_TRACE("This %p, ref %d\n", This, ref);
+
+    return ref;
+}
+
+/*** IUIAutomationFocusChangedEventHandler methods ***/
+HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChangedEventHandler *iface,
+        IUIAutomationElement *sender)
+{
+    event_data *This = impl_from_uia_focus_event(iface);
+
+    WINE_TRACE("This %p, sender %p\n", This, sender);
+    if (sender)
+    {
+        VARIANT var;
+        INT ct_id;
+        BSTR name;
+
+        IUIAutomationElement_get_CurrentControlType(sender, &ct_id);
+        IUIAutomationElement_get_CurrentName(sender, &name);
+        IUIAutomationElement_GetCurrentPropertyValue(sender, UIA_IsKeyboardFocusablePropertyId, &var);
+
+        if ((last_keyup_event < (GetTickCount() - 5000)) &&
+                ct_id == UIA_EditControlTypeId && (V_VT(&var) == VT_BOOL && V_BOOL(&var)))
+        {
+            if (!keyboard_up)
+            {
+                WINE_TRACE("Keyboard up!\n");
+                keyboard_up = TRUE;
+                ShellExecuteW(NULL, NULL, L"steam://open/keyboard", NULL, NULL, SW_SHOWNOACTIVATE);
+
+                last_keyup_event = GetTickCount();
+            }
+        }
+        else
+        {
+            if (keyboard_up)
+            {
+                WINE_TRACE("Keyboard down!\n");
+                keyboard_up = FALSE;
+            }
+        }
+
+        if (ct_id >= 50000)
+            ct_id -= 50000;
+        else
+            ct_id = 0;
+
+        WINE_TRACE("element name: %s, ct_id %s\n", wine_dbgstr_w(name), ct_id_str[ct_id]);
+    }
+
+    return S_OK;
+}
+
+IUIAutomationFocusChangedEventHandlerVtbl uia_focus_event_vtbl = {
+    uia_focus_event_QueryInterface,
+    uia_focus_event_AddRef,
+    uia_focus_event_Release,
+    uia_focus_event_HandleFocusChangedEvent,
+};
+
+static HRESULT create_uia_event_handler(IUIAutomation **uia_iface, event_data *data)
+{
+    HRESULT hr;
+
+    hr = CoCreateInstance(&CLSID_CUIAutomation, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IUIAutomation, (void **)uia_iface);
+    if (FAILED(hr))
+    {
+        ERR("Failed to create IUIAutomation interface, hr %#x\n", hr);
+        return hr;
+    }
+
+    data->IUIAutomationFocusChangedEventHandler_iface.lpVtbl = &uia_focus_event_vtbl;
+    data->ref = 1;
+
+    hr = IUIAutomation_AddFocusChangedEventHandler(*uia_iface, NULL,
+            &data->IUIAutomationFocusChangedEventHandler_iface);
+    if (FAILED(hr))
+        ERR("Failed to add focus changed event handler, hr %#x\n", hr);
+
+    return hr;
+}
+
+static DWORD WINAPI tabtip_exit_watcher(LPVOID lpParam)
+{
+    struct thread_data *data = (struct thread_data *)lpParam;
+    DWORD event;
+
+    event = WaitForMultipleObjects(THREAD_EVENT_COUNT, data->events, FALSE, INFINITE);
+    switch (event)
+    {
+    case EVENT_PGM_EXIT:
+        break;
+
+    case EVENT_WINE_EXIT:
+        PostMessageW(data->main_hwnd, WM_DESTROY, 0, 0);
+        break;
+
+    default:
+        break;
+    }
+
+    return 0;
+}
+
+int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)
+{
+    HANDLE wine_exit_event, pgm_exit_event, started_event;
+    // Register the window class.
+    const wchar_t CLASS_NAME[]  = L"IPTip_Main_Window";
+    struct thread_data t_data = { };
+    IUIAutomation *uia_iface;
+    WNDCLASSW wc = { };
+    event_data data = { };
+    MSG msg = { };
+    int ret = 0;
+    HWND hwnd;
+
+    wine_exit_event = pgm_exit_event = started_event = NULL;
+    last_keyup_event = 0;
+    keyboard_up = FALSE;
+
+    NtSetInformationProcess( GetCurrentProcess(), ProcessWineMakeProcessSystem,
+                             &wine_exit_event, sizeof(HANDLE *) );
+    pgm_exit_event = CreateEventW(NULL, 0, 0, NULL);
+    started_event = CreateEventW(NULL, TRUE, FALSE, L"TABTIP_STARTED_EVENT");
+
+    if (!pgm_exit_event || !wine_exit_event || !started_event)
+    {
+        ERR("Failed to create event handles!\n");
+        ret = -1;
+        goto exit;
+    }
+
+    wc.lpfnWndProc   = WindowProc;
+    wc.hInstance     = hInstance;
+    wc.lpszClassName = CLASS_NAME;
+
+    RegisterClassW(&wc);
+
+    hwnd = CreateWindowExW(0, CLASS_NAME,
+            L"Input", WS_OVERLAPPEDWINDOW, 4, 4, 0, 0, NULL,
+            NULL, hInstance, NULL);
+
+    if (!hwnd)
+    {
+        ERR("Failed to create hwnd!\n");
+        ret = -1;
+        goto exit;
+    }
+
+    if (FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
+    {
+        ERR("CoInitialize failed!\n");
+        ret = -1;
+        goto exit;
+    }
+
+    if (FAILED(create_uia_event_handler(&uia_iface, &data)))
+    {
+        ret = -1;
+        goto exit;
+    }
+
+    t_data.events[EVENT_WINE_EXIT] = wine_exit_event;
+    t_data.events[EVENT_PGM_EXIT]  = pgm_exit_event;
+    t_data.main_hwnd = hwnd;
+
+    SetEvent(started_event);
+    CreateThread(NULL, 0, tabtip_exit_watcher, &t_data, 0, NULL);
+
+    while (GetMessageW(&msg, NULL, 0, 0))
+    {
+        TranslateMessage(&msg);
+        DispatchMessageW(&msg);
+    }
+
+    SetEvent(pgm_exit_event);
+    IUIAutomation_RemoveAllEventHandlers(uia_iface);
+    IUIAutomation_Release(uia_iface);
+
+    CoUninitialize();
+
+exit:
+
+    if (wine_exit_event)
+        CloseHandle(wine_exit_event);
+
+    if (pgm_exit_event)
+        CloseHandle(pgm_exit_event);
+
+    if (started_event)
+        CloseHandle(started_event);
+
+    return ret;
+}
+
+LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+{
+    switch (uMsg)
+    {
+    case WM_DESTROY:
+        PostQuitMessage(0);
+        return 0;
+
+    case WM_PAINT:
+        {
+            PAINTSTRUCT ps;
+            HDC hdc = BeginPaint(hwnd, &ps);
+
+            FillRect(hdc, &ps.rcPaint, (HBRUSH) (COLOR_WINDOW+1));
+
+            EndPaint(hwnd, &ps);
+        }
+        return 0;
+    default:
+        break;
+    }
+
+    return DefWindowProcW(hwnd, uMsg, wParam, lParam);
+}
From 79b36647ecc3984775491eb7ddf4d7975d9ebc51 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Tue, 27 Jul 2021 15:54:01 -0400
Subject: [PATCH] ia2comproxy: Add proxy/stub dll for IAccessible2 interfaces.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 configure                           |    2 +
 configure.ac                        |    1 +
 dlls/ia2comproxy/Makefile.in        |   10 +
 dlls/ia2comproxy/ia2_classes.idl    |   31 +
 dlls/ia2comproxy/ia2comproxy.spec   |    4 +
 dlls/ia2comproxy/oleacc_classes.idl |   21 +
 include/Makefile.in                 |    1 +
 include/ia2api.idl                  | 5538 +++++++++++++++++++++++++++
 8 files changed, 5608 insertions(+)
 create mode 100644 dlls/ia2comproxy/Makefile.in
 create mode 100644 dlls/ia2comproxy/ia2_classes.idl
 create mode 100644 dlls/ia2comproxy/ia2comproxy.spec
 create mode 100644 dlls/ia2comproxy/oleacc_classes.idl
 create mode 100644 include/ia2api.idl

diff --git a/configure b/configure
index 2c7c59e8996..bbfdd5cc762 100755
--- a/configure
+++ b/configure
@@ -1414,6 +1414,7 @@ enable_hlink
 enable_hnetcfg
 enable_http_sys
 enable_httpapi
+enable_ia2comproxy
 enable_iccvid
 enable_icmp
 enable_ieframe
@@ -21977,6 +21978,7 @@ wine_fn_config_makefile dlls/hnetcfg/tests enable_tests
 wine_fn_config_makefile dlls/http.sys enable_http_sys
 wine_fn_config_makefile dlls/httpapi enable_httpapi
 wine_fn_config_makefile dlls/httpapi/tests enable_tests
+wine_fn_config_makefile dlls/ia2comproxy enable_ia2comproxy
 wine_fn_config_makefile dlls/iccvid enable_iccvid
 wine_fn_config_makefile dlls/icmp enable_icmp
 wine_fn_config_makefile dlls/ieframe enable_ieframe
diff --git a/configure.ac b/configure.ac
index b6d0e64c2b8..f37f4e02324 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2937,6 +2937,7 @@ WINE_CONFIG_MAKEFILE(dlls/hnetcfg/tests)
 WINE_CONFIG_MAKEFILE(dlls/http.sys)
 WINE_CONFIG_MAKEFILE(dlls/httpapi)
 WINE_CONFIG_MAKEFILE(dlls/httpapi/tests)
+WINE_CONFIG_MAKEFILE(dlls/ia2comproxy)
 WINE_CONFIG_MAKEFILE(dlls/iccvid)
 WINE_CONFIG_MAKEFILE(dlls/icmp)
 WINE_CONFIG_MAKEFILE(dlls/ieframe)
diff --git a/dlls/ia2comproxy/Makefile.in b/dlls/ia2comproxy/Makefile.in
new file mode 100644
index 00000000000..4b824b09590
--- /dev/null
+++ b/dlls/ia2comproxy/Makefile.in
@@ -0,0 +1,10 @@
+MODULE    = ia2comproxy.dll
+IMPORTLIB = ia2comproxy
+IMPORTS   = uuid rpcrt4 oleacc ole32 oleaut32
+
+EXTRADLLFLAGS = -mno-cygwin
+
+IDL_SRCS = ia2_classes.idl \
+           oleacc_classes.idl
+
+dlldata_EXTRADEFS = -DWINE_REGISTER_DLL -DPROXY_DELEGATION
diff --git a/dlls/ia2comproxy/ia2_classes.idl b/dlls/ia2comproxy/ia2_classes.idl
new file mode 100644
index 00000000000..d608a194e30
--- /dev/null
+++ b/dlls/ia2comproxy/ia2_classes.idl
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2021 Connor McAdams for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep ident
+#pragma makedep regtypelib
+#pragma makedep proxy
+#pragma makedep register
+
+cpp_quote("#include \"oleacc.h\"")
+#include "ia2api.idl"
+
+[
+    threading(both),
+    uuid(01c20f2b-3dd2-400f-949f-ad00bdab1d41)  /* IAccessibleHyperLink */
+]
+coclass PSFactoryBuffer { interface IFactoryBuffer; }
diff --git a/dlls/ia2comproxy/ia2comproxy.spec b/dlls/ia2comproxy/ia2comproxy.spec
new file mode 100644
index 00000000000..b16365d0c9f
--- /dev/null
+++ b/dlls/ia2comproxy/ia2comproxy.spec
@@ -0,0 +1,4 @@
+@ stdcall -private DllCanUnloadNow()
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
+@ stdcall -private DllRegisterServer()
+@ stdcall -private DllUnregisterServer()
diff --git a/dlls/ia2comproxy/oleacc_classes.idl b/dlls/ia2comproxy/oleacc_classes.idl
new file mode 100644
index 00000000000..62674f0e6ec
--- /dev/null
+++ b/dlls/ia2comproxy/oleacc_classes.idl
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2021 Connor McAdams for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep ident
+
+#include "oleacc.idl"
diff --git a/include/Makefile.in b/include/Makefile.in
index a3841c8870b..95d5a896830 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -338,6 +338,7 @@ SOURCES = \
 	httprequest.idl \
 	httprequestid.h \
 	i_cryptasn1tls.h \
+        ia2api.idl \
 	iads.idl \
 	icftypes.idl \
 	icm.h \
diff --git a/include/ia2api.idl b/include/ia2api.idl
new file mode 100644
index 00000000000..f34f6cf2fae
--- /dev/null
+++ b/include/ia2api.idl
@@ -0,0 +1,5538 @@
+/*************************************************************************
+ *
+ *  File Name (api_all_headers.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2013 Linux Foundation
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+import "objidl.idl";
+import "oaidl.idl";
+import "oleacc.idl";
+
+/*************************************************************************
+ *
+ *  File Name (IA2CommonTypes.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+ /** These constants control the scrolling of an object or substring into a window.
+
+ This enum is used in IAccessible2::scrollTo and IAccessibleText::scrollSubstringTo.
+*/
+enum IA2ScrollType {
+
+  /** Scroll the top left corner of the object or substring such that the top left
+   corner (and as much as possible of the rest of the object or substring) is within
+   the top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_TOP_LEFT,
+
+  /** Scroll the bottom right corner of the object or substring such that the bottom right
+   corner (and as much as possible of the rest of the object or substring) is within
+   the top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_BOTTOM_RIGHT,
+
+  /** Scroll the top edge of the object or substring such that the top edge
+   (and as much as possible of the rest of the object or substring) is within the
+   top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_TOP_EDGE,
+
+  /** Scroll the bottom edge of the object or substring such that the bottom edge
+   (and as much as possible of the rest of the object or substring) is within the
+   top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_BOTTOM_EDGE,
+
+  /** Scroll the left edge of the object or substring such that the left edge
+   (and as much as possible of the rest of the object or substring) is within the
+   top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_LEFT_EDGE,
+
+  /** Scroll the right edge of the object or substring such that the right edge
+   (and as much as possible of the rest of the object or substring) is within the
+   top level window.  In cases where the entire object or substring fits within
+   the top level window, the placement of the object or substring is dependent on
+   the application.  For example, the object or substring may be scrolled to the
+   closest edge, the furthest edge, or midway between those two edges.  In cases
+   where there is a hierarchy of nested scrollable controls, more than one control
+   may have to be scrolled.
+  */
+  IA2_SCROLL_TYPE_RIGHT_EDGE,
+
+  /** Scroll the object or substring such that as much as possible of the
+   object or substring is within the top level window.  The placement of
+   the object is dependent on the application.  For example, the object or
+   substring may be scrolled to to closest edge, the furthest edge, or midway
+   between those two edges.
+  */
+  IA2_SCROLL_TYPE_ANYWHERE
+};
+
+/** These constants define which coordinate system a point is located in.
+
+ This enum is used in IAccessible2::scrollToPoint, IAccessibleImage::imagePosition,
+ IAccessibleText::characterExtents, and IAccessibleText::offsetAtPoint, and
+ IAccessibleText::scrollSubstringToPoint.
+*/
+enum IA2CoordinateType {
+
+  /// The coordinates are relative to the screen.
+  IA2_COORDTYPE_SCREEN_RELATIVE,
+
+  /** The coordinates are relative to the upper left corner of the bounding box
+   of the immediate parent.
+  */
+  IA2_COORDTYPE_PARENT_RELATIVE
+
+};
+
+/** Special offsets for use in IAccessibleText and IAccessibleEditableText methods
+
+  Refer to @ref _specialOffsets
+  "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+  for more information.
+*/
+enum IA2TextSpecialOffsets {
+  IA2_TEXT_OFFSET_LENGTH = -1,	/**< This offset is equivalent to the length of the string.  It eliminates
+								 the need to call IAccessibleText::nCharacters. */
+  IA2_TEXT_OFFSET_CARET = -2	/**< This offset signifies that the text related to the physical location
+								 of the caret should be used. */
+};
+
+/** These constants specify the kind of change made to a table.
+
+   This enum is used in the IA2TableModelChange struct which in turn is used by
+   IAccessibleTable::modelChange and IAccessibleTable2::modelChange.
+*/
+enum IA2TableModelChangeType {
+  IA2_TABLE_MODEL_CHANGE_INSERT,  // = 0;
+  IA2_TABLE_MODEL_CHANGE_DELETE,
+  IA2_TABLE_MODEL_CHANGE_UPDATE
+};
+
+/** A structure defining the type of and extents of changes made to a table
+
+ IAccessibleTable::modelChange and IAccessibleTable2::modelChange return this struct.
+ In the case of an insertion or change the row and column offsets define the boundaries
+ of the inserted or changed subtable after the operation.  In the case of a deletion
+ the row and column offsets define the boundaries of the subtable being removed before
+ the removal.
+*/
+typedef struct IA2TableModelChange {
+  enum IA2TableModelChangeType type;	// insert, delete, update
+  long firstRow;		///< 0 based, inclusive
+  long lastRow;			///< 0 based, inclusive
+  long firstColumn;		///< 0 based, inclusive
+  long lastColumn;		///< 0 based, inclusive
+} IA2TableModelChange;
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleRelation.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2013 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @defgroup grpRelations Relations
+  Use the following constants to compare against the BSTRs returned by
+  IAccessibleRelation::relationType.
+*/
+///@{
+
+/** The target object is the containing application object. */
+const WCHAR *const IA2_RELATION_CONTAINING_APPLICATION = L"containingApplication";
+
+/** The target object is the containing document object. The target object implements
+ the IAccessibleDocument interface.
+*/
+const WCHAR *const IA2_RELATION_CONTAINING_DOCUMENT = L"containingDocument";
+
+/** The target object is the containing tab pane object. */
+const WCHAR *const IA2_RELATION_CONTAINING_TAB_PANE = L"containingTabPane";
+
+/** The target object is the containing window object. */
+const WCHAR *const IA2_RELATION_CONTAINING_WINDOW = L"containingWindow";
+
+/** Some attribute of this object is affected by a target object. */
+const WCHAR *const IA2_RELATION_CONTROLLED_BY = L"controlledBy";
+
+/** This object is interactive and controls some attribute of a target object. */
+const WCHAR *const IA2_RELATION_CONTROLLER_FOR = L"controllerFor";
+
+/** This object is described by the target object. */
+const WCHAR *const IA2_RELATION_DESCRIBED_BY = L"describedBy";
+
+/** This object is describes the target object. */
+const WCHAR *const IA2_RELATION_DESCRIPTION_FOR = L"descriptionFor";
+
+/** This object is embedded by a target object. */
+const WCHAR *const IA2_RELATION_EMBEDDED_BY = L"embeddedBy";
+
+/** This object embeds a target object. This relation can be used on the
+ OBJID_CLIENT accessible for a top level window to show where the content
+ areas are.
+*/
+const WCHAR *const IA2_RELATION_EMBEDS = L"embeds";
+
+/** Content flows to this object from a target object.
+ This relation and IA2_RELATION_FLOWS_TO are useful to tie text and non-text
+ objects together in order to allow assistive technology to follow the
+ intended reading order.
+*/
+const WCHAR *const IA2_RELATION_FLOWS_FROM = L"flowsFrom";
+
+/** Content flows from this object to a target object. */
+const WCHAR *const IA2_RELATION_FLOWS_TO = L"flowsTo";
+
+/** This object is label for a target object. */
+const WCHAR *const IA2_RELATION_LABEL_FOR = L"labelFor";
+
+/** This object is labelled by a target object. Note that the double L spelling
+ which follows is preferred.  Please use it instead.  This single L version may
+ be removed in a later version.
+*/
+const WCHAR *const IA2_RELATION_LABELED_BY = L"labelledBy";
+
+/** This object is labelled by a target object. */
+const WCHAR *const IA2_RELATION_LABELLED_BY = L"labelledBy";
+
+/** This object is a member of a group of one or more objects. When
+ there is more than one object in the group each member may have one and the
+ same target, e.g. a grouping object.  It is also possible that each member has
+ multiple additional targets, e.g. one for every other member in the group.
+*/
+const WCHAR *const IA2_RELATION_MEMBER_OF = L"memberOf";
+
+/** The target object is the next object in the tab order. */
+const WCHAR *const IA2_RELATION_NEXT_TABBABLE = L"nextTabbable";
+
+/** This object is a logical child of a target object.  This relation is the reciprocal
+ of the IA2_RELATION_NODE_PARENT_OF relation. In some cases an application's accessible
+ tree is such that objects can be in a logical parent-child relationship which is
+ different from the hierarchy of the accessible tree. */
+const WCHAR *const IA2_RELATION_NODE_CHILD_OF = L"nodeChildOf";
+
+/** This object is a logical parent of a target object. This relation is the reciprocal
+ of the IA2_RELATION_NODE_CHILD_OF relation. In some cases an application's accessible
+ tree is such that objects can be in a logical parent-child relationship which is
+ different from the hierarchy of the accessible tree. */
+const WCHAR *const IA2_RELATION_NODE_PARENT_OF = L"nodeParentOf";
+
+/** This object is a parent window of the target object. */
+const WCHAR *const IA2_RELATION_PARENT_WINDOW_OF = L"parentWindowOf";
+
+/** This object is a transient component related to the target object.
+ When this object is activated the target object doesn't lose focus.
+*/
+const WCHAR *const IA2_RELATION_POPUP_FOR = L"popupFor";
+
+/** The target object is the previous object in the tab order. */
+const WCHAR *const IA2_RELATION_PREVIOUS_TABBABLE = L"previousTabbable";
+
+/** This object is a sub window of a target object. */
+const WCHAR *const IA2_RELATION_SUBWINDOW_OF = L"subwindowOf";
+
+/** The target object provides the detailed, extended description for this
+ object. It provides more detailed information than would normally be provided
+ using the IA2_RELATION_DESCRIBED_BY relation. A common use for this relation is
+ in digital publishing where an extended description needs to be conveyed in
+ a book that requires structural markup or the embedding of other technology to
+ provide illustrative content. */
+const WCHAR *const IA2_RELATION_DETAILS = L"details";
+
+/** This object provides the detailed, extended description for the target
+ object. See IA2_RELATION_DETAILS. */
+const WCHAR *const IA2_RELATION_DETAILS_FOR = L"detailsFor";
+
+/** The target object is the error message for this object. */
+const WCHAR *const IA2_RELATION_ERROR = L"error";
+
+/** This object is the error message for the target object. */
+const WCHAR *const IA2_RELATION_ERROR_FOR = L"errorFor";
+
+///@}
+
+/** This interface gives access to an object's set of relations.
+*/
+[object, uuid(7CDF86EE-C3DA-496a-BDA4-281B336E1FDC)]
+interface IAccessibleRelation : IUnknown
+{
+  /** @brief Returns the type of the relation.
+   @param [out] relationType
+    The strings returned are defined @ref grpRelations "in this section of the documentation".
+   @retval S_OK
+  */
+  [propget] HRESULT relationType
+    (
+     [out, retval] BSTR *relationType
+    );
+
+  /** @brief Returns a localized version of the relation type.
+   @param [out] localizedRelationType
+   @retval S_OK
+  */
+  [propget] HRESULT localizedRelationType
+    (
+     [out, retval] BSTR *localizedRelationType
+    );
+
+  /** @brief Returns the number of targets for this relation.
+   @param [out] nTargets
+   @retval S_OK
+  */
+  [propget] HRESULT nTargets
+    (
+     [out, retval] long *nTargets
+    );
+
+  /** @brief Returns one accessible relation target.
+   @param [in] targetIndex
+    0 based index
+   @param [out] target
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Use QueryInterface to get IAccessible2.
+  */
+  [propget] HRESULT target
+    (
+     [in] long targetIndex,
+     [out, retval] IUnknown **target
+    );
+
+  /** @brief Returns multiple accessible relation targets
+   @param [in] maxTargets
+    maximum size of the array allocated by the client
+   @param [out] targets
+    The array of target objects.  Note that this array is to be allocated by the
+	client and freed when no longer needed.  Refer to @ref _arrayConsideration
+	"Special Consideration when using Arrays" for more details.  You will need to use
+	QueryInterface on the IUnknown to get the IAccessible2.
+   @param [out] nTargets
+	actual number of targets in the returned array (not more than maxTargets)
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, e.g. a negative value
+  */
+  [propget] HRESULT targets
+    (
+     [in] long maxTargets,
+     [out, size_is(maxTargets), length_is(*nTargets)]
+       IUnknown **targets,
+     [out, retval] long *nTargets
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleAction.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2013 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** This enum defines values which are predefined actions for use when implementing
+ support for media.
+
+ This enum is used when specifying an action for IAccessibleAction::doAction.
+*/
+
+enum IA2Actions {
+  IA2_ACTION_OPEN = -1,         /**< Used to inform the server that the client will
+                                signal via IA2_ACTION_COMPLETE when it has consumed
+                                the content provided by the object.  This action
+                                allows the object's server to wait for all clients
+                                to signal their readiness for additional content.
+                                Any form of content generation that requires
+                                synchronization with an AT would require use of this
+                                action.  One example is the generation of text describing
+                                visual content not obvious from a video's sound track.
+                                In this scenario the Text to Speech or Braille output
+                                may take more time than the related length of silence
+                                in the video's sound track. */
+  IA2_ACTION_COMPLETE = -2,  	/**< Used by the client to inform the server that it has
+                                consumed the most recent content provided by this object. */
+  IA2_ACTION_CLOSE = -3         /**< Used to inform the server that the client no longer
+                                requires synchronization. */
+};
+
+/** @brief This interface gives access to actions that can be executed
+  for accessible objects.
+
+ Every accessible object that can be manipulated via the native GUI beyond the
+  methods available either in the MSAA IAccessible interface or in the set of
+  IAccessible2 interfaces (other than this IAccessibleAction interface) should
+  support the IAccessibleAction interface in order to provide Assistive Technology
+  access to all the actions that can be performed by the object.  Each action can
+  be performed or queried for a name, description or associated key bindings.
+  Actions are needed more for ATs that assist the mobility impaired, such as
+  on-screen keyboards and voice command software.  By providing actions directly,
+  the AT can present them to the user without the user having to perform the extra
+  steps to navigate a context menu.
+
+ The first action should be equivalent to the MSAA default action.  If there is
+  only one action, %IAccessibleAction should also be implemented.
+*/
+[object, uuid(B70D9F59-3B5A-4dba-AB9E-22012F607DF5)]
+interface IAccessibleAction : IUnknown
+{
+
+  /** @brief Returns the number of accessible actions available in this object.
+
+   If there are more than one, the first one is considered the
+    "default" action of the object.
+   @param [out] nActions
+    The returned value of the number of actions is zero if there are
+    no actions.
+   @retval S_OK
+   @note This method is missing a [propget] prefix in the IDL.  The result is the
+    method is named nActions in generated C++ code instead of get_nActions.
+  */
+  HRESULT nActions
+    (
+     [out,retval] long* nActions
+    );
+
+  /** @brief Performs the specified Action on the object.
+   @param [in] actionIndex
+    0 based index specifying the action to perform.  If it lies outside
+    the valid range no action is performed.
+   @retval S_OK
+   @retval S_FALSE if action could not be performed
+   @retval E_INVALIDARG if bad [in] passed
+   @note If implementing support for media, refer to the predefined constants in the ::IA2Actions enum.
+    */
+  HRESULT doAction
+    (
+     [in] long actionIndex
+    );
+
+  /** @brief Returns a description of the specified action of the object.
+   @param [in] actionIndex
+    0 based index specifying which action's description to return.
+    If it lies outside the valid range an empty string is returned.
+   @param [out] description
+    The returned value is a localized string of the specified action.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed
+    */
+  [propget] HRESULT description
+    (
+     [in] long actionIndex,
+     [out, retval] BSTR *description
+    );
+
+  /** @brief Returns an array of BSTRs describing one or more key bindings, if
+   there are any, associated with the specified action.
+
+   The returned strings are the localized human readable key sequences to be
+   used to activate each action, e.g. "Ctrl+Shift+D".  Since these key
+   sequences are to be used when the object has focus, they are like
+   mnemonics (access keys), and not like shortcut (accelerator) keys.
+
+   There is no need to implement this method for single action controls since
+   that would be redundant with the standard MSAA programming practice of
+   getting the mnemonic from get_accKeyboardShortcut.
+
+   An AT such as an On Screen Keyboard might not expose these bindings but
+   provide alternative means of activation.
+
+   Note: the client allocates and passes in an array of pointers.  The server
+   allocates the BSTRs and passes back one or more pointers to these BSTRs into
+   the array of pointers allocated by the client.  The client is responsible
+   for deallocating the BSTRs.
+
+   @param [in] actionIndex
+    0 based index specifying which action's key bindings should be returned.
+   @param [in] nMaxBindings
+    This parameter is ignored. Refer to @ref _arrayConsideration
+	"Special Consideration when using Arrays" for more details.
+   @param [out] keyBindings
+    An array of BSTRs, allocated by the server, one for each key binding.
+	The client must free it with CoTaskMemFree.
+   @param [out] nBindings
+    The number of key bindings returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are no key bindings, [out] values are NULL and 0 respectively
+   @retval E_INVALIDARG if bad [in] passed
+	*/
+  [propget] HRESULT keyBinding
+    (
+     [in] long actionIndex,
+     [in] long nMaxBindings,
+     [out, size_is(,nMaxBindings), length_is(,*nBindings)] BSTR **keyBindings,
+	 [out, retval] long *nBindings
+    );
+
+  /** @brief Returns the non-localized name of specified action.
+   @param [in] actionIndex
+    0 based index specifying which action's non-localized name should be returned.
+   @param [out] name
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed
+   */
+  [propget] HRESULT name
+    (
+     [in] long actionIndex,
+     [out, retval] BSTR *name
+    );
+
+  /** @brief Returns the localized name of specified action.
+   @param [in] actionIndex
+    0 based index specifying which action's localized name should be returned.
+   @param [out] localizedName
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed
+   */
+  [propget] HRESULT localizedName
+    (
+     [in] long actionIndex,
+     [out, retval] BSTR *localizedName
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleRole.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007-2018 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** Collection of roles
+
+  This enumerator defines an extended set of accessible roles of objects implementing
+  the %IAccessible2 interface. These roles are in addition to the MSAA roles obtained
+  through the MSAA get_accRole method.  Examples are 'footnote', 'heading', and
+  'label'. You obtain an object's %IAccessible2 roles by calling IAccessible2::role.
+*/
+enum IA2Role {
+
+  /** Unknown role. The object contains some Accessible information, but its
+   role is not known.
+  */
+  IA2_ROLE_UNKNOWN = 0,
+
+  /** An object that can be drawn into and to manage events from the objects
+   drawn into it.  Also refer to ::IA2_ROLE_FRAME,
+   ::IA2_ROLE_GLASS_PANE, and ::IA2_ROLE_LAYERED_PANE.
+  */
+  IA2_ROLE_CANVAS = 0x401,
+
+  /// A caption describing another object.
+  IA2_ROLE_CAPTION,
+
+  /// Used for check buttons that are menu items.
+  IA2_ROLE_CHECK_MENU_ITEM,
+
+  /// A specialized dialog that lets the user choose a color.
+  IA2_ROLE_COLOR_CHOOSER,
+
+  /// A date editor.
+  IA2_ROLE_DATE_EDITOR,
+
+  /** An iconified internal frame in an ::IA2_ROLE_DESKTOP_PANE.
+   Also refer to ::IA2_ROLE_INTERNAL_FRAME.
+  */
+  IA2_ROLE_DESKTOP_ICON,
+
+  /** A desktop pane. A pane that supports internal frames and iconified
+   versions of those internal frames.  Also refer to ::IA2_ROLE_INTERNAL_FRAME.
+  */
+  IA2_ROLE_DESKTOP_PANE,
+
+  /** A directory pane. A pane that allows the user to navigate through
+   and select the contents of a directory. May be used by a file chooser.
+   Also refer to ::IA2_ROLE_FILE_CHOOSER.
+  */
+  IA2_ROLE_DIRECTORY_PANE,
+
+  /** An editable text object in a toolbar. <b>Deprecated.</b>
+   The edit bar role was meant for a text area in a tool bar. However, to detect
+   a text area in a tool bar the AT can query the parent.
+  */
+  IA2_ROLE_EDITBAR,
+
+  /// Embedded (OLE) object.
+  IA2_ROLE_EMBEDDED_OBJECT,
+
+  /// Text that is used as an endnote (footnote at the end of a chapter or section).
+  IA2_ROLE_ENDNOTE,
+
+  /** A file chooser. A specialized dialog that displays the files in the
+   directory and lets the user select a file, browse a different directory,
+   or specify a filename. May use the directory pane to show the contents of
+   a directory.
+   Also refer to ::IA2_ROLE_DIRECTORY_PANE.
+  */
+  IA2_ROLE_FILE_CHOOSER,
+
+  /** A font chooser. A font chooser is a component that lets the user pick
+   various attributes for fonts.
+  */
+  IA2_ROLE_FONT_CHOOSER,
+
+  /** Footer of a document page.
+   Also refer to ::IA2_ROLE_HEADER.
+  */
+  IA2_ROLE_FOOTER,
+
+  /// Text that is used as a footnote.  Also refer to ::IA2_ROLE_ENDNOTE.
+  IA2_ROLE_FOOTNOTE,
+
+  /** A container of form controls.  An example of the use of this role is to
+   represent an HTML FORM tag.
+  */
+  IA2_ROLE_FORM,
+
+  /** Frame role. A top level window with a title bar, border, menu bar, etc.
+   It is often used as the primary window for an application.  Also refer to
+   ::IA2_ROLE_CANVAS and the MSAA roles of dialog and window.
+  */
+  IA2_ROLE_FRAME,
+
+  /** A glass pane. A pane that is guaranteed to be painted on top of all panes
+   beneath it.  Also refer to ::IA2_ROLE_CANVAS, ::IA2_ROLE_INTERNAL_FRAME, and
+   ::IA2_ROLE_ROOT_PANE.
+  */
+  IA2_ROLE_GLASS_PANE,
+
+  /** Header of a document page.
+   Also refer to ::IA2_ROLE_FOOTER.
+  */
+  IA2_ROLE_HEADER,
+
+  /// Heading.  Use the IAccessible2::attributes level attribute to determine the heading level.
+  IA2_ROLE_HEADING,
+
+  /// A small fixed size picture, typically used to decorate components.
+  IA2_ROLE_ICON,
+
+  /** An image map object.  Usually a graphic with multiple hotspots, where
+   each hotspot can be activated resulting in the loading of another document
+   or section of a document.
+  */
+  IA2_ROLE_IMAGE_MAP,
+
+  /** An object which is used to allow input of characters not found on a keyboard,
+   such as the input of Chinese characters on a Western keyboard.
+  */
+  IA2_ROLE_INPUT_METHOD_WINDOW,
+
+  /** An internal frame. A frame-like object that is clipped by a desktop pane.
+   The desktop pane, internal frame, and desktop icon objects are often used to
+   create multiple document interfaces within an application.
+   Also refer to ::IA2_ROLE_DESKTOP_ICON, ::IA2_ROLE_DESKTOP_PANE, and ::IA2_ROLE_FRAME.
+  */
+  IA2_ROLE_INTERNAL_FRAME,
+
+  /// An object used to present an icon or short string in an interface.
+  IA2_ROLE_LABEL,
+
+  /** A layered pane. A specialized pane that allows its children to be drawn
+   in layers, providing a form of stacking order. This is usually the pane that
+   holds the menu bar as  well as the pane that contains most of the visual
+   components in a window.
+   Also refer to ::IA2_ROLE_CANVAS, ::IA2_ROLE_GLASS_PANE, and ::IA2_ROLE_ROOT_PANE.
+  */
+  IA2_ROLE_LAYERED_PANE,
+
+  /** A section whose content is parenthetic or ancillary to the main content
+   of the resource.
+  */
+  IA2_ROLE_NOTE,
+
+ /** A specialized pane whose primary use is inside a dialog.
+   Also refer to MSAA's dialog role.
+  */
+  IA2_ROLE_OPTION_PANE,
+
+  /** An object representing a page of document content.  It is used in documents
+   which are accessed by the user on a page by page basis.
+  */
+  IA2_ROLE_PAGE,
+
+  /// A paragraph of text.
+  IA2_ROLE_PARAGRAPH,
+
+  /** A radio button that is a menu item.
+   Also refer to MSAA's button and menu item roles.
+  */
+  IA2_ROLE_RADIO_MENU_ITEM,
+
+  /** An object which is redundant with another object in the accessible hierarchy.
+   ATs typically ignore objects with this role.
+  */
+  IA2_ROLE_REDUNDANT_OBJECT,
+
+  /** A root pane. A specialized pane that has a glass pane and a layered pane
+   as its children.
+   Also refer to ::IA2_ROLE_GLASS_PANE and ::IA2_ROLE_LAYERED_PANE
+  */
+  IA2_ROLE_ROOT_PANE,
+
+  /** A ruler such as those used in word processors.
+  */
+  IA2_ROLE_RULER,
+
+  /** A scroll pane. An object that allows a user to incrementally view a large
+   amount of information.  Its children can include scroll bars and a viewport.
+   Also refer to ::IA2_ROLE_VIEW_PORT and MSAA's scroll bar role.
+  */
+  IA2_ROLE_SCROLL_PANE,
+
+  /** A container of document content.  An example of the use of this role is to
+   represent an HTML DIV tag.  A section may be used as a region.  A region is a
+   group of elements that together form a perceivable unit.  A region does not
+   necessarily follow the logical structure of the content, but follows the
+   perceivable structure of the page.  A region may have an attribute in the set
+   of IAccessible2::attributes which indicates that it is "live".  A live region
+   is content that is likely to change in response to a timed change, a user
+   event, or some other programmed logic or event.
+  */
+  IA2_ROLE_SECTION,
+
+  /// Object with graphical representation used to represent content on draw pages.
+  IA2_ROLE_SHAPE,
+
+  /** A split pane. A specialized panel that presents two other panels at the
+   same time. Between the two panels is a divider the user can manipulate to make
+   one panel larger and the other panel smaller.
+  */
+  IA2_ROLE_SPLIT_PANE,
+
+  /** An object that forms part of a menu system but which can be "undocked"
+   from or "torn off" the menu system to exist as a separate window.
+  */
+  IA2_ROLE_TEAR_OFF_MENU,
+
+  /// An object used as a terminal emulator.
+  IA2_ROLE_TERMINAL,
+
+  /// Collection of objects that constitute a logical text entity.
+  IA2_ROLE_TEXT_FRAME,
+
+  /** A toggle button. A specialized push button that can be checked or unchecked,
+   but does not provide a separate indicator for the current state.
+   Also refer to MSAA's roles of push button, check box, and radio button.
+   <BR><B>Note:</B> IA2_ROLE_TOGGLE_BUTTON should not be used.  Instead, use MSAA's
+   ROLE_SYSTEM_PUSHBUTTON and STATE_SYSTEM_PRESSED.
+  */
+  IA2_ROLE_TOGGLE_BUTTON,
+
+  /** A viewport. An object usually used in a scroll pane. It represents the
+   portion of the entire data that the user can see. As the user manipulates
+   the scroll bars, the contents of the viewport can change.
+   Also refer to ::IA2_ROLE_SCROLL_PANE.
+  */
+  IA2_ROLE_VIEW_PORT,
+
+  /** An object containing content which is complementary to the main content of
+   a document, but remains meaningful when separated from the main content.  There
+   are various types of content that would appropriately have this role.  For example,
+   in the case where content is delivered via a web portal to a web browser, this may
+   include but not be limited to show times, current weather, related articles, or
+   stocks to watch.  The complementary role indicates that contained content is relevant
+   to the main content.  If the complementary content is completely separable main
+   content, it may be appropriate to use a more general role.
+  */
+  IA2_ROLE_COMPLEMENTARY_CONTENT,
+
+  /** An object representing a navigational landmark, a region on a page to
+   which the user may want quick access, such as a navigation area, a search
+   facility or the main content of a page.
+  */
+  IA2_ROLE_LANDMARK,
+
+  /**
+   * A bar that serves as a level indicator to, for instance, show
+   * the strength of a password or the charge of a battery.
+   */
+  IA2_ROLE_LEVEL_BAR,
+
+  /** Content previously deleted or proposed for deletion, e.g. in revision
+   history or a content view providing suggestions from reviewers.
+  */
+  IA2_ROLE_CONTENT_DELETION,
+
+  /** Content previously inserted or proposed for insertion, e.g. in revision
+   history or a content view providing suggestions from reviewers.
+  */
+  IA2_ROLE_CONTENT_INSERTION,
+
+  /// A section of content that is quoted from another source.
+  IA2_ROLE_BLOCK_QUOTE,
+
+  /** A run of content that is marked or highlighted, such as for reference
+   purposes, or to call it out as having a special purpose that is clear from
+   context. If the mark is used in conjuction with a related content section
+   in the document, then IA2_RELATION_DETAILS should be used to link the
+   related content (and the reverse relation IA2_RELATION_DETAILS_FOR should
+   link back to the IA2_ROLE_MARK object). If the mark has related information
+   in a tooltip, or as hidden text, then accDescription should be used to
+   provide this information.
+  */
+  IA2_ROLE_MARK,
+
+  /** A grouping for content that is called out as a proposed change from the
+   current version of the document, such as by a reviewer of the content.
+   Should include as children one or both of:
+   IA2_ROLE_CONTENT_DELETION and IA2_ROLE_CONTENT_INSERTION, in any order,
+   to indicate what the actual change is.
+   If the suggestion is accepted, the implementation should change the role to
+   a generic one such as IA2_ROLE_SECTION or IA2_ROLE_TEXT_FRAME.
+  */
+  IA2_ROLE_SUGGESTION,
+
+  /** A single comment, typically user-generated content. Supports reply
+  hierarchies via descendant structure, e.g. a child comment is a reply
+  to the parent comment. Supports groupPosition() method to determine
+  reply level (top comment is 1), as well as set size and position in set
+  within that level.
+  */
+  IA2_ROLE_COMMENT
+};
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleStates.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+typedef long AccessibleStates;
+
+/** %IAccessible2 specific state bit constants
+
+  This enum defines the state bits returned by IAccessible2::states.  The
+  %IAccessible2 state bits are in addition to those returned by MSAA.
+*/
+enum IA2States {
+
+/** Indicates a window is currently the active window, or is an active subelement
+  within a container or table.
+
+ This state can be used to indicate the current active item in a container, even
+  if the container itself is not currently active. In other words this would indicate
+  the item that will get focus if you tab to the container.
+
+ This information is important for knowing what to report for trees and potentially
+  other containers in a virtual buffer.
+
+ Also, see ::IA2_STATE_MANAGES_DESCENDANTS for more information.
+*/
+IA2_STATE_ACTIVE =					0x1,
+
+/** Indicates that the object is armed.
+
+ Used to indicate that the control is "pressed" and will be invoked when the
+  actuator, e.g. a mouse button, is "released".  An AT which either monitors the
+  mouse or synthesizes mouse events might need to know that, and possibly a talking
+  interface would even let the user know about it.  It could also potentially be
+  useful to on screen keyboards or test tools since the information does indicate
+  something about the state of the interface, for example, code operating asynchronously
+  might need to wait for the armed state to change before doing something else.
+
+*/
+IA2_STATE_ARMED =					0x2,
+
+/** Indicates the user interface object corresponding to this object no longer exists. */
+IA2_STATE_DEFUNCT =					0x4,
+
+/** An object with this state has a caret and implements the IAccessibleText interface.
+
+ Such fields may be read-only, so STATE_SYSTEM_READONLY is valid in combination
+  with IA2_STATE_EDITABLE.
+
+*/
+IA2_STATE_EDITABLE =				0x8,
+
+/** Indicates the orientation of this object is horizontal. */
+IA2_STATE_HORIZONTAL =				0x10,
+
+/** Indicates this object is minimized and is represented only by an icon. */
+IA2_STATE_ICONIFIED =				0x20,
+
+/** Indicates an input validation failure. */
+IA2_STATE_INVALID_ENTRY =			0x40,
+
+/** Indicates that this object manages its children.
+
+ Note: Due to the fact that MSAA's WinEvents don't allow the active child index
+  to be passed on the IA2_EVENT_ACTIVE_DESCENDANT_CHANGED event, the manages
+  descendants	scheme can't be used.  Instead the active child object has to fire
+  MSAA's EVENT_OBJECT_FOCUS.  In a future release a new event mechanism may be
+  added to provide for event specific data to be passed with the event.  At that
+  time the IA2_EVENT_ACTIVE_DECENDENT_CHANGED event and
+  IA2_STATE_MANAGES_DESCENDANTS state would be useful.
+*/
+IA2_STATE_MANAGES_DESCENDANTS =		0x80,
+
+/** Indicates that an object is modal.
+
+ Modal objects have the behavior that something must be done with the object
+  before the user can interact with an object in a different window.
+*/
+IA2_STATE_MODAL =					0x100,
+
+/** Indicates this text object can contain multiple lines of text. */
+IA2_STATE_MULTI_LINE =				0x200,
+
+/** Indicates this object paints every pixel within its rectangular region. */
+IA2_STATE_OPAQUE =					0x400,
+
+/** Indicates that user interaction is required.
+
+ An example of when this state is used is when a field in a form must be filled
+  before a form can be processed.
+*/
+IA2_STATE_REQUIRED =				0x800,
+
+/** Indicates an object which supports text selection.
+
+ Note: This is different than MSAA STATE_SYSTEM_SELECTABLE.
+*/
+IA2_STATE_SELECTABLE_TEXT =			0x1000,
+
+/** Indicates that this text object can contain only a single line of text. */
+IA2_STATE_SINGLE_LINE =				0x2000,
+
+/** Indicates that the accessible object is stale.
+
+ This state is used when the accessible object no longer accurately
+  represents the state of the object which it is representing such as when an
+  object is transient or when an object has been or is in the process of being
+  destroyed or when the object's index in its parent has changed.
+*/
+IA2_STATE_STALE =					0x4000,
+
+/** Indicates that the object implements autocompletion.
+
+ This state indicates that a text control will respond to the input of
+ one ore more characters and cause a sub-item to become selected.  The
+ selection may also result in events fired on the parent object.
+*/
+IA2_STATE_SUPPORTS_AUTOCOMPLETION =	0x8000,
+
+/** Indicates this object is transient.
+
+ An object has this state when its parent object has the state ::IA2_STATE_MANAGES_DESCENDANTS.
+ For example, a list item object may be managed by its parent list object and may only
+ exist as long as the object is actually rendered.  Similarly a table cell's accessible
+ object may exist only while the cell has focus.  However, from the perspective of an
+ assistive technology a transient object behaves like a non-transient object.  As a
+ result it is likely that this state is not of use to an assistive technology, but it
+ is provided in case an assistive technology determines that knowledge of the transient
+ nature of the object is useful and also for harmony with the Linux accessibility API.
+
+ Also, see ::IA2_STATE_MANAGES_DESCENDANTS for more information.
+ */
+IA2_STATE_TRANSIENT =				0x10000,
+
+/** Indicates the orientation of this object is vertical. */
+IA2_STATE_VERTICAL =				0x20000,
+
+/** Indicates this object is checkable.
+
+ The standard checkable objects are check boxes, radio buttons, check box menu
+ items, radio menu items, and toggle buttons.  Since assistive technology will
+ determine that these objects are checkable via the object's role the checkable
+ state is not required.  However, this state is necessary in those cases where
+ an object has a role which is not one of the previously mentioned roles.  An
+ example is a table cell which indicates whether or not an email has an attachment,
+ whether or not an mail is considered spam, and whether or not an email has been read.
+ */
+IA2_STATE_CHECKABLE =				0x40000,
+
+/** Indicates this object is pinned.
+
+ This state indicates that an object is fixed at a certain location.  One example
+ is a browser tab that when pinned cannot be moved until unpinned.  Another example
+ is a movable or floating object that when pinned remains in its pinned location
+ until being unpinned.
+ */
+IA2_STATE_PINNED =					0x80000
+
+};
+
+/*************************************************************************
+ *
+ *  File Name (Accessible2.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2013 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @mainpage
+
+ @section _interfaces Interfaces
+  IAccessible2\n
+  IAccessible2_2\n
+  IAccessible2_3\n
+  IAccessibleAction\n
+  IAccessibleApplication\n
+  IAccessibleComponent\n
+  IAccessibleDocument\n
+  IAccessibleEditableText\n
+  IAccessibleHypertext\n
+  IAccessibleHypertext2\n
+  IAccessibleHyperlink\n
+  IAccessibleImage\n
+  IAccessibleRelation\n
+  IAccessibleTable [Deprecated]\n
+  IAccessibleTable2\n
+  IAccessibleTableCell\n
+  IAccessibleText\n
+  IAccessibleText2\n
+  IAccessibleValue
+
+ @section _structs Structs
+  IA2Locale\n
+  IA2Range\n
+  IA2TableModelChange\n
+  IA2TextSegment
+
+ @section _enums Enums
+  ::IA2Actions values are predefined actions for use when implementing support for HTML5 media.\n
+  ::IA2CoordinateType values define the requested coordinate type (screen or parent window).\n
+  ::IA2EventID values identify events.\n
+  ::IA2Role values defines roles which are in addition to the existing MSAA roles.\n
+  ::IA2ScrollType values define where to place an object or substring on the screen.\n
+  ::IA2States values define states which are in addition to the existing MSAA states.\n
+  ::IA2TableModelChangeType values describe the kinds of changes made to a table (insert, delete, update).\n
+  ::IA2TextBoundaryType values define the requested text unit (character, word, sentence, line, paragraph).\n
+  ::IA2TextSpecialOffsets values define special offsets for use in the text interfaces.
+
+ @section _constants Constants
+  @ref grpRelations
+
+ @section _misc Miscellaneous
+  @ref _licensePage "BSD License"\n
+  @ref _generalInfo "General Information"\n
+
+ @page _licensePage BSD License
+  %IAccessible2 IDL Specification
+
+  Copyright (c) 2007, 2013 Linux Foundation\n
+  Copyright (c) 2006 IBM Corporation\n
+  Copyright (c) 2000, 2006 Sun Microsystems, Inc.\n
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+   2. Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials
+      provided with the distribution.
+
+   3. Neither the name of the Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products
+      derived from this software without specific prior written
+      permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  This BSD License conforms to the Open Source Initiative "Simplified
+  BSD License" as published at:
+  http://www.opensource.org/licenses/bsd-license.php
+
+  %IAccessible2 is a trademark of the Linux Foundation. The %IAccessible2
+  mark may be used in accordance with the
+  <a href="http://www.linuxfoundation.org/collaborate/workgroups/accessibility/trademark-policy">
+  Linux Foundation Trademark Policy</a> to indicate compliance with the %IAccessible2 specification.
+
+ @page _generalInfo General Information
+  The following information is applicable to two or more interfaces.
+
+ @ref _errors\n
+ @ref _memory\n
+ &nbsp;&nbsp;@ref _arrayConsideration\n
+ @ref _indexes\n
+ @ref _enums\n
+ @ref _specialOffsets\n
+ @ref _dicoveringInterfaces\n
+ @ref _changingInterfaces\n
+ @ref _applicationInfo\n
+ @ref _childIDs\n
+ @ref _variants\n
+ @ref _iaaction-iahyperlink\n
+ @ref _trademark
+
+ @section _errors Error Handling
+  HRESULT values are defined by the Microsoft&reg; Win32&reg; API.  For more information, refer to
+  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa378137%28v=vs.85%29.aspx">
+  Interpreting HRESULT Values</a> in MSDN&reg;.
+
+  Note that the S_FALSE return value is considered a non-error value and the
+  SUCCEEDED macro will return TRUE.  S_FALSE is used when there is no failure
+  but there was nothing valid to return, e.g. in IAccessible2::attributes when
+  there are no attributes.  When S_FALSE is returned [out] pointer types should
+  be NULL and [out] longs should generally be 0, but sometimes -1 is used such
+  as IAccessible2::indexInParent, IAccessibleText::caretOffset, and
+  IAccessibleHypertext::hyperlinkIndex.
+
+  Note that for BSTR [out] variables common COM practice is that the server does
+  the SysAllocString and the client does the SysFreeString.  Also note that when
+  NULL is returned there is no need for the client to call SysFreeString.  Please
+  refer to the documentation for each method for more details regarding error handling.
+
+ @section _memory Memory Management
+  The following memory management issues should be considered:
+  @li Although [out] BSTR variables are declared by the client, their space is
+   allocated by the server.  They need to be freed with SysFreeString by the
+   client at end of life; the same is true when BSTRs are used in structs or
+   arrays which are passed to the server.
+  @li If there is no valid [out] BSTR to return, the server should return S_FALSE and
+   assign NULL to the output, e.g. *theOutBSTR = NULL;.
+  @li COM interfaces need to be referenced with AddRef when used and dereferenced
+   with Release at end of life.
+  @li Single [out] longs, HWNDs, booleans, and structs are declared by the caller
+   and passed by reference. The marshaller does all the memory management.
+
+  The following articles may be helpful for understanding memory management issues:
+  @li An article by Don Box in a
+   <a href="http://www.microsoft.com/msj/1196/activex1196.aspx">Q & A section</a>
+   of the November 1996 edition of the Microsoft Systems Journal.
+  @li A posting to a CodeGuru forum,
+   <a href="http://www.codeguru.com/forum/showthread.php?t=364511">Windows SDK
+   String: What are the rules for BSTR allocation and deallocation?</a>
+
+ @subsection _arrayConsideration Special Consideration when using Arrays
+  There are several methods which return arrays.  In the case of IAccessible2::relations
+  and IAccessibleRelation::targets the client must allocate and free the arrays.
+
+  For the remaining methods which return arrays, the server must allocate the array
+  and the client must free the array when no longer needed.  These methods are
+  IAccessible2::extendedStates, IAccessible2::localizedExtendedStates,
+  IAccessible2_2::relationTargetsOfType, IAccessibleAction::keyBinding,
+  IAccessibleHypertext2::hyperlinks, IAccessibleTable::selectedChildren,
+  IAccessibleTable::selectedColumns, IAccessibleTable::selectedRows,
+  IAccessibleTable2::selectedCells, IAccessibleTable2::selectedColumns,
+  IAccessibleTable2::selectedRows, IAccessibleTableCell::columnHeaderCells,
+  and IAccessibleTableCell::rowHeaderCells.
+  For those methods, the server must allocate both the top level array and any storage
+  associated with it, e.g. for BSTRs.  The server must allocate the arrays with
+  CoTaskMemAlloc and any BSTRs with SysAllocString.  The client must use CoTaskMemFree
+  to free the array and any BSTRs must be freed with SysFreeString.
+
+  Also, the IDL for IAccessible2::extendedStates, IAccessible2::localizedExtendedStates,
+  IAccessibleAction::keyBinding, IAccessibleTable::selectedChildren,
+  IAccessibleTable::selectedColumns, and IAccessibleTable::selectedRows includes an
+  extraneous [in] parameter for the caller to specify the max size of the array.
+  This parameter will be ignored by the COM server.
+
+ @section _indexes Zero and One Based Indexes
+  Unless otherwise specified all offsets and indexes are 0 based.
+
+ @section _enums Enums
+  Note that enums start at 0.
+
+ @section _specialOffsets Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods
+  IAccessibleText and IAccessibleEditableText can use one or more of the following
+  special offset values.  They are defined in the ::IA2TextSpecialOffsets enum.
+  @li Using ::IA2_TEXT_OFFSET_LENGTH (-1) as an offset in any of the IAccessibleText or
+   IAccessibleEditableText methods is the same as specifying the length of the string.
+  @li Using ::IA2_TEXT_OFFSET_CARET (-2) as an offset for IAccessibleText::textBeforeOffset,
+   IAccessibleText::textAtOffset, and IAccessibleText::textAfterOffset indicates that the
+   text related to the physical location of the caret should be used.  This is needed for
+   applications that consider the character offset of the end of one line (as reached by
+   pressing the End key) the same as the offset of the first character on the next line.
+   Since the same offset is associated with two different lines a special means is needed
+   to fetch text from the line where the caret is physically located.
+
+ @section _dicoveringInterfaces Discovery of Interfaces
+  In general AT (Assistive Technology) should try IAccessible2 interfaces, followed by using
+  the MSAA (Microsoft&reg; Active Accessibility&reg;) interfaces.  (In cases where the an application
+  is known to have custom interfaces which provide information not supplied by IAccessible2
+  or MSAA, then those custom interfaces can be used.)  The AT can then, by default, support
+  unknown IAccessible2/MSAA applications, without the application developers having to request
+  AT vendors for support on an individual application by application basis.
+
+  When you have a reference to an IAccessible and require a reference to an IAccessible2 use
+  QueryService as follows:
+  @code
+  // pAcc is a reference to the accessible object's IAccessible interface.
+  IServiceProvider *pService = NULL;
+  hr = pAcc->QueryInterface(IID_IServiceProvider, (void **)&pService);
+  if(SUCCEEDED(hr)) {
+    IAccessible2 *pIA2 = NULL;
+    hr = pService->QueryService(IID_IAccessible, IID_IAccessible2, (void**)&pIA2);
+    if (SUCCEEDED(hr) && pIA2) {
+      // The control supports IAccessible2.
+      // pIA2 is the reference to the accessible object's IAccessible2 interface.
+    }
+  }
+  @endcode
+
+  @section _changingInterfaces Changing between Accessible Interfaces
+  Note that developers must always implement MSAA's IAccessible and, if needed, some
+  of the interfaces in the set of IAccessible2 interfaces.  Although the IAccessible2
+  IDL is coded such that IAccessible2 is a subclass of MSAA's IAccessible, none of
+  MSAA's IAccessible methods are redefined by IAccessible2.
+
+  QueryService must be used to switch from a reference to an MSAA IAccessible interface
+  to another interface.  This has been
+  <a href="http://www.atia.org/files/public/Introducing_IAccessibleEx.doc">
+  documented</a> and the pertinent facts have been extracted below:
+
+  @par
+   Why use QueryService instead of just using QueryInterface to get IAccessibleEx
+   directly? The reason is that since MSAA 2.0, clients don't talk to a server's
+   IAccessible interface directly; instead they talk to an intermediate MSAA-provided
+   wrapper that calls through to the original IAccessible. This wrapper provides services
+   such as implementing IDispatch, supplying information from MSAA 2.0's Dynamic Annotation
+   service, and scaling locations when running on Windows Vista with DPI scaling enabled.
+   QueryService is the supported way to expose additional interfaces from an existing
+   IAccessible and was originally used by MSHTML to expose IHTMLElement objects corresponding
+   to IAccessibles. QueryService is often more convenient for servers to implement than
+   QueryInterface because it does not have the same requirements for preserving object
+   identity or symmetry/transitivity as QueryInterface, so QueryService allows servers to
+   easily implement the interface on the same object or a separate object. The latter is
+   often hard to do with QueryInterface unless the original object supports aggregation.
+
+  Two related references in MSDN&reg; are:
+  @li <a href="http://msdn.microsoft.com/en-us/library/ms696078(VS.85).aspx">
+  "Using QueryService to expose a native object model interface for an IAccessible object"</a>
+  @li <a href="http://msdn.microsoft.com/en-us/library/ms528415.aspx#acc_obj">
+  "Accessing the Internet Explorer Object Associated with an Accessible Object"</a>
+
+  Based on this information from Microsoft, QueryService must be used to switch back and forth
+  between a reference to an MSAA IAccessible interface and any of the IAccessible2 interfaces.
+
+  Regarding switching between any of the IAccessible2 interfaces, applications implementing
+  IAccessible2 should implement the IAccessible2 interfaces on a single object since ATs
+  will be using QueryInterface to switch between the IAccessilbe2 interfaces.  Implementing
+  the IAccessible2 interfaces on separate objects would require the use of QueryService.
+  There is one exception, IAccessibleApplication can be implemented on a separate object so
+  its common code doesn't have to be included in each accessible object.  ATs should use
+  QueryService to access IAccessibleApplication.
+
+ @section _applicationInfo Access to Information about the Application
+  Servers implementing IAccessible2 should provide access to the IAccessibleApplication
+  interface via QueryService from any object so that ATs can easily determine specific
+  information about the application such as its name or version.
+
+ @section _childIDs Child IDs
+  The IAccessible2 interfaces do not support child IDs, i.e. simple child elements.
+  Full accessible objects must be created for each object that supports IAccessible2.
+  Therefore MSAA's get_accChild should never return a child ID (other than CHILDID_SELF)
+  for an object that implements any of the IAccessible2 interfaces.
+
+  Microsoft's UI Automation specification has the same limitation and this was resolved
+  in the UI Automation Express specification by adding IAccessibleEx::GetObjectForChild
+  and IAccessibleEx::GetIAccessiblePair.  These methods allow mapping back and forth
+  between an IAccessibleEx and an {IAccessible, Child ID} pair.  A future version of
+  IAccessible2 may include similar methods to map back and forth between an IAccessible2
+  and an {IAccessible, Child ID} pair.
+
+ @section _variants VARIANTs
+  Some methods return a VARIANT.  Implementers need to make sure that the return type is
+  specified, i.e. VT_I4, VT_IDISPATCH, etc.  The methods that return VARIANTs are
+  IAccessibleHyperlink::anchor, IAccessibleHyperlink::anchorTarget, IAccessibleValue::currentValue,
+  IAccessibleValue::maximumValue, IAccessibleValue::minimumValue.
+
+ @section _iaaction-iahyperlink IAccessibleHyperlink as subclass of IAccessibleAction
+  In this version of the IDL, IAccessibleHyperlink is a subclass of IAccessibleAction.
+  However, there is no practical need for that inheritance and in some cases, such as
+  an image map of smart tags, it doesn't make sense because such an image map doesn't
+  have actionable objects; it's the secondary smart tags that are actionable.  As a
+  result, implementations should not rely on the inheritance as it may be removed in
+  a later version of the IDL.
+
+ @section _trademark Trademark Attribution
+  The names of actual companies and products mentioned herein may be the trademarks of
+  their respective owners.  In particular, Active Accessibility, Microsoft, MSDN, and Win32
+  are trademarks of the Microsoft group of companies in the U.S.A. and/or other countries.
+
+**/
+
+/** A structure defining the locale of an accessible object.
+
+IAccessible2::locale returns this struct.
+*/
+typedef struct IA2Locale {
+  BSTR language; ///< ISO 639-1 Alpha-2 two character language code
+  BSTR country;  ///< ISO 3166-1 Alpha-2 two character country code
+  BSTR variant;  ///< Application specific variant of the locale
+} IA2Locale;
+
+/** @brief This interface exposes the primary set of information about an
+ IAccessible2 enabled accessible object.
+
+ This interface must always be provided for objects that support some
+ portion of the collection of the %IAccessible2 interfaces.
+
+ Please refer to @ref _changingInterfaces "Changing between Accessible Interfaces"
+ for special considerations related to use of the MSAA IAccessible interface and
+ the set of %IAccessible2 interfaces.
+ */
+[object, oleautomation, uuid(E89F726E-C4F4-4c19-BB19-B647D7FA8478)]
+interface IAccessible2 : IAccessible
+{
+
+  /** @brief Returns the number of accessible relations for this object.
+   @param [out] nRelations
+   @retval S_OK
+  */
+  [propget] HRESULT nRelations
+    (
+     [out, retval] long *nRelations
+    );
+
+  /** @brief Returns one accessible relation for this object.
+   @param [in] relationIndex
+     0 based
+   @param [out] relation
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT relation
+    (
+     [in] long relationIndex,
+     [out, retval] IAccessibleRelation **relation
+    );
+
+  /** @brief Returns multiple accessible relations for this object.
+   @param [in] maxRelations
+     maximum size of the array allocated by the client
+   @param [out] relations
+    The array of accessible relation objects.  Note that this array is to be
+	allocated by the client and freed when no longer needed.  Refer to @ref
+	_arrayConsideration "Special Consideration when using Arrays" for more details.
+   @param [out] nRelations
+    actual number of relations in the returned array (not more than maxRelations)
+   @retval S_OK
+   @retval S_FALSE if there are no relations, nRelations is set to 0
+   @note As a performant alternative, client code should consider using IAccessible2_2::relationTargetsOfType.
+  */
+  [propget] HRESULT relations
+    (
+     [in] long maxRelations,
+     [out, size_is(maxRelations), length_is(*nRelations)]
+       IAccessibleRelation **relations,
+     [out, retval] long *nRelations
+    );
+
+  /** @brief Returns the role of an %IAccessible2 object.
+   @param [out] role
+    The role of an %IAccessible2 object.
+   @retval S_OK
+   @note
+   @li For convenience MSAA roles are also passed through this method so the
+    AT doesn't have to also fetch roles through MSAA's get_accRole.
+   @li %IAccessible2 roles should not be passed through MSAA's get_accRole.
+   @li For compatibility with non IAccessible2 enabled ATs, IAccessible2
+    applications should also add support to get_accRole to return the closest
+	MSAA role or ROLE_SYSTEM_CLIENT (the MSAA defined default role) if there
+	is not a good match.
+   @li This method is missing a [propget] prefix in the IDL.  The result is the
+    method is named role in generated C++ code instead of get_role.
+  */
+  HRESULT role
+    (
+     [out, retval] long *role
+    );
+
+  /** @brief Makes an object visible on the screen.
+   @param [in] scrollType
+    Defines where the object should be placed on the screen.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT scrollTo
+    (
+     [in] enum IA2ScrollType scrollType
+    );
+
+  /** @brief Moves the top left of an object to a specified location.
+
+   @param [in] coordinateType
+    Specifies whether the coordinates are relative to the screen or the parent object.
+   @param [in] x
+    Defines the x coordinate.
+   @param [in] y
+    Defines the y coordinate.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT scrollToPoint
+    (
+     [in] enum IA2CoordinateType coordinateType,
+	 [in] long x,
+	 [in] long y
+    );
+
+  /** @brief Returns grouping information.
+
+   Used for tree items, list items, tab panel labels, radio buttons, etc.
+   Also used for collections of non-text objects.
+
+   @param [out] groupLevel
+    1 based, 0 indicates that this value is not applicable
+   @param [out] similarItemsInGroup
+    1 based, 0 indicates that this value is not applicable
+   @param [out] positionInGroup
+    1 based, 0 indicates that this value is not applicable. This is an index
+    into the objects in the current group, not an index into all the objects
+    at the same group level.
+   @retval S_OK if at least one value is valid
+   @retval S_FALSE if no values are valid, [out] values are 0s
+   @note This method is meant to describe the nature of an object's containment
+    structure.  It's exposed by trees, tree grids, nested lists, nested menus,
+    but not headings, which uses the level object attribute.  It is also exposed
+    by radio buttons (with groupLevel == 0).
+   @note This is normally not implemented on a combo box to describe the nature
+    of its contents.  Normally an AT will get that information from its child list
+    object.  However, in some cases when non-edit combo boxes are not able to be structured
+    such that the list is a child of the combo box, this method is implemented on
+    the combo box itself. ATs can use this interface if a child list is not found.
+	*/
+  [propget] HRESULT groupPosition
+    (
+     [out] long *groupLevel,
+     [out] long *similarItemsInGroup,
+     [out, retval] long *positionInGroup
+    );
+
+  /** @brief Returns the bit strip containing any IAccessible2 states.
+
+   The IAccessible2 states are in addition to the MSAA states and are defined in
+   the IA2States enum.
+
+   @param [out] states
+   @retval S_OK
+  */
+  [propget] HRESULT states
+    (
+	 [out, retval] AccessibleStates *states
+    );
+
+  /** @brief Returns the extended role.
+
+   An extended role is a role which is dynamically generated by the application.
+   It is not predefined by the %IAccessible2 specification.
+
+   @param [out] extendedRole
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT extendedRole
+    (
+	 [out, retval] BSTR *extendedRole
+    );
+
+  /** @brief Returns the localized extended role.
+   @param [out] localizedExtendedRole
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT localizedExtendedRole
+    (
+	 [out, retval] BSTR *localizedExtendedRole
+    );
+
+  /** @brief Returns the number of extended states.
+   @param [out] nExtendedStates
+   @retval S_OK
+  */
+  [propget] HRESULT nExtendedStates
+    (
+     [out, retval] long *nExtendedStates
+    );
+
+  /** @brief Returns the extended states (array of strings).
+
+   An extended state is a state which is dynamically generated by the application.
+   It is not predefined by the %IAccessible2 specification.
+
+   @param [in] maxExtendedStates
+    This parameter is ignored. Refer to @ref _arrayConsideration
+	"Special Consideration when using Arrays" for more details.
+   @param [out] extendedStates
+    This array is allocated by the server.  The client must free it with CoTaskMemFree.
+   @param [out] nExtendedStates
+    The number of extended states returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are no states, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT extendedStates
+    (
+     [in] long maxExtendedStates,
+     [out, size_is(,maxExtendedStates), length_is(,*nExtendedStates)] BSTR **extendedStates,
+     [out, retval] long *nExtendedStates
+    );
+
+  /** @brief Returns the localized extended states (array of strings).
+
+   @param [in] maxLocalizedExtendedStates
+    This parameter is ignored. Refer to @ref _arrayConsideration
+	"Special Consideration when using Arrays" for more details.
+   @param [out] localizedExtendedStates
+    This array is allocated by the server.  The client must free it with CoTaskMemFree.
+   @param [out] nLocalizedExtendedStates
+    The number of localized extended states returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are no states, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT localizedExtendedStates
+    (
+     [in] long maxLocalizedExtendedStates,
+     [out, size_is(,maxLocalizedExtendedStates), length_is(,*nLocalizedExtendedStates)] BSTR **localizedExtendedStates,
+     [out, retval] long *nLocalizedExtendedStates
+    );
+
+  /** @brief Returns the unique ID.
+
+   The uniqueID is an identifier for this object, is unique within the
+   current window, and remains the same for the lifetime of the accessible
+   object.
+
+   The uniqueID is not related to:
+   - the MSAA objectID which is used by the server to disambiguate between
+   IAccessibles per HWND or
+   - the MSAA childID which is used to disambiguate between children being
+   managed by an IAccessible.
+
+   This value is provided so the AT can have access to a unique runtime persistent
+   identifier even when not handling an event for the object.
+
+   An example of when this value is useful is if the AT wants to build a cache.
+   The AT could cache the uniqueIDs in addition to other data being cached.
+   When an event is fired the AT could map the uniqueID to its internal model.
+   Thus, if there's a REORDER/SHOW/HIDE event the AT knows which part of the
+   internal structure has been invalidated and can refetch just that part.
+
+   This value can also be used by an AT to determine when the current control
+   has changed. If the role is the same for two controls that are adjacent in
+   the tab order, this can be used to detect the new control.
+
+   Another use of this value by an AT is to identify when a grouping object has
+   changed, e.g. when moving from a radio button in one group to a radio button in a
+   different group.
+
+   One means of implementing this would be to create a factory with a 32 bit number
+   generator and a reuse pool.  The number generator would emit numbers starting
+   at 1.  Each time an object's life cycle ended, its number would be saved into a
+   reuse pool.  The number generator would be used whenever the reuse pool was empty.
+
+   Another way to create a unique ID is to generate it from a pointer value, e.g. an
+   object's address. That would be unique because no two active objects can use the
+   same allocated memory space.
+
+   @param [out] uniqueID
+   @retval S_OK
+  */
+  [propget] HRESULT uniqueID
+    (
+     [out, retval] long *uniqueID
+    );
+
+  /** @brief Returns the window handle for the parent window which contains this object.
+
+   This is the same window handle which will be passed for any events that occur on the
+   object, but is cached in the accessible object for use when it would be helpful to
+   access the window handle in cases where an event isn't fired on this object.
+
+   A use case is when a screen reader is grabbing an entire web page on a page load.
+   Without the availability of windowHandle, the AT would have to get the window handle
+   by using WindowFromAccessibleObject on each IAccessible, which is slow because it's
+   implemented by oleacc.dll as a loop which crawls up the ancestor chain and looks for
+   a ROLE_WINDOW object, mapping that back to a window handle.
+
+   @param [out] windowHandle
+   @retval S_OK
+  */
+  [propget] HRESULT windowHandle
+    (
+     [out, retval] HWND *windowHandle
+    );
+
+  /** @brief Returns the index of this object in its parent object.
+   @param [out] indexInParent
+     0 based; -1 indicates there is no parent; the upper bound is the value
+	 returned by the parent's IAccessible::get_accChildCount.
+   @retval S_OK
+   @retval S_FALSE if no parent, [out] value is -1
+  */
+  [propget] HRESULT indexInParent
+    (
+     [out, retval] long *indexInParent
+    );
+
+  /** @brief Returns the IA2Locale of the accessible object.
+   @param [out] locale
+   @retval S_OK
+  */
+  [propget] HRESULT locale
+    (
+     [out, retval] IA2Locale *locale
+    );
+
+  /** @brief Returns the attributes specific to this object, such as a cell's formula.
+   @param [out] attributes
+   @retval S_OK
+   @retval S_FALSE returned if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT attributes
+    (
+     [out, retval] BSTR *attributes
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (Accessible2_2.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2013 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface exposes the primary set of information about an
+ IAccessible2 enabled accessible object.
+
+ This interface must always be provided for objects that support some
+ portion of the collection of the %IAccessible2 interfaces.
+
+ Please refer to @ref _changingInterfaces "Changing between Accessible Interfaces"
+ for special considerations related to use of the MSAA IAccessible interface and
+ the set of %IAccessible2 interfaces.
+ */
+[object, uuid(6C9430E9-299D-4E6F-BD01-A82A1E88D3FF)]
+interface IAccessible2_2 : IAccessible2
+{
+  /** @brief Returns the attribute value of a specified attribute specific to this object.
+   @param [in] name
+   @param [out] attribute
+   @retval S_OK
+   @retval S_FALSE returned if there is nothing to return, [out] value is NULL.
+   @retval E_INVALIDARG if bad [in] passed.
+   @note The output value is a VARIANT.  Typically it will be a VT_BSTR, but there
+     are some cases where it will be a VT_I4 or VT_BOOL.  Refer to the <a href=
+     "http://www.linuxfoundation.org/collaborate/workgroups/accessibility/iaccessible2/objectattributesIAccessible2">
+     Object Attributes specification</a> for more information.
+  */
+  [propget] HRESULT attribute
+    (
+     [in] BSTR name,
+     [out, retval] VARIANT *attribute
+    );
+
+  /** @brief Returns the deepest hypertext accessible in the subtree of this object, and the caret offset within it.
+   @param [out] accessible
+   @param [out] caretOffset
+   @retval S_OK
+   @retval S_FALSE returned if there is no caret in any of the objects in the subtree, [out] accessible is NULL and [out] caretOffset is -1.
+  */
+  [propget] HRESULT accessibleWithCaret
+    (
+     [out] IUnknown **accessible,
+     [out, retval] long *caretOffset
+    );
+
+  /** @brief Returns relation targets for a specified target type.
+   @param [in] type
+    The requested @ref grpRelations "relation type".
+   @param [in] maxTargets
+    The number of targets requested.  0 indicates that all targets should be returned.
+   @param [out] targets
+    This array is allocated by the server.  The client must free it with CoTaskMemFree.
+   @param [out] nTargets
+    The number of targets returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are no targets, [out] values are NULL and 0 respectively.
+   @retval E_INVALIDARG if bad [in] passed.
+  */
+  [propget] HRESULT relationTargetsOfType
+    (
+     [in] BSTR type,
+     [in] long maxTargets,
+     [out, size_is(,*nTargets)] IUnknown ***targets,
+     [out, retval] long *nTargets
+    );
+
+}
+
+/**
+ * This structure represents a directional range of the content. It is defined
+ * by two points in the content, where each one is defined by an accessible
+ * object and an offset relative to it. A typical case of a range point is
+ * a text accessible and text offset within it.
+ *
+ * The "anchor" is one point of the range and typically remains constant.
+ * The other point is the "active" point, which typically corresponds to
+ * the user's focus or point of interest. The user moves the active point to
+ * expand or collapse the range. In most cases, anchor is the start of the range
+ * and active is the end. However, in case of selection, when selecting
+ * backwards (e.g. pressing shift+left arrow in a text field), the start of
+ * the range is the active point, as the user moves this to manipulate
+ * the selection.
+ */
+typedef struct IA2Range {
+  IUnknown* anchor;
+  long anchorOffset;
+  IUnknown* active;
+  long activeOffset;
+} IA2Range;
+
+/**
+ * @brief This interface is an extension of IAccessible2_2 and IAccessible2
+ * interfaces.
+ */
+[object, uuid(5BE18059-762E-4E73-9476-ABA294FED411)]
+interface IAccessible2_3 : IAccessible2_2
+{
+  /**
+   * @brief Returns an array of ranges for selections within the accessible.
+   * @param [out] ranges
+     The array of selection ranges, allocated by the server. The client must
+     free it with CoTaskMemFree.
+   * @param [out] nRanges
+     the array length
+   * @retval S_OK
+   * @retval S_FALSE returned if there is no selection within the accessible
+  */
+  [propget] HRESULT selectionRanges
+    (
+      [out, size_is(,*nRanges)] IA2Range **ranges,
+      [out, retval] long *nRanges
+    );
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleComponent.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** A value specifying a color in ARGB format, where each 8 bit color component
+specifies alpha, red, green, and blue respectively.  The alpha value is optional.
+*/
+typedef long IA2Color;
+
+/** @brief This interface is implemented by any object that can be rendered
+ on the screen.
+
+ This interface provides the standard mechanism for an assistive technology
+  to retrieve information concerning the graphical representation of an object.
+  Coordinates used by the functions of this interface are specified in
+  different coordinate systems.  Their scale is the same and is equal to
+  that of the screen coordinate system.  In other words all coordinates
+  are measured in pixels.  They differ in their respective origin:
+  <ul>
+   <li>The screen coordinate system has its origin in the upper left
+    corner of the current screen.</li>
+   <li>The origin of the parent coordinate system is the upper left corner
+    of the parent's bounding box.  With no parent the screen coordinate
+    system is used instead.</li>
+  </ul>
+*/
+[object, uuid(1546D4B0-4C98-4bda-89AE-9A64748BDDE4)]
+interface IAccessibleComponent : IUnknown
+{
+
+  /** @brief Returns the location of the upper left corner of the object's
+    bounding box relative to the immediate parent object.
+
+	The coordinates of the bounding box are given relative to the parent's
+	coordinate system. The coordinates of the returned position are relative
+	to this object's parent or relative to the screen on which this object
+    is rendered if it has no parent. If the object is not on any screen
+    the returned position is (0,0).
+
+   @param [out] x
+   @param [out] y
+   @retval S_OK
+  */
+  [propget] HRESULT locationInParent
+    (
+	 [out] long *x,
+     [out, retval] long *y
+    );
+
+  /** @brief Returns the foreground color of this object.
+   @param [out] foreground
+    The returned color is the foreground color of this object or, if
+    that is not supported, the default foreground color.
+   @retval S_OK
+  */
+  [propget] HRESULT foreground
+    (
+     [out, retval] IA2Color *foreground
+    );
+
+   /** @brief Returns the background color of this object.
+    @param [out] background
+     The returned color is the background color of this object or, if
+     that is not supported, the default background color.
+    @retval S_OK
+   */
+  [propget] HRESULT background
+    (
+     [out, retval] IA2Color *background
+    );
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleValue.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface gives access to a single numerical value.
+
+ The %IAccessibleValue interface represents a single numerical value and should
+  be implemented by any class that supports numerical value like progress bars
+  and spin boxes.  This interface lets you access the value and its upper and
+  lower bounds.
+*/
+[object, uuid(35855B5B-C566-4fd0-A7B1-E65465600394)]
+interface IAccessibleValue : IUnknown
+{
+
+  /** @brief Returns the value of this object as a number.
+
+   The exact return type is implementation dependent.  Typical types are long and
+    double.
+   @param [out] currentValue
+    Returns the current value represented by this object.  See the section about
+	@ref _variants "VARIANTs" for additional information.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is a VARIANT with vt = VT_EMPTY
+  */
+  [propget] HRESULT currentValue
+    (
+     [out, retval] VARIANT *currentValue
+    );
+
+  /** @brief Sets the value of this object to the given number.
+
+   The argument is clipped to the valid interval whose upper and lower
+    bounds are returned by the methods IAccessibleValue::maximumValue and
+	IAccessibleValue::minimumValue, i.e. if it is 	lower than the minimum
+	value the new value will be the minimum and if it is greater than the
+	maximum then the new value will be the maximum.
+
+   @param [in] value
+    The new value represented by this object.  The set of admissible types for
+    this argument is implementation dependent.
+   @retval S_OK
+  */
+  HRESULT setCurrentValue
+    (
+     [in] VARIANT value
+    );
+
+  /** @brief Returns the maximal value that can be represented by this object.
+
+   The type of the returned value is implementation dependent.  It does not have
+    to be the same type as that returned by method IAccessibleValue::currentValue.
+
+   @param [out] maximumValue
+    Returns the maximal value in an implementation dependent type. If this object
+    has no upper bound then an empty object is returned.  See the section about
+	@ref _variants "VARIANTs" for additional information.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is a VARIANT with vt = VT_EMPTY
+  */
+  [propget] HRESULT maximumValue
+    (
+     [out, retval] VARIANT *maximumValue
+    );
+
+  /** @brief Returns the minimal value that can be represented by this object.
+
+   The type of the returned value is implementation dependent.  It does not have
+    to be the same type as that returned by method IAccessibleValue::currentValue.
+
+   @param [out] minimumValue
+    Returns the minimal value in an implementation dependent type. If this object
+    has no lower bound then an empty object is returned.  See the section about
+	@ref _variants "VARIANTs" for additional information.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is a VARIANT with vt = VT_EMPTY
+  */
+  [propget] HRESULT minimumValue
+    (
+     [out, retval] VARIANT *minimumValue
+    );
+
+};
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleText.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2013 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** A structure containing a substring and the start and end offsets in the enclosing string.
+
+ IAccessibleText::newText and IAccessibleText::oldText return this struct.
+*/
+typedef struct IA2TextSegment {
+  BSTR text;	///< A copy of a segment of text taken from an enclosing paragraph.
+  long start;	///< Index of the first character of the segment in the enclosing text.
+  long end;		///< Index of the character following the last character of the segment in the enclosing text.
+} IA2TextSegment;
+
+/** This enum defines values which specify a text boundary type.
+
+ IA2_TEXT_BOUNDARY_SENTENCE is optional.  When a method doesn't implement this
+ method it must return S_FALSE.  Typically this feature would not be implemented
+ by an application.  However, if the application developer was not satisfied with
+ how screen readers have handled the reading of sentences this boundary type
+ could be implemented and screen readers could use the application's version of a
+ sentence rather than the screen reader's.
+
+ The rest of the boundary types must be supported.
+
+ This enum is used in IAccessibleText::textBeforeOffset, IAccessibleText::textAtOffset,
+ and IAccessibleText::textAfterOffset.
+*/
+
+enum IA2TextBoundaryType {
+  /** Typically, a single character is returned. In some cases more than one
+   character is returned, for example, when a document contains field data such
+   as a field containing a date, time, or footnote reference. In this case
+   the caret can move over several characters in one movement of the caret.
+   Note, that after the caret moves, the caret offset changes by the number of
+  characters in the field, e.g. by 8 characters in the following date: 03/26/07.
+  */
+  IA2_TEXT_BOUNDARY_CHAR,
+
+  /** The range provided matches the range observed when the application
+   processes the Ctrl + left arrow and Ctrl + right arrow key sequences.
+   Typically this is from the start of one word to the start of the next, but
+   various applications are inconsistent in the handling of the end of a line.
+  */
+  IA2_TEXT_BOUNDARY_WORD,
+
+  /** Range is from start of one sentence to the start of another sentence.
+  */
+  IA2_TEXT_BOUNDARY_SENTENCE,
+
+  /** Range is from start of one paragraph to the start of another paragraph.
+  */
+  IA2_TEXT_BOUNDARY_PARAGRAPH,
+
+  /** Range is from start of one line to the start of another line. This often
+   means that an end-of-line character will appear at the end of the range.
+   However in the case of some applications an end-of-line character indicates
+   the end of a paragraph and the lines composing the paragraph, other than
+   the last line, do not contain an end of line character.
+  */
+  IA2_TEXT_BOUNDARY_LINE,
+
+  /** <b>Deprecated.</b> Using this value will cause all text to be returned.
+   Note: IAccessibleText::text should be used instead.
+  */
+  IA2_TEXT_BOUNDARY_ALL
+};
+
+/** @brief This interface gives read-only access to text.
+
+ The %IAccessibleText interface should be implemented by all components
+  that present textual information on the display like  buttons,
+  text entry fields, or text portions of the document window.  The interface
+  provides access to the text's content, attributes, and spatial location.
+  However, text can not be modified with this interface.  That is the task
+  of the IAccessibleEditableText interface.
+
+ The text length, i.e. the number of characters in the text, is
+  returned by IAccessibleText::nCharacters. All methods that operate
+  on particular characters (e.g. IAccessibleText::textAtOffset) use character
+  indices from 0 to length-1. All methods that operate on character positions
+  (e.g. IAccessibleText::text) use indices from 0 to length.
+
+ Please note that accessible text does not necessarily support selection.
+  In this case it should behave as if there where no selection.  An empty
+  selection is used for example to express the current cursor position.
+
+ Refer to @ref _specialOffsets
+  "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+  for information about special offsets that can be used in %IAccessibleText methods.
+
+ E_FAIL is returned in the following cases
+ @li endOffset < startOffset
+ @li endoffset > length
+*/
+[object, uuid(24FD2FFB-3AAD-4a08-8335-A3AD89C0FB4B)]
+interface IAccessibleText : IUnknown
+{
+
+  /** @brief Adds a text selection
+   @param [in] startOffset
+    Starting offset ( 0 based).
+   @param [in] endOffset
+    Offset of first character after new selection (0 based).
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note  Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+  */
+  HRESULT addSelection
+    (
+     [in] long startOffset,
+     [in] long endOffset
+    );
+
+  /** @brief Returns text attributes.
+   @param [in] offset
+    Text offset (0 based).  Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @param [out] startOffset
+    The starting offset of the character range over which all text attributes match
+    those of offset. (0 based)
+   @param [out] endOffset
+    The offset of the first character past the character range over which all text
+    attributes match those of offset. (0 based)
+   @param [out] textAttributes
+    A string of attributes describing the text.  The attributes are described in the
+    <a href="http://www.linuxfoundation.org/en/Accessibility/IAccessible2/TextAttributes">
+    text attributes specification</a> on the %IAccessible2 web site.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] values are 0s and NULL respectively
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT attributes
+    (
+     [in] long offset,
+     [out] long *startOffset,
+     [out] long *endOffset,
+     [out, retval] BSTR *textAttributes
+    );
+
+  /** @brief Returns the position of the caret.
+
+   Returns the 0-based offset of the caret within the text.  If the text is
+   implemented as a tree of text objects with embed characters in higher levels
+   representing substrings of child text objects and the caret is in one of the
+   child text objects, then the offset in the higher level text object would be
+   at the embed character representing child text object that contains the caret.
+
+   For example, if the string "one two three" is implemented as a two text objects,
+   with a top level text object containing an embed character "one ? three" and a
+   child text object containing "two" and if the caret is in the descendant object
+   just before the 'o' in "two", then:
+   <ul>
+   <li>the caretOffset for the "one ? three" object would be 4, matching the embed character</li>
+   <li>the caretOffset for "two" would be 2, matching the "o"</li>
+   </ul>
+   The caret position/offset is that of the character logically following it, e.g.
+   to the right of it in a left to right language, or to the left of it in a right
+   to left language.
+   @param [out] offset
+    The returned offset is relative to the text represented by this object.
+   @retval S_OK
+   @retval S_FALSE if the caret is not currently active on this object, i.e. the
+    caret is located on some other object.  The returned offset value will be -1.
+   @note S_FALSE (and an offset of -1) will not be returned if the caret is somewhere
+   in the text object or one of its descendants.
+  */
+  [propget] HRESULT caretOffset
+    (
+     [out, retval] long *offset
+    );
+
+
+  /** @brief Returns the bounding box of the specified position.
+
+   The virtual character after the last character of the represented
+    text, i.e. the one at position length is a special case. It represents the
+    current input position and will therefore typically be queried by AT more
+    often than other positions.  Because it does not represent an existing character
+    its bounding box is defined in relation to preceding characters.  It should be
+    roughly equivalent to the bounding box of some character when inserted at the
+    end of the text.  Its height typically being the maximal height of all the
+    characters in the text or the height of the preceding character, its width being
+    at least one pixel so that the bounding box is not degenerate.
+
+   Note that the index 'length' is not always valid.  Whether it is or not is
+    implementation dependent.  It typically is when text is editable or otherwise
+    when on the screen the caret can be placed behind the text.  You can be sure
+    that the index is valid after you have received a ::IA2_EVENT_TEXT_CARET_MOVED
+    event for this index.
+   @param [in] offset
+    Index of the character for which to return its bounding box. The valid range
+    is 0..length.  Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @param [in] coordType
+    Specifies if the coordinates are relative to the screen or to the parent window.
+   @param [out] x
+    X coordinate of the top left corner of the bounding box of the referenced character.
+   @param [out] y
+    Y coordinate of the top left corner of the bounding box of the referenced character.
+   @param [out] width
+    Width of the bounding box of the referenced character.
+   @param [out] height
+    Height of the bounding box of the referenced character.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT characterExtents
+    (
+     [in] long offset,
+     [in] enum IA2CoordinateType coordType,
+     [out] long *x,
+     [out] long *y,
+     [out] long *width,
+     [out, retval] long *height
+    );
+
+
+  /** @brief Returns the number of active non-contiguous selections
+   @param [out] nSelections
+   @retval S_OK
+  */
+  [propget] HRESULT nSelections
+    (
+     [out, retval] long *nSelections
+    );
+
+  /** @brief Returns the text position for the specified screen position.
+
+   Given a point return the zero-based index of the character under that
+   point.  The same functionality could be achieved by using the bounding
+   boxes for each character as returned by IAccessibleText::characterExtents.
+   The method IAccessibleText::offsetAtPoint, however, can be implemented
+   more efficiently.
+
+   @param [in] x
+    The position's x value for which to look up the index of the character that
+    is rendered on to the display at that point.
+   @param [in] y
+    The position's y value for which to look up the index of the character that
+    is rendered on to the display at that point.
+   @param [in] coordType
+    Screen coordinates or window coordinates.
+   @param [out] offset
+    Index of the character under the given point or -1 if the point
+    is invalid or there is no character under the point.
+   @retval S_OK
+   @retval S_FALSE if nothing to return, [out] value is -1
+
+   @retval E_INVALIDARG if bad [in] passed
+    */
+  [propget] HRESULT offsetAtPoint
+    (
+     [in] long x,
+     [in] long y,
+     [in] enum IA2CoordinateType coordType,
+     [out, retval] long *offset
+    );
+
+  /** @brief Returns the character offsets of Nth active text selection
+
+   Returns the 0-based starting and ending offsets of the Nth selection.  If the
+   text is implemented as a tree of text objects with embed characters in higher
+   levels representing substrings of child text objects, consider the following.
+   If the starting selection offset is in one of the child text objects, then the
+   starting offset in the higher level text object would be at the embed character
+   representing the child text object that contains the starting selection offset.
+   If the ending selection offset is in one of the child text objects, then the
+   ending offset in the higher level text object would be just after the embed
+   character representing the child text object that contains the ending selection
+   offset.
+
+   For example, if the string "one two three" is implemented as a two text objects,
+   with a top level text object containing an embed character "one ? three" and a
+   child text object containing "two" and if the selection is the string "two" then:
+   <ul>
+   <li>the startOffset for the "one ? three" object would be 4, matching the embed character and the endOffset would be 5.</li>
+   <li>the startOffset for the "two" object would be 0, and the endOffset would be 3</li>
+   </ul>
+   Selection offsets are that of the character logically following it, e.g.
+   to the right of it in a left to right language or to the left of it in a right to left language.
+   @param [in] selectionIndex
+    Index of selection (0 based).
+   @param [out] startOffset
+    0 based offset of first selected character
+   @param [out] endOffset
+    0 based offset of one past the last selected character.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT selection
+    (
+     [in] long selectionIndex,
+     [out] long *startOffset,
+     [out, retval] long *endOffset
+    );
+
+  /** @brief Returns the substring between the two given indices.
+
+   The substring starts with the character at startOffset (inclusive) and up to
+    the character at endOffset (exclusive), if startOffset is less or equal
+    endOffset.  If endOffset is lower than startOffset, the result is the same
+    as a call with the two arguments being exchanged.
+
+   The whole text can be requested by passing the indices zero and
+    IAccessibleText::nCharacters. If both indices have the same value, an empty
+    string is returned.
+   @param [in] startOffset
+    Index of the first character to include in the returned string. The valid range
+    is 0..length.
+   @param [in] endOffset
+    Index of the last character to exclude in the returned string. The valid range
+    is 0..length.
+   @param [out] text
+    Returns the substring starting with the character at startOffset (inclusive)
+    and up to the character at endOffset (exclusive), if startOffset is less than
+    or equal to endOffset.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note
+   @li The returned string may be longer than endOffset-startOffset bytes if text
+    contains multi-byte characters.
+   @li Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+  */
+  [propget] HRESULT text
+    (
+     [in] long startOffset,
+     [in] long endOffset,
+     [out, retval] BSTR *text
+    );
+
+  /** @brief Returns a text portion before the given position.
+
+   Returns the substring of the specified text type that is located before the
+    given character and does not include it. The result of this method should be
+    same as a result for IAccessibleText::textAtOffset with a suitably decreased
+    index value.
+
+   For example, if text type is ::IA2_TEXT_BOUNDARY_WORD, then the complete
+    word that is closest to and located before offset is returned.
+
+   If the index is valid, but no text is found, S_FALSE is returned along with out
+    values of 0, 0, and a NULL pointer.  This would happen for boundary types other
+    than character when the text consists entirely of whitespace.
+
+   @param [in] offset
+    Index of the character for which to return the text part before it.  The index
+    character will not be part of the returned string. The valid range is 0..length.
+    Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @param [in] boundaryType
+    The type of the text portion to return.  See ::IA2TextBoundaryType for the
+    complete list.
+   @param [out] startOffset
+    0 based offset of first character.
+   @param [out] endOffset
+    0 based offset of one past the last character.
+   @param [out] text
+    Returns the requested text portion.  This portion may be empty or invalid when
+    no appropriate text portion is found or text type is invalid.
+   @retval S_OK
+   @retval S_FALSE if the requested boundary type is not implemented, such as
+    ::IA2_TEXT_BOUNDARY_SENTENCE, or if there is nothing to return;
+    [out] values are 0s and NULL respectively
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT textBeforeOffset
+    (
+     [in] long offset,
+     [in] enum IA2TextBoundaryType boundaryType,
+     [out] long *startOffset,
+     [out] long *endOffset,
+     [out, retval] BSTR *text
+    );
+
+  /** @brief Returns a text portion after the given position.
+
+   Returns the substring of the specified text type that is located after the
+    given character and does not include it. The result of this method should be
+    same as a result for IAccessibleText::textAtOffset with a suitably increased
+    index value.
+
+   For example, if text type is ::IA2_TEXT_BOUNDARY_WORD, then the complete
+    word that is closest to and located after offset is returned.
+
+   If the index is valid, but no text is found, S_FALSE is returned along with out
+    values of 0, 0, and a NULL pointer.  This would happen for boundary types other
+    than character when the text consists entirely of whitespace.
+
+   @param [in] offset
+    Index of the character for which to return the text part after it.  The index
+    character will not be part of the returned string. The valid range is 0..length.
+    Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @param [in] boundaryType
+    The type of the text portion to return.  See ::IA2TextBoundaryType for the complete
+    list.
+   @param [out] startOffset
+    0 based offset of first character.
+   @param [out] endOffset
+    0 based offset of one past the last character.
+   @param [out] text
+    Returns the requested text portion.  This portion may be empty or invalid when
+    no appropriate text portion is found or text type is invalid.
+   @retval S_OK
+   @retval S_FALSE if the requested boundary type is not implemented, such as
+    ::IA2_TEXT_BOUNDARY_SENTENCE, or if there is nothing to return;
+    [out] values are 0s and NULL respectively
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT textAfterOffset
+    (
+     [in] long offset,
+     [in] enum IA2TextBoundaryType boundaryType,
+     [out] long *startOffset,
+     [out] long *endOffset,
+     [out, retval] BSTR *text
+    );
+
+  /** @brief Returns a text portion that spans the given position.
+
+   Returns the substring defined by the specified boundary type at the specified
+    offset.  Refer to IA2TextBoundaryType for more details.
+
+   For the word boundary type the returned string will contain the word at the
+    offset if the offset is inside a word and will contain the word before the
+    offset if the offset is not inside a word.  All offsets from the first to the
+    last characters of a word are considered inside the word.  Boundary types of
+    sentence and paragraph should exhibit similar behavior.
+
+   If the index is valid, but no text is found, S_FALSE is returned along with out
+    values of 0, 0, and a NULL pointer.  This would happen for boundary types other
+    than character when the text consists entirely of whitespace.
+
+   @param [in] offset
+    Index of the character for which to return the text part it belongs to.  The valid
+    range is 0..length.
+    Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @param [in] boundaryType
+    The type of the text portion to return.  See ::IA2TextBoundaryType for the complete
+    list.
+   @param [out] startOffset
+    0 based offset of first character.
+   @param [out] endOffset
+    0 based offset of one past the last character.
+   @param [out] text
+    Returns the requested text portion.  This portion may be empty or invalid when
+    no appropriate text portion is found or text type is invalid.
+   @retval S_OK
+   @retval S_FALSE if the requested boundary type is not implemented, such as
+    ::IA2_TEXT_BOUNDARY_SENTENCE, or if there is nothing to return;
+    [out] values are 0s and NULL respectively
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT textAtOffset
+    (
+     [in] long offset,
+     [in] enum IA2TextBoundaryType boundaryType,
+     [out] long *startOffset,
+     [out] long *endOffset,
+     [out, retval] BSTR *text
+    );
+
+  /** @brief Unselects a range of text.
+   @param [in] selectionIndex
+    Index of selection to remove (0 based).
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT removeSelection
+    (
+     [in] long selectionIndex
+    );
+
+  /** @brief Sets the position of the caret.
+
+   The caret position/offset is that of the character logically following it,
+   e.g. to the right of it in a left to right language.
+
+   Setting the caret position may or may not alter the current selection.  A
+    change of the selection is notified to the accessibility event listeners with
+    an ::IA2_EVENT_TEXT_SELECTION_CHANGED event.
+
+   When the new caret position differs from the old one (which, of course, is the
+    standard case) this is notified to the accessibility event listeners with an
+    ::IA2_EVENT_TEXT_CARET_MOVED event.
+   @param [in] offset
+    The new index of the caret.  This caret is actually placed to the left side of
+    the character with that index.  An index of 0 places the caret so that the next
+    insertion goes before the first character.  An index of IAccessibleText::nCharacters
+    leads to insertion after the last character.  Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+   @retval S_OK
+   @retval E_FAIL if the caret cannot be set
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT setCaretOffset
+    (
+     [in] long offset
+    );
+
+  /** @brief Changes the bounds of an existing selection.
+   @param [in] selectionIndex
+    Index of selection to change (0 based)
+   @param [in] startOffset
+    New starting offset (0 based)
+   @param [in] endOffset
+    New ending offset (0 based) - the offset of the character just past the last character of the selection.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+  */
+  HRESULT setSelection
+    (
+     [in] long selectionIndex,
+     [in] long startOffset,
+     [in] long endOffset
+    );
+
+  /** @brief Returns total number of characters.
+
+   Note that this may be different than the total number of bytes required to store the
+    text, if the text contains multi-byte characters.
+   @param [out] nCharacters
+   @retval S_OK
+  */
+  [propget] HRESULT nCharacters
+    (
+     [out, retval] long *nCharacters
+    );
+
+  /** @brief Makes a specific part of string visible on screen.
+   @param [in] startIndex
+    0 based character offset.
+   @param [in] endIndex
+    0 based character offset - the offset of the character just past the last character of the string.
+   @param [in] scrollType
+    Defines where the object should be placed on the screen.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+  */
+  HRESULT scrollSubstringTo
+    (
+     [in] long startIndex,
+     [in] long endIndex,
+     [in] enum IA2ScrollType scrollType
+    );
+
+  /** @brief Moves the top left of a substring to a specified location.
+
+   @param [in] startIndex
+    0 based character offset.
+   @param [in] endIndex
+    0 based character offset - the offset of the character just past the last character of the string.
+   @param [in] coordinateType
+    Specifies whether the coordinates are relative to the screen or the parent object.
+   @param [in] x
+    Defines the x coordinate.
+   @param [in] y
+    Defines the y coordinate.
+   @retval S_OK
+   @retval S_FALSE if the object is already at the specified location.
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleText methods.
+  */
+  HRESULT scrollSubstringToPoint
+    (
+     [in] long startIndex,
+     [in] long endIndex,
+     [in] enum IA2CoordinateType coordinateType,
+     [in] long x,
+     [in] long y
+    );
+
+  /** @brief Returns any inserted text.
+
+   Provided for use by the ::IA2_EVENT_TEXT_INSERTED and ::IA2_EVENT_TEXT_UPDATED
+    event handlers.
+
+   This data is only guaranteed to be valid while the thread notifying the event
+   continues. Once the handler has returned, the validity of the data depends on
+   how the server manages the life cycle of its objects. Also, note that the server
+   may have different life cycle management strategies for controls depending on
+   whether or not a control manages its children. Lists, trees, and tables can have
+   a large number of children and thus it's possible that the child objects for those
+   controls would only be created as needed. Servers should document their life cycle
+   strategy as this will be of interest to assistive technology or script engines
+   accessing data out of process or from other threads. Servers only need to save the
+   last inserted block of text and a scope of the entire application is adequate.
+
+   @param [out] newText
+    The text that was just inserted.
+   @retval S_OK
+   @retval S_FALSE If there is nothing to return, the values of IA2TextSegment
+    struct are set as follows:  text = NULL, start = 0, end = 0.
+
+  */
+  [propget] HRESULT newText
+    (
+     [out, retval] IA2TextSegment *newText
+    );
+
+  /** @brief Returns any removed text.
+
+   Provided for use by the IA2_EVENT_TEXT_REMOVED/UPDATED event handlers.
+
+   This data is only guaranteed to be valid while the thread notifying the event
+   continues. Once the handler has returned, the validity of the data depends on
+   how the server manages the life cycle of its objects. Also, note that the server
+   may have different life cycle management strategies for controls depending on
+   whether or not a control manages its children. Lists, trees, and tables can have
+   a large number of children and thus it's possible that the child objects for those
+   controls would only be created as needed. Servers should document their life cycle
+   strategy as this will be of interest to assistive technology or script engines
+   accessing data out of process or from other threads. Servers only need to save the
+   last removed block of text and a scope of the entire application is adequate.
+
+   @param [out] oldText
+    The text that was just removed.
+   @retval S_OK
+   @retval S_FALSE If there is nothing to return, the values of IA2TextSegment
+    struct are set as follows:  text = NULL, start = 0, end = 0.
+  */
+  [propget] HRESULT oldText
+    (
+     [out, retval] IA2TextSegment *oldText
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleText2.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2013 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface gives read-only access to text.
+
+ The %IAccessibleText2 interface extends the functionality of the
+ %IAccessibleText interface.
+*/
+/*
+[object, uuid(9690A9CC-5C80-4DF5-852E-2D5AE4189A54)]
+interface IAccessibleText2 : IAccessibleText
+{
+*/
+  /** @brief Returns the range and of the specified set of attributes.
+
+   Return the range (start and end offsets) and text attributes that correspond
+    to the given attributes filter at the given offset.
+
+   @param [in] offset
+    The offset at which to search for the attributes specified in the filter.
+   @param [in] filter
+    The requested attribute names.  The filter format is "attribute1, attribute2".
+   @param [out] startOffset
+    The starting (0-based) offset of the text containing the specified attributes.
+   @param [out] endOffset
+    The (0-based) offset one past the last character of the text containing the
+    specified attributes.
+   @param [out] attributeValues
+    The values of the requested attributes.
+   @retval S_OK
+   @retval S_FALSE if nothing to return, [out] values are -1, -1, NULL respectively.
+   @retval E_INVALIDARG if bad [in] passed.
+   */
+/*
+  [propget] HRESULT attributeRange
+    (
+     [in] long offset,
+     [in] BSTR filter,
+     [out] long *startOffset,
+     [out] long *endOffset,
+     [out, retval] BSTR *attributeValues
+    );
+
+}
+*/
+/*************************************************************************
+ *
+ *  File Name (AccessibleEditableText.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2012 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface provides clipboard capability to text objects.
+
+ This interface is typically used in conjunction with the IAccessibleText
+  interface and complements that interface with the additional capability of
+  clipboard operations.  Note that even a read only text object can support
+  the copy capability so this interface is not limited to editable objects.
+
+ The substrings used with this interface are specified as follows:
+  If startOffset is less than endOffset, the substring starts with the
+  character at startOffset and ends with the character just before endOffset.
+  If endOffset is lower than startOffset,  the result is the same as a call
+  with the two arguments exchanged. The whole text can be defined by passing
+  the indices zero and IAccessibleText::nCharacters. If both indices have the
+  same value, an empty string is defined.
+
+ Refer to the @ref _specialOffsets
+  "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+  for information about a special offset constant that can be used in %IAccessibleEditableText methods.
+*/
+[object, uuid(A59AA09A-7011-4b65-939D-32B1FB5547E3)]
+interface IAccessibleEditableText : IUnknown
+{
+
+  /** @brief Copies the text range into the clipboard.
+
+   The selection is set to the specified offsets and then selection is copied into
+   the system clipboard.
+
+   @param [in] startOffset
+    Start index of the text to moved into the clipboard.
+    The valid range is 0..length.
+   @param [in] endOffset
+    End index of the text to moved into the clipboard.
+    The valid range is 0..length.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+   @deprecated This function is available via the application's GUI.
+  */
+  HRESULT copyText
+    (
+     [in] long startOffset,
+     [in] long endOffset
+    );
+
+  /** @brief Deletes a range of text.
+
+   The text between and including the two given indices is deleted
+    from the text represented by this object.
+
+   @param [in] startOffset
+    Start index of the text to be deleted.
+    The valid range is 0..length.
+   @param [in] endOffset
+    End index of the text to be deleted.
+    The valid range is 0..length.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+  */
+  HRESULT deleteText
+    (
+     [in] long startOffset,
+     [in] long endOffset
+    );
+
+  /** @brief Inserts text at the specified position.
+
+   The specified string is inserted at the given index into the text
+    represented by this object.
+
+   @param [in] offset
+    Index at which to insert the text.
+    The valid range is 0..length.
+	Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+   @param [in] text
+    Text that is inserted.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT insertText
+    (
+     [in] long offset,
+     [in] BSTR *text
+    );
+
+  /** @brief Deletes a range of text and copies it to the clipboard.
+
+   The selection is set to the specified offsets, the selection is then copied into
+    the system clipboard, and then the selection is deleted.
+
+   @param [in] startOffset
+    Start index of the text to be deleted.
+    The valid range is 0..length.
+   @param [in] endOffset
+    End index of the text to be deleted.
+    The valid range is 0..length.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+   @deprecated This function is available via the application's GUI.
+  */
+  HRESULT cutText
+    (
+     [in] long startOffset,
+     [in] long endOffset
+    );
+
+  /** @brief Pastes content from the clipboard.
+
+   Any existing selection is removed, the clipboard content is then pasted into
+    this object's text at the given offset.  This method is similar to the insertText
+    method.  If the index is not valid the system clipboard content is not inserted. The
+    behavior is the same as	when Ctrl+V is used, i.e. the pasted contents are not
+    necessarily plain text.
+
+   @param [in] offset
+    Index at which to insert the content from the system clipboard into
+    the text represented by this object.
+    The valid range is 0..length.
+	Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @deprecated This function is available via the application's GUI.
+  */
+  HRESULT pasteText
+    (
+     [in] long offset
+    );
+
+  /** @brief Replaces text.
+
+   The text between the two given indices is replaced by the specified
+    replacement string. This method is equivalent to calling first
+    IAccessibleEditableText::deleteText with the two indices and then
+    calling IAccessibleEditableText::insertText with the replacement text
+	at the start index.
+
+   @param [in] startOffset
+    Start index of the text to be replaced.
+    The valid range is 0..length.
+   @param [in] endOffset
+    End index of the text to be replaced.
+    The valid range is 0..length.
+   @param [in] text
+    The Text that replaces the text between the given indices.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+  */
+  HRESULT replaceText
+    (
+     [in] long startOffset,
+     [in] long endOffset,
+     [in] BSTR *text
+    );
+
+  /** @brief Replaces the attributes of a text range by the given set of attributes.
+
+   Sets the attributes for the text between the two given indices. The old
+    attributes are replaced by the new list of attributes.
+
+   @param [in] startOffset
+    Start index of the text whose attributes are modified.
+    The valid range is 0..length.
+   @param [in] endOffset
+    End index of the text whose attributes are modified.
+    The valid range is 0..length.
+   @param [in] attributes
+    Set of attributes that replaces the old list of attributes of
+    the specified text portion.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+   @note Refer to @ref _specialOffsets
+    "Special Offsets for use in the IAccessibleText and IAccessibleEditableText Methods"
+    for information about special offsets that can be used in %IAccessibleEditableText
+    methods.
+  */
+  HRESULT setAttributes
+    (
+     [in] long startOffset,
+     [in] long endOffset,
+     [in] BSTR *attributes
+    );
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleHyperlink.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface represents hyperlinks.
+
+ This interface represents a hyperlink associated with a single substring
+  of text or single non-text object.  Non-text objects can have either a
+  single link or a collection of links such as when the non-text object is
+  an image map.
+
+ Linked objects and anchors are implementation dependent. This interface is derived
+  from IAccessibleAction.  IAccessibleAction::nActions is one greater than the
+  maximum value for the indices used with the methods of this interface.
+
+ Furthermore, the object that implements this interface has to be connected
+  implicitly or explicitly with an object that implements IAccessibleText.
+  IAccessibleHyperlink::startIndex and IAccessibleHyperlink::endIndex are
+  indices with respect to the text exposed by IAccessibleText.
+
+ This interface provides access to a single object which can have multiple actions.
+  An example is an image map which is an image with multiple links each of which is
+  associated with a separate non-overlapping area of the image.  This interface could
+  also be applied to other kinds of objects with multiple actions such as "smart tags"
+  which are objects, typically strings, which have multiple actions such as
+  "Activate URI", "Bookmark URI", etc.
+
+ An interesting use case is an image map where each area is associated with multiple
+  actions, e.g. an image map of smart tags.  In this case you would have to implement
+  two levels of accessible hyperlinks.  The first level hyperlinks would only implement
+  anchor and anchorTarget.  The anchors would all reference the image object.  The
+  anchorTargets would reference the second level accessible hyperlink objects.  None
+  of the IAccessibleAction methods would be implemented on the first level hyperlink
+  objects.  The second level hyperlink objects would implement the IAccessibleAction
+  methods.  Their anchors would also reference the image object and their anchorTargets
+  would reference URLs or the objects that would be activated.
+
+ This use case demonstrates that in some cases there is no need for IAccessibleHyperlink
+  to derive from IAccessibleAction.  As a result it may be removed in a later version of
+  the IDL and it is suggested that implementations should not rely on the inheritance.
+
+*/
+[object, uuid(01C20F2B-3DD2-400f-949F-AD00BDAB1D41)]
+interface IAccessibleHyperlink : IAccessibleAction
+{
+
+  /** @brief Returns an object that represents the link anchor, as appropriate
+   for the link at the specified index.
+   @param [in] index
+    A 0 based index identifies the anchor when, as in the case of an image map,
+    there is more than one link represented by this object.  The valid maximal
+    index is indicated by IAccessibleAction::nActions.
+   @param [out] anchor
+    This is an implementation dependent value.  For example, for a text link this
+	method could return the substring of the containing string where the substring
+	is overridden with link behavior, and for an image link this method could return
+	an IUnknown VARIANT for IAccessibleImage.  See the section about
+	@ref _variants "VARIANTs" for additional information.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT anchor
+    (
+     [in] long index,
+     [out, retval] VARIANT *anchor
+    );
+
+  /** @brief Returns an object representing the target of the link, as appropriate
+   for the link at the specified index.
+   @param [in] index
+    A 0 based index identifies the anchor when, as in the case of an image map,
+    there is more than one link represented by this object.  The valid maximal
+    index is indicated by IAccessibleAction::nActions.
+   @param [out] anchorTarget
+    This is an implementation dependent value.  For example this method could
+	return a BSTR VARIANT of the URI.  Alternatively this method could return an
+	IUnknown VARIANT of a COM interface representing a target object to be
+	activated when the link is activated.  See the section about
+	@ref _variants "VARIANTs" for additional information.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT anchorTarget
+    (
+     [in] long index,
+     [out, retval] VARIANT *anchorTarget
+    );
+
+  /** @brief Returns the 0 based character offset at which the textual representation of the hyperlink starts.
+
+   The returned value is related to the IAccessibleText interface of the object that
+   owns this hyperlink.
+   @param [out] index
+   @retval S_OK
+  */
+  [propget] HRESULT startIndex
+    (
+     [out, retval] long *index
+    );
+
+  /** @brief Returns the 0 based character offset at which the textual representation of the hyperlink ends.
+
+   The returned value is related to the IAccessibleText interface of the object that
+   owns this hyperlink. The character at the index is not part of the hypertext.
+   @param [out] index
+   @retval S_OK
+  */
+  [propget] HRESULT endIndex
+    (
+     [out, retval] long *index
+    );
+
+  /** @brief Returns whether the target object referenced by this link is still valid.
+
+   This is a volatile state that may change without sending an appropriate event.
+   Returns TRUE if the referenced target is still valid and FALSE otherwise.
+
+   This has also been used to indicate whether or not the URI of the anchorTarget
+   is malformed.
+
+   @param [out] valid
+    If false, one or more of the object's links are invalid.
+	If true, all of the object's links are valid.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is FALSE
+   @note This method is not being used, is deprecated, and should not be implemented or
+    used.  It is likely that this method will be removed in a later version of the IDL.
+  */
+  [propget] HRESULT valid
+    (
+     [out, retval] boolean *valid
+    );
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleHypertext.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface exposes information about hypertext in a document.
+
+ The %IAccessibleHypertext interface is the main interface to expose
+  hyperlinks in a document, typically a text document, that are used
+  to reference other documents.  A typical implementation is to implement
+  this interface on the smallest text object such as a paragraph of text.
+*/
+[object, uuid(6B4F8BBF-F1F2-418a-B35E-A195BC4103B9)]
+interface IAccessibleHypertext : IAccessibleText
+{
+
+  /** @brief Returns the number of links and link groups contained within this hypertext
+    paragraph.
+   @param [out] hyperlinkCount
+    The number of links and link groups within this hypertext paragraph.
+    Returns 0 if there is no link.
+   @retval S_OK
+  */
+  [propget] HRESULT nHyperlinks
+    (
+     [out, retval] long *hyperlinkCount
+    );
+
+  /** @brief Returns the specified link.
+
+   The returned IAccessibleHyperlink object encapsulates the hyperlink and
+    provides several kinds of information describing it.
+   @param [in] index
+    This 0 based index specifies the hyperlink to return.
+   @param [out] hyperlink
+    If the given index is valid, i.e. lies in the interval from 0 to the number
+    of links minus one, a reference to the specified hyperlink object is returned.
+    If the index is invalid then a NULL pointer is returned.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT hyperlink
+    (
+     [in] long index,
+     [out, retval] IAccessibleHyperlink **hyperlink
+    );
+
+  /** @brief Returns the index of the hyperlink that is associated with this character index.
+
+   This is the case when a link spans the given character index.
+   @param [in] charIndex
+    A 0 based index of the character for which to return the link index.  If
+	IAccessibleText is used to represent the text containing the link, then the
+	character index is only  valid if it is greater than or equal to zero and
+	lower than the number of characters in the text.
+   @param [out] hyperlinkIndex
+    Returns the 0 based index of the hyperlink that is associated with this
+	character index, or -1 if charIndex is not on a link.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is -1
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT hyperlinkIndex
+    (
+     [in] long charIndex,
+     [out, retval] long *hyperlinkIndex
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleHypertext2.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2013 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface exposes information about hypertext in a document.
+
+ The %IAccessibleHypertext2 interface extends the functinality of the
+ %IAccessibleHypertext inteface.
+*/
+[object, uuid(CF64D89F-8287-4B44-8501-A827453A6077)]
+interface IAccessibleHypertext2 : IAccessibleHypertext
+{
+
+ /** @brief Returns the links for this object.
+
+   The returned IAccessibleHyperlink objects encapsulate the hyperlink and
+    provides several kinds of information describing it.
+
+   @param [out] hyperlinks
+    This array is allocated by the server.  The client must free it with CoTaskMemFree.
+   @param [out] nHyperlinks
+    The number of links returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are no links, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT hyperlinks
+    (
+     [out, size_is(,*nHyperlinks)] IAccessibleHyperlink ***hyperlinks,
+     [out, retval] long *nHyperlinks
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleTable.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2013 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface gives access to a two-dimensional table.
+
+ Typically all accessible objects that represent cells or cell-clusters of a table
+  will be at the same time children of the table.  In this case IAccessible2::indexInParent
+  will return the child index which then can be used when calling IAccessibleTable::rowIndex
+  and IAccessibleTable::columnIndex.
+
+ However, in some cases that kind of implementation will not be possible.  When
+  the table cells are not direct children of a table, the object representing
+  the cell can define a "table-cell-index" object attribute identifying the 0
+  based table cell index.  This object attribute is obtained by parsing the
+  attribute string returned by IAccessible2::attributes.  The "table-cell-index"
+  attribute can be used just like a child index of the typical case.  ATs should
+  first test for the presence of the "table-cell-index" attribute and if it is not
+  present then IAccessible2::indexInParent can be used as in the typical case
+  where cells are direct children of the table.
+
+ The range of valid coordinates for this interface are implementation dependent.
+  However, that range includes at least the intervals from the from the first row
+  or column with the index 0 up to the last (but not including) used row or column
+  as returned by IAccessibleTable::nRows and IAccessibleTable::nColumns.
+
+ Note that newer implementations are now using IAccessibleTable2 and IAccessibleTableCell
+  rather than this interface.
+*/
+[object, uuid(35AD8070-C20C-4fb4-B094-F4F7275DD469)]
+interface IAccessibleTable : IUnknown
+{
+
+  /** @brief Returns the accessible object at the specified row and column in
+    the table.  This object could be an IAccessible or an IAccessible2.
+   @param [in] row
+    The 0 based row index for which to retrieve the cell.
+   @param [in] column
+    The 0 based column index for which to retrieve the cell.
+   @param [out] accessible
+    If both row and column index are valid then the corresponding accessible
+    object is returned that represents the requested cell regardless of whether
+    the cell is currently visible (on the screen).
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is NULL
+  */
+  [propget] HRESULT accessibleAt
+    (
+     [in] long row,
+     [in] long column,
+     [out, retval] IUnknown **accessible
+    );
+
+  /** @brief Returns the caption for the table.  The returned object could be
+    an IAccessible or an IAccessible2.
+   @param [out] accessible
+    If the table has a caption then a reference to it is returned, else a NULL
+    pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT caption
+    (
+     [out, retval] IUnknown **accessible
+    );
+
+  /** @brief Translates the given row and column indexes into the corresponding cell index.
+   @param [in] rowIndex
+    0 based row index for the cell.
+   @param [in] columnIndex
+    0 based column index for the cell.
+   @param [out] cellIndex
+    Returns the 0 based index of the cell at the specified row and column indexes.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is 0
+   @note The returned value is not necessarily a child index of the immediate parent.
+    In cases where the table cells are not direct children of the table the index
+    is actually the cell index, i.e. conceptually it's an index into a one dimensional
+	array of cells laid out in row order.
+  */
+  [propget] HRESULT childIndex
+	(
+	 [in] long rowIndex,
+	 [in] long columnIndex,
+	 [out, retval] long *cellIndex
+	);
+
+  /** @brief Returns the description text of the specified column in the table.
+   @param [in] column
+    The 0 based index of the column for which to retrieve the description.
+   @param [out] description
+    Returns the description text of the specified column in the table if such a
+    description exists.  Otherwise a NULL pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed, [out] value is NULL
+  */
+  [propget] HRESULT columnDescription
+    (
+     [in] long column,
+     [out, retval] BSTR *description
+    );
+
+  /** @brief Returns the number of columns occupied by the accessible object
+    at the specified row and column in the table.
+
+   The result is greater than 1 if the specified cell spans multiple columns.
+   @param [in] row
+    0 based row index of the accessible for which to return the column extent.
+   @param [in] column
+    0 based column index of the accessible for which to return the column extent.
+   @param [out] nColumnsSpanned
+    Returns the 1 based column extent of the specified cell.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is 0
+  */
+  [propget] HRESULT columnExtentAt
+    (
+     [in] long row,
+     [in] long column,
+     [out, retval] long *nColumnsSpanned
+    );
+
+  /** @brief Returns the column headers as an %IAccessibleTable object.
+
+   Content and size of the returned table are implementation dependent.
+   @param [out] accessibleTable
+    The column header
+   @param [out] startingRowIndex
+    The 0 based row index where the header starts, usually 0.
+   @retval S_OK
+   @retval S_FALSE if there is no header, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT columnHeader
+    (
+     [out] IAccessibleTable **accessibleTable,
+	 [out, retval] long *startingRowIndex
+    );
+
+  /** @brief Translates the given cell index into the corresponding column index.
+   @param [in] cellIndex
+    0 based index of the cell in the parent or closest ancestor table.  Typically this
+	is the value returned from IAccessible2::indexInParent, but in the case where the
+	table cells are not direct children of the table this is the cell index specified
+	by the "table-cell-index" object attribute obtained from parsing the attributes
+	string returned by calling IAccessible2::attributes on the cell object.
+   @param [out] columnIndex
+    Returns the 0 based column index of the cell of the specified child or the index of
+    the first column if the child spans multiple columns.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is 0
+  */
+  [propget] HRESULT columnIndex
+    (
+	 [in] long cellIndex,
+	 [out, retval] long *columnIndex
+	);
+
+  /** @brief Returns the total number of columns in table
+   @param [out] columnCount
+    Number of columns in table (including columns outside the current viewport)
+   @retval S_OK
+  */
+  [propget] HRESULT nColumns
+    (
+     [out, retval] long *columnCount
+    );
+
+  /** @brief Returns the total number of rows in table
+   @param [out] rowCount
+    Number of rows in table (including rows outside the current viewport)
+   @retval S_OK
+  */
+  [propget] HRESULT nRows
+    (
+     [out, retval] long *rowCount
+    );
+
+  /** @brief Returns the total number of selected cells
+   @param [out] cellCount
+    Number of cells currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedChildren
+    (
+	 [out, retval] long *cellCount
+	);
+
+  /** @brief Returns the total number of selected columns
+   @param [out] columnCount
+    Number of columns currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedColumns
+    (
+     [out, retval] long *columnCount
+    );
+
+  /** @brief Returns the total number of selected rows
+   @param [out] rowCount
+    Number of rows currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedRows
+    (
+     [out, retval] long *rowCount
+    );
+
+  /** @brief Returns the description text of the specified row in the table.
+   @param [in] row
+    The 0 based index of the row for which to retrieve the description.
+   @param [out] description
+    Returns the description text of the specified row in the table if such a
+    description exists.  Otherwise a NULL pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed, [out] value is NULL
+  */
+  [propget] HRESULT rowDescription
+    (
+     [in] long row,
+     [out, retval] BSTR *description
+    );
+
+  /** @brief Returns the number of rows occupied by the accessible object
+    at the specified row and column in the table.
+
+   The result is greater than 1 if the specified cell spans multiple rows.
+   @param [in] row
+    0 based row index of the accessible for which to return the row extent.
+   @param [in] column
+    0 based column index of the accessible for which to return the row extent.
+   @param [out] nRowsSpanned
+    Returns the row extent of the specified cell.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is 0
+  */
+  [propget] HRESULT rowExtentAt
+    (
+     [in] long row,
+     [in] long column,
+     [out, retval] long *nRowsSpanned
+    );
+
+  /** @brief Returns the row headers as an %IAccessibleTable object.
+
+   Content and size of the returned table are implementation dependent.
+   @param [out] accessibleTable
+    The row header.
+   @param [out] startingColumnIndex
+    The 0 based column index where the header starts, usually 0.
+   @retval S_OK
+   @retval S_FALSE if there is no header, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT rowHeader
+    (
+     [out] IAccessibleTable **accessibleTable,
+	 [out, retval] long *startingColumnIndex
+    );
+
+  /** @brief Translates the given cell index into a row index.
+   @param [in] cellIndex
+    0 based index of the cell in the parent or closest ancestor table.  Typically this
+	is the value returned from IAccessible2::indexInParent, but in the case where the
+	table cells are not direct children of the table this is the cell index specified
+	by the "table-cell-index" object attribute obtained from parsing the attributes
+	string returned by calling IAccessible2::attributes on the cell object.
+   @param [out] rowIndex
+    0 based row index
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is 0
+  */
+  [propget] HRESULT rowIndex
+    (
+	 [in] long cellIndex,
+	 [out, retval] long *rowIndex
+	);
+
+  /** @brief Returns a list of cell indexes currently selected (0 based).
+   @param [in] maxChildren
+    This parameter is ignored. Refer to @ref _arrayConsideration
+	"Special Consideration when using Arrays" for more details.
+   @param [out] children
+    An array of cell indexes of selected cells (each index is 0 based),
+	allocated by the server. The client must free it with CoTaskMemFree.
+   @param [out] nChildren
+    The number of cell indexes returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedChildren
+    (
+     [in] long maxChildren,
+     [out, size_is(,maxChildren), length_is(,*nChildren)] long **children,
+     [out, retval] long *nChildren
+    );
+
+  /** @brief Returns a list of column indexes currently selected (0 based).
+   @param [in] maxColumns
+    This parameter is ignored. Refer to @ref _arrayConsideration
+	"Special Consideration when using Arrays" for more details.
+   @param [out] columns
+	An array of column indexes of selected columns (each index is 0 based), allocated
+	by the server. The client must free it with CoTaskMemFree.
+   @param [out] nColumns
+    The number of column indexes returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedColumns
+    (
+     [in] long maxColumns,
+     [out, size_is(,maxColumns), length_is(,*nColumns)] long **columns,
+     [out, retval] long *nColumns
+    );
+
+  /** @brief Returns a list of row indexes currently selected (0 based).
+   @param [in] maxRows
+    This parameter is ignored. Refer to @ref _arrayConsideration
+	"Special Consideration when using Arrays" for more details.
+   @param [out] rows
+    An array of row indexes of selected rows (each index is 0 based), allocated
+	by the server. The client must free it with CoTaskMemFree.
+   @param [out] nRows
+    The number of row indexes returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedRows
+    (
+     [in] long maxRows,
+     [out, size_is(,maxRows), length_is(,*nRows)] long **rows,
+     [out, retval] long *nRows
+    );
+
+  /** @brief Returns the summary description of the table.  The returned object could be
+    an IAccessible or an IAccessible2.
+   @param [out] accessible
+    Returns a reference to an implementation dependent accessible object
+    representing the table's summary or a NULL pointer if the table
+    does not support a summary.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT summary
+    (
+     [out, retval] IUnknown **accessible
+    );
+
+  /** @brief Returns a boolean value indicating whether the specified column is
+    completely selected.
+   @param [in] column
+    0 based index of the column for which to determine whether it is selected.
+   @param [out] isSelected
+    Returns TRUE if the specified column is selected completely and FALSE otherwise.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is FALSE
+  */
+  [propget] HRESULT isColumnSelected
+    (
+     [in] long column,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Returns a boolean value indicating whether the specified row is completely
+    selected.
+   @param [in] row
+    0 based index of the row for which to determine whether it is selected.
+   @param [out] isSelected
+    Returns TRUE if the specified row is selected completely and FALSE otherwise.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is FALSE
+  */
+  [propget] HRESULT isRowSelected
+    (
+     [in] long row,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Returns a boolean value indicating whether the specified cell is selected.
+   @param [in] row
+    0 based index of the row for the cell to determine whether it is selected.
+   @param [in] column
+    0 based index of the column for the cell to determine whether it is selected.
+   @param [out] isSelected
+    Returns TRUE if the specified cell is selected and FALSE otherwise.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] value is FALSE
+  */
+  [propget] HRESULT isSelected
+    (
+     [in] long row,
+     [in] long column,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Selects a row and unselects all previously selected rows.
+   @param [in] row
+    0 based index of the row to be selected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT selectRow
+    (
+     [in] long row
+    );
+
+  /** @brief Selects a column and unselects all previously selected columns.
+   @param [in] column
+    0 based index of the column to be selected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT selectColumn
+    (
+     [in] long column
+    );
+
+  /** @brief Unselects one row, leaving other selected rows selected (if any).
+   @param [in] row
+    0 based index of the row to be unselected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT unselectRow
+    (
+     [in] long row
+    );
+
+  /** @brief Unselects one column, leaving other selected columns selected (if any).
+   @param [in] column
+    0 based index of the column to be unselected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT unselectColumn
+    (
+     [in] long column
+    );
+
+  /** @brief Given a cell index, gets the row and column indexes and extents of a cell
+    and whether or not it is selected.
+
+   This is a convenience function.  It is not mandatory to implement it.
+   @param [in] index
+    0 based index of this cell in the table.
+   @param [out] row
+    0 based row index.
+   @param [out] column
+    0 based column index.
+   @param [out] rowExtents
+    Number of cells spanned by this cell in this row.
+   @param [out] columnExtents
+    Number of cells spanned by this cell in this column.
+   @param [out] isSelected
+    Indicates if the specified cell is selected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed, [out] values are 0s and FALSE respectively
+  */
+  [propget] HRESULT rowColumnExtentsAtIndex
+    (
+	 [in] long index,
+	 [out] long *row,
+	 [out] long *column,
+	 [out] long *rowExtents,
+	 [out] long *columnExtents,
+	 [out, retval] boolean *isSelected
+	);
+
+  /** @brief Returns the type and extents describing how a table changed.
+
+   Provided for use by the IA2_EVENT_TABLE_MODEL_CHANGED event handler.
+
+   This data is only guaranteed to be valid while the thread notifying the event
+   continues. Once the handler has returned, the validity of the data depends on
+   how the server manages the life cycle of its objects. Also, note that the server
+   may have different life cycle management strategies for controls depending on
+   whether or not a control manages its children. Lists, trees, and tables can have
+   a large number of children and thus it's possible that the child objects for those
+   controls would only be created as needed. Servers should document their life cycle
+   strategy as this will be of interest to assistive technology or script engines
+   accessing data out of process or from other threads. Servers only need to save the
+   most recent row and column values associated with the change and a scope of the
+   entire application is adequate.
+
+   @param [out] modelChange
+    A struct of (type(insert, delete, update), firstRow, lastRow, firstColumn, lastColumn).
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT modelChange
+    (
+	 [out, retval] IA2TableModelChange *modelChange
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleTable2.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2012 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface gives access to a two-dimensional table.
+
+ Please also refer to the IAccessibleTableCell interface.
+
+ If you want to support older applications you should also support the
+  IAccessibleTable inteface.
+*/
+[object, uuid(6167f295-06f0-4cdd-a1fa-02e25153d869)]
+interface IAccessibleTable2 : IUnknown
+{
+
+  /** @brief Returns the accessible object at the specified row and column in
+    the table.  This object could be an IAccessible or an IAccessible2.
+   @param [in] row
+    The 0 based row index for which to retrieve the cell.
+   @param [in] column
+    The 0 based column index for which to retrieve the cell.
+   @param [out] cell
+    If both row and column index are valid then the corresponding accessible
+    object is returned that represents the requested cell regardless of whether
+    the cell is currently visible (on the screen).
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT cellAt
+    (
+     [in] long row,
+     [in] long column,
+     [out, retval] IUnknown **cell
+    );
+
+  /** @brief Returns the caption for the table.  The returned object could be
+    an IAccessible or an IAccessible2.
+   @param [out] accessible
+    If the table has a caption then a reference to it is returned, else a NULL
+    pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @deprecated use a describedBy relation
+  */
+  [propget] HRESULT caption
+    (
+     [out, retval] IUnknown **accessible
+    );
+
+  /** @brief Returns the description text of the specified column in the table.
+   @param [in] column
+    The 0 based index of the column for which to retrieve the description.
+   @param [out] description
+    Returns the description text of the specified column in the table if such a
+    description exists.  Otherwise a NULL pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT columnDescription
+    (
+     [in] long column,
+     [out, retval] BSTR *description
+    );
+
+
+  /** @brief Returns the total number of columns in table
+   @param [out] columnCount
+    Number of columns in table (including columns outside the current viewport)
+   @retval S_OK
+  */
+  [propget] HRESULT nColumns
+    (
+     [out, retval] long *columnCount
+    );
+
+  /** @brief Returns the total number of rows in table
+   @param [out] rowCount
+    Number of rows in table (including rows outside the current viewport)
+   @retval S_OK
+  */
+  [propget] HRESULT nRows
+    (
+     [out, retval] long *rowCount
+    );
+
+  /** @brief Returns the total number of selected cells
+   @param [out] cellCount
+    Number of cells currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedCells
+    (
+     [out, retval] long *cellCount
+    );
+
+  /** @brief Returns the total number of selected columns
+   @param [out] columnCount
+    Number of columns currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedColumns
+    (
+     [out, retval] long *columnCount
+    );
+
+  /** @brief Returns the total number of selected rows
+   @param [out] rowCount
+    Number of rows currently selected
+   @retval S_OK
+  */
+  [propget] HRESULT nSelectedRows
+    (
+     [out, retval] long *rowCount
+    );
+
+  /** @brief Returns the description text of the specified row in the table.
+   @param [in] row
+    The 0 based index of the row for which to retrieve the description.
+   @param [out] description
+    Returns the description text of the specified row in the table if such a
+    description exists.  Otherwise a NULL pointer is returned.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT rowDescription
+    (
+     [in] long row,
+     [out, retval] BSTR *description
+    );
+
+  /** @brief Returns a list of accessibles currently selected.
+   @param [out] cells
+    Pointer to an array of references to selected accessibles.  The array is
+    allocated by the server with CoTaskMemAlloc and freed by the client with
+    CoTaskMemFree.
+   @param [out] nSelectedCells
+    The number of accessibles returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedCells
+    (
+     [out, size_is(,*nSelectedCells)] IUnknown ***cells,
+     [out, retval] long *nSelectedCells
+    );
+
+  /** @brief Returns a list of column indexes currently selected (0 based).
+   @param [out] selectedColumns
+    A pointer to an array of column indexes of selected columns (each index is
+    0 based).  The array is allocated by the server with CoTaskMemAlloc and
+    freed by the client with CoTaskMemFree.
+   @param [out] nColumns
+    The number of column indexes returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedColumns
+    (
+     [out, size_is(,*nColumns)] long **selectedColumns,
+     [out, retval] long *nColumns
+    );
+
+  /** @brief Returns a list of row indexes currently selected (0 based).
+   @param [out] selectedRows
+    An array of row indexes of selected rows (each index is 0 based).  The array
+    is allocated by the server with CoTaskMemAlloc and freed by the client with
+    CoTaskMemFree.
+   @param [out] nRows
+    The number of row indexes returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there are none, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT selectedRows
+    (
+     [out, size_is(,*nRows)] long **selectedRows,
+     [out, retval] long *nRows
+    );
+
+  /** @brief Returns the summary description of the table.  The returned object could be
+    an IAccessible or an IAccessible2.
+   @param [out] accessible
+    Returns a reference to an implementation dependent accessible object
+    representing the table's summary or a NULL pointer if the table
+    does not support a summary.
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+   @deprecated Use the labeledBy relation
+  */
+  [propget] HRESULT summary
+    (
+     [out, retval] IUnknown **accessible
+    );
+
+  /** @brief Returns a boolean value indicating whether the specified column is
+    completely selected.
+   @param [in] column
+    0 based index of the column for which to determine whether it is selected.
+   @param [out] isSelected
+    Returns TRUE if the specified column is selected completely and FALSE otherwise.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT isColumnSelected
+    (
+     [in] long column,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Returns a boolean value indicating whether the specified row is completely
+    selected.
+   @param [in] row
+    0 based index of the row for which to determine whether it is selected.
+   @param [out] isSelected
+    Returns TRUE if the specified row is selected completely and FALSE otherwise.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  [propget] HRESULT isRowSelected
+    (
+     [in] long row,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Selects a row and unselects all previously selected rows.
+
+   The behavior should mimic that of the application, but for those applications
+    which do not have a means in the GUI to select a full row of cells the behavior
+    should be as follows:  First any selected rows in the table are unselected.  Then
+    the entire row of cells for the specified row is selected.  If any of the
+    cells in the selected row span additional rows, the cells in those rows
+    are also selected.
+   @param [in] row
+    0 based index of the row to be selected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT selectRow
+    (
+     [in] long row
+    );
+
+  /** @brief Selects a column and unselects all previously selected columns.
+
+   The behavior should mimic that of the application, but for those applications
+    which do not have a means in the GUI to select a full column of cells the behavior
+    should be as follows:  First any selected columns in the table are unselected.  Then
+    the entire column of cells for the specified column is selected.  If any of the
+    cells in the selected column span additional columns, the cells in those columns
+    are also selected.
+   @param [in] column
+    0 based index of the column to be selected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT selectColumn
+    (
+     [in] long column
+    );
+
+  /** @brief Unselects one row, leaving other selected rows selected (if any).
+
+   The behavior should mimic that of the application, but for those applications
+    which do not have a means in the GUI to unselect a full row of cells the
+    behavior should be as follows:  The entire row of cells for the specified
+    row is unselected.  If any of the cells in the selected row span additional
+    rows, the cells in those rows are also unselected.
+   @param [in] row
+    0 based index of the row to be unselected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT unselectRow
+    (
+     [in] long row
+    );
+
+  /** @brief Unselects one column, leaving other selected columns selected (if any).
+
+   The behavior should mimic that of the application, but for those applications
+    which do not have a means in the GUI to unselect a full column of cells the
+    behavior should be as follows:  The entire column of cells for the specified
+    column is unselected.  If any of the cells in the selected column span additional
+    columns, the cells in those columns are also unselected.
+   @param [in] column
+    0 based index of the column to be unselected.
+   @retval S_OK
+   @retval E_INVALIDARG if bad [in] passed
+  */
+  HRESULT unselectColumn
+    (
+     [in] long column
+    );
+
+  /** @brief Returns the type and extents describing how a table changed.
+
+   Provided for use by the IA2_EVENT_TABLE_MODEL_CHANGED event handler.
+
+   This data is only guaranteed to be valid while the thread notifying the event
+   continues. Once the handler has returned, the validity of the data depends on
+   how the server manages the life cycle of its objects. Also, note that the server
+   may have different life cycle management strategies for controls depending on
+   whether or not a control manages its children. Lists, trees, and tables can have
+   a large number of children and thus it's possible that the child objects for those
+   controls would only be created as needed. Servers should document their life cycle
+   strategy as this will be of interest to assistive technology or script engines
+   accessing data out of process or from other threads. Servers only need to save the
+   most recent row and column values associated with the change and a scope of the
+   entire application is adequate.
+
+   @param [out] modelChange
+    A struct of (type(insert, delete, update), firstRow, lastRow, firstColumn, lastColumn).
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT modelChange
+    (
+     [out, retval] IA2TableModelChange *modelChange
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleTableCell.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2013 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface gives access to the cells of a two-dimensional table.
+
+ Please also refer to the IAccessibleTable2 interface.
+
+*/
+[object, uuid(594116B1-C99F-4847-AD06-0A7A86ECE645)]
+interface IAccessibleTableCell : IUnknown
+{
+
+  /** @brief Returns the number of columns occupied by this cell accessible.
+
+   The result is greater than 1 if the specified cell spans multiple columns.
+   @param [out] nColumnsSpanned
+    Returns the 1 based column extent of the specified cell.
+   @retval S_OK
+  */
+  [propget] HRESULT columnExtent
+    (
+     [out, retval] long *nColumnsSpanned
+    );
+
+  /** @brief Returns the column headers as an array of cell accessibles.
+
+   @param [out] cellAccessibles
+    Pointer to an array of references to cell accessibles.  The array is allocated
+	by the server.  The client must free it with CoTaskMemFree.
+   @param [out] nColumnHeaderCells
+    The number of accessibles returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there is no header, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT columnHeaderCells
+    (
+     [out, size_is(,*nColumnHeaderCells)] IUnknown ***cellAccessibles,
+     [out, retval] long *nColumnHeaderCells
+    );
+
+  /** @brief Translates this cell accessible into the corresponding column index.
+
+   @param [out] columnIndex
+    Returns the 0 based column index of the cell of the specified cell or the index of
+    the first column if the cell spans multiple columns.
+   @retval S_OK
+  */
+  [propget] HRESULT columnIndex
+    (
+     [out, retval] long *columnIndex
+    );
+
+  /** @brief Returns the number of rows occupied by this cell accessible.
+
+   @param [out] nRowsSpanned
+    Returns the row extent of the specified cell.
+   @retval S_OK
+  */
+  [propget] HRESULT rowExtent
+    (
+     [out, retval] long *nRowsSpanned
+    );
+
+  /** @brief Returns the row headers as an array of cell accessibles.
+
+   @param [out] cellAccessibles
+    Pointer to an array of references to cell accessibles.  The array is allocated
+	by the server.  The client must free it with CoTaskMemFree.
+   @param [out] nRowHeaderCells
+    The number of accessibles returned; the size of the returned array.
+   @retval S_OK
+   @retval S_FALSE if there is no header, [out] values are NULL and 0 respectively
+  */
+  [propget] HRESULT rowHeaderCells
+    (
+     [out, size_is(,*nRowHeaderCells)] IUnknown ***cellAccessibles,
+     [out, retval] long *nRowHeaderCells
+    );
+
+  /** @brief Translates this cell accessible into the corresponding row index.
+
+   @param [out] rowIndex
+    Returns the 0 based row index of the specified cell or the index of
+    the first row if the cell spans multiple rows.
+   @retval S_OK
+  */
+  [propget] HRESULT rowIndex
+    (
+     [out, retval] long *rowIndex
+    );
+
+  /** @brief Returns a boolean value indicating whether this cell is selected.
+
+   @param [out] isSelected
+    Returns TRUE if the specified cell is selected and FALSE otherwise.
+   @retval S_OK
+  */
+  [propget] HRESULT isSelected
+    (
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Gets the row and column indexes and extents of this cell accessible
+    and whether or not it is selected.
+
+   This is a convenience function.  It is not mandatory to implement it.
+   @param [out] row
+    0 based row index.
+   @param [out] column
+    0 based column index.
+   @param [out] rowExtents
+    Number of cells spanned by this cell in this row.
+   @param [out] columnExtents
+    Number of cells spanned by this cell in this column.
+   @param [out] isSelected
+    Indicates if the specified cell is selected.
+   @retval S_OK
+  */
+  [propget] HRESULT rowColumnExtents
+    (
+     [out] long *row,
+     [out] long *column,
+     [out] long *rowExtents,
+     [out] long *columnExtents,
+     [out, retval] boolean *isSelected
+    );
+
+  /** @brief Returns a reference to the accessbile of the containing table.
+
+   @param [out] table
+    Returns a reference to the IUnknown of the containing table.
+   @retval S_OK
+  */
+  [propget] HRESULT table
+    (
+     [out, retval] IUnknown **table
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleImage.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface represents images and icons.
+
+ This interface is used for a representation of images like icons on buttons.
+  %IAccessibleImage only needs to be implemented in certain situations.  Some
+  examples are:
+  <ol>
+   <li>The accessible name and description are not enough to fully
+    describe the image, e.g. when the accessible description is used to define the
+    behavior of an actionable image and the image itself conveys semantically
+    significant information.
+   <li>The user can edit the content that includes an
+    image and therefore the user needs to be able to review the image's position.
+  </ol>
+*/
+[object, uuid(FE5ABB3D-615E-4f7b-909F-5F0EDA9E8DDE)]
+interface IAccessibleImage : IUnknown
+{
+  /** @brief Returns the localized description of the image.
+   @param [out] description
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT description
+    (
+     [out, retval] BSTR *description
+    );
+
+  /** @brief Returns the coordinates of the image.
+   @param [in] coordinateType
+    Specifies whether the returned coordinates should be relative to the screen or the parent object.
+   @param [out] x
+   @param [out] y
+   @retval S_OK
+  */
+  [propget] HRESULT imagePosition
+    (
+	 [in] enum IA2CoordinateType coordinateType,
+	 [out] long *x,
+     [out, retval] long *y
+    );
+
+  /** @brief Returns the size of the image in units specified by parent's coordinate system.
+   @param [out] height
+   @param [out] width
+   @retval S_OK
+  */
+
+  [propget] HRESULT imageSize
+    (
+     [out] long *height,
+	 [out, retval] long *width
+    );
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleEventID.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** %IAccessible2 specific event constants
+
+ This enum defines the event IDs fired by %IAccessible2 objects.  The event IDs
+ are in addition to those used by MSAA.
+*/
+enum IA2EventID {
+
+  /** The change of the number or attributes of actions of an accessible
+    object is signaled by events of this type.
+  */
+  IA2_EVENT_ACTION_CHANGED = 0x101,
+
+  /** <b>Deprecated.</b> The active descendant of a component has changed.
+
+	Note: This event constant is misspelled and thus is deprecated and will be
+	removed in a later version. Please use the correctly spelled version which
+	follows.
+  */
+  IA2_EVENT_ACTIVE_DECENDENT_CHANGED,
+
+  /** The active descendant of a component has changed.  The active descendant
+    is used in objects with transient children.
+
+    Note: Due to the fact that MSAA's WinEvents don't allow the active child index
+	to be passed on the IA2_EVENT_ACTIVE_DESCENDANT_CHANGED event the manages
+	descendants	scheme can't be used.  Instead the active child object has to fire
+	MSAA's EVENT_OBJECT_FOCUS.  In a future release a new event mechanism may be
+	added to provide for event specific data to be passed with the event.  At that
+	time the IA2_EVENT_ACTIVE_DECENDENT_CHANGED event and
+	IA2_STATE_MANAGES_DESCENDANTS state would be useful.
+  */
+  IA2_EVENT_ACTIVE_DESCENDANT_CHANGED = IA2_EVENT_ACTIVE_DECENDENT_CHANGED,
+
+  /** The document wide attributes of the document object have changed.
+  */
+  IA2_EVENT_DOCUMENT_ATTRIBUTE_CHANGED,
+
+  /** The contents of the document have changed.
+  */
+  IA2_EVENT_DOCUMENT_CONTENT_CHANGED,
+
+  /** The loading of the document has completed.
+  */
+  IA2_EVENT_DOCUMENT_LOAD_COMPLETE,
+
+  /** The loading of the document was interrupted.
+  */
+  IA2_EVENT_DOCUMENT_LOAD_STOPPED,
+
+  /** The document contents are being reloaded.
+  */
+  IA2_EVENT_DOCUMENT_RELOAD,
+
+  /** The ending index of this link within the containing string has changed.
+  */
+  IA2_EVENT_HYPERLINK_END_INDEX_CHANGED,
+
+  /** The number of anchors associated with this hyperlink object has changed.
+  */
+  IA2_EVENT_HYPERLINK_NUMBER_OF_ANCHORS_CHANGED,
+
+  /** The hyperlink selected state changed from selected to unselected or
+    from unselected to selected.
+  */
+  IA2_EVENT_HYPERLINK_SELECTED_LINK_CHANGED,
+
+  /** One of the links associated with the hypertext object has been activated.
+  */
+  IA2_EVENT_HYPERTEXT_LINK_ACTIVATED,
+
+  /** One of the links associated with the hypertext object has been selected.
+  */
+  IA2_EVENT_HYPERTEXT_LINK_SELECTED,
+
+  /** The starting index of this link within the containing string has changed.
+  */
+  IA2_EVENT_HYPERLINK_START_INDEX_CHANGED,
+
+  /** Focus has changed from one hypertext object to another, or focus moved
+   from a non-hypertext object to a hypertext object, or focus moved from a
+   hypertext object to a non-hypertext object.
+  */
+  IA2_EVENT_HYPERTEXT_CHANGED,
+
+  /** The number of hyperlinks associated with a hypertext object changed
+  */
+  IA2_EVENT_HYPERTEXT_NLINKS_CHANGED,
+
+  /** An object's attributes changed.
+  Also see ::IA2_EVENT_TEXT_ATTRIBUTE_CHANGED.
+  */
+  IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED,
+
+  /** A slide changed in a presentation document or a page boundary was
+   crossed in a word processing document.
+  */
+  IA2_EVENT_PAGE_CHANGED,
+
+  /** The caret moved from one section to the next.
+  */
+  IA2_EVENT_SECTION_CHANGED,
+
+  /** A table caption changed.
+  */
+  IA2_EVENT_TABLE_CAPTION_CHANGED,
+
+  /** A table's column description changed.
+  */
+  IA2_EVENT_TABLE_COLUMN_DESCRIPTION_CHANGED,
+
+  /** A table's column header changed.
+  */
+  IA2_EVENT_TABLE_COLUMN_HEADER_CHANGED,
+
+  /** A table's data changed.
+  */
+  IA2_EVENT_TABLE_MODEL_CHANGED,
+
+  /** A table's row description changed.
+  */
+  IA2_EVENT_TABLE_ROW_DESCRIPTION_CHANGED,
+
+  /** A table's row header changed.
+  */
+  IA2_EVENT_TABLE_ROW_HEADER_CHANGED,
+
+  /** A table's summary changed.
+  */
+  IA2_EVENT_TABLE_SUMMARY_CHANGED,
+
+  /** A text object's attributes changed.
+  Also see ::IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED.
+  */
+  IA2_EVENT_TEXT_ATTRIBUTE_CHANGED,
+
+  /** The caret has moved to a new position.
+  */
+  IA2_EVENT_TEXT_CARET_MOVED,
+
+  /** <b>Deprecated.</b>  This event is equivalent to ::IA2_EVENT_TEXT_UPDATED.
+  */
+  IA2_EVENT_TEXT_CHANGED,
+
+  /** The caret moved from one column to the next.
+  */
+  IA2_EVENT_TEXT_COLUMN_CHANGED,
+
+  /** Text was inserted.
+  */
+  IA2_EVENT_TEXT_INSERTED,
+
+  /** Text was removed.
+  */
+  IA2_EVENT_TEXT_REMOVED,
+
+  /** This event indicates general text changes, i.e. changes to text that are
+    exposed through the IAccessibleText interface.  For compatibility with ATK/AT-SPI
+	which does not have an equivalent event, servers can alternatively fire
+	::IA2_EVENT_TEXT_REMOVED and ::IA2_EVENT_TEXT_INSERTED.
+  */
+  IA2_EVENT_TEXT_UPDATED,
+
+  /** The text selection changed.  Later versions of Microsoft development environments
+   have an equivalent event identified, EVENT_OBJECT_TEXTSELECTIONCHANGED.  Servers
+   should use that if it is available and use IA2_EVENT_TEXT_SELECTION_CHANGED otherwise.
+   Clients should be prepared to respond to either event.
+
+  */
+  IA2_EVENT_TEXT_SELECTION_CHANGED,
+
+  /** A visible data event indicates the change of the visual appearance
+    of an accessible object.  This includes for example most of the
+    attributes available via the IAccessibleComponent interface.
+  */
+  IA2_EVENT_VISIBLE_DATA_CHANGED,
+
+  /** The role changed. This should only be used if the interfaces supported by the object
+   did not also change. If the interfaces need to change, the object should be destroyed
+   and a new object created.
+  */
+  IA2_EVENT_ROLE_CHANGED
+};
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleApplication.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2010 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+
+/** @brief This interface gives access to the application's name and version information.
+
+ This interface provides the AT with the information it needs to differentiate
+ this application from other applications, from other versions of this
+ application, or from other versions of this application running on different
+ versions of an accessibility bridge or accessibility toolkit.
+
+ Servers implementing IAccessible2 should provide access to the %IAccessibleApplication
+ interface via QueryService from any object so that ATs can easily determine specific
+ information about the application such as its name or version.
+*/
+[object, uuid(D49DED83-5B25-43F4-9B95-93B44595979E)]
+interface IAccessibleApplication : IUnknown
+{
+
+  /** @brief Returns the application name.
+   @param [out] name
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT appName
+    (
+     [out, retval] BSTR *name
+    );
+
+  /** @brief Returns the application version.
+   @param [out] version
+    The version string must not contain levels when it is know beforehand that
+    this information will never require a change in a client's behavior.
+    For example, use "3.6.0" rather than "3.6.0.v201005131500".
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT appVersion
+    (
+     [out, retval] BSTR *version
+    );
+
+  /** @brief Returns the toolkit/bridge name.
+   @param [out] name
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT toolkitName
+    (
+     [out, retval] BSTR *name
+    );
+
+  /** @brief Returns the toolkit/bridge version.
+   @param [out] version
+    The version string must not contain levels when it is know beforehand that
+    this information will never require a change in a client's behavior.
+    For example, use "3.6.0" rather than "3.6.0.v201005131500".
+   @retval S_OK
+   @retval S_FALSE if there is nothing to return, [out] value is NULL
+  */
+  [propget] HRESULT toolkitVersion
+    (
+     [out, retval] BSTR *version
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (AccessibleDocument.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2013 Linux Foundation
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+/** @brief This interface represents documents.
+
+ This interface is used for a representation of documents.
+*/
+[object, uuid(C48C7FCF-4AB5-4056-AFA6-902D6E1D1149)]
+interface IAccessibleDocument : IUnknown
+{
+  /** @brief Returns the most recently used anchor target within a document.
+
+   A document's most recently targeted in-page anchor is returned.  A typical use
+    of this method is to fetch the anchor target within an HTML document.  In this
+    case anchor targets are those which has been defined with the <a> tag.
+
+   @param [out] accessible
+   @retval S_OK
+   @retval S_FALSE if there are no existing valid anchor targets, [out] value is NULL.
+  */
+  [propget] HRESULT anchorTarget
+    (
+     [out, retval] IUnknown **accessible
+    );
+
+}
+
+/*************************************************************************
+ *
+ *  File Name (IA2TypeLibrary.idl)
+ *
+ *  IAccessible2 IDL Specification
+ *
+ *  Copyright (c) 2007, 2012 Linux Foundation
+ *  Copyright (c) 2006 IBM Corporation
+ *  Copyright (c) 2000, 2006 Sun Microsystems, Inc.
+ *  All rights reserved.
+ *
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *
+ *   2. Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following
+ *      disclaimer in the documentation and/or other materials
+ *      provided with the distribution.
+ *
+ *   3. Neither the name of the Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products
+ *      derived from this software without specific prior written
+ *      permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  This BSD License conforms to the Open Source Initiative "Simplified
+ *  BSD License" as published at:
+ *  http://www.opensource.org/licenses/bsd-license.php
+ *
+ *  IAccessible2 is a trademark of the Linux Foundation. The IAccessible2
+ *  mark may be used in accordance with the Linux Foundation Trademark
+ *  Policy to indicate compliance with the IAccessible2 specification.
+ *
+ ************************************************************************/
+
+// This is not a standalone file.  It is to be appended to the end of the
+// merged IDL file.
+
+cpp_quote("")
+cpp_quote("// Type Library Definitions")
+cpp_quote("")
+
+[
+    uuid(CE3F726E-D1D3-44FE-B995-FF1DB3B48B2B),
+    helpstring("IAccessible2 Type Library"),
+    version(1.3),
+]
+
+library IAccessible2Lib
+{
+    importlib ("stdole2.tlb");
+    interface IAccessible2;
+    interface IAccessible2_2;
+    interface IAccessible2_3;
+    interface IAccessibleAction;
+    interface IAccessibleApplication;
+    interface IAccessibleComponent;
+    interface IAccessibleDocument;
+    interface IAccessibleEditableText;
+    interface IAccessibleHyperlink;
+    interface IAccessibleHypertext;
+    interface IAccessibleHypertext2;
+    interface IAccessibleImage;
+    interface IAccessibleRelation;
+    interface IAccessibleTable;
+    interface IAccessibleTable2;
+    interface IAccessibleTableCell;
+    interface IAccessibleText;
+/*    interface IAccessibleText2;*/
+    interface IAccessibleValue;
+    enum IA2CoordinateType;
+    enum IA2EventID;
+    enum IA2Role;
+    enum IA2ScrollType;
+    enum IA2States;
+    enum IA2TableModelChangeType;
+    enum IA2TextBoundaryType;
+    enum IA2TextSpecialOffsets;
+}
From ea147313669c87ed675cbbccf34832aa30b6713d Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Wed, 28 Jul 2021 13:09:32 -0400
Subject: [PATCH] uiautomationcore: Begin adding IAccessible2 support.

Incomplete, but enough to get IAccessible2 applications (I.e chromium)
to start firing EVENT_OBJECT_FOCUS events for all accessible objects.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_client.c  | 32 +++++++++++++++++++++++++++++
 dlls/uiautomationcore/uia_event.c   | 15 +++++++++++++-
 dlls/uiautomationcore/uia_private.h |  3 +++
 3 files changed, 49 insertions(+), 1 deletion(-)

diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index 46c72f76ddf..b09a8f46363 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -1737,6 +1737,36 @@ HRESULT create_uia_elem_from_raw_provider(IUIAutomationElement **iface,
     return S_OK;
 }

+static void uia_test_iaccessible2(IAccessible *acc, INT child_id)
+{
+    IServiceProvider *serv_prov;
+    IAccessible2 *acc2;
+    HRESULT hr;
+    HWND parent_win;
+    LONG tmp;
+
+    hr = IAccessible_QueryInterface(acc, &IID_IServiceProvider, (void **)&serv_prov);
+    if (FAILED(hr))
+        return;
+
+    TRACE("Got IServiceProvider, passed first step.\n");
+    hr = IServiceProvider_QueryService(serv_prov, &IID_IAccessible, &IID_IAccessible2, (void **)&acc2);
+    if (FAILED(hr))
+    {
+        IServiceProvider_Release(serv_prov);
+        return;
+    }
+
+    TRACE("Got IAccessible2 interface, success!\n");
+    hr = IAccessible2_get_uniqueID(acc2, &tmp);
+    hr = IAccessible2_get_windowHandle(acc2, &parent_win);
+    if (SUCCEEDED(hr))
+        TRACE("Child_id %d, UniqueID %d, hwnd %p!\n", child_id, tmp, parent_win);
+
+    IServiceProvider_Release(serv_prov);
+    IAccessible2_Release(acc2);
+}
+
 HRESULT create_uia_elem_from_msaa_acc(IUIAutomationElement **iface,
         IAccessible *wrap, INT child_id)
 {
@@ -1753,5 +1783,7 @@ HRESULT create_uia_elem_from_msaa_acc(IUIAutomationElement **iface,
     V_VT(&uia->child_id) = VT_I4;
     V_I4(&uia->child_id) = child_id;

+    uia_test_iaccessible2(wrap, child_id);
+
     return S_OK;
 }
diff --git a/dlls/uiautomationcore/uia_event.c b/dlls/uiautomationcore/uia_event.c
index fcb0907101c..d31bb5192f3 100644
--- a/dlls/uiautomationcore/uia_event.c
+++ b/dlls/uiautomationcore/uia_event.c
@@ -276,6 +276,17 @@ static EVENTID uia_msaa_event_to_uia_event_id(LONG obj_id, LONG event)
     return 0;
 }

+/*
+ * Event hook callback for IAccessible2 events.
+ */
+void CALLBACK uia_evl_ia2_event_proc(HWINEVENTHOOK hWinEventHook, DWORD event,
+        HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread,
+        DWORD dwmsEventTime)
+{
+    TRACE("hook %p, event %d, hwnd %p, obj_id %#x, child_id %#x, tid %#x, time %d\n",
+            hWinEventHook, event, hwnd, idObject, idChild, idEventThread, dwmsEventTime);
+}
+
 /*
  * Event hook callback for window creation events.
  */
@@ -419,7 +430,8 @@ static HRESULT uia_event_listener_thread_initialize(struct uia_evl *evl)
             EVENT_OBJECT_FOCUS, 0, uia_evl_msaa_obj_focus_proc, 0, 0, WINEVENT_OUTOFCONTEXT);
     evl->win_creation_hook = SetWinEventHook(EVENT_OBJECT_CREATE,
             EVENT_OBJECT_CREATE, 0, uia_evl_window_create_proc, 0, 0, WINEVENT_OUTOFCONTEXT);
-
+    evl->ia2_event_hook = SetWinEventHook(IA2_EVENT_ACTION_CHANGED, IA2_EVENT_ROLE_CHANGED, 0, uia_evl_ia2_event_proc,
+            0, 0, WINEVENT_OUTOFCONTEXT);
     /*
      * Create interface to be passed to providers so that they can signal
      * events to active listeners.
@@ -437,6 +449,7 @@ static void uia_event_listener_thread_exit(struct uia_evl *evl)

     UnhookWinEvent(evl->object_focus_hook);
     UnhookWinEvent(evl->win_creation_hook);
+    UnhookWinEvent(evl->ia2_event_hook);

     CoDisconnectObject((IUnknown *)evl->evlc_iface, 0);
     IUIAEvlConnection_Release(evl->evlc_iface);
diff --git a/dlls/uiautomationcore/uia_private.h b/dlls/uiautomationcore/uia_private.h
index 2f329206251..513738c42f5 100644
--- a/dlls/uiautomationcore/uia_private.h
+++ b/dlls/uiautomationcore/uia_private.h
@@ -18,6 +18,8 @@

 #include "uiautomation.h"
 #include "oleacc.h"
+#include "ia2api.h"
+#include "servprov.h"

 #include "wine/list.h"

@@ -95,6 +97,7 @@ struct uia_evl

     HWINEVENTHOOK win_creation_hook;
     HWINEVENTHOOK object_focus_hook;
+    HWINEVENTHOOK ia2_event_hook;
     IUIAEvlConnection *evlc_iface;

     struct uia_data *data;
From d06aa06904d809afec1cd3c555cce1845d099430 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Wed, 8 Sep 2021 13:11:21 -0400
Subject: [PATCH] uiautomationcore: Implement bounding rectangle property ID.

Implement MSAA mappings and default values for
UIA_BoundingRectanglePropertyId.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_client.c | 88 ++++++++++++++++++++++++++++--
 1 file changed, 84 insertions(+), 4 deletions(-)

diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index b09a8f46363..312cac97fe7 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -740,6 +740,24 @@ static INT uia_msaa_role_to_uia_control_type(INT role)
     return UIA_ButtonControlTypeId;
 }

+static void uia_create_bounding_rect_variant(double left, double top,
+        double width, double height, VARIANT *arr_out)
+{
+    SAFEARRAYBOUND sab = { 0 };
+    LPSAFEARRAY lpsa;
+
+    sab.cElements = 4;
+    lpsa = SafeArrayCreate(VT_R8, 1, &sab);
+    ((double *)lpsa->pvData)[0] = left;
+    ((double *)lpsa->pvData)[1] = top;
+    ((double *)lpsa->pvData)[2] = width;
+    ((double *)lpsa->pvData)[3] = height;
+
+    VariantInit(arr_out);
+    V_VT(arr_out) = VT_R8 | VT_ARRAY;
+    V_ARRAY(arr_out) = lpsa;
+}
+
 static void uia_get_default_property_val(PROPERTYID propertyId, VARIANT *retVal)
 {
     switch (propertyId)
@@ -760,6 +778,10 @@ static void uia_get_default_property_val(PROPERTYID propertyId, VARIANT *retVal)
         V_BOOL(retVal) = VARIANT_FALSE;
         break;

+    case UIA_BoundingRectanglePropertyId:
+        uia_create_bounding_rect_variant(0, 0, 0, 0, retVal);
+        break;
+
     default:
         FIXME("Unimplemented default value for PropertyId %d!\n", propertyId);
         V_VT(retVal) = VT_EMPTY;
@@ -775,7 +797,34 @@ static HRESULT uia_get_uia_elem_prov_property_val(IRawElementProviderSimple *ele

     VariantInit(&res);
     *use_default = TRUE;
-    hr = IRawElementProviderSimple_GetPropertyValue(elem_prov, propertyId, &res);
+    switch (propertyId)
+    {
+    case UIA_BoundingRectanglePropertyId:
+    {
+        IRawElementProviderFragment *elem_frag;
+
+        hr = IRawElementProviderSimple_QueryInterface(elem_prov,
+                &IID_IRawElementProviderFragment, (void **)&elem_frag);
+        if (SUCCEEDED(hr))
+        {
+            struct UiaRect rect;
+
+            hr = IRawElementProviderFragment_get_BoundingRectangle(elem_frag, &rect);
+            IRawElementProviderFragment_Release(elem_frag);
+            if (SUCCEEDED(hr))
+            {
+                uia_create_bounding_rect_variant(rect.left, rect.top, rect.width, rect.height, &res);
+                break;
+            }
+        }
+        hr = IRawElementProviderSimple_GetPropertyValue(elem_prov, propertyId, &res);
+    }
+        break;
+
+    default:
+        hr = IRawElementProviderSimple_GetPropertyValue(elem_prov, propertyId, &res);
+        break;
+    }

     /* VT_EMPTY means this PropertyId is unimplemented/unsupported. */
     if (V_VT(&res) != VT_EMPTY && SUCCEEDED(hr))
@@ -848,6 +897,20 @@ static HRESULT uia_get_msaa_acc_property_val(IAccessible *acc,
         }
         break;

+    case UIA_BoundingRectanglePropertyId:
+    {
+        LONG left, top, width, height;
+
+        hr = IAccessible_accLocation(acc, &left, &top, &width, &height, child_id);
+        if (SUCCEEDED(hr))
+        {
+            uia_create_bounding_rect_variant((double)left, (double)top,
+                    (double)width, (double)height, retVal);
+            *use_default = FALSE;
+        }
+    }
+        break;
+
     default:
         FIXME("UIA PropertyId %d unimplemented for IAccessible!\n", propertyId);
         break;
@@ -1284,9 +1347,26 @@ static HRESULT WINAPI uia_elem_get_CurrentItemStatus(IUIAutomationElement *iface
 static HRESULT WINAPI uia_elem_get_CurrentBoundingRectangle(IUIAutomationElement *iface,
         RECT *retVal)
 {
-    struct uia_elem_data *This = impl_from_IUIAutomationElement(iface);
-    FIXME("%p\n", This);
-    return E_NOTIMPL;
+    VARIANT res;
+    HRESULT hr;
+
+    TRACE("%p %p\n", iface, retVal);
+
+    memset(retVal, 0, sizeof(*retVal));
+    hr = IUIAutomationElement_GetCurrentPropertyValue(iface,
+            UIA_BoundingRectanglePropertyId, &res);
+    if (FAILED(hr))
+        return hr;
+
+    if (V_VT(&res) == (VT_R8 | VT_ARRAY))
+    {
+        retVal->left = (LONG)((double *)V_ARRAY(&res)->pvData)[0];
+        retVal->top = (LONG)((double *)V_ARRAY(&res)->pvData)[1];
+        retVal->right = retVal->left + (LONG)((double *)V_ARRAY(&res)->pvData)[2];
+        retVal->bottom = retVal->top + (LONG)((double *)V_ARRAY(&res)->pvData)[3];
+    }
+
+    return S_OK;
 }

 static HRESULT WINAPI uia_elem_get_CurrentLabeledBy(IUIAutomationElement *iface,
From 6ca562b432aa52fafbcacd1109ec730e1d5a417e Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Wed, 8 Sep 2021 18:04:33 -0400
Subject: [PATCH] tabtip: Retrieve bounding rectangle for focused element.

Retrieve the bounding rectangle of the focused accessible object, and
pass this data to the steam OSK link if it's retrieved.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 programs/tabtip/tabtip.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/programs/tabtip/tabtip.c b/programs/tabtip/tabtip.c
index 18b8ae32ef8..18c87042658 100644
--- a/programs/tabtip/tabtip.c
+++ b/programs/tabtip/tabtip.c
@@ -155,12 +155,14 @@ HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChanged
     WINE_TRACE("This %p, sender %p\n", This, sender);
     if (sender)
     {
+        RECT rect = { 0 };
         VARIANT var;
         INT ct_id;
         BSTR name;

         IUIAutomationElement_get_CurrentControlType(sender, &ct_id);
         IUIAutomationElement_get_CurrentName(sender, &name);
+        IUIAutomationElement_get_CurrentBoundingRectangle(sender, &rect);
         IUIAutomationElement_GetCurrentPropertyValue(sender, UIA_IsKeyboardFocusablePropertyId, &var);

         if ((last_keyup_event < (GetTickCount() - 5000)) &&
@@ -170,7 +172,16 @@ HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChanged
             {
                 WINE_TRACE("Keyboard up!\n");
                 keyboard_up = TRUE;
-                ShellExecuteW(NULL, NULL, L"steam://open/keyboard", NULL, NULL, SW_SHOWNOACTIVATE);
+                if (rect.left || rect.top || rect.right || rect.bottom)
+                {
+                    WCHAR link_buf[1024];
+
+                    wsprintfW(link_buf, L"steam://open/keyboard?XPosition=%d&YPosition=%d&Width=%d&Height=%d&Mode=0",
+                            rect.left, rect.top, (rect.right - rect.left), (rect.bottom - rect.top));
+                    ShellExecuteW(NULL, NULL, link_buf, NULL, NULL, SW_SHOWNOACTIVATE);
+                }
+                else
+                    ShellExecuteW(NULL, NULL, L"steam://open/keyboard", NULL, NULL, SW_SHOWNOACTIVATE);

                 last_keyup_event = GetTickCount();
             }
@@ -189,7 +200,8 @@ HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChanged
         else
             ct_id = 0;

-        WINE_TRACE("element name: %s, ct_id %s\n", wine_dbgstr_w(name), ct_id_str[ct_id]);
+        WINE_TRACE("element name: %s, ct_id %s, rect { %d, %d } - { %d, %d }\n", wine_dbgstr_w(name), ct_id_str[ct_id],
+                rect.left, rect.top, rect.right, rect.bottom);
     }

     return S_OK;
From 590f393df6e72993f9cfae8de7360514a2b4fd43 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Thu, 9 Sep 2021 14:02:08 -0400
Subject: [PATCH] tabtip: Only trigger steam OSK link if we're running on Steam
 Deck.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 programs/tabtip/tabtip.c | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/programs/tabtip/tabtip.c b/programs/tabtip/tabtip.c
index 18c87042658..6938eb3924f 100644
--- a/programs/tabtip/tabtip.c
+++ b/programs/tabtip/tabtip.c
@@ -55,6 +55,7 @@ typedef struct {

 DWORD last_keyup_event;
 BOOL keyboard_up;
+BOOL use_steam_osk;

 static const char *ct_id_str[] = {
     "UIA_ButtonControlTypeId (50000)",
@@ -165,7 +166,7 @@ HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChanged
         IUIAutomationElement_get_CurrentBoundingRectangle(sender, &rect);
         IUIAutomationElement_GetCurrentPropertyValue(sender, UIA_IsKeyboardFocusablePropertyId, &var);

-        if ((last_keyup_event < (GetTickCount() - 5000)) &&
+        if (use_steam_osk && (last_keyup_event < (GetTickCount() - 5000)) &&
                 ct_id == UIA_EditControlTypeId && (V_VT(&var) == VT_BOOL && V_BOOL(&var)))
         {
             if (!keyboard_up)
@@ -259,6 +260,18 @@ static DWORD WINAPI tabtip_exit_watcher(LPVOID lpParam)
     return 0;
 }

+static void tabtip_use_osk_check(void)
+{
+    const char *var = getenv("SteamDeck");
+
+    if (var && !strcmp(var, "1"))
+        use_steam_osk = TRUE;
+    else
+        use_steam_osk = FALSE;
+
+    WINE_TRACE("use_steam_osk=%d\n", use_steam_osk);
+}
+
 int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)
 {
     HANDLE wine_exit_event, pgm_exit_event, started_event;
@@ -275,6 +288,7 @@ int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine
     wine_exit_event = pgm_exit_event = started_event = NULL;
     last_keyup_event = 0;
     keyboard_up = FALSE;
+    tabtip_use_osk_check();

     NtSetInformationProcess( GetCurrentProcess(), ProcessWineMakeProcessSystem,
                              &wine_exit_event, sizeof(HANDLE *) );
From 64a7057ed114dfce6135c6471797a59ea7b65d9e Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 23 Aug 2021 10:24:29 -0400
Subject: [PATCH] uiautomationcore: Added UiaRaiseStructureChangedEvent stub.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/uiautomationcore/uia_main.c            | 10 ++++++++++
 dlls/uiautomationcore/uiautomationcore.spec |  2 +-
 include/uiautomationcoreapi.h               |  2 ++
 3 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/dlls/uiautomationcore/uia_main.c b/dlls/uiautomationcore/uia_main.c
index 952a9d47a0d..c2466aa2697 100644
--- a/dlls/uiautomationcore/uia_main.c
+++ b/dlls/uiautomationcore/uia_main.c
@@ -428,6 +428,16 @@ HRESULT WINAPI UiaRaiseAutomationPropertyChangedEvent(IRawElementProviderSimple
     return S_OK;
 }

+/***********************************************************************
+ *          UiaRaiseStructureChangedEvent (uiautomationcore.@)
+ */
+HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple *provider, enum StructureChangeType struct_change_type,
+                                             int *runtime_id, int runtime_id_len)
+{
+    FIXME("(%p, %d, %p, %d): stub\n", provider, struct_change_type, runtime_id, runtime_id_len);
+    return S_OK;
+}
+
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *callback)
 {
     FIXME("(%p): stub\n", callback);
diff --git a/dlls/uiautomationcore/uiautomationcore.spec b/dlls/uiautomationcore/uiautomationcore.spec
index 93d4e130799..15e0d4dd3c7 100644
--- a/dlls/uiautomationcore/uiautomationcore.spec
+++ b/dlls/uiautomationcore/uiautomationcore.spec
@@ -89,7 +89,7 @@
 @ stdcall UiaRaiseAutomationPropertyChangedEvent(ptr long int128 int128)
 #@ stub UiaRaiseChangesEvent
 #@ stub UiaRaiseNotificationEvent
-@ stub UiaRaiseStructureChangedEvent
+@ stdcall UiaRaiseStructureChangedEvent(ptr long ptr long)
 #@ stub UiaRaiseTextEditTextChangedEvent
 @ stdcall UiaRegisterProviderCallback(ptr)
 @ stub UiaRemoveEvent
diff --git a/include/uiautomationcoreapi.h b/include/uiautomationcoreapi.h
index 563d5c602bd..0cdf9e4b6bb 100644
--- a/include/uiautomationcoreapi.h
+++ b/include/uiautomationcoreapi.h
@@ -67,6 +67,8 @@ int WINAPI UiaLookupId(enum AutomationIdentifierType type, const GUID *guid);
 BOOL WINAPI UiaPatternRelease(HUIAPATTERNOBJECT hobj);
 HRESULT WINAPI UiaRaiseAutomationEvent(IRawElementProviderSimple *provider, EVENTID id);
 HRESULT WINAPI UiaRaiseAutomationPropertyChangedEvent(IRawElementProviderSimple *provider, PROPERTYID id, VARIANT old, VARIANT new);
+HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple *provider, enum StructureChangeType struct_change_type,
+                                             int *runtime_id, int runtime_id_len);
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *pCallback);
 LRESULT WINAPI UiaReturnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple *elprov);
 BOOL WINAPI UiaTextRangeRelease(HUIATEXTRANGE hobj);
From 075f6f028e60373fe3df1b246bf441967164b0bd Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 26 Jul 2021 23:18:46 -0400
Subject: [PATCH] wineboot: HACK: Run tabtip.exe on startup.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 programs/wineboot/wineboot.c | 37 ++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index 14d12883813..8c4e253100f 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -1296,6 +1296,40 @@ static BOOL start_services_process(void)
     return TRUE;
 }

+static BOOL start_tabtip_process(void)
+{
+    static const WCHAR tabtip_started_event[] = L"TABTIP_STARTED_EVENT";
+    PROCESS_INFORMATION pi;
+    STARTUPINFOW si = { sizeof(si) };
+    HANDLE wait_handles[2];
+
+    if (!CreateProcessW(L"C:\\windows\\system32\\tabtip.exe", NULL,
+                        NULL, NULL, TRUE, DETACHED_PROCESS, NULL, NULL, &si, &pi))
+    {
+        WINE_ERR("Couldn't start tabtip.exe: error %u\n", GetLastError());
+        return FALSE;
+    }
+    CloseHandle(pi.hThread);
+
+    wait_handles[0] = CreateEventW(NULL, TRUE, FALSE, tabtip_started_event);
+    wait_handles[1] = pi.hProcess;
+
+    /* wait for the event to become available or the process to exit */
+    if ((WaitForMultipleObjects(2, wait_handles, FALSE, INFINITE)) == WAIT_OBJECT_0 + 1)
+    {
+        DWORD exit_code;
+        GetExitCodeProcess(pi.hProcess, &exit_code);
+        WINE_ERR("Unexpected termination of tabtip.exe - exit code %d\n", exit_code);
+        CloseHandle(pi.hProcess);
+        CloseHandle(wait_handles[0]);
+        return FALSE;
+    }
+
+    CloseHandle(pi.hProcess);
+    CloseHandle(wait_handles[0]);
+    return TRUE;
+}
+
 static HANDLE start_rundll32( const WCHAR *inf_path, const WCHAR *install, WORD machine )
 {
     WCHAR app[MAX_PATH + ARRAY_SIZE(L"\\rundll32.exe" )];
@@ -1713,6 +1747,9 @@ int __cdecl main( int argc, char *argv[] )
     {
         ProcessRunKeys( HKEY_LOCAL_MACHINE, L"RunServices", FALSE, FALSE );
         start_services_process();
+
+        /* FIXME: hack, run tabtip.exe on startup. */
+        start_tabtip_process();
     }
     if (init || update) update_wineprefix( update );

From c51eac4533e7ef2b60854d43a90257cc1b14b85f Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Thu, 29 Jul 2021 20:34:33 -0400
Subject: [PATCH] HACK: setupapi: Make sure dlls are updated in proton wine
 prefix.

Due to Proton's wine prefix containing read-only symlinks to dll files,
install_fake_dll fails to get a valid file handle to write to, which
means register_fake_dll is never called. To get around this, check if we
got a read-only file handle, and if the sizes match, set the handle to
NUL so the write completes and the dll ends up registered.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
CW-Bug-Id: #18351
---
 dlls/setupapi/fakedll.c | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/dlls/setupapi/fakedll.c b/dlls/setupapi/fakedll.c
index 1ce15d937eb..a930baf7da8 100644
--- a/dlls/setupapi/fakedll.c
+++ b/dlls/setupapi/fakedll.c
@@ -503,6 +503,7 @@ static HANDLE create_dest_file( const WCHAR *name, BOOL delete )
     }
     else if (!delete)
     {
+        if (GetLastError() == ERROR_ACCESS_DENIED) return 0;
         if (GetLastError() == ERROR_PATH_NOT_FOUND) create_directories( name );

         h = CreateFileW( name, GENERIC_WRITE, 0, NULL, CREATE_NEW, 0, NULL );
@@ -512,6 +513,28 @@ static HANDLE create_dest_file( const WCHAR *name, BOOL delete )
     return h;
 }

+static HANDLE check_dest_file_size_match( const WCHAR *name, SIZE_T size )
+{
+    HANDLE h = CreateFileW( name, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL );
+    if (h && h != INVALID_HANDLE_VALUE)
+    {
+        LARGE_INTEGER li;
+
+        if (GetFileSizeEx(h, &li) && (size == li.QuadPart))
+        {
+            CloseHandle( h );
+            h = CreateFileW( L"nul", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL );
+        }
+        else
+        {
+            ERR( "Incorrect file size for %s, not registering!\n", debugstr_w(name) );
+            CloseHandle ( h );
+            h = 0;
+        }
+    }
+    return h;
+}
+
 /* XML parsing code copied from ntdll */

 typedef struct
@@ -909,6 +932,17 @@ static int install_fake_dll( WCHAR *dest, WCHAR *file, BOOL delete, struct list
     {
         HANDLE h = create_dest_file( dest, delete );

+        /*
+         * In Proton, prefixes contain read-only symlinks to dll's, so there's
+         * no need to copy anything. However, we still want to make sure new
+         * dll's are registered properly. So, check if we seem to have a
+         * matching file by checking if their sizes match, and if we do,
+         * just set the handle to NUL for the write and allow register_fake_dll
+         * to run.
+         */
+        if (!h && GetLastError() == ERROR_ACCESS_DENIED)
+            h = check_dest_file_size_match( dest, size );
+
         if (h && h != INVALID_HANDLE_VALUE)
         {
             TRACE( "%s -> %s\n", debugstr_w(file), debugstr_w(dest) );
From a8fb837cd58181ff3883709df12280ee69bfe39b Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 11 Oct 2021 20:21:00 -0400
Subject: [PATCH] uiautomationcore: Add UiaRaiseAsyncContentLoadedEvent stub.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
---
 dlls/uiautomationcore/uia_main.c            | 11 +++++++++++
 dlls/uiautomationcore/uiautomationcore.spec |  2 +-
 include/uiautomationcoreapi.h               |  8 ++++++++
 3 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/dlls/uiautomationcore/uia_main.c b/dlls/uiautomationcore/uia_main.c
index c2466aa2697..ca5b0062080 100644
--- a/dlls/uiautomationcore/uia_main.c
+++ b/dlls/uiautomationcore/uia_main.c
@@ -438,6 +438,17 @@ HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple *provider
     return S_OK;
 }

+/***********************************************************************
+ *          UiaRaiseAsyncContentLoadedEvent (uiautomationcore.@)
+ */
+HRESULT WINAPI UiaRaiseAsyncContentLoadedEvent(IRawElementProviderSimple *provider,
+                                                enum AsyncContentLoadedState async_content_loaded_state,
+                                                double percent_complete)
+{
+    FIXME("(%p, %d, %f): stub\n", provider, async_content_loaded_state, percent_complete);
+    return S_OK;
+}
+
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *callback)
 {
     FIXME("(%p): stub\n", callback);
diff --git a/dlls/uiautomationcore/uiautomationcore.spec b/dlls/uiautomationcore/uiautomationcore.spec
index 15e0d4dd3c7..161c4f6a734 100644
--- a/dlls/uiautomationcore/uiautomationcore.spec
+++ b/dlls/uiautomationcore/uiautomationcore.spec
@@ -84,7 +84,7 @@
 @ stub UiaPatternRelease
 #@ stub UiaProviderForNonClient
 #@ stub UiaProviderFromIAccessible
-@ stub UiaRaiseAsyncContentLoadedEvent
+@ stdcall UiaRaiseAsyncContentLoadedEvent(ptr long double)
 @ stdcall UiaRaiseAutomationEvent(ptr long)
 @ stdcall UiaRaiseAutomationPropertyChangedEvent(ptr long int128 int128)
 #@ stub UiaRaiseChangesEvent
diff --git a/include/uiautomationcoreapi.h b/include/uiautomationcoreapi.h
index 0cdf9e4b6bb..8f5ebe91ea9 100644
--- a/include/uiautomationcoreapi.h
+++ b/include/uiautomationcoreapi.h
@@ -59,6 +59,12 @@ enum ProviderType
     ProviderType_NonClientArea,
 };

+enum AsyncContentLoadedState {
+    AsyncContentLoadedState_Beginning,
+    AsyncContentLoadedState_Progress,
+    AsyncContentLoadedState_Completed,
+};
+
 typedef SAFEARRAY * WINAPI UiaProviderCallback(HWND hwnd,enum ProviderType providerType);

 HRESULT WINAPI UiaGetReservedMixedAttributeValue(IUnknown **value);
@@ -67,6 +73,8 @@ int WINAPI UiaLookupId(enum AutomationIdentifierType type, const GUID *guid);
 BOOL WINAPI UiaPatternRelease(HUIAPATTERNOBJECT hobj);
 HRESULT WINAPI UiaRaiseAutomationEvent(IRawElementProviderSimple *provider, EVENTID id);
 HRESULT WINAPI UiaRaiseAutomationPropertyChangedEvent(IRawElementProviderSimple *provider, PROPERTYID id, VARIANT old, VARIANT new);
+HRESULT WINAPI UiaRaiseAsyncContentLoadedEvent(IRawElementProviderSimple *provider,
+                                                enum AsyncContentLoadedState async_content_loaded_state, double percent_complete);
 HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple *provider, enum StructureChangeType struct_change_type,
                                              int *runtime_id, int runtime_id_len);
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *pCallback);
From 7f6ca308619f76d3b84a7526a7b924a198a43f1e Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 11 Oct 2021 20:26:30 -0400
Subject: [PATCH] uiautomationcore: Add UiaRaiseTextEditTextChangedEvent stub.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
---
 dlls/uiautomationcore/uia_main.c            | 10 ++++++++++
 dlls/uiautomationcore/uiautomationcore.spec |  2 +-
 include/uiautomationcoreapi.h               |  2 ++
 3 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/dlls/uiautomationcore/uia_main.c b/dlls/uiautomationcore/uia_main.c
index ca5b0062080..384191d5350 100644
--- a/dlls/uiautomationcore/uia_main.c
+++ b/dlls/uiautomationcore/uia_main.c
@@ -449,6 +449,16 @@ HRESULT WINAPI UiaRaiseAsyncContentLoadedEvent(IRawElementProviderSimple *provid
     return S_OK;
 }

+/***********************************************************************
+ *          UiaRaiseTextEditTextChangedEvent (uiautomationcore.@)
+ */
+HRESULT WINAPI UiaRaiseTextEditTextChangedEvent(IRawElementProviderSimple *provider,
+        enum TextEditChangeType text_edit_change_type, SAFEARRAY *changed_data)
+{
+    FIXME("(%p, %d, %p): stub\n", provider, text_edit_change_type, changed_data);
+    return S_OK;
+}
+
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *callback)
 {
     FIXME("(%p): stub\n", callback);
diff --git a/dlls/uiautomationcore/uiautomationcore.spec b/dlls/uiautomationcore/uiautomationcore.spec
index 161c4f6a734..ef7195a5bf1 100644
--- a/dlls/uiautomationcore/uiautomationcore.spec
+++ b/dlls/uiautomationcore/uiautomationcore.spec
@@ -90,7 +90,7 @@
 #@ stub UiaRaiseChangesEvent
 #@ stub UiaRaiseNotificationEvent
 @ stdcall UiaRaiseStructureChangedEvent(ptr long ptr long)
-#@ stub UiaRaiseTextEditTextChangedEvent
+@ stdcall UiaRaiseTextEditTextChangedEvent(ptr long ptr)
 @ stdcall UiaRegisterProviderCallback(ptr)
 @ stub UiaRemoveEvent
 @ stdcall UiaReturnRawElementProvider(long long long ptr)
diff --git a/include/uiautomationcoreapi.h b/include/uiautomationcoreapi.h
index 8f5ebe91ea9..e74f37a125e 100644
--- a/include/uiautomationcoreapi.h
+++ b/include/uiautomationcoreapi.h
@@ -75,6 +75,8 @@ HRESULT WINAPI UiaRaiseAutomationEvent(IRawElementProviderSimple *provider, EVEN
 HRESULT WINAPI UiaRaiseAutomationPropertyChangedEvent(IRawElementProviderSimple *provider, PROPERTYID id, VARIANT old, VARIANT new);
 HRESULT WINAPI UiaRaiseAsyncContentLoadedEvent(IRawElementProviderSimple *provider,
                                                 enum AsyncContentLoadedState async_content_loaded_state, double percent_complete);
+HRESULT WINAPI UiaRaiseTextEditTextChangedEvent(IRawElementProviderSimple *provider, enum TextEditChangeType text_edit_change_type,
+                                                SAFEARRAY *changed_data);
 HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple *provider, enum StructureChangeType struct_change_type,
                                              int *runtime_id, int runtime_id_len);
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *pCallback);
From 75b41c07a758de023a97a17334ea500e9bfcd830 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 11 Oct 2021 20:30:28 -0400
Subject: [PATCH] uiautomationcore: Add UiaRaiseNotificationEvent stub.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
---
 dlls/uiautomationcore/uia_main.c            | 12 ++++++++++++
 dlls/uiautomationcore/uiautomationcore.spec |  2 +-
 include/uiautomationcore.idl                | 16 ++++++++++++++++
 include/uiautomationcoreapi.h               |  2 ++
 4 files changed, 31 insertions(+), 1 deletion(-)

diff --git a/dlls/uiautomationcore/uia_main.c b/dlls/uiautomationcore/uia_main.c
index 384191d5350..750e7d19372 100644
--- a/dlls/uiautomationcore/uia_main.c
+++ b/dlls/uiautomationcore/uia_main.c
@@ -459,6 +459,18 @@ HRESULT WINAPI UiaRaiseTextEditTextChangedEvent(IRawElementProviderSimple *provi
     return S_OK;
 }

+/***********************************************************************
+ *          UiaRaiseNotificationEvent (uiautomationcore.@)
+ */
+HRESULT WINAPI UiaRaiseNotificationEvent(IRawElementProviderSimple *provider,
+        enum NotificationKind notification_kind, enum NotificationProcessing notification_processing,
+        BSTR display_str, BSTR activity_id)
+{
+    FIXME("(%p, %d, %d, %s, %s): stub\n", provider, notification_kind, notification_processing,
+            debugstr_w(display_str), debugstr_w(activity_id));
+    return S_OK;
+}
+
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *callback)
 {
     FIXME("(%p): stub\n", callback);
diff --git a/dlls/uiautomationcore/uiautomationcore.spec b/dlls/uiautomationcore/uiautomationcore.spec
index ef7195a5bf1..52c09926fb1 100644
--- a/dlls/uiautomationcore/uiautomationcore.spec
+++ b/dlls/uiautomationcore/uiautomationcore.spec
@@ -88,7 +88,7 @@
 @ stdcall UiaRaiseAutomationEvent(ptr long)
 @ stdcall UiaRaiseAutomationPropertyChangedEvent(ptr long int128 int128)
 #@ stub UiaRaiseChangesEvent
-#@ stub UiaRaiseNotificationEvent
+@ stdcall UiaRaiseNotificationEvent(ptr long long wstr wstr)
 @ stdcall UiaRaiseStructureChangedEvent(ptr long ptr long)
 @ stdcall UiaRaiseTextEditTextChangedEvent(ptr long ptr)
 @ stdcall UiaRegisterProviderCallback(ptr)
diff --git a/include/uiautomationcore.idl b/include/uiautomationcore.idl
index 7d33bde45a4..32c80ec8d5f 100644
--- a/include/uiautomationcore.idl
+++ b/include/uiautomationcore.idl
@@ -152,6 +152,22 @@ enum ZoomUnit {
     ZoomUnit_SmallIncrement = 0x0004,
 };

+enum NotificationProcessing {
+    NotificationProcessing_ImportantAll          = 0x0000,
+    NotificationProcessing_ImportantMostRecent   = 0x0001,
+    NotificationProcessing_All                   = 0x0002,
+    NotificationProcessing_MostRecent            = 0x0003,
+    NotificationProcessing_CurrentThenMostRecent = 0x0004,
+};
+
+enum NotificationKind {
+    NotificationKind_ItemAdded       = 0x0000,
+    NotificationKind_ItemRemoved     = 0x0001,
+    NotificationKind_ActionCompleted = 0x0002,
+    NotificationKind_ActionAborted   = 0x0003,
+    NotificationKind_Other           = 0x0004,
+};
+
 typedef int PROPERTYID;
 typedef int PATTERNID;
 typedef int EVENTID;
diff --git a/include/uiautomationcoreapi.h b/include/uiautomationcoreapi.h
index e74f37a125e..9c1a7ffa3d5 100644
--- a/include/uiautomationcoreapi.h
+++ b/include/uiautomationcoreapi.h
@@ -79,6 +79,8 @@ HRESULT WINAPI UiaRaiseTextEditTextChangedEvent(IRawElementProviderSimple *provi
                                                 SAFEARRAY *changed_data);
 HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple *provider, enum StructureChangeType struct_change_type,
                                              int *runtime_id, int runtime_id_len);
+HRESULT WINAPI UiaRaiseNotificationEvent(IRawElementProviderSimple *provider, enum NotificationKind notification_kind,
+                                            enum NotificationProcessing notification_processing, BSTR display_str, BSTR activity_id);
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *pCallback);
 LRESULT WINAPI UiaReturnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple *elprov);
 BOOL WINAPI UiaTextRangeRelease(HUIATEXTRANGE hobj);
From ba9c0676b8c3139b99840713e8daf234afdb9fec Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 11 Oct 2021 20:35:28 -0400
Subject: [PATCH] uiautomationcore: Add UiaRaiseChangesEvent stub.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
---
 dlls/uiautomationcore/uia_main.c            | 10 ++++++++++
 dlls/uiautomationcore/uiautomationcore.spec |  2 +-
 include/uiautomationcoreapi.h               |  1 +
 3 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/dlls/uiautomationcore/uia_main.c b/dlls/uiautomationcore/uia_main.c
index 750e7d19372..2eccd77eb71 100644
--- a/dlls/uiautomationcore/uia_main.c
+++ b/dlls/uiautomationcore/uia_main.c
@@ -471,6 +471,16 @@ HRESULT WINAPI UiaRaiseNotificationEvent(IRawElementProviderSimple *provider,
     return S_OK;
 }

+/***********************************************************************
+ *          UiaRaiseChangesEvent (uiautomationcore.@)
+ */
+HRESULT WINAPI UiaRaiseChangesEvent(IRawElementProviderSimple *provider, int event_id_count,
+        struct UiaChangeInfo *uia_changes)
+{
+    FIXME("(%p, %d, %p): stub\n", provider, event_id_count, uia_changes);
+    return S_OK;
+}
+
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *callback)
 {
     FIXME("(%p): stub\n", callback);
diff --git a/dlls/uiautomationcore/uiautomationcore.spec b/dlls/uiautomationcore/uiautomationcore.spec
index 52c09926fb1..084c9e9f144 100644
--- a/dlls/uiautomationcore/uiautomationcore.spec
+++ b/dlls/uiautomationcore/uiautomationcore.spec
@@ -87,7 +87,7 @@
 @ stdcall UiaRaiseAsyncContentLoadedEvent(ptr long double)
 @ stdcall UiaRaiseAutomationEvent(ptr long)
 @ stdcall UiaRaiseAutomationPropertyChangedEvent(ptr long int128 int128)
-#@ stub UiaRaiseChangesEvent
+@ stdcall UiaRaiseChangesEvent(ptr long ptr)
 @ stdcall UiaRaiseNotificationEvent(ptr long long wstr wstr)
 @ stdcall UiaRaiseStructureChangedEvent(ptr long ptr long)
 @ stdcall UiaRaiseTextEditTextChangedEvent(ptr long ptr)
diff --git a/include/uiautomationcoreapi.h b/include/uiautomationcoreapi.h
index 9c1a7ffa3d5..c8e77e9cc9f 100644
--- a/include/uiautomationcoreapi.h
+++ b/include/uiautomationcoreapi.h
@@ -81,6 +81,7 @@ HRESULT WINAPI UiaRaiseStructureChangedEvent(IRawElementProviderSimple *provider
                                              int *runtime_id, int runtime_id_len);
 HRESULT WINAPI UiaRaiseNotificationEvent(IRawElementProviderSimple *provider, enum NotificationKind notification_kind,
                                             enum NotificationProcessing notification_processing, BSTR display_str, BSTR activity_id);
+HRESULT WINAPI UiaRaiseChangesEvent(IRawElementProviderSimple *provider, int event_id_count, struct UiaChangeInfo *uia_changes);
 void WINAPI UiaRegisterProviderCallback(UiaProviderCallback *pCallback);
 LRESULT WINAPI UiaReturnRawElementProvider(HWND hwnd, WPARAM wParam, LPARAM lParam, IRawElementProviderSimple *elprov);
 BOOL WINAPI UiaTextRangeRelease(HUIATEXTRANGE hobj);
From b8a175ff4bc65ff494df415e4bbf11ca661dc3e9 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Thu, 4 Nov 2021 11:00:56 -0400
Subject: [PATCH] HACK: user32: Handle OBJID_QUERYCLASSNAMEIDX for user32 edit
 control.

Due to Wine's implementation of RealGetWindowClass being broken for
subclassed controls, we'll need to respond to OBJID_QUERYCLASSNAMEIDX to
know that we have an edit control.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>

CW-Bug-Id: #18351
---
 dlls/user32/edit.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/dlls/user32/edit.c b/dlls/user32/edit.c
index 73885566d3b..b5da20f8b73 100644
--- a/dlls/user32/edit.c
+++ b/dlls/user32/edit.c
@@ -5231,6 +5231,12 @@ LRESULT EditWndProc_common( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam, B
 		}
 		break;

+        case WM_GETOBJECT:
+                if (lParam == (DWORD)OBJID_QUERYCLASSNAMEIDX)
+                    result = 0x10004;
+
+                break;
+
 	default:
 		result = DefWindowProcT(hwnd, msg, wParam, lParam, unicode);
 		break;
From 8362d1581f6622e7db518fa982b95bb55317242a Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Thu, 4 Nov 2021 11:54:50 -0400
Subject: [PATCH] tabtip: Close keyboard upon focus loss.

Call new "steam://close/keyboard" link upon edit control focus loss, to
make sure keyboard is closed.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>

CW-Bug-Id: #18351
---
 programs/tabtip/tabtip.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/programs/tabtip/tabtip.c b/programs/tabtip/tabtip.c
index 6938eb3924f..2bb554a4694 100644
--- a/programs/tabtip/tabtip.c
+++ b/programs/tabtip/tabtip.c
@@ -192,6 +192,7 @@ HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChanged
             if (keyboard_up)
             {
                 WINE_TRACE("Keyboard down!\n");
+                ShellExecuteW(NULL, NULL, L"steam://close/keyboard", NULL, NULL, SW_SHOWNOACTIVATE);
                 keyboard_up = FALSE;
             }
         }
From a2b52ab831cb8a1e0089e6fc36cc02b403444ddc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 30 Nov 2021 09:29:21 +0100
Subject: [PATCH] tabtip: Set started event before creating a window.

CW-Bug-Id: #18351
CW-Bug-Id: #19584
---
 programs/tabtip/tabtip.c | 30 +++++++++++++++---------------
 1 file changed, 15 insertions(+), 15 deletions(-)

diff --git a/programs/tabtip/tabtip.c b/programs/tabtip/tabtip.c
index 2bb554a4694..89e66267593 100644
--- a/programs/tabtip/tabtip.c
+++ b/programs/tabtip/tabtip.c
@@ -303,6 +303,21 @@ int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine
         goto exit;
     }

+    if (FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
+    {
+        ERR("CoInitialize failed!\n");
+        ret = -1;
+        goto exit;
+    }
+
+    if (FAILED(create_uia_event_handler(&uia_iface, &data)))
+    {
+        ret = -1;
+        goto exit;
+    }
+
+    SetEvent(started_event);
+
     wc.lpfnWndProc   = WindowProc;
     wc.hInstance     = hInstance;
     wc.lpszClassName = CLASS_NAME;
@@ -320,24 +335,9 @@ int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine
         goto exit;
     }

-    if (FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)))
-    {
-        ERR("CoInitialize failed!\n");
-        ret = -1;
-        goto exit;
-    }
-
-    if (FAILED(create_uia_event_handler(&uia_iface, &data)))
-    {
-        ret = -1;
-        goto exit;
-    }
-
     t_data.events[EVENT_WINE_EXIT] = wine_exit_event;
     t_data.events[EVENT_PGM_EXIT]  = pgm_exit_event;
     t_data.main_hwnd = hwnd;
-
-    SetEvent(started_event);
     CreateThread(NULL, 0, tabtip_exit_watcher, &t_data, 0, NULL);

     while (GetMessageW(&msg, NULL, 0, 0))
From 4f2d430ca3c0354607c284ab9a7940c109d3a0ea Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Tue, 23 Nov 2021 17:04:40 -0500
Subject: [PATCH] uiautomationcore: Implement UIA_ValueIsReadOnlyPropertyId.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
---
 dlls/uiautomationcore/uia_client.c | 117 +++++++++++++++++++++++++++++
 1 file changed, 117 insertions(+)

diff --git a/dlls/uiautomationcore/uia_client.c b/dlls/uiautomationcore/uia_client.c
index 312cac97fe7..d486a1b50ac 100644
--- a/dlls/uiautomationcore/uia_client.c
+++ b/dlls/uiautomationcore/uia_client.c
@@ -758,6 +758,79 @@ static void uia_create_bounding_rect_variant(double left, double top,
     V_ARRAY(arr_out) = lpsa;
 }

+struct uia_pattern_id_info {
+    PATTERNID pattern_id;
+    REFIID pattern_iid;
+};
+
+static const struct uia_pattern_id_info uia_pattern_ids[] = {
+    { UIA_AnnotationPatternId, &IID_IAnnotationProvider },
+    { UIA_CustomNavigationPatternId, &IID_ICustomNavigationProvider },
+    { UIA_DockPatternId, &IID_IDockProvider },
+    { UIA_DragPatternId, &IID_IDragProvider },
+    { UIA_DropTargetPatternId, &IID_IDropTargetProvider },
+    { UIA_ExpandCollapsePatternId, &IID_IExpandCollapseProvider },
+    { UIA_GridItemPatternId, &IID_IGridItemProvider },
+    { UIA_GridPatternId, &IID_IGridProvider },
+    { UIA_InvokePatternId, &IID_IInvokeProvider },
+    { UIA_ItemContainerPatternId, &IID_IItemContainerProvider },
+    { UIA_LegacyIAccessiblePatternId, &IID_ILegacyIAccessibleProvider },
+    { UIA_MultipleViewPatternId, &IID_IMultipleViewProvider },
+    { UIA_ObjectModelPatternId, &IID_IObjectModelProvider },
+    { UIA_RangeValuePatternId, &IID_IRangeValueProvider },
+    { UIA_ScrollItemPatternId, &IID_IScrollItemProvider },
+    { UIA_ScrollPatternId, &IID_IScrollProvider },
+    { UIA_SelectionItemPatternId, &IID_ISelectionItemProvider, },
+    { UIA_SelectionPatternId, &IID_ISelectionProvider, },
+    { UIA_SpreadsheetPatternId, &IID_ISpreadsheetProvider, },
+    { UIA_SpreadsheetItemPatternId, &IID_ISpreadsheetItemProvider, },
+    { UIA_StylesPatternId, &IID_IStylesProvider, },
+    { UIA_SynchronizedInputPatternId, &IID_ISynchronizedInputProvider, },
+    { UIA_TableItemPatternId, &IID_ITableItemProvider, },
+    /* GridPattern should also be checked if TablePattern is. */
+    { UIA_TablePatternId,  &IID_ITableProvider, },
+    { UIA_TextChildPatternId, &IID_ITextChildProvider, },
+    { UIA_TextEditPatternId, &IID_ITextEditProvider, },
+    { UIA_TextPatternId, &IID_ITextProvider, },
+    { UIA_TextPattern2Id, &IID_ITextProvider2, },
+    { UIA_TogglePatternId, &IID_IToggleProvider, },
+    { UIA_TransformPatternId, &IID_ITransformProvider, },
+    { UIA_TransformPattern2Id, &IID_ITransformProvider2, },
+    { UIA_ValuePatternId, &IID_IValueProvider, },
+    { UIA_VirtualizedItemPatternId, &IID_IVirtualizedItemProvider, },
+    { UIA_WindowPatternId, &IID_IWindowProvider, },
+};
+
+static const struct uia_pattern_id_info *uia_get_pattern_id_info(PATTERNID pattern_id)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(uia_pattern_ids); i++)
+    {
+        if (uia_pattern_ids[i].pattern_id == pattern_id)
+            return &uia_pattern_ids[i];
+    }
+
+    return NULL;
+}
+
+static HRESULT uia_get_pattern_provider(IRawElementProviderSimple *elem_prov,
+        PATTERNID pattern_id, void **pattern_prov_iface)
+{
+    const struct uia_pattern_id_info *pattern_info = uia_get_pattern_id_info(pattern_id);
+    IUnknown *pattern_unk = NULL;
+    HRESULT hr;
+
+    *pattern_prov_iface = NULL;
+    if (!pattern_info)
+        return E_FAIL;
+
+    hr = IRawElementProviderSimple_GetPatternProvider(elem_prov, pattern_id, &pattern_unk);
+    if (FAILED(hr) || !pattern_unk) return hr;
+
+    return IUnknown_QueryInterface(pattern_unk, pattern_info->pattern_iid, pattern_prov_iface);
+}
+
 static void uia_get_default_property_val(PROPERTYID propertyId, VARIANT *retVal)
 {
     switch (propertyId)
@@ -782,6 +855,11 @@ static void uia_get_default_property_val(PROPERTYID propertyId, VARIANT *retVal)
         uia_create_bounding_rect_variant(0, 0, 0, 0, retVal);
         break;

+    case UIA_ValueIsReadOnlyPropertyId:
+        V_VT(retVal) = VT_BOOL;
+        V_BOOL(retVal) = VARIANT_TRUE;
+        break;
+
     default:
         FIXME("Unimplemented default value for PropertyId %d!\n", propertyId);
         V_VT(retVal) = VT_EMPTY;
@@ -821,6 +899,29 @@ static HRESULT uia_get_uia_elem_prov_property_val(IRawElementProviderSimple *ele
     }
         break;

+    case UIA_ValueIsReadOnlyPropertyId:
+    {
+        IValueProvider *val_prov;
+        BOOL ret;
+
+        hr = uia_get_pattern_provider(elem_prov, UIA_ValuePatternId, (void **)&val_prov);
+        if (FAILED(hr) || !val_prov)
+            break;
+
+        hr = IValueProvider_get_IsReadOnly(val_prov, &ret);
+        if (FAILED(hr))
+            break;
+
+        V_VT(&res) = VT_BOOL;
+        if (ret)
+            V_BOOL(&res) = VARIANT_TRUE;
+        else
+            V_BOOL(&res) = VARIANT_FALSE;
+
+        IValueProvider_Release(val_prov);
+    }
+        break;
+
     default:
         hr = IRawElementProviderSimple_GetPropertyValue(elem_prov, propertyId, &res);
         break;
@@ -911,6 +1012,22 @@ static HRESULT uia_get_msaa_acc_property_val(IAccessible *acc,
     }
         break;

+    case UIA_ValueIsReadOnlyPropertyId:
+    {
+        hr = IAccessible_get_accState(acc, child_id, &res);
+        if (SUCCEEDED(hr) && V_VT(&res) == VT_I4)
+        {
+            V_VT(retVal) = VT_BOOL;
+            if (V_I4(&res) & STATE_SYSTEM_READONLY)
+                V_BOOL(retVal) = VARIANT_TRUE;
+            else
+                V_BOOL(retVal) = VARIANT_FALSE;
+
+            *use_default = FALSE;
+        }
+    }
+        break;
+
     default:
         FIXME("UIA PropertyId %d unimplemented for IAccessible!\n", propertyId);
         break;
From ea603cf47d280d22270bf66c75969ba607a63fb9 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Tue, 23 Nov 2021 17:09:13 -0500
Subject: [PATCH] tabtip: Check UIA_ValueIsReadOnlyPropertyId before triggering
 OSK.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
---
 programs/tabtip/tabtip.c | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/programs/tabtip/tabtip.c b/programs/tabtip/tabtip.c
index 89e66267593..cb2c52c1db2 100644
--- a/programs/tabtip/tabtip.c
+++ b/programs/tabtip/tabtip.c
@@ -147,6 +147,14 @@ ULONG WINAPI uia_focus_event_Release(IUIAutomationFocusChangedEventHandler* ifac
     return ref;
 }

+static BOOL variant_to_bool(VARIANT *v)
+{
+    if (V_VT(v) == VT_BOOL && (V_BOOL(v) == VARIANT_TRUE))
+        return TRUE;
+
+    return FALSE;
+}
+
 /*** IUIAutomationFocusChangedEventHandler methods ***/
 HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChangedEventHandler *iface,
         IUIAutomationElement *sender)
@@ -157,7 +165,7 @@ HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChanged
     if (sender)
     {
         RECT rect = { 0 };
-        VARIANT var;
+        VARIANT var, var2;
         INT ct_id;
         BSTR name;

@@ -165,9 +173,10 @@ HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChanged
         IUIAutomationElement_get_CurrentName(sender, &name);
         IUIAutomationElement_get_CurrentBoundingRectangle(sender, &rect);
         IUIAutomationElement_GetCurrentPropertyValue(sender, UIA_IsKeyboardFocusablePropertyId, &var);
+        IUIAutomationElement_GetCurrentPropertyValue(sender, UIA_ValueIsReadOnlyPropertyId, &var2);

         if (use_steam_osk && (last_keyup_event < (GetTickCount() - 5000)) &&
-                ct_id == UIA_EditControlTypeId && (V_VT(&var) == VT_BOOL && V_BOOL(&var)))
+                (ct_id == UIA_EditControlTypeId) && variant_to_bool(&var) && !variant_to_bool(&var2))
         {
             if (!keyboard_up)
             {
From a73a8c988c3f9abc50f2e633d87c4291d144ba48 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Tue, 23 Nov 2021 17:11:26 -0500
Subject: [PATCH] tabtip: Free returned UI Automation element name string.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
---
 programs/tabtip/Makefile.in | 2 +-
 programs/tabtip/tabtip.c    | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/programs/tabtip/Makefile.in b/programs/tabtip/Makefile.in
index 846b813be69..d60a4eafd89 100644
--- a/programs/tabtip/Makefile.in
+++ b/programs/tabtip/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = tabtip.exe
-IMPORTS   = uuid ole32 user32 oleacc uiautomationcore rpcrt4 shell32
+IMPORTS   = uuid ole32 user32 oleacc uiautomationcore rpcrt4 shell32 oleaut32

 EXTRADLLFLAGS = -mconsole -municode -mno-cygwin

diff --git a/programs/tabtip/tabtip.c b/programs/tabtip/tabtip.c
index cb2c52c1db2..bf5936ed719 100644
--- a/programs/tabtip/tabtip.c
+++ b/programs/tabtip/tabtip.c
@@ -213,6 +213,7 @@ HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChanged

         WINE_TRACE("element name: %s, ct_id %s, rect { %d, %d } - { %d, %d }\n", wine_dbgstr_w(name), ct_id_str[ct_id],
                 rect.left, rect.top, rect.right, rect.bottom);
+        SysFreeString(name);
     }

     return S_OK;
From 58cbc0b829f1376fe9d3e191a999fd69aeb10fc5 Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Tue, 23 Nov 2021 17:14:15 -0500
Subject: [PATCH] tabtip: Simplify OSK triggering conditions.

Get rid of old, no longer necessary OSK trigger conditions. First is the
delay between subsequent OSK trigger events, which was necessary when
the big picture mode OSK would steal focus, but no longer applies here.
Also allow for the OSK to be triggered even if the last focused control
triggered the OSK, as sometimes a subsequent text field is selected
without a non-edit control inbetween.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
---
 programs/tabtip/tabtip.c | 31 ++++++++++++-------------------
 1 file changed, 12 insertions(+), 19 deletions(-)

diff --git a/programs/tabtip/tabtip.c b/programs/tabtip/tabtip.c
index bf5936ed719..9f844151ad9 100644
--- a/programs/tabtip/tabtip.c
+++ b/programs/tabtip/tabtip.c
@@ -53,7 +53,6 @@ typedef struct {
     LONG ref;
 } event_data;

-DWORD last_keyup_event;
 BOOL keyboard_up;
 BOOL use_steam_osk;

@@ -175,26 +174,21 @@ HRESULT WINAPI uia_focus_event_HandleFocusChangedEvent(IUIAutomationFocusChanged
         IUIAutomationElement_GetCurrentPropertyValue(sender, UIA_IsKeyboardFocusablePropertyId, &var);
         IUIAutomationElement_GetCurrentPropertyValue(sender, UIA_ValueIsReadOnlyPropertyId, &var2);

-        if (use_steam_osk && (last_keyup_event < (GetTickCount() - 5000)) &&
-                (ct_id == UIA_EditControlTypeId) && variant_to_bool(&var) && !variant_to_bool(&var2))
+        if (use_steam_osk && (ct_id == UIA_EditControlTypeId) && variant_to_bool(&var) &&
+                !variant_to_bool(&var2))
         {
-            if (!keyboard_up)
+            WINE_TRACE("Keyboard up!\n");
+            keyboard_up = TRUE;
+            if (rect.left || rect.top || rect.right || rect.bottom)
             {
-                WINE_TRACE("Keyboard up!\n");
-                keyboard_up = TRUE;
-                if (rect.left || rect.top || rect.right || rect.bottom)
-                {
-                    WCHAR link_buf[1024];
-
-                    wsprintfW(link_buf, L"steam://open/keyboard?XPosition=%d&YPosition=%d&Width=%d&Height=%d&Mode=0",
-                            rect.left, rect.top, (rect.right - rect.left), (rect.bottom - rect.top));
-                    ShellExecuteW(NULL, NULL, link_buf, NULL, NULL, SW_SHOWNOACTIVATE);
-                }
-                else
-                    ShellExecuteW(NULL, NULL, L"steam://open/keyboard", NULL, NULL, SW_SHOWNOACTIVATE);
-
-                last_keyup_event = GetTickCount();
+                WCHAR link_buf[1024];
+
+                wsprintfW(link_buf, L"steam://open/keyboard?XPosition=%d&YPosition=%d&Width=%d&Height=%d&Mode=0",
+                        rect.left, rect.top, (rect.right - rect.left), (rect.bottom - rect.top));
+                ShellExecuteW(NULL, NULL, link_buf, NULL, NULL, SW_SHOWNOACTIVATE);
             }
+            else
+                ShellExecuteW(NULL, NULL, L"steam://open/keyboard", NULL, NULL, SW_SHOWNOACTIVATE);
         }
         else
         {
@@ -297,7 +291,6 @@ int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine
     HWND hwnd;

     wine_exit_event = pgm_exit_event = started_event = NULL;
-    last_keyup_event = 0;
     keyboard_up = FALSE;
     tabtip_use_osk_check();

From fb7fb08936c2f99fa92fdd283cd3e1600993a5df Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 22 Nov 2021 10:31:56 -0500
Subject: [PATCH] include: Add UI Automation provider interface definitions.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
---
 include/uiautomationcore.idl | 554 +++++++++++++++++++++++++++++++++++
 1 file changed, 554 insertions(+)

diff --git a/include/uiautomationcore.idl b/include/uiautomationcore.idl
index 32c80ec8d5f..7d1a0e43480 100644
--- a/include/uiautomationcore.idl
+++ b/include/uiautomationcore.idl
@@ -324,4 +324,558 @@ library UIA
                 [out, retval] VARIANT *val);
     }
 #endif
+    [
+        object,
+        uuid(159bc72c-4ad3-485e-9637-d7052edf0146),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IDockProvider : IUnknown {
+        HRESULT SetDockPosition([in]enum DockPosition dockPosition);
+        [propget]HRESULT DockPosition([out, retval]enum DockPosition *pRetVal);
+    };
+
+    [
+        object,
+        uuid(d847d3a5-cab0-4a98-8c32-ecb45c59ad24),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IExpandCollapseProvider : IUnknown {
+        HRESULT Expand();
+        HRESULT Collapse();
+        [propget]HRESULT ExpandCollapseState([out, retval]enum ExpandCollapseState *pRetVal);
+    };
+
+    [
+        object,
+        uuid(b17d6187-0907-464b-a168-0ef17a1572b1),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IGridProvider : IUnknown {
+        HRESULT GetItem([in]int row,
+                        [in]int column,
+                        [out, retval]IRawElementProviderSimple **pRetVal);
+        [propget]HRESULT RowCount([out, retval]int *pRetVal);
+        [propget]HRESULT ColumnCount([out, retval]int *pRetVal);
+    };
+
+    [
+        object,
+        uuid(d02541f1-fb81-4d64-ae32-f520f8a6dbd1),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IGridItemProvider : IUnknown {
+        [propget]HRESULT Row([out, retval]int *pRetVal);
+        [propget]HRESULT Column([out, retval]int *pRetVal);
+        [propget]HRESULT RowSpan([out, retval]int *pRetVal);
+        [propget]HRESULT ColumnSpan([out, retval]int *pRetVal);
+        [propget]HRESULT ContainingGrid([out, retval]IRawElementProviderSimple **pRetVal);
+    };
+
+    [
+        object,
+        uuid(54fcb24b-e18e-47a2-b4d3-eccbe77599a2),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IInvokeProvider : IUnknown {
+        HRESULT Invoke();
+    };
+
+    [
+        object,
+        uuid(6278cab1-b556-4a1a-b4e0-418acc523201),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IMultipleViewProvider : IUnknown {
+        HRESULT GetViewName([in]int viewId, [out, retval]BSTR *pRetVal);
+        HRESULT SetCurrentView([in]int viewId);
+        [propget]HRESULT CurrentView([out, retval]int *pRetVal);
+        HRESULT GetSupportedViews([out, retval]SAFEARRAY(int) *pRetVal);
+    };
+
+    [
+        object,
+        uuid(36dc7aef-33e6-4691-afe1-2be7274b3d33),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IRangeValueProvider : IUnknown {
+        HRESULT SetValue([in]double val);
+        [propget]HRESULT Value([out, retval]double *pRetVal);
+        [propget]HRESULT IsReadOnly([out, retval]BOOL *pRetVal);
+        [propget]HRESULT Maximum([out, retval]double *pRetVal);
+        [propget]HRESULT Minimum([out, retval]double *pRetVal);
+        [propget]HRESULT LargeChange([out, retval]double *pRetVal);
+        [propget]HRESULT SmallChange([out, retval]double *pRetVal);
+    };
+
+    [
+        object,
+        uuid(2360c714-4bf1-4b26-ba65-9b21316127eb),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IScrollItemProvider : IUnknown {
+        HRESULT ScrollIntoView ();
+    };
+
+    [
+        object,
+        uuid(fb8b03af-3bdf-48d4-bd36-1a65793be168),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISelectionProvider : IUnknown {
+        /* SAFEARRAY(IUnknown *) currently unsupported by WIDL. */
+/*        HRESULT GetSelection([out, retval]SAFEARRAY(IRawElementProviderSimple *) *pRetVal);*/
+        HRESULT GetSelection([out, retval]SAFEARRAY(VARIANT) *pRetVal);
+        [propget]HRESULT CanSelectMultiple([out, retval]BOOL *pRetVal);
+        [propget]HRESULT IsSelectionRequired([out, retval]BOOL *pRetVal);
+    };
+
+    [
+        object,
+        uuid(14f68475-ee1c-44f6-a869-d239381f0fe7),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISelectionProvider2 : ISelectionProvider {
+        [propget]HRESULT FirstSelectedItem([out, retval]IRawElementProviderSimple **retVal);
+        [propget]HRESULT LastSelectedItem([out, retval]IRawElementProviderSimple **retVal);
+        [propget]HRESULT CurrentSelectedItem([out, retval]IRawElementProviderSimple **retVal);
+        [propget]HRESULT ItemCount([out, retval]int *retVal);
+    };
+
+    [
+        object,
+        uuid(b38b8077-1fc3-42a5-8cae-d40c2215055a),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IScrollProvider : IUnknown {
+        HRESULT Scroll([in]enum ScrollAmount horizontalAmount,
+                       [in]enum ScrollAmount verticalAmount);
+        HRESULT SetScrollPercent([in]double horizontalPercent,
+                                 [in]double verticalPercent);
+
+        [propget]HRESULT HorizontalScrollPercent([out, retval]double *pRetVal);
+        [propget]HRESULT VerticalScrollPercent([out, retval]double *pRetVal);
+        [propget]HRESULT HorizontalViewSize([out, retval]double *pRetVal);
+        [propget]HRESULT VerticalViewSize([out, retval]double *pRetVal);
+        [propget]HRESULT HorizontallyScrollable([out, retval]BOOL *pRetVal);
+        [propget]HRESULT VerticallyScrollable([out, retval]BOOL *pRetVal);
+    };
+
+    [
+        object,
+        uuid(2acad808-b2d4-452d-a407-91ff1ad167b2),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISelectionItemProvider : IUnknown {
+        HRESULT Select();
+        HRESULT AddToSelection();
+        HRESULT RemoveFromSelection();
+        [propget]HRESULT IsSelected([out, retval]BOOL *pRetVal);
+        [propget]HRESULT SelectionContainer([out, retval]IRawElementProviderSimple **pRetVal);
+    };
+
+    [
+        object,
+        uuid(29db1a06-02ce-4cf7-9b42-565d4fab20ee),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISynchronizedInputProvider : IUnknown {
+        HRESULT StartListening([in]enum SynchronizedInputType inputType);
+        HRESULT Cancel();
+    };
+
+    [
+        object,
+        uuid(9c860395-97b3-490a-b52a-858cc22af166),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITableProvider : IUnknown {
+        /* SAFEARRAY(IUnknown *) currently unsupported by WIDL. */
+/*
+        HRESULT GetRowHeaders([out, retval]SAFEARRAY(IRawElementProviderSimple*) *pRetVal);
+        HRESULT GetColumnHeaders([out, retval]SAFEARRAY(IRawElementProviderSimple*) *pRetVal);
+*/
+        HRESULT GetRowHeaders([out, retval]SAFEARRAY(VARIANT) *pRetVal);
+        HRESULT GetColumnHeaders([out, retval]SAFEARRAY(VARIANT) *pRetVal);
+        [propget]HRESULT RowOrColumnMajor([out, retval]enum RowOrColumnMajor *pRetVal);
+    };
+
+    [
+        object,
+        uuid(b9734fa6-771f-4d78-9c90-2517999349cd),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITableItemProvider : IUnknown {
+        /* SAFEARRAY(IUnknown *) currently unsupported by WIDL. */
+/*
+        HRESULT GetRowHeaderItems([out, retval]SAFEARRAY(IRawElementProviderSimple*) *pRetVal);
+        HRESULT GetColumnHeaderItems([out, retval]SAFEARRAY(IRawElementProviderSimple*) *pRetVal);
+*/
+        HRESULT GetRowHeaderItems([out, retval]SAFEARRAY(VARIANT) *pRetVal);
+        HRESULT GetColumnHeaderItems([out, retval]SAFEARRAY(VARIANT) *pRetVal);
+    };
+
+    [object, uuid(56d00bd0-c4f4-433c-a836-1a52a57e0892), pointer_default(unique), oleautomation]
+    interface IToggleProvider : IUnknown {
+        HRESULT Toggle();
+        [propget]HRESULT ToggleState([out, retval]enum ToggleState *pRetVal);
+    };
+
+    [
+        object,
+        uuid(6829ddc4-4f91-4ffa-b86f-bd3e2987cb4c),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITransformProvider : IUnknown {
+        HRESULT Move([in]double x, [in]double y);
+        HRESULT Resize([in]double width, [in]double height);
+        HRESULT Rotate([in]double degrees);
+        [propget]HRESULT CanMove([out, retval]BOOL *pRetVal);
+        [propget]HRESULT CanResize([out, retval]BOOL *pRetVal);
+        [propget]HRESULT CanRotate([out, retval]BOOL *pRetVal);
+    };
+
+    [
+        object,
+        uuid(c7935180-6fb3-4201-b174-7df73adbf64a),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IValueProvider : IUnknown {
+        /*
+         * HACK: Make SetValue's argument a BSTR since LPCWSTR marshaling is
+         * currently unsupported.
+         */
+/*        HRESULT SetValue([in]LPCWSTR val);*/
+        HRESULT SetValue([in]BSTR val);
+        [propget]HRESULT Value([out, retval]BSTR *pRetVal);
+        [propget]HRESULT IsReadOnly([out, retval]BOOL *pRetVal);
+    };
+
+    [
+        object,
+        uuid(987df77b-db06-4d77-8f8a-86a9c3bb90b9),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IWindowProvider : IUnknown {
+        HRESULT SetVisualState([in]enum WindowVisualState state);
+        HRESULT Close();
+        HRESULT WaitForInputIdle([in]int milliseconds, [out, retval]BOOL *pRetVal);
+
+        [propget]HRESULT CanMaximize([out, retval]BOOL *pRetVal);
+        [propget]HRESULT CanMinimize ([out, retval]BOOL *pRetVal);
+        [propget]HRESULT IsModal([out, retval]BOOL *pRetVal);
+        [propget]HRESULT WindowVisualState ([out, retval]enum WindowVisualState *pRetVal);
+        [propget]HRESULT WindowInteractionState([out, retval]enum WindowInteractionState *pRetVal);
+        [propget]HRESULT IsTopmost([out, retval]BOOL *pRetVal);
+    };
+
+    [
+        object,
+        uuid(e44c3566-915d-4070-99c6-047bff5a08f5),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ILegacyIAccessibleProvider : IUnknown {
+        HRESULT Select( long flagsSelect );
+        HRESULT DoDefaultAction();
+        HRESULT SetValue(LPCWSTR szValue);
+        HRESULT GetIAccessible([out, retval]IAccessible **ppAccessible);
+
+        [propget]HRESULT ChildId([out, retval]int *pRetVal);
+        [propget]HRESULT Name([out, retval]BSTR *pszName);
+        [propget]HRESULT Value([out, retval]BSTR *pszValue);
+        [propget]HRESULT Description([out, retval]BSTR *pszDescription);
+        [propget]HRESULT Role([out, retval]DWORD *pdwRole);
+        [propget]HRESULT State([out, retval]DWORD *pdwState);
+        [propget]HRESULT Help([out, retval]BSTR *pszHelp);
+        [propget]HRESULT KeyboardShortcut([out, retval]BSTR *pszKeyboardShortcut);
+
+        /* SAFEARRAY(IUnknown *) currently unsupported by WIDL. */
+/*        HRESULT GetSelection([out, retval]SAFEARRAY(IRawElementProviderSimple *) *pvarSelectedChildren);*/
+        HRESULT GetSelection([out, retval]SAFEARRAY(VARIANT) *pvarSelectedChildren);
+
+        [propget]HRESULT DefaultAction([out, retval]BSTR *pszDefaultAction);
+    };
+
+    [
+        object,
+        uuid(e747770b-39ce-4382-ab30-d8fb3f336f24),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IItemContainerProvider : IUnknown {
+        HRESULT FindItemByProperty([in]IRawElementProviderSimple *pStartAfter,
+                                   [in]PROPERTYID propertyId,
+                                   [in]VARIANT value,
+                                   [out, retval]IRawElementProviderSimple **pFound);
+    };
+
+    [
+        object,
+        uuid(cb98b665-2d35-4fac-ad35-f3c60d0c0b8b),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IVirtualizedItemProvider : IUnknown {
+        HRESULT Realize();
+    };
+
+    [
+        object,
+        uuid(3ad86ebd-f5ef-483d-bb18-b1042a475d64),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IObjectModelProvider : IUnknown {
+        HRESULT GetUnderlyingObjectModel([out, retval]IUnknown **ppUnknown);
+    };
+
+    [
+        object,
+        uuid(f95c7e80-bd63-4601-9782-445ebff011fc),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IAnnotationProvider : IUnknown {
+        [propget]HRESULT AnnotationTypeId([out, retval] int *retVal);
+        [propget]HRESULT AnnotationTypeName([out, retval]BSTR *retVal);
+        [propget]HRESULT Author([out, retval]BSTR *retVal);
+        [propget]HRESULT DateTime([out, retval] BSTR *retVal);
+        [propget]HRESULT Target([out, retval]IRawElementProviderSimple **retVal);
+    };
+
+    [
+        object,
+        uuid(19b6b649-f5d7-4a6d-bdcb-129252be588a),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IStylesProvider : IUnknown {
+        [propget]HRESULT StyleId([out, retval]int *retVal);
+        [propget]HRESULT StyleName([out, retval]BSTR *retVal);
+        [propget]HRESULT FillColor([out, retval]int *retVal);
+        [propget]HRESULT FillPatternStyle([out, retval]BSTR *retVal);
+        [propget]HRESULT Shape([out, retval]BSTR *retVal);
+        [propget]HRESULT FillPatternColor([out, retval]int *retVal);
+        [propget]HRESULT ExtendedProperties([out, retval]BSTR *retVal);
+    };
+
+    [
+        object,
+        uuid(6f6b5d35-5525-4f80-b758-85473832ffc7),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISpreadsheetProvider : IUnknown {
+        HRESULT GetItemByName([in]LPCWSTR name,
+                              [out, retval]IRawElementProviderSimple **pRetVal);
+    };
+
+    [
+        object,
+        uuid(eaed4660-7b3d-4879-a2e6-365ce603f3d0),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ISpreadsheetItemProvider : IUnknown {
+        [propget]HRESULT Formula([out, retval]BSTR *pRetVal);
+
+        /* SAFEARRAY(IUnknown *) currently unsupported by WIDL. */
+/*        HRESULT GetAnnotationObjects([out, retval]SAFEARRAY(IRawElementProviderSimple*) *pRetVal);*/
+        HRESULT GetAnnotationObjects([out, retval]SAFEARRAY(VARIANT) *pRetVal);
+
+        HRESULT GetAnnotationTypes([out, retval]SAFEARRAY(int) *pRetVal);
+    };
+
+    [
+        object,
+        uuid(4758742f-7ac2-460c-bc48-09fc09308a93),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITransformProvider2 : ITransformProvider {
+        HRESULT Zoom([in]double zoom);
+
+        [propget]HRESULT CanZoom([out, retval]BOOL *pRetVal);
+        [propget]HRESULT ZoomLevel([out, retval]double *pRetVal);
+        [propget]HRESULT ZoomMinimum([out, retval]double *pRetVal);
+        [propget]HRESULT ZoomMaximum([out, retval]double *pRetVal);
+
+        HRESULT ZoomByUnit([in]enum ZoomUnit zoomUnit);
+    }
+
+    [
+        object,
+        uuid(6aa7bbbb-7ff9-497d-904f-d20b897929d8),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IDragProvider : IUnknown {
+        [propget]HRESULT IsGrabbed([out, retval]BOOL *pRetVal);
+        [propget]HRESULT DropEffect([out, retval]BSTR *pRetVal);
+        [propget]HRESULT DropEffects([out, retval]SAFEARRAY(BSTR) *pRetVal);
+
+        /* SAFEARRAY(IUnknown *) currently unsupported by WIDL. */
+/*        HRESULT GetGrabbedItems([out, retval]SAFEARRAY(IRawElementProviderSimple*) *pRetVal);*/
+        HRESULT GetGrabbedItems([out, retval]SAFEARRAY(VARIANT) *pRetVal);
+    };
+
+    [
+        object,
+        uuid(bae82bfd-358a-481c-85a0-d8b4d90a5d61),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface IDropTargetProvider : IUnknown {
+        [propget]HRESULT DropTargetEffect([out, retval]BSTR *pRetVal);
+        [propget]HRESULT DropTargetEffects([out, retval]SAFEARRAY(BSTR) *pRetVal);
+    };
+
+    interface ITextRangeProvider;
+    [
+        object,
+        uuid(3589c92c-63f3-4367-99bb-ada653b77cf2),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextProvider : IUnknown {
+        /* SAFEARRAY(IUnknown *) currently unsupported by WIDL. */
+/*
+        HRESULT GetSelection([out, retval]SAFEARRAY(ITextRangeProvider *) *pRetVal);
+        HRESULT GetVisibleRanges([out, retval]SAFEARRAY(ITextRangeProvider *) *pRetVal);
+*/
+        HRESULT GetSelection([out, retval]SAFEARRAY(VARIANT) *pRetVal);
+        HRESULT GetVisibleRanges([out, retval]SAFEARRAY(VARIANT) *pRetVal);
+        HRESULT RangeFromChild([in]IRawElementProviderSimple *childElement,
+                               [out, retval]ITextRangeProvider **pRetVal);
+        HRESULT RangeFromPoint([in]struct UiaPoint point,
+                               [out, retval]ITextRangeProvider **pRetVal);
+
+        [propget]HRESULT DocumentRange([out, retval]ITextRangeProvider **pRetVal);
+        [propget]HRESULT SupportedTextSelection([out, retval]enum SupportedTextSelection *pRetVal);
+    };
+
+    [
+        object,
+        uuid(0dc5e6ed-3e16-4bf1-8f9a-a979878bc195),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextProvider2 : ITextProvider {
+        HRESULT RangeFromAnnotation([in]IRawElementProviderSimple *annotationElement,
+                                    [out, retval]ITextRangeProvider **pRetVal);
+
+        HRESULT GetCaretRange([out]BOOL *isActive,
+                              [out, retval]ITextRangeProvider **pRetVal);
+    }
+
+    [
+        object,
+        uuid(EA3605B4-3A05-400E-B5F9-4E91B40F6176),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextEditProvider : ITextProvider {
+        HRESULT GetActiveComposition([out, retval]ITextRangeProvider **pRetVal);
+        HRESULT GetConversionTarget([out, retval]ITextRangeProvider **pRetVal);
+    }
+
+    [
+        object,
+        uuid(5347ad7b-c355-46f8-aff5-909033582f63),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextRangeProvider : IUnknown {
+        HRESULT Clone([out, retval]ITextRangeProvider **pRetVal);
+        HRESULT Compare([in]ITextRangeProvider *range,
+                        [out, retval]BOOL *pRetVal);
+        HRESULT CompareEndpoints([in]enum TextPatternRangeEndpoint endpoint,
+                                 [in]ITextRangeProvider *targetRange,
+                                 [in]enum TextPatternRangeEndpoint targetEndpoint,
+                                 [out, retval]int *pRetVal);
+        HRESULT ExpandToEnclosingUnit([in]enum TextUnit unit);
+        HRESULT FindAttribute([in]TEXTATTRIBUTEID attributeId,
+                              [in]VARIANT val,
+                              [in]BOOL backward,
+                              [out, retval]ITextRangeProvider **pRetVal);
+        HRESULT FindText([in]BSTR text,
+                         [in]BOOL backward,
+                         [in]BOOL ignoreCase,
+                         [out, retval]ITextRangeProvider **pRetVal);
+        HRESULT GetAttributeValue([in]TEXTATTRIBUTEID attributeId,
+                                  [out, retval]VARIANT *pRetVal);
+        HRESULT GetBoundingRectangles([out, retval]SAFEARRAY(double) *pRetVal);
+        HRESULT GetEnclosingElement([out, retval]IRawElementProviderSimple **pRetVal);
+        HRESULT GetText([in]int maxLength,
+                        [out, retval]BSTR *pRetVal);
+        HRESULT Move([in]enum TextUnit unit,
+                     [in]int count,
+                     [out, retval]int *pRetVal);
+        HRESULT MoveEndpointByUnit(
+            [in]enum TextPatternRangeEndpoint endpoint,
+            [in]enum TextUnit unit,
+            [in]int count,
+            [out, retval]int *pRetVal);
+        HRESULT MoveEndpointByRange([in]enum TextPatternRangeEndpoint endpoint,
+                                    [in]ITextRangeProvider *targetRange,
+                                    [in]enum TextPatternRangeEndpoint targetEndpoint);
+        HRESULT Select();
+        HRESULT AddToSelection();
+        HRESULT RemoveFromSelection();
+        HRESULT ScrollIntoView([in]BOOL alignToTop);
+        /* SAFEARRAY(IUnknown *) currently unsupported by WIDL. */
+/*        HRESULT GetChildren([out, retval]SAFEARRAY(IRawElementProviderSimple*) *pRetVal);*/
+        HRESULT GetChildren([out, retval]SAFEARRAY(VARIANT) *pRetVal);
+    };
+
+    [
+        object,
+        uuid(9BBCE42C-1921-4F18-89CA-DBA1910A0386),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextRangeProvider2 : ITextRangeProvider {
+        HRESULT ShowContextMenu();
+    }
+
+    [
+        object,
+        uuid(4c2de2b9-c88f-4f88-a111-f1d336b7d1a9),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ITextChildProvider : IUnknown {
+        [propget]HRESULT TextContainer([out, retval]IRawElementProviderSimple **pRetVal);
+
+        [propget]HRESULT TextRange([out, retval]ITextRangeProvider **pRetVal);
+    };
+
+    [
+        object,
+        uuid(2062A28A-8C07-4B94-8E12-7037C622AEB8),
+        pointer_default(unique),
+        oleautomation
+    ]
+    interface ICustomNavigationProvider : IUnknown {
+        HRESULT Navigate([in]enum NavigateDirection direction,
+                         [out, retval]IRawElementProviderSimple **pRetVal);
+    }
 }

