--- a/server/thread.c	2022-01-10 18:07:45.848683949 -0500
+++ b/server/thread.c	2022-01-10 18:07:25.428019136 -0500
@@ -413,6 +413,7 @@ struct thread *create_thread( int fd, st
     thread->process = (struct process *)grab_object( process );
     thread->desktop = 0;
     thread->affinity = process->affinity;
+    thread->priority = process->priority;
     if (!current) current = thread;
 
     list_add_tail( &thread_list, &thread->entry );
@@ -762,10 +763,32 @@ static void delayed_set_thread_priority(
     apply_thread_priority( thread, priority_class, priority, TRUE );
 }
 
+static int wine_rt_policy = -1;
+
 static void apply_thread_priority( struct thread *thread, int priority_class, int priority, int delayed )
 {
     int niceness, limit = min( nice_limit, thread->process->nice_limit );
-
+    int min, max, base_priority;
+    // Get RT policy
+    const char *policyStr = getenv("WINE_RT_POLICY");
+
+    min = sched_get_priority_min( SCHED_FIFO );
+    max = sched_get_priority_max( SCHED_FIFO );
+
+    // RT priority for threads must be below kernel-mode APC, TIME_CRITICAL threads and Wineserver.
+    if ((base_priority = get_priority( "WINE_RT_PRIO", min, max )) != -1)
+    {
+        thread_base_priority = base_priority - 1;
+    }
+    
+    // Set the RT policy      
+    if (policyStr) {
+        if (strcmp(policyStr, "RR")==0)
+            wine_rt_policy = SCHED_RR;
+        else if (strcmp(policyStr, "FF")==0)
+            wine_rt_policy = SCHED_FIFO;
+    } 
+    
     if (!delayed && thread->delay_priority) remove_timeout_user( thread->delay_priority );
     thread->delay_priority = NULL;
 
@@ -775,9 +798,40 @@ static void apply_thread_priority( struc
         return;
     }
 
-    /* FIXME: handle REALTIME class using SCHED_RR if possible, for now map it to HIGH */
-    if (priority_class == PROCESS_PRIOCLASS_REALTIME) priority_class = PROCESS_PRIOCLASS_HIGH;
+        struct sched_param param;
+        if (sched_getparam( thread->unix_tid, &param ) != 0)
+            return;
 
+    if ((priority_class == PROCESS_PRIOCLASS_REALTIME) && (priority >= THREAD_PRIORITY_TIME_CRITICAL))
+    {
+        param.sched_priority = thread_base_priority;
+        if (sched_setscheduler( thread->unix_tid, SCHED_FIFO|SCHED_RESET_ON_FORK, &param ) == 0)
+            return;
+    }
+    else if ((priority_class == PROCESS_PRIOCLASS_REALTIME) && (priority >= THREAD_PRIORITY_HIGHEST))
+    {
+        param.sched_priority = thread_base_priority -2;
+        if (sched_setscheduler( thread->unix_tid, wine_rt_policy|SCHED_RESET_ON_FORK, &param ) == 0)
+            return;
+    }
+    else if ((priority_class == PROCESS_PRIOCLASS_REALTIME) && (priority >= THREAD_PRIORITY_ABOVE_NORMAL))
+    {
+        param.sched_priority = thread_base_priority -4;
+        if (sched_setscheduler( thread->unix_tid, wine_rt_policy|SCHED_RESET_ON_FORK, &param ) == 0)
+            return;
+    }
+    else if ((priority_class == PROCESS_PRIOCLASS_REALTIME) && (priority >= THREAD_PRIORITY_NORMAL))
+    {
+        param.sched_priority = thread_base_priority -6;
+        if (sched_setscheduler( thread->unix_tid, wine_rt_policy|SCHED_RESET_ON_FORK, &param ) == 0)
+            return;
+    }
+    else if ((priority_class == PROCESS_PRIOCLASS_REALTIME) && (priority <= THREAD_PRIORITY_NORMAL))
+    {
+        param.sched_priority = thread_base_priority -8;
+        if (sched_setscheduler( thread->unix_tid, wine_rt_policy|SCHED_RESET_ON_FORK, &param ) == 0)
+            return;
+    }  
 #ifdef __linux__
 #ifdef HAVE_SETPRIORITY
     if (limit < 0)
