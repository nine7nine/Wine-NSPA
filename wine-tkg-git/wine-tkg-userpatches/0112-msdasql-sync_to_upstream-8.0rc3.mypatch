diff -Npur a/dlls/msdasql/msdasql_main.c b/dlls/msdasql/msdasql_main.c
--- a/dlls/msdasql/msdasql_main.c	2023-01-10 20:25:29.125519240 -0500
+++ b/dlls/msdasql/msdasql_main.c	2023-01-10 09:35:53.000000000 -0500
@@ -40,6 +40,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(msdasql);
 
 DEFINE_GUID(DBPROPSET_DATASOURCEINFO, 0xc8b522bb, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
 DEFINE_GUID(DBPROPSET_DBINIT,    0xc8b522bc, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
+DEFINE_GUID(DBPROPSET_ROWSET,    0xc8b522be, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
 
 DEFINE_GUID(DBGUID_DEFAULT,      0xc8b521fb, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
 
diff -Npur a/dlls/msdasql/session.c b/dlls/msdasql/session.c
--- a/dlls/msdasql/session.c	2023-01-10 20:25:29.125519240 -0500
+++ b/dlls/msdasql/session.c	2023-01-10 09:35:53.000000000 -0500
@@ -36,6 +36,247 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msdasql);
 
+struct msdasql_prop
+{
+    DBPROPID    property_id;
+    DBPROPFLAGS flags;
+    VARTYPE     vartype;
+
+    LONG value;
+};
+
+static struct msdasql_prop msdasql_init_props[] =
+{
+    { DBPROP_ABORTPRESERVE,                   DBPROPFLAGS_ROWSET | DBPROPFLAGS_DATASOURCEINFO, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_BLOCKINGSTORAGEOBJECTS,          DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_BOOKMARKS,                       DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_BOOKMARKSKIPPED,                 DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_BOOKMARKTYPE,                    DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_I4, 1 },
+    { DBPROP_CANFETCHBACKWARDS,               DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_CANHOLDROWS,                     DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_CANSCROLLBACKWARDS,              DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_COLUMNRESTRICT,                  DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_COMMITPRESERVE,                  DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_DELAYSTORAGEOBJECTS,             DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_IMMOBILEROWS,                    DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_LITERALBOOKMARKS,                DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_LITERALIDENTITY,                 DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_MAXOPENROWS,                     DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4, 0 },
+    { DBPROP_MAXPENDINGROWS,                  DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_I4,  0 },
+    { DBPROP_MAXROWS,                         DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_I4, 0 },
+    { DBPROP_NOTIFICATIONPHASES,              DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4, 31 },
+    { DBPROP_OTHERUPDATEDELETE,               DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_OWNINSERT,                       DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_OWNUPDATEDELETE,                 DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_QUICKRESTART ,                   DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_REENTRANTEVENTS,                 DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_REMOVEDELETED,                   DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_REPORTMULTIPLECHANGES,           DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_ROWRESTRICT,                     DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_ROWTHREADMODEL,                  DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4, 2 },
+    { DBPROP_TRANSACTEDOBJECT,                DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_UPDATABILITY,                    DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4, 0 },
+    { DBPROP_STRONGIDENTITY,                  DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_IAccessor,                       DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_IColumnsInfo,                    DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_IColumnsRowset,                  DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_IConnectionPointContainer,       DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_IRowset,                         DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_IRowsetChange,                   DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_IRowsetIdentity,                 DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_IRowsetInfo,                     DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_IRowsetLocate,                   DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_IRowsetResynch,                  DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_IRowsetUpdate,                   DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_ISupportErrorInfo,               DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_ISequentialStream,               DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_NOTIFYCOLUMNSET,                 DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_NOTIFYROWDELETE,                 DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_NOTIFYROWFIRSTCHANGE,            DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_NOTIFYROWINSERT,                 DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_NOTIFYROWRESYNCH,                DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_NOTIFYROWSETRELEASE,             DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE, DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_NOTIFYROWUNDOCHANGE,             DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_NOTIFYROWUNDODELETE,             DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_NOTIFYROWUNDOINSERT,             DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_NOTIFYROWUPDATE,                 DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4,  3 },
+    { DBPROP_CHANGEINSERTEDROWS,              DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_RETURNPENDINGINSERTS,            DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_IConvertType,                    DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_NOTIFICATIONGRANULARITY,         DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_I4, 1 },
+    { DBPROP_IMultipleResults,                DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_ACCESSORDER,                     DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_I4, 1 },
+    { DBPROP_BOOKMARKINFO,                    DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4, 0 },
+    { DBPROP_UNIQUEROWS,                      DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_IRowsetFind,                     DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_IRowsetScroll,                   DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_IRowsetRefresh,                  DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_FINDCOMPAREOPS,                  DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ, VT_I4, 27 },
+    { DBPROP_ORDEREDBOOKMARKS,                DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_CLIENTCURSOR,                    DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_TRUE },
+    { DBPROP_ABORTPRESERVE,                   DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_ACTIVESESSIONS,                  DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_ASYNCTXNCOMMIT,                  DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_AUTH_CACHE_AUTHINFO,             DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_AUTH_ENCRYPT_PASSWORD,           DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_I4, 0 },
+    { DBPROP_AUTH_INTEGRATED,                 DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_I4, 14 },
+    { DBPROP_AUTH_MASK_PASSWORD,              DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_AUTH_PASSWORD,                   DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_AUTH_PERSIST_ENCRYPTED,          DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO, DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_AUTH_USERID,                     DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+    { DBPROP_BLOCKINGSTORAGEOBJECTS,          DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE, VT_BOOL, VARIANT_FALSE },
+};
+
+#define SQLTYPE_TO_STR(x) case x: return #x
+
+static const char *debugstr_sqltype(SQLSMALLINT type)
+{
+    switch (type)
+    {
+        SQLTYPE_TO_STR(SQL_DECIMAL);
+        SQLTYPE_TO_STR(SQL_CHAR);
+        SQLTYPE_TO_STR(SQL_VARCHAR);
+        SQLTYPE_TO_STR(SQL_LONGVARCHAR);
+        SQLTYPE_TO_STR(SQL_NUMERIC);
+        SQLTYPE_TO_STR(SQL_GUID);
+        SQLTYPE_TO_STR(SQL_TINYINT);
+        SQLTYPE_TO_STR(SQL_SMALLINT);
+        SQLTYPE_TO_STR(SQL_INTEGER);
+        SQLTYPE_TO_STR(SQL_REAL);
+        SQLTYPE_TO_STR(SQL_FLOAT);
+        SQLTYPE_TO_STR(SQL_DOUBLE);
+        SQLTYPE_TO_STR(SQL_BINARY);
+        SQLTYPE_TO_STR(SQL_VARBINARY);
+        SQLTYPE_TO_STR(SQL_LONGVARBINARY);
+        SQLTYPE_TO_STR(SQL_TYPE_DATE);
+        SQLTYPE_TO_STR(SQL_DATE);
+        SQLTYPE_TO_STR(SQL_TIME);
+        SQLTYPE_TO_STR(SQL_TYPE_TIMESTAMP);
+        SQLTYPE_TO_STR(SQL_TIMESTAMP);
+        SQLTYPE_TO_STR(SQL_TYPE_TIME);
+        SQLTYPE_TO_STR(SQL_BIGINT);
+        SQLTYPE_TO_STR(SQL_C_SBIGINT);
+        SQLTYPE_TO_STR(SQL_C_SLONG);
+        SQLTYPE_TO_STR(SQL_C_ULONG);
+        SQLTYPE_TO_STR(SQL_WLONGVARCHAR);
+        SQLTYPE_TO_STR(SQL_WCHAR);
+        SQLTYPE_TO_STR(SQL_WVARCHAR);
+        default:
+             return "Unknown";
+    }
+}
+
+static const char *debugstr_dbtype(DBTYPE type)
+{
+    switch(type)
+    {
+        SQLTYPE_TO_STR(DBTYPE_NUMERIC);
+        SQLTYPE_TO_STR(DBTYPE_STR);
+        SQLTYPE_TO_STR(DBTYPE_GUID);
+        SQLTYPE_TO_STR(DBTYPE_I1);
+        SQLTYPE_TO_STR(DBTYPE_I2);
+        SQLTYPE_TO_STR(DBTYPE_UI2);
+        SQLTYPE_TO_STR(DBTYPE_I4);
+        SQLTYPE_TO_STR(DBTYPE_I8);
+        SQLTYPE_TO_STR(DBTYPE_UI4);
+        SQLTYPE_TO_STR(DBTYPE_R4);
+        SQLTYPE_TO_STR(DBTYPE_R8);
+        SQLTYPE_TO_STR(DBTYPE_BYTES);
+        SQLTYPE_TO_STR(DBTYPE_DBDATE);
+        SQLTYPE_TO_STR(DBTYPE_DBTIME);
+        SQLTYPE_TO_STR(DBTYPE_DATE);
+        SQLTYPE_TO_STR(DBTYPE_DBTIMESTAMP);
+        SQLTYPE_TO_STR(DBTYPE_WSTR);
+        default:
+             return "Unknown";
+    }
+}
+
+static SQLSMALLINT sqltype_to_bindtype(SQLSMALLINT type, BOOL sign)
+{
+    switch (type)
+    {
+        case SQL_DECIMAL:
+            return DBTYPE_NUMERIC;
+        case SQL_CHAR:
+        case SQL_VARCHAR:
+        case SQL_LONGVARCHAR:
+        case SQL_NUMERIC:
+            return DBTYPE_STR;
+        case SQL_GUID:
+            return DBTYPE_GUID;
+        case SQL_TINYINT:
+            return DBTYPE_I1;
+        case SQL_SMALLINT:
+            return sign ? DBTYPE_I2 : DBTYPE_UI2;
+        case SQL_INTEGER:
+            return sign ? DBTYPE_I4 : DBTYPE_UI4;
+        case SQL_REAL:
+            return DBTYPE_R4;
+        case SQL_FLOAT:
+        case SQL_DOUBLE:
+            return DBTYPE_R8;
+        case SQL_BINARY:
+        case SQL_VARBINARY:
+        case SQL_LONGVARBINARY:
+            return DBTYPE_BYTES;
+        case SQL_TYPE_DATE:
+            return DBTYPE_DBDATE;
+        case SQL_DATE:
+            return DBTYPE_DBTIME;
+        case SQL_TIME:
+            return DBTYPE_DATE;
+        case SQL_TYPE_TIMESTAMP:
+        case SQL_TIMESTAMP:
+            return DBTYPE_DBTIMESTAMP;
+        case SQL_TYPE_TIME:
+            return DBTYPE_DBTIME;
+        case SQL_BIGINT:
+        case SQL_C_SBIGINT:
+            return DBTYPE_I8;
+        case SQL_C_SLONG:
+            return DBTYPE_I4;
+        case SQL_C_ULONG:
+            return DBTYPE_UI4;
+        case SQL_WLONGVARCHAR:
+        case SQL_WCHAR:
+        case SQL_WVARCHAR:
+            return DBTYPE_WSTR;
+        default:
+            FIXME("Unsupported type %i\n", type);
+    }
+
+    return DBTYPE_I4;
+}
+
+static BOOL is_variable_length(SQLSMALLINT type)
+{
+    switch(type)
+    {
+        case SQL_LONGVARCHAR:
+        case SQL_WLONGVARCHAR:
+        case SQL_LONGVARBINARY:
+            return TRUE;
+    }
+    return FALSE;
+}
+
+static BOOL is_fixed_length(SQLSMALLINT type)
+{
+    switch(type)
+    {
+        case SQL_LONGVARCHAR:
+        case SQL_WLONGVARCHAR:
+        case SQL_WVARCHAR:
+        case SQL_LONGVARBINARY:
+        case SQL_VARBINARY:
+            return FALSE;
+    }
+    return TRUE;
+}
+
 struct msdasql_session
 {
     IUnknown session_iface;
@@ -332,6 +573,9 @@ struct command
     IUnknown *session;
     HDBC hdbc;
     SQLHSTMT hstmt;
+
+    struct msdasql_prop *properties;
+    LONG prop_count;
 };
 
 static inline struct command *impl_from_ICommandText( ICommandText *iface )
@@ -449,6 +693,8 @@ static ULONG WINAPI command_Release(ICom
     if (!refs)
     {
         TRACE( "destroying %p\n", command );
+        if (command->properties)
+            heap_free(command->properties);
         if (command->session)
             IUnknown_Release(command->session);
 
@@ -659,8 +905,19 @@ static HRESULT WINAPI rowset_info_GetPro
         const DBPROPIDSET propertyidsets[], ULONG *out_count, DBPROPSET **propertysets)
 {
     struct msdasql_rowset *rowset = impl_from_IRowsetInfo( iface );
-    FIXME("%p, %lu, %p, %p, %p\n", rowset, count, propertyidsets, out_count, propertysets);
-    return E_NOTIMPL;
+    HRESULT hr;
+    ICommandProperties *props;
+
+    TRACE("%p, %lu, %p, %p, %p\n", rowset, count, propertyidsets, out_count, propertysets);
+
+    hr = IUnknown_QueryInterface(rowset->caller, &IID_ICommandProperties, (void**)&props);
+    if (FAILED(hr))
+        return hr;
+
+    hr = ICommandProperties_GetProperties(props, count, propertyidsets, out_count, propertysets);
+    ICommandProperties_Release(props);
+
+    return hr;
 }
 
 static HRESULT WINAPI rowset_info_GetReferencedRowset(IRowsetInfo *iface, DBORDINAL ordinal,
@@ -718,9 +975,134 @@ static ULONG  WINAPI rowset_colsinfo_Rel
 static HRESULT WINAPI rowset_colsinfo_GetColumnInfo(IColumnsInfo *iface, DBORDINAL *columns,
         DBCOLUMNINFO **colinfo, OLECHAR **stringsbuffer)
 {
+#define MAX_COLUMN_LEN 128
+
     struct msdasql_rowset *rowset = rowset_impl_from_IColumnsInfo( iface );
-    FIXME("%p, %p, %p, %p\n", rowset, columns, colinfo, stringsbuffer);
-    return E_NOTIMPL;
+    DBCOLUMNINFO *dbcolumn;
+    RETCODE ret;
+    SQLSMALLINT colcnt;
+    int i;
+    OLECHAR *ptr;
+
+    TRACE("%p, %p, %p, %p\n", rowset, columns, colinfo, stringsbuffer);
+
+    if (!columns || !colinfo || !stringsbuffer)
+        return E_INVALIDARG;
+
+    SQLNumResultCols(rowset->hstmt, &colcnt);
+    TRACE("SQLNumResultCols %d\n", colcnt);
+
+    *columns = colcnt;
+
+    ptr = *stringsbuffer = CoTaskMemAlloc(colcnt * MAX_COLUMN_LEN * sizeof(WCHAR));
+    if (!ptr)
+        return E_OUTOFMEMORY;
+
+    dbcolumn = CoTaskMemAlloc(colcnt * sizeof(DBCOLUMNINFO));
+    if (!dbcolumn)
+    {
+        CoTaskMemFree(ptr);
+        return E_OUTOFMEMORY;
+    }
+
+    for (i = 0; i < colcnt; i++)
+    {
+        SQLWCHAR      columnname[MAX_COLUMN_LEN];
+        SQLSMALLINT   ColumnNameLen;
+        SQLSMALLINT   ColumnDataType;
+        SQLULEN       ColumnDataSize;
+        SQLSMALLINT   ColumnDataDigits;
+        SQLSMALLINT   ColumnDataNullable;
+
+        ret = SQLDescribeColW(rowset->hstmt, i+1, columnname, MAX_COLUMN_LEN, &ColumnNameLen, &ColumnDataType,
+                    &ColumnDataSize, &ColumnDataDigits, &ColumnDataNullable);
+        if (SQL_SUCCEEDED(ret))
+        {
+            SQLLEN  length;
+
+            TRACE("%d: Column Name : %s, Column Name Len : %i, SQL Data Type : %i, Data Size : %i, DecimalDigits : %i, Nullable %i\n",
+                 i, debugstr_w(columnname), (int)ColumnNameLen, (int)ColumnDataType, (int)ColumnDataSize, (int)ColumnDataDigits,
+                 (int)ColumnDataNullable);
+            lstrcpyW(ptr, columnname);
+
+            dbcolumn[i].pwszName = ptr;
+            dbcolumn[i].pTypeInfo = NULL;
+            dbcolumn[i].iOrdinal = i+1;
+
+            ret = SQLColAttribute(rowset->hstmt, i+1, SQL_DESC_UNSIGNED, NULL, 0, NULL, &length);
+            if (!SQL_SUCCEEDED(ret))
+            {
+                CoTaskMemFree(ptr);
+                CoTaskMemFree(dbcolumn);
+                ERR("Failed to get column %d attribute\n", i+1);
+                return E_FAIL;
+            }
+
+            dbcolumn[i].wType = sqltype_to_bindtype(ColumnDataType, length == SQL_FALSE);
+            TRACE("SQLType %s -> %s\n", debugstr_sqltype(ColumnDataType), debugstr_dbtype(dbcolumn[i].wType));
+
+            dbcolumn[i].dwFlags = DBCOLUMNFLAGS_WRITE;
+
+            ret = SQLColAttribute(rowset->hstmt, i+1, SQL_DESC_LENGTH, NULL, 0, NULL, &length);
+            if (!SQL_SUCCEEDED(ret))
+            {
+                CoTaskMemFree(ptr);
+                CoTaskMemFree(dbcolumn);
+                ERR("Failed to get column %d length (%d)\n", i+1, ret);
+                return E_FAIL;
+            }
+            dbcolumn[i].ulColumnSize = length;
+
+            if (dbcolumn[i].ulColumnSize > 1024 && is_variable_length(ColumnDataType))
+                dbcolumn[i].dwFlags |= DBCOLUMNFLAGS_MAYDEFER | DBCOLUMNFLAGS_ISLONG;
+
+            if (ColumnDataNullable)
+                dbcolumn[i].dwFlags |= DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL;
+
+            if (is_fixed_length(ColumnDataType))
+                dbcolumn[i].dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH;
+
+            ret = SQLColAttribute(rowset->hstmt, i+1, SQL_DESC_SCALE, NULL, 0, NULL, &length);
+            if (!SQL_SUCCEEDED(ret))
+            {
+                CoTaskMemFree(ptr);
+                CoTaskMemFree(dbcolumn);
+                ERR("Failed to get column %d scale (%d)\n", i+1, ret);
+                return E_FAIL;
+            }
+            if (length == 0)
+                length = 255;
+            dbcolumn[i].bScale = length;
+
+            ret = SQLColAttribute(rowset->hstmt, i+1, SQL_DESC_PRECISION, NULL, 0, NULL, &length);
+            if (!SQL_SUCCEEDED(ret))
+            {
+                CoTaskMemFree(ptr);
+                CoTaskMemFree(dbcolumn);
+                ERR("Failed to get column %d precision (%d)\n", i+1, ret);
+                return E_FAIL;
+            }
+            if (length == 0)
+                length = 255;
+            dbcolumn[i].bPrecision= length;
+
+            dbcolumn[i].columnid.eKind = DBKIND_NAME;
+            dbcolumn[i].columnid.uName.pwszName = ptr;
+
+            ptr += ColumnNameLen + 1;
+        }
+        else
+        {
+            CoTaskMemFree(ptr);
+            CoTaskMemFree(dbcolumn);
+            ERR("Failed to get column %d description (%d)\n", i+1, ret);
+            return E_FAIL;
+        }
+    }
+
+    *colinfo = dbcolumn;
+#undef MAX_COLUMN_LEN
+    return S_OK;
 }
 
 static HRESULT WINAPI rowset_colsinfo_MapColumnIDs(IColumnsInfo *iface, DBORDINAL column_ids,
@@ -821,8 +1203,16 @@ static ULONG WINAPI column_rs_Release(IC
 static HRESULT WINAPI column_rs_GetAvailableColumns(IColumnsRowset *iface, DBORDINAL *count, DBID **columns)
 {
     struct msdasql_rowset *rowset = impl_from_IColumnsRowset( iface );
-    FIXME("%p, %p, %p\n", rowset, count, columns);
-    return E_NOTIMPL;
+
+    TRACE("%p, %p, %p\n", rowset, count, columns);
+
+    if (!count || !columns)
+        return E_INVALIDARG;
+
+    *count = 0;
+    *columns = NULL;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI column_rs_GetColumnsRowset(IColumnsRowset *iface, IUnknown *outer, DBORDINAL count,
@@ -865,13 +1255,6 @@ static HRESULT WINAPI command_Execute(IC
         return E_FAIL;
     }
 
-    ret = SQLRowCount(hstmt, &results);
-    if (ret != SQL_SUCCESS)
-        ERR("SQLRowCount failed (%d)\n", ret);
-
-    if (affected)
-        *affected = results;
-
     *rowset = NULL;
     if (!wcsnicmp( command->query, L"select ", 7 ))
     {
@@ -894,7 +1277,16 @@ static HRESULT WINAPI command_Execute(IC
         IRowset_Release(&msrowset->IRowset_iface);
     }
     else
+    {
+        ret = SQLRowCount(hstmt, &results);
+        if (ret != SQL_SUCCESS)
+            ERR("SQLRowCount failed (%d)\n", ret);
+
         SQLFreeStmt(hstmt, SQL_CLOSE);
+    }
+
+    if (affected)
+        *affected = results;
 
     return hr;
 }
@@ -989,19 +1381,187 @@ static ULONG WINAPI command_prop_Release
     return ICommandText_Release(&command->ICommandText_iface);
 }
 
+static ULONG get_property_count(DWORD flag, struct msdasql_prop *properties, int prop_count)
+{
+    int i, count = 0;
+
+    for(i=0; i < prop_count; i++)
+    {
+        if (properties[i].flags & flag)
+            count++;
+    }
+
+    return count;
+}
+
 static HRESULT WINAPI command_prop_GetProperties(ICommandProperties *iface, ULONG count,
         const DBPROPIDSET propertyidsets[], ULONG *sets_cnt, DBPROPSET **propertyset)
 {
     struct command *command = impl_from_ICommandProperties( iface );
-    FIXME("%p %lu %p %p %p\n", command, count, propertyidsets, sets_cnt, propertyset);
-    return E_NOTIMPL;
+    DBPROPSET *propset = NULL;
+    int i, j, k;
+
+    TRACE("%p %ld %p %p %p\n", command, count, propertyidsets, sets_cnt, propertyset);
+
+    /* All Properties */
+    if (count == 0)
+    {
+        int idx;
+        propset = CoTaskMemAlloc(2 * sizeof(DBPROPSET));
+        if (!propset)
+            return E_OUTOFMEMORY;
+
+        propset[0].guidPropertySet = DBPROPSET_ROWSET;
+        propset[0].cProperties = get_property_count(DBPROPFLAGS_ROWSET, command->properties, command->prop_count);
+        propset[0].rgProperties = CoTaskMemAlloc(propset[0].cProperties * sizeof(DBPROP));
+        if (!propset[0].rgProperties)
+        {
+            CoTaskMemFree(propset);
+            return E_OUTOFMEMORY;
+        }
+
+        idx = 0;
+        for (j=0; j < command->prop_count; j++)
+        {
+            if (!(command->properties[j].flags & DBPROPFLAGS_ROWSET))
+                continue;
+            propset[0].rgProperties[idx].dwPropertyID = command->properties[j].property_id;
+
+            V_VT(&propset[0].rgProperties[idx].vValue) = command->properties[j].vartype;
+            if (command->properties[j].vartype == VT_BOOL)
+            {
+                V_BOOL(&propset[0].rgProperties[idx].vValue) = command->properties[j].value;
+            }
+            else if (command->properties[j].vartype == VT_I4)
+            {
+                V_I4(&propset[0].rgProperties[idx].vValue) = command->properties[j].value;
+            }
+            else
+                ERR("Unknown variant type %d\n", command->properties[j].vartype);
+
+            idx++;
+        }
+
+        propset[1].guidPropertySet = DBPROPSET_PROVIDERROWSET;
+        propset[1].cProperties = get_property_count(DBPROPFLAGS_DATASOURCEINFO, command->properties, command->prop_count);
+        propset[1].rgProperties = CoTaskMemAlloc(propset[1].cProperties * sizeof(DBPROP));
+        if (!propset[1].rgProperties)
+        {
+            CoTaskMemFree(propset[0].rgProperties);
+            CoTaskMemFree(propset);
+            return E_OUTOFMEMORY;
+        }
+
+        idx = 0;
+        for (j=0; j < command->prop_count; j++)
+        {
+            if (!(command->properties[j].flags & DBPROPFLAGS_DATASOURCEINFO))
+                continue;
+            propset[1].rgProperties[idx].dwPropertyID = command->properties[j].property_id;
+
+            V_VT(&propset[1].rgProperties[idx].vValue) = command->properties[j].vartype;
+            if (command->properties[j].vartype == VT_BOOL)
+            {
+                V_BOOL(&propset[1].rgProperties[idx].vValue) = command->properties[j].value;
+            }
+            else if (command->properties[j].vartype == VT_I4)
+            {
+                V_I4(&propset[1].rgProperties[idx].vValue) = command->properties[j].value;
+            }
+            else
+                ERR("Unknown variant type %d\n", command->properties[j].vartype);
+
+            idx++;
+        }
+
+        *sets_cnt = 2;
+    }
+    else
+    {
+        propset = CoTaskMemAlloc(count * sizeof(DBPROPSET));
+        if (!propset)
+            return E_OUTOFMEMORY;
+
+        for (i=0; i < count; i++)
+        {
+            TRACE("Property id %d (count %ld, set %s)\n", i, propertyidsets[i].cPropertyIDs,
+                    debugstr_guid(&propertyidsets[i].guidPropertySet));
+
+            propset[i].cProperties = propertyidsets[i].cPropertyIDs;
+            propset[i].rgProperties = CoTaskMemAlloc(propset[i].cProperties * sizeof(DBPROP));
+
+            for (j=0; j < propset[i].cProperties; j++)
+            {
+                propset[i].rgProperties[j].dwPropertyID = propertyidsets[i].rgPropertyIDs[j];
+
+                for(k = 0; k < command->prop_count; k++)
+                {
+                    if (command->properties[k].property_id == propertyidsets[i].rgPropertyIDs[j])
+                    {
+                        V_VT(&propset[i].rgProperties[i].vValue) = command->properties[j].vartype;
+                        if (command->properties[j].vartype == VT_BOOL)
+                        {
+                            V_BOOL(&propset[i].rgProperties[i].vValue) = command->properties[j].value;
+                        }
+                        else if (command->properties[j].vartype == VT_I4)
+                        {
+                            V_I4(&propset[i].rgProperties[i].vValue) = command->properties[j].value;
+                        }
+                        else
+                            ERR("Unknown variant type %d\n", command->properties[j].vartype);
+                        break;
+                    }
+                }
+            }
+        }
+
+        *sets_cnt = count;
+    }
+
+    *propertyset = propset;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI command_prop_SetProperties(ICommandProperties *iface, ULONG count,
         DBPROPSET propertyset[])
 {
     struct command *command = impl_from_ICommandProperties( iface );
-    FIXME("%p, %lu, %p\n", command, count, propertyset);
+    int i, j, k;
+
+    TRACE("%p %lu, %p\n", command, count, propertyset);
+
+    for(i=0; i < count; i++)
+    {
+        TRACE("set %s, count %ld\n", debugstr_guid(&propertyset[i].guidPropertySet), propertyset[i].cProperties);
+        for(j=0; j < propertyset[i].cProperties; j++)
+        {
+            for(k=0; k < command->prop_count; k++)
+            {
+                if (command->properties[k].property_id == propertyset[i].rgProperties[j].dwPropertyID)
+                {
+                    TRACE("Found property 0x%08lx\n", command->properties[k].property_id);
+                    if (command->properties[k].flags & DBPROPFLAGS_WRITE)
+                    {
+                        if (command->properties[k].vartype == VT_BOOL)
+                        {
+                            command->properties[k].value = V_BOOL(&propertyset[i].rgProperties[j].vValue);
+                        }
+                        else if (command->properties[k].vartype == VT_I4)
+                        {
+                            command->properties[k].value = V_I4(&propertyset[i].rgProperties[j].vValue);
+                        }
+                        else
+                            ERR("Unknown variant type %d\n", command->properties[j].vartype);
+                    }
+                    else
+                        WARN("Attempting to set Readonly property\n");
+
+                    break;
+                }
+            }
+        }
+    }
     return S_OK;
 }
 
@@ -1227,6 +1787,10 @@ static HRESULT WINAPI createcommand_Crea
     command->hdbc = session->hdbc;
     command->hstmt = NULL;
 
+    command->prop_count = ARRAY_SIZE(msdasql_init_props);
+    command->properties = heap_alloc(sizeof(msdasql_init_props));
+    memcpy(command->properties, msdasql_init_props, sizeof(msdasql_init_props));
+
     IUnknown_QueryInterface(&session->session_iface, &IID_IUnknown, (void**)&command->session);
 
     hr = ICommandText_QueryInterface(&command->ICommandText_iface, riid, (void**)out);
diff -Npur a/dlls/msdasql/tests/provider.c b/dlls/msdasql/tests/provider.c
--- a/dlls/msdasql/tests/provider.c	2023-01-10 20:25:29.126519244 -0500
+++ b/dlls/msdasql/tests/provider.c	2023-01-10 09:35:53.000000000 -0500
@@ -34,6 +34,7 @@
 DEFINE_GUID(DBPROPSET_DATASOURCEINFO, 0xc8b522bb, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
 DEFINE_GUID(DBPROPSET_DBINITALL, 0xc8b522ca, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
 DEFINE_GUID(DBPROPSET_DBINIT,    0xc8b522bc, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
+DEFINE_GUID(DBPROPSET_ROWSET,    0xc8b522be, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
 
 DEFINE_GUID(DBGUID_DEFAULT,      0xc8b521fb, 0x5cf3, 0x11ce, 0xad, 0xe5, 0x00, 0xaa, 0x00, 0x44, 0x77, 0x3d);
 
@@ -183,6 +184,149 @@ static void test_Properties(void)
     IDBProperties_Release(props);
 }
 
+static void test_command_properties(ICommandProperties *props)
+{
+    HRESULT hr;
+    ULONG count;
+    DBPROPSET *propset;
+    int i;
+
+    DWORD row_props[68] = {
+            DBPROP_ABORTPRESERVE, DBPROP_BLOCKINGSTORAGEOBJECTS, DBPROP_BOOKMARKS, DBPROP_BOOKMARKSKIPPED,
+            DBPROP_BOOKMARKTYPE, DBPROP_CANFETCHBACKWARDS, DBPROP_CANHOLDROWS, DBPROP_CANSCROLLBACKWARDS,
+            DBPROP_COLUMNRESTRICT, DBPROP_COMMITPRESERVE, DBPROP_DELAYSTORAGEOBJECTS, DBPROP_IMMOBILEROWS,
+            DBPROP_LITERALBOOKMARKS, DBPROP_LITERALIDENTITY, DBPROP_MAXOPENROWS, DBPROP_MAXPENDINGROWS,
+            DBPROP_MAXROWS, DBPROP_NOTIFICATIONPHASES, DBPROP_OTHERUPDATEDELETE, DBPROP_OWNINSERT,
+            DBPROP_OWNUPDATEDELETE, DBPROP_QUICKRESTART, DBPROP_REENTRANTEVENTS, DBPROP_REMOVEDELETED,
+            DBPROP_REPORTMULTIPLECHANGES, DBPROP_ROWRESTRICT, DBPROP_ROWTHREADMODEL, DBPROP_TRANSACTEDOBJECT,
+            DBPROP_UPDATABILITY, DBPROP_STRONGIDENTITY, DBPROP_IAccessor, DBPROP_IColumnsInfo,
+            DBPROP_IColumnsRowset, DBPROP_IConnectionPointContainer, DBPROP_IRowset, DBPROP_IRowsetChange,
+            DBPROP_IRowsetIdentity, DBPROP_IRowsetInfo, DBPROP_IRowsetLocate, DBPROP_IRowsetResynch,
+            DBPROP_IRowsetUpdate, DBPROP_ISupportErrorInfo, DBPROP_ISequentialStream, DBPROP_NOTIFYCOLUMNSET,
+            DBPROP_NOTIFYROWDELETE, DBPROP_NOTIFYROWFIRSTCHANGE, DBPROP_NOTIFYROWINSERT, DBPROP_NOTIFYROWRESYNCH,
+            DBPROP_NOTIFYROWSETRELEASE, DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE, DBPROP_NOTIFYROWUNDOCHANGE, DBPROP_NOTIFYROWUNDODELETE,
+            DBPROP_NOTIFYROWUNDOINSERT, DBPROP_NOTIFYROWUPDATE, DBPROP_CHANGEINSERTEDROWS, DBPROP_RETURNPENDINGINSERTS,
+            DBPROP_IConvertType, DBPROP_NOTIFICATIONGRANULARITY, DBPROP_IMultipleResults, DBPROP_ACCESSORDER,
+            DBPROP_BOOKMARKINFO, DBPROP_UNIQUEROWS, DBPROP_IRowsetFind, DBPROP_IRowsetScroll,
+            DBPROP_IRowsetRefresh, DBPROP_FINDCOMPAREOPS, DBPROP_ORDEREDBOOKMARKS, DBPROP_CLIENTCURSOR
+    };
+
+    DWORD prov_props[12] = {
+            DBPROP_ABORTPRESERVE, DBPROP_ACTIVESESSIONS, DBPROP_ASYNCTXNCOMMIT, DBPROP_AUTH_CACHE_AUTHINFO,
+            DBPROP_AUTH_ENCRYPT_PASSWORD, DBPROP_AUTH_INTEGRATED, DBPROP_AUTH_MASK_PASSWORD, DBPROP_AUTH_PASSWORD,
+            DBPROP_AUTH_PERSIST_ENCRYPTED, DBPROP_AUTH_PERSIST_SENSITIVE_AUTHINFO, DBPROP_AUTH_USERID, DBPROP_BLOCKINGSTORAGEOBJECTS
+    };
+
+    hr = ICommandProperties_GetProperties(props, 0, NULL, &count, &propset);
+    ok(hr == S_OK, "got 0x%08lx\n", hr);
+    ok(count == 2, "got %ld\n", count);
+    ok(propset[0].cProperties == 68, "got %ld\n", propset[0].cProperties);
+    ok(propset[1].cProperties == 12, "got %ld\n", propset[1].cProperties);
+
+    ok(IsEqualGUID(&DBPROPSET_ROWSET, &propset[0].guidPropertySet), "got %s\n",
+        debugstr_guid(&propset[0].guidPropertySet));
+    for (i = 0; i < propset[0].cProperties; i++)
+    {
+        ok(propset[0].rgProperties[i].dwPropertyID == row_props[i], "%d: got 0x%08lx\n", i, propset[0].rgProperties[i].dwPropertyID);
+
+        switch(propset[0].rgProperties[i].dwPropertyID )
+        {
+            case DBPROP_BOOKMARKTYPE:
+            case DBPROP_NOTIFICATIONGRANULARITY:
+            case DBPROP_ACCESSORDER:
+                ok(V_VT(&propset[0].rgProperties[i].vValue) == VT_I4, "%d: got %d\n", i, V_VT(&propset[0].rgProperties[i].vValue));
+                ok(V_I4(&propset[0].rgProperties[i].vValue) == 1, "%d: got %ld\n", i, V_I4(&propset[0].rgProperties[i].vValue));
+                break;
+            case DBPROP_MAXOPENROWS:
+            case DBPROP_MAXPENDINGROWS:
+            case DBPROP_MAXROWS:
+            case DBPROP_UPDATABILITY:
+            case DBPROP_BOOKMARKINFO:
+                ok(V_VT(&propset[0].rgProperties[i].vValue) == VT_I4, "%d: got %d\n", i, V_VT(&propset[0].rgProperties[i].vValue));
+                ok(V_I4(&propset[0].rgProperties[i].vValue) == 0, "%d: got %ld\n", i, V_I4(&propset[0].rgProperties[i].vValue));
+                break;
+            case DBPROP_FINDCOMPAREOPS:
+                ok(V_VT(&propset[0].rgProperties[i].vValue) == VT_I4, "%d: got %d\n", i, V_VT(&propset[0].rgProperties[i].vValue));
+                ok(V_I4(&propset[0].rgProperties[i].vValue) == 27, "%d: got %ld\n", i, V_I4(&propset[0].rgProperties[i].vValue));
+                break;
+            case DBPROP_NOTIFICATIONPHASES:
+                ok(V_VT(&propset[0].rgProperties[i].vValue) == VT_I4, "%d: got %d\n", i, V_VT(&propset[0].rgProperties[i].vValue));
+                ok(V_I4(&propset[0].rgProperties[i].vValue) == 31, "%d: got %ld\n", i, V_I4(&propset[0].rgProperties[i].vValue));
+                break;
+            case DBPROP_ROWTHREADMODEL:
+                ok(V_VT(&propset[0].rgProperties[i].vValue) == VT_I4, "%d: got %d\n", i, V_VT(&propset[0].rgProperties[i].vValue));
+                ok(V_I4(&propset[0].rgProperties[i].vValue) == 2, "%d: got %ld\n", i, V_I4(&propset[0].rgProperties[i].vValue));
+                break;
+            case DBPROP_NOTIFYCOLUMNSET:
+            case DBPROP_NOTIFYROWDELETE:
+            case DBPROP_NOTIFYROWFIRSTCHANGE:
+            case DBPROP_NOTIFYROWINSERT:
+            case DBPROP_NOTIFYROWRESYNCH:
+            case DBPROP_NOTIFYROWSETRELEASE:
+            case DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE:
+            case DBPROP_NOTIFYROWUNDOCHANGE:
+            case DBPROP_NOTIFYROWUNDODELETE:
+            case DBPROP_NOTIFYROWUNDOINSERT:
+            case DBPROP_NOTIFYROWUPDATE:
+                ok(V_VT(&propset[0].rgProperties[i].vValue) == VT_I4, "%d: got %d\n", i, V_VT(&propset[0].rgProperties[i].vValue));
+                ok(V_I4(&propset[0].rgProperties[i].vValue) == 3, "%d: got %ld\n", i, V_I4(&propset[0].rgProperties[i].vValue));
+                break;
+            case DBPROP_BLOCKINGSTORAGEOBJECTS:
+            case DBPROP_IMMOBILEROWS:
+            case DBPROP_LITERALIDENTITY:
+            case DBPROP_REENTRANTEVENTS:
+            case DBPROP_IAccessor:
+            case DBPROP_IColumnsInfo:
+            case DBPROP_IColumnsRowset:
+            case DBPROP_IRowset:
+            case DBPROP_IRowsetInfo:
+            case DBPROP_ISupportErrorInfo:
+            case DBPROP_CHANGEINSERTEDROWS:
+            case DBPROP_IConvertType:
+            case DBPROP_IRowsetScroll:
+            case DBPROP_IRowsetRefresh:
+            case DBPROP_ORDEREDBOOKMARKS:
+            case DBPROP_CLIENTCURSOR:
+                ok(V_VT(&propset[0].rgProperties[i].vValue) == VT_BOOL, "%d: got %d\n", i, V_VT(&propset[0].rgProperties[i].vValue));
+                ok(V_BOOL(&propset[0].rgProperties[i].vValue) == VARIANT_TRUE, "%d: got %ld\n", i, V_I4(&propset[0].rgProperties[i].vValue));
+                break;
+            default:
+                ok(V_VT(&propset[0].rgProperties[i].vValue) == VT_BOOL, "%d: got %d\n", i, V_VT(&propset[0].rgProperties[i].vValue));
+                ok(V_BOOL(&propset[0].rgProperties[i].vValue) == VARIANT_FALSE, "%d: got %ld\n", i, V_I4(&propset[0].rgProperties[i].vValue));
+                break;
+        }
+    }
+
+    ok(IsEqualGUID(&DBPROPSET_PROVIDERROWSET, &propset[1].guidPropertySet), "got %s\n",
+        debugstr_guid(&propset[1].guidPropertySet));
+    for (i = 0; i < propset[1].cProperties; i++)
+    {
+        ok(propset[1].rgProperties[i].dwPropertyID == prov_props[i], "%d: got 0x%08lx\n", i, propset[1].rgProperties[i].dwPropertyID);
+
+        switch(propset[1].rgProperties[i].dwPropertyID )
+        {
+            case DBPROP_AUTH_ENCRYPT_PASSWORD:
+                ok(V_VT(&propset[1].rgProperties[i].vValue) == VT_I4, "%d: got %d\n", i, V_VT(&propset[1].rgProperties[i].vValue));
+                ok(V_I4(&propset[1].rgProperties[i].vValue) == 0, "%d: got %ld\n", i, V_I4(&propset[1].rgProperties[i].vValue));
+                break;
+            case DBPROP_AUTH_INTEGRATED:
+                ok(V_VT(&propset[1].rgProperties[i].vValue) == VT_I4, "%d: got %d\n", i, V_VT(&propset[1].rgProperties[i].vValue));
+                ok(V_I4(&propset[1].rgProperties[i].vValue) == 14, "%d: got %ld\n", i, V_I4(&propset[1].rgProperties[i].vValue));
+                break;
+            case DBPROP_BLOCKINGSTORAGEOBJECTS:
+                ok(V_VT(&propset[1].rgProperties[i].vValue) == VT_BOOL, "%d: got %d\n", i, V_VT(&propset[1].rgProperties[i].vValue));
+                ok(V_BOOL(&propset[1].rgProperties[i].vValue) == VARIANT_FALSE, "%d: got %ld\n", i, V_I4(&propset[1].rgProperties[i].vValue));
+                break;
+            default:
+                ok(V_VT(&propset[1].rgProperties[i].vValue) == VT_BOOL, "%d: got %d\n", i, V_VT(&propset[1].rgProperties[i].vValue));
+                ok(V_BOOL(&propset[1].rgProperties[i].vValue) == VARIANT_FALSE, "%d: got %ld\n", i, V_I4(&propset[1].rgProperties[i].vValue));
+                break;
+        }
+    }
+
+    CoTaskMemFree(propset);
+}
+
 static void test_command_interfaces(IUnknown *cmd)
 {
     HRESULT hr;
@@ -198,6 +342,7 @@ static void test_command_interfaces(IUnk
 
     hr = IUnknown_QueryInterface(cmd, &IID_ICommandProperties, (void**)&commandProp);
     ok(hr == S_OK, "got 0x%08lx\n", hr);
+    test_command_properties(commandProp);
     ICommandProperties_Release(commandProp);
 
     hr = IUnknown_QueryInterface(cmd, &IID_ICommandWithParameters, (void**)&cmdwithparams);
@@ -351,6 +496,43 @@ static void test_rowset_interfaces(IRows
     ok(hr == E_NOINTERFACE, "got 0x%08lx\n", hr);
 }
 
+static void test_rowset_info(IRowset *rowset)
+{
+    IRowsetInfo *info;
+    HRESULT hr;
+    ULONG propcnt;
+    DBPROPIDSET propidset;
+    DBPROPSET *propset;
+    int i;
+    DWORD row_props[] = {
+            DBPROP_CANSCROLLBACKWARDS, DBPROP_IRowsetUpdate, DBPROP_IRowsetResynch,
+            DBPROP_IConnectionPointContainer, DBPROP_BOOKMARKSKIPPED, DBPROP_REMOVEDELETED,
+            DBPROP_IConvertType, DBPROP_NOTIFICATIONGRANULARITY, DBPROP_IMultipleResults, DBPROP_ACCESSORDER,
+            DBPROP_BOOKMARKINFO, DBPROP_UNIQUEROWS
+    };
+
+    hr = IRowset_QueryInterface(rowset, &IID_IRowsetInfo, (void**)&info);
+    ok(hr == S_OK, "got 0x%08lx\n", hr);
+
+    propidset.rgPropertyIDs = row_props;
+    propidset.cPropertyIDs = ARRAY_SIZE(row_props);
+    propidset.guidPropertySet = DBPROPSET_ROWSET;
+
+    hr = IRowsetInfo_GetProperties(info, 1, &propidset, &propcnt, &propset);
+    ok(hr == S_OK, "got 0x%08lx\n", hr);
+    ok(propset->cProperties == ARRAY_SIZE(row_props), "got %lu\n", propset->cProperties);
+
+    for(i=0; i < ARRAY_SIZE(row_props); i++)
+    {
+        ok(propset->rgProperties[i].dwPropertyID == row_props[i], "expected 0x%08lx got 0x%08lx\n",
+                propset->rgProperties[i].dwPropertyID, row_props[i]);
+    }
+
+    CoTaskMemFree(propset);
+
+    IRowsetInfo_Release(info);
+}
+
 static void test_command_rowset(IUnknown *cmd)
 {
     ICommandText *command_text;
@@ -372,7 +554,7 @@ static void test_command_rowset(IUnknown
     hr = ICommandPrepare_Prepare(commandprepare, 1);
     ok(hr == DB_E_NOCOMMAND, "got 0x%08lx\n", hr);
 
-    hr = ICommandText_SetCommandText(command_text, &DBGUID_DEFAULT, L"CREATE TABLE testing (col1 INT, col2 SHORT)");
+    hr = ICommandText_SetCommandText(command_text, &DBGUID_DEFAULT, L"CREATE TABLE testing (col1 INT, col2 VARCHAR(20) NOT NULL, col3 FLOAT)");
     ok(hr == S_OK, "got 0x%08lx\n", hr);
 
     hr = ICommandPrepare_Prepare(commandprepare, 1);
@@ -387,7 +569,7 @@ static void test_command_rowset(IUnknown
     if (unk)
         IUnknown_Release(unk);
 
-    hr = ICommandText_SetCommandText(command_text, &DBGUID_DEFAULT, L"insert into testing values(1, 0)");
+    hr = ICommandText_SetCommandText(command_text, &DBGUID_DEFAULT, L"insert into testing values(1, 'red', 1.0)");
     ok(hr == S_OK, "got 0x%08lx\n", hr);
 
     affected = 9999;
@@ -405,13 +587,45 @@ static void test_command_rowset(IUnknown
     ok(unk != NULL, "Unexpected value\n");
     if (hr == S_OK)
     {
-        ok(affected == -1, "got %Id\n", affected);
+        const DWORD flag1 = DBCOLUMNFLAGS_ISFIXEDLENGTH | DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL | DBCOLUMNFLAGS_WRITE;
+        const DWORD flag2 = DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_MAYBENULL | DBCOLUMNFLAGS_WRITE;
+        IColumnsInfo *colinfo;
+        DBORDINAL columns;
+        DBCOLUMNINFO *dbcolinfo;
+        OLECHAR *stringsbuffer;
+
+        todo_wine ok(affected == -1, "got %Id\n", affected);
 
         hr = IUnknown_QueryInterface(unk, &IID_IRowset, (void**)&rowset);
         ok(hr == S_OK, "got 0x%08lx\n", hr);
 
         test_rowset_interfaces(rowset, command_text);
 
+        hr = IRowset_QueryInterface(rowset, &IID_IColumnsInfo, (void**)&colinfo);
+        ok(hr == S_OK, "got 0x%08lx\n", hr);
+
+        columns = 0;
+        hr = IColumnsInfo_GetColumnInfo(colinfo, &columns, &dbcolinfo, &stringsbuffer);
+        ok(hr == S_OK, "got 0x%08lx\n", hr);
+        ok(columns == 3, "got %Iu\n", columns);
+
+        ok(dbcolinfo[0].dwFlags == flag1, "got 0x%08lx\n", dbcolinfo[0].dwFlags);
+        ok(dbcolinfo[0].wType == DBTYPE_I4, "got 0x%08x\n", dbcolinfo[0].wType);
+
+        todo_wine ok(dbcolinfo[1].dwFlags == flag2, "got 0x%08lx\n", dbcolinfo[1].dwFlags);
+        ok(dbcolinfo[1].wType == DBTYPE_WSTR /* Unicode MySQL Driver */ ||
+           dbcolinfo[1].wType == DBTYPE_STR  /* ASCII MySQL Driver */, "got 0x%08x\n", dbcolinfo[1].wType);
+
+        ok(dbcolinfo[2].dwFlags == flag1, "got 0x%08lx\n", dbcolinfo[2].dwFlags);
+        ok(dbcolinfo[2].wType == DBTYPE_R4 /* MySQL */ ||
+           dbcolinfo[2].wType == DBTYPE_R8 /* Access */, "got 0x%08x\n", dbcolinfo[2].wType);
+
+        CoTaskMemFree(dbcolinfo);
+        CoTaskMemFree(stringsbuffer);
+        IColumnsInfo_Release(colinfo);
+
+        test_rowset_info(rowset);
+
         IRowset_Release(rowset);
         IUnknown_Release(unk);
     }
