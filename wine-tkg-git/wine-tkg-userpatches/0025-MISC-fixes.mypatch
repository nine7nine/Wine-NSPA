From: Piotr Caban <piotr@codeweavers.com>
Subject: [PATCH v2] server: Don't wait for low level hook result when queuing hardware message.
Message-Id: <daf382d3-924e-7c33-c876-5b8d6298c137@codeweavers.com>
Date: Tue, 21 Sep 2021 15:51:35 +0200


Without the change graphic drivers are blocking until low level hooks
are processed when injecting keyboard and mouse events. Causes 2-seconds 
(timeout) freeze in GtaV.

Signed-off-by: Piotr Caban <piotr@codeweavers.com>
---
v2:
  - don't specify sender in send_hook_ll_message to avoid queuing result

  server/queue.c | 16 +++++++++++++---
  1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2132,7 +2132,12 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         /* specify a sender only when sending the last message */
         if (!(flags & ((1 << ARRAY_SIZE( messages )) - 1)))
         {
-            if (!(wait = send_hook_ll_message( desktop, msg, input, sender )))
+            if (origin == IMO_HARDWARE)
+            {
+                if (!send_hook_ll_message( desktop, msg, input, NULL ))
+                    queue_hardware_message( desktop, msg, 0 );
+            }
+            else if (!(wait = send_hook_ll_message( desktop, msg, input, sender )))
                 queue_hardware_message( desktop, msg, 0 );
         }
         else if (!send_hook_ll_message( desktop, msg, input, NULL ))
@@ -2153,7 +2158,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
     struct thread *foreground;
     unsigned char vkey = input->kbd.vkey;
     unsigned int message_code, time;
-    int wait;
+    int wait = 0;
 
     if (!(time = input->kbd.time)) time = get_tick_count();
 
@@ -2273,7 +2278,12 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         msg_data->flags |= (flags & (KF_EXTENDED | KF_ALTDOWN | KF_UP)) >> 8;
     }
 
-    if (!(wait = send_hook_ll_message( desktop, msg, input, sender )))
+    if (origin == IMO_HARDWARE)
+    {
+        if (!send_hook_ll_message( desktop, msg, input, NULL ))
+            queue_hardware_message( desktop, msg, 1 );
+    }
+    else if (!(wait = send_hook_ll_message( desktop, msg, input, sender )))
         queue_hardware_message( desktop, msg, 1 );
 
     return wait;
From: Keno Fischer <keno@juliacomputing.com>
Subject: [PATCH v2] ntdll: NtCurrentTeb: Remove unnecessary use of .byte
Message-Id: <20211216000953.GA1695242@juliacomputing.com>
Date: Wed, 15 Dec 2021 19:09:53 -0500

The definitions of `NtCurrentTeb` make use of an inline-assembly .byte
prefix to access the `fs` and `gs` prefixes. Given that the last-modify
date for this file is 23 and 13 years ago for i386 and x86_64
respectively, I assume the reason for this use of `.byte` is that the
assemblers of the time did not understand the %fs and %gs prefixes
in textual assembly. However, this is not the case anymore and modern
assemblers understand these just fine. Further, this doesn't reduce
the set of assembler versions capable of building wine either, since
wine elsewhere uses the `xsavec` instruction, which requires a
relatively recent assembler to assemble correctly. Certainly any
assembler that can assemble `xsavec` can also assemble `%fs` and
`%gs` prefixes properly.

The reason to change this is that gcc/gas generate bad DWARF line
tables for this particular inline assembly. This causes crashes
when debugging wine under GDB and accidentally stepping into a
function that makes use of NtCurrentTeb. Arguably this is a GAS
bug and I have filed an appropriate issue [1], but we might as
well fix this in wine also to make debugging more reliable.

See also [2] where I originally reduced this from the GDB crash.

[1] https://sourceware.org/bugzilla/show_bug.cgi?id=28699
[2] https://github.com/rr-debugger/rr/issues/3009

Signed-off-by: Keno Fischer <keno@juliacomputing.com>
---

v2: Fix signoff

 include/winnt.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/winnt.h b/include/winnt.h
index 11111111111..11111111111 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -2267,7 +2267,7 @@ struct _TEB;
 static FORCEINLINE struct _TEB * WINAPI NtCurrentTeb(void)
 {
     struct _TEB *teb;
-    __asm__(".byte 0x64\n\tmovl (0x18),%0" : "=r" (teb));
+    __asm__("movl %%fs:0x18,%0" : "=r" (teb));
     return teb;
 }
 #elif defined(__i386__) && defined(_MSC_VER)
@@ -2282,7 +2282,7 @@ static FORCEINLINE struct _TEB * WINAPI NtCurrentTeb(void)
 static FORCEINLINE struct _TEB * WINAPI NtCurrentTeb(void)
 {
     struct _TEB *teb;
-    __asm__(".byte 0x65\n\tmovq (0x30),%0" : "=r" (teb));
+    __asm__("movq %%gs:0x30,%0" : "=r" (teb));
     return teb;
 }
 #elif defined(__x86_64__) && defined(_MSC_VER)

-- 
2.36.1

From: Keno Fischer <keno@juliacomputing.com>
Subject: [PATCH v2] ntdll/server: Make robust to spurious short writes
Message-Id: <20211216020935.GA1741897@juliacomputing.com>
Date: Wed, 15 Dec 2021 21:09:35 -0500

It is possible for the write/writev functions in send_request to
return short writes, even in non-error conditions. There are
several situations where this might happen. Examples are:
 - SIGSTOP/SIGCONT (either explicitly or via ptrace attach)
 - cgroup freezes and similar mechanisms
 - system suspends
 - External debuggers or profilers

In general, Linux makes very few guarantees about syscall restarts.
In some cases (in particular when no bytes have been transferred at all),
the linux kernel will automatically restart the system call, but once any
bytes have been transferred, the result will be a short write with
no automatic restart.

Make wine robust to this corner case by properly restarting a
short write with adjusted buffers.

Signed-off-by: Keno Fischer <keno@juliacomputing.com>
---

v2: Fix signoff, fix comment style, stop talking about SIGINT example
    in comments and commit message which, as Alexandre Julliard points
    out, is not applicable here.

 dlls/ntdll/unix/server.c | 41 +++++++++++++++++++++++++++++++++-------
 1 file changed, 34 insertions(+), 7 deletions(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -207,13 +207,25 @@ static DECLSPEC_NORETURN void server_protocol_perror( const char *err )
 static unsigned int send_request( const struct __server_request_info *req )
 {
     unsigned int i;
-    int ret;
+    int ret = 0;
 
+    int to_write = sizeof(req->u.req) + req->u.req.request_header.request_size;
     if (!req->u.req.request_header.request_size)
     {
-        if ((ret = write( ntdll_get_thread_data()->request_fd, &req->u.req,
-                          sizeof(req->u.req) )) == sizeof(req->u.req)) return STATUS_SUCCESS;
-
+        const char *write_ptr = (const char *)&req->u.req;
+        for (;;) {
+            ret = write( ntdll_get_thread_data()->request_fd, (void*)write_ptr,
+                         to_write );
+            if (ret == to_write) return STATUS_SUCCESS;
+            else if (ret < 0) break;
+            /* Short write. Most signals are blocked at this point, but it is
+               still possible to experience a syscall restart due to, e.g.
+               a SIGSTOP, cgroup freeze or external debug/profile tooling.
+               This is not an error. Simply adjust the remaining write length
+               and buffer and start again. */
+            to_write -= ret;
+            write_ptr += ret;
+        }
     }
     else
     {
@@ -226,11 +238,26 @@ static unsigned int send_request( const struct __server_request_info *req )
             vec[i+1].iov_base = (void *)req->data[i].ptr;
             vec[i+1].iov_len = req->data[i].size;
         }
-        if ((ret = writev( ntdll_get_thread_data()->request_fd, vec, i+1 )) ==
-            req->u.req.request_header.request_size + sizeof(req->u.req)) return STATUS_SUCCESS;
+
+        for (;;) {
+            ret = writev( ntdll_get_thread_data()->request_fd, vec, i+1 );
+            if (ret == to_write) return STATUS_SUCCESS;
+            else if (ret < 0) break;
+            /* Short write as above. Adjust buffer lengths and start again. */
+            to_write -= ret;
+            for (unsigned int j = 0; j < i+1; j++) {
+                if (ret >= vec[j].iov_len) {
+                    ret -= vec[j].iov_len;
+                    vec[j].iov_len = 0;
+                } else {
+                    vec[j].iov_base = (char *)vec[j].iov_base + ret;
+                    vec[j].iov_len -= ret;
+                    break;
+                }
+            }
+        }
     }
 
-    if (ret >= 0) server_protocol_error( "partial write %d\n", ret );
     if (errno == EPIPE) abort_thread(0);
     if (errno == EFAULT) return STATUS_ACCESS_VIOLATION;
     server_protocol_perror( "write" );

-- 
2.36.1

From: Haoyang Chen <chenhaoyang@uniontech.com>
#Subject: [PATCH] hidclass.sys: Fix a leak in hid_device_thread()
Message-Id: <c6af8e6f-a4cd-11a9-6afe-e175220354c3@uniontech.com>
Date: Wed, 9 Sep 2020 14:40:18 +0800

From daf4ffcceeb9b30c93b6808d3797c4d756d6251f Mon Sep 17 00:00:00 2001
From: Haoyang Chen <chenhaoyang@uniontech.com>
Date: Wed, 9 Sep 2020 14:35:58 +0800
Subject: [PATCH] hidclass.sys: Fix a leak in hid_device_thread().

Signed-off-by: Haoyang Chen <chenhaoyang@uniontech.com>
---
 dlls/hidclass.sys/device.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
index 11111111111..11111111111 100644
--- a/dlls/hidclass.sys/device.c
+++ b/dlls/hidclass.sys/device.c
@@ -364,6 +364,8 @@ static DWORD CALLBACK hid_device_thread(void *args)
         res = WaitForSingleObject(ext->u.pdo.halt_event, polled ? ext->u.pdo.poll_interval : 0);
     } while (res == WAIT_TIMEOUT);
 
+    HeapFree(GetProcessHeap(), 0, packet);
+
     TRACE( "device thread exiting, res %#lx\n", res );
     return 1;
 }
Subject: [PATCH] msi: Fix page fault when a patch does not contain a cabinet.

Taken from https://bugs.winehq.org/show_bug.cgi?id=50148

diff --git a/dlls/msi/files.c b/dlls/msi/files.c
index 11111111111..11111111111 100644
--- a/dlls/msi/files.c
+++ b/dlls/msi/files.c
@@ -827,7 +827,7 @@ UINT ACTION_PatchFiles( MSIPACKAGE *package )
             data.cb      = patchfiles_cb;
             data.user    = &cursor;
 
-            if (!msi_cabextract( package, mi, &data ))
+            if (mi->cabinet && !msi_cabextract( package, mi, &data ))
             {
                 ERR("Failed to extract cabinet: %s\n", debugstr_w(mi->cabinet));
                 rc = ERROR_INSTALL_FAILURE;
From: Myah Caron <qsniyg@protonmail.com>
Subject: [PATCH resend 1/3] ntdll: Use Vista's algorithm for RtlEncode/DecodePointer.
Message-Id: <t6E_KbjMO57JXjdT_S0DgMaDnoDBHGKG3Le0dXDYT9Jx5kb6maLOtD3xB3vIwzd4EUfXPipQs3pp_795_Kl-HHHTnrqdVbOzzZB20fuBMBQ=@protonmail.com>
Date: Thu, 11 Mar 2021 02:44:10 +0000

The algorithm is described here:
https://web.archive.org/web/20100603042315/http://blogs.msdn.com/b/michael_howard/archive/2006/08/16/702707.aspx

It still appears to be the same algorithm used in Windows 10.

Signed-off-by: Myah Caron <qsniyg@protonmail.com>
---
 dlls/ntdll/rtl.c | 34 ++++++++++++++++++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/rtl.c b/dlls/ntdll/rtl.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/rtl.c
+++ b/dlls/ntdll/rtl.c
@@ -1592,19 +1592,49 @@ static DWORD_PTR get_pointer_obfuscator( void )
     return pointer_obfuscator;
 }
 
+/***********************************************************************
+ * rotl_ptr (internal)
+ */
+#ifdef _WIN64
+#define ROT_BITS 64
+#else
+#define ROT_BITS 32
+#endif
+
+static DWORD_PTR rotl_ptr( DWORD_PTR num, int shift )
+{
+    shift &= ROT_BITS - 1;
+    return (num << shift) | (num >> (ROT_BITS-shift));
+}
+
+static DWORD_PTR rotr_ptr( DWORD_PTR num, int shift )
+{
+    shift &= ROT_BITS - 1;
+    return (num >> shift) | (num << (ROT_BITS-shift));
+}
+
+#undef ROT_BITS
+
 /*************************************************************************
  * RtlEncodePointer   [NTDLL.@]
  */
 PVOID WINAPI RtlEncodePointer( PVOID ptr )
 {
+
     DWORD_PTR ptrval = (DWORD_PTR) ptr;
-    return (PVOID)(ptrval ^ get_pointer_obfuscator());
+    DWORD_PTR cookie = get_pointer_obfuscator();
+
+    ptrval = (ptrval ^ cookie);
+    return (PVOID)rotr_ptr(ptrval, cookie);
 }
 
 PVOID WINAPI RtlDecodePointer( PVOID ptr )
 {
     DWORD_PTR ptrval = (DWORD_PTR) ptr;
-    return (PVOID)(ptrval ^ get_pointer_obfuscator());
+    DWORD_PTR cookie = get_pointer_obfuscator();
+
+    ptrval = rotl_ptr(ptrval, cookie);
+    return (PVOID)(ptrval ^ cookie);
 }
 
 /*************************************************************************
-- 
2.36.1

From: Myah Caron <qsniyg@protonmail.com>
Subject: [PATCH resend 2/3] ntdll: Implement ProcessCookie for NtQueryInformationProcess.
Message-Id: <kOZB-Qr3zAOzuV6t2aRc7ldQGANigaQuL58so2yBFj5AnoiD8ZeA85bXhsjGDyO1XeT00jJC68tA7a5kEkvEeBGuKandT7bwIdne1WbS-Mk=@protonmail.com>
Date: Thu, 11 Mar 2021 02:44:40 +0000

The entropy is based on
https://web.archive.org/web/20100603042315/http://blogs.msdn.com/b/michael_howard/archive/2006/08/16/702707.aspx

Signed-off-by: Myah Caron <qsniyg@protonmail.com>
---
I've opted not to include the rdtsc instruction for patch simplicity. It would require either intrinsics or inline assembly, and I'm not sure what's the right way to integrate this under wine.

Since the SystemCalls and PageFaults fields are not currently implemented under wine, the entropy currently isn't as good as it could be. I initially thought of (ab)using SystemInterruptInformation's getrandom usage, but I figured that would be even more of a hack. If this (or something else) would be preferred however, please let me know.

 dlls/ntdll/unix/process.c | 28 ++++++++++++++++++++++++++--
 1 file changed, 26 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -65,6 +65,7 @@
 #include "windef.h"
 #include "winternl.h"
 #include "winioctl.h"
+#include "ddk/wdm.h"
 #include "unix_private.h"
 #include "wine/condrv.h"
 #include "wine/server.h"
@@ -1056,6 +1057,30 @@ void fill_vm_counters( VM_COUNTERS_EX *pvmi, int unix_pid )
 
 #endif
 
+static ULONG get_process_cookie( void )
+{
+    static ULONG process_cookie;
+
+    if (!process_cookie)
+    {
+        SYSTEM_PERFORMANCE_INFORMATION spi;
+
+        ULONG cookie = user_shared_data->TickCount.High1Time;
+        cookie ^= user_shared_data->TickCount.LowPart;
+        cookie ^= user_shared_data->InterruptTime.LowPart;
+
+        NtQuerySystemInformation( SystemPerformanceInformation, &spi, sizeof( spi ), NULL );
+        cookie ^= spi.SystemCalls;
+        cookie ^= spi.PageFaults;
+
+        /* cookie ^= (ULONG)rdtsc */
+
+        InterlockedExchange( (LONG*)&process_cookie, cookie );
+    }
+
+    return process_cookie;
+}
+
 #define UNIMPLEMENTED_INFO_CLASS(c) \
     case c: \
         FIXME( "(process=%p) Unimplemented information class: " #c "\n", handle); \
@@ -1494,11 +1519,10 @@ NTSTATUS WINAPI NtQueryInformationProcess( HANDLE handle, PROCESSINFOCLASS class
         break;
 
     case ProcessCookie:
-        FIXME( "ProcessCookie (%p,%p,0x%08x,%p) stub\n", handle, info, size, ret_len );
         if (handle == NtCurrentProcess())
         {
             len = sizeof(ULONG);
-            if (size == len) *(ULONG *)info = 0;
+            if (size == len) *(ULONG *)info = get_process_cookie();
             else ret = STATUS_INFO_LENGTH_MISMATCH;
         }
         else ret = STATUS_INVALID_PARAMETER;

-- 
2.36.1

From: Myah Caron <qsniyg@protonmail.com>
Subject: [PATCH resend 3/3] ntdll: Use ProcessCookie in RtlEncode/DecodePointer.
Message-Id: <Y-LCRs9OnrXxeFO0BFMHAFAaxb7EfqhOmo-_aY-O6t3B6WtiNGLX-RLiczvv7CAVX2hgv1BhxM7As4OYkB52JSPv8Jr8nWzxq6itDyf-jDA=@protonmail.com>
Date: Thu, 11 Mar 2021 02:45:08 +0000

Signed-off-by: Myah Caron <qsniyg@protonmail.com>
---
 dlls/ntdll/rtl.c | 30 +++++++++++-------------------
 1 file changed, 11 insertions(+), 19 deletions(-)

diff --git a/dlls/ntdll/rtl.c b/dlls/ntdll/rtl.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/rtl.c
+++ b/dlls/ntdll/rtl.c
@@ -1566,30 +1566,22 @@ WCHAR * WINAPI RtlIpv6AddressToStringW(const IN6_ADDR *address, WCHAR *str)
 }
 
 /***********************************************************************
- * get_pointer_obfuscator (internal)
+ * get_process_cookie (internal)
  */
-static DWORD_PTR get_pointer_obfuscator( void )
+static ULONG get_process_cookie( void )
 {
-    static DWORD_PTR pointer_obfuscator;
+    static ULONG process_cookie;
 
-    if (!pointer_obfuscator)
+    if (!process_cookie)
     {
-        ULONG seed = NtGetTickCount();
-        ULONG_PTR rand;
+        ULONG cookie;
+        NtQueryInformationProcess( NtCurrentProcess(), ProcessCookie, &cookie,
+                                   sizeof( cookie ), NULL );
 
-        /* generate a random value for the obfuscator */
-        rand = RtlUniform( &seed );
-
-        /* handle 64bit pointers */
-        rand ^= (ULONG_PTR)RtlUniform( &seed ) << ((sizeof (DWORD_PTR) - sizeof (ULONG))*8);
-
-        /* set the high bits so dereferencing obfuscated pointers will (usually) crash */
-        rand |= (ULONG_PTR)0xc0000000 << ((sizeof (DWORD_PTR) - sizeof (ULONG))*8);
-
-        InterlockedCompareExchangePointer( (void**) &pointer_obfuscator, (void*) rand, NULL );
+        InterlockedExchange( (LONG*)&process_cookie, cookie );
     }
 
-    return pointer_obfuscator;
+    return process_cookie;
 }
 
 /***********************************************************************
@@ -1622,7 +1614,7 @@ PVOID WINAPI RtlEncodePointer( PVOID ptr )
 {
 
     DWORD_PTR ptrval = (DWORD_PTR) ptr;
-    DWORD_PTR cookie = get_pointer_obfuscator();
+    DWORD_PTR cookie = (DWORD_PTR) get_process_cookie();
 
     ptrval = (ptrval ^ cookie);
     return (PVOID)rotr_ptr(ptrval, cookie);
@@ -1631,7 +1623,7 @@ PVOID WINAPI RtlEncodePointer( PVOID ptr )
 PVOID WINAPI RtlDecodePointer( PVOID ptr )
 {
     DWORD_PTR ptrval = (DWORD_PTR) ptr;
-    DWORD_PTR cookie = get_pointer_obfuscator();
+    DWORD_PTR cookie = (DWORD_PTR) get_process_cookie();
 
     ptrval = rotl_ptr(ptrval, cookie);
     return (PVOID)(ptrval ^ cookie);
-- 
2.36.1


