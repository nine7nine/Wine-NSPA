--- a/dlls/ntdll/unix/fsync.c	2023-04-08 12:17:43.829222462 -0500
+++ b/dlls/ntdll/unix/fsync.c	2023-04-08 12:17:00.675898486 -0500
@@ -146,7 +146,7 @@ static void simulate_sched_quantum(void)
     /* futex wait is often very quick to resume a waiting thread when woken.
      * That reveals synchonization bugs in some games which happen to work on
      * Windows due to the waiting threads having some minimal delay to wake up. */
-    usleep(0);
+    NtYieldExecution();;
 }
 
 static inline int futex_wait_multiple( const struct futex_waitv *futexes,
@@ -743,7 +743,7 @@ NTSTATUS fsync_pulse_event( HANDLE handl
 
     /* Try to give other threads a chance to wake up. Hopefully erring on this
      * side is the better thing to do... */
-    usleep(0);
+    NtYieldExecution();;
 
     __atomic_store_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
 
--- a/dlls/ntdll/unix/sync.c	2023-04-08 12:17:29.817968054 -0500
+++ b/dlls/ntdll/unix/sync.c	2023-04-08 12:17:13.735746784 -0500
@@ -1743,7 +1743,7 @@ NTSTATUS WINAPI NtDelayExecution( BOOLEA
                 when.tv_nsec = (long)((ticks % TICKSPERSEC) * 100);
             }
 
-            usleep(0);
+            NtYieldExecution();;
             while ((err = clock_nanosleep( CLOCK_REALTIME, TIMER_ABSTIME, &when, NULL )) == EINTR);
             if (!err)
                 return STATUS_SUCCESS;
@@ -2814,7 +2814,7 @@ NTSTATUS WINAPI NtWaitForAlertByThreadId
         }
         
         if (alert_simulate_sched_quantum && waited)
-            usleep(0);
+            NtYieldExecution();;
         
         return STATUS_ALERTED;
     }

