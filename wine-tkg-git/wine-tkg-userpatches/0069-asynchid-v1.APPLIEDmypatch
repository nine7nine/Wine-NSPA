From aebabe1d135df3df2f82ad9654c562de0b47a0aa Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Nov 2021 14:44:42 +0100
Subject: [PATCH 1/7] hidclass.sys: Move HID_GET_COLLECTION_* handling inline.

---
 dlls/hidclass.sys/device.c | 54 +++++++++++++-------------------------
 1 file changed, 18 insertions(+), 36 deletions(-)

diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
index dd288a82b67..00789dfcd17 100644
--- a/dlls/hidclass.sys/device.c
+++ b/dlls/hidclass.sys/device.c
@@ -372,40 +372,6 @@ void HID_StartDeviceThread(DEVICE_OBJECT *device)
     ext->u.pdo.thread = CreateThread(NULL, 0, hid_device_thread, device, 0, NULL);
 }
 
-static void handle_IOCTL_HID_GET_COLLECTION_INFORMATION( IRP *irp, BASE_DEVICE_EXTENSION *ext )
-{
-    IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation( irp );
-    if (irpsp->Parameters.DeviceIoControl.OutputBufferLength <  sizeof(HID_COLLECTION_INFORMATION))
-    {
-        irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
-        irp->IoStatus.Information = 0;
-    }
-    else
-    {
-        memcpy(irp->AssociatedIrp.SystemBuffer, &ext->u.pdo.information, sizeof(HID_COLLECTION_INFORMATION));
-        irp->IoStatus.Information = sizeof(HID_COLLECTION_INFORMATION);
-        irp->IoStatus.Status = STATUS_SUCCESS;
-    }
-}
-
-static void handle_IOCTL_HID_GET_COLLECTION_DESCRIPTOR( IRP *irp, BASE_DEVICE_EXTENSION *ext )
-{
-    HIDP_COLLECTION_DESC *desc = ext->u.pdo.device_desc.CollectionDesc;
-    IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation( irp );
-
-    if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < desc->PreparsedDataLength)
-    {
-        irp->IoStatus.Status = STATUS_INVALID_BUFFER_SIZE;
-        irp->IoStatus.Information = 0;
-    }
-    else
-    {
-        memcpy( irp->UserBuffer, desc->PreparsedData, desc->PreparsedDataLength );
-        irp->IoStatus.Information = desc->PreparsedDataLength;
-        irp->IoStatus.Status = STATUS_SUCCESS;
-    }
-}
-
 struct device_strings
 {
     const WCHAR *id;
@@ -616,12 +582,28 @@ NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
         }
         case IOCTL_HID_GET_COLLECTION_INFORMATION:
         {
-            handle_IOCTL_HID_GET_COLLECTION_INFORMATION( irp, ext );
+            irp->IoStatus.Information = sizeof(HID_COLLECTION_INFORMATION);
+            if (irpsp->Parameters.DeviceIoControl.OutputBufferLength <  sizeof(HID_COLLECTION_INFORMATION))
+                irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
+            else
+            {
+                memcpy(irp->AssociatedIrp.SystemBuffer, &ext->u.pdo.information, sizeof(HID_COLLECTION_INFORMATION));
+                irp->IoStatus.Status = STATUS_SUCCESS;
+            }
             break;
         }
         case IOCTL_HID_GET_COLLECTION_DESCRIPTOR:
         {
-            handle_IOCTL_HID_GET_COLLECTION_DESCRIPTOR( irp, ext );
+            HIDP_COLLECTION_DESC *desc = ext->u.pdo.device_desc.CollectionDesc;
+
+            irp->IoStatus.Information = desc->PreparsedDataLength;
+            if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < desc->PreparsedDataLength)
+                irp->IoStatus.Status = STATUS_INVALID_BUFFER_SIZE;
+            else
+            {
+                memcpy( irp->UserBuffer, desc->PreparsedData, desc->PreparsedDataLength );
+                irp->IoStatus.Status = STATUS_SUCCESS;
+            }
             break;
         }
         case IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS:

From 8de9e72de30f608cd5f30821390e50666e776591 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Nov 2021 16:46:57 +0100
Subject: [PATCH 2/7] hidclass.sys: Move handle_minidriver_string inline.

---
 dlls/hidclass.sys/device.c | 62 +++++++++++++++++---------------------
 1 file changed, 27 insertions(+), 35 deletions(-)

diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
index 00789dfcd17..a99f1cfeb7e 100644
--- a/dlls/hidclass.sys/device.c
+++ b/dlls/hidclass.sys/device.c
@@ -400,11 +400,13 @@ static const struct device_strings device_strings[] =
     { .id = L"VID_054C&PID_0CE6", .product = L"Wireless Controller" },
 };
 
-static const WCHAR *find_product_string( const WCHAR *device_id )
+static const WCHAR *find_device_string( const WCHAR *device_id, ULONG index )
 {
     const WCHAR *match_id = wcsrchr( device_id, '\\' ) + 1;
     DWORD i;
 
+    if (index != HID_STRING_ID_IPRODUCT) return NULL;
+
     for (i = 0; i < ARRAY_SIZE(device_strings); ++i)
         if (!wcsnicmp( device_strings[i].id, match_id, 17 ))
             return device_strings[i].product;
@@ -412,30 +414,6 @@ static const WCHAR *find_product_string( const WCHAR *device_id )
     return NULL;
 }
 
-static void handle_minidriver_string( BASE_DEVICE_EXTENSION *ext, IRP *irp, ULONG index )
-{
-    IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation( irp );
-    WCHAR *output_buf = MmGetSystemAddressForMdlSafe( irp->MdlAddress, NormalPagePriority );
-    ULONG output_len = stack->Parameters.DeviceIoControl.OutputBufferLength;
-    const WCHAR *str = NULL;
-
-    if (index == HID_STRING_ID_IPRODUCT) str = find_product_string( ext->device_id );
-
-    if (!str) call_minidriver( IOCTL_HID_GET_STRING, ext->u.pdo.parent_fdo, ULongToPtr( index ),
-                               sizeof(index), output_buf, output_len, &irp->IoStatus );
-    else
-    {
-        irp->IoStatus.Information = (wcslen( str ) + 1) * sizeof(WCHAR);
-        if (irp->IoStatus.Information > output_len)
-            irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
-        else
-        {
-            memcpy( output_buf, str, irp->IoStatus.Information );
-            irp->IoStatus.Status = STATUS_SUCCESS;
-        }
-    }
-}
-
 static void hid_device_xfer_report( BASE_DEVICE_EXTENSION *ext, ULONG code, IRP *irp )
 {
     IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation( irp );
@@ -517,9 +495,10 @@ NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
     struct hid_queue *queue = irp->Tail.Overlay.OriginalFileObject->FsContext;
     IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation( irp );
     BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
+    ULONG code, index;
+    const WCHAR *str;
     NTSTATUS status;
     BOOL removed;
-    ULONG code;
     KIRQL irql;
 
     irp->IoStatus.Information = 0;
@@ -566,18 +545,31 @@ NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
             break;
         }
         case IOCTL_HID_GET_PRODUCT_STRING:
-        {
-            handle_minidriver_string( ext, irp, HID_STRING_ID_IPRODUCT );
-            break;
-        }
         case IOCTL_HID_GET_SERIALNUMBER_STRING:
-        {
-            handle_minidriver_string( ext, irp, HID_STRING_ID_ISERIALNUMBER );
-            break;
-        }
         case IOCTL_HID_GET_MANUFACTURER_STRING:
         {
-            handle_minidriver_string( ext, irp, HID_STRING_ID_IMANUFACTURER );
+            WCHAR *output_buf = MmGetSystemAddressForMdlSafe( irp->MdlAddress, NormalPagePriority );
+            ULONG output_len = irpsp->Parameters.DeviceIoControl.OutputBufferLength;
+
+            if (code == IOCTL_HID_GET_PRODUCT_STRING) index = HID_STRING_ID_IPRODUCT;
+            if (code == IOCTL_HID_GET_SERIALNUMBER_STRING) index = HID_STRING_ID_ISERIALNUMBER;
+            if (code == IOCTL_HID_GET_MANUFACTURER_STRING) index = HID_STRING_ID_IMANUFACTURER;
+
+            if ((str = find_device_string( ext->device_id, index )))
+            {
+                irp->IoStatus.Information = (wcslen( str ) + 1) * sizeof(WCHAR);
+                if (irp->IoStatus.Information > output_len)
+                    irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
+                else
+                {
+                    memcpy( output_buf, str, irp->IoStatus.Information );
+                    irp->IoStatus.Status = STATUS_SUCCESS;
+                }
+                break;
+            }
+
+            call_minidriver( IOCTL_HID_GET_STRING, ext->u.pdo.parent_fdo, ULongToPtr( index ),
+                             sizeof(index), output_buf, output_len, &irp->IoStatus );
             break;
         }
         case IOCTL_HID_GET_COLLECTION_INFORMATION:

From 4b8df4680a6c5a6505e802d1e6352a768a535e4a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Nov 2021 15:02:45 +0100
Subject: [PATCH 3/7] hidclass.sys: Use a local NTSTATUS variable to keep IRP
 status.

So we can handle pending asynchronous calls to minidriver more easily.
---
 dlls/hidclass.sys/device.c | 64 ++++++++++++++++++--------------------
 1 file changed, 31 insertions(+), 33 deletions(-)

diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
index a99f1cfeb7e..b3db33b85fc 100644
--- a/dlls/hidclass.sys/device.c
+++ b/dlls/hidclass.sys/device.c
@@ -495,9 +495,9 @@ NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
     struct hid_queue *queue = irp->Tail.Overlay.OriginalFileObject->FsContext;
     IO_STACK_LOCATION *irpsp = IoGetCurrentIrpStackLocation( irp );
     BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
+    NTSTATUS status = irp->IoStatus.Status;
     ULONG code, index;
     const WCHAR *str;
-    NTSTATUS status;
     BOOL removed;
     KIRQL irql;
 
@@ -519,29 +519,27 @@ NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
     switch ((code = irpsp->Parameters.DeviceIoControl.IoControlCode))
     {
         case IOCTL_HID_GET_POLL_FREQUENCY_MSEC:
-            TRACE("IOCTL_HID_GET_POLL_FREQUENCY_MSEC\n");
+            irp->IoStatus.Information = sizeof(ULONG);
             if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
+                status = STATUS_BUFFER_OVERFLOW;
+            else
             {
-                irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
-                irp->IoStatus.Information = 0;
-                break;
+                *(ULONG *)irp->AssociatedIrp.SystemBuffer = ext->u.pdo.poll_interval;
+                status = STATUS_SUCCESS;
             }
-            *(ULONG *)irp->AssociatedIrp.SystemBuffer = ext->u.pdo.poll_interval;
-            irp->IoStatus.Information = sizeof(ULONG);
-            irp->IoStatus.Status = STATUS_SUCCESS;
             break;
         case IOCTL_HID_SET_POLL_FREQUENCY_MSEC:
         {
             ULONG poll_interval;
-            TRACE("IOCTL_HID_SET_POLL_FREQUENCY_MSEC\n");
+            irp->IoStatus.Information = sizeof(ULONG);
             if (irpsp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG))
+                status = STATUS_BUFFER_TOO_SMALL;
+            else
             {
-                irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
-                break;
+                poll_interval = *(ULONG *)irp->AssociatedIrp.SystemBuffer;
+                if (poll_interval) ext->u.pdo.poll_interval = min(poll_interval, MAX_POLL_INTERVAL_MSEC);
+                status = STATUS_SUCCESS;
             }
-            poll_interval = *(ULONG *)irp->AssociatedIrp.SystemBuffer;
-            if (poll_interval) ext->u.pdo.poll_interval = min(poll_interval, MAX_POLL_INTERVAL_MSEC);
-            irp->IoStatus.Status = STATUS_SUCCESS;
             break;
         }
         case IOCTL_HID_GET_PRODUCT_STRING:
@@ -559,28 +557,29 @@ NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
             {
                 irp->IoStatus.Information = (wcslen( str ) + 1) * sizeof(WCHAR);
                 if (irp->IoStatus.Information > output_len)
-                    irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
+                    status = STATUS_BUFFER_TOO_SMALL;
                 else
                 {
                     memcpy( output_buf, str, irp->IoStatus.Information );
-                    irp->IoStatus.Status = STATUS_SUCCESS;
+                    status = STATUS_SUCCESS;
                 }
                 break;
             }
 
             call_minidriver( IOCTL_HID_GET_STRING, ext->u.pdo.parent_fdo, ULongToPtr( index ),
                              sizeof(index), output_buf, output_len, &irp->IoStatus );
+            status = irp->IoStatus.Status;
             break;
         }
         case IOCTL_HID_GET_COLLECTION_INFORMATION:
         {
             irp->IoStatus.Information = sizeof(HID_COLLECTION_INFORMATION);
             if (irpsp->Parameters.DeviceIoControl.OutputBufferLength <  sizeof(HID_COLLECTION_INFORMATION))
-                irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
+                status = STATUS_BUFFER_OVERFLOW;
             else
             {
                 memcpy(irp->AssociatedIrp.SystemBuffer, &ext->u.pdo.information, sizeof(HID_COLLECTION_INFORMATION));
-                irp->IoStatus.Status = STATUS_SUCCESS;
+                status = STATUS_SUCCESS;
             }
             break;
         }
@@ -590,36 +589,32 @@ NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
 
             irp->IoStatus.Information = desc->PreparsedDataLength;
             if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < desc->PreparsedDataLength)
-                irp->IoStatus.Status = STATUS_INVALID_BUFFER_SIZE;
+                status = STATUS_INVALID_BUFFER_SIZE;
             else
             {
                 memcpy( irp->UserBuffer, desc->PreparsedData, desc->PreparsedDataLength );
-                irp->IoStatus.Status = STATUS_SUCCESS;
+                status = STATUS_SUCCESS;
             }
             break;
         }
         case IOCTL_SET_NUM_DEVICE_INPUT_BUFFERS:
         {
-            irp->IoStatus.Information = 0;
-
+            irp->IoStatus.Information = sizeof(ULONG);
             if (irpsp->Parameters.DeviceIoControl.InputBufferLength != sizeof(ULONG))
-                irp->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
+                status = STATUS_BUFFER_OVERFLOW;
             else
-                irp->IoStatus.Status = hid_queue_resize( queue, *(ULONG *)irp->AssociatedIrp.SystemBuffer );
+                status = hid_queue_resize( queue, *(ULONG *)irp->AssociatedIrp.SystemBuffer );
             break;
         }
         case IOCTL_GET_NUM_DEVICE_INPUT_BUFFERS:
         {
+            irp->IoStatus.Information = sizeof(ULONG);
             if (irpsp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ULONG))
-            {
-                irp->IoStatus.Information = 0;
-                irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
-            }
+                status = STATUS_BUFFER_TOO_SMALL;
             else
             {
                 *(ULONG *)irp->AssociatedIrp.SystemBuffer = queue->length;
-                irp->IoStatus.Information = sizeof(ULONG);
-                irp->IoStatus.Status = STATUS_SUCCESS;
+                status = STATUS_SUCCESS;
             }
             break;
         }
@@ -634,13 +629,16 @@ NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
             ULONG code = irpsp->Parameters.DeviceIoControl.IoControlCode;
             FIXME("Unsupported ioctl %x (device=%x access=%x func=%x method=%x)\n",
                   code, code >> 16, (code >> 14) & 3, (code >> 2) & 0xfff, code & 3);
-            irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
+            status = STATUS_NOT_SUPPORTED;
             break;
         }
     }
 
-    status = irp->IoStatus.Status;
-    if (status != STATUS_PENDING) IoCompleteRequest( irp, IO_NO_INCREMENT );
+    if (status != STATUS_PENDING)
+    {
+        irp->IoStatus.Status = status;
+        IoCompleteRequest( irp, IO_NO_INCREMENT );
+    }
     return status;
 }
 

From edcd1bf11d6e9e09b029434b00c454ddae884051 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Nov 2021 18:36:37 +0100
Subject: [PATCH 4/7] hidclass.sys: Call internal minidriver report ioctls
 asynchronously.

Instead of calling it synchronously. Use a completion routine to wait
for their completion before returning.
---
 dlls/hidclass.sys/device.c | 93 +++++++++++++++++++++++++++++---------
 1 file changed, 71 insertions(+), 22 deletions(-)

diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
index b3db33b85fc..c0c9d0557f1 100644
--- a/dlls/hidclass.sys/device.c
+++ b/dlls/hidclass.sys/device.c
@@ -414,12 +414,40 @@ static const WCHAR *find_device_string( const WCHAR *device_id, ULONG index )
     return NULL;
 }
 
-static void hid_device_xfer_report( BASE_DEVICE_EXTENSION *ext, ULONG code, IRP *irp )
+struct completion_params
+{
+    HID_XFER_PACKET packet;
+    IO_STATUS_BLOCK io;
+    IRP *irp;
+};
+
+static NTSTATUS CALLBACK xfer_completion( DEVICE_OBJECT *device, IRP *irp, void *context )
+{
+    struct completion_params *params = context;
+    TRACE( "device %p, irp %p, context %p\n", device, irp, context );
+
+    params->irp->IoStatus = params->io;
+    IoCompleteRequest( params->irp, IO_NO_INCREMENT );
+
+    free( params );
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS CALLBACK write_completion( DEVICE_OBJECT *device, IRP *irp, void *context )
+{
+    struct completion_params *params = context;
+    TRACE( "device %p, irp %p, context %p\n", device, irp, context );
+    if (!params->io.Status && params->packet.reportId) params->io.Information--;
+    return xfer_completion( device, irp, context );
+}
+
+static NTSTATUS hid_device_xfer_report( BASE_DEVICE_EXTENSION *ext, ULONG code, IRP *irp )
 {
     IO_STACK_LOCATION *stack = IoGetCurrentIrpStackLocation( irp );
     ULONG offset = 0, report_len = 0, buffer_len = 0;
+    struct completion_params *params;
     HIDP_REPORT_IDS *report = NULL;
-    HID_XFER_PACKET packet;
+    HID_XFER_PACKET *packet;
     BYTE *buffer = NULL;
 
     switch (code)
@@ -440,10 +468,7 @@ static void hid_device_xfer_report( BASE_DEVICE_EXTENSION *ext, ULONG code, IRP
         break;
     }
     if (!buffer || !buffer_len)
-    {
-        irp->IoStatus.Status = STATUS_INVALID_USER_BUFFER;
-        return;
-    }
+        return STATUS_INVALID_USER_BUFFER;
 
     switch (code)
     {
@@ -464,30 +489,53 @@ static void hid_device_xfer_report( BASE_DEVICE_EXTENSION *ext, ULONG code, IRP
     }
 
     if (!report || buffer_len < report_len)
+        return STATUS_INVALID_PARAMETER;
+
+    if (!report->ReportID) offset = 1;
+
+    if (!(params = malloc(sizeof(HID_XFER_PACKET)))) return STATUS_NO_MEMORY;
+    params->packet.reportId = report->ReportID;
+    params->packet.reportBuffer = buffer + offset;
+    params->io = irp->IoStatus;
+    params->irp = irp;
+
+    if (!(irp = IoAllocateIrp( ext->u.pdo.parent_fdo->StackSize, FALSE )))
     {
-        irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
-        return;
+        free(params);
+        return STATUS_NO_MEMORY;
     }
+    irp->RequestorMode = KernelMode;
+    irp->UserBuffer = &params->packet;
+    irp->UserIosb = &params->io;
+    irp->Tail.Overlay.Thread = (PETHREAD)KeGetCurrentThread();
 
-    if (!report->ReportID) offset = 1;
-    packet.reportId = report->ReportID;
-    packet.reportBuffer = buffer + offset;
+    stack = IoGetNextIrpStackLocation( irp );
+    stack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
+    stack->Parameters.DeviceIoControl.IoControlCode = code;
+
+    IoSetCompletionRoutine( irp, code == IOCTL_HID_WRITE_REPORT ? write_completion : xfer_completion,
+                            params, TRUE, TRUE, TRUE );
 
     switch (code)
     {
     case IOCTL_HID_GET_FEATURE:
     case IOCTL_HID_GET_INPUT_REPORT:
-        packet.reportBufferLen = buffer_len - offset;
-        call_minidriver( code, ext->u.pdo.parent_fdo, NULL, 0, &packet, sizeof(packet), &irp->IoStatus );
+        params->packet.reportBufferLen = buffer_len - offset;
+        stack->Parameters.DeviceIoControl.InputBufferLength = 0;
+        stack->Parameters.DeviceIoControl.OutputBufferLength = sizeof(*packet);
         break;
     case IOCTL_HID_SET_FEATURE:
     case IOCTL_HID_SET_OUTPUT_REPORT:
     case IOCTL_HID_WRITE_REPORT:
-        packet.reportBufferLen = report_len - offset;
-        call_minidriver( code, ext->u.pdo.parent_fdo, NULL, sizeof(packet), &packet, 0, &irp->IoStatus );
-        if (code == IOCTL_HID_WRITE_REPORT && packet.reportId) irp->IoStatus.Information--;
+        params->packet.reportBufferLen = report_len - offset;
+        stack->Parameters.DeviceIoControl.InputBufferLength = sizeof(*packet);
+        stack->Parameters.DeviceIoControl.OutputBufferLength = 0;
         break;
     }
+
+    IoMarkIrpPending( params->irp );
+    IoCallDriver( ext->u.pdo.parent_fdo, irp );
+    return STATUS_PENDING;
 }
 
 NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
@@ -622,7 +670,7 @@ NTSTATUS WINAPI pdo_ioctl(DEVICE_OBJECT *device, IRP *irp)
         case IOCTL_HID_SET_FEATURE:
         case IOCTL_HID_GET_INPUT_REPORT:
         case IOCTL_HID_SET_OUTPUT_REPORT:
-            hid_device_xfer_report( ext, code, irp );
+            status = hid_device_xfer_report( ext, code, irp );
             break;
         default:
         {
@@ -689,12 +737,13 @@ NTSTATUS WINAPI pdo_read(DEVICE_OBJECT *device, IRP *irp)
 NTSTATUS WINAPI pdo_write(DEVICE_OBJECT *device, IRP *irp)
 {
     BASE_DEVICE_EXTENSION *ext = device->DeviceExtension;
-    NTSTATUS status;
-
-    hid_device_xfer_report( ext, IOCTL_HID_WRITE_REPORT, irp );
+    NTSTATUS status = hid_device_xfer_report( ext, IOCTL_HID_WRITE_REPORT, irp );
 
-    status = irp->IoStatus.Status;
-    IoCompleteRequest( irp, IO_NO_INCREMENT );
+    if (status != STATUS_PENDING)
+    {
+        irp->IoStatus.Status = status;
+        IoCompleteRequest( irp, IO_NO_INCREMENT );
+    }
     return status;
 }
 

From 1754f602c6c9741f1a264c312f64eda920397f56 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Nov 2021 19:50:40 +0100
Subject: [PATCH 5/7] winebus.sys: Use a local NTSTATUS variable to keep IRP
 status.

So we can handle pending asynchronous calls.
---
 dlls/winebus.sys/main.c | 38 +++++++++++++++++++++++---------------
 1 file changed, 23 insertions(+), 15 deletions(-)

diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index 111953c3bae..d8409763bd0 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -987,7 +987,7 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
 
             if (buffer_len < sizeof(*attr))
             {
-                irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
+                status = STATUS_BUFFER_TOO_SMALL;
                 break;
             }
 
@@ -997,15 +997,15 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
             attr->ProductID = ext->desc.pid;
             attr->VersionNumber = ext->desc.version;
 
-            irp->IoStatus.Status = STATUS_SUCCESS;
             irp->IoStatus.Information = sizeof(*attr);
+            status = STATUS_SUCCESS;
             break;
         }
         case IOCTL_HID_GET_DEVICE_DESCRIPTOR:
         {
             HID_DESCRIPTOR *descriptor = (HID_DESCRIPTOR *)irp->UserBuffer;
             irp->IoStatus.Information = sizeof(*descriptor);
-            if (buffer_len < sizeof(*descriptor)) irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
+            if (buffer_len < sizeof(*descriptor)) status = STATUS_BUFFER_TOO_SMALL;
             else
             {
                 memset(descriptor, 0, sizeof(*descriptor));
@@ -1016,18 +1016,18 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
                 descriptor->bNumDescriptors = 1;
                 descriptor->DescriptorList[0].bReportType = HID_REPORT_DESCRIPTOR_TYPE;
                 descriptor->DescriptorList[0].wReportLength = ext->report_desc_length;
-                irp->IoStatus.Status = STATUS_SUCCESS;
+                status = STATUS_SUCCESS;
             }
             break;
         }
         case IOCTL_HID_GET_REPORT_DESCRIPTOR:
             irp->IoStatus.Information = ext->report_desc_length;
             if (buffer_len < irp->IoStatus.Information)
-                irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
+                status = STATUS_BUFFER_TOO_SMALL;
             else
             {
                 memcpy(irp->UserBuffer, ext->report_desc, ext->report_desc_length);
-                irp->IoStatus.Status = STATUS_SUCCESS;
+                status = STATUS_SUCCESS;
             }
             break;
         case IOCTL_HID_GET_STRING:
@@ -1035,9 +1035,8 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
             DWORD index = (ULONG_PTR)irpsp->Parameters.DeviceIoControl.Type3InputBuffer;
             TRACE("IOCTL_HID_GET_STRING[%08x]\n", index);
 
-            irp->IoStatus.Status = hid_get_device_string(device, index, (WCHAR *)irp->UserBuffer, buffer_len);
-            if (irp->IoStatus.Status == STATUS_SUCCESS)
-                irp->IoStatus.Information = (wcslen((WCHAR *)irp->UserBuffer) + 1) * sizeof(WCHAR);
+            status = hid_get_device_string(device, index, (WCHAR *)irp->UserBuffer, buffer_len);
+            if (status == STATUS_SUCCESS) irp->IoStatus.Information = (wcslen((WCHAR *)irp->UserBuffer) + 1) * sizeof(WCHAR);
             break;
         }
         case IOCTL_HID_GET_INPUT_REPORT:
@@ -1047,7 +1046,7 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
             memcpy(packet->reportBuffer, last_report->buffer, last_report->length);
             packet->reportBufferLen = last_report->length;
             irp->IoStatus.Information = packet->reportBufferLen;
-            irp->IoStatus.Status = STATUS_SUCCESS;
+            status = STATUS_SUCCESS;
             if (TRACE_ON(hid))
             {
                 TRACE("read input report id %u length %u:\n", packet->reportId, packet->reportBufferLen);
@@ -1064,13 +1063,15 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
         }
         case IOCTL_HID_READ_REPORT:
         {
-            if (!deliver_next_report(ext, irp))
+            if (deliver_next_report(ext, irp))
+                status = STATUS_SUCCESS;
+            else
             {
                 /* hidclass.sys should guarantee this */
                 assert(!ext->pending_read);
                 ext->pending_read = irp;
                 IoMarkIrpPending(irp);
-                irp->IoStatus.Status = STATUS_PENDING;
+                status = STATUS_PENDING;
             }
             break;
         }
@@ -1091,13 +1092,15 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
                 }
             }
             unix_device_set_output_report(device, packet, &irp->IoStatus);
+            status = irp->IoStatus.Status;
             break;
         }
         case IOCTL_HID_GET_FEATURE:
         {
             HID_XFER_PACKET *packet = (HID_XFER_PACKET *)irp->UserBuffer;
             unix_device_get_feature_report(device, packet, &irp->IoStatus);
-            if (!irp->IoStatus.Status && TRACE_ON(hid))
+            status = irp->IoStatus.Status;
+            if (!status && TRACE_ON(hid))
             {
                 TRACE("read feature report id %u length %u:\n", packet->reportId, packet->reportBufferLen);
                 for (i = 0; i < packet->reportBufferLen;)
@@ -1127,18 +1130,23 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
                 }
             }
             unix_device_set_feature_report(device, packet, &irp->IoStatus);
+            status = irp->IoStatus.Status;
             break;
         }
         default:
             FIXME("Unsupported ioctl %x (device=%x access=%x func=%x method=%x)\n",
                   code, code >> 16, (code >> 14) & 3, (code >> 2) & 0xfff, code & 3);
+            status = STATUS_NOT_IMPLEMENTED;
             break;
     }
 
-    status = irp->IoStatus.Status;
     RtlLeaveCriticalSection(&ext->cs);
 
-    if (status != STATUS_PENDING) IoCompleteRequest(irp, IO_NO_INCREMENT);
+    if (status != STATUS_PENDING)
+    {
+        irp->IoStatus.Status = status;
+        IoCompleteRequest(irp, IO_NO_INCREMENT);
+    }
     return status;
 }
 

From 35df28b0bc62ec8ba05943c90dc6376ed248c29d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Nov 2021 11:47:27 +0100
Subject: [PATCH 6/7] winebus.sys: Write output reports asynchronously.

Some devices, for instance the DS4 controller over bluetooth, may take
some unusual amount of time when writing output reports, and more
specifically when calling SDL_JoystickRumble.

This handles output reports IRPs asynchronously, queueing them first
and then copying the packet and completing the IRP before actually
writing it out.
---
 dlls/winebus.sys/Makefile.in |   2 +-
 dlls/winebus.sys/main.c      | 216 +++++++++++++++++++++++++++++++----
 2 files changed, 193 insertions(+), 25 deletions(-)

diff --git a/dlls/winebus.sys/Makefile.in b/dlls/winebus.sys/Makefile.in
index d9ea33d267d..2bd1c54fa9c 100644
--- a/dlls/winebus.sys/Makefile.in
+++ b/dlls/winebus.sys/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = winebus.sys
 UNIXLIB   = winebus.so
-IMPORTS   = ntoskrnl hidparse
+IMPORTS   = ntoskrnl hidparse hal
 EXTRALIBS = $(IOKIT_LIBS) $(UDEV_LIBS) $(PTHREAD_LIBS) $(INOTIFY_LIBS)
 EXTRAINCL = $(UDEV_CFLAGS) $(SDL2_CFLAGS)
 
diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index d8409763bd0..140606e43e9 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -60,6 +60,88 @@ struct hid_report
     BYTE buffer[1];
 };
 
+struct irp_queue
+{
+    KSPIN_LOCK lock;
+    LIST_ENTRY list;
+};
+
+static void WINAPI irp_cancel_routine(DEVICE_OBJECT *device, IRP *irp)
+{
+    struct irp_queue *queue = irp->Tail.Overlay.DriverContext[0];
+    KIRQL irql;
+
+    IoReleaseCancelSpinLock(irp->CancelIrql);
+
+    KeAcquireSpinLock(&queue->lock, &irql);
+    RemoveEntryList(&irp->Tail.Overlay.ListEntry);
+    KeReleaseSpinLock(&queue->lock, irql);
+
+    irp->IoStatus.Information = 0;
+    irp->IoStatus.Status = STATUS_CANCELLED;
+    IoCompleteRequest(irp, IO_NO_INCREMENT);
+}
+
+static IRP *irp_queue_pop(struct irp_queue *queue)
+{
+    LIST_ENTRY *entry;
+    IRP *irp = NULL;
+    KIRQL irql;
+
+    KeAcquireSpinLock(&queue->lock, &irql);
+    while (!irp && (entry = RemoveHeadList(&queue->list)) != &queue->list)
+    {
+        irp = CONTAINING_RECORD(entry, IRP, Tail.Overlay.ListEntry);
+        if (!IoSetCancelRoutine(irp, NULL))
+        {
+            /* cancel routine is already cleared, meaning that it was called. let it handle completion. */
+            InitializeListHead(&irp->Tail.Overlay.ListEntry);
+            irp = NULL;
+        }
+    }
+    KeReleaseSpinLock(&queue->lock, irql);
+
+    return irp;
+}
+
+static NTSTATUS irp_queue_push(struct irp_queue *queue, IRP *irp)
+{
+    NTSTATUS status;
+    KIRQL irql;
+
+    KeAcquireSpinLock(&queue->lock, &irql);
+    IoSetCancelRoutine(irp, irp_cancel_routine);
+    if (irp->Cancel && !IoSetCancelRoutine(irp, NULL))
+        status = STATUS_CANCELLED;
+    else
+    {
+        irp->Tail.Overlay.DriverContext[0] = queue;
+        InsertTailList(&queue->list, &irp->Tail.Overlay.ListEntry);
+        IoMarkIrpPending(irp);
+        status = STATUS_PENDING;
+    }
+    KeReleaseSpinLock(&queue->lock, irql);
+
+    return status;
+}
+
+static void irp_queue_clear(struct irp_queue *queue)
+{
+    IRP *irp;
+
+    while ((irp = irp_queue_pop(queue)))
+    {
+        irp->IoStatus.Status = STATUS_DELETE_PENDING;
+        IoCompleteRequest(irp, IO_NO_INCREMENT);
+    }
+}
+
+static void irp_queue_init(struct irp_queue *queue)
+{
+    KeInitializeSpinLock(&queue->lock);
+    InitializeListHead(&queue->list);
+}
+
 enum device_state
 {
     DEVICE_STATE_STOPPED,
@@ -532,8 +614,8 @@ static void keyboard_device_create(void)
     IoInvalidateDeviceRelations(bus_pdo, BusRelations);
 }
 
-static DWORD bus_count;
-static HANDLE bus_thread[16];
+static DWORD thread_count;
+static HANDLE threads[16];
 
 struct bus_main_params
 {
@@ -600,12 +682,12 @@ static DWORD CALLBACK bus_main_thread(void *args)
 
 static NTSTATUS bus_main_thread_start(struct bus_main_params *bus)
 {
-    DWORD i = bus_count++, max_size;
+    DWORD i = thread_count++, max_size;
 
     if (!(bus->init_done = CreateEventW(NULL, FALSE, FALSE, NULL)))
     {
         ERR("failed to create %s bus init done event.\n", debugstr_w(bus->name));
-        bus_count--;
+        thread_count--;
         return STATUS_UNSUCCESSFUL;
     }
 
@@ -614,15 +696,15 @@ static NTSTATUS bus_main_thread_start(struct bus_main_params *bus)
     {
         ERR("failed to allocate %s bus event.\n", debugstr_w(bus->name));
         CloseHandle(bus->init_done);
-        bus_count--;
+        thread_count--;
         return STATUS_UNSUCCESSFUL;
     }
 
-    if (!(bus_thread[i] = CreateThread(NULL, 0, bus_main_thread, bus, 0, NULL)))
+    if (!(threads[i] = CreateThread(NULL, 0, bus_main_thread, bus, 0, NULL)))
     {
         ERR("failed to create %s bus thread.\n", debugstr_w(bus->name));
         CloseHandle(bus->init_done);
-        bus_count--;
+        thread_count--;
         return STATUS_UNSUCCESSFUL;
     }
 
@@ -631,6 +713,101 @@ static NTSTATUS bus_main_thread_start(struct bus_main_params *bus)
     return STATUS_SUCCESS;
 }
 
+static struct irp_queue write_queue;
+static HANDLE write_control[3];
+
+static DWORD CALLBACK write_thread(void *args)
+{
+    struct unix_device *unix_device;
+    HID_XFER_PACKET *packet, *tmp;
+    DEVICE_OBJECT *device;
+    IO_STATUS_BLOCK io;
+    DWORD i, size, res;
+    IRP *irp;
+
+    irp_queue_init(&write_queue);
+    SetEvent(write_control[2]);
+    TRACE("write thread started\n");
+
+    while ((res = WaitForMultipleObjects(2, write_control, FALSE, INFINITE)) == 1)
+    {
+        while ((irp = irp_queue_pop(&write_queue)))
+        {
+            unix_device = irp->Tail.Overlay.DriverContext[1];
+            packet = (HID_XFER_PACKET *)irp->UserBuffer;
+
+            size = sizeof(HID_XFER_PACKET) + packet->reportBufferLen;
+            tmp = RtlAllocateHeap(GetProcessHeap(), 0, size);
+            tmp->reportId = packet->reportId;
+            tmp->reportBuffer = (BYTE *)(tmp + 1);
+            tmp->reportBufferLen = packet->reportBufferLen;
+            memcpy(tmp->reportBuffer, packet->reportBuffer, packet->reportBufferLen);
+
+            io = irp->IoStatus;
+            RtlEnterCriticalSection(&device_list_cs);
+            if (!(device = bus_find_unix_device(unix_device)))
+            {
+                irp->IoStatus.Information = 0;
+                irp->IoStatus.Status = STATUS_DELETE_PENDING;
+            }
+            else
+            {
+                irp->IoStatus.Information = packet->reportBufferLen;
+                irp->IoStatus.Status = STATUS_SUCCESS;
+            }
+            RtlLeaveCriticalSection(&device_list_cs);
+            IoCompleteRequest(irp, IO_NO_INCREMENT);
+
+            if (TRACE_ON(hid))
+            {
+                TRACE("write output report id %u length %u:\n", tmp->reportId, tmp->reportBufferLen);
+                for (i = 0; i < tmp->reportBufferLen;)
+                {
+                    char buffer[256], *buf = buffer;
+                    buf += sprintf(buf, "%08x ", i);
+                    do { buf += sprintf(buf, " %02x", tmp->reportBuffer[i]); }
+                    while (++i % 16 && i < tmp->reportBufferLen);
+                    TRACE("%s\n", buffer);
+                }
+            }
+
+            if (device) unix_device_set_output_report(device, tmp, &io);
+
+            RtlFreeHeap(GetProcessHeap(), 0, tmp);
+        }
+    }
+
+    if (res) WARN("write wait returned status %#x\n", res);
+    else TRACE("write thread exited\n");
+
+    CloseHandle(write_control[0]);
+    CloseHandle(write_control[1]);
+    irp_queue_clear(&write_queue);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS write_thread_start(void)
+{
+    DWORD i = thread_count++;
+
+    if (!(write_control[0] = CreateEventW(NULL, FALSE, FALSE, NULL)) ||
+        !(write_control[1] = CreateEventW(NULL, FALSE, FALSE, NULL)) ||
+        !(write_control[2] = CreateEventW(NULL, FALSE, FALSE, NULL)) ||
+        !(threads[i] = CreateThread(NULL, 0, write_thread, NULL, 0, NULL)))
+    {
+        ERR("failed to create write thread.\n");
+        CloseHandle(write_control[0]);
+        CloseHandle(write_control[1]);
+        CloseHandle(write_control[2]);
+        thread_count--;
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    WaitForSingleObject(write_control[2], INFINITE);
+    CloseHandle(write_control[2]);
+    return STATUS_SUCCESS;
+}
+
 static void sdl_bus_free_mappings(struct sdl_bus_options *options)
 {
     DWORD count = options->mappings_count;
@@ -775,6 +952,7 @@ static NTSTATUS fdo_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
         irp->IoStatus.Status = handle_IRP_MN_QUERY_DEVICE_RELATIONS(irp);
         break;
     case IRP_MN_START_DEVICE:
+        write_thread_start();
         mouse_device_create();
         keyboard_device_create();
 
@@ -794,8 +972,9 @@ static NTSTATUS fdo_pnp_dispatch(DEVICE_OBJECT *device, IRP *irp)
         winebus_call(udev_stop, NULL);
         winebus_call(iohid_stop, NULL);
 
-        WaitForMultipleObjects(bus_count, bus_thread, TRUE, INFINITE);
-        while (bus_count--) CloseHandle(bus_thread[bus_count]);
+        SetEvent(write_control[0]);
+        WaitForMultipleObjects(thread_count, threads, TRUE, INFINITE);
+        while (thread_count--) CloseHandle(threads[thread_count]);
 
         irp->IoStatus.Status = STATUS_SUCCESS;
         IoSkipCurrentIrpStackLocation(irp);
@@ -968,6 +1147,7 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
         return IoCallDriver(bus_pdo, irp);
     }
 
+    irp->IoStatus.Information = 0;
     RtlEnterCriticalSection(&ext->cs);
 
     if (ext->state == DEVICE_STATE_REMOVED)
@@ -1078,21 +1258,9 @@ static NTSTATUS WINAPI hid_internal_dispatch(DEVICE_OBJECT *device, IRP *irp)
         case IOCTL_HID_SET_OUTPUT_REPORT:
         case IOCTL_HID_WRITE_REPORT:
         {
-            HID_XFER_PACKET *packet = (HID_XFER_PACKET *)irp->UserBuffer;
-            if (TRACE_ON(hid))
-            {
-                TRACE("write output report id %u length %u:\n", packet->reportId, packet->reportBufferLen);
-                for (i = 0; i < packet->reportBufferLen;)
-                {
-                    char buffer[256], *buf = buffer;
-                    buf += sprintf(buf, "%08x ", i);
-                    do { buf += sprintf(buf, " %02x", packet->reportBuffer[i]); }
-                    while (++i % 16 && i < packet->reportBufferLen);
-                    TRACE("%s\n", buffer);
-                }
-            }
-            unix_device_set_output_report(device, packet, &irp->IoStatus);
-            status = irp->IoStatus.Status;
+            irp->Tail.Overlay.DriverContext[1] = ext->unix_device;
+            status = irp_queue_push(&write_queue, irp);
+            if (status == STATUS_PENDING) SetEvent(write_control[1]);
             break;
         }
         case IOCTL_HID_GET_FEATURE:

From 79376c9184d1962fe632fab48dd13dd40cbb0b9d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 22 Nov 2021 12:10:11 +0100
Subject: [PATCH 7/7] xinput1_3: Write rumble and buzz reports asynchronously.

Some devices may block when writing output reports, and now that we can
write them in winebus.sys asynchronously, we need to also request async
operations on the user side.

This also waits for 1ms for the write to complete before cancelling the
previous writes, as we only track one pending write for each motor, to
leave a bit of time for the operation to take effect and not cancel
every write.
---
 dlls/xinput1_3/main.c | 67 +++++++++++++++++++++++++++++++------------
 1 file changed, 48 insertions(+), 19 deletions(-)

diff --git a/dlls/xinput1_3/main.c b/dlls/xinput1_3/main.c
index 506802d142a..6711419dd09 100644
--- a/dlls/xinput1_3/main.c
+++ b/dlls/xinput1_3/main.c
@@ -75,10 +75,15 @@ struct xinput_controller
 
         HANDLE read_event;
         OVERLAPPED read_ovl;
+        HANDLE rumble_event;
+        OVERLAPPED rumble_ovl;
+        HANDLE buzz_event;
+        OVERLAPPED buzz_ovl;
 
         char *input_report_buf;
-        char *output_report_buf;
         char *feature_report_buf;
+        char *rumble_report_buf;
+        char *buzz_report_buf;
 
         BYTE haptics_report;
         BYTE haptics_rumble_index;
@@ -280,8 +285,8 @@ static DWORD HID_set_state(struct xinput_controller *controller, XINPUT_VIBRATIO
 {
     ULONG report_len = controller->hid.caps.OutputReportByteLength;
     PHIDP_PREPARSED_DATA preparsed = controller->hid.preparsed;
-    char *report_buf = controller->hid.output_report_buf;
     BYTE report_id = controller->hid.haptics_report;
+    char *report_buf;
     NTSTATUS status;
 
     if (!(controller->caps.Flags & XINPUT_CAPS_FFB_SUPPORTED)) return ERROR_SUCCESS;
@@ -291,7 +296,19 @@ static DWORD HID_set_state(struct xinput_controller *controller, XINPUT_VIBRATIO
 
     if (!controller->enabled) return ERROR_SUCCESS;
 
+    if (WaitForSingleObject(controller->hid.rumble_ovl.hEvent, 1) == WAIT_TIMEOUT)
+    {
+        CancelIoEx(controller->device, &controller->hid.rumble_ovl);
+        WaitForSingleObject(controller->hid.rumble_ovl.hEvent, INFINITE);
+    }
+    if (WaitForSingleObject(controller->hid.buzz_ovl.hEvent, 1) == WAIT_TIMEOUT)
+    {
+        CancelIoEx(controller->device, &controller->hid.buzz_ovl);
+        WaitForSingleObject(controller->hid.buzz_ovl.hEvent, INFINITE);
+    }
+
     /* send haptics rumble report (left motor) */
+    report_buf = controller->hid.rumble_report_buf;
     status = HidP_InitializeReportForID(HidP_Output, report_id, preparsed, report_buf, report_len);
     if (status != HIDP_STATUS_SUCCESS) WARN("HidP_InitializeReportForID returned %#x\n", status);
     status = HidP_SetUsageValue(HidP_Output, HID_USAGE_PAGE_HAPTICS, 0, HID_USAGE_HAPTICS_INTENSITY,
@@ -300,13 +317,13 @@ static DWORD HID_set_state(struct xinput_controller *controller, XINPUT_VIBRATIO
     status = HidP_SetUsageValue(HidP_Output, HID_USAGE_PAGE_HAPTICS, 0, HID_USAGE_HAPTICS_MANUAL_TRIGGER,
                                 controller->hid.haptics_rumble_index, preparsed, report_buf, report_len);
     if (status != HIDP_STATUS_SUCCESS) WARN("HidP_SetUsageValue MANUAL_TRIGGER returned %#x\n", status);
-    if (!HidD_SetOutputReport(controller->device, report_buf, report_len))
-    {
-        WARN("HidD_SetOutputReport failed with error %u\n", GetLastError());
-        return GetLastError();
-    }
+
+    memset(&controller->hid.rumble_ovl, 0, sizeof(controller->hid.rumble_ovl));
+    controller->hid.rumble_ovl.hEvent = controller->hid.rumble_event;
+    WriteFile(controller->device, report_buf, report_len, NULL, &controller->hid.rumble_ovl);
 
     /* send haptics buzz report (right motor) */
+    report_buf = controller->hid.buzz_report_buf;
     status = HidP_InitializeReportForID(HidP_Output, report_id, preparsed, report_buf, report_len);
     if (status != HIDP_STATUS_SUCCESS) WARN("HidP_InitializeReportForID returned %#x\n", status);
     status = HidP_SetUsageValue(HidP_Output, HID_USAGE_PAGE_HAPTICS, 0, HID_USAGE_HAPTICS_INTENSITY,
@@ -315,11 +332,10 @@ static DWORD HID_set_state(struct xinput_controller *controller, XINPUT_VIBRATIO
     status = HidP_SetUsageValue(HidP_Output, HID_USAGE_PAGE_HAPTICS, 0, HID_USAGE_HAPTICS_MANUAL_TRIGGER,
                                 controller->hid.haptics_buzz_index, preparsed, report_buf, report_len);
     if (status != HIDP_STATUS_SUCCESS) WARN("HidP_SetUsageValue MANUAL_TRIGGER returned %#x\n", status);
-    if (!HidD_SetOutputReport(controller->device, report_buf, report_len))
-    {
-        WARN("HidD_SetOutputReport failed with error %u\n", GetLastError());
-        return GetLastError();
-    }
+
+    memset(&controller->hid.buzz_ovl, 0, sizeof(controller->hid.buzz_ovl));
+    controller->hid.buzz_ovl.hEvent = controller->hid.buzz_event;
+    WriteFile(controller->device, report_buf, report_len, NULL, &controller->hid.buzz_ovl);
 
     return ERROR_SUCCESS;
 }
@@ -354,25 +370,34 @@ static void controller_disable(struct xinput_controller *controller)
 
     CancelIoEx(controller->device, &controller->hid.read_ovl);
     WaitForSingleObject(controller->hid.read_ovl.hEvent, INFINITE);
+    CancelIoEx(controller->device, &controller->hid.rumble_ovl);
+    WaitForSingleObject(controller->hid.rumble_ovl.hEvent, INFINITE);
+    CancelIoEx(controller->device, &controller->hid.buzz_ovl);
+    WaitForSingleObject(controller->hid.buzz_ovl.hEvent, INFINITE);
     SetEvent(update_event);
 }
 
 static BOOL controller_init(struct xinput_controller *controller, PHIDP_PREPARSED_DATA preparsed,
                             HIDP_CAPS *caps, HANDLE device, WCHAR *device_path)
 {
-    HANDLE event = NULL;
+    HANDLE read_event = NULL, rumble_event = NULL, buzz_event = NULL;
 
     controller->hid.caps = *caps;
     if (!(controller->hid.feature_report_buf = calloc(1, controller->hid.caps.FeatureReportByteLength))) goto failed;
     if (!controller_check_caps(controller, device, preparsed)) goto failed;
-    if (!(event = CreateEventW(NULL, TRUE, FALSE, NULL))) goto failed;
+    if (!(read_event = CreateEventW(NULL, TRUE, FALSE, NULL))) goto failed;
+    if (!(rumble_event = CreateEventW(NULL, TRUE, FALSE, NULL))) goto failed;
+    if (!(buzz_event = CreateEventW(NULL, TRUE, FALSE, NULL))) goto failed;
 
     TRACE("Found gamepad %s\n", debugstr_w(device_path));
 
     controller->hid.preparsed = preparsed;
-    controller->hid.read_event = event;
+    controller->hid.read_event = read_event;
+    controller->hid.rumble_event = rumble_event;
+    controller->hid.buzz_event = buzz_event;
     if (!(controller->hid.input_report_buf = calloc(1, controller->hid.caps.InputReportByteLength))) goto failed;
-    if (!(controller->hid.output_report_buf = calloc(1, controller->hid.caps.OutputReportByteLength))) goto failed;
+    if (!(controller->hid.rumble_report_buf = calloc(1, controller->hid.caps.OutputReportByteLength))) goto failed;
+    if (!(controller->hid.buzz_report_buf = calloc(1, controller->hid.caps.OutputReportByteLength))) goto failed;
 
     memset(&controller->state, 0, sizeof(controller->state));
     memset(&controller->vibration, 0, sizeof(controller->vibration));
@@ -387,10 +412,13 @@ static BOOL controller_init(struct xinput_controller *controller, PHIDP_PREPARSE
 
 failed:
     free(controller->hid.input_report_buf);
-    free(controller->hid.output_report_buf);
     free(controller->hid.feature_report_buf);
+    free(controller->hid.rumble_report_buf);
+    free(controller->hid.buzz_report_buf);
     memset(&controller->hid, 0, sizeof(controller->hid));
-    CloseHandle(event);
+    CloseHandle(read_event);
+    CloseHandle(rumble_event);
+    CloseHandle(buzz_event);
     return FALSE;
 }
 
@@ -508,8 +536,9 @@ static void controller_destroy(struct xinput_controller *controller, BOOL alread
         controller->device = NULL;
 
         free(controller->hid.input_report_buf);
-        free(controller->hid.output_report_buf);
         free(controller->hid.feature_report_buf);
+        free(controller->hid.rumble_report_buf);
+        free(controller->hid.buzz_report_buf);
         HidD_FreePreparsedData(controller->hid.preparsed);
         memset(&controller->hid, 0, sizeof(controller->hid));
     }

