From: Piotr Caban <piotr@codeweavers.com>
Subject: [PATCH v2] server: Don't wait for low level hook result when queuing hardware message.
Message-Id: <daf382d3-924e-7c33-c876-5b8d6298c137@codeweavers.com>
Date: Tue, 21 Sep 2021 15:51:35 +0200


Without the change graphic drivers are blocking until low level hooks
are processed when injecting keyboard and mouse events. Causes 2-seconds 
(timeout) freeze in GtaV.

Signed-off-by: Piotr Caban <piotr@codeweavers.com>
---
v2:
  - don't specify sender in send_hook_ll_message to avoid queuing result

  server/queue.c | 16 +++++++++++++---
  1 file changed, 13 insertions(+), 3 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2132,7 +2132,12 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         /* specify a sender only when sending the last message */
         if (!(flags & ((1 << ARRAY_SIZE( messages )) - 1)))
         {
-            if (!(wait = send_hook_ll_message( desktop, msg, input, sender )))
+            if (origin == IMO_HARDWARE)
+            {
+                if (!send_hook_ll_message( desktop, msg, input, NULL ))
+                    queue_hardware_message( desktop, msg, 0 );
+            }
+            else if (!(wait = send_hook_ll_message( desktop, msg, input, sender )))
                 queue_hardware_message( desktop, msg, 0 );
         }
         else if (!send_hook_ll_message( desktop, msg, input, NULL ))
@@ -2153,7 +2158,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
     struct thread *foreground;
     unsigned char vkey = input->kbd.vkey;
     unsigned int message_code, time;
-    int wait;
+    int wait = 0;
 
     if (!(time = input->kbd.time)) time = get_tick_count();
 
@@ -2273,7 +2278,12 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         msg_data->flags |= (flags & (KF_EXTENDED | KF_ALTDOWN | KF_UP)) >> 8;
     }
 
-    if (!(wait = send_hook_ll_message( desktop, msg, input, sender )))
+    if (origin == IMO_HARDWARE)
+    {
+        if (!send_hook_ll_message( desktop, msg, input, NULL ))
+            queue_hardware_message( desktop, msg, 1 );
+    }
+    else if (!(wait = send_hook_ll_message( desktop, msg, input, sender )))
         queue_hardware_message( desktop, msg, 1 );
 
     return wait;
From: Keno Fischer <keno@juliacomputing.com>
Subject: [PATCH v2] ntdll: NtCurrentTeb: Remove unnecessary use of .byte
Message-Id: <20211216000953.GA1695242@juliacomputing.com>
Date: Wed, 15 Dec 2021 19:09:53 -0500

The definitions of `NtCurrentTeb` make use of an inline-assembly .byte
prefix to access the `fs` and `gs` prefixes. Given that the last-modify
date for this file is 23 and 13 years ago for i386 and x86_64
respectively, I assume the reason for this use of `.byte` is that the
assemblers of the time did not understand the %fs and %gs prefixes
in textual assembly. However, this is not the case anymore and modern
assemblers understand these just fine. Further, this doesn't reduce
the set of assembler versions capable of building wine either, since
wine elsewhere uses the `xsavec` instruction, which requires a
relatively recent assembler to assemble correctly. Certainly any
assembler that can assemble `xsavec` can also assemble `%fs` and
`%gs` prefixes properly.

The reason to change this is that gcc/gas generate bad DWARF line
tables for this particular inline assembly. This causes crashes
when debugging wine under GDB and accidentally stepping into a
function that makes use of NtCurrentTeb. Arguably this is a GAS
bug and I have filed an appropriate issue [1], but we might as
well fix this in wine also to make debugging more reliable.

See also [2] where I originally reduced this from the GDB crash.

[1] https://sourceware.org/bugzilla/show_bug.cgi?id=28699
[2] https://github.com/rr-debugger/rr/issues/3009

Signed-off-by: Keno Fischer <keno@juliacomputing.com>
---

v2: Fix signoff

 include/winnt.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/winnt.h b/include/winnt.h
index 11111111111..11111111111 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -2267,7 +2267,7 @@ struct _TEB;
 static FORCEINLINE struct _TEB * WINAPI NtCurrentTeb(void)
 {
     struct _TEB *teb;
-    __asm__(".byte 0x64\n\tmovl (0x18),%0" : "=r" (teb));
+    __asm__("movl %%fs:0x18,%0" : "=r" (teb));
     return teb;
 }
 #elif defined(__i386__) && defined(_MSC_VER)
@@ -2282,7 +2282,7 @@ static FORCEINLINE struct _TEB * WINAPI NtCurrentTeb(void)
 static FORCEINLINE struct _TEB * WINAPI NtCurrentTeb(void)
 {
     struct _TEB *teb;
-    __asm__(".byte 0x65\n\tmovq (0x30),%0" : "=r" (teb));
+    __asm__("movq %%gs:0x30,%0" : "=r" (teb));
     return teb;
 }
 #elif defined(__x86_64__) && defined(_MSC_VER)

-- 
2.36.1

From: Keno Fischer <keno@juliacomputing.com>
Subject: [PATCH v2] ntdll/server: Make robust to spurious short writes
Message-Id: <20211216020935.GA1741897@juliacomputing.com>
Date: Wed, 15 Dec 2021 21:09:35 -0500

It is possible for the write/writev functions in send_request to
return short writes, even in non-error conditions. There are
several situations where this might happen. Examples are:
 - SIGSTOP/SIGCONT (either explicitly or via ptrace attach)
 - cgroup freezes and similar mechanisms
 - system suspends
 - External debuggers or profilers

In general, Linux makes very few guarantees about syscall restarts.
In some cases (in particular when no bytes have been transferred at all),
the linux kernel will automatically restart the system call, but once any
bytes have been transferred, the result will be a short write with
no automatic restart.

Make wine robust to this corner case by properly restarting a
short write with adjusted buffers.

Signed-off-by: Keno Fischer <keno@juliacomputing.com>
---

v2: Fix signoff, fix comment style, stop talking about SIGINT example
    in comments and commit message which, as Alexandre Julliard points
    out, is not applicable here.

 dlls/ntdll/unix/server.c | 41 +++++++++++++++++++++++++++++++++-------
 1 file changed, 34 insertions(+), 7 deletions(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -207,13 +207,25 @@ static DECLSPEC_NORETURN void server_protocol_perror( const char *err )
 static unsigned int send_request( const struct __server_request_info *req )
 {
     unsigned int i;
-    int ret;
+    int ret = 0;
 
+    int to_write = sizeof(req->u.req) + req->u.req.request_header.request_size;
     if (!req->u.req.request_header.request_size)
     {
-        if ((ret = write( ntdll_get_thread_data()->request_fd, &req->u.req,
-                          sizeof(req->u.req) )) == sizeof(req->u.req)) return STATUS_SUCCESS;
-
+        const char *write_ptr = (const char *)&req->u.req;
+        for (;;) {
+            ret = write( ntdll_get_thread_data()->request_fd, (void*)write_ptr,
+                         to_write );
+            if (ret == to_write) return STATUS_SUCCESS;
+            else if (ret < 0) break;
+            /* Short write. Most signals are blocked at this point, but it is
+               still possible to experience a syscall restart due to, e.g.
+               a SIGSTOP, cgroup freeze or external debug/profile tooling.
+               This is not an error. Simply adjust the remaining write length
+               and buffer and start again. */
+            to_write -= ret;
+            write_ptr += ret;
+        }
     }
     else
     {
@@ -226,11 +238,26 @@ static unsigned int send_request( const struct __server_request_info *req )
             vec[i+1].iov_base = (void *)req->data[i].ptr;
             vec[i+1].iov_len = req->data[i].size;
         }
-        if ((ret = writev( ntdll_get_thread_data()->request_fd, vec, i+1 )) ==
-            req->u.req.request_header.request_size + sizeof(req->u.req)) return STATUS_SUCCESS;
+
+        for (;;) {
+            ret = writev( ntdll_get_thread_data()->request_fd, vec, i+1 );
+            if (ret == to_write) return STATUS_SUCCESS;
+            else if (ret < 0) break;
+            /* Short write as above. Adjust buffer lengths and start again. */
+            to_write -= ret;
+            for (unsigned int j = 0; j < i+1; j++) {
+                if (ret >= vec[j].iov_len) {
+                    ret -= vec[j].iov_len;
+                    vec[j].iov_len = 0;
+                } else {
+                    vec[j].iov_base = (char *)vec[j].iov_base + ret;
+                    vec[j].iov_len -= ret;
+                    break;
+                }
+            }
+        }
     }
 
-    if (ret >= 0) server_protocol_error( "partial write %d\n", ret );
     if (errno == EPIPE) abort_thread(0);
     if (errno == EFAULT) return STATUS_ACCESS_VIOLATION;
     server_protocol_perror( "write" );

-- 
2.36.1

From: Haoyang Chen <chenhaoyang@uniontech.com>
#Subject: [PATCH] hidclass.sys: Fix a leak in hid_device_thread()
Message-Id: <c6af8e6f-a4cd-11a9-6afe-e175220354c3@uniontech.com>
Date: Wed, 9 Sep 2020 14:40:18 +0800

From daf4ffcceeb9b30c93b6808d3797c4d756d6251f Mon Sep 17 00:00:00 2001
From: Haoyang Chen <chenhaoyang@uniontech.com>
Date: Wed, 9 Sep 2020 14:35:58 +0800
Subject: [PATCH] hidclass.sys: Fix a leak in hid_device_thread().

Signed-off-by: Haoyang Chen <chenhaoyang@uniontech.com>
---
 dlls/hidclass.sys/device.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/hidclass.sys/device.c b/dlls/hidclass.sys/device.c
index 11111111111..11111111111 100644
--- a/dlls/hidclass.sys/device.c
+++ b/dlls/hidclass.sys/device.c
@@ -364,6 +364,8 @@ static DWORD CALLBACK hid_device_thread(void *args)
         res = WaitForSingleObject(ext->u.pdo.halt_event, polled ? ext->u.pdo.poll_interval : 0);
     } while (res == WAIT_TIMEOUT);
 
+    HeapFree(GetProcessHeap(), 0, packet);
+
     TRACE( "device thread exiting, res %#lx\n", res );
     return 1;
 }
Subject: [PATCH] msi: Fix page fault when a patch does not contain a cabinet.

Taken from https://bugs.winehq.org/show_bug.cgi?id=50148

diff --git a/dlls/msi/files.c b/dlls/msi/files.c
index 11111111111..11111111111 100644
--- a/dlls/msi/files.c
+++ b/dlls/msi/files.c
@@ -827,7 +827,7 @@ UINT ACTION_PatchFiles( MSIPACKAGE *package )
             data.cb      = patchfiles_cb;
             data.user    = &cursor;
 
-            if (!msi_cabextract( package, mi, &data ))
+            if (mi->cabinet && !msi_cabextract( package, mi, &data ))
             {
                 ERR("Failed to extract cabinet: %s\n", debugstr_w(mi->cabinet));
                 rc = ERROR_INSTALL_FAILURE;
From: Myah Caron <qsniyg@protonmail.com>
Subject: [PATCH resend 1/3] ntdll: Use Vista's algorithm for RtlEncode/DecodePointer.
Message-Id: <t6E_KbjMO57JXjdT_S0DgMaDnoDBHGKG3Le0dXDYT9Jx5kb6maLOtD3xB3vIwzd4EUfXPipQs3pp_795_Kl-HHHTnrqdVbOzzZB20fuBMBQ=@protonmail.com>
Date: Thu, 11 Mar 2021 02:44:10 +0000

The algorithm is described here:
https://web.archive.org/web/20100603042315/http://blogs.msdn.com/b/michael_howard/archive/2006/08/16/702707.aspx

It still appears to be the same algorithm used in Windows 10.

Signed-off-by: Myah Caron <qsniyg@protonmail.com>
---
 dlls/ntdll/rtl.c | 34 ++++++++++++++++++++++++++++++++--
 1 file changed, 32 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/rtl.c b/dlls/ntdll/rtl.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/rtl.c
+++ b/dlls/ntdll/rtl.c
@@ -1592,19 +1592,49 @@ static DWORD_PTR get_pointer_obfuscator( void )
     return pointer_obfuscator;
 }
 
+/***********************************************************************
+ * rotl_ptr (internal)
+ */
+#ifdef _WIN64
+#define ROT_BITS 64
+#else
+#define ROT_BITS 32
+#endif
+
+static DWORD_PTR rotl_ptr( DWORD_PTR num, int shift )
+{
+    shift &= ROT_BITS - 1;
+    return (num << shift) | (num >> (ROT_BITS-shift));
+}
+
+static DWORD_PTR rotr_ptr( DWORD_PTR num, int shift )
+{
+    shift &= ROT_BITS - 1;
+    return (num >> shift) | (num << (ROT_BITS-shift));
+}
+
+#undef ROT_BITS
+
 /*************************************************************************
  * RtlEncodePointer   [NTDLL.@]
  */
 PVOID WINAPI RtlEncodePointer( PVOID ptr )
 {
+
     DWORD_PTR ptrval = (DWORD_PTR) ptr;
-    return (PVOID)(ptrval ^ get_pointer_obfuscator());
+    DWORD_PTR cookie = get_pointer_obfuscator();
+
+    ptrval = (ptrval ^ cookie);
+    return (PVOID)rotr_ptr(ptrval, cookie);
 }
 
 PVOID WINAPI RtlDecodePointer( PVOID ptr )
 {
     DWORD_PTR ptrval = (DWORD_PTR) ptr;
-    return (PVOID)(ptrval ^ get_pointer_obfuscator());
+    DWORD_PTR cookie = get_pointer_obfuscator();
+
+    ptrval = rotl_ptr(ptrval, cookie);
+    return (PVOID)(ptrval ^ cookie);
 }
 
 /*************************************************************************
-- 
2.36.1

From: Myah Caron <qsniyg@protonmail.com>
Subject: [PATCH resend 2/3] ntdll: Implement ProcessCookie for NtQueryInformationProcess.
Message-Id: <kOZB-Qr3zAOzuV6t2aRc7ldQGANigaQuL58so2yBFj5AnoiD8ZeA85bXhsjGDyO1XeT00jJC68tA7a5kEkvEeBGuKandT7bwIdne1WbS-Mk=@protonmail.com>
Date: Thu, 11 Mar 2021 02:44:40 +0000

The entropy is based on
https://web.archive.org/web/20100603042315/http://blogs.msdn.com/b/michael_howard/archive/2006/08/16/702707.aspx

Signed-off-by: Myah Caron <qsniyg@protonmail.com>
---
I've opted not to include the rdtsc instruction for patch simplicity. It would require either intrinsics or inline assembly, and I'm not sure what's the right way to integrate this under wine.

Since the SystemCalls and PageFaults fields are not currently implemented under wine, the entropy currently isn't as good as it could be. I initially thought of (ab)using SystemInterruptInformation's getrandom usage, but I figured that would be even more of a hack. If this (or something else) would be preferred however, please let me know.

 dlls/ntdll/unix/process.c | 28 ++++++++++++++++++++++++++--
 1 file changed, 26 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -65,6 +65,7 @@
 #include "windef.h"
 #include "winternl.h"
 #include "winioctl.h"
+#include "ddk/wdm.h"
 #include "unix_private.h"
 #include "wine/condrv.h"
 #include "wine/server.h"
@@ -1056,6 +1057,30 @@ void fill_vm_counters( VM_COUNTERS_EX *pvmi, int unix_pid )
 
 #endif
 
+static ULONG get_process_cookie( void )
+{
+    static ULONG process_cookie;
+
+    if (!process_cookie)
+    {
+        SYSTEM_PERFORMANCE_INFORMATION spi;
+
+        ULONG cookie = user_shared_data->TickCount.High1Time;
+        cookie ^= user_shared_data->TickCount.LowPart;
+        cookie ^= user_shared_data->InterruptTime.LowPart;
+
+        NtQuerySystemInformation( SystemPerformanceInformation, &spi, sizeof( spi ), NULL );
+        cookie ^= spi.SystemCalls;
+        cookie ^= spi.PageFaults;
+
+        /* cookie ^= (ULONG)rdtsc */
+
+        InterlockedExchange( (LONG*)&process_cookie, cookie );
+    }
+
+    return process_cookie;
+}
+
 #define UNIMPLEMENTED_INFO_CLASS(c) \
     case c: \
         FIXME( "(process=%p) Unimplemented information class: " #c "\n", handle); \
@@ -1494,11 +1519,10 @@ NTSTATUS WINAPI NtQueryInformationProcess( HANDLE handle, PROCESSINFOCLASS class
         break;
 
     case ProcessCookie:
-        FIXME( "ProcessCookie (%p,%p,0x%08x,%p) stub\n", handle, info, size, ret_len );
         if (handle == NtCurrentProcess())
         {
             len = sizeof(ULONG);
-            if (size == len) *(ULONG *)info = 0;
+            if (size == len) *(ULONG *)info = get_process_cookie();
             else ret = STATUS_INFO_LENGTH_MISMATCH;
         }
         else ret = STATUS_INVALID_PARAMETER;

-- 
2.36.1

From: Myah Caron <qsniyg@protonmail.com>
Subject: [PATCH resend 3/3] ntdll: Use ProcessCookie in RtlEncode/DecodePointer.
Message-Id: <Y-LCRs9OnrXxeFO0BFMHAFAaxb7EfqhOmo-_aY-O6t3B6WtiNGLX-RLiczvv7CAVX2hgv1BhxM7As4OYkB52JSPv8Jr8nWzxq6itDyf-jDA=@protonmail.com>
Date: Thu, 11 Mar 2021 02:45:08 +0000

Signed-off-by: Myah Caron <qsniyg@protonmail.com>
---
 dlls/ntdll/rtl.c | 30 +++++++++++-------------------
 1 file changed, 11 insertions(+), 19 deletions(-)

diff --git a/dlls/ntdll/rtl.c b/dlls/ntdll/rtl.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/rtl.c
+++ b/dlls/ntdll/rtl.c
@@ -1566,30 +1566,22 @@ WCHAR * WINAPI RtlIpv6AddressToStringW(const IN6_ADDR *address, WCHAR *str)
 }
 
 /***********************************************************************
- * get_pointer_obfuscator (internal)
+ * get_process_cookie (internal)
  */
-static DWORD_PTR get_pointer_obfuscator( void )
+static ULONG get_process_cookie( void )
 {
-    static DWORD_PTR pointer_obfuscator;
+    static ULONG process_cookie;
 
-    if (!pointer_obfuscator)
+    if (!process_cookie)
     {
-        ULONG seed = NtGetTickCount();
-        ULONG_PTR rand;
+        ULONG cookie;
+        NtQueryInformationProcess( NtCurrentProcess(), ProcessCookie, &cookie,
+                                   sizeof( cookie ), NULL );
 
-        /* generate a random value for the obfuscator */
-        rand = RtlUniform( &seed );
-
-        /* handle 64bit pointers */
-        rand ^= (ULONG_PTR)RtlUniform( &seed ) << ((sizeof (DWORD_PTR) - sizeof (ULONG))*8);
-
-        /* set the high bits so dereferencing obfuscated pointers will (usually) crash */
-        rand |= (ULONG_PTR)0xc0000000 << ((sizeof (DWORD_PTR) - sizeof (ULONG))*8);
-
-        InterlockedCompareExchangePointer( (void**) &pointer_obfuscator, (void*) rand, NULL );
+        InterlockedExchange( (LONG*)&process_cookie, cookie );
     }
 
-    return pointer_obfuscator;
+    return process_cookie;
 }
 
 /***********************************************************************
@@ -1622,7 +1614,7 @@ PVOID WINAPI RtlEncodePointer( PVOID ptr )
 {
 
     DWORD_PTR ptrval = (DWORD_PTR) ptr;
-    DWORD_PTR cookie = get_pointer_obfuscator();
+    DWORD_PTR cookie = (DWORD_PTR) get_process_cookie();
 
     ptrval = (ptrval ^ cookie);
     return (PVOID)rotr_ptr(ptrval, cookie);
@@ -1631,7 +1623,7 @@ PVOID WINAPI RtlEncodePointer( PVOID ptr )
 PVOID WINAPI RtlDecodePointer( PVOID ptr )
 {
     DWORD_PTR ptrval = (DWORD_PTR) ptr;
-    DWORD_PTR cookie = get_pointer_obfuscator();
+    DWORD_PTR cookie = (DWORD_PTR) get_process_cookie();
 
     ptrval = rotl_ptr(ptrval, cookie);
     return (PVOID)(ptrval ^ cookie);
-- 
2.36.1

From 01a971ca4a8f0ce544843703b50e8faed2a1c745 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 19 May 2022 11:30:40 +0200
Subject: [PATCH] combase: Use CRT memory allocation functions.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
(cherry picked from commit 9d1beee6c753f1ad864fb11d16598f09c3f0f510)
---
 dlls/combase/apartment.c       | 36 ++++++++---------
 dlls/combase/combase.c         | 35 ++++++++---------
 dlls/combase/combase_private.h |  1 -
 dlls/combase/errorinfo.c       | 40 ++++++-------------
 dlls/combase/hglobalstream.c   | 12 +++---
 dlls/combase/malloc.c          |  1 -
 dlls/combase/marshal.c         | 29 +++++++-------
 dlls/combase/roapi.c           | 10 ++---
 dlls/combase/rpc.c             | 71 +++++++++++++++++-----------------
 dlls/combase/string.c          |  4 +-
 dlls/combase/stubmanager.c     | 16 ++++----
 dlls/combase/usrmarshal.c      |  4 +-
 12 files changed, 118 insertions(+), 141 deletions(-)

diff --git a/dlls/combase/apartment.c b/dlls/combase/apartment.c
index c1b381879d3..b951486ee82 100644
--- a/dlls/combase/apartment.c
+++ b/dlls/combase/apartment.c
@@ -160,9 +160,9 @@ static HRESULT apartment_add_dll(const WCHAR *library_name, struct opendll **ret
     else
     {
         len = lstrlenW(library_name);
-        entry = heap_alloc(sizeof(*entry));
+        entry = malloc(sizeof(*entry));
         if (entry)
-            entry->library_name = heap_alloc((len + 1) * sizeof(WCHAR));
+            entry->library_name = malloc((len + 1) * sizeof(WCHAR));
         if (entry && entry->library_name)
         {
             memcpy(entry->library_name, library_name, (len + 1)*sizeof(WCHAR));
@@ -175,7 +175,7 @@ static HRESULT apartment_add_dll(const WCHAR *library_name, struct opendll **ret
         }
         else
         {
-            heap_free(entry);
+            free(entry);
             hr = E_OUTOFMEMORY;
             FreeLibrary(hLibrary);
         }
@@ -199,8 +199,8 @@ static void apartment_release_dll(struct opendll *entry, BOOL free_entry)
         TRACE("freeing %p\n", entry->library);
         FreeLibrary(entry->library);
 
-        heap_free(entry->library_name);
-        heap_free(entry);
+        free(entry->library_name);
+        free(entry);
     }
 }
 
@@ -212,8 +212,8 @@ static void apartment_release_dlls(void)
     LIST_FOR_EACH_ENTRY_SAFE(entry, cursor2, &dlls, struct opendll, entry)
     {
         list_remove(&entry->entry);
-        heap_free(entry->library_name);
-        heap_free(entry);
+        free(entry->library_name);
+        free(entry);
     }
     LeaveCriticalSection(&dlls_cs);
     DeleteCriticalSection(&dlls_cs);
@@ -279,7 +279,7 @@ static ULONG WINAPI local_server_Release(IServiceProvider *iface)
     if (!refcount)
     {
         assert(!local_server->apt);
-        heap_free(local_server);
+        free(local_server);
     }
 
     return refcount;
@@ -324,7 +324,7 @@ HRESULT apartment_get_local_server_stream(struct apartment *apt, IStream **ret)
     {
         struct local_server *obj;
 
-        obj = heap_alloc(sizeof(*obj));
+        obj = malloc(sizeof(*obj));
         if (obj)
         {
             obj->IServiceProvider_iface.lpVtbl = &local_server_vtbl;
@@ -343,7 +343,7 @@ HRESULT apartment_get_local_server_stream(struct apartment *apt, IStream **ret)
             if (SUCCEEDED(hr))
                 apt->local_server = obj;
             else
-                heap_free(obj);
+                free(obj);
         }
         else
             hr = E_OUTOFMEMORY;
@@ -367,7 +367,7 @@ static struct apartment *apartment_construct(DWORD model)
 
     TRACE("creating new apartment, model %ld\n", model);
 
-    apt = heap_alloc_zero(sizeof(*apt));
+    apt = calloc(1, sizeof(*apt));
     apt->tid = GetCurrentThreadId();
 
     list_init(&apt->proxies);
@@ -429,7 +429,7 @@ void apartment_freeunusedlibraries(struct apartment *apt, DWORD delay)
             {
                 list_remove(&entry->entry);
                 apartment_release_dll(entry->dll, TRUE);
-                heap_free(entry);
+                free(entry);
             }
             else
             {
@@ -531,13 +531,13 @@ void apartment_release(struct apartment *apt)
             struct apartment_loaded_dll *apartment_loaded_dll = LIST_ENTRY(cursor, struct apartment_loaded_dll, entry);
             apartment_release_dll(apartment_loaded_dll->dll, FALSE);
             list_remove(cursor);
-            heap_free(apartment_loaded_dll);
+            free(apartment_loaded_dll);
         }
 
         apt->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&apt->cs);
 
-        heap_free(apt);
+        free(apt);
     }
 }
 
@@ -796,7 +796,7 @@ static HRESULT apartment_getclassobject(struct apartment *apt, LPCWSTR dllpath,
 
     if (!found)
     {
-        apartment_loaded_dll = heap_alloc(sizeof(*apartment_loaded_dll));
+        apartment_loaded_dll = malloc(sizeof(*apartment_loaded_dll));
         if (!apartment_loaded_dll)
             hr = E_OUTOFMEMORY;
         if (SUCCEEDED(hr))
@@ -805,7 +805,7 @@ static HRESULT apartment_getclassobject(struct apartment *apt, LPCWSTR dllpath,
             apartment_loaded_dll->multi_threaded = FALSE;
             hr = apartment_add_dll(dllpath, &apartment_loaded_dll->dll);
             if (FAILED(hr))
-                heap_free(apartment_loaded_dll);
+                free(apartment_loaded_dll);
         }
         if (SUCCEEDED(hr))
         {
@@ -1175,7 +1175,7 @@ HRESULT apartment_increment_mta_usage(CO_MTA_USAGE_COOKIE *cookie)
 
     *cookie = NULL;
 
-    if (!(mta_cookie = heap_alloc(sizeof(*mta_cookie))))
+    if (!(mta_cookie = malloc(sizeof(*mta_cookie))))
         return E_OUTOFMEMORY;
 
     EnterCriticalSection(&apt_cs);
@@ -1208,7 +1208,7 @@ void apartment_decrement_mta_usage(CO_MTA_USAGE_COOKIE cookie)
             if (mta_cookie == cur)
             {
                 list_remove(&cur->entry);
-                heap_free(cur);
+                free(cur);
                 apartment_release(mta);
                 break;
             }
diff --git a/dlls/combase/combase.c b/dlls/combase/combase.c
index 3ffd08ab635..16c4514f8c9 100644
--- a/dlls/combase/combase.c
+++ b/dlls/combase/combase.c
@@ -32,7 +32,6 @@
 #include "combase_private.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ole);
 
@@ -392,7 +391,7 @@ BOOL WINAPI InternalIsProcessInitialized(void)
  */
 HRESULT WINAPI InternalTlsAllocData(struct tlsdata **data)
 {
-    if (!(*data = heap_alloc_zero(sizeof(**data))))
+    if (!(*data = calloc(1, sizeof(**data))))
         return E_OUTOFMEMORY;
 
     list_init(&(*data)->spies);
@@ -421,13 +420,13 @@ static void com_cleanup_tlsdata(void)
         list_remove(&cursor->entry);
         if (cursor->spy)
             IInitializeSpy_Release(cursor->spy);
-        heap_free(cursor);
+        free(cursor);
     }
 
     if (tlsdata->context_token)
         IObjContext_Release(tlsdata->context_token);
 
-    heap_free(tlsdata);
+    free(tlsdata);
     NtCurrentTeb()->ReservedForOle = NULL;
 }
 
@@ -478,7 +477,7 @@ static ULONG WINAPI global_options_Release(IGlobalOptions *iface)
     TRACE("%p, refcount %ld.\n", iface, refcount);
 
     if (!refcount)
-        heap_free(options);
+        free(options);
 
     return refcount;
 }
@@ -552,7 +551,7 @@ static HRESULT WINAPI global_options_CreateInstance(IClassFactory *iface, IUnkno
     if (outer)
         return E_INVALIDARG;
 
-    if (!(object = heap_alloc(sizeof(*object))))
+    if (!(object = malloc(sizeof(*object))))
         return E_OUTOFMEMORY;
     object->IGlobalOptions_iface.lpVtbl = &global_options_vtbl;
     object->refcount = 1;
@@ -1387,18 +1386,18 @@ static HRESULT clsid_from_string_reg(LPCOLESTR progid, CLSID *clsid)
     WCHAR *buf;
 
     memset(clsid, 0, sizeof(*clsid));
-    buf = heap_alloc((lstrlenW(progid) + 8) * sizeof(WCHAR));
+    buf = malloc((lstrlenW(progid) + 8) * sizeof(WCHAR));
     if (!buf) return E_OUTOFMEMORY;
 
     lstrcpyW(buf, progid);
     lstrcatW(buf, L"\\CLSID");
     if (open_classes_key(HKEY_CLASSES_ROOT, buf, MAXIMUM_ALLOWED, &xhkey))
     {
-        heap_free(buf);
+        free(buf);
         WARN("couldn't open key for ProgID %s\n", debugstr_w(progid));
         return CO_E_CLASSSTRING;
     }
-    heap_free(buf);
+    free(buf);
 
     if (RegQueryValueW(xhkey, NULL, buf2, &buf2len))
     {
@@ -1978,7 +1977,7 @@ HRESULT WINAPI CoRegisterInitializeSpy(IInitializeSpy *spy, ULARGE_INTEGER *cook
     if (FAILED(hr))
         return hr;
 
-    entry = heap_alloc(sizeof(*entry));
+    entry = malloc(sizeof(*entry));
     if (!entry)
     {
         IInitializeSpy_Release(spy);
@@ -2026,7 +2025,7 @@ HRESULT WINAPI CoRevokeInitializeSpy(ULARGE_INTEGER cookie)
     if (!tlsdata->spies_lock)
     {
         list_remove(&spy->entry);
-        heap_free(spy);
+        free(spy);
     }
     return S_OK;
 }
@@ -2239,7 +2238,7 @@ static void com_revoke_all_ps_clsids(void)
     LIST_FOR_EACH_ENTRY_SAFE(cur, cur2, &registered_proxystubs, struct registered_ps, entry)
     {
         list_remove(&cur->entry);
-        heap_free(cur);
+        free(cur);
     }
 
     LeaveCriticalSection(&cs_registered_ps);
@@ -2359,7 +2358,7 @@ HRESULT WINAPI CoRegisterPSClsid(REFIID riid, REFCLSID rclsid)
         }
     }
 
-    cur = heap_alloc(sizeof(*cur));
+    cur = malloc(sizeof(*cur));
     if (!cur)
     {
         LeaveCriticalSection(&cs_registered_ps);
@@ -2442,7 +2441,7 @@ static ULONG WINAPI thread_context_info_Release(IComThreadingInfo *iface)
        releasing context while refcount is at 0 destroys it. */
     if (!context->refcount)
     {
-        heap_free(context);
+        free(context);
         return 0;
     }
 
@@ -2667,7 +2666,7 @@ HRESULT WINAPI CoGetContextToken(ULONG_PTR *token)
     {
         struct thread_context *context;
 
-        context = heap_alloc_zero(sizeof(*context));
+        context = calloc(1, sizeof(*context));
         if (!context)
             return E_OUTOFMEMORY;
 
@@ -2762,7 +2761,7 @@ static void unlock_init_spies(struct tlsdata *tlsdata)
     {
         if (spy->spy) continue;
         list_remove(&spy->entry);
-        heap_free(spy);
+        free(spy);
     }
 }
 
@@ -2995,7 +2994,7 @@ HRESULT WINAPI CoRegisterClassObject(REFCLSID rclsid, IUnknown *object, DWORD cl
         return CO_E_OBJISREG;
     }
 
-    newclass = heap_alloc_zero(sizeof(*newclass));
+    newclass = calloc(1, sizeof(*newclass));
     if (!newclass)
     {
         apartment_release(apt);
@@ -3046,7 +3045,7 @@ static void com_revoke_class_object(struct registered_class *entry)
         rpc_revoke_local_server(entry->rpcss_cookie);
 
     IUnknown_Release(entry->object);
-    heap_free(entry);
+    free(entry);
 }
 
 /* Cleans up rpcss registry */
diff --git a/dlls/combase/combase_private.h b/dlls/combase/combase_private.h
index 9247af4ebb6..19e3def0b4e 100644
--- a/dlls/combase/combase_private.h
+++ b/dlls/combase/combase_private.h
@@ -17,7 +17,6 @@
 #include "winternl.h"
 #include "wine/orpc.h"
 
-#include "wine/heap.h"
 #include "wine/list.h"
 
 extern HINSTANCE hProxyDll;
diff --git a/dlls/combase/errorinfo.c b/dlls/combase/errorinfo.c
index 4ce9117d50d..779f5f5513c 100644
--- a/dlls/combase/errorinfo.c
+++ b/dlls/combase/errorinfo.c
@@ -25,27 +25,9 @@
 #include "combase_private.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ole);
 
-static WCHAR *heap_strdupW(const WCHAR *str)
-{
-    WCHAR *ret = NULL;
-
-    if (str)
-    {
-        size_t size;
-
-        size = (lstrlenW(str)+1)*sizeof(WCHAR);
-        ret = heap_alloc(size);
-        if (ret)
-            memcpy(ret, str, size);
-    }
-
-    return ret;
-}
-
 struct error_info
 {
     IErrorInfo IErrorInfo_iface;
@@ -125,10 +107,10 @@ static ULONG WINAPI errorinfo_Release(IErrorInfo *iface)
 
     if (!refcount)
     {
-        heap_free(error_info->source);
-        heap_free(error_info->description);
-        heap_free(error_info->help_file);
-        heap_free(error_info);
+        free(error_info->source);
+        free(error_info->description);
+        free(error_info->help_file);
+        free(error_info);
     }
 
     return refcount;
@@ -241,8 +223,8 @@ static HRESULT WINAPI create_errorinfo_SetSource(ICreateErrorInfo *iface, LPOLES
 
     TRACE("%p, %s.\n", iface, debugstr_w(source));
 
-    heap_free(error_info->source);
-    error_info->source = heap_strdupW(source);
+    free(error_info->source);
+    error_info->source = wcsdup(source);
 
     return S_OK;
 }
@@ -253,8 +235,8 @@ static HRESULT WINAPI create_errorinfo_SetDescription(ICreateErrorInfo *iface, L
 
     TRACE("%p, %s.\n", iface, debugstr_w(description));
 
-    heap_free(error_info->description);
-    error_info->description = heap_strdupW(description);
+    free(error_info->description);
+    error_info->description = wcsdup(description);
 
     return S_OK;
 }
@@ -265,8 +247,8 @@ static HRESULT WINAPI create_errorinfo_SetHelpFile(ICreateErrorInfo *iface, LPOL
 
     TRACE("%p, %s.\n", iface, debugstr_w(helpfile));
 
-    heap_free(error_info->help_file);
-    error_info->help_file = heap_strdupW(helpfile);
+    free(error_info->help_file);
+    error_info->help_file = wcsdup(helpfile);
 
     return S_OK;
 }
@@ -340,7 +322,7 @@ HRESULT WINAPI CreateErrorInfo(ICreateErrorInfo **ret)
 
     if (!ret) return E_INVALIDARG;
 
-    if (!(error_info = heap_alloc(sizeof(*error_info))))
+    if (!(error_info = malloc(sizeof(*error_info))))
         return E_OUTOFMEMORY;
 
     error_info->IErrorInfo_iface.lpVtbl = &errorinfo_vtbl;
diff --git a/dlls/combase/hglobalstream.c b/dlls/combase/hglobalstream.c
index 3dc770a47ac..04eeeab7779 100644
--- a/dlls/combase/hglobalstream.c
+++ b/dlls/combase/hglobalstream.c
@@ -48,7 +48,7 @@ static void handle_release(struct handle_wrapper *handle)
     if (!ref)
     {
         if (handle->delete_on_release) GlobalFree(handle->hglobal);
-        HeapFree(GetProcessHeap(), 0, handle);
+        free(handle);
     }
 }
 
@@ -56,14 +56,14 @@ static struct handle_wrapper *handle_create(HGLOBAL hglobal, BOOL delete_on_rele
 {
     struct handle_wrapper *handle;
 
-    handle = HeapAlloc(GetProcessHeap(), 0, sizeof(*handle));
+    handle = malloc(sizeof(*handle));
     if (!handle) return NULL;
 
     /* allocate a handle if one is not supplied */
     if (!hglobal) hglobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD | GMEM_SHARE, 0);
     if (!hglobal)
     {
-        HeapFree(GetProcessHeap(), 0, handle);
+        free(handle);
         return NULL;
     }
     handle->ref = 1;
@@ -92,7 +92,7 @@ static const IStreamVtbl hglobalstreamvtbl;
 
 static struct hglobal_stream *hglobalstream_construct(void)
 {
-    struct hglobal_stream *object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
+    struct hglobal_stream *object = calloc(1, sizeof(*object));
 
     if (object)
     {
@@ -134,7 +134,7 @@ static ULONG WINAPI stream_Release(IStream *iface)
     if (!ref)
     {
         handle_release(stream->handle);
-        HeapFree(GetProcessHeap(), 0, stream);
+        free(stream);
     }
 
     return ref;
@@ -422,7 +422,7 @@ HRESULT WINAPI CreateStreamOnHGlobal(HGLOBAL hGlobal, BOOL delete_on_release, IS
     object->handle = handle_create(hGlobal, delete_on_release);
     if (!object->handle)
     {
-        HeapFree(GetProcessHeap(), 0, object);
+        free(object);
         return E_OUTOFMEMORY;
     }
 
diff --git a/dlls/combase/malloc.c b/dlls/combase/malloc.c
index f31e1ef7705..5d5b61ca42e 100644
--- a/dlls/combase/malloc.c
+++ b/dlls/combase/malloc.c
@@ -21,7 +21,6 @@
 #include "oleauto.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(olemalloc);
 
diff --git a/dlls/combase/marshal.c b/dlls/combase/marshal.c
index b943c0dd6fa..a3da851b139 100644
--- a/dlls/combase/marshal.c
+++ b/dlls/combase/marshal.c
@@ -28,7 +28,6 @@
 #include "combase_private.h"
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ole);
 
@@ -219,7 +218,7 @@ static ULONG WINAPI ftmarshaler_inner_Release(IUnknown *iface)
     TRACE("%p, refcount %lu\n", iface, refcount);
 
     if (!refcount)
-        heap_free(marshaler);
+        free(marshaler);
 
     return refcount;
 }
@@ -421,7 +420,7 @@ HRESULT WINAPI CoCreateFreeThreadedMarshaler(IUnknown *outer, IUnknown **marshal
 
     TRACE("%p, %p\n", outer, marshaler);
 
-    object = heap_alloc(sizeof(*object));
+    object = malloc(sizeof(*object));
     if (!object)
         return E_OUTOFMEMORY;
 
@@ -1001,9 +1000,9 @@ static HRESULT WINAPI ClientIdentity_QueryMultipleInterfaces(IMultiQI *iface, UL
     ULONG nonlocal_mqis = 0;
     ULONG i;
     ULONG successful_mqis = 0;
-    IID *iids = HeapAlloc(GetProcessHeap(), 0, cMQIs * sizeof(*iids));
+    IID *iids = malloc(cMQIs * sizeof(*iids));
     /* mapping of RemQueryInterface index to QueryMultipleInterfaces index */
-    ULONG *mapping = HeapAlloc(GetProcessHeap(), 0, cMQIs * sizeof(*mapping));
+    ULONG *mapping = malloc(cMQIs * sizeof(*mapping));
 
     TRACE("cMQIs: %ld\n", cMQIs);
 
@@ -1084,8 +1083,8 @@ static HRESULT WINAPI ClientIdentity_QueryMultipleInterfaces(IMultiQI *iface, UL
 
     TRACE("%ld/%ld successfully queried\n", successful_mqis, cMQIs);
 
-    HeapFree(GetProcessHeap(), 0, iids);
-    HeapFree(GetProcessHeap(), 0, mapping);
+    free(iids);
+    free(mapping);
 
     if (successful_mqis == cMQIs)
         return S_OK; /* we got all requested interfaces */
@@ -1531,20 +1530,20 @@ static void ifproxy_destroy(struct ifproxy * This)
 
     if (This->proxy) IRpcProxyBuffer_Release(This->proxy);
 
-    HeapFree(GetProcessHeap(), 0, This);
+    free(This);
 }
 
 static HRESULT proxy_manager_construct(
     struct apartment * apt, ULONG sorflags, OXID oxid, OID oid,
     const OXID_INFO *oxid_info, struct proxy_manager ** proxy_manager)
 {
-    struct proxy_manager * This = HeapAlloc(GetProcessHeap(), 0, sizeof(*This));
+    struct proxy_manager * This = malloc(sizeof(*This));
     if (!This) return E_OUTOFMEMORY;
 
     This->remoting_mutex = CreateMutexW(NULL, FALSE, NULL);
     if (!This->remoting_mutex)
     {
-        HeapFree(GetProcessHeap(), 0, This);
+        free(This);
         return HRESULT_FROM_WIN32(GetLastError());
     }
 
@@ -1562,7 +1561,7 @@ static HRESULT proxy_manager_construct(
         if (FAILED(hr))
         {
             CloseHandle(This->remoting_mutex);
-            HeapFree(GetProcessHeap(), 0, This);
+            free(This);
             return hr;
         }
     }
@@ -1718,7 +1717,7 @@ static HRESULT proxy_manager_create_ifproxy(
 {
     HRESULT hr;
     IPSFactoryBuffer * psfb;
-    struct ifproxy * ifproxy = HeapAlloc(GetProcessHeap(), 0, sizeof(*ifproxy));
+    struct ifproxy * ifproxy = malloc(sizeof(*ifproxy));
     if (!ifproxy) return E_OUTOFMEMORY;
 
     list_init(&ifproxy->entry);
@@ -1931,7 +1930,7 @@ static void proxy_manager_destroy(struct proxy_manager * This)
 
     CloseHandle(This->remoting_mutex);
 
-    HeapFree(GetProcessHeap(), 0, This);
+    free(This);
 }
 
 /* finds the proxy manager corresponding to a given OXID and OID that has
@@ -2014,7 +2013,7 @@ static ULONG WINAPI StdMarshalImpl_Release(IMarshal *iface)
     ULONG refcount = InterlockedDecrement(&marshal->refcount);
 
     if (!refcount)
-        heap_free(marshal);
+        free(marshal);
 
     return refcount;
 }
@@ -2215,7 +2214,7 @@ static HRESULT StdMarshalImpl_Construct(REFIID riid, DWORD dest_context, void *d
     struct stdmarshal *object;
     HRESULT hr;
 
-    object = heap_alloc(sizeof(*object));
+    object = malloc(sizeof(*object));
     if (!object)
         return E_OUTOFMEMORY;
 
diff --git a/dlls/combase/roapi.c b/dlls/combase/roapi.c
index 46adf088247..eadf0ac2ecb 100644
--- a/dlls/combase/roapi.c
+++ b/dlls/combase/roapi.c
@@ -69,7 +69,7 @@ static HRESULT get_library_for_classid(const WCHAR *classid, WCHAR **out)
         hr = REGDB_E_READREGDB;
         goto done;
     }
-    if (!(buf = HeapAlloc(GetProcessHeap(), 0, size)))
+    if (!(buf = malloc(size)))
     {
         hr = E_OUTOFMEMORY;
         goto done;
@@ -83,13 +83,13 @@ static HRESULT get_library_for_classid(const WCHAR *classid, WCHAR **out)
     {
         WCHAR *expanded;
         DWORD len = ExpandEnvironmentStringsW(buf, NULL, 0);
-        if (!(expanded = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR))))
+        if (!(expanded = malloc(len * sizeof(WCHAR))))
         {
             hr = E_OUTOFMEMORY;
             goto done;
         }
         ExpandEnvironmentStringsW(buf, expanded, len);
-        HeapFree(GetProcessHeap(), 0, buf);
+        free(buf);
         buf = expanded;
     }
 
@@ -97,7 +97,7 @@ static HRESULT get_library_for_classid(const WCHAR *classid, WCHAR **out)
     return S_OK;
 
 done:
-    HeapFree(GetProcessHeap(), 0, buf);
+    free(buf);
     RegCloseKey(hkey_class);
     return hr;
 }
@@ -178,7 +178,7 @@ HRESULT WINAPI RoGetActivationFactory(HSTRING classid, REFIID iid, void **class_
     }
 
 done:
-    HeapFree(GetProcessHeap(), 0, library);
+    free(library);
     if (module) FreeLibrary(module);
     return hr;
 }
diff --git a/dlls/combase/rpc.c b/dlls/combase/rpc.c
index 0a86183030a..c97cfbd4eb8 100644
--- a/dlls/combase/rpc.c
+++ b/dlls/combase/rpc.c
@@ -29,7 +29,6 @@
 
 #include "wine/debug.h"
 #include "wine/exception.h"
-#include "wine/heap.h"
 
 #include "combase_private.h"
 
@@ -170,12 +169,12 @@ struct channel_hook_buffer_data
 };
 void * __RPC_USER MIDL_user_allocate(SIZE_T size)
 {
-    return heap_alloc(size);
+    return malloc(size);
 }
 
 void __RPC_USER MIDL_user_free(void *p)
 {
-    heap_free(p);
+    free(p);
 }
 
 static LONG WINAPI rpc_filter(EXCEPTION_POINTERS *eptr)
@@ -455,14 +454,14 @@ static HRESULT create_local_service(REFCLSID rclsid)
         r = RegQueryValueExW(hkey, L"ServiceParams", NULL, &type, NULL, &sz);
         if (r == ERROR_SUCCESS && type == REG_SZ && sz)
         {
-            args[0] = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sz);
+            args[0] = calloc(1, sz);
             num_args++;
             RegQueryValueExW(hkey, L"ServiceParams", NULL, &type, (LPBYTE)args[0], &sz);
         }
         r = start_local_service(buf, num_args, (LPCWSTR *)args);
         if (r != ERROR_SUCCESS)
             hr = REGDB_E_CLASSNOTREG; /* FIXME: check retval */
-        HeapFree(GetProcessHeap(),0,args[0]);
+        free(args[0]);
     }
     else
     {
@@ -607,7 +606,7 @@ HRESULT rpc_register_local_server(REFCLSID clsid, IStream *stream, DWORD flags,
     if (FAILED(hr)) return hr;
 
     size = GlobalSize(hmem);
-    if (!(obj = heap_alloc(FIELD_OFFSET(MInterfacePointer, abData[size]))))
+    if (!(obj = malloc(FIELD_OFFSET(MInterfacePointer, abData[size]))))
         return E_OUTOFMEMORY;
     obj->ulCntData = size;
     ptr = GlobalLock(hmem);
@@ -616,7 +615,7 @@ HRESULT rpc_register_local_server(REFCLSID clsid, IStream *stream, DWORD flags,
 
     hr = rpcss_server_register(clsid, flags, obj, cookie);
 
-    heap_free(obj);
+    free(obj);
 
     return hr;
 }
@@ -642,7 +641,7 @@ static ULONG ChannelHooks_ClientGetSize(SChannelHookCallInfo *info, struct chann
         (*hook_count)++;
 
     if (*hook_count)
-        *data = HeapAlloc(GetProcessHeap(), 0, *hook_count * sizeof(struct channel_hook_buffer_data));
+        *data = malloc(*hook_count * sizeof(struct channel_hook_buffer_data));
     else
         *data = NULL;
 
@@ -760,7 +759,7 @@ static ULONG ChannelHooks_ServerGetSize(SChannelHookCallInfo *info,
         (*hook_count)++;
 
     if (*hook_count)
-        *data = HeapAlloc(GetProcessHeap(), 0, *hook_count * sizeof(struct channel_hook_buffer_data));
+        *data = malloc(*hook_count * sizeof(struct channel_hook_buffer_data));
     else
         *data = NULL;
 
@@ -867,7 +866,7 @@ HRESULT rpc_register_channel_hook(REFGUID rguid, IChannelHook *hook)
 {
     struct channel_hook_entry *entry;
 
-    entry = HeapAlloc(GetProcessHeap(), 0, sizeof(*entry));
+    entry = malloc(sizeof(*entry));
     if (!entry)
         return E_OUTOFMEMORY;
 
@@ -889,7 +888,7 @@ void rpc_unregister_channel_hooks(void)
 
     EnterCriticalSection(&csChannelHook);
     LIST_FOR_EACH_ENTRY_SAFE(cursor, cursor2, &channel_hooks, struct channel_hook_entry, entry)
-        HeapFree(GetProcessHeap(), 0, cursor);
+        free(cursor);
     LeaveCriticalSection(&csChannelHook);
     DeleteCriticalSection(&csChannelHook);
     DeleteCriticalSection(&csRegIf);
@@ -924,7 +923,7 @@ static ULONG WINAPI ServerRpcChannelBuffer_Release(LPRPCCHANNELBUFFER iface)
     if (ref)
         return ref;
 
-    HeapFree(GetProcessHeap(), 0, This);
+    free(This);
     return 0;
 }
 
@@ -939,7 +938,7 @@ static ULONG WINAPI ClientRpcChannelBuffer_Release(LPRPCCHANNELBUFFER iface)
 
     if (This->event) CloseHandle(This->event);
     RpcBindingFree(&This->bind);
-    HeapFree(GetProcessHeap(), 0, This);
+    free(This);
     return 0;
 }
 
@@ -975,12 +974,12 @@ static HRESULT WINAPI ServerRpcChannelBuffer_GetBuffer(LPRPCCHANNELBUFFER iface,
 
     if (message_state->bypass_rpcrt)
     {
-        msg->Buffer = HeapAlloc(GetProcessHeap(), 0, msg->BufferLength);
+        msg->Buffer = malloc(msg->BufferLength);
         if (msg->Buffer)
             status = RPC_S_OK;
         else
         {
-            HeapFree(GetProcessHeap(), 0, channel_hook_data);
+            free(channel_hook_data);
             return E_OUTOFMEMORY;
         }
     }
@@ -1024,7 +1023,7 @@ static HRESULT WINAPI ServerRpcChannelBuffer_GetBuffer(LPRPCCHANNELBUFFER iface,
         }
     }
 
-    HeapFree(GetProcessHeap(), 0, channel_hook_data);
+    free(channel_hook_data);
 
     /* store the prefixed data length so that we can restore the real buffer
      * later */
@@ -1074,14 +1073,14 @@ static HRESULT WINAPI ClientRpcChannelBuffer_GetBuffer(LPRPCCHANNELBUFFER iface,
 
     TRACE("(%p)->(%p,%s)\n", This, olemsg, debugstr_guid(riid));
 
-    cif = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(RPC_CLIENT_INTERFACE));
+    cif = calloc(1, sizeof(RPC_CLIENT_INTERFACE));
     if (!cif)
         return E_OUTOFMEMORY;
 
-    message_state = HeapAlloc(GetProcessHeap(), 0, sizeof(*message_state));
+    message_state = malloc(sizeof(*message_state));
     if (!message_state)
     {
-        HeapFree(GetProcessHeap(), 0, cif);
+        free(cif);
         return E_OUTOFMEMORY;
     }
 
@@ -1154,7 +1153,7 @@ static HRESULT WINAPI ClientRpcChannelBuffer_GetBuffer(LPRPCCHANNELBUFFER iface,
     /* shortcut the RPC runtime */
     if (message_state->target_hwnd)
     {
-        msg->Buffer = HeapAlloc(GetProcessHeap(), 0, msg->BufferLength);
+        msg->Buffer = malloc(msg->BufferLength);
         if (msg->Buffer)
             status = RPC_S_OK;
         else
@@ -1214,7 +1213,7 @@ static HRESULT WINAPI ClientRpcChannelBuffer_GetBuffer(LPRPCCHANNELBUFFER iface,
         msg->BufferLength -= message_state->prefix_data_len;
     }
 
-    HeapFree(GetProcessHeap(), 0, channel_hook_data);
+    free(channel_hook_data);
 
     TRACE("-- %ld\n", status);
 
@@ -1430,7 +1429,7 @@ static HRESULT WINAPI ServerRpcChannelBuffer_FreeBuffer(LPRPCCHANNELBUFFER iface
 
     if (message_state->bypass_rpcrt)
     {
-        HeapFree(GetProcessHeap(), 0, msg->Buffer);
+        free(msg->Buffer);
         status = RPC_S_OK;
     }
     else
@@ -1459,20 +1458,20 @@ static HRESULT WINAPI ClientRpcChannelBuffer_FreeBuffer(LPRPCCHANNELBUFFER iface
 
     if (message_state->params.bypass_rpcrt)
     {
-        HeapFree(GetProcessHeap(), 0, msg->Buffer);
+        free(msg->Buffer);
         status = RPC_S_OK;
     }
     else
         status = I_RpcFreeBuffer(msg);
 
-    HeapFree(GetProcessHeap(), 0, msg->RpcInterfaceInformation);
+    free(msg->RpcInterfaceInformation);
     msg->RpcInterfaceInformation = NULL;
 
     if (message_state->params.stub)
         IRpcStubBuffer_Release(message_state->params.stub);
     if (message_state->params.chan)
         IRpcChannelBuffer_Release(message_state->params.chan);
-    HeapFree(GetProcessHeap(), 0, message_state);
+    free(message_state);
 
     TRACE("-- %ld\n", status);
 
@@ -1579,7 +1578,7 @@ HRESULT rpc_create_clientchannel(const OXID *oxid, const IPID *ipid,
         return HRESULT_FROM_WIN32(status);
     }
 
-    This = HeapAlloc(GetProcessHeap(), 0, sizeof(*This));
+    This = malloc(sizeof(*This));
     if (!This)
     {
         RpcBindingFree(&bind);
@@ -1603,7 +1602,7 @@ HRESULT rpc_create_clientchannel(const OXID *oxid, const IPID *ipid,
 
 HRESULT rpc_create_serverchannel(DWORD dest_context, void *dest_context_data, IRpcChannelBuffer **chan)
 {
-    RpcChannelBuffer *This = HeapAlloc(GetProcessHeap(), 0, sizeof(*This));
+    RpcChannelBuffer *This = malloc(sizeof(*This));
     if (!This)
         return E_OUTOFMEMORY;
 
@@ -1792,7 +1791,7 @@ void rpc_execute_call(struct dispatch_params *params)
         goto exit;
     }
 
-    message_state = HeapAlloc(GetProcessHeap(), 0, sizeof(*message_state));
+    message_state = malloc(sizeof(*message_state));
     if (!message_state)
     {
         params->hr = E_OUTOFMEMORY;
@@ -1876,7 +1875,7 @@ void rpc_execute_call(struct dispatch_params *params)
 
     /* the invoke allocated a new buffer, so free the old one */
     if (message_state->bypass_rpcrt && original_buffer != msg->Buffer)
-        HeapFree(GetProcessHeap(), 0, original_buffer);
+        free(original_buffer);
 
 exit_reset_state:
     message_state = msg->Handle;
@@ -1885,7 +1884,7 @@ void rpc_execute_call(struct dispatch_params *params)
     msg->BufferLength += message_state->prefix_data_len;
 
 exit:
-    HeapFree(GetProcessHeap(), 0, message_state);
+    free(message_state);
     if (params->handle) SetEvent(params->handle);
 }
 
@@ -1901,7 +1900,7 @@ static void __RPC_STUB dispatch_rpc(RPC_MESSAGE *msg)
 
     TRACE("ipid = %s, iMethod = %d\n", debugstr_guid(&ipid), msg->ProcNum);
 
-    params = HeapAlloc(GetProcessHeap(), 0, sizeof(*params));
+    params = malloc(sizeof(*params));
     if (!params)
     {
         RpcRaiseException(E_OUTOFMEMORY);
@@ -1913,7 +1912,7 @@ static void __RPC_STUB dispatch_rpc(RPC_MESSAGE *msg)
     if (hr != S_OK)
     {
         ERR("no apartment found for ipid %s\n", debugstr_guid(&ipid));
-        HeapFree(GetProcessHeap(), 0, params);
+        free(params);
         RpcRaiseException(hr);
         return;
     }
@@ -1967,7 +1966,7 @@ static void __RPC_STUB dispatch_rpc(RPC_MESSAGE *msg)
         IRpcChannelBuffer_Release(params->chan);
     if (params->stub)
         IRpcStubBuffer_Release(params->stub);
-    HeapFree(GetProcessHeap(), 0, params);
+    free(params);
 
     stub_manager_int_release(stub_manager);
     apartment_release(apt);
@@ -2000,7 +1999,7 @@ HRESULT rpc_register_interface(REFIID riid)
     {
         TRACE("Creating new interface\n");
 
-        rif = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*rif));
+        rif = calloc(1, sizeof(*rif));
         if (rif)
         {
             RPC_STATUS status;
@@ -2023,7 +2022,7 @@ HRESULT rpc_register_interface(REFIID riid)
             else
             {
                 ERR("RpcServerRegisterIfEx failed with error %ld\n", status);
-                HeapFree(GetProcessHeap(), 0, rif);
+                free(rif);
                 hr = HRESULT_FROM_WIN32(status);
             }
         }
@@ -2047,7 +2046,7 @@ void rpc_unregister_interface(REFIID riid, BOOL wait)
             {
                 RpcServerUnregisterIf((RPC_IF_HANDLE)&rif->If, NULL, wait);
                 list_remove(&rif->entry);
-                HeapFree(GetProcessHeap(), 0, rif);
+                free(rif);
             }
             break;
         }
diff --git a/dlls/combase/string.c b/dlls/combase/string.c
index 59e39f59956..1345870cf2f 100644
--- a/dlls/combase/string.c
+++ b/dlls/combase/string.c
@@ -66,7 +66,7 @@ static inline struct hstring_private *impl_from_HSTRING_BUFFER(HSTRING_BUFFER bu
 static BOOL alloc_string(UINT32 len, HSTRING *out)
 {
     struct hstring_private *priv;
-    priv = HeapAlloc(GetProcessHeap(), 0, offsetof(struct hstring_private, buffer[len+1]));
+    priv = malloc(offsetof(struct hstring_private, buffer[len+1]));
     if (!priv)
         return FALSE;
 
@@ -151,7 +151,7 @@ HRESULT WINAPI WindowsDeleteString(HSTRING str)
     if (priv->header.flags & HSTRING_REFERENCE_FLAG)
         return S_OK;
     if (InterlockedDecrement(&priv->refcount) == 0)
-        HeapFree(GetProcessHeap(), 0, priv);
+        free(priv);
     return S_OK;
 }
 
diff --git a/dlls/combase/stubmanager.c b/dlls/combase/stubmanager.c
index 931d32f7f2e..59782b8c623 100644
--- a/dlls/combase/stubmanager.c
+++ b/dlls/combase/stubmanager.c
@@ -77,13 +77,13 @@ struct ifstub * stub_manager_new_ifstub(struct stub_manager *m, IRpcStubBuffer *
     TRACE("oid=%s, stubbuffer=%p, iid=%s, dest_context=%lx\n", wine_dbgstr_longlong(m->oid), sb,
           debugstr_guid(iid), dest_context);
 
-    stub = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct ifstub));
+    stub = calloc(1, sizeof(struct ifstub));
     if (!stub) return NULL;
 
     hr = IUnknown_QueryInterface(m->object, iid, (void **)&stub->iface);
     if (hr != S_OK)
     {
-        HeapFree(GetProcessHeap(), 0, stub);
+        free(stub);
         return NULL;
     }
 
@@ -91,7 +91,7 @@ struct ifstub * stub_manager_new_ifstub(struct stub_manager *m, IRpcStubBuffer *
     if (hr != S_OK)
     {
         IUnknown_Release(stub->iface);
-        HeapFree(GetProcessHeap(), 0, stub);
+        free(stub);
         return NULL;
     }
 
@@ -132,7 +132,7 @@ static void stub_manager_delete_ifstub(struct stub_manager *m, struct ifstub *if
     IUnknown_Release(ifstub->iface);
     IRpcChannelBuffer_Release(ifstub->chan);
 
-    HeapFree(GetProcessHeap(), 0, ifstub);
+    free(ifstub);
 }
 
 static struct ifstub *stub_manager_ipid_to_ifstub(struct stub_manager *m, const IPID *ipid)
@@ -182,7 +182,7 @@ static struct stub_manager *new_stub_manager(struct apartment *apt, IUnknown *ob
 
     assert(apt);
 
-    sm = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct stub_manager));
+    sm = calloc(1, sizeof(struct stub_manager));
     if (!sm) return NULL;
 
     list_init(&sm->ifstubs);
@@ -288,7 +288,7 @@ static void stub_manager_delete(struct stub_manager *m)
     m->lock.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&m->lock);
 
-    HeapFree(GetProcessHeap(), 0, m);
+    free(m);
 }
 
 /* increments the internal refcount */
@@ -634,7 +634,7 @@ static inline RemUnknown *impl_from_IRemUnknown(IRemUnknown *iface)
 /* construct an IRemUnknown object with one outstanding reference */
 static HRESULT RemUnknown_Construct(IRemUnknown **ppRemUnknown)
 {
-    RemUnknown *object = HeapAlloc(GetProcessHeap(), 0, sizeof(*object));
+    RemUnknown *object = malloc(sizeof(*object));
 
     if (!object)
         return E_OUTOFMEMORY;
@@ -683,7 +683,7 @@ static ULONG WINAPI RemUnknown_Release(IRemUnknown *iface)
 
     refs = InterlockedDecrement(&remunk->refs);
     if (!refs)
-        HeapFree(GetProcessHeap(), 0, remunk);
+        free(remunk);
 
     TRACE("%p after: %ld\n", iface, refs);
     return refs;
diff --git a/dlls/combase/usrmarshal.c b/dlls/combase/usrmarshal.c
index d12ea7f759c..52891cbf563 100644
--- a/dlls/combase/usrmarshal.c
+++ b/dlls/combase/usrmarshal.c
@@ -494,7 +494,7 @@ unsigned char * __RPC_USER HBITMAP_UserUnmarshal(ULONG *flags, unsigned char *bu
 
             bitmap_size = *(ULONG *)buffer;
             buffer += sizeof(ULONG);
-            bits = HeapAlloc(GetProcessHeap(), 0, bitmap_size);
+            bits = malloc(bitmap_size);
 
             memcpy(&bitmap, buffer, header_size);
             buffer += header_size;
@@ -505,7 +505,7 @@ unsigned char * __RPC_USER HBITMAP_UserUnmarshal(ULONG *flags, unsigned char *bu
             bitmap.bmBits = bits;
             *bmp = CreateBitmapIndirect(&bitmap);
 
-            HeapFree(GetProcessHeap(), 0, bits);
+            free(bits);
         }
         else
             *bmp = NULL;
From 298fcc110a2a7294a10b6e0683f9305fca95740d Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 1 Feb 2022 22:39:42 +0300
Subject: [PATCH] ntdll: Use .seh handler instead of __TRY in
 RtlUserThreadStart() on x64.

CW-Bug-Id: #19913
---
 dlls/ntdll/thread.c | 36 +++++++++++++++++++++++++++++++++++-
 include/wine/asm.h  |  1 +
 2 files changed, 36 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index 5fc956b1dc4..4cec391cf8b 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -240,7 +240,41 @@ void DECLSPEC_HIDDEN call_thread_func( PRTL_THREAD_START_ROUTINE entry, void *ar
     __ENDTRY
 }
 
-#else  /* __i386__ */
+#elif /* __i386__ */ defined(__x86_64__) && defined(__ASM_SEH_SUPPORTED)
+EXCEPTION_DISPOSITION WINAPI call_thread_func_handler( EXCEPTION_RECORD *rec, ULONG64 frame,
+                                                       CONTEXT *context, DISPATCHER_CONTEXT *dispatch )
+{
+    EXCEPTION_POINTERS ep = { rec, context };
+
+    WARN( "Unhandled exception, calling filter.\n" );
+
+    switch (call_unhandled_exception_filter( &ep ))
+    {
+        case EXCEPTION_CONTINUE_SEARCH:
+            return ExceptionContinueSearch;
+        case EXCEPTION_CONTINUE_EXECUTION:
+            return ExceptionContinueExecution;
+        case EXCEPTION_EXECUTE_HANDLER:
+            break;
+    }
+    NtTerminateProcess( GetCurrentProcess(), rec->ExceptionCode );
+    return ExceptionContinueExecution;
+}
+
+extern void WINAPI RtlUserThreadStart( PRTL_THREAD_START_ROUTINE entry, void *arg );
+__ASM_GLOBAL_FUNC( RtlUserThreadStart,
+                  "subq $0x28, %rsp\n\t"
+                  __ASM_SEH(".seh_stackalloc 0x28\n\t")
+                  __ASM_SEH(".seh_endprologue\n\t")
+                  "movq %rdx,%r8\n\t"
+                  "movq %rcx,%rdx\n\t"
+                  "xorq %rcx,%rcx\n\t"
+                  "movq pBaseThreadInitThunk(%rip),%r9\n\t"
+                  "call *%r9\n\t"
+                  "int3\n\t"
+                   __ASM_SEH(".seh_handler call_thread_func_handler, @except\n\t") )
+
+#else /* defined(__x86_64__) && defined(__ASM_SEH_SUPPORTED) */
 
 void WINAPI RtlUserThreadStart( PRTL_THREAD_START_ROUTINE entry, void *arg )
 {
diff --git a/include/wine/asm.h b/include/wine/asm.h
index 0547ee94b19..9200491afd0 100644
--- a/include/wine/asm.h
+++ b/include/wine/asm.h
@@ -50,6 +50,7 @@
 #  define __ASM_SEH(str)
 # else
 #  define __ASM_SEH(str) str
+#  define __ASM_SEH_SUPPORTED
 # endif
 #else
 # define __ASM_SEH(str)

From: "Jiangyi Chen" <cjy520lcy@163.com>
#Subject: [PATCH] shell32: Use CP_UTF8 in __SHCloneStrAtoW.
Message-Id: <26bf0c42.3726.178151abb94.Coremail.cjy520lcy@163.com>
Date: Tue, 9 Mar 2021 11:49:36 +0800 (CST)

From 55b69cbacc40a684b6abafee155aa8fa63218433 Mon Sep 17 00:00:00 2001
From: Jiangyi Chen <chenjiangyi@uniontech.com>
Date: Tue, 9 Mar 2021 11:46:53 +0800
Subject: [PATCH] shell32: Use CP_UTF8 in __SHCloneStrAtoW. Fix problem that
 some paths cannot be opened by ShellExecuteA or ShellExecuteExA.

Signed-off-by: Jiangyi Chen <chenjiangyi@uniontech.com>
---
 dlls/shell32/shell32_main.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/shell32/shell32_main.h b/dlls/shell32/shell32_main.h
index 11111111111..11111111111 100644
--- a/dlls/shell32/shell32_main.h
+++ b/dlls/shell32/shell32_main.h
@@ -170,9 +170,9 @@ static inline BOOL SHELL_OsIsUnicode(void)
 
 static inline WCHAR * __SHCloneStrAtoW(WCHAR ** target, const char * source)
 {
-	int len = MultiByteToWideChar(CP_ACP, 0, source, -1, NULL, 0);
+	int len = MultiByteToWideChar(CP_UTF8, 0, source, -1, NULL, 0);
 	*target = SHAlloc(len*sizeof(WCHAR));
-	MultiByteToWideChar(CP_ACP, 0, source, -1, *target, len);
+	MultiByteToWideChar(CP_UTF8, 0, source, -1, *target, len);
 	return *target;
 }
 

-- 
2.36.1

From: Louis Lenders <xerox.xerox2000x@gmail.com>
Subject: [PATCH] Add RtlDosPathNameToRelativeNtPathName_U
Message-Id: <20210201175953.6137-1-xerox.xerox2000x@gmail.com>
Date: Mon,  1 Feb 2021 18:59:53 +0100

Trying to get scoop running in wine, turned out it needs robocopy.exe. As wine lacks robocopy, i had to fall
back to native robocopy, in this case from windows 8.1. Then one gets crash below.

Call from 7BC2C17A to unimplemented function ntdll.dll.RtlDosPathNameToRelativeNtPathName_U, aborting
wine: Unimplemented function ntdll.dll.RtlDosPathNameToRelativeNtPathName_U called at address 7BC2C17A (thread 0024), starting debugger...

So I added similar code as for RtlDosPathNameToNtPathName_U --> RtlDosPathNameToNtPathName_U_WithStatus
and that makes robocopy  work

Signed-off-by: Louis Lenders <xerox.xerox2000x@gmail.com>
---
 dlls/ntdll/ntdll.spec |  1 +
 dlls/ntdll/path.c     | 11 +++++++++++
 2 files changed, 12 insertions(+)

diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index 11111111111..11111111111 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -621,6 +621,7 @@
 # @ stub RtlDosApplyFileIsolationRedirection_Ustr
 @ stdcall RtlDosPathNameToNtPathName_U(wstr ptr ptr ptr)
 @ stdcall RtlDosPathNameToNtPathName_U_WithStatus(wstr ptr ptr ptr)
+@ stdcall RtlDosPathNameToRelativeNtPathName_U(wstr ptr ptr ptr)
 @ stdcall RtlDosPathNameToRelativeNtPathName_U_WithStatus(wstr ptr ptr ptr)
 @ stdcall RtlDosSearchPath_U(wstr wstr wstr long ptr ptr)
 # @ stub RtlDosSearchPath_Ustr
diff --git a/dlls/ntdll/path.c b/dlls/ntdll/path.c
index 11111111111..11111111111 100644
--- a/dlls/ntdll/path.c
+++ b/dlls/ntdll/path.c
@@ -330,6 +330,17 @@ NTSTATUS WINAPI RtlDosPathNameToRelativeNtPathName_U_WithStatus(const WCHAR *dos
     return RtlDosPathNameToNtPathName_U_WithStatus(dos_path, ntpath, file_part, NULL);
 }
 
+/**************************************************************************
+ *        RtlDosPathNameToRelativeNtPathName_U [NTDLL.@]
+ *
+ * See RtlDosPathNameToRelativeNtPathName_U_WithStatus
+ */
+BOOLEAN WINAPI RtlDosPathNameToRelativeNtPathName_U(const WCHAR *dos_path,
+    UNICODE_STRING *ntpath, WCHAR **file_part, RTL_RELATIVE_NAME *relative)
+{
+    return RtlDosPathNameToRelativeNtPathName_U_WithStatus(dos_path, ntpath, file_part, relative) == STATUS_SUCCESS;
+}
+
 /**************************************************************************
  *        RtlReleaseRelativeName [NTDLL.@]
  */

-- 
2.36.1

From 7130d843a12757b75c5588a9e19f9f4a4b9ea7ae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 8 Feb 2022 17:27:13 +0100
Subject: [PATCH] server: Seal shared memory mappings against future writes.

So that even if we leak console handles, we will, at least, stop messing
with these once and for all. This only prevents write(2) and mmap(2), as
we've already mmaped the writable pages we don't need it anymore.

This fixes Dead Cells hanging on launch, as it writes its DXVK logs to
one of the thread input shared memory handles, causing GetFocus to loop
forever as the sequence number got overwritten.

CW-Bug-Id: #20128
---
 configure.ac     |  1 +
 server/mapping.c | 24 ++++++++++++++++++++++++
 2 files changed, 25 insertions(+)

diff --git a/configure.ac b/configure.ac
index bc4f47d9889..22229880023 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1994,6 +1994,7 @@ AC_CHECK_FUNCS(\
 	getrandom \
 	kqueue \
 	mach_continuous_time \
+	memfd_create \
 	pipe2 \
 	port_create \
 	posix_fadvise \
diff --git a/server/mapping.c b/server/mapping.c
index ecbfbee7ea1..4514a877177 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -268,6 +268,7 @@ int grow_file( int unix_fd, file_pos_t new_size )
     return 0;
 }
 
+#ifndef HAVE_MEMFD_CREATE
 /* simplified version of mkstemps() */
 static int make_temp_file( char name[16] )
 {
@@ -301,10 +302,23 @@ static int check_current_dir_for_exec(void)
     unlink( tmpfn );
     return (ret != MAP_FAILED);
 }
+#endif
 
 /* create a temp file for anonymous mappings */
 static int create_temp_file( file_pos_t size )
 {
+#ifdef HAVE_MEMFD_CREATE
+    int fd = memfd_create( "wine-mapping", MFD_ALLOW_SEALING );
+    if (fd != -1)
+    {
+        if (!grow_file( fd, size ))
+        {
+            close( fd );
+            fd = -1;
+        }
+    }
+    else file_set_error();
+#else
     static int temp_dir_fd = -1;
     char tmpfn[16];
     int fd;
@@ -337,6 +351,7 @@ static int create_temp_file( file_pos_t size )
     else file_set_error();
 
     if (temp_dir_fd != server_dir_fd) fchdir( server_dir_fd );
+#endif
     return fd;
 }
 
@@ -1103,6 +1118,10 @@ int get_page_size(void)
     return page_mask + 1;
 }
 
+#ifndef F_SEAL_FUTURE_WRITE
+#define F_SEAL_FUTURE_WRITE 0x0010  /* prevent future writes while mapped */
+#endif
+
 struct object *create_user_data_mapping( struct object *root, const struct unicode_str *name,
                                          unsigned int attr, const struct security_descriptor *sd )
 {
@@ -1112,6 +1131,7 @@ struct object *create_user_data_mapping( struct object *root, const struct unico
     if (!(mapping = create_mapping( root, name, attr, sizeof(KSHARED_USER_DATA),
                                     SEC_COMMIT, 0, FILE_READ_DATA | FILE_WRITE_DATA, sd ))) return NULL;
     ptr = mmap( NULL, mapping->size, PROT_WRITE, MAP_SHARED, get_unix_fd( mapping->fd ), 0 );
+
     if (ptr != MAP_FAILED)
     {
         user_shared_data = ptr;
@@ -1123,11 +1143,15 @@ struct object *create_user_data_mapping( struct object *root, const struct unico
 struct object *create_shared_mapping( struct object *root, const struct unicode_str *name,
                                       mem_size_t size, const struct security_descriptor *sd, void **ptr )
 {
+    static int seals = F_SEAL_FUTURE_WRITE | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_SEAL;
     struct mapping *mapping;
 
     if (!(mapping = create_mapping( root, name, OBJ_OPENIF, size, SEC_COMMIT, 0,
                                     FILE_READ_DATA | FILE_WRITE_DATA, sd ))) return NULL;
     *ptr = mmap( NULL, mapping->size, PROT_WRITE, MAP_SHARED, get_unix_fd( mapping->fd ), 0 );
+
+    fcntl( get_unix_fd( mapping->fd ), F_ADD_SEALS, seals );
+
     if (*ptr == MAP_FAILED)
     {
         release_object( &mapping->obj );

