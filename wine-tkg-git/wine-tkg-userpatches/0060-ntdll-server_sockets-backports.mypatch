From 677eee8e7d5a8edce02bcff5e32f92cf091f5a52 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Tue, 26 Apr 2022 23:44:56 -0500
Subject: [PATCH] server: Return void from sock_reselect().

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 server/sock.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index b403541fcbf..a9d8d2ca2bd 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -567,7 +567,7 @@ void sock_init(void)
     }
 }
 
-static int sock_reselect( struct sock *sock )
+static void sock_reselect( struct sock *sock )
 {
     int ev = sock_get_poll_events( sock->fd );
 
@@ -575,7 +575,6 @@ static int sock_reselect( struct sock *sock )
         fprintf(stderr,"sock_reselect(%p): new mask %x\n", sock, ev);
 
     set_fd_events( sock->fd, ev );
-    return ev;
 }
 
 static unsigned int afd_poll_flag_to_win32( unsigned int flags )
-- 
2.37.1

From ad078be430615b9ae6911b61d6fdc8e1bf5bf6ad Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Tue, 3 May 2022 17:56:26 -0500
Subject: [PATCH] server: Send AFD_POLL_READ messages before AFD_POLL_WRITE.

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/tests/sock.c | 2 +-
 server/sock.c            | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index a9d8d2ca2bd..9f9b9bdfcd9 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -505,8 +505,8 @@ static const enum afd_poll_bit event_bitorder[] =
     AFD_POLL_BIT_CONNECT_ERR,
     AFD_POLL_BIT_ACCEPT,
     AFD_POLL_BIT_OOB,
-    AFD_POLL_BIT_WRITE,
     AFD_POLL_BIT_READ,
+    AFD_POLL_BIT_WRITE,
     AFD_POLL_BIT_RESET,
     AFD_POLL_BIT_HUP,
     AFD_POLL_BIT_CLOSE,
-- 
2.37.1

From 683d46a2cdf08d999f07d13e048ac6bca98b46fa Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Tue, 3 May 2022 17:56:27 -0500
Subject: [PATCH] server: Clear only returned events in IOCTL_AFD_GET_EVENTS.

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/tests/sock.c | 6 +++---
 server/sock.c            | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 9f9b9bdfcd9..29dd1ca7fa8 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -2516,7 +2516,7 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
         for (i = 0; i < ARRAY_SIZE( params.status ); ++i)
             params.status[i] = sock_get_ntstatus( sock->errors[i] );
 
-        sock->pending_events = 0;
+        sock->pending_events &= ~sock->mask;
         sock_reselect( sock );
 
         set_reply_data( &params, sizeof(params) );
-- 
2.37.1

From cafd260014932bf6a7319dae768a1f43e65176cf Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 5 May 2022 00:43:25 -0500
Subject: [PATCH] server: Do not signal read/write bits if there are read/write
 asyncs waiting.

This is validated by tests introduced in
59beffb46c813a3de2eae6f28e3f7f321f666e89 etc. This commit alone doesn't fix said
tests, because:

* on this poll, we will alert the waiting async;

* when reselecting, we will still request POLLIN, because the AFD_POLL_READ
  request is still active,

* when POLLIN is subsequently signaled, we do not remove it in
  sock_dispatch_asyncs(), because we check async_waiting(), not async_queued().

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 server/sock.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 29dd1ca7fa8..db0df5ecf79 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1179,10 +1179,9 @@ static void sock_poll_event( struct fd *fd, int event )
         break;
     }
 
-    complete_async_polls( sock, event, error );
-
     event = sock_dispatch_asyncs( sock, event, error );
     sock_dispatch_events( sock, prevstate, event, error );
+    complete_async_polls( sock, event, error );
 
     sock_reselect( sock );
 }
-- 
2.37.1

From 04b33ef098f453d7c46c6b45990d4ceb36716620 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 5 May 2022 00:43:26 -0500
Subject: [PATCH] server: Don't poll for POLLIN or POLLPRI if there are alerted
 read asyncs.

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/tests/afd.c |  2 +-
 server/sock.c           | 34 +++++++++++++++++++++-------------
 2 files changed, 22 insertions(+), 14 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index db0df5ecf79..cf25994c383 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1229,6 +1229,18 @@ static int sock_get_poll_events( struct fd *fd )
     if (!sock->type) /* not initialized yet */
         return -1;
 
+    LIST_FOR_EACH_ENTRY( req, &poll_list, struct poll_req, entry )
+    {
+        unsigned int i;
+
+        for (i = 0; i < req->count; ++i)
+        {
+            if (req->sockets[i].sock != sock) continue;
+
+            ev |= poll_flags_from_afd( sock, req->sockets[i].mask );
+        }
+    }
+
     switch (sock->state)
     {
     case SOCK_UNCONNECTED:
@@ -1271,7 +1283,15 @@ static int sock_get_poll_events( struct fd *fd )
         }
         else if (async_queued( &sock->read_q ))
         {
-            if (async_waiting( &sock->read_q )) ev |= POLLIN | POLLPRI;
+            /* Clear POLLIN and POLLPRI if we have an alerted async, even if
+             * we're polling this socket for READ or OOB. We can't signal the
+             * poll if the pending async will read all of the data [cf. the
+             * matching logic in sock_dispatch_asyncs()], but we also don't
+             * want to spin polling for POLLIN if we're not going to use it. */
+            if (async_waiting( &sock->read_q ))
+                ev |= POLLIN | POLLPRI;
+            else
+                ev &= ~(POLLIN | POLLPRI);
         }
         else
         {
@@ -1302,18 +1322,6 @@ static int sock_get_poll_events( struct fd *fd )
         break;
     }
 
-    LIST_FOR_EACH_ENTRY( req, &poll_list, struct poll_req, entry )
-    {
-        unsigned int i;
-
-        for (i = 0; i < req->count; ++i)
-        {
-            if (req->sockets[i].sock != sock) continue;
-
-            ev |= poll_flags_from_afd( sock, req->sockets[i].mask );
-        }
-    }
-
     return ev;
 }
 
-- 
2.37.1

From 30a56639fde4daf5e1eb3c3d37541b1bc9f75a6d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 5 May 2022 00:43:27 -0500
Subject: [PATCH] server: Do not signal read bits if there are read asyncs
 alerted.

Asyncs which are alerted but not "waiting" may still consume all data, and we
shouldn't signal AFD_POLL_READ or AFD_POLL_OOB in that case.

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 server/sock.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index cf25994c383..2bb2963a840 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1001,10 +1001,13 @@ static int sock_dispatch_asyncs( struct sock *sock, int event, int error )
     if ((event & POLLOUT) && sock->connect_req && sock->connect_req->iosb->status == STATUS_PENDING)
         complete_async_connect( sock );
 
-    if (event & (POLLIN | POLLPRI) && async_waiting( &sock->read_q ))
+    if ((event & (POLLIN | POLLPRI)) && async_queued( &sock->read_q ))
     {
-        if (debug_level) fprintf( stderr, "activating read queue for socket %p\n", sock );
-        async_wake_up( &sock->read_q, STATUS_ALERTED );
+        if (async_waiting( &sock->read_q ))
+        {
+            if (debug_level) fprintf( stderr, "activating read queue for socket %p\n", sock );
+            async_wake_up( &sock->read_q, STATUS_ALERTED );
+        }
         event &= ~(POLLIN | POLLPRI);
     }
 
-- 
2.37.1

From c5541f8a0814279e477b4c6199981bbe2d8575a4 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 5 May 2022 00:43:28 -0500
Subject: [PATCH] server: Don't poll for POLLOUT if there are alerted write
 asyncs.

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 server/sock.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/server/sock.c b/server/sock.c
index 2bb2963a840..cb76765e495 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1315,7 +1315,12 @@ static int sock_get_poll_events( struct fd *fd )
 
         if (async_queued( &sock->write_q ))
         {
-            if (async_waiting( &sock->write_q )) ev |= POLLOUT;
+            /* As with read asyncs above, clear POLLOUT if we have an alerted
+             * async. */
+            if (async_waiting( &sock->write_q ))
+                ev |= POLLOUT;
+            else
+                ev &= ~POLLOUT;
         }
         else if (!sock->wr_shutdown && (mask & AFD_POLL_WRITE))
         {
-- 
2.37.1

From bff228c198597f4a1c43432988a2d61f93df5bc9 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 5 May 2022 00:43:29 -0500
Subject: [PATCH] server: Do not signal write bits if there are write asyncs
 alerted.

Asyncs which are alerted but not "waiting" may still fill the pipe, and we
shouldn't signal AFD_POLL_WRITE in that case.

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 server/sock.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index cb76765e495..aa62a03d699 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1011,10 +1011,13 @@ static int sock_dispatch_asyncs( struct sock *sock, int event, int error )
         event &= ~(POLLIN | POLLPRI);
     }
 
-    if (event & POLLOUT && async_waiting( &sock->write_q ))
+    if ((event & POLLOUT) && async_queued( &sock->write_q ))
     {
-        if (debug_level) fprintf( stderr, "activating write queue for socket %p\n", sock );
-        async_wake_up( &sock->write_q, STATUS_ALERTED );
+        if (async_waiting( &sock->write_q ))
+        {
+            if (debug_level) fprintf( stderr, "activating write queue for socket %p\n", sock );
+            async_wake_up( &sock->write_q, STATUS_ALERTED );
+        }
         event &= ~POLLOUT;
     }
 
-- 
2.37.1

From 753fbb28d5c57ef73392dddd6b9e0c57c0dd675b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 5 May 2022 00:43:30 -0500
Subject: [PATCH] server: Do not signal accept bits if there are accept asyncs
 queued.

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ws2_32/tests/afd.c  | 2 +-
 dlls/ws2_32/tests/sock.c | 4 ++--
 server/sock.c            | 1 +
 3 files changed, 4 insertions(+), 3 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index aa62a03d699..e46be9349e2 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -990,6 +990,7 @@ static int sock_dispatch_asyncs( struct sock *sock, int event, int error )
             if (req->iosb->status == STATUS_PENDING && !req->accepted)
             {
                 complete_async_accept( sock, req );
+                event &= ~POLLIN;
                 break;
             }
         }
-- 
2.37.1

From 5a4e39795f8f54d3336d037263d21ce569179a89 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 6 May 2022 01:44:28 -0500
Subject: [PATCH] server: Remove a redundant call to set_fd_events().

We will always call set_fd_events() again in sock_reselect().

Signed-off-by: Zebediah Figura <zfigura@codeweavers.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 server/sock.c | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index e46be9349e2..77a88a7fcf7 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1112,9 +1112,6 @@ static void sock_poll_event( struct fd *fd, int event )
     if (debug_level)
         fprintf(stderr, "socket %p select event: %x\n", sock, event);
 
-    /* we may change event later, remove from loop here */
-    if (event & (POLLERR|POLLHUP)) set_fd_events( sock->fd, -1 );
-
     switch (sock->state)
     {
     case SOCK_UNCONNECTED:
-- 
2.37.1

From 9d1085c8d39daaa02a0d30ac4a7af2860ff9fe3d Mon Sep 17 00:00:00 2001
From: Piotr Caban <piotr@codeweavers.com>
Date: Fri, 10 Jun 2022 17:05:37 +0200
Subject: [PATCH] server: Always return Win32 error code from
 IOCTL_AFD_GET_SO_ERROR.

Signed-off-by: Piotr Caban <piotr@codeweavers.com>
---
 server/sock.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/server/sock.c b/server/sock.c
index 77a88a7fcf7..8a0f3198c4e 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -2804,12 +2804,13 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
             {
                 if (sock->errors[i])
                 {
-                    error = sock_get_error( sock->errors[i] );
+                    error = sock->errors[i];
                     break;
                 }
             }
         }
 
+        error = sock_get_error( error );
         set_reply_data( &error, sizeof(error) );
         return;
     }
-- 
2.37.1

From 73648f901cc64e061d4b9d316719c952e3a52ce8 Mon Sep 17 00:00:00 2001
From: Piotr Caban <piotr@codeweavers.com>
Date: Fri, 10 Jun 2022 17:07:25 +0200
Subject: [PATCH] server: Don't reset socket error in poll_socket.

Otherwise socket error may be cleared in poll_socket causing ioctl SO_ERROR calls to return no error.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51433
Signed-off-by: Piotr Caban <piotr@codeweavers.com>
---
 server/sock.c | 30 ++++++++++++++++++++++--------
 1 file changed, 22 insertions(+), 8 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 8a0f3198c4e..439801a8cfa 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -631,13 +631,27 @@ static void sock_wake_up( struct sock *sock )
     }
 }
 
-static inline int sock_error( struct fd *fd )
+static inline int sock_error( struct sock *sock )
 {
-    unsigned int optval = 0;
-    socklen_t optlen = sizeof(optval);
+    int error = 0;
+    socklen_t len = sizeof(error);
 
-    getsockopt( get_unix_fd(fd), SOL_SOCKET, SO_ERROR, (void *) &optval, &optlen);
-    return optval;
+    getsockopt( get_unix_fd(sock->fd), SOL_SOCKET, SO_ERROR, (void *)&error, &len);
+    if (sock->state == SOCK_CONNECTING)
+    {
+        if (error)
+            sock->errors[AFD_POLL_BIT_CONNECT_ERR] = error;
+        else
+            error = sock->errors[AFD_POLL_BIT_CONNECT_ERR];
+    }
+    else if (sock->state == SOCK_LISTENING)
+    {
+        if (error)
+            sock->errors[AFD_POLL_BIT_ACCEPT] = error;
+        else
+            error = sock->errors[AFD_POLL_BIT_ACCEPT];
+    }
+    return error;
 }
 
 static void free_accept_req( void *private )
@@ -1120,9 +1134,9 @@ static void sock_poll_event( struct fd *fd, int event )
     case SOCK_CONNECTING:
         if (event & (POLLERR|POLLHUP))
         {
+            error = sock_error( sock );
             sock->state = SOCK_UNCONNECTED;
             event &= ~POLLOUT;
-            error = sock_error( fd );
         }
         else if (event & POLLOUT)
         {
@@ -1133,7 +1147,7 @@ static void sock_poll_event( struct fd *fd, int event )
 
     case SOCK_LISTENING:
         if (event & (POLLERR|POLLHUP))
-            error = sock_error( fd );
+            error = sock_error( sock );
         break;
 
     case SOCK_CONNECTED:
@@ -3125,7 +3139,7 @@ static void poll_socket( struct sock *poll_sock, struct async *async, int exclus
         {
             signaled = TRUE;
             req->sockets[i].flags = flags;
-            req->sockets[i].status = sock_get_ntstatus( sock_error( sock->fd ) );
+            req->sockets[i].status = sock_get_ntstatus( sock_error( sock ) );
         }
 
         /* FIXME: do other error conditions deserve a similar treatment? */
-- 
2.37.1

From 0c7928061c05d6f24bc62b7bb5de7e2447ac4163 Mon Sep 17 00:00:00 2001
From: Piotr Caban <piotr@codeweavers.com>
Date: Fri, 10 Jun 2022 17:09:30 +0200
Subject: [PATCH] server: Don't reset socket error in IOCTL_AFD_GET_SO_ERROR.

Signed-off-by: Piotr Caban <piotr@codeweavers.com>
---
 server/sock.c | 8 +-------
 1 file changed, 1 insertion(+), 7 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 439801a8cfa..b11ebddb51d 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -2797,7 +2797,6 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
     case IOCTL_AFD_WINE_GET_SO_ERROR:
     {
         int error;
-        socklen_t len = sizeof(error);
         unsigned int i;
 
         if (get_reply_max_size() < sizeof(error))
@@ -2806,12 +2805,7 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
             return;
         }
 
-        if (getsockopt( unix_fd, SOL_SOCKET, SO_ERROR, (char *)&error, &len ) < 0)
-        {
-            set_error( sock_get_ntstatus( errno ) );
-            return;
-        }
-
+        error = sock_error( sock );
         if (!error)
         {
             for (i = 0; i < ARRAY_SIZE( sock->errors ); ++i)
-- 
2.37.1

From 68d4643a6758cbe87f90054fdcabf0558fc353ca Mon Sep 17 00:00:00 2001
From: David Curtiss <david.curtiss@ni.com>
Date: Mon, 6 Jun 2022 15:34:12 -0500
Subject: [PATCH] ws2_32: Allow getsockname after AcceptEx.

.NET 6's HTTP/Socket code queries this. Winsock allows getsockname
on the AcceptEx AcceptSocket, but only if SO_UPDATE_ACCEPT_CONTEXT
is set.

Signed-off-by: David Curtiss <david.curtiss@ni.com>
---
 dlls/ws2_32/tests/sock.c | 9 +++++++++
 server/sock.c            | 1 +
 2 files changed, 10 insertions(+)

diff --git a/server/sock.c b/server/sock.c
index b11ebddb51d..2f1b33a333d 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1846,6 +1846,7 @@ static int accept_into_socket( struct sock *sock, struct sock *acceptsock )
     }
 
     acceptsock->state = SOCK_CONNECTED;
+    acceptsock->bound = 1;
     acceptsock->pending_events = 0;
     acceptsock->reported_events = 0;
     acceptsock->proto   = sock->proto;
-- 
2.37.1

From 3af025879583dff92540e29a92031a1078296484 Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Tue, 28 Jun 2022 13:16:51 +0200
Subject: [PATCH] ntdll: Fix returned status code for paths with a trailing
 slash.

Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/kernel32/tests/file.c | 25 ++++---------------------
 dlls/ntdll/tests/file.c    |  5 +----
 dlls/ntdll/tests/path.c    | 11 +++++------
 dlls/ntdll/unix/file.c     |  7 +++++--
 dlls/ucrtbase/tests/misc.c |  2 +-
 server/fd.c                |  6 +++++-
 6 files changed, 21 insertions(+), 35 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 4873f7f093c..e09e8cafc82 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -3187,7 +3187,7 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
 
         /* grow the buffer if needed */
 
-        if (unix_len - pos < MAX_DIR_ENTRY_LEN + 2)
+        if (unix_len - pos < MAX_DIR_ENTRY_LEN + 3)
         {
             char *new_name;
             unix_len += 2 * MAX_DIR_ENTRY_LEN;
@@ -3208,7 +3208,9 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
                     if (ret > 0 && ret <= MAX_DIR_ENTRY_LEN)
                     {
                         unix_name[pos] = '/';
-                        unix_name[pos + 1 + ret] = 0;
+                        pos += ret + 1;
+                        if (end < next) unix_name[pos++] = '/';
+                        unix_name[pos] = 0;
                         status = STATUS_NO_SUCH_FILE;
                         break;
                     }
@@ -3218,6 +3220,7 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
             {
                 status = STATUS_OBJECT_NAME_COLLISION;
             }
+            if (end < next) strcat( unix_name, "/" );
         }
         else if (status == STATUS_OBJECT_NAME_NOT_FOUND) status = STATUS_OBJECT_PATH_NOT_FOUND;
 
diff --git a/server/fd.c b/server/fd.c
index 1b4b98b0e76..eaebe044f37 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -2191,8 +2191,12 @@ struct fd *open_fd( struct fd *root, con
 
         if (fd->unix_fd == -1)
         {
-            file_set_error();
-            if (do_chmod) chmod( name, *mode );
+            /* check for trailing slash on file path */
+            if ((errno == ENOENT || errno == ENOTDIR) && name[strlen(name) - 1] == '/')
+                set_error( STATUS_OBJECT_NAME_INVALID );
+            else
+                file_set_error();
+                if (do_chmod) chmod( name, *mode );
             goto error;
         }
     }

-- 
2.37.1

From 41d16358dc558c0544f3506a3a4c9dd464d6ceff Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Sun, 29 May 2022 16:56:16 -0500
Subject: [PATCH] server: Remove the no longer used sock_queue_async()
 function.

---
 server/sock.c | 47 +----------------------------------------------
 1 file changed, 1 insertion(+), 46 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index caa68dd213b..9f872c65637 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -237,7 +237,6 @@ static void sock_poll_event( struct fd *fd, int event );
 static enum server_fd_type sock_get_fd_type( struct fd *fd );
 static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async );
 static void sock_cancel_async( struct fd *fd, struct async *async );
-static void sock_queue_async( struct fd *fd, struct async *async, int type, int count );
 static void sock_reselect_async( struct fd *fd, struct async_queue *queue );
 
 static int accept_into_socket( struct sock *sock, struct sock *acceptsock );
@@ -283,7 +282,7 @@ static const struct fd_ops sock_fd_ops =
     no_fd_get_volume_info,        /* get_volume_info */
     sock_ioctl,                   /* ioctl */
     sock_cancel_async,            /* cancel_async */
-    sock_queue_async,             /* queue_async */
+    no_fd_queue_async,            /* queue_async */
     sock_reselect_async           /* reselect_async */
 };
 
@@ -1376,50 +1375,6 @@ static void sock_cancel_async( struct fd *fd, struct async *async )
     async_terminate( async, STATUS_CANCELLED );
 }
 
-static void sock_queue_async( struct fd *fd, struct async *async, int type, int count )
-{
-    struct sock *sock = get_fd_user( fd );
-    struct async_queue *queue;
-
-    assert( sock->obj.ops == &sock_ops );
-
-    switch (type)
-    {
-    case ASYNC_TYPE_READ:
-        if (sock->rd_shutdown)
-        {
-            set_error( STATUS_PIPE_DISCONNECTED );
-            return;
-        }
-        queue = &sock->read_q;
-        break;
-
-    case ASYNC_TYPE_WRITE:
-        if (sock->wr_shutdown)
-        {
-            set_error( STATUS_PIPE_DISCONNECTED );
-            return;
-        }
-        queue = &sock->write_q;
-        break;
-
-    default:
-        set_error( STATUS_INVALID_PARAMETER );
-        return;
-    }
-
-    if (sock->state != SOCK_CONNECTED)
-    {
-        set_error( STATUS_PIPE_DISCONNECTED );
-        return;
-    }
-
-    queue_async( queue, async );
-    sock_reselect( sock );
-
-    set_error( STATUS_PENDING );
-}
-
 static void sock_reselect_async( struct fd *fd, struct async_queue *queue )
 {
     struct sock *sock = get_fd_user( fd );
-- 
2.37.1

From 647bed72f5be32d00453d3caff1bbaf172e4f265 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Sun, 19 Jun 2022 21:42:52 -0500
Subject: [PATCH] server: Remove the unused "flags" field from struct sock.

---
 server/sock.c | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 9f872c65637..5a4240e78f4 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -187,7 +187,6 @@ struct sock
      * both pending_events and reported_events (as we should only ever report
      * any event once until it is reset.) */
     unsigned int        reported_events;
-    unsigned int        flags;       /* socket flags */
     unsigned short      proto;       /* socket protocol */
     unsigned short      type;        /* socket type */
     unsigned short      family;      /* socket family */
@@ -1479,7 +1478,6 @@ static struct sock *create_socket(void)
     sock->mask    = 0;
     sock->pending_events = 0;
     sock->reported_events = 0;
-    sock->flags   = 0;
     sock->proto   = 0;
     sock->type    = 0;
     sock->family  = 0;
@@ -1594,7 +1592,7 @@ static void set_dont_fragment( int fd, int level, int value )
     setsockopt( fd, level, optname, &value, sizeof(value) );
 }
 
-static int init_socket( struct sock *sock, int family, int type, int protocol, unsigned int flags )
+static int init_socket( struct sock *sock, int family, int type, int protocol )
 {
     unsigned int options = 0;
     int sockfd, unix_type, unix_family, unix_protocol, value;
@@ -1673,7 +1671,6 @@ static int init_socket( struct sock *sock, int family, int type, int protocol, u
         sock->sndbuf = value;
 
     sock->state  = (type == WS_SOCK_STREAM ? SOCK_UNCONNECTED : SOCK_CONNECTIONLESS);
-    sock->flags  = flags;
     sock->proto  = protocol;
     sock->type   = type;
     sock->family = family;
@@ -1751,7 +1748,6 @@ static struct sock *accept_socket( struct sock *sock )
         acceptsock->message = sock->message;
         acceptsock->connect_time = current_time;
         if (sock->event) acceptsock->event = (struct event *)grab_object( sock->event );
-        acceptsock->flags = sock->flags;
         if (!(acceptsock->fd = create_anonymous_fd( &sock_fd_ops, acceptfd, &acceptsock->obj,
                                                     get_fd_options( sock->fd ) )))
         {
@@ -2159,7 +2155,7 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
             set_error( STATUS_INVALID_PARAMETER );
             return;
         }
-        init_socket( sock, params->family, params->type, params->protocol, params->flags );
+        init_socket( sock, params->family, params->type, params->protocol );
         return;
     }
 
-- 
2.37.1

From ea6f88d83fddfb88610f8457f68cbeb571140ec1 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Sun, 29 May 2022 11:29:28 -0500
Subject: [PATCH] server: Do not set the socket state in
 complete_async_connect().

It's already set previously in sock_poll_event(). Moreover, complete_async_connect() will not always be called.
---
 server/sock.c | 2 --
 1 file changed, 2 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 5a4240e78f4..60b03c13bba 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -806,8 +806,6 @@ static void complete_async_connect( struct sock *sock )
 
     if (debug_level) fprintf( stderr, "completing connect request for socket %p\n", sock );
 
-    sock->state = SOCK_CONNECTED;
-
     if (!req->send_len)
     {
         async_terminate( req->async, STATUS_SUCCESS );
-- 
2.37.1

From 869cbc4b4b7c46b0d94a34900daac849de860eea Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Sun, 29 May 2022 11:30:28 -0500
Subject: [PATCH] server: Set the connection time if connect() returns 0.

---
 server/sock.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/server/sock.c b/server/sock.c
index 60b03c13bba..fed8e3b3093 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -2359,6 +2359,7 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
         if (!ret)
         {
             sock->state = SOCK_CONNECTED;
+            sock->connect_time = current_time;
 
             if (!send_len) return;
         }
-- 
2.37.1

From 8a4433d6a7755fb6b156563b166a9993f54c8103 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Sun, 29 May 2022 17:32:28 -0500
Subject: [PATCH] server: Do not set connectionless sockets into the CONNECTING
 or CONNECTED state.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=53058
---
 dlls/ws2_32/tests/sock.c | 12 ++++++------
 server/sock.c            | 10 +++++++---
 2 files changed, 13 insertions(+), 9 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 2bf56045612..4eef5c1ddb7 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -2385,13 +2385,17 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
 
         if (!ret)
         {
-            sock->state = SOCK_CONNECTED;
-            sock->connect_time = current_time;
+            if (sock->type != WS_SOCK_DGRAM)
+            {
+                sock->state = SOCK_CONNECTED;
+                sock->connect_time = current_time;
+            }
 
             if (!send_len) return;
         }
 
-        sock->state = SOCK_CONNECTING;
+        if (sock->type != WS_SOCK_DGRAM)
+            sock->state = SOCK_CONNECTING;
 
         if (params->synchronous && sock->nonblocking)
         {
-- 
2.37.1

From 07b66768b101c3bf8152c5db09c2bfa432e0eba6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 28 Apr 2022 21:11:02 -0500
Subject: [PATCH] Revert "server: Explicitly shutdown destroyed sockets to
 force pending poll() calls to return.".

This reverts commit 24b64534e592e47e5cac70e497a98c0ddbc3941b.

We no longer perform any blocking waits on the client side, so shutdown() is no
longer necessary.

Moreover, shutting down is not always correct. Under some conditions, closing a
TCP socket should trigger RST without FIN (namely, when SO_LINGER is on but has
a zero timeout). By reverting this commit we match Windows behaviour in this
respect.
---
 dlls/ws2_32/tests/afd.c  |  9 ++++-----
 dlls/ws2_32/tests/sock.c | 30 +++++++++++++++---------------
 server/sock.c            |  7 +------
 3 files changed, 20 insertions(+), 26 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 4eef5c1ddb7..31a04579fce 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1467,12 +1467,7 @@ static void sock_destroy( struct object *obj )
     free_async_queue( &sock->connect_q );
     free_async_queue( &sock->poll_q );
     if (sock->event) release_object( sock->event );
-    if (sock->fd)
-    {
-        /* shut the socket down to force pending poll() calls in the client to return */
-        shutdown( get_unix_fd(sock->fd), SHUT_RDWR );
-        release_object( sock->fd );
-    }
+    if (sock->fd) release_object( sock->fd );
 }
 
 static struct sock *create_socket(void)
-- 
2.37.1

From f234341ca1170a799d03179061914b772d4166cd Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 28 Apr 2022 21:40:46 -0500
Subject: [PATCH] server: Always wake up pending read or write asyncs on
 POLLHUP or POLLERR.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52815
---
 dlls/ws2_32/tests/sock.c | 32 ++++++++++++++++----------------
 server/sock.c            |  6 ++----
 2 files changed, 18 insertions(+), 20 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 31a04579fce..95335df8fd3 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1046,10 +1046,8 @@ static int sock_dispatch_asyncs( struct sock *sock, int event, int error )
         int status = sock_get_ntstatus( error );
         struct accept_req *req, *next;
 
-        if (sock->rd_shutdown || sock->hangup)
-            async_wake_up( &sock->read_q, status );
-        if (sock->wr_shutdown)
-            async_wake_up( &sock->write_q, status );
+        async_wake_up( &sock->read_q, status );
+        async_wake_up( &sock->write_q, status );
 
         LIST_FOR_EACH_ENTRY_SAFE( req, next, &sock->accept_list, struct accept_req, entry )
         {
-- 
2.37.1

From 236476417ac6777951d1cfc26c0393bff2a64c23 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 27 Apr 2022 19:25:20 -0500
Subject: [PATCH] server: Use sock_poll_event() in poll_socket().

In multiple cases errors may be reported only once by the host socket
implementation, but should persist for Windows sockets. These cases are
currently not handled by poll_socket().

poll_socket() also does not include logic for filtering out events when asyncs
are queued or alerted on the relevant socket.

Hence, instead of duplicating more logic, remove the logic already duplicated,
and just call sock_poll_event(), so that there is one central place where events
are translated.

Mark the currently active poll async with a special "pending" field so that
poll_socket() does not attempt to complete it before all sockets are checked.
---
 server/sock.c | 53 +++++++++++++++++----------------------------------
 1 file changed, 17 insertions(+), 36 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 95335df8fd3..b96f81a0ea8 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -124,6 +124,7 @@ struct poll_req
     struct timeout_user *timeout;
     timeout_t orig_timeout;
     int exclusive;
+    int pending;
     unsigned int count;
     struct
     {
@@ -981,8 +982,11 @@ static void complete_async_polls( struct sock *sock, int event, int error )
             req->sockets[i].flags = req->sockets[i].mask & flags;
             req->sockets[i].status = sock_get_ntstatus( error );
 
-            complete_async_poll( req, STATUS_SUCCESS );
-            break;
+            if (req->pending)
+            {
+                complete_async_poll( req, STATUS_SUCCESS );
+                break;
+            }
         }
     }
 }
@@ -3002,32 +3006,6 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
     }
 }
 
-static int poll_single_socket( struct sock *sock, int mask )
-{
-    struct pollfd pollfd;
-
-    pollfd.fd = get_unix_fd( sock->fd );
-    pollfd.events = poll_flags_from_afd( sock, mask );
-    if (pollfd.events < 0 || poll( &pollfd, 1, 0 ) < 0)
-        return 0;
-
-    if (sock->state == SOCK_CONNECTING && (pollfd.revents & (POLLERR | POLLHUP)))
-        pollfd.revents &= ~POLLOUT;
-
-    if ((mask & AFD_POLL_HUP) && (pollfd.revents & POLLIN) && sock->type == WS_SOCK_STREAM)
-    {
-        char dummy;
-
-        if (!recv( get_unix_fd( sock->fd ), &dummy, 1, MSG_PEEK ))
-        {
-            pollfd.revents &= ~POLLIN;
-            pollfd.revents |= POLLHUP;
-        }
-    }
-
-    return get_poll_flags( sock, pollfd.revents ) & mask;
-}
-
 static void handle_exclusive_poll(struct poll_req *req)
 {
     unsigned int i;
@@ -3065,6 +3043,7 @@ static void poll_socket( struct sock *poll_sock, struct async *async, int exclus
         return;
 
     req->timeout = NULL;
+    req->pending = 0;
     if (timeout && timeout != TIMEOUT_INFINITE &&
         !(req->timeout = add_timeout_user( timeout, async_poll_timeout, req )))
     {
@@ -3103,26 +3082,28 @@ static void poll_socket( struct sock *poll_sock, struct async *async, int exclus
     {
         struct sock *sock = req->sockets[i].sock;
         int mask = req->sockets[i].mask;
-        int flags = poll_single_socket( sock, mask );
+        struct pollfd pollfd;
 
-        if (flags)
-        {
-            signaled = TRUE;
-            req->sockets[i].flags = flags;
-            req->sockets[i].status = sock_get_ntstatus( sock_error( sock ) );
-        }
+        pollfd.fd = get_unix_fd( sock->fd );
+        pollfd.events = poll_flags_from_afd( sock, mask );
+        if (pollfd.events >= 0 && poll( &pollfd, 1, 0 ) >= 0)
+            sock_poll_event( sock->fd, pollfd.revents );
 
         /* FIXME: do other error conditions deserve a similar treatment? */
         if (sock->state != SOCK_CONNECTING && sock->errors[AFD_POLL_BIT_CONNECT_ERR] && (mask & AFD_POLL_CONNECT_ERR))
         {
-            signaled = TRUE;
             req->sockets[i].flags |= AFD_POLL_CONNECT_ERR;
             req->sockets[i].status = sock_get_ntstatus( sock->errors[AFD_POLL_BIT_CONNECT_ERR] );
         }
+
+        if (req->sockets[i].flags)
+            signaled = TRUE;
     }
 
     if (!timeout || signaled)
         complete_async_poll( req, STATUS_SUCCESS );
+    else
+        req->pending = 1;
 
     for (i = 0; i < req->count; ++i)
         sock_reselect( req->sockets[i].sock );
-- 
2.37.1

From a1fd99cfbb478b2668aa684e5de00b6994a4daee Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 11 Jul 2022 23:08:04 -0500
Subject: [PATCH] server: Clear sock->errors[AFD_POLL_BIT_CONNECT_ERR] in
 sock_poll_event().

Give sock_dispatch_events() a more consistent scope.
---
 server/sock.c | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index b96f81a0ea8..1224c3b4674 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1090,10 +1090,7 @@ static void sock_dispatch_events( struct sock *sock, enum connection_state prevs
 
     case SOCK_CONNECTING:
         if (event & POLLOUT)
-        {
             post_socket_event( sock, AFD_POLL_BIT_CONNECT, 0 );
-            sock->errors[AFD_POLL_BIT_CONNECT_ERR] = 0;
-        }
         if (event & (POLLERR | POLLHUP))
             post_socket_event( sock, AFD_POLL_BIT_CONNECT_ERR, error );
         break;
@@ -1149,6 +1146,7 @@ static void sock_poll_event( struct fd *fd, int event )
         {
             sock->state = SOCK_CONNECTED;
             sock->connect_time = current_time;
+            sock->errors[AFD_POLL_BIT_CONNECT_ERR] = 0;
         }
         break;
 
-- 
2.37.1

From a2f2b773fb9a55bd73affe4c0ac9e3ff50f6ce03 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 11 Jul 2022 23:24:38 -0500
Subject: [PATCH] server: Record the error for connected and connectionless
 sockets sockets in sock_error().

As long as we do it for connecting and listening sockets, do it here for the
remaining socket types as well.
---
 server/sock.c | 23 +++++++++++++++++++----
 1 file changed, 19 insertions(+), 4 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 1224c3b4674..373236cab56 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -645,20 +645,35 @@ static inline int sock_error( struct sock *sock )
     socklen_t len = sizeof(error);
 
     getsockopt( get_unix_fd(sock->fd), SOL_SOCKET, SO_ERROR, (void *)&error, &len);
-    if (sock->state == SOCK_CONNECTING)
+
+    switch (sock->state)
     {
+    case SOCK_UNCONNECTED:
+        break;
+
+    case SOCK_CONNECTING:
         if (error)
             sock->errors[AFD_POLL_BIT_CONNECT_ERR] = error;
         else
             error = sock->errors[AFD_POLL_BIT_CONNECT_ERR];
-    }
-    else if (sock->state == SOCK_LISTENING)
-    {
+        break;
+
+    case SOCK_LISTENING:
         if (error)
             sock->errors[AFD_POLL_BIT_ACCEPT] = error;
         else
             error = sock->errors[AFD_POLL_BIT_ACCEPT];
+        break;
+
+    case SOCK_CONNECTED:
+    case SOCK_CONNECTIONLESS:
+        if (error)
+            sock->errors[AFD_POLL_BIT_HUP] = error;
+        else
+            error = sock->errors[AFD_POLL_BIT_HUP];
+        break;
     }
+
     return error;
 }
 
-- 
2.37.1

From 41cdc6674cd5882adc151ec7f4199c6b11c9227f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 11 Jul 2022 23:38:34 -0500
Subject: [PATCH] server: Report the socket error in sock_poll_event() on
 POLLERR or POLLHUP.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52815
---
 dlls/ws2_32/tests/afd.c | 3 ++-
 server/sock.c           | 6 +++---
 2 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 373236cab56..a8c0b56c2bc 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1145,6 +1145,9 @@ static void sock_poll_event( struct fd *fd, int event )
     if (debug_level)
         fprintf(stderr, "socket %p select event: %x\n", sock, event);
 
+    if (event & (POLLERR | POLLHUP))
+        error = sock_error( sock );
+
     switch (sock->state)
     {
     case SOCK_UNCONNECTED:
@@ -1153,7 +1156,6 @@ static void sock_poll_event( struct fd *fd, int event )
     case SOCK_CONNECTING:
         if (event & (POLLERR|POLLHUP))
         {
-            error = sock_error( sock );
             sock->state = SOCK_UNCONNECTED;
             event &= ~POLLOUT;
         }
@@ -1166,8 +1168,6 @@ static void sock_poll_event( struct fd *fd, int event )
         break;
 
     case SOCK_LISTENING:
-        if (event & (POLLERR|POLLHUP))
-            error = sock_error( sock );
         break;
 
     case SOCK_CONNECTED:
-- 
2.37.1

From 1d0e21db29b7d5b11cff8726ca3e2d0fe57c9ab6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 11 Jul 2022 23:48:09 -0500
Subject: [PATCH] server: Move sock->error setting completely out of
 sock_dispatch_events().

---
 server/sock.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index a8c0b56c2bc..53553ab8ee7 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1084,7 +1084,7 @@ static int sock_dispatch_asyncs( struct sock *sock, int event, int error )
     return event;
 }
 
-static void post_socket_event( struct sock *sock, enum afd_poll_bit event_bit, int error )
+static void post_socket_event( struct sock *sock, enum afd_poll_bit event_bit )
 {
     unsigned int event = (1 << event_bit);
 
@@ -1092,11 +1092,10 @@ static void post_socket_event( struct sock *sock, enum afd_poll_bit event_bit, i
     {
         sock->pending_events |= event;
         sock->reported_events |= event;
-        sock->errors[event_bit] = error;
     }
 }
 
-static void sock_dispatch_events( struct sock *sock, enum connection_state prevstate, int event, int error )
+static void sock_dispatch_events( struct sock *sock, enum connection_state prevstate, int event )
 {
     switch (prevstate)
     {
@@ -1105,29 +1104,29 @@ static void sock_dispatch_events( struct sock *sock, enum connection_state prevs
 
     case SOCK_CONNECTING:
         if (event & POLLOUT)
-            post_socket_event( sock, AFD_POLL_BIT_CONNECT, 0 );
+            post_socket_event( sock, AFD_POLL_BIT_CONNECT );
         if (event & (POLLERR | POLLHUP))
-            post_socket_event( sock, AFD_POLL_BIT_CONNECT_ERR, error );
+            post_socket_event( sock, AFD_POLL_BIT_CONNECT_ERR );
         break;
 
     case SOCK_LISTENING:
         if (event & (POLLIN | POLLERR | POLLHUP))
-            post_socket_event( sock, AFD_POLL_BIT_ACCEPT, error );
+            post_socket_event( sock, AFD_POLL_BIT_ACCEPT );
         break;
 
     case SOCK_CONNECTED:
     case SOCK_CONNECTIONLESS:
         if (event & POLLIN)
-            post_socket_event( sock, AFD_POLL_BIT_READ, 0 );
+            post_socket_event( sock, AFD_POLL_BIT_READ );
 
         if (event & POLLOUT)
-            post_socket_event( sock, AFD_POLL_BIT_WRITE, 0 );
+            post_socket_event( sock, AFD_POLL_BIT_WRITE );
 
         if (event & POLLPRI)
-            post_socket_event( sock, AFD_POLL_BIT_OOB, 0 );
+            post_socket_event( sock, AFD_POLL_BIT_OOB );
 
         if (event & (POLLERR | POLLHUP))
-            post_socket_event( sock, AFD_POLL_BIT_HUP, error );
+            post_socket_event( sock, AFD_POLL_BIT_HUP );
         break;
     }
 
@@ -1194,6 +1193,7 @@ static void sock_poll_event( struct fd *fd, int event )
                 {
                     error = errno;
                     event |= POLLERR;
+                    sock->errors[AFD_POLL_BIT_HUP] = error;
                     if ( debug_level )
                         fprintf( stderr, "recv error on socket %p: %d\n", sock, errno );
                 }
@@ -1218,7 +1218,7 @@ static void sock_poll_event( struct fd *fd, int event )
     }
 
     event = sock_dispatch_asyncs( sock, event, error );
-    sock_dispatch_events( sock, prevstate, event, error );
+    sock_dispatch_events( sock, prevstate, event );
     complete_async_polls( sock, event, error );
 
     sock_reselect( sock );
-- 
2.37.1

From fef675e764d268d85be9f9ad2b2e62b66e1b1511 Mon Sep 17 00:00:00 2001
From: Alexandre Julliard <julliard@winehq.org>
Date: Tue, 28 Jun 2022 13:01:26 +0200
Subject: [PATCH] ntdll: Fix returned status code for non-directory in path.

Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/ntdll/tests/file.c | 2 --
 dlls/ntdll/tests/path.c | 8 ++++----
 dlls/ntdll/unix/file.c  | 6 +++---
 3 files changed, 7 insertions(+), 9 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index cc8bf0c6e82..4873f7f093c 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -2594,7 +2594,7 @@ static NTSTATUS find_file_in_dir( char *unix_name, int pos, const WCHAR *name, i
 
 not_found:
     unix_name[pos - 1] = 0;
-    return STATUS_OBJECT_PATH_NOT_FOUND;
+    return STATUS_OBJECT_NAME_NOT_FOUND;
 }
 
 
@@ -3437,10 +3437,9 @@ static NTSTATUS lookup_unix_name( const
         /* if this is the last element, not finding it is not necessarily fatal */
         if (!name_len)
         {
-            if (status == STATUS_OBJECT_PATH_NOT_FOUND
+            if (status == STATUS_OBJECT_NAME_NOT_FOUND
                 || (disposition == FILE_WINE_PATH && status == STATUS_OBJECT_NAME_NOT_FOUND))
             {
-                status = STATUS_OBJECT_NAME_NOT_FOUND;
                 if (disposition != FILE_OPEN && disposition != FILE_OVERWRITE)
                 {
                     ret = ntdll_wcstoumbs( name, end - name, unix_name + pos + 1, MAX_DIR_ENTRY_LEN + 1, TRUE );
@@ -3220,6 +3219,7 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
                 status = STATUS_OBJECT_NAME_COLLISION;
             }
         }
+        else if (status == STATUS_OBJECT_NAME_NOT_FOUND) status = STATUS_OBJECT_PATH_NOT_FOUND;
 
         if (status != STATUS_SUCCESS) break;
 
-- 
2.37.1

From 9783e2e16c35586b5fa65ae27ac1f96c6260c534 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Sun, 29 May 2022 16:40:36 -0500
Subject: [PATCH] ntdll: Use the recv_socket request for NtReadFile() on a
 socket.

recv_socket does some extra bookkeeping that's currently missing from the
register_async path. Instead of adding it to sock_queue_async(), let's just
centralize all recv requests so that they go through recv_socket.
---
 dlls/ntdll/unix/file.c         |   6 ++
 dlls/ntdll/unix/socket.c       | 129 ++++++++++++++++++++-------------
 dlls/ntdll/unix/unix_private.h |   2 +
 dlls/ws2_32/tests/afd.c        |   2 +-
 4 files changed, 89 insertions(+), 50 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index e09e8cafc82c..f57532f55bff 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -5670,6 +5676,12 @@ NTSTATUS WINAPI NtReadFile( HANDLE handl
             goto done;
         }
     }
+    else if (type == FD_TYPE_SOCKET)
+    {
+        status = sock_read( handle, unix_handle, event, apc, apc_user, io, buffer, length );
+        if (needs_close) close( unix_handle );
+        return status;
+    }
     else if (type == FD_TYPE_SYMLINK)
     {
         status = STATUS_SUCCESS;
diff --git a/dlls/ntdll/unix/socket.c b/dlls/ntdll/unix/socket.c
index 351028d4983e..6abee680ee58 100644
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -676,17 +676,67 @@ static BOOL async_recv_proc( void *user, ULONG_PTR *info, NTSTATUS *status )
 }
 
 static NTSTATUS sock_recv( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user, IO_STATUS_BLOCK *io,
-                           int fd, const void *buffers_ptr, unsigned int count, WSABUF *control,
-                           struct WS_sockaddr *addr, int *addr_len, DWORD *ret_flags, int unix_flags, int force_async )
+                           int fd, struct async_recv_ioctl *async, int force_async )
 {
-    struct async_recv_ioctl *async;
+    BOOL nonblocking, alerted;
     ULONG_PTR information;
     HANDLE wait_handle;
-    DWORD async_size;
     NTSTATUS status;
     unsigned int i;
     ULONG options;
-    BOOL nonblocking, alerted;
+
+    for (i = 0; i < async->count; ++i)
+    {
+        if (!virtual_check_buffer_for_write( async->iov[i].iov_base, async->iov[i].iov_len ))
+        {
+            release_fileio( &async->io );
+            return STATUS_ACCESS_VIOLATION;
+        }
+    }
+
+    SERVER_START_REQ( recv_socket )
+    {
+        req->force_async = force_async;
+        req->async  = server_async( handle, &async->io, event, apc, apc_user, iosb_client_ptr(io) );
+        req->oob    = !!(async->unix_flags & MSG_OOB);
+        status = wine_server_call( req );
+        wait_handle = wine_server_ptr_handle( reply->wait );
+        options     = reply->options;
+        nonblocking = reply->nonblocking;
+    }
+    SERVER_END_REQ;
+
+    alerted = status == STATUS_ALERTED;
+    if (alerted)
+    {
+        status = try_recv( fd, async, &information );
+        if (status == STATUS_DEVICE_NOT_READY && (force_async || !nonblocking))
+            status = STATUS_PENDING;
+    }
+
+    if (status != STATUS_PENDING)
+    {
+        if (!NT_ERROR(status) || (wait_handle && !alerted))
+        {
+            io->Status = status;
+            io->Information = information;
+        }
+        release_fileio( &async->io );
+    }
+
+    if (alerted) set_async_direct_result( &wait_handle, status, information, FALSE );
+    if (wait_handle) status = wait_async( wait_handle, options & FILE_SYNCHRONOUS_IO_ALERT );
+    return status;
+}
+
+
+static NTSTATUS sock_ioctl_recv( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user, IO_STATUS_BLOCK *io,
+                                 int fd, const void *buffers_ptr, unsigned int count, WSABUF *control,
+                                 struct WS_sockaddr *addr, int *addr_len, DWORD *ret_flags, int unix_flags, int force_async )
+{
+    struct async_recv_ioctl *async;
+    DWORD async_size;
+    unsigned int i;
 
     if (unix_flags & MSG_OOB)
     {
@@ -728,48 +778,29 @@ static NTSTATUS sock_recv( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, voi
     async->addr_len = addr_len;
     async->ret_flags = ret_flags;
 
-    for (i = 0; i < count; ++i)
-    {
-        if (!virtual_check_buffer_for_write( async->iov[i].iov_base, async->iov[i].iov_len ))
-        {
-            release_fileio( &async->io );
-            return STATUS_ACCESS_VIOLATION;
-        }
-    }
+    return sock_recv( handle, event, apc, apc_user, io, fd, async, force_async );
+}
 
-    SERVER_START_REQ( recv_socket )
-    {
-        req->force_async = force_async;
-        req->async  = server_async( handle, &async->io, event, apc, apc_user, iosb_client_ptr(io) );
-        req->oob    = !!(unix_flags & MSG_OOB);
-        status = wine_server_call( req );
-        wait_handle = wine_server_ptr_handle( reply->wait );
-        options     = reply->options;
-        nonblocking = reply->nonblocking;
-    }
-    SERVER_END_REQ;
 
-    alerted = status == STATUS_ALERTED;
-    if (alerted)
-    {
-        status = try_recv( fd, async, &information );
-        if (status == STATUS_DEVICE_NOT_READY && (force_async || !nonblocking))
-            status = STATUS_PENDING;
-    }
+NTSTATUS sock_read( HANDLE handle, int fd, HANDLE event, PIO_APC_ROUTINE apc,
+                    void *apc_user, IO_STATUS_BLOCK *io, void *buffer, ULONG length )
+{
+    static const DWORD async_size = offsetof( struct async_recv_ioctl, iov[1] );
+    struct async_recv_ioctl *async;
 
-    if (status != STATUS_PENDING)
-    {
-        if (!NT_ERROR(status) || (wait_handle && !alerted))
-        {
-            io->Status = status;
-            io->Information = information;
-        }
-        release_fileio( &async->io );
-    }
+    if (!(async = (struct async_recv_ioctl *)alloc_fileio( async_size, async_recv_proc, handle )))
+        return STATUS_NO_MEMORY;
 
-    if (alerted) set_async_direct_result( &wait_handle, status, information, FALSE );
-    if (wait_handle) status = wait_async( wait_handle, options & FILE_SYNCHRONOUS_IO_ALERT );
-    return status;
+    async->count = 1;
+    async->iov[0].iov_base = buffer;
+    async->iov[0].iov_len = length;
+    async->unix_flags = 0;
+    async->control = NULL;
+    async->addr = NULL;
+    async->addr_len = NULL;
+    async->ret_flags = NULL;
+
+    return sock_recv( handle, event, apc, apc_user, io, fd, async, 1 );
 }
 
 
@@ -1334,8 +1365,8 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
                 unix_flags |= MSG_PEEK;
             if (params.msg_flags & AFD_MSG_WAITALL)
                 FIXME( "MSG_WAITALL is not supported\n" );
-            status = sock_recv( handle, event, apc, apc_user, io, fd, params.buffers, params.count, NULL,
-                                NULL, NULL, NULL, unix_flags, !!(params.recv_flags & AFD_RECV_FORCE_ASYNC) );
+            status = sock_ioctl_recv( handle, event, apc, apc_user, io, fd, params.buffers, params.count, NULL,
+                                      NULL, NULL, NULL, unix_flags, !!(params.recv_flags & AFD_RECV_FORCE_ASYNC) );
             if (needs_close) close( fd );
             return status;
         }
@@ -1361,10 +1392,10 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
                 unix_flags |= MSG_PEEK;
             if (*ws_flags & WS_MSG_WAITALL)
                 FIXME( "MSG_WAITALL is not supported\n" );
-            status = sock_recv( handle, event, apc, apc_user, io, fd, u64_to_user_ptr(params->buffers_ptr),
-                                params->count, u64_to_user_ptr(params->control_ptr),
-                                u64_to_user_ptr(params->addr_ptr), u64_to_user_ptr(params->addr_len_ptr),
-                                ws_flags, unix_flags, params->force_async );
+            status = sock_ioctl_recv( handle, event, apc, apc_user, io, fd, u64_to_user_ptr(params->buffers_ptr),
+                                      params->count, u64_to_user_ptr(params->control_ptr),
+                                      u64_to_user_ptr(params->addr_ptr), u64_to_user_ptr(params->addr_len_ptr),
+                                      ws_flags, unix_flags, params->force_async );
             if (needs_close) close( fd );
             return status;
         }
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 39b667ddd4a9..8d305bdada62 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -256,6 +256,8 @@ extern NTSTATUS serial_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROU
 extern NTSTATUS serial_FlushBuffersFile( int fd ) DECLSPEC_HIDDEN;
 extern NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user, IO_STATUS_BLOCK *io,
                             ULONG code, void *in_buffer, ULONG in_size, void *out_buffer, ULONG out_size ) DECLSPEC_HIDDEN;
+extern NTSTATUS sock_read( HANDLE handle, int fd, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                           IO_STATUS_BLOCK *io, void *buffer, ULONG length ) DECLSPEC_HIDDEN;
 extern NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
                                       IO_STATUS_BLOCK *io, ULONG code, void *in_buffer,
                                       ULONG in_size, void *out_buffer, ULONG out_size ) DECLSPEC_HIDDEN;
-- 
2.37.1

From cb8937801d42417c2b98cba15366ccc154c1cc40 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Sun, 29 May 2022 16:51:00 -0500
Subject: [PATCH] ntdll: Use the send_socket request for NtWriteFile() on a
 socket.

send_socket does some extra bookkeeping that's currently missing from the
register_async path. Instead of adding it to sock_queue_async(), let's just
centralize all send requests so that they go through send_socket.
---
 dlls/ntdll/unix/file.c         |  10 ++-
 dlls/ntdll/unix/socket.c       | 111 +++++++++++++++++++++------------
 dlls/ntdll/unix/unix_private.h |   2 +
 3 files changed, 81 insertions(+), 42 deletions(-)

diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index f57532f55bf..738367dbb57 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -4768,7 +4768,7 @@ static BOOL async_write_proc( void *user, ULONG_PTR *info, NTSTATUS *status )
                                           &needs_close, &type, NULL )))
             break;
 
-        if (!fileio->count && (type == FD_TYPE_MAILSLOT || type == FD_TYPE_SOCKET))
+        if (!fileio->count && type == FD_TYPE_MAILSLOT)
             result = send( fd, fileio->buffer, 0, 0 );
         else
             result = write( fd, &fileio->buffer[fileio->already], fileio->count - fileio->already );
@@ -5498,11 +5498,17 @@ NTSTATUS WINAPI NtWriteFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, v
             goto done;
         }
     }
+    else if (type == FD_TYPE_SOCKET)
+    {
+        status = sock_write( handle, unix_handle, event, apc, apc_user, io, buffer, length );
+        if (needs_close) close( unix_handle );
+        return status;
+    }
 
     for (;;)
     {
         /* zero-length writes on sockets may not work with plain write(2) */
-        if (!length && (type == FD_TYPE_MAILSLOT || type == FD_TYPE_SOCKET))
+        if (!length && type == FD_TYPE_MAILSLOT)
             result = send( unix_handle, buffer, 0, 0 );
         else
             result = write( unix_handle, (const char *)buffer + total, length - total );
diff --git a/dlls/ntdll/unix/socket.c b/dlls/ntdll/unix/socket.c
index 6abee680ee5..ef3c8494c3d 100644
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -895,49 +895,13 @@ static BOOL async_send_proc( void *user, ULONG_PTR *info, NTSTATUS *status )
 }
 
 static NTSTATUS sock_send( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
-                           IO_STATUS_BLOCK *io, int fd, const void *buffers_ptr, unsigned int count,
-                           const struct WS_sockaddr *addr, unsigned int addr_len, int unix_flags, int force_async )
+                           IO_STATUS_BLOCK *io, int fd, struct async_send_ioctl *async, int force_async )
 {
-    struct async_send_ioctl *async;
+    BOOL nonblocking, alerted;
     ULONG_PTR information;
     HANDLE wait_handle;
-    DWORD async_size;
     NTSTATUS status;
-    unsigned int i;
     ULONG options;
-    BOOL nonblocking, alerted;
-
-    async_size = offsetof( struct async_send_ioctl, iov[count] );
-
-    if (!(async = (struct async_send_ioctl *)alloc_fileio( async_size, async_send_proc, handle )))
-        return STATUS_NO_MEMORY;
-
-    async->count = count;
-    if (in_wow64_call())
-    {
-        const struct afd_wsabuf_32 *buffers = buffers_ptr;
-
-        for (i = 0; i < count; ++i)
-        {
-            async->iov[i].iov_base = ULongToPtr( buffers[i].buf );
-            async->iov[i].iov_len = buffers[i].len;
-        }
-    }
-    else
-    {
-        const WSABUF *buffers = buffers_ptr;
-
-        for (i = 0; i < count; ++i)
-        {
-            async->iov[i].iov_base = buffers[i].buf;
-            async->iov[i].iov_len = buffers[i].len;
-        }
-    }
-    async->unix_flags = unix_flags;
-    async->addr = addr;
-    async->addr_len = addr_len;
-    async->iov_cursor = 0;
-    async->sent_len = 0;
 
     SERVER_START_REQ( send_socket )
     {
@@ -982,6 +946,72 @@ static NTSTATUS sock_send( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, voi
     return status;
 }
 
+static NTSTATUS sock_ioctl_send( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                                 IO_STATUS_BLOCK *io, int fd, const void *buffers_ptr, unsigned int count,
+                                 const struct WS_sockaddr *addr, unsigned int addr_len, int unix_flags, int force_async )
+{
+    struct async_send_ioctl *async;
+    DWORD async_size;
+    unsigned int i;
+
+    async_size = offsetof( struct async_send_ioctl, iov[count] );
+
+    if (!(async = (struct async_send_ioctl *)alloc_fileio( async_size, async_send_proc, handle )))
+        return STATUS_NO_MEMORY;
+
+    async->count = count;
+    if (in_wow64_call())
+    {
+        const struct afd_wsabuf_32 *buffers = buffers_ptr;
+
+        for (i = 0; i < count; ++i)
+        {
+            async->iov[i].iov_base = ULongToPtr( buffers[i].buf );
+            async->iov[i].iov_len = buffers[i].len;
+        }
+    }
+    else
+    {
+        const WSABUF *buffers = buffers_ptr;
+
+        for (i = 0; i < count; ++i)
+        {
+            async->iov[i].iov_base = buffers[i].buf;
+            async->iov[i].iov_len = buffers[i].len;
+        }
+    }
+    async->unix_flags = unix_flags;
+    async->addr = addr;
+    async->addr_len = addr_len;
+    async->iov_cursor = 0;
+    async->sent_len = 0;
+
+    return sock_send( handle, event, apc, apc_user, io, fd, async, force_async );
+}
+
+
+NTSTATUS sock_write( HANDLE handle, int fd, HANDLE event, PIO_APC_ROUTINE apc,
+                     void *apc_user, IO_STATUS_BLOCK *io, const void *buffer, ULONG length )
+{
+    static const DWORD async_size = offsetof( struct async_send_ioctl, iov[1] );
+    struct async_send_ioctl *async;
+
+    if (!(async = (struct async_send_ioctl *)alloc_fileio( async_size, async_recv_proc, handle )))
+        return STATUS_NO_MEMORY;
+
+    async->count = 1;
+    async->iov[0].iov_base = (void *)buffer;
+    async->iov[0].iov_len = length;
+    async->unix_flags = 0;
+    async->addr = NULL;
+    async->addr_len = 0;
+    async->iov_cursor = 0;
+    async->sent_len = 0;
+
+    return sock_send( handle, event, apc, apc_user, io, fd, async, 1 );
+}
+
+
 static ssize_t do_send( int fd, const void *buffer, size_t len, int flags )
 {
     ssize_t ret;
@@ -1420,8 +1450,9 @@ NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc
                 WARN( "ignoring MSG_PARTIAL\n" );
             if (params->ws_flags & ~(WS_MSG_OOB | WS_MSG_PARTIAL))
                 FIXME( "unknown flags %#x\n", params->ws_flags );
-            status = sock_send( handle, event, apc, apc_user, io, fd, u64_to_user_ptr( params->buffers_ptr ), params->count,
-                                u64_to_user_ptr( params->addr_ptr ), params->addr_len, unix_flags, params->force_async );
+            status = sock_ioctl_send( handle, event, apc, apc_user, io, fd, u64_to_user_ptr( params->buffers_ptr ),
+                                      params->count, u64_to_user_ptr( params->addr_ptr ), params->addr_len,
+                                      unix_flags, params->force_async );
             if (needs_close) close( fd );
             return status;
         }
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 8d305bdada6..47f0f9c56a9 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -258,6 +258,8 @@ extern NTSTATUS sock_ioctl( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, vo
                             ULONG code, void *in_buffer, ULONG in_size, void *out_buffer, ULONG out_size ) DECLSPEC_HIDDEN;
 extern NTSTATUS sock_read( HANDLE handle, int fd, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
                            IO_STATUS_BLOCK *io, void *buffer, ULONG length ) DECLSPEC_HIDDEN;
+extern NTSTATUS sock_write( HANDLE handle, int fd, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
+                            IO_STATUS_BLOCK *io, const void *buffer, ULONG length ) DECLSPEC_HIDDEN;
 extern NTSTATUS tape_DeviceIoControl( HANDLE device, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
                                       IO_STATUS_BLOCK *io, ULONG code, void *in_buffer,
                                       ULONG in_size, void *out_buffer, ULONG out_size ) DECLSPEC_HIDDEN;
-- 
2.37.1

From 1e35966eb57db7060d0c459bc7aaac2f6cad7442 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 4 Jul 2022 21:15:38 -0500
Subject: [PATCH] ntdll: Support SOCK_RAW / IPPROTO_ICMP fallback over
 SOCK_DGRAM.

Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
---
 dlls/ntdll/unix/socket.c | 109 ++++++++++++++++++++++++++++++++++++++-
 server/sock.c            |  17 ++++++
 2 files changed, 125 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/socket.c b/dlls/ntdll/unix/socket.c
index ef3c8494c3df..53b4ac9dc485 100644
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -115,6 +115,7 @@ struct async_recv_ioctl
     DWORD *ret_flags;
     int unix_flags;
     unsigned int count;
+    BOOL icmp_over_dgram;
     struct iovec iov[1];
 };
 
@@ -566,6 +567,89 @@ static int wow64_translate_control( const WSABUF *control64, struct afd_wsabuf_3
     return 1;
 }
 
+struct ip_hdr
+{
+    BYTE v_hl; /* version << 4 | hdr_len */
+    BYTE tos;
+    UINT16 tot_len;
+    UINT16 id;
+    UINT16 frag_off;
+    BYTE ttl;
+    BYTE protocol;
+    UINT16 checksum;
+    ULONG saddr;
+    ULONG daddr;
+};
+
+static ssize_t fixup_icmp_over_dgram( struct msghdr *hdr, union unix_sockaddr *unix_addr,
+                                      ssize_t recv_len, NTSTATUS *status )
+{
+    unsigned int tot_len = sizeof(struct ip_hdr) + recv_len;
+    struct cmsghdr *cmsg;
+    struct ip_hdr ip_h;
+    size_t buf_len;
+    char *buf;
+
+    if (hdr->msg_iovlen != 1)
+    {
+        FIXME( "Buffer count %zu is not supported for ICMP fixup.\n", (size_t)hdr->msg_iovlen );
+        return recv_len;
+    }
+
+    buf = hdr->msg_iov[0].iov_base;
+    buf_len = hdr->msg_iov[0].iov_len;
+
+    if (recv_len + sizeof(ip_h) > buf_len)
+        *status = STATUS_BUFFER_OVERFLOW;
+
+    if (buf_len < sizeof(ip_h))
+    {
+        recv_len = buf_len;
+    }
+    else
+    {
+        recv_len = min( recv_len, buf_len - sizeof(ip_h) );
+        memmove( buf + sizeof(ip_h), buf, recv_len );
+        recv_len += sizeof(ip_h);
+    }
+    memset( &ip_h, 0, sizeof(ip_h) );
+    ip_h.v_hl = (4 << 4) | (sizeof(ip_h) >> 2);
+    ip_h.tot_len = htons( tot_len );
+    ip_h.protocol = 1;
+    ip_h.saddr = unix_addr->in.sin_addr.s_addr;
+
+    for (cmsg = CMSG_FIRSTHDR( hdr ); cmsg; cmsg = CMSG_NXTHDR( hdr, cmsg ))
+    {
+        if (cmsg->cmsg_level != IPPROTO_IP) continue;
+        switch (cmsg->cmsg_type)
+        {
+#if defined(IP_TTL)
+            case IP_TTL:
+                ip_h.ttl = *(BYTE *)CMSG_DATA( cmsg );
+                break;
+#endif
+#if defined(IP_TOS)
+            case IP_TOS:
+                ip_h.tos = *(BYTE *)CMSG_DATA( cmsg );
+                break;
+#endif
+#if defined(IP_PKTINFO)
+            case IP_PKTINFO:
+            {
+                struct in_pktinfo *info;
+
+                info = (struct in_pktinfo *)CMSG_DATA( cmsg );
+                ip_h.daddr = info->ipi_addr.s_addr;
+                break;
+            }
+#endif
+        }
+    }
+    memcpy( buf, &ip_h, min( sizeof(ip_h), buf_len ));
+
+    return recv_len;
+}
+
 static NTSTATUS try_recv( int fd, struct async_recv_ioctl *async, ULONG_PTR *size )
 {
 #ifndef HAVE_STRUCT_MSGHDR_MSG_ACCRIGHTS
@@ -577,7 +661,7 @@ static NTSTATUS try_recv( int fd, struct async_recv_ioctl *async, ULONG_PTR *siz
     ssize_t ret;
 
     memset( &hdr, 0, sizeof(hdr) );
-    if (async->addr)
+    if (async->addr || async->icmp_over_dgram)
     {
         hdr.msg_name = &unix_addr.addr;
         hdr.msg_namelen = sizeof(unix_addr);
@@ -602,9 +686,14 @@ static NTSTATUS try_recv( int fd, struct async_recv_ioctl *async, ULONG_PTR *siz
     }
 
     status = (hdr.msg_flags & MSG_TRUNC) ? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;
+    if (async->icmp_over_dgram)
+        ret = fixup_icmp_over_dgram( &hdr, &unix_addr, ret, &status );
 
     if (async->control)
     {
+        if (async->icmp_over_dgram)
+            FIXME( "May return extra control headers.\n" );
+
         if (in_wow64_call())
         {
             char control_buffer64[512];
@@ -675,6 +764,23 @@ static BOOL async_recv_proc( void *user, ULONG_PTR *info, NTSTATUS *status )
     return TRUE;
 }
 
+static BOOL is_icmp_over_dgram( int fd )
+{
+#ifdef linux
+    socklen_t len;
+    int val;
+
+    len = sizeof(val);
+    if (getsockopt( fd, SOL_SOCKET, SO_PROTOCOL, (char *)&val, &len ) || val != IPPROTO_ICMP)
+        return FALSE;
+
+    len = sizeof(val);
+    return !getsockopt( fd, SOL_SOCKET, SO_TYPE, (char *)&val, &len ) && val == SOCK_DGRAM;
+#else
+    return FALSE;
+#endif
+}
+
 static NTSTATUS sock_recv( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user, IO_STATUS_BLOCK *io,
                            int fd, struct async_recv_ioctl *async, int force_async )
 {
@@ -777,6 +883,7 @@ static NTSTATUS sock_ioctl_recv( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
     async->addr = addr;
     async->addr_len = addr_len;
     async->ret_flags = ret_flags;
+    async->icmp_over_dgram = is_icmp_over_dgram( fd );
 
     return sock_recv( handle, event, apc, apc_user, io, fd, async, force_async );
 }
diff --git a/server/sock.c b/server/sock.c
index fed8e3b3093d..dbb6d231a463 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -1618,6 +1618,23 @@ static int init_socket( struct sock *sock, int family, int type, int protocol )
     }
 
     sockfd = socket( unix_family, unix_type, unix_protocol );
+
+#ifdef linux
+    if (sockfd == -1 && errno == EPERM && unix_family == AF_INET
+        && unix_type == SOCK_RAW && unix_protocol == IPPROTO_ICMP)
+    {
+        sockfd = socket( unix_family, SOCK_DGRAM, unix_protocol );
+        if (sockfd != -1)
+        {
+            const int val = 1;
+
+            setsockopt( sockfd, IPPROTO_IP, IP_RECVTTL, (const char *)&val, sizeof(val) );
+            setsockopt( sockfd, IPPROTO_IP, IP_RECVTOS, (const char *)&val, sizeof(val) );
+            setsockopt( sockfd, IPPROTO_IP, IP_PKTINFO, (const char *)&val, sizeof(val) );
+        }
+    }
+#endif
+
     if (sockfd == -1)
     {
         if (errno == EINVAL) set_win32_error( WSAESOCKTNOSUPPORT );

From 0f337f3d8e165764214c08239cf92aa65e4f5a57 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 5 Jul 2022 14:07:29 -0500
Subject: [PATCH] ntdll: Fixup ICMP packet id if SOCK_DGRAM fallback is used.

Signed-off-by: Paul Gofman <pgofman@codeweavers.com>
---
 dlls/ntdll/unix/socket.c       | 98 +++++++++++++++++++++++++++++++++-
 dlls/ws2_32/tests/sock.c       |  2 +-
 include/wine/server_protocol.h | 39 +++++++++++++-
 server/protocol.def            | 18 +++++++
 server/request.h               | 14 +++++
 server/sock.c                  | 54 +++++++++++++++++++
 server/trace.c                 | 24 +++++++++
 7 files changed, 245 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/socket.c b/dlls/ntdll/unix/socket.c
index 53b4ac9dc485..e938eb9b6278 100644
--- a/dlls/ntdll/unix/socket.c
+++ b/dlls/ntdll/unix/socket.c
@@ -581,10 +581,55 @@ struct ip_hdr
     ULONG daddr;
 };
 
+struct icmp_hdr
+{
+    BYTE type;
+    BYTE code;
+    UINT16 checksum;
+    union
+    {
+        struct
+        {
+            UINT16 id;
+            UINT16 sequence;
+        } echo;
+    } un;
+};
+
+/* rfc 1071 checksum */
+static unsigned short chksum(BYTE *data, unsigned int count)
+{
+    unsigned int sum = 0, carry = 0;
+    unsigned short check, s;
+
+    while (count > 1)
+    {
+        s = *(unsigned short *)data;
+        data += 2;
+        sum += carry;
+        sum += s;
+        carry = s > sum;
+        count -= 2;
+    }
+    sum += carry; /* This won't produce another carry */
+    sum = (sum & 0xffff) + (sum >> 16);
+
+    if (count) sum += *data; /* LE-only */
+
+    sum = (sum & 0xffff) + (sum >> 16);
+    /* fold in any carry */
+    sum = (sum & 0xffff) + (sum >> 16);
+
+    check = ~sum;
+    return check;
+}
+
 static ssize_t fixup_icmp_over_dgram( struct msghdr *hdr, union unix_sockaddr *unix_addr,
-                                      ssize_t recv_len, NTSTATUS *status )
+                                      HANDLE handle, ssize_t recv_len, NTSTATUS *status )
 {
     unsigned int tot_len = sizeof(struct ip_hdr) + recv_len;
+    struct icmp_hdr *icmp_h = NULL;
+    NTSTATUS fixup_status;
     struct cmsghdr *cmsg;
     struct ip_hdr ip_h;
     size_t buf_len;
@@ -610,6 +655,8 @@ static ssize_t fixup_icmp_over_dgram( struct msghdr *hdr, union unix_sockaddr *u
     {
         recv_len = min( recv_len, buf_len - sizeof(ip_h) );
         memmove( buf + sizeof(ip_h), buf, recv_len );
+        if (recv_len >= sizeof(struct icmp_hdr))
+            icmp_h = (struct icmp_hdr *)(buf + sizeof(ip_h));
         recv_len += sizeof(ip_h);
     }
     memset( &ip_h, 0, sizeof(ip_h) );
@@ -645,6 +692,25 @@ static ssize_t fixup_icmp_over_dgram( struct msghdr *hdr, union unix_sockaddr *u
 #endif
         }
     }
+    if (icmp_h)
+    {
+        SERVER_START_REQ( socket_get_icmp_id )
+        {
+            req->handle = wine_server_obj_handle( handle );
+            req->icmp_seq = icmp_h->un.echo.sequence;
+            if (!(fixup_status = wine_server_call( req )))
+                icmp_h->un.echo.id = reply->icmp_id;
+            else
+                WARN( "socket_get_fixup_data returned %#x.\n", fixup_status );
+        }
+        SERVER_END_REQ;
+
+        if (!fixup_status)
+        {
+            icmp_h->checksum = 0;
+            icmp_h->checksum = chksum( (BYTE *)icmp_h, recv_len - sizeof(ip_h) );
+        }
+    }
     memcpy( buf, &ip_h, min( sizeof(ip_h), buf_len ));
 
     return recv_len;
@@ -687,7 +753,7 @@ static NTSTATUS try_recv( int fd, struct async_recv_ioctl *async, ULONG_PTR *siz
 
     status = (hdr.msg_flags & MSG_TRUNC) ? STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;
     if (async->icmp_over_dgram)
-        ret = fixup_icmp_over_dgram( &hdr, &unix_addr, ret, &status );
+        ret = fixup_icmp_over_dgram( &hdr, &unix_addr, async->io.handle, ret, &status );
 
     if (async->control)
     {
@@ -1001,6 +1067,31 @@ static BOOL async_send_proc( void *user, ULONG_PTR *info, NTSTATUS *status )
     return TRUE;
 }
 
+static void sock_save_icmp_id( struct async_send_ioctl *async )
+{
+    unsigned short id, seq;
+    struct icmp_hdr *h;
+
+    if (async->count != 1 || async->iov[0].iov_len < sizeof(*h))
+    {
+        FIXME( "ICMP over DGRAM fixup is not supported for count %u, len %zu.\n", async->count, async->iov[0].iov_len );
+        return;
+    }
+
+    h = async->iov[0].iov_base;
+    id = h->un.echo.id;
+    seq = h->un.echo.sequence;
+    SERVER_START_REQ( socket_send_icmp_id )
+    {
+        req->handle = wine_server_obj_handle( async->io.handle );
+        req->icmp_id = id;
+        req->icmp_seq = seq;
+        if (wine_server_call( req ))
+            WARN( "socket_fixup_send_data failed.\n" );
+    }
+    SERVER_END_REQ;
+}
+
 static NTSTATUS sock_send( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, void *apc_user,
                            IO_STATUS_BLOCK *io, int fd, struct async_send_ioctl *async, int force_async )
 {
@@ -1021,6 +1112,9 @@ static NTSTATUS sock_send( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, voi
     }
     SERVER_END_REQ;
 
+    if (!NT_ERROR(status) && is_icmp_over_dgram( fd ))
+        sock_save_icmp_id( async );
+
     alerted = status == STATUS_ALERTED;
     if (alerted)
     {
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index 0f39333919ba..c80b2790b956 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -1797,6 +1797,37 @@ struct send_socket_reply
 
 
 
+struct socket_send_icmp_id_request
+{
+    struct request_header __header;
+    obj_handle_t   handle;
+    unsigned short icmp_id;
+    unsigned short icmp_seq;
+    char __pad_20[4];
+};
+struct socket_send_icmp_id_reply
+{
+    struct reply_header __header;
+};
+
+
+
+struct socket_get_icmp_id_request
+{
+    struct request_header __header;
+    obj_handle_t   handle;
+    unsigned short icmp_seq;
+    char __pad_18[6];
+};
+struct socket_get_icmp_id_reply
+{
+    struct reply_header __header;
+    unsigned short icmp_id;
+    char __pad_10[6];
+};
+
+
+
 struct get_next_console_request_request
 {
     struct request_header __header;
@@ -5516,6 +5547,8 @@ enum request
     REQ_unlock_file,
     REQ_recv_socket,
     REQ_send_socket,
+    REQ_socket_send_icmp_id,
+    REQ_socket_get_icmp_id,
     REQ_get_next_console_request,
     REQ_read_directory_changes,
     REQ_read_change,
@@ -5799,6 +5832,8 @@ union generic_request
     struct unlock_file_request unlock_file_request;
     struct recv_socket_request recv_socket_request;
     struct send_socket_request send_socket_request;
+    struct socket_send_icmp_id_request socket_send_icmp_id_request;
+    struct socket_get_icmp_id_request socket_get_icmp_id_request;
     struct get_next_console_request_request get_next_console_request_request;
     struct read_directory_changes_request read_directory_changes_request;
     struct read_change_request read_change_request;
@@ -6080,6 +6115,8 @@ union generic_reply
     struct unlock_file_reply unlock_file_reply;
     struct recv_socket_reply recv_socket_reply;
     struct send_socket_reply send_socket_reply;
+    struct socket_send_icmp_id_reply socket_send_icmp_id_reply;
+    struct socket_get_icmp_id_reply socket_get_icmp_id_reply;
     struct get_next_console_request_reply get_next_console_request_reply;
     struct read_directory_changes_reply read_directory_changes_reply;
     struct read_change_reply read_change_reply;
diff --git a/server/protocol.def b/server/protocol.def
index 6cb6275f2f28..a8044582ef83 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1470,6 +1470,24 @@ enum server_fd_type
 @END
 
 
+/* Store ICMP id for ICMP over datagram fixup */
+@REQ(socket_send_icmp_id)
+    obj_handle_t   handle;        /* socket handle */
+    unsigned short icmp_id;       /* ICMP packet id */
+    unsigned short icmp_seq;      /* ICMP packed sequence */
+@REPLY
+@END
+
+
+/* Get ICMP id for ICMP over datagram fixup */
+@REQ(socket_get_icmp_id)
+    obj_handle_t   handle;        /* socket handle */
+    unsigned short icmp_seq;      /* ICMP packed sequence */
+@REPLY
+    unsigned short icmp_id;       /* ICMP packet id */
+@END
+
+
 /* Retrieve the next pending console ioctl request */
 @REQ(get_next_console_request)
     obj_handle_t handle;        /* console server handle */
diff --git a/server/request.h b/server/request.h
index dc9c4e820291..236c2e25abb7 100644
--- a/server/request.h
+++ b/server/request.h
@@ -175,6 +175,8 @@ DECL_HANDLER(lock_file);
 DECL_HANDLER(unlock_file);
 DECL_HANDLER(recv_socket);
 DECL_HANDLER(send_socket);
+DECL_HANDLER(socket_send_icmp_id);
+DECL_HANDLER(socket_get_icmp_id);
 DECL_HANDLER(get_next_console_request);
 DECL_HANDLER(read_directory_changes);
 DECL_HANDLER(read_change);
@@ -457,6 +459,8 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_unlock_file,
     (req_handler)req_recv_socket,
     (req_handler)req_send_socket,
+    (req_handler)req_socket_send_icmp_id,
+    (req_handler)req_socket_get_icmp_id,
     (req_handler)req_get_next_console_request,
     (req_handler)req_read_directory_changes,
     (req_handler)req_read_change,
@@ -1059,6 +1063,16 @@ C_ASSERT( FIELD_OFFSET(struct send_socket_reply, wait) == 8 );
 C_ASSERT( FIELD_OFFSET(struct send_socket_reply, options) == 12 );
 C_ASSERT( FIELD_OFFSET(struct send_socket_reply, nonblocking) == 16 );
 C_ASSERT( sizeof(struct send_socket_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct socket_send_icmp_id_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct socket_send_icmp_id_request, icmp_id) == 16 );
+C_ASSERT( FIELD_OFFSET(struct socket_send_icmp_id_request, icmp_seq) == 18 );
+C_ASSERT( sizeof(struct socket_send_icmp_id_request) == 24 );
+C_ASSERT( sizeof(struct socket_send_icmp_id_reply) == 8 );
+C_ASSERT( FIELD_OFFSET(struct socket_get_icmp_id_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct socket_get_icmp_id_request, icmp_seq) == 16 );
+C_ASSERT( sizeof(struct socket_get_icmp_id_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct socket_get_icmp_id_reply, icmp_id) == 8 );
+C_ASSERT( sizeof(struct socket_get_icmp_id_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_next_console_request_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct get_next_console_request_request, signal) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_next_console_request_request, read) == 20 );
diff --git a/server/sock.c b/server/sock.c
index dbb6d231a463..2bf560456125 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -168,6 +168,8 @@ enum connection_state
     SOCK_CONNECTIONLESS,
 };
 
+#define MAX_ICMP_HISTORY_LENGTH 8
+
 struct sock
 {
     struct object       obj;         /* object header */
@@ -215,6 +217,13 @@ struct sock
     unsigned int        sndbuf;      /* advisory send buffer size */
     unsigned int        rcvtimeo;    /* receive timeout in ms */
     unsigned int        sndtimeo;    /* send timeout in ms */
+    struct
+    {
+        unsigned short icmp_id;
+        unsigned short icmp_seq;
+    }
+    icmp_fixup_data[MAX_ICMP_HISTORY_LENGTH]; /* Sent ICMP packets history used to fixup reply id. */
+    unsigned int        icmp_fixup_data_len;  /* Sent ICMP packets history length. */
     unsigned int        rd_shutdown : 1; /* is the read end shut down? */
     unsigned int        wr_shutdown : 1; /* is the write end shut down? */
     unsigned int        wr_shutdown_pending : 1; /* is a write shutdown pending? */
@@ -1502,6 +1511,7 @@ static struct sock *create_socket(void)
     sock->sndbuf = 0;
     sock->rcvtimeo = 0;
     sock->sndtimeo = 0;
+    sock->icmp_fixup_data_len = 0;
     init_async_queue( &sock->read_q );
     init_async_queue( &sock->write_q );
     init_async_queue( &sock->ifchange_q );
@@ -3589,3 +3599,47 @@ DECL_HANDLER(send_socket)
     }
     release_object( sock );
 }
+
+DECL_HANDLER(socket_send_icmp_id)
+{
+    struct sock *sock = (struct sock *)get_handle_obj( current->process, req->handle, 0, &sock_ops );
+
+    if (!sock) return;
+
+    if (sock->icmp_fixup_data_len == MAX_ICMP_HISTORY_LENGTH)
+    {
+        memmove( sock->icmp_fixup_data, sock->icmp_fixup_data + 1,
+                 sizeof(*sock->icmp_fixup_data) * (MAX_ICMP_HISTORY_LENGTH - 1) );
+        --sock->icmp_fixup_data_len;
+    }
+
+    sock->icmp_fixup_data[sock->icmp_fixup_data_len].icmp_id = req->icmp_id;
+    sock->icmp_fixup_data[sock->icmp_fixup_data_len].icmp_seq = req->icmp_seq;
+    ++sock->icmp_fixup_data_len;
+
+    release_object( sock );
+}
+
+DECL_HANDLER(socket_get_icmp_id)
+{
+    struct sock *sock = (struct sock *)get_handle_obj( current->process, req->handle, 0, &sock_ops );
+    unsigned int i;
+
+    if (!sock) return;
+
+    for (i = 0; i < sock->icmp_fixup_data_len; ++i)
+    {
+        if (sock->icmp_fixup_data[i].icmp_seq == req->icmp_seq)
+        {
+            reply->icmp_id = sock->icmp_fixup_data[i].icmp_id;
+            --sock->icmp_fixup_data_len;
+            memmove( &sock->icmp_fixup_data[i], &sock->icmp_fixup_data[i + 1],
+                     (sock->icmp_fixup_data_len - i) * sizeof(*sock->icmp_fixup_data) );
+            release_object( sock );
+            return;
+        }
+    }
+
+    set_error( STATUS_NOT_FOUND );
+    release_object( sock );
+}
diff --git a/server/trace.c b/server/trace.c
index c3dd1199f06d..4eb07fefc03d 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -2055,6 +2055,24 @@ static void dump_send_socket_reply( const struct send_socket_reply *req )
     fprintf( stderr, ", nonblocking=%d", req->nonblocking );
 }
 
+static void dump_socket_send_icmp_id_request( const struct socket_send_icmp_id_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", icmp_id=%04x", req->icmp_id );
+    fprintf( stderr, ", icmp_seq=%04x", req->icmp_seq );
+}
+
+static void dump_socket_get_icmp_id_request( const struct socket_get_icmp_id_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", icmp_seq=%04x", req->icmp_seq );
+}
+
+static void dump_socket_get_icmp_id_reply( const struct socket_get_icmp_id_reply *req )
+{
+    fprintf( stderr, " icmp_id=%04x", req->icmp_id );
+}
+
 static void dump_get_next_console_request_request( const struct get_next_console_request_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -4548,6 +4566,8 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_unlock_file_request,
     (dump_func)dump_recv_socket_request,
     (dump_func)dump_send_socket_request,
+    (dump_func)dump_socket_send_icmp_id_request,
+    (dump_func)dump_socket_get_icmp_id_request,
     (dump_func)dump_get_next_console_request_request,
     (dump_func)dump_read_directory_changes_request,
     (dump_func)dump_read_change_request,
@@ -4827,6 +4847,8 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     NULL,
     (dump_func)dump_recv_socket_reply,
     (dump_func)dump_send_socket_reply,
+    NULL,
+    (dump_func)dump_socket_get_icmp_id_reply,
     (dump_func)dump_get_next_console_request_reply,
     NULL,
     (dump_func)dump_read_change_reply,
@@ -5106,6 +5128,8 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "unlock_file",
     "recv_socket",
     "send_socket",
+    "socket_send_icmp_id",
+    "socket_get_icmp_id",
     "get_next_console_request",
     "read_directory_changes",
     "read_change",

From 7343d439af984688bddc7eaf025d147ef3396ce5 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 15 Jul 2022 18:42:40 -0500
Subject: [PATCH 1/4] ws2_32: Map AFD_POLL_RESET to the "read" set in select().

---
 dlls/ws2_32/socket.c | 17 ++++++++++-------
 1 file changed, 10 insertions(+), 7 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index d3c93e15a47..b0f90cccbe3 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -2709,6 +2709,10 @@ static int add_fd_to_set( SOCKET fd, struct fd_set *set )
 int WINAPI select( int count, fd_set *read_ptr, fd_set *write_ptr,
                    fd_set *except_ptr, const struct timeval *timeout)
 {
+    static const int read_flags = AFD_POLL_READ | AFD_POLL_ACCEPT | AFD_POLL_HUP | AFD_POLL_RESET;
+    static const int write_flags = AFD_POLL_WRITE;
+    static const int except_flags = AFD_POLL_OOB | AFD_POLL_CONNECT_ERR;
+
     struct fd_set *read_input = NULL;
     struct afd_poll_params *params;
     unsigned int poll_count = 0;
@@ -2760,7 +2764,7 @@ int WINAPI select( int count, fd_set *read_ptr, fd_set *write_ptr,
         for (i = 0; i < read_ptr->fd_count; ++i)
         {
             params->sockets[params->count].socket = read_ptr->fd_array[i];
-            params->sockets[params->count].flags = AFD_POLL_READ | AFD_POLL_ACCEPT | AFD_POLL_HUP;
+            params->sockets[params->count].flags = read_flags;
             ++params->count;
             poll_socket = read_ptr->fd_array[i];
         }
@@ -2771,7 +2775,7 @@ int WINAPI select( int count, fd_set *read_ptr, fd_set *write_ptr,
         for (i = 0; i < write_ptr->fd_count; ++i)
         {
             params->sockets[params->count].socket = write_ptr->fd_array[i];
-            params->sockets[params->count].flags = AFD_POLL_WRITE;
+            params->sockets[params->count].flags = write_flags;
             ++params->count;
             poll_socket = write_ptr->fd_array[i];
         }
@@ -2782,7 +2786,7 @@ int WINAPI select( int count, fd_set *read_ptr, fd_set *write_ptr,
         for (i = 0; i < except_ptr->fd_count; ++i)
         {
             params->sockets[params->count].socket = except_ptr->fd_array[i];
-            params->sockets[params->count].flags = AFD_POLL_OOB | AFD_POLL_CONNECT_ERR;
+            params->sockets[params->count].flags = except_flags;
             ++params->count;
             poll_socket = except_ptr->fd_array[i];
         }
@@ -2819,8 +2823,7 @@ int WINAPI select( int count, fd_set *read_ptr, fd_set *write_ptr,
             {
                 for (j = 0; j < read_input->fd_count; ++j)
                 {
-                    if (read_input->fd_array[j] == s
-                            && (flags & (AFD_POLL_READ | AFD_POLL_ACCEPT | AFD_POLL_HUP | AFD_POLL_CLOSE)))
+                    if (read_input->fd_array[j] == s && (flags & (read_flags | AFD_POLL_CLOSE)))
                     {
                         ret_count += add_fd_to_set( s, read_ptr );
                         flags &= ~AFD_POLL_CLOSE;
@@ -2831,10 +2834,10 @@ int WINAPI select( int count, fd_set *read_ptr, fd_set *write_ptr,
             if (flags & AFD_POLL_CLOSE)
                 status = STATUS_INVALID_HANDLE;
 
-            if (flags & AFD_POLL_WRITE)
+            if (flags & write_flags)
                 ret_count += add_fd_to_set( s, write_ptr );
 
-            if (flags & (AFD_POLL_OOB | AFD_POLL_CONNECT_ERR))
+            if (flags & except_flags)
                 ret_count += add_fd_to_set( s, except_ptr );
         }
     }
-- 
GitLab


From c81209895e0bb53f9513a061ecd5cd0c8190ab83 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 15 Jul 2022 18:43:03 -0500
Subject: [PATCH 2/4] ws2_32: Add a FIXME for unhandled flags in select().

---
 dlls/ws2_32/socket.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index b0f90cccbe3..493ea3299a9 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -2839,6 +2839,9 @@ int WINAPI select( int count, fd_set *read_ptr, fd_set *write_ptr,
 
             if (flags & except_flags)
                 ret_count += add_fd_to_set( s, except_ptr );
+
+            if (flags & ~(read_flags | write_flags | except_flags | AFD_POLL_CLOSE))
+                FIXME( "not reporting AFD flags %#x\n", flags );
         }
     }
 
-- 
GitLab


From 67e5399d0ae52041e42a6a517292d311e46525ca Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 15 Jul 2022 20:07:20 -0500
Subject: [PATCH 3/4] ws2_32: Map AFD_POLL_RESET to both POLLHUP and POLLERR.

---
 dlls/ws2_32/socket.c     | 2 +-

 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 493ea3299a9..9d51fef1adb 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -2974,7 +2974,7 @@ int WINAPI WSAPoll( WSAPOLLFD *fds, ULONG count, int timeout )
                         revents |= POLLRDBAND;
                     if (params->sockets[j].flags & AFD_POLL_WRITE)
                         revents |= POLLWRNORM;
-                    if (params->sockets[j].flags & AFD_POLL_HUP)
+                    if (params->sockets[j].flags & (AFD_POLL_RESET | AFD_POLL_HUP))
                         revents |= POLLHUP;
                     if (params->sockets[j].flags & (AFD_POLL_RESET | AFD_POLL_CONNECT_ERR))
                         revents |= POLLERR;
-- 
GitLab


From 1e01aa8e1ed3a9b692a620aca665d2ef4a410067 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 15 Jul 2022 18:44:06 -0500
Subject: [PATCH 4/4] server: Properly implement AFD_POLL_RESET.

---
 server/sock.c            | 34 +++++++++++++++++++++++++++++++---
 3 files changed, 40 insertions(+), 13 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 53553ab8ee7..7d7e470be28 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -232,6 +232,7 @@ struct sock
     unsigned int        aborted : 1; /* did we get a POLLERR or irregular POLLHUP? */
     unsigned int        nonblocking : 1; /* is the socket nonblocking? */
     unsigned int        bound : 1;   /* is the socket bound? */
+    unsigned int        reset : 1;   /* did we get a TCP reset? */
 };
 
 static void sock_dump( struct object *obj, int verbose );
@@ -667,7 +668,12 @@ static inline int sock_error( struct sock *sock )
 
     case SOCK_CONNECTED:
     case SOCK_CONNECTIONLESS:
-        if (error)
+        if (error == ECONNRESET || error == EPIPE)
+        {
+            sock->reset = 1;
+            error = 0;
+        }
+        else if (error)
             sock->errors[AFD_POLL_BIT_HUP] = error;
         else
             error = sock->errors[AFD_POLL_BIT_HUP];
@@ -897,6 +903,8 @@ static int get_poll_flags( struct sock *sock, int event )
         flags |= AFD_POLL_HUP;
     if (event & POLLERR)
         flags |= AFD_POLL_CONNECT_ERR;
+    if (sock->reset)
+        flags |= AFD_POLL_RESET;
 
     return flags;
 }
@@ -1081,6 +1089,15 @@ static int sock_dispatch_asyncs( struct sock *sock, int event, int error )
             async_terminate( sock->connect_req->async, status );
     }
 
+    if (sock->reset)
+    {
+        async_wake_up( &sock->read_q, STATUS_CONNECTION_RESET );
+        async_wake_up( &sock->write_q, STATUS_CONNECTION_RESET );
+
+        if (sock->accept_recv_req && sock->accept_recv_req->iosb->status == STATUS_PENDING)
+            async_terminate( sock->accept_recv_req->async, STATUS_CONNECTION_RESET );
+    }
+
     return event;
 }
 
@@ -1116,6 +1133,9 @@ static void sock_dispatch_events( struct sock *sock, enum connection_state prevs
 
     case SOCK_CONNECTED:
     case SOCK_CONNECTIONLESS:
+        if (sock->reset)
+            post_socket_event( sock, AFD_POLL_BIT_RESET );
+
         if (event & POLLIN)
             post_socket_event( sock, AFD_POLL_BIT_READ );
 
@@ -1171,6 +1191,9 @@ static void sock_poll_event( struct fd *fd, int event )
 
     case SOCK_CONNECTED:
     case SOCK_CONNECTIONLESS:
+        if (sock->reset)
+            event &= ~(POLLIN | POLLERR | POLLHUP);
+
         if (sock->type == WS_SOCK_STREAM && (event & POLLIN))
         {
             char dummy;
@@ -1189,7 +1212,11 @@ static void sock_poll_event( struct fd *fd, int event )
                 event &= ~POLLIN;
                 /* EAGAIN can happen if an async recv() falls between the server's poll()
                    call and the invocation of this routine */
-                if ( errno != EAGAIN )
+                if (errno == ECONNRESET || errno == EPIPE)
+                {
+                    sock->reset = 1;
+                }
+                else if (errno != EAGAIN)
                 {
                     error = errno;
                     event |= POLLERR;
@@ -1312,7 +1339,7 @@ static int sock_get_poll_events( struct fd *fd )
             return -1;
         }
 
-        if (sock->aborted)
+        if (sock->aborted || sock->reset)
             return -1;
 
         if (sock->accept_recv_req)
@@ -1517,6 +1544,7 @@ static struct sock *create_socket(void)
     sock->aborted = 0;
     sock->nonblocking = 0;
     sock->bound = 0;
+    sock->reset = 0;
     sock->rcvbuf = 0;
     sock->sndbuf = 0;
     sock->rcvtimeo = 0;
-- 
GitLab

From d191513167e69e0147130bfdca1d155d66d32ddf Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Fri, 22 Jul 2022 02:31:13 +0900
Subject: [PATCH] server: Allow cancelling alerted asyncs.

---
 server/async.c | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/server/async.c b/server/async.c
index 4832d69b7bf..8b9afe3b5a0 100644
--- a/server/async.c
+++ b/server/async.c
@@ -44,6 +44,7 @@ struct async
     struct fd           *fd;              /* fd associated with an unqueued async */
     struct timeout_user *timeout;
     unsigned int         timeout_status;  /* status to report upon timeout */
+    unsigned int         terminate_status;/* pending termination status, or STATUS_PENDING */
     struct event        *event;
     async_data_t         data;            /* data for async I/O call */
     struct iosb         *iosb;            /* I/O status block */
@@ -165,6 +166,11 @@ void async_terminate( struct async *async, unsigned int status )
 {
     struct iosb *iosb = async->iosb;
 
+    if (status != STATUS_ALERTED && async->terminate_status == STATUS_PENDING)
+    {
+        async->terminate_status = status;
+    }
+
     if (async->terminated) return;
 
     async->terminated = 1;
@@ -268,6 +274,7 @@ struct async *create_async( struct fd *fd, struct thread *thread, const async_da
     async->queue         = NULL;
     async->fd            = (struct fd *)grab_object( fd );
     async->initial_status = STATUS_PENDING;
+    async->terminate_status = STATUS_PENDING;
     async->signaled      = 0;
     async->pending       = 1;
     async->wait_handle   = 0;
@@ -497,7 +504,15 @@ void async_set_result( struct object *obj, unsigned int status, apc_param_t tota
     {
         async->terminated = 0;
         async->alerted = 0;
-        async_reselect( async );
+
+        if (async->terminate_status != STATUS_PENDING)
+        {
+            async_terminate( async, async->terminate_status );
+        }
+        else
+        {
+            async_reselect( async );
+        }
     }
     else
     {
-- 
GitLab

From 78f1dd89676b72b217e69e131602aa4b1897e4ae Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Tue, 9 Aug 2022 22:21:02 +0900
Subject: [PATCH 1/3] server: Use POLLIN instead of POLLPRI if the socket is in
 oobinline mode.

---
 server/sock.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/sock.c b/server/sock.c
index 7d7e470be28..caa3724eb59 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -3470,7 +3470,7 @@ DECL_HANDLER(recv_socket)
          */
         struct pollfd pollfd;
         pollfd.fd = get_unix_fd( sock->fd );
-        pollfd.events = req->oob ? POLLPRI : POLLIN;
+        pollfd.events = req->oob && !is_oobinline( sock ) ? POLLPRI : POLLIN;
         pollfd.revents = 0;
         if (poll(&pollfd, 1, 0) >= 0 && pollfd.revents)
         {
-- 
GitLab


From 13fb500cbbbeae06503d1d1598030ead0cf49a9b Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Tue, 9 Aug 2022 22:24:44 +0900
Subject: [PATCH 2/3] server: Use check_fd_events() instead of calling poll()
 directly.

---
 server/sock.c | 12 ++----------
 1 file changed, 2 insertions(+), 10 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index caa3724eb59..7b5bb187aa0 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -3468,11 +3468,7 @@ DECL_HANDLER(recv_socket)
          * asyncs will not consume all available data; if there's no data
          * available, the current request won't be immediately satiable.
          */
-        struct pollfd pollfd;
-        pollfd.fd = get_unix_fd( sock->fd );
-        pollfd.events = req->oob && !is_oobinline( sock ) ? POLLPRI : POLLIN;
-        pollfd.revents = 0;
-        if (poll(&pollfd, 1, 0) >= 0 && pollfd.revents)
+        if (check_fd_events( sock->fd, req->oob && !is_oobinline( sock ) ? POLLPRI : POLLIN ))
         {
             /* Give the client opportunity to complete synchronously.
              * If it turns out that the I/O request is not actually immediately satiable,
@@ -3568,11 +3564,7 @@ DECL_HANDLER(send_socket)
          * asyncs will not consume all available space; if there's no space
          * available, the current request won't be immediately satiable.
          */
-        struct pollfd pollfd;
-        pollfd.fd = get_unix_fd( sock->fd );
-        pollfd.events = POLLOUT;
-        pollfd.revents = 0;
-        if (poll(&pollfd, 1, 0) >= 0 && pollfd.revents)
+        if (check_fd_events( sock->fd, POLLOUT ))
         {
             /* Give the client opportunity to complete synchronously.
              * If it turns out that the I/O request is not actually immediately satiable,
-- 
GitLab


From a115feab9ca8af9689a4ee13cd88ee6e93f902bd Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Tue, 9 Aug 2022 23:07:56 +0900
Subject: [PATCH 3/3] server: Always prefer synchronous I/O in nonblocking
 mode.

foobar2000.exe's UPnP Media Renderer component (foo_out_upnp.dll)
expects that, if a select() call completes successfully with a non-empty
writefds set, any immediately following send() call on a socket in the
writefds set never fails with WSAEWOULDBLOCK.

On Wine, the Winsock select() and send() implementations both call the
Unix poll(2) under the hood to test if I/O is possible on the socket.
As it turns out, it's entirely possible that Linux poll() may yield
POLLOUT on the first call (by select) but *not* the second (by send),
even if no send() call has been made in the meanwhile.

On Linux (as of v5.19), a connected (ESTABLISHED) TCP socket that has
not been shut down indicates (E)POLLOUT only if the ratio of
sk_wmem_queued (the amount of bytes queued in the send buffer) to
sk_sndbuf (the size of send buffer size itself, which can be retrieved
via SO_SNDBUF) is below a certain threshold.  Therefore, a falling edge
in POLLOUT can be triggered due to a number of reasons:

1. TCP fragmentation.  Once a TCP packet is split out from a larger
   sk_buff, it incurs extra bookkeeping overhead (e.g. sk_buff header)
   that is counted in sk_wmem_queued alongside application data.
   See also: tcp_fragment(), tso_fragment() (Linux 5.19).

2. Control packets (e.g. MTU probing).  Such packets share the same
   buffer with application-initiated packets, and thus counted in
   sk_wmem_queued.
   See also: sk_wmem_queued_add() callers (Linux 5.19).

3. Memory pressure.  This causes sk_sndbuf to shrink.
   See also: sk_stream_moderate_sndbuf() callers (Linux 5.19).

Fix this by always attempting synchronous I/O first if req->force_async
is unset and the nonblocking flag is set.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=53486
---
 server/sock.c | 32 ++++++++++++++++++++++++++++----
 1 file changed, 28 insertions(+), 4 deletions(-)

diff --git a/server/sock.c b/server/sock.c
index 7b5bb187aa0..4e57d6774a6 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -3468,11 +3468,19 @@ DECL_HANDLER(recv_socket)
          * asyncs will not consume all available data; if there's no data
          * available, the current request won't be immediately satiable.
          */
-        if (check_fd_events( sock->fd, req->oob && !is_oobinline( sock ) ? POLLPRI : POLLIN ))
+        if ((!req->force_async && sock->nonblocking) ||
+            check_fd_events( sock->fd, req->oob && !is_oobinline( sock ) ? POLLPRI : POLLIN ))
         {
             /* Give the client opportunity to complete synchronously.
              * If it turns out that the I/O request is not actually immediately satiable,
-             * the client may then choose to re-queue the async (with STATUS_PENDING). */
+             * the client may then choose to re-queue the async (with STATUS_PENDING).
+             *
+             * Note: If the nonblocking flag is set, we don't poll the socket
+             * here and always opt for synchronous completion first.  This is
+             * because the application has probably seen POLLIN already from a
+             * preceding select()/poll() call before it requested to receive
+             * data.
+             */
             status = STATUS_ALERTED;
         }
     }
@@ -3564,11 +3572,27 @@ DECL_HANDLER(send_socket)
          * asyncs will not consume all available space; if there's no space
          * available, the current request won't be immediately satiable.
          */
-        if (check_fd_events( sock->fd, POLLOUT ))
+        if ((!req->force_async && sock->nonblocking) || check_fd_events( sock->fd, POLLOUT ))
         {
             /* Give the client opportunity to complete synchronously.
              * If it turns out that the I/O request is not actually immediately satiable,
-             * the client may then choose to re-queue the async (with STATUS_PENDING). */
+             * the client may then choose to re-queue the async (with STATUS_PENDING).
+             *
+             * Note: If the nonblocking flag is set, we don't poll the socket
+             * here and always opt for synchronous completion first.  This is
+             * because the application has probably seen POLLOUT already from a
+             * preceding select()/poll() call before it requested to send data.
+             *
+             * Furthermore, some applications expect that any send() call on a
+             * socket that has indicated POLLOUT beforehand never fails with
+             * WSAEWOULDBLOCK.  It's possible that Linux poll() may yield
+             * POLLOUT on the first call but not the second, even if no send()
+             * call has been made in the meanwhile.  This can happen for a
+             * number of reasons; for example, TCP fragmentation may consume
+             * extra buffer space for each packet that has been split out, or
+             * the TCP/IP networking stack may decide to shrink the send buffer
+             * due to memory pressure.
+             */
             status = STATUS_ALERTED;
         }
     }
-- 
GitLab
