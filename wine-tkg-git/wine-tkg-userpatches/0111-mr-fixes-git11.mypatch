From 051066e494dd2e97bff01a29b57376e6306e02db Mon Sep 17 00:00:00 2001
From: dreamer <dreamer@puikheid.nl>
Date: Fri, 30 Dec 2022 14:45:39 +0100
Subject: [PATCH 1/2] increase number of midi ports to 64

---
 include/mmddk.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/include/mmddk.h b/include/mmddk.h
index d4217f2ebef..02115754f1a 100644
--- a/include/mmddk.h
+++ b/include/mmddk.h
@@ -30,13 +30,13 @@
 extern "C" {
 #endif
 
-#define MAX_MIDIINDRV 	(16)
+#define MAX_MIDIINDRV 	(64)
 /* For now I'm making 16 the maximum number of midi devices one can
  * have. This should be more than enough for everybody. But as a purist,
  * I intend to make it unbounded in the future, as soon as I figure
  * a good way to do so.
  */
-#define MAX_MIDIOUTDRV 	(16)
+#define MAX_MIDIOUTDRV 	(64)
 
 /* ==================================
  *   Multimedia DDK compatible part
-- 
GitLab


From 208de7a04a6d5d78c6b29ca6ae06d3ce44b22943 Mon Sep 17 00:00:00 2001
From: dreamer <dreamer@puikheid.nl>
Date: Fri, 30 Dec 2022 15:20:49 +0100
Subject: [PATCH 2/2] update comment

---
 include/mmddk.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/include/mmddk.h b/include/mmddk.h
index 02115754f1a..e237683a164 100644
--- a/include/mmddk.h
+++ b/include/mmddk.h
@@ -31,7 +31,7 @@ extern "C" {
 #endif
 
 #define MAX_MIDIINDRV 	(64)
-/* For now I'm making 16 the maximum number of midi devices one can
+/* For now I'm making 64 the maximum number of midi devices one can
  * have. This should be more than enough for everybody. But as a purist,
  * I intend to make it unbounded in the future, as soon as I figure
  * a good way to do so.
-- 
GitLab

From 7459e9d37dff05a3ed6e0345fa9eff6284191b8b Mon Sep 17 00:00:00 2001
From: Sidney Kelley <memory.thrasher@gmail.com>
Date: Sat, 24 Dec 2022 20:39:40 -0700
Subject: [PATCH] Implements basic rpcrt4.dll.RpcServerUseAllProtseqsIf

A very simple function. Normally rpc servers are handed endpoints one at a time, but the app has the option of associating one or more endpoints and protocol pairs to a given interface object, and then asking the rpc server to use them all. This replaces a stub that had caused the entire wineserver to crash (abort).
---
 AUTHORS                  |  1 +
 dlls/rpcrt4/rpc_server.c | 14 ++++++++++++++
 dlls/rpcrt4/rpcrt4.spec  |  2 +-
 include/rpcdce.h         |  2 ++
 4 files changed, 18 insertions(+), 1 deletion(-)

diff --git a/AUTHORS b/AUTHORS
index 6639a165a5f..20871c3070e 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -1584,6 +1584,7 @@ Shi Quan He
 Shuai Meng
 Shunichi Fuji
 Shu Yokoyama
+Sidney Kelley
 Simen Zamecnik
 Simeon Pilgrim
 Simon Britnell
diff --git a/dlls/rpcrt4/rpc_server.c b/dlls/rpcrt4/rpc_server.c
index 41431ebca02..a86afc2f602 100644
--- a/dlls/rpcrt4/rpc_server.c
+++ b/dlls/rpcrt4/rpc_server.c
@@ -908,6 +908,20 @@ RPC_STATUS WINAPI RpcServerInqBindings( RPC_BINDING_VECTOR** BindingVector )
   return status;
 }
 
+RPC_STATUS WINAPI RpcServerUseAllProtseqsIf( unsigned int MaxCalls, RPC_IF_HANDLE IfSpec, void *SecurityDescriptor )
+{
+  PRPC_SERVER_INTERFACE iface = (PRPC_SERVER_INTERFACE)IfSpec;
+  /*don't really care if this is a client or server interface because the part of the ABI we care about is the same*/
+  TRACE("Binding RPC to %u endpoints\n", iface->RpcProtseqEndpointCount);
+  for(unsigned int i = 0;i < iface->RpcProtseqEndpointCount;i++) {
+    RPC_STATUS result = RpcServerUseProtseqEpA(iface->RpcProtseqEndpoint[i].RpcProtocolSequence, MaxCalls, iface->RpcProtseqEndpoint[i].Endpoint, SecurityDescriptor);
+    TRACE("Bound to RPC to proto: %s; endpoint: %s; with result: %ld\n", iface->RpcProtseqEndpoint[i].RpcProtocolSequence, iface->RpcProtseqEndpoint[i].Endpoint, result);
+    if(result != RPC_S_OK)
+      return result;
+  }
+  return RPC_S_OK;
+}
+
 /***********************************************************************
  *             RpcServerUseProtseqEpA (RPCRT4.@)
  */
diff --git a/dlls/rpcrt4/rpcrt4.spec b/dlls/rpcrt4/rpcrt4.spec
index 21476714ae2..676164626f6 100644
--- a/dlls/rpcrt4/rpcrt4.spec
+++ b/dlls/rpcrt4/rpcrt4.spec
@@ -445,7 +445,7 @@
 @ stdcall RpcServerUnregisterIfEx(ptr ptr long)
 @ stub RpcServerUseAllProtseqs
 @ stub RpcServerUseAllProtseqsEx
-@ stub RpcServerUseAllProtseqsIf
+@ stdcall RpcServerUseAllProtseqsIf(long ptr ptr)
 @ stub RpcServerUseAllProtseqsIfEx
 @ stdcall RpcServerUseProtseqA(str long ptr)
 @ stdcall RpcServerUseProtseqEpA(str  long str  ptr)
diff --git a/include/rpcdce.h b/include/rpcdce.h
index 79418f8084c..a97cc0d18b0 100644
--- a/include/rpcdce.h
+++ b/include/rpcdce.h
@@ -469,6 +469,8 @@ RPCRTAPI RPC_STATUS RPC_ENTRY
 RPCRTAPI RPC_STATUS RPC_ENTRY
   RpcServerUnregisterIfEx( RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, int RundownContextHandles );
 
+RPCRTAPI RPC_STATUS RPC_ENTRY
+  RpcServerUseAllProtseqsIf( unsigned int MaxCalls, RPC_IF_HANDLE IfSpec, void *SecurityDescriptor );
 
 RPCRTAPI RPC_STATUS RPC_ENTRY
   RpcServerUseProtseqA(RPC_CSTR Protseq, unsigned int MaxCalls, void *SecurityDescriptor);
-- 
GitLab

From d72061c10d38626e9febc93ecd9d89f8ba48610a Mon Sep 17 00:00:00 2001
From: Hugh McMaster <hugh.mcmaster@outlook.com>
Date: Fri, 23 Dec 2022 22:09:49 +1100
Subject: [PATCH] conhost: Migrate from FontPitchFamily to FontFamily

To ensure a seamless transition between value names, we try loading the
registry value from FontFamily first and FontPitchFamily second.

Any changes to the console font family are saved to the new value name.
---
 programs/conhost/window.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/programs/conhost/window.c b/programs/conhost/window.c
index 3db4b159696..0a44186beb1 100644
--- a/programs/conhost/window.c
+++ b/programs/conhost/window.c
     RegQueryValueExW( key, L"FaceName", 0, &type, (BYTE *)&config->face_name, &count );
 
     count = sizeof(val);
-    if (!RegQueryValueExW( key, L"FontPitchFamily", 0, &type, (BYTE *)&val, &count ))
+    if (!RegQueryValueExW( key, L"FontFamily", 0, &type, (BYTE *)&val, &count ) ||
+        !RegQueryValueExW( key, L"FontPitchFamily", 0, &type, (BYTE *)&val, &count ))
         config->font_pitch_family = val;
 
     count = sizeof(val);
@@ -307,7 +308,7 @@ static void save_registry_key( HKEY key,
                     (lstrlenW(config->face_name) + 1) * sizeof(WCHAR) );
 
     val = config->font_pitch_family;
-    RegSetValueExW( key, L"FontPitchFamily", 0, REG_DWORD, (BYTE *)&val, sizeof(val) );
+    RegSetValueExW( key, L"FontFamily", 0, REG_DWORD, (BYTE *)&val, sizeof(val) );
 
     width  = MulDiv( config->cell_width,  USER_DEFAULT_SCREEN_DPI, GetDpiForSystem() );
     height = MulDiv( config->cell_height, USER_DEFAULT_SCREEN_DPI, GetDpiForSystem() );
-- 
GitLab

From dbe6244f103aaef9f0c32b8008a2e1748b686e73 Mon Sep 17 00:00:00 2001
From: Piotr Caban <piotr@codeweavers.com>
Date: Thu, 5 Jan 2023 19:21:35 +0100
Subject: [PATCH 1/2] msvcirt: Don't fail in streambuf_xsputn on 0xff
 character.

---
 dlls/msvcirt/msvcirt.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/msvcirt/msvcirt.c b/dlls/msvcirt/msvcirt.c
index 35f532425d3..9ad0f45cbed 100644
--- a/dlls/msvcirt/msvcirt.c
+++ b/dlls/msvcirt/msvcirt.c
@@ -820,7 +820,7 @@ int __thiscall streambuf_xsputn(streambuf *this, const char *data, int length)
 
     while (copied < length) {
         if (this->unbuffered || this->pptr == this->epptr) {
-            if (call_streambuf_overflow(this, data[copied]) == EOF)
+            if (call_streambuf_overflow(this, (unsigned char)data[copied]) == EOF)
                 break;
             copied++;
         } else {
-- 
GitLab


From 8028ef5be8afb786e9905d3b0668770aa29b18b8 Mon Sep 17 00:00:00 2001
From: Piotr Caban <piotr@codeweavers.com>
Date: Thu, 5 Jan 2023 19:22:17 +0100
Subject: [PATCH 2/2] msvcirt: Fix ostream_print_char on 0 character.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=54180
---
 dlls/msvcirt/msvcirt.c | 23 +++++++++++++----------
 1 file changed, 13 insertions(+), 10 deletions(-)

diff --git a/dlls/msvcirt/msvcirt.c b/dlls/msvcirt/msvcirt.c
index 9ad0f45cbed..8d83fca7c94 100644
--- a/dlls/msvcirt/msvcirt.c
+++ b/dlls/msvcirt/msvcirt.c
@@ -2670,15 +2670,12 @@ ostream* __thiscall ostream_write(ostream *this, const char *str, int count)
     return this;
 }
 
-/* ?writepad@ostream@@AAEAAV1@PBD0@Z */
-/* ?writepad@ostream@@AEAAAEAV1@PEBD0@Z */
-DEFINE_THISCALL_WRAPPER(ostream_writepad, 12)
-ostream* __thiscall ostream_writepad(ostream *this, const char *str1, const char *str2)
+static ostream* ostream_writepad_len(ostream *this, const char *str1, const char *str2, int len2)
 {
     ios *base = ostream_get_ios(this);
-    int len1 = strlen(str1), len2 = strlen(str2), i;
+    int len1 = strlen(str1), i;
 
-    TRACE("(%p %p %p)\n", this, str1, str2);
+    TRACE("(%p %p %p %d)\n", this, str1, str2, len2);
 
     /* left of the padding */
     if (base->flags & (FLAGS_left|FLAGS_internal)) {
@@ -2703,6 +2700,14 @@ ostream* __thiscall ostream_writepad(ostream *this, const char *str1, const char
     return this;
 }
 
+/* ?writepad@ostream@@AAEAAV1@PBD0@Z */
+/* ?writepad@ostream@@AEAAAEAV1@PEBD0@Z */
+DEFINE_THISCALL_WRAPPER(ostream_writepad, 12)
+ostream* __thiscall ostream_writepad(ostream *this, const char *str1, const char *str2)
+{
+    return ostream_writepad_len(this, str1, str2, strlen(str2));
+}
+
 static ostream* ostream_internal_print_integer(ostream *ostr, int n, BOOL unsig, BOOL shrt)
 {
     ios *base = ostream_get_ios(ostr);
@@ -2792,12 +2797,10 @@ static ostream* ostream_internal_print_float(ostream *ostr, double d, BOOL dbl)
 DEFINE_THISCALL_WRAPPER(ostream_print_char, 8)
 ostream* __thiscall ostream_print_char(ostream *this, char c)
 {
-    const char c_str[2] = {c, 0};
-
-    TRACE("(%p %c)\n", this, c);
+    TRACE("(%p %d)\n", this, c);
 
     if (ostream_opfx(this)) {
-        ostream_writepad(this, "", c_str);
+        ostream_writepad_len(this, "", &c, 1);
         ostream_osfx(this);
     }
     return this;
-- 
GitLab

From ec05c03463368ed0f5309def116c88a4376d8db6 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 11 Jan 2023 14:07:17 +0100
Subject: [PATCH] conhost: Initialize color_map when creating an alternate
 screen buffer.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=54287
Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 programs/conhost/conhost.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/programs/conhost/conhost.c b/programs/conhost/conhost.c
index bf46e6b1c18..800e8bab822 100644
--- a/programs/conhost/conhost.c
+++ b/programs/conhost/conhost.c
@@ -96,6 +96,7 @@ static struct screen_buffer *create_screen_buffer( struct console *console, int
         screen_buffer->attr       = console->active->attr;
         screen_buffer->popup_attr = console->active->attr;
         screen_buffer->font       = console->active->font;
+        memcpy( screen_buffer->color_map, console->active->color_map, sizeof(console->active->color_map) );
 
         if (screen_buffer->font.face_len)
         {
-- 
GitLab

From 8993f5720a453aecb9ead2cd7531f6513340de97 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 11 Jan 2023 10:34:03 +0100
Subject: [PATCH] conhost: Reset console attribute upon exit in unix mode.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 programs/conhost/conhost.c | 16 ++++++++++++++--
 1 file changed, 14 insertions(+), 2 deletions(-)

diff --git a/programs/conhost/conhost.c b/programs/conhost/conhost.c
index 769f998f404..bf46e6b1c18 100644
--- a/programs/conhost/conhost.c
+++ b/programs/conhost/conhost.c
@@ -2859,9 +2859,18 @@ static int main_loop( struct console *console, HANDLE signal )
     return 0;
 }
 
+static void teardown( struct console *console )
+{
+    if (console->is_unix)
+    {
+        set_tty_attr( console, empty_char_info.attr );
+        tty_flush( console );
+    }
+}
+
 int __cdecl wmain(int argc, WCHAR *argv[])
 {
-    int headless = 0, i, width = 0, height = 0;
+    int headless = 0, i, width = 0, height = 0, ret;
     HANDLE signal = NULL;
     WCHAR *end;
 
@@ -2954,5 +2963,8 @@ int __cdecl wmain(int argc, WCHAR *argv[])
         ShowWindow( console.win, (si.dwFlags & STARTF_USESHOWWINDOW) ? si.wShowWindow : SW_SHOW );
     }
 
-    return main_loop( &console, signal );
+    ret = main_loop( &console, signal );
+    teardown( &console );
+
+    return ret;
 }
-- 
GitLab

From 6998d808afe3fa19b28dd6628dceda2a11424783 Mon Sep 17 00:00:00 2001
From: Torge Matthies <tmatthies@codeweavers.com>
Date: Wed, 18 Jan 2023 12:54:51 +0100
Subject: [PATCH 1/5] msvcr100: Implement _StructuredTaskCollection canceling.

Signed-off-by: Torge Matthies <tmatthies@codeweavers.com>
---
 dlls/msvcrt/concurrency.c      | 59 +++++++++++++++++++++++++++++++++-
 2 files changed, 59 insertions(+), 2 deletions(-)

diff --git a/dlls/msvcrt/concurrency.c b/dlls/msvcrt/concurrency.c
index fe156938e3a..bc41d2a3aae 100644
--- a/dlls/msvcrt/concurrency.c
+++ b/dlls/msvcrt/concurrency.c
@@ -1950,6 +1950,58 @@ static ThreadScheduler *get_thread_scheduler_from_context(Context *context)
     return NULL;
 }
 
+static void cancel_task_collection(_StructuredTaskCollection *this)
+{
+    ExternalContextBase* context;
+    ThreadScheduler *scheduler;
+    void *prev_exception, *new_exception;
+    struct scheduled_chore *sc, *next;
+    LONG removed = 0;
+    LONG prev_finished, new_finished;
+
+    context = (ExternalContextBase*)this->context;
+    if (!context)
+        return;
+    scheduler = get_thread_scheduler_from_context(context);
+    if (!scheduler)
+        return;
+
+    new_exception = this->exception;
+    do {
+        prev_exception = new_exception;
+        if ((ULONG_PTR)prev_exception & 0x2)
+            return;
+        new_exception = (void*)((ULONG_PTR)prev_exception | 0x2);
+    } while ((new_exception = InterlockedCompareExchangePointer(
+                    &this->exception, new_exception, prev_exception))
+             != prev_exception);
+
+    EnterCriticalSection(&scheduler->cs);
+    LIST_FOR_EACH_ENTRY_SAFE(sc, next, &scheduler->scheduled_chores,
+                             struct scheduled_chore, entry) {
+        if (sc->chore->task_collection != this)
+            continue;
+        sc->chore->task_collection = NULL;
+        list_remove(&sc->entry);
+        removed++;
+        operator_delete(sc);
+    }
+    LeaveCriticalSection(&scheduler->cs);
+    if (!removed)
+        return;
+
+    new_finished = this->finished;
+    do {
+        prev_finished = new_finished;
+        if (prev_finished == FINISHED_INITIAL)
+            new_finished = removed;
+        else
+            new_finished = prev_finished + removed;
+    } while ((new_finished = InterlockedCompareExchange(&this->finished,
+                    new_finished, prev_finished)) != prev_finished);
+    RtlWakeAddressAll((LONG*)&this->finished);
+}
+
 struct execute_chore_data {
     _UnrealizedChore *chore;
     _StructuredTaskCollection *task_collection;
@@ -1964,6 +2016,8 @@ static LONG CALLBACK execute_chore_except(EXCEPTION_POINTERS *pexc, void *_data)
     if (pexc->ExceptionRecord->ExceptionCode != CXX_EXCEPTION)
         return EXCEPTION_CONTINUE_SEARCH;
 
+    cancel_task_collection(data->task_collection);
+
     ptr = operator_new(sizeof(*ptr));
     __ExceptionPtrCreate(ptr);
     exception_ptr_from_record(ptr, pexc->ExceptionRecord);
@@ -2200,6 +2254,8 @@ static void CALLBACK exception_ptr_rethrow_finally(BOOL normal, void *data)
         }
         __FINALLY_CTX(exception_ptr_rethrow_finally, ep)
     }
+    if (exception & 0x2)
+        return 2;
     return 1;
 }
 
@@ -2210,7 +2266,8 @@ DEFINE_THISCALL_WRAPPER(_StructuredTaskCollection__Cancel, 4)
 void __thiscall _StructuredTaskCollection__Cancel(
         _StructuredTaskCollection *this)
 {
-    FIXME("(%p): stub!\n", this);
+    TRACE("(%p)\n", this);
+    cancel_task_collection(this);
 }
 
 /* ?_IsCanceling@_StructuredTaskCollection@details@Concurrency@@QAA_NXZ */
-- 
GitLab


From 7b65ce321c0657736226f9498f1f8ad028586a7b Mon Sep 17 00:00:00 2001
From: Torge Matthies <tmatthies@codeweavers.com>
Date: Wed, 18 Jan 2023 12:54:51 +0100
Subject: [PATCH 2/5] msvcr100: Implement
 _StructuredTaskCollection::_IsCanceling.

Signed-off-by: Torge Matthies <tmatthies@codeweavers.com>
---
 dlls/msvcrt/concurrency.c      | 4 ++--
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/msvcrt/concurrency.c b/dlls/msvcrt/concurrency.c
index bc41d2a3aae..5ab8db3e2f1 100644
--- a/dlls/msvcrt/concurrency.c
+++ b/dlls/msvcrt/concurrency.c
@@ -2277,8 +2277,8 @@ DEFINE_THISCALL_WRAPPER(_StructuredTaskCollection__IsCanceling, 4)
 bool __thiscall _StructuredTaskCollection__IsCanceling(
         _StructuredTaskCollection *this)
 {
-    FIXME("(%p): stub!\n", this);
-    return FALSE;
+    TRACE("(%p)\n", this);
+    return !!((ULONG_PTR)this->exception & 0x2);
 }
 
 /* ??0critical_section@Concurrency@@QAE@XZ */
-- 
GitLab


From 692839247060be1c4c262c3a1e059e3d7ef3083d Mon Sep 17 00:00:00 2001
From: Torge Matthies <tmatthies@codeweavers.com>
Date: Wed, 18 Jan 2023 12:54:51 +0100
Subject: [PATCH 3/5] msvcr110: Add
 _Cancellation_beacon::_Cancellation_beacon_ctor stub.

The pointer is needed for Crazy Machines 3 to not crash.

Signed-off-by: Torge Matthies <tmatthies@codeweavers.com>
---
 dlls/msvcr110/msvcr110.spec         |  2 +-
 dlls/msvcr120/msvcr120.spec         |  2 +-
 dlls/msvcr120_app/msvcr120_app.spec |  2 +-
 dlls/msvcrt/concurrency.c           | 19 +++++++++++++++++++
 4 files changed, 22 insertions(+), 3 deletions(-)

diff --git a/dlls/msvcr110/msvcr110.spec b/dlls/msvcr110/msvcr110.spec
index 4fc5a069fbb..6a64474fb84 100644
--- a/dlls/msvcr110/msvcr110.spec
+++ b/dlls/msvcr110/msvcr110.spec
@@ -19,7 +19,7 @@
 @ stub -arch=win64 ??0_CancellationTokenState@details@Concurrency@@AEAA@XZ
 @ stub -arch=arm ??0_Cancellation_beacon@details@Concurrency@@QAA@XZ
 @ stub -arch=i386 ??0_Cancellation_beacon@details@Concurrency@@QAE@XZ
-@ stub -arch=win64 ??0_Cancellation_beacon@details@Concurrency@@QEAA@XZ
+@ cdecl -arch=win64 ??0_Cancellation_beacon@details@Concurrency@@QEAA@XZ(ptr) _Cancellation_beacon_ctor
 @ cdecl -arch=arm ??0_Condition_variable@details@Concurrency@@QAA@XZ(ptr) _Condition_variable_ctor
 @ thiscall -arch=i386 ??0_Condition_variable@details@Concurrency@@QAE@XZ(ptr) _Condition_variable_ctor
 @ cdecl -arch=win64 ??0_Condition_variable@details@Concurrency@@QEAA@XZ(ptr) _Condition_variable_ctor
diff --git a/dlls/msvcr120/msvcr120.spec b/dlls/msvcr120/msvcr120.spec
index 7b379830d4b..e88dcb97f06 100644
--- a/dlls/msvcr120/msvcr120.spec
+++ b/dlls/msvcr120/msvcr120.spec
@@ -16,7 +16,7 @@
 @ cdecl -arch=win64 ??0SchedulerPolicy@Concurrency@@QEAA@XZ(ptr) SchedulerPolicy_ctor
 @ stub -arch=arm ??0_Cancellation_beacon@details@Concurrency@@QAA@XZ
 @ stub -arch=i386 ??0_Cancellation_beacon@details@Concurrency@@QAE@XZ
-@ stub -arch=win64 ??0_Cancellation_beacon@details@Concurrency@@QEAA@XZ
+@ cdecl -arch=win64 ??0_Cancellation_beacon@details@Concurrency@@QEAA@XZ(ptr) _Cancellation_beacon_ctor
 @ cdecl -arch=arm ??0_Condition_variable@details@Concurrency@@QAA@XZ(ptr) _Condition_variable_ctor
 @ thiscall -arch=i386 ??0_Condition_variable@details@Concurrency@@QAE@XZ(ptr) _Condition_variable_ctor
 @ cdecl -arch=win64 ??0_Condition_variable@details@Concurrency@@QEAA@XZ(ptr) _Condition_variable_ctor
diff --git a/dlls/msvcr120_app/msvcr120_app.spec b/dlls/msvcr120_app/msvcr120_app.spec
index 37282fc54f8..705e64baf5f 100644
--- a/dlls/msvcr120_app/msvcr120_app.spec
+++ b/dlls/msvcr120_app/msvcr120_app.spec
@@ -14,7 +14,7 @@
 @ cdecl -arch=win64 ??0SchedulerPolicy@Concurrency@@QEAA@XZ(ptr) msvcr120.??0SchedulerPolicy@Concurrency@@QEAA@XZ
 @ stub -arch=arm ??0_Cancellation_beacon@details@Concurrency@@QAA@XZ
 @ stub -arch=i386 ??0_Cancellation_beacon@details@Concurrency@@QAE@XZ
-@ stub -arch=win64 ??0_Cancellation_beacon@details@Concurrency@@QEAA@XZ
+@ cdecl -arch=win64 ??0_Cancellation_beacon@details@Concurrency@@QEAA@XZ(ptr) msvcr120.??0_Cancellation_beacon@details@Concurrency@@QEAA@XZ
 @ cdecl -arch=arm ??0_Condition_variable@details@Concurrency@@QAA@XZ(ptr) msvcr120.??0_Condition_variable@details@Concurrency@@QAA@XZ
 @ thiscall -arch=i386 ??0_Condition_variable@details@Concurrency@@QAE@XZ(ptr) msvcr120.??0_Condition_variable@details@Concurrency@@QAE@XZ
 @ cdecl -arch=win64 ??0_Condition_variable@details@Concurrency@@QEAA@XZ(ptr) msvcr120.??0_Condition_variable@details@Concurrency@@QEAA@XZ
diff --git a/dlls/msvcrt/concurrency.c b/dlls/msvcrt/concurrency.c
index 5ab8db3e2f1..55d7c1cc52c 100644
--- a/dlls/msvcrt/concurrency.c
+++ b/dlls/msvcrt/concurrency.c
@@ -297,6 +297,10 @@ typedef struct cv_queue {
     LONG expired;
 } cv_queue;
 
+typedef struct {
+    void *unknown;
+} _Cancellation_beacon;
+
 typedef struct {
     /* cv_queue structure is not binary compatible */
     cv_queue *queue;
@@ -2841,6 +2845,21 @@ int __cdecl event_wait_for_multiple(event **events, size_t count, bool wait_all,
 
 #if _MSVCR_VER >= 110
 
+struct {
+    void *unk;
+} _Cancellation_beacon_unknown = {
+    0x0
+};
+
+/* ??0_Cancellation_beacon@details@Concurrency@@QEAA@XZ */
+DEFINE_THISCALL_WRAPPER(_Cancellation_beacon_ctor, 4)
+_Cancellation_beacon* __thiscall _Cancellation_beacon_ctor(_Cancellation_beacon *this)
+{
+    FIXME("(%p): stub!\n", this);
+    this->unknown = &_Cancellation_beacon_unknown;
+    return this;
+}
+
 /* ??0_Condition_variable@details@Concurrency@@QAE@XZ */
 /* ??0_Condition_variable@details@Concurrency@@QEAA@XZ */
 DEFINE_THISCALL_WRAPPER(_Condition_variable_ctor, 4)
-- 
GitLab


From 70009dc482f2b1c4b387ef10019d46ee8e02bc7e Mon Sep 17 00:00:00 2001
From: Torge Matthies <tmatthies@codeweavers.com>
Date: Wed, 18 Jan 2023 12:54:51 +0100
Subject: [PATCH 4/5] msvcr110: Add
 _Cancellation_beacon::_Cancellation_beacon_dtor stub.

Signed-off-by: Torge Matthies <tmatthies@codeweavers.com>
---
 dlls/msvcr110/msvcr110.spec         | 2 +-
 dlls/msvcr120/msvcr120.spec         | 2 +-
 dlls/msvcr120_app/msvcr120_app.spec | 2 +-
 dlls/msvcrt/concurrency.c           | 7 +++++++
 4 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/dlls/msvcr110/msvcr110.spec b/dlls/msvcr110/msvcr110.spec
index 6a64474fb84..023c992a5e3 100644
--- a/dlls/msvcr110/msvcr110.spec
+++ b/dlls/msvcr110/msvcr110.spec
@@ -277,7 +277,7 @@
 @ stub -arch=win64 ??1_CancellationTokenState@details@Concurrency@@UEAA@XZ
 @ stub -arch=arm ??1_Cancellation_beacon@details@Concurrency@@QAA@XZ
 @ stub -arch=i386 ??1_Cancellation_beacon@details@Concurrency@@QAE@XZ
-@ stub -arch=win64 ??1_Cancellation_beacon@details@Concurrency@@QEAA@XZ
+@ cdecl -arch=win64 ??1_Cancellation_beacon@details@Concurrency@@QEAA@XZ(ptr) _Cancellation_beacon_dtor
 @ cdecl -arch=arm ??1_Condition_variable@details@Concurrency@@QAA@XZ(ptr) _Condition_variable_dtor
 @ thiscall -arch=i386 ??1_Condition_variable@details@Concurrency@@QAE@XZ(ptr) _Condition_variable_dtor
 @ cdecl -arch=win64 ??1_Condition_variable@details@Concurrency@@QEAA@XZ(ptr) _Condition_variable_dtor
diff --git a/dlls/msvcr120/msvcr120.spec b/dlls/msvcr120/msvcr120.spec
index e88dcb97f06..85c336b1205 100644
--- a/dlls/msvcr120/msvcr120.spec
+++ b/dlls/msvcr120/msvcr120.spec
@@ -271,7 +271,7 @@
 @ cdecl -arch=win64 ??1SchedulerPolicy@Concurrency@@QEAA@XZ(ptr) SchedulerPolicy_dtor
 @ stub -arch=arm ??1_Cancellation_beacon@details@Concurrency@@QAA@XZ
 @ stub -arch=i386 ??1_Cancellation_beacon@details@Concurrency@@QAE@XZ
-@ stub -arch=win64 ??1_Cancellation_beacon@details@Concurrency@@QEAA@XZ
+@ cdecl -arch=win64 ??1_Cancellation_beacon@details@Concurrency@@QEAA@XZ(ptr) _Cancellation_beacon_dtor
 @ cdecl -arch=arm ??1_Condition_variable@details@Concurrency@@QAA@XZ(ptr) _Condition_variable_dtor
 @ thiscall -arch=i386 ??1_Condition_variable@details@Concurrency@@QAE@XZ(ptr) _Condition_variable_dtor
 @ cdecl -arch=win64 ??1_Condition_variable@details@Concurrency@@QEAA@XZ(ptr) _Condition_variable_dtor
diff --git a/dlls/msvcr120_app/msvcr120_app.spec b/dlls/msvcr120_app/msvcr120_app.spec
index 705e64baf5f..0b5b33bb513 100644
--- a/dlls/msvcr120_app/msvcr120_app.spec
+++ b/dlls/msvcr120_app/msvcr120_app.spec
@@ -269,7 +269,7 @@
 @ cdecl -arch=win64 ??1SchedulerPolicy@Concurrency@@QEAA@XZ(ptr) msvcr120.??1SchedulerPolicy@Concurrency@@QEAA@XZ
 @ stub -arch=arm ??1_Cancellation_beacon@details@Concurrency@@QAA@XZ
 @ stub -arch=i386 ??1_Cancellation_beacon@details@Concurrency@@QAE@XZ
-@ stub -arch=win64 ??1_Cancellation_beacon@details@Concurrency@@QEAA@XZ
+@ cdecl -arch=win64 ??1_Cancellation_beacon@details@Concurrency@@QEAA@XZ(ptr) msvcr120.??1_Cancellation_beacon@details@Concurrency@@QEAA@XZ
 @ cdecl -arch=arm ??1_Condition_variable@details@Concurrency@@QAA@XZ(ptr) msvcr120.??1_Condition_variable@details@Concurrency@@QAA@XZ
 @ thiscall -arch=i386 ??1_Condition_variable@details@Concurrency@@QAE@XZ(ptr) msvcr120.??1_Condition_variable@details@Concurrency@@QAE@XZ
 @ cdecl -arch=win64 ??1_Condition_variable@details@Concurrency@@QEAA@XZ(ptr) msvcr120.??1_Condition_variable@details@Concurrency@@QEAA@XZ
diff --git a/dlls/msvcrt/concurrency.c b/dlls/msvcrt/concurrency.c
index 55d7c1cc52c..f7bda445bc1 100644
--- a/dlls/msvcrt/concurrency.c
+++ b/dlls/msvcrt/concurrency.c
@@ -2860,6 +2860,13 @@ _Cancellation_beacon* __thiscall _Cancellation_beacon_ctor(_Cancellation_beacon
     return this;
 }
 
+/* ??1_Cancellation_beacon@details@Concurrency@@QEAA@XZ */
+DEFINE_THISCALL_WRAPPER(_Cancellation_beacon_dtor, 4)
+void __thiscall _Cancellation_beacon_dtor(_Cancellation_beacon *this)
+{
+    FIXME("(%p): stub!\n", this);
+}
+
 /* ??0_Condition_variable@details@Concurrency@@QAE@XZ */
 /* ??0_Condition_variable@details@Concurrency@@QEAA@XZ */
 DEFINE_THISCALL_WRAPPER(_Condition_variable_ctor, 4)
-- 
GitLab


From dd7f03ffbbd4c57b417ca070e5af7c5ac13c063a Mon Sep 17 00:00:00 2001
From: Torge Matthies <tmatthies@codeweavers.com>
Date: Wed, 18 Jan 2023 12:54:51 +0100
Subject: [PATCH 5/5] msvcr110: Add _Context::_IsSynchronouslyBlocked stub.

Signed-off-by: Torge Matthies <tmatthies@codeweavers.com>
---
 dlls/msvcr110/msvcr110.spec         | 6 +++---
 dlls/msvcr120/msvcr120.spec         | 6 +++---
 dlls/msvcr120_app/msvcr120_app.spec | 6 +++---
 dlls/msvcrt/concurrency.c           | 7 +++++++
 4 files changed, 16 insertions(+), 9 deletions(-)

diff --git a/dlls/msvcr110/msvcr110.spec b/dlls/msvcr110/msvcr110.spec
index 023c992a5e3..cf68d652385 100644
--- a/dlls/msvcr110/msvcr110.spec
+++ b/dlls/msvcr110/msvcr110.spec
@@ -550,9 +550,9 @@
 @ stub -arch=arm ?_IsCanceling@_TaskCollection@details@Concurrency@@QAA_NXZ
 @ stub -arch=i386 ?_IsCanceling@_TaskCollection@details@Concurrency@@QAE_NXZ
 @ stub -arch=win64 ?_IsCanceling@_TaskCollection@details@Concurrency@@QEAA_NXZ
-@ stub -arch=arm ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBA_NXZ
-@ stub -arch=i386 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBE_NXZ
-@ stub -arch=win64 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QEBA_NXZ
+@ cdecl -arch=arm ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBA_NXZ(ptr) _Context_IsSynchronouslyBlocked
+@ thiscall -arch=i386 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBE_NXZ(ptr) _Context_IsSynchronouslyBlocked
+@ cdecl -arch=win64 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QEBA_NXZ(ptr) _Context_IsSynchronouslyBlocked
 @ stub -arch=win32 ?_Name_base@type_info@@CAPBDPBV1@PAU__type_info_node@@@Z
 @ stub -arch=win64 ?_Name_base@type_info@@CAPEBDPEBV1@PEAU__type_info_node@@@Z
 @ stub -arch=win32 ?_Name_base_internal@type_info@@CAPBDPBV1@PAU__type_info_node@@@Z
diff --git a/dlls/msvcr120/msvcr120.spec b/dlls/msvcr120/msvcr120.spec
index 85c336b1205..580fb26756c 100644
--- a/dlls/msvcr120/msvcr120.spec
+++ b/dlls/msvcr120/msvcr120.spec
@@ -541,9 +541,9 @@
 @ stub -arch=arm ?_IsCanceling@_TaskCollection@details@Concurrency@@QAA_NXZ
 @ stub -arch=i386 ?_IsCanceling@_TaskCollection@details@Concurrency@@QAE_NXZ
 @ stub -arch=win64 ?_IsCanceling@_TaskCollection@details@Concurrency@@QEAA_NXZ
-@ stub -arch=arm ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBA_NXZ
-@ stub -arch=i386 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBE_NXZ
-@ stub -arch=win64 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QEBA_NXZ
+@ cdecl -arch=arm ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBA_NXZ(ptr) _Context_IsSynchronouslyBlocked
+@ thiscall -arch=i386 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBE_NXZ(ptr) _Context_IsSynchronouslyBlocked
+@ cdecl -arch=win64 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QEBA_NXZ(ptr) _Context_IsSynchronouslyBlocked
 @ stub -arch=win32 ?_Name_base@type_info@@CAPBDPBV1@PAU__type_info_node@@@Z
 @ stub -arch=win64 ?_Name_base@type_info@@CAPEBDPEBV1@PEAU__type_info_node@@@Z
 @ stub -arch=win32 ?_Name_base_internal@type_info@@CAPBDPBV1@PAU__type_info_node@@@Z
diff --git a/dlls/msvcr120_app/msvcr120_app.spec b/dlls/msvcr120_app/msvcr120_app.spec
index 0b5b33bb513..afee7894a0a 100644
--- a/dlls/msvcr120_app/msvcr120_app.spec
+++ b/dlls/msvcr120_app/msvcr120_app.spec
@@ -538,9 +538,9 @@
 @ stub -arch=arm ?_IsCanceling@_TaskCollection@details@Concurrency@@QAA_NXZ
 @ stub -arch=i386 ?_IsCanceling@_TaskCollection@details@Concurrency@@QAE_NXZ
 @ stub -arch=win64 ?_IsCanceling@_TaskCollection@details@Concurrency@@QEAA_NXZ
-@ stub -arch=arm ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBA_NXZ
-@ stub -arch=i386 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBE_NXZ
-@ stub -arch=win64 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QEBA_NXZ
+@ cdecl -arch=arm ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBA_NXZ(ptr) msvcr120.?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBA_NXZ
+@ thiscall -arch=i386 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBE_NXZ(ptr) msvcr120.?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QBE_NXZ
+@ cdecl -arch=win64 ?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QEBA_NXZ(ptr) msvcr120.?_IsSynchronouslyBlocked@_Context@details@Concurrency@@QEBA_NXZ
 @ stub -arch=win32 ?_Name_base@type_info@@CAPBDPBV1@PAU__type_info_node@@@Z
 @ stub -arch=win64 ?_Name_base@type_info@@CAPEBDPEBV1@PEAU__type_info_node@@@Z
 @ stub -arch=win32 ?_Name_base_internal@type_info@@CAPBDPBV1@PAU__type_info_node@@@Z
diff --git a/dlls/msvcrt/concurrency.c b/dlls/msvcrt/concurrency.c
index f7bda445bc1..ba13243b4d5 100644
--- a/dlls/msvcrt/concurrency.c
+++ b/dlls/msvcrt/concurrency.c
@@ -867,6 +867,13 @@ _Context *__cdecl _Context__CurrentContext(_Context *ret)
     ret->context = Context_CurrentContext();
     return ret;
 }
+
+DEFINE_THISCALL_WRAPPER(_Context_IsSynchronouslyBlocked, 4)
+BOOL __thiscall _Context_IsSynchronouslyBlocked(const _Context *this)
+{
+    TRACE("(%p)\n", this);
+    return FALSE;
+}
 #endif
 
 DEFINE_THISCALL_WRAPPER(ExternalContextBase_GetId, 4)
-- 
GitLab

From c852fb12c5be329ffe25838fcd2d8f945ce7d838 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 11 Jan 2023 10:58:47 -0600
Subject: [PATCH 1/5] ntdll/tests: Fix the case of absent XSTATE context in
 test_copy_context().

---
 dlls/ntdll/tests/exception.c | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
index 4bf2e4ec78e..e714feed375 100644
--- a/dlls/ntdll/tests/exception.c
+++ b/dlls/ntdll/tests/exception.c
@@ -10524,10 +10524,13 @@ static void test_copy_context(void)
         *(DWORD *)((BYTE *)dst + flags_offset) = 0;
         *(DWORD *)((BYTE *)src + flags_offset) = 0;
 
-        src_xs = (XSTATE *)((BYTE *)src_ex + src_ex->XState.Offset);
-        memset(src_xs, 0xcc, sizeof(XSTATE));
-        src_xs->Mask = 3;
-        src_xs->CompactionMask = ~(ULONG64)0;
+        if (src_ex->XState.Offset != 25)
+        {
+            src_xs = (XSTATE *)((BYTE *)src_ex + src_ex->XState.Offset);
+            memset(src_xs, 0xcc, sizeof(XSTATE));
+            src_xs->Mask = 3;
+            src_xs->CompactionMask = ~(ULONG64)0;
+        }
 
         status = pRtlCopyExtendedContext(dst_ex, flags, src_ex);
         ok(!status, "Got unexpected status %#lx, flags %#lx.\n", status, flags);
-- 
GitLab


From f458f17f116a4f7a8d28b96b905856178091bd63 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 11 Jan 2023 12:30:58 -0600
Subject: [PATCH 2/5] ntdll/tests: Fix xstate tests failing on modern Windows
 and CPUs with more xstate features.

---
 dlls/ntdll/tests/exception.c | 51 +++++++++++++++++++++---------------
 1 file changed, 30 insertions(+), 21 deletions(-)

diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
index e714feed375..3cf88047217 100644
--- a/dlls/ntdll/tests/exception.c
+++ b/dlls/ntdll/tests/exception.c
@@ -198,7 +198,7 @@ static int test_stage;
 #if defined(__i386__) || defined(__x86_64__)
 static void test_debugger_xstate(HANDLE thread, CONTEXT *ctx, int stage)
 {
-    char context_buffer[sizeof(CONTEXT) + sizeof(CONTEXT_EX) + sizeof(XSTATE) + 63];
+    char context_buffer[sizeof(CONTEXT) + sizeof(CONTEXT_EX) + sizeof(XSTATE) + 1024];
     CONTEXT_EX *c_ex;
     NTSTATUS status;
     YMMCONTEXT *ymm;
@@ -9487,6 +9487,7 @@ static void test_extended_context(void)
             8,
         },
     };
+    const ULONG64 supported_features = 7, supported_compaction_mask = supported_features | ((ULONG64)1 << 63);
     ULONG expected_length, expected_length_xstate, context_flags, expected_offset;
     ULONG64 enabled_features, expected_compaction;
     DECLSPEC_ALIGN(64) BYTE context_buffer2[2048];
@@ -9999,7 +10000,7 @@ static void test_extended_context(void)
         mask = 0xdeadbeef;
         bret = pGetXStateFeaturesMask(context, &mask);
         if (flags & CONTEXT_NATIVE)
-            ok(bret && mask == enabled_features,
+            ok(bret && mask == (enabled_features & supported_features),
                     "Got unexpected bret %#x, mask %s, flags %#lx.\n", bret, wine_dbgstr_longlong(mask), flags);
         else
             ok(!bret && mask == 0xdeadbeef,
@@ -10243,9 +10244,9 @@ static void test_extended_context(void)
     expected_compaction = compaction_enabled ? ((ULONG64)1 << 63) | 4 : 0;
 
     xs = (XSTATE *)((BYTE *)context_ex + context_ex->XState.Offset);
-    ok(xs->Mask == (xsaveopt_enabled ? 0 : 4), "Got unexpected Mask %#I64x.\n", xs->Mask);
-    ok(xs->CompactionMask == expected_compaction, "Got unexpected CompactionMask %s.\n",
-            wine_dbgstr_longlong(xs->CompactionMask));
+    ok((xs->Mask & supported_features) == (xsaveopt_enabled ? 0 : 4), "Got unexpected Mask %#I64x.\n", xs->Mask);
+    ok((xs->CompactionMask & (supported_features | ((ULONG64)1 << 63))) == expected_compaction,
+            "Got unexpected CompactionMask %s.\n", wine_dbgstr_longlong(xs->CompactionMask));
 
     for (i = 4; i < 8; ++i)
         ok(!data[i], "Got unexpected data %#x, i %u.\n", data[i], i);
@@ -10291,9 +10292,10 @@ static void test_extended_context(void)
     bret = GetThreadContext(thread, context);
     ok(bret, "Got unexpected bret %#x, GetLastError() %lu.\n", bret, GetLastError());
     todo_wine_if (!xsaveopt_enabled)
-        ok(xs->Mask == (xsaveopt_enabled ? 0 : 4), "Got unexpected Mask %#I64x.\n", xs->Mask);
-    ok(xs->CompactionMask == expected_compaction, "Got unexpected CompactionMask %s.\n",
-            wine_dbgstr_longlong(xs->CompactionMask));
+        ok((xs->Mask & supported_features) == (xsaveopt_enabled ? 0 : 4), "Got unexpected Mask %#I64x.\n", xs->Mask);
+    ok((xs->CompactionMask & supported_compaction_mask) == expected_compaction,
+            "Got unexpected CompactionMask %s.\n", wine_dbgstr_longlong(xs->CompactionMask));
+
     for (i = 0; i < 16 * 4; ++i)
         ok(((ULONG *)&xs->YmmContext)[i] == ((xs->Mask & 4) ? 0 : 0xcccccccc),
                 "Got unexpected value %#lx, i %u.\n", ((ULONG *)&xs->YmmContext)[i], i);
@@ -10306,8 +10308,9 @@ static void test_extended_context(void)
     memset(&xs->YmmContext, 0xcc, sizeof(xs->YmmContext));
     bret = GetThreadContext(thread, context);
     ok(bret, "Got unexpected bret %#x, GetLastError() %lu.\n", bret, GetLastError());
-    ok(!xs->Mask || broken(xs->Mask == 4), "Got unexpected Mask %s.\n", wine_dbgstr_longlong(xs->Mask));
-    ok(xs->CompactionMask == expected_compaction, "Got unexpected CompactionMask %s.\n",
+    ok(!(xs->Mask & supported_features) || broken((xs->Mask & supported_features) == 4), "Got unexpected Mask %s.\n",
+            wine_dbgstr_longlong(xs->Mask));
+    ok((xs->CompactionMask & supported_compaction_mask) == expected_compaction, "Got unexpected CompactionMask %s.\n",
             wine_dbgstr_longlong(xs->CompactionMask));
     for (i = 0; i < 16 * 4; ++i)
         ok(((ULONG *)&xs->YmmContext)[i] == 0xcccccccc || broken(xs->Mask == 4 && !((ULONG *)&xs->YmmContext)[i]),
@@ -10320,8 +10323,8 @@ static void test_extended_context(void)
     memset(&xs->YmmContext, 0xcc, sizeof(xs->YmmContext));
     bret = GetThreadContext(thread, context);
     ok(bret, "Got unexpected bret %#x, GetLastError() %lu.\n", bret, GetLastError());
-    ok(xs->Mask == 4, "Got unexpected Mask %s.\n", wine_dbgstr_longlong(xs->Mask));
-    ok(xs->CompactionMask == expected_compaction, "Got unexpected CompactionMask %s.\n",
+    ok((xs->Mask & supported_features) == 4, "Got unexpected Mask %s.\n", wine_dbgstr_longlong(xs->Mask));
+    ok((xs->CompactionMask & supported_compaction_mask) == expected_compaction, "Got unexpected CompactionMask %s.\n",
             wine_dbgstr_longlong(xs->CompactionMask));
     for (i = 0; i < 16 * 4; ++i)
         ok(((ULONG *)&xs->YmmContext)[i] == 0x28282828, "Got unexpected value %#lx, i %u.\n",
@@ -10341,7 +10344,7 @@ static void test_extended_context(void)
     memset(&xs->YmmContext, 0xcc, sizeof(xs->YmmContext));
     bret = GetThreadContext(thread, context);
     ok(bret, "Got unexpected bret %#x, GetLastError() %lu.\n", bret, GetLastError());
-    ok(xs->Mask == 4, "Got unexpected Mask %s.\n", wine_dbgstr_longlong(xs->Mask));
+    ok((xs->Mask & supported_features) == 4, "Got unexpected Mask %s.\n", wine_dbgstr_longlong(xs->Mask));
 
     for (i = 0; i < 4; ++i)
         ok(((ULONG *)&xs->YmmContext)[i] == 0x68686868, "Got unexpected value %#lx, i %u.\n",
@@ -10353,9 +10356,10 @@ static void test_extended_context(void)
     bret = GetThreadContext(thread, context);
     ok(bret, "Got unexpected bret %#x, GetLastError() %lu.\n", bret, GetLastError());
     todo_wine_if (!xsaveopt_enabled && sizeof(void *) != 4)
-        ok(xs->Mask == (xsaveopt_enabled ? 0 : 4) || (sizeof(void *) == 4 && xs->Mask == 4),
-                "Got unexpected Mask %#I64x.\n", xs->Mask);
-    if (xs->Mask == 4)
+        ok((xs->Mask & supported_features) == (xsaveopt_enabled ? 0 : 4)
+                || (sizeof(void *) == 4 && (xs->Mask & supported_features) == 4),
+                "Got unexpected Mask %#I64x, supported_features.\n", xs->Mask);
+    if ((xs->Mask & supported_features) == 4)
     {
         for (i = 0; i < 8 * sizeof(void *); ++i)
             ok(((ULONG *)&xs->YmmContext)[i] == 0,
@@ -10431,13 +10435,13 @@ static void check_changes_in_range_(const char *file, unsigned int line, const B
 
 static void test_copy_context(void)
 {
-    static const struct modified_range ranges_amd64[] =
+    static struct modified_range ranges_amd64[] =
     {
         {0x30, ~0}, {0x38, 0x1}, {0x3a, 0x4}, {0x42, 0x1}, {0x48, 0x10}, {0x78, 0x2}, {0x98, 0x1},
         {0xa0, 0x2}, {0xf8, 0x1}, {0x100, 0x8}, {0x2a0, 0x80000008}, {0x4b0, 0x10}, {0x4d0, ~0},
         {0x4e8, 0}, {0x500, ~0}, {0x640, 0}, {0x1000, 0},
     };
-    static const struct modified_range ranges_x86[] =
+    static struct modified_range ranges_x86[] =
     {
         {0x0, ~0}, {0x4, 0x10}, {0x1c, 0x8}, {0x8c, 0x4}, {0x9c, 0x2}, {0xb4, 0x1}, {0xcc, 0x20}, {0x1ec, 0x80000020},
         {0x2cc, ~0}, {0x294, 0}, {0x1000, 0},
@@ -10524,18 +10528,23 @@ static void test_copy_context(void)
         *(DWORD *)((BYTE *)dst + flags_offset) = 0;
         *(DWORD *)((BYTE *)src + flags_offset) = 0;
 
+        context_length = (BYTE *)dst_ex - (BYTE *)dst + dst_ex->All.Length;
+
         if (src_ex->XState.Offset != 25)
         {
             src_xs = (XSTATE *)((BYTE *)src_ex + src_ex->XState.Offset);
-            memset(src_xs, 0xcc, sizeof(XSTATE));
-            src_xs->Mask = 3;
+            memset(src_xs, 0xcc, src_ex->XState.Length);
+            src_xs->Mask = enabled_features & ~(ULONG64)4;
             src_xs->CompactionMask = ~(ULONG64)0;
+            if (flags & CONTEXT_AMD64)
+                ranges_amd64[ARRAY_SIZE(ranges_amd64) - 2].start = 0x640 + src_ex->XState.Length - sizeof(XSTATE);
+            else
+                ranges_x86[ARRAY_SIZE(ranges_x86) - 2].start = 0x294 + src_ex->XState.Length - sizeof(XSTATE);
         }
 
         status = pRtlCopyExtendedContext(dst_ex, flags, src_ex);
         ok(!status, "Got unexpected status %#lx, flags %#lx.\n", status, flags);
 
-        context_length = (BYTE *)dst_ex - (BYTE *)dst + dst_ex->All.Length;
         check_changes_in_range((BYTE *)dst, flags & CONTEXT_AMD64 ? &ranges_amd64[0] : &ranges_x86[0],
                 flags, context_length);
 
-- 
GitLab


From 1a7a87804e2117ea16e8eda42cf3aa6a23ea32f4 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 11 Jan 2023 13:04:43 -0600
Subject: [PATCH 3/5] ntdll/tests: Fix random test failure in
 test_restore_context().

---
 dlls/ntdll/tests/exception.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
index 3cf88047217..accf15a0415 100644
--- a/dlls/ntdll/tests/exception.c
+++ b/dlls/ntdll/tests/exception.c
@@ -2458,6 +2458,7 @@ static void test_restore_context(void)
     RtlCaptureContext(&ctx);
     InterlockedIncrement(&pass); /* only called once */
     p_setjmp(&buf);
+    buf.MxCsr = 0x1f90;
     InterlockedIncrement(&pass);
     if (pass == 3)
     {
@@ -2465,7 +2466,7 @@ static void test_restore_context(void)
         rec.NumberParameters = 1;
         rec.ExceptionInformation[0] = (DWORD64)&buf;
 
-        ok(buf.MxCsr == 0x1f80, "Got unexpected MxCsr %#lx.\n", buf.MxCsr);
+        ok(buf.MxCsr == 0x1f90, "Got unexpected MxCsr %#lx.\n", buf.MxCsr);
         ok(buf.FpCsr == 0x27f, "Got unexpected FpCsr %#x.\n", buf.FpCsr);
         buf.FpCsr = 0x7f;
         buf.MxCsr = 0x3f80;
-- 
GitLab


From 82b3f07b60ce6deb82f50d5bd38c1b29560c251b Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 11 Jan 2023 12:52:56 -0600
Subject: [PATCH 4/5] ntdll: Factor out context_copy_ranges() function.

---
 dlls/ntdll/exception.c | 51 ++++++++++++++++++++++--------------------
 1 file changed, 27 insertions(+), 24 deletions(-)

diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
index 22c9c829a4d..fa30118f142 100644
--- a/dlls/ntdll/exception.c
+++ b/dlls/ntdll/exception.c
@@ -961,6 +961,32 @@ ULONG64 WINAPI RtlGetExtendedFeaturesMask( CONTEXT_EX *context_ex )
 }
 
 
+static void context_copy_ranges( BYTE *d, DWORD context_flags, BYTE *s, const struct context_parameters *p )
+{
+    const struct context_copy_range *range;
+    unsigned int start;
+
+    *((ULONG *)(d + p->flags_offset)) |= context_flags;
+
+    start = 0;
+    range = p->copy_ranges;
+    do
+    {
+        if (range->flag & context_flags)
+        {
+            if (!start)
+                start = range->start;
+        }
+        else if (start)
+        {
+            memcpy( d + start, s + start, range->start - start );
+            start = 0;
+        }
+    }
+    while (range++->start != p->context_size);
+}
+
+
 /***********************************************************************
  *              RtlCopyContext  (NTDLL.@)
  */
@@ -1010,12 +1036,9 @@ NTSTATUS WINAPI RtlCopyContext( CONTEXT *dst, DWORD context_flags, CONTEXT *src
  */
 NTSTATUS WINAPI RtlCopyExtendedContext( CONTEXT_EX *dst, ULONG context_flags, CONTEXT_EX *src )
 {
-    const struct context_copy_range *range;
     const struct context_parameters *p;
     XSTATE *dst_xs, *src_xs;
     ULONG64 feature_mask;
-    unsigned int start;
-    BYTE *d, *s;
 
     TRACE( "dst %p, context_flags %#lx, src %p.\n", dst, context_flags, src );
 
@@ -1025,27 +1048,7 @@ NTSTATUS WINAPI RtlCopyExtendedContext( CONTEXT_EX *dst, ULONG context_flags, CO
     if (!(feature_mask = RtlGetEnabledExtendedFeatures( ~(ULONG64)0 )) && context_flags & 0x40)
         return STATUS_NOT_SUPPORTED;
 
-    d = RtlLocateLegacyContext( dst, NULL );
-    s = RtlLocateLegacyContext( src, NULL );
-
-    *((ULONG *)(d + p->flags_offset)) |= context_flags;
-
-    start = 0;
-    range = p->copy_ranges;
-    do
-    {
-        if (range->flag & context_flags)
-        {
-            if (!start)
-                start = range->start;
-        }
-        else if (start)
-        {
-            memcpy( d + start, s + start, range->start - start );
-            start = 0;
-        }
-    }
-    while (range++->start != p->context_size);
+    context_copy_ranges( RtlLocateLegacyContext( dst, NULL ), context_flags, RtlLocateLegacyContext( src, NULL ), p );
 
     if (!(context_flags & 0x40))
         return STATUS_SUCCESS;
-- 
GitLab


From 61a1e159c3ffa7172b35ed44d521d4c2181c23f7 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 11 Jan 2023 12:32:58 -0600
Subject: [PATCH 5/5] ntdll: Do not use extended context in RtlCopyContext() if
 extended state is not copied.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=54289
---
 dlls/ntdll/exception.c       | 12 ++++++++++--
 dlls/ntdll/tests/exception.c | 20 ++++++++++++++++++++
 2 files changed, 30 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/exception.c b/dlls/ntdll/exception.c
index fa30118f142..556b424ac6e 100644
--- a/dlls/ntdll/exception.c
+++ b/dlls/ntdll/exception.c
@@ -994,6 +994,7 @@ NTSTATUS WINAPI RtlCopyContext( CONTEXT *dst, DWORD context_flags, CONTEXT *src
 {
     DWORD context_size, arch_flag, flags_offset, dst_flags, src_flags;
     static const DWORD arch_mask = CONTEXT_i386 | CONTEXT_AMD64;
+    const struct context_parameters *p;
     BYTE *d, *s;
 
     TRACE("dst %p, context_flags %#lx, src %p.\n", dst, context_flags, src);
@@ -1026,8 +1027,15 @@ NTSTATUS WINAPI RtlCopyContext( CONTEXT *dst, DWORD context_flags, CONTEXT *src
     context_flags &= src_flags;
     if (context_flags & ~dst_flags & 0x40) return STATUS_BUFFER_OVERFLOW;
 
-    return RtlCopyExtendedContext( (CONTEXT_EX *)(d + context_size), context_flags,
-                                   (CONTEXT_EX *)(s + context_size) );
+    if (context_flags & 0x40)
+        return RtlCopyExtendedContext( (CONTEXT_EX *)(d + context_size), context_flags,
+                                       (CONTEXT_EX *)(s + context_size) );
+
+    if (!(p = context_get_parameters( context_flags )))
+        return STATUS_INVALID_PARAMETER;
+
+    context_copy_ranges( d, context_flags, s, p );
+    return STATUS_SUCCESS;
 }
 
 
diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
index accf15a0415..557d3405d90 100644
--- a/dlls/ntdll/tests/exception.c
+++ b/dlls/ntdll/tests/exception.c
@@ -10501,6 +10501,26 @@ static void test_copy_context(void)
 
     enabled_features = pRtlGetEnabledExtendedFeatures(~(ULONG64)0);
 
+    memset(dst_context_buffer, 0xdd, sizeof(dst_context_buffer));
+    memset(src_context_buffer, 0xcc, sizeof(src_context_buffer));
+
+    status = pRtlInitializeExtendedContext(src_context_buffer, CONTEXT_ALL | CONTEXT_XSTATE, &src_ex);
+    if (!status)
+    {
+        src = pRtlLocateLegacyContext(src_ex, NULL);
+        dst = (CONTEXT *)dst_context_buffer;
+        dst->ContextFlags = CONTEXT_ALL;
+        status = pRtlCopyContext(dst, dst->ContextFlags, src);
+        ok(!status, "Got status %#lx.\n", status);
+        check_changes_in_range((BYTE *)dst, CONTEXT_ALL & CONTEXT_AMD64 ? &ranges_amd64[0] : &ranges_x86[0],
+                CONTEXT_ALL, sizeof(CONTEXT));
+    }
+    else
+    {
+        ok(status == STATUS_NOT_SUPPORTED, "Got status %#lx.\n", status);
+        skip("Extended context is not supported.\n");
+    }
+
     for (i = 0; i < ARRAY_SIZE(tests); ++i)
     {
         flags = tests[i];
-- 
GitLab

From 750e5ee33cb85c1d95a2642919b87f7f4176097a Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Thu, 22 Dec 2022 01:20:59 +0900
Subject: [PATCH 1/2] user32/tests: Add tests for CS_HREDRAW and CS_VREDRAW.

---
 dlls/user32/tests/msg.c | 130 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 130 insertions(+)

diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
index 50bfc9855dd..461d79d9a5d 100644
--- a/dlls/user32/tests/msg.c
+++ b/dlls/user32/tests/msg.c
@@ -9416,6 +9416,120 @@ static void test_swp_paint_regions(void)
     subtest_swp_paint_regions( 0, "SimpleWindowClassWithParentDC", "SimpleWindowClass" );
 }
 
+static void subtest_hvredraw(HWND hparent, const char *classname, DWORD style)
+{
+    static const struct movesize_test {
+        int dx, dy, dw, dh;
+    } movesize_tests[] = {
+        {   0,   0,   0,  50 },
+        {   0,   0,  50,   0 },
+        {   0,   0,  50,  50 },
+        {   0,   0, -50, -50 },
+        { -50, -50,   0,  50 },
+        { -50, -50,  50,   0 },
+        { -50, -50,  50,  50 },
+    };
+    HRGN hrgn_old_vis = CreateRectRgn( 0, 0, 0, 0 );
+    HRGN hrgn_new_vis = CreateRectRgn( 0, 0, 0, 0 );
+    HRGN hrgn_expect = CreateRectRgn( 0, 0, 0, 0 );
+    HRGN hrgn_actual = CreateRectRgn( 0, 0, 0, 0 );
+    const int x0 = 100, y0 = 100, w0 = 200, h0 = 200;
+    size_t i;
+    HWND hwnd;
+    UINT class_style;
+
+    hwnd = CreateWindowExA( 0, classname, "Test window", style, x0, y0, w0, h0, hparent, 0, 0, NULL );
+    ok(hwnd != NULL, "Failed to create the window\n");
+
+    class_style = GetClassLongA( hwnd, GCL_STYLE );
+
+    ShowWindow( hwnd, SW_SHOW );
+    UpdateWindow( hwnd );
+
+    for (i = 0; i < ARRAY_SIZE(movesize_tests); i++)
+    {
+        const struct movesize_test *test = &movesize_tests[i];
+        int is_redraw = (test->dw != 0 && (class_style & CS_HREDRAW)) ||
+                        (test->dh != 0 && (class_style & CS_VREDRAW));
+        RECT rect_old_vis, rect_new_vis;
+        BOOL rgn_ok;
+
+        winetest_push_context( "%s %08lx SetWindowPos redraw #%Id (%d, %d, %d, %d)",
+                               classname, style, i, test->dx, test->dy, test->dw, test->dh );
+
+        SetWindowPos( hwnd, HWND_TOP, x0, y0, w0, h0, SWP_NOACTIVATE );
+
+        GetClientRect( hwnd, &rect_old_vis );
+        SetRectRgn( hrgn_old_vis, rect_old_vis.left, rect_old_vis.top, rect_old_vis.right, rect_old_vis.bottom );
+
+        UpdateWindow( hparent );
+        flush_events();
+
+        SetWindowPos( hwnd, HWND_TOP,
+                      x0 + test->dx, y0 + test->dy,
+                      w0 + test->dw, h0 + test->dh, SWP_NOACTIVATE );
+        ok( GetUpdateRgn( hwnd, hrgn_actual, FALSE ) != ERROR, "GetUpdateRgn shall succeed\n" );
+
+        GetClientRect( hwnd, &rect_new_vis );
+        SetRectRgn( hrgn_new_vis, rect_new_vis.left, rect_new_vis.top, rect_new_vis.right, rect_new_vis.bottom );
+        CombineRgn( hrgn_expect, hrgn_new_vis, hrgn_old_vis, is_redraw ? RGN_COPY : RGN_DIFF );
+
+        rgn_ok = EqualRgn( hrgn_expect, hrgn_actual );
+        todo_wine_if( is_redraw )
+        ok( !!rgn_ok, "Update region shall match expected region\n" );
+
+        if (!rgn_ok && winetest_debug > 1)
+        {
+            trace( "Expected update region: " );
+            dump_region( hrgn_expect );
+            trace( "Actual update region: " );
+            dump_region( hrgn_actual );
+            trace( "Old window visible area: %s\n", wine_dbgstr_rect( &rect_old_vis ) );
+            trace( "New window visible area: %s\n", wine_dbgstr_rect( &rect_new_vis ) );
+        }
+
+        if (winetest_interactive)
+        {
+            if (!rgn_ok)
+            {
+                visualize_region_differences( hwnd, NULL, hrgn_expect, hrgn_actual );
+            }
+
+            /* Let the position change be visible to the user */
+            flush_events();
+        }
+
+        winetest_pop_context();
+    }
+
+    DestroyWindow( hwnd );
+    DeleteObject( hrgn_actual );
+    DeleteObject( hrgn_expect );
+    DeleteObject( hrgn_new_vis );
+    DeleteObject( hrgn_old_vis );
+}
+
+
+static void test_hvredraw(void)
+{
+    HWND htoplevel;
+
+    subtest_hvredraw( NULL, "SimpleWindowClassWithHRedraw", WS_OVERLAPPEDWINDOW );
+    subtest_hvredraw( NULL, "SimpleWindowClassWithVRedraw", WS_OVERLAPPEDWINDOW );
+    subtest_hvredraw( NULL, "SimpleWindowClassWithHVRedraw", WS_OVERLAPPEDWINDOW );
+
+    htoplevel = CreateWindowExA( 0, "SimpleWindowClass", "Test toplevel",
+                                 WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_VISIBLE,
+                                 100, 100, 400, 400, 0, 0, 0, NULL );
+    ok( htoplevel != 0, "Failed to create top-level window: %lu\n", GetLastError() );
+
+    subtest_hvredraw( htoplevel, "SimpleWindowClassWithHRedraw", WS_CHILD | WS_BORDER );
+    subtest_hvredraw( htoplevel, "SimpleWindowClassWithVRedraw", WS_CHILD | WS_BORDER );
+    subtest_hvredraw( htoplevel, "SimpleWindowClassWithHVRedraw", WS_CHILD | WS_BORDER );
+
+    DestroyWindow( htoplevel );
+}
+
 struct wnd_event
 {
     HWND hwnd;
@@ -10766,6 +10880,21 @@ static BOOL RegisterWindowClasses(void)
     cls.lpszClassName = "SimpleWindowClassWithParentDC";
     if(!RegisterClassA(&cls)) return FALSE;
 
+    cls.lpfnWndProc = DefWindowProcA;
+    cls.style = CS_HREDRAW;
+    cls.lpszClassName = "SimpleWindowClassWithHRedraw";
+    if(!RegisterClassA(&cls)) return FALSE;
+
+    cls.lpfnWndProc = DefWindowProcA;
+    cls.style = CS_VREDRAW;
+    cls.lpszClassName = "SimpleWindowClassWithVRedraw";
+    if(!RegisterClassA(&cls)) return FALSE;
+
+    cls.lpfnWndProc = DefWindowProcA;
+    cls.style = CS_HREDRAW | CS_VREDRAW;
+    cls.lpszClassName = "SimpleWindowClassWithHVRedraw";
+    if(!RegisterClassA(&cls)) return FALSE;
+
     clsW.style = 0;
     clsW.lpfnWndProc = MsgCheckProcW;
     clsW.cbClsExtra = 0;
@@ -19521,6 +19650,7 @@ START_TEST(msg)
     test_wmime_keydown_message();
     test_paint_messages();
     test_swp_paint_regions();
+    test_hvredraw();
     test_interthread_messages();
     test_message_conversion();
     test_accelerators();
-- 
GitLab


From 3946d01eecd1658fca9968368b2da40ef5f47f6b Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Thu, 22 Dec 2022 01:21:48 +0900
Subject: [PATCH 2/2] win32u: Honor CS_HREDRAW and CS_VREDRAW when resizing
 window.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52903
---
 dlls/user32/tests/msg.c | 1 -
 dlls/win32u/window.c    | 7 ++++++-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
index 461d79d9a5d..35e4f0dd1f8 100644
--- a/dlls/user32/tests/msg.c
+++ b/dlls/user32/tests/msg.c
@@ -9475,7 +9475,6 @@ static void subtest_hvredraw(HWND hparent, const char *classname, DWORD style)
         CombineRgn( hrgn_expect, hrgn_new_vis, hrgn_old_vis, is_redraw ? RGN_COPY : RGN_DIFF );
 
         rgn_ok = EqualRgn( hrgn_expect, hrgn_actual );
-        todo_wine_if( is_redraw )
         ok( !!rgn_ok, "Update region shall match expected region\n" );
 
         if (!rgn_ok && winetest_debug > 1)
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 19348338c46..a3ff0647dcd 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -3116,6 +3116,7 @@ static UINT calc_ncsize( WINDOWPOS *winpos, const RECT *old_window_rect, const R
     {
         NCCALCSIZE_PARAMS params;
         WINDOWPOS winposCopy;
+        UINT class_style;
 
         params.rgrc[0] = *new_window_rect;
         params.rgrc[1] = *old_window_rect;
@@ -3135,7 +3136,11 @@ static UINT calc_ncsize( WINDOWPOS *winpos, const RECT *old_window_rect, const R
             winposCopy.cy = old_window_rect->bottom - old_window_rect->top;
         }
 
-        wvr_flags = send_message( winpos->hwnd, WM_NCCALCSIZE, TRUE, (LPARAM)&params );
+        class_style = get_class_long( winpos->hwnd, GCL_STYLE, FALSE );
+        if (class_style & CS_VREDRAW) wvr_flags |= WVR_VREDRAW;
+        if (class_style & CS_HREDRAW) wvr_flags |= WVR_HREDRAW;
+
+        wvr_flags |= send_message( winpos->hwnd, WM_NCCALCSIZE, TRUE, (LPARAM)&params );
 
         *new_client_rect = params.rgrc[0];
 
-- 
GitLab

From 354c9b2ad4ffaabaa2de5914b190baa0aa3d0a2c Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Fri, 18 Nov 2022 02:15:39 -0500
Subject: [PATCH 1/5] include: Add
 windows.system.profile.systemmanufacturers.idl file.

---
 include/Makefile.in                           |  1 +
 ...ows.system.profile.systemmanufacturers.idl | 60 +++++++++++++++++++
 2 files changed, 61 insertions(+)
 create mode 100644 include/windows.system.profile.systemmanufacturers.idl

diff --git a/include/Makefile.in b/include/Makefile.in
index 23a4265a437..c15c4db6f11 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -802,6 +802,7 @@ SOURCES = \
 	windows.storage.streams.idl \
 	windows.system.idl \
 	windows.system.power.idl \
+	windows.system.profile.systemmanufacturers.idl \
 	windows.system.userprofile.idl \
 	windowscontracts.idl \
 	windowsx.h \
diff --git a/include/windows.system.profile.systemmanufacturers.idl b/include/windows.system.profile.systemmanufacturers.idl
new file mode 100644
index 00000000000..644a664020b
--- /dev/null
+++ b/include/windows.system.profile.systemmanufacturers.idl
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "asyncinfo.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+
+namespace Windows.System.Profile.SystemManufacturers
+{
+    apicontract SystemManufacturersContract;
+    interface ISmbiosInformationStatics;
+    runtimeclass SmbiosInformation;
+
+    [
+        contractversion(3.0)
+    ]
+    apicontract SystemManufacturersContract
+    {
+    }
+
+    [
+        contract(Windows.System.Profile.SystemManufacturers.SystemManufacturersContract, 1.0),
+        exclusiveto(Windows.System.Profile.SystemManufacturers.SmbiosInformation),
+        uuid(080cca7c-637c-48c4-b728-f9273812db8e)
+    ]
+    interface ISmbiosInformationStatics : IInspectable
+    {
+        [propget] HRESULT SerialNumber([out, retval] HSTRING *value);
+    }
+
+    [
+        contract(Windows.System.Profile.SystemManufacturers.SystemManufacturersContract, 1.0),
+        marshaling_behavior(agile),
+        static(Windows.System.Profile.SystemManufacturers.ISmbiosInformationStatics, Windows.System.Profile.SystemManufacturers.SystemManufacturersContract, 1.0)
+    ]
+    runtimeclass SmbiosInformation
+    {
+    }
+}
-- 
GitLab


From 41bff7dfa360936494067284a2947e61f5ef6640 Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Sat, 19 Nov 2022 20:42:14 -0500
Subject: [PATCH 2/5] windows.system.profile.systemmanufacturers: Add stub DLL.

---
 configure.ac                                  |   2 +
 .../Makefile.in                               |   8 +
 .../classes.idl                               |  23 +++
 .../main.c                                    | 148 ++++++++++++++++++
 .../private.h                                 |  31 ++++
 .../tests/Makefile.in                         |   5 +
 .../tests/smbios.c                            |  83 ++++++++++
 ...ws.system.profile.systemmanufacturers.spec |   3 +
 8 files changed, 303 insertions(+)
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/Makefile.in
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/classes.idl
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/main.c
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/private.h
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec

diff --git a/configure.ac b/configure.ac
index 9115244cb78..80bd78678e6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3190,6 +3190,8 @@ WINE_CONFIG_MAKEFILE(dlls/windows.media.
 WINE_CONFIG_MAKEFILE(dlls/windows.media.speech)
 WINE_CONFIG_MAKEFILE(dlls/windows.media.speech/tests)
 WINE_CONFIG_MAKEFILE(dlls/windows.networking.connectivity)
+WINE_CONFIG_MAKEFILE(dlls/windows.system.profile.systemmanufacturers)
+WINE_CONFIG_MAKEFILE(dlls/windows.system.profile.systemmanufacturers/tests)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecs)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecs/tests)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecsext)
diff --git a/dlls/windows.system.profile.systemmanufacturers/Makefile.in b/dlls/windows.system.profile.systemmanufacturers/Makefile.in
new file mode 100644
index 00000000000..a2d6076740f
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/Makefile.in
@@ -0,0 +1,8 @@
+MODULE  = windows.system.profile.systemmanufacturers.dll
+IMPORTS = combase
+
+C_SRCS = \
+	main.c
+
+IDL_SRCS = \
+	classes.idl
diff --git a/dlls/windows.system.profile.systemmanufacturers/classes.idl b/dlls/windows.system.profile.systemmanufacturers/classes.idl
new file mode 100644
index 00000000000..6072a782222
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/classes.idl
@@ -0,0 +1,23 @@
+/*
+ * Runtime Classes for windows.system.profile.systemmanufacturers.dll
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+#include "windows.system.profile.systemmanufacturers.idl"
diff --git a/dlls/windows.system.profile.systemmanufacturers/main.c b/dlls/windows.system.profile.systemmanufacturers/main.c
new file mode 100644
index 00000000000..3f5e937392e
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/main.c
@@ -0,0 +1,148 @@
+/* WinRT Windows.System.Profile.SystemManufacturers Implementation
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "initguid.h"
+#include "private.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(smbios);
+
+static const char *debugstr_hstring( HSTRING hstr )
+{
+    const WCHAR *str;
+    UINT32 len;
+    if (hstr && !((ULONG_PTR)hstr >> 16)) return "(invalid)";
+    str = WindowsGetStringRawBuffer(hstr, &len);
+    return wine_dbgstr_wn(str, len);
+}
+
+struct smbios_statics
+{
+    IActivationFactory IActivationFactory_iface;
+    LONG ref;
+};
+
+static inline struct smbios_statics *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct smbios_statics, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI factory_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct smbios_statics *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        *out = &impl->IActivationFactory_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI factory_AddRef( IActivationFactory *iface )
+{
+    struct smbios_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI factory_Release( IActivationFactory *iface )
+{
+    struct smbios_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI factory_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    FIXME( "iface %p, instance %p stub!\n", iface, instance );
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl factory_vtbl =
+{
+    factory_QueryInterface,
+    factory_AddRef,
+    factory_Release,
+    /* IInspectable methods */
+    factory_GetIids,
+    factory_GetRuntimeClassName,
+    factory_GetTrustLevel,
+    /* IActivationFactory methods */
+    factory_ActivateInstance,
+};
+
+static struct smbios_statics smbios_statics =
+{
+    {&factory_vtbl},
+    1,
+};
+
+static IActivationFactory *smbios_factory = &smbios_statics.IActivationFactory_iface;
+
+HRESULT WINAPI DllGetClassObject( REFCLSID clsid, REFIID riid, void **out )
+{
+    FIXME( "clsid %s, riid %s, out %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), out );
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+HRESULT WINAPI DllGetActivationFactory( HSTRING classid, IActivationFactory **factory )
+{
+    const WCHAR *name = WindowsGetStringRawBuffer( classid, NULL );
+
+    TRACE( "classid %s, factory %p.\n", debugstr_hstring(classid), factory );
+
+    *factory = NULL;
+
+    if (!wcscmp( name, RuntimeClass_Windows_System_Profile_SystemManufacturers_SmbiosInformation ))
+        IActivationFactory_QueryInterface( smbios_factory, &IID_IActivationFactory, (void **)factory );
+
+    if (*factory) return S_OK;
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
diff --git a/dlls/windows.system.profile.systemmanufacturers/private.h b/dlls/windows.system.profile.systemmanufacturers/private.h
new file mode 100644
index 00000000000..e3672c3aec5
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/private.h
@@ -0,0 +1,31 @@
+/* WinRT Windows.System.Profile.SystemManufacturers Implementation
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <stddef.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "activation.h"
+
+#define WIDL_using_Windows_System_Profile_SystemManufacturers
+#include "windows.system.profile.systemmanufacturers.h"
diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in b/dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in
new file mode 100644
index 00000000000..ade0c6b12dd
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL = windows.system.profile.systemmanufacturers.dll
+IMPORTS = combase
+
+C_SRCS = \
+	smbios.c
diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
new file mode 100644
index 00000000000..fa3308f21ab
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#define COBJMACROS
+#include "initguid.h"
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "roapi.h"
+
+#define WIDL_using_Windows_System_Profile_SystemManufacturers
+#include "windows.system.profile.systemmanufacturers.h"
+
+#include "wine/test.h"
+
+#define check_interface( obj, iid ) check_interface_( __LINE__, obj, iid )
+static void check_interface_( unsigned int line, void *obj, const IID *iid )
+{
+    IUnknown *iface = obj;
+    IUnknown *unk;
+    HRESULT hr;
+
+    hr = IUnknown_QueryInterface( iface, iid, (void **)&unk );
+    ok_(__FILE__, line)( hr == S_OK, "got hr %#lx.\n", hr );
+    IUnknown_Release( unk );
+}
+
+static void test_Smbios_Statics(void)
+{
+    static const WCHAR *smbios_statics_name = L"Windows.System.Profile.SystemManufacturers.SmbiosInformation";
+    IActivationFactory *factory;
+    HSTRING str;
+    HRESULT hr;
+    LONG ref;
+
+    hr = WindowsCreateString( smbios_statics_name, wcslen( smbios_statics_name ), &str );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    hr = RoGetActivationFactory( str, &IID_IActivationFactory, (void **)&factory );
+    WindowsDeleteString( str );
+    ok( hr == S_OK || broken( hr == REGDB_E_CLASSNOTREG ), "got hr %#lx.\n", hr );
+    if (hr == REGDB_E_CLASSNOTREG)
+    {
+        win_skip( "%s runtimeclass not registered, skipping tests.\n", wine_dbgstr_w( smbios_statics_name ) );
+        return;
+    }
+
+    check_interface( factory, &IID_IUnknown );
+    check_interface( factory, &IID_IInspectable );
+    check_interface( factory, &IID_IAgileObject );
+
+    ref = IActivationFactory_Release( factory );
+    ok( ref == 1, "got ref %ld.\n", ref );
+}
+
+START_TEST(smbios)
+{
+    HRESULT hr;
+
+    hr = RoInitialize( RO_INIT_MULTITHREADED );
+    ok( hr == S_OK, "RoInitialize failed, hr %#lx\n", hr );
+
+    test_Smbios_Statics();
+
+    RoUninitialize();
+}
diff --git a/dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec b/dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec
new file mode 100644
index 00000000000..31a5eafe950
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec
@@ -0,0 +1,3 @@
+@ stdcall -private DllGetActivationFactory(ptr ptr)
+@ stdcall -private DllCanUnloadNow()
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
-- 
GitLab


From 9275a848fef628cf50eea34cadb8921055dfb4cc Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Mon, 28 Nov 2022 03:15:39 -0500
Subject: [PATCH 3/5] windows.system.profile.systemmanufacturers: Stub
 ISmbiosInformationStatics interface.

---
 .../main.c                                    | 30 +++++++++++++++
 .../private.h                                 | 38 +++++++++++++++++++
 .../tests/smbios.c                            |  7 ++++
 3 files changed, 75 insertions(+)

diff --git a/dlls/windows.system.profile.systemmanufacturers/main.c b/dlls/windows.system.profile.systemmanufacturers/main.c
index 3f5e937392e..35b4529ad7a 100644
--- a/dlls/windows.system.profile.systemmanufacturers/main.c
+++ b/dlls/windows.system.profile.systemmanufacturers/main.c
@@ -36,6 +36,7 @@ static const char *debugstr_hstring( HSTRING hstr )
 struct smbios_statics
 {
     IActivationFactory IActivationFactory_iface;
+    ISmbiosInformationStatics ISmbiosInformationStatics_iface;
     LONG ref;
 };
 
@@ -60,6 +61,13 @@ static HRESULT WINAPI factory_QueryInterface( IActivationFactory *iface, REFIID
         return S_OK;
     }
 
+    if (IsEqualGUID( iid, &IID_ISmbiosInformationStatics ))
+    {
+        *out = &impl->ISmbiosInformationStatics_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
     FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
     *out = NULL;
     return E_NOINTERFACE;
@@ -118,9 +126,31 @@ static const struct IActivationFactoryVtbl factory_vtbl =
     factory_ActivateInstance,
 };
 
+DEFINE_IINSPECTABLE( statics, ISmbiosInformationStatics, struct smbios_statics, IActivationFactory_iface )
+
+static HRESULT WINAPI statics_get_SerialNumber( ISmbiosInformationStatics *iface, HSTRING *value )
+{
+    FIXME( "iface %p, value %p stub!\n", iface, value );
+    return E_NOTIMPL;
+}
+
+static const struct ISmbiosInformationStaticsVtbl statics_vtbl =
+{
+    statics_QueryInterface,
+    statics_AddRef,
+    statics_Release,
+    /* IInspectable methods */
+    statics_GetIids,
+    statics_GetRuntimeClassName,
+    statics_GetTrustLevel,
+    /* ISmbiosInformationStatics methods */
+    statics_get_SerialNumber,
+};
+
 static struct smbios_statics smbios_statics =
 {
     {&factory_vtbl},
+    {&statics_vtbl},
     1,
 };
 
diff --git a/dlls/windows.system.profile.systemmanufacturers/private.h b/dlls/windows.system.profile.systemmanufacturers/private.h
index e3672c3aec5..42c19710dcb 100644
--- a/dlls/windows.system.profile.systemmanufacturers/private.h
+++ b/dlls/windows.system.profile.systemmanufacturers/private.h
@@ -29,3 +29,41 @@
 
 #define WIDL_using_Windows_System_Profile_SystemManufacturers
 #include "windows.system.profile.systemmanufacturers.h"
+
+#define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
+    static inline impl_type *impl_from( iface_type *iface )                                        \
+    {                                                                                              \
+        return CONTAINING_RECORD( iface, impl_type, iface_mem );                                   \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_QueryInterface( iface_type *iface, REFIID iid, void **out )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_QueryInterface( (IInspectable *)(expr), iid, out );                    \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_AddRef( iface_type *iface )                                          \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_AddRef( (IInspectable *)(expr) );                                      \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_Release( iface_type *iface )                                         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_Release( (IInspectable *)(expr) );                                     \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetIids( iface_type *iface, ULONG *iid_count, IID **iids )         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetIids( (IInspectable *)(expr), iid_count, iids );                    \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetRuntimeClassName( iface_type *iface, HSTRING *class_name )      \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetRuntimeClassName( (IInspectable *)(expr), class_name );             \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetTrustLevel( iface_type *iface, TrustLevel *trust_level )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetTrustLevel( (IInspectable *)(expr), trust_level );                  \
+    }
+#define DEFINE_IINSPECTABLE( pfx, iface_type, impl_type, base_iface )                              \
+    DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, &impl->base_iface )
diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
index fa3308f21ab..e23a4d9adb7 100644
--- a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
@@ -45,6 +45,7 @@ static void check_interface_( unsigned int line, void *obj, const IID *iid )
 static void test_Smbios_Statics(void)
 {
     static const WCHAR *smbios_statics_name = L"Windows.System.Profile.SystemManufacturers.SmbiosInformation";
+    ISmbiosInformationStatics *smbios_statics;
     IActivationFactory *factory;
     HSTRING str;
     HRESULT hr;
@@ -66,6 +67,12 @@ static void test_Smbios_Statics(void)
     check_interface( factory, &IID_IInspectable );
     check_interface( factory, &IID_IAgileObject );
 
+    hr = IActivationFactory_QueryInterface( factory, &IID_ISmbiosInformationStatics, (void **)&smbios_statics );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    ref = ISmbiosInformationStatics_Release( smbios_statics );
+    ok( ref == 2, "got ref %ld.\n", ref );
+
     ref = IActivationFactory_Release( factory );
     ok( ref == 1, "got ref %ld.\n", ref );
 }
-- 
GitLab


From ef1f8b7ff12a791b1f38dd05c07763d2a41524c5 Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Mon, 28 Nov 2022 23:20:30 -0500
Subject: [PATCH 4/5] windows.system.profile.systemmanufacturers/tests: Add
 ISmbiosInformationStatics_get_SerialNumber tests.

---
 .../tests/smbios.c                               | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
index e23a4d9adb7..49e90216c42 100644
--- a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
@@ -47,8 +47,10 @@ static void test_Smbios_Statics(void)
     static const WCHAR *smbios_statics_name = L"Windows.System.Profile.SystemManufacturers.SmbiosInformation";
     ISmbiosInformationStatics *smbios_statics;
     IActivationFactory *factory;
-    HSTRING str;
+    HSTRING str, serial;
+    const WCHAR *buf;
     HRESULT hr;
+    UINT32 len;
     LONG ref;
 
     hr = WindowsCreateString( smbios_statics_name, wcslen( smbios_statics_name ), &str );
@@ -70,6 +72,18 @@ static void test_Smbios_Statics(void)
     hr = IActivationFactory_QueryInterface( factory, &IID_ISmbiosInformationStatics, (void **)&smbios_statics );
     ok( hr == S_OK, "got hr %#lx.\n", hr );
 
+    if (0) /* Win8 Crash */
+    {
+        hr = ISmbiosInformationStatics_get_SerialNumber( smbios_statics, &serial );
+        todo_wine ok( hr == S_OK || broken(hr == E_UNEXPECTED), "got hr %#lx.\n", hr );
+        if (hr == S_OK)
+        {
+            buf = WindowsGetStringRawBuffer( serial, &len );
+            todo_wine ok( buf != NULL && len > 0, "WindowsGetStringRawBuffer returned buf %p, len %u\n", buf, len );
+            WindowsDeleteString( serial );
+        }
+    }
+
     ref = ISmbiosInformationStatics_Release( smbios_statics );
     ok( ref == 2, "got ref %ld.\n", ref );
 
-- 
GitLab


From a02795ffcc9470e603d64f0e90e644a32142b6a5 Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Mon, 28 Nov 2022 23:22:34 -0500
Subject: [PATCH 5/5] windows.system.profile.systemmanufacturers: Implement
 ISmbiosInformationStatics_get_SerialNumber.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=53747
---
 .../Makefile.in                               |  2 +-
 .../main.c                                    | 62 ++++++++++++++++++-
 .../private.h                                 |  2 +
 .../tests/smbios.c                            |  4 +-
 4 files changed, 65 insertions(+), 5 deletions(-)

diff --git a/dlls/windows.system.profile.systemmanufacturers/Makefile.in b/dlls/windows.system.profile.systemmanufacturers/Makefile.in
index a2d6076740f..9d07caa287c 100644
--- a/dlls/windows.system.profile.systemmanufacturers/Makefile.in
+++ b/dlls/windows.system.profile.systemmanufacturers/Makefile.in
@@ -1,5 +1,5 @@
 MODULE  = windows.system.profile.systemmanufacturers.dll
-IMPORTS = combase
+IMPORTS = combase oleaut32
 
 C_SRCS = \
 	main.c
diff --git a/dlls/windows.system.profile.systemmanufacturers/main.c b/dlls/windows.system.profile.systemmanufacturers/main.c
index 35b4529ad7a..d2feb32054e 100644
--- a/dlls/windows.system.profile.systemmanufacturers/main.c
+++ b/dlls/windows.system.profile.systemmanufacturers/main.c
@@ -128,10 +128,68 @@ static const struct IActivationFactoryVtbl factory_vtbl =
 
 DEFINE_IINSPECTABLE( statics, ISmbiosInformationStatics, struct smbios_statics, IActivationFactory_iface )
 
+static HRESULT get_bios_serialnumber( BSTR *value )
+{
+    const WCHAR *class = L"Win32_BIOS";
+    IEnumWbemClassObject *wbem_enum;
+    IWbemClassObject *wbem_class;
+    IWbemServices *wbem_service;
+    IWbemLocator *wbem_locator;
+    VARIANT serial;
+    ULONG count;
+    HRESULT hr;
+    BSTR bstr;
+
+    hr = CoCreateInstance( &CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, (void**)&wbem_locator );
+    if (FAILED(hr)) return hr;
+
+    bstr = SysAllocString( L"ROOT\\CIMV2" );
+    if (!bstr)
+    {
+        IWbemLocator_Release( wbem_locator );
+        return E_OUTOFMEMORY;
+    }
+    hr = IWbemLocator_ConnectServer( wbem_locator, bstr, NULL, NULL, NULL, 0, NULL, NULL, &wbem_service );
+    IWbemLocator_Release( wbem_locator );
+    SysFreeString( bstr );
+    if (FAILED(hr)) return hr;
+
+    bstr = SysAllocString( class );
+    if (!bstr)
+    {
+        IWbemServices_Release( wbem_service );
+        return E_OUTOFMEMORY;
+    }
+    hr = IWbemServices_CreateInstanceEnum( wbem_service, bstr, WBEM_FLAG_SYSTEM_ONLY, NULL, &wbem_enum );
+    IWbemServices_Release( wbem_service );
+    SysFreeString( bstr );
+    if (FAILED(hr)) return hr;
+
+    hr = IEnumWbemClassObject_Next( wbem_enum, 1000, 1, &wbem_class, &count );
+    IEnumWbemClassObject_Release( wbem_enum );
+    if (FAILED(hr)) return hr;
+
+    hr = IWbemClassObject_Get( wbem_class, L"SerialNumber", 0, &serial, NULL, NULL );
+    IWbemClassObject_Release( wbem_class );
+    if (FAILED(hr)) return hr;
+
+    *value = V_BSTR( &serial );
+    VariantClear( &serial );
+    return hr;
+}
+
 static HRESULT WINAPI statics_get_SerialNumber( ISmbiosInformationStatics *iface, HSTRING *value )
 {
-    FIXME( "iface %p, value %p stub!\n", iface, value );
-    return E_NOTIMPL;
+    BSTR serial;
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (FAILED( hr = get_bios_serialnumber( &serial ) )) return hr;
+    if (FAILED( hr = WindowsCreateString( serial, wcslen(serial), value ) )) return hr;
+
+    TRACE( "Returning serial number: %s.\n", debugstr_w( serial ) );
+    return hr;
 }
 
 static const struct ISmbiosInformationStaticsVtbl statics_vtbl =
diff --git a/dlls/windows.system.profile.systemmanufacturers/private.h b/dlls/windows.system.profile.systemmanufacturers/private.h
index 42c19710dcb..374a2829130 100644
--- a/dlls/windows.system.profile.systemmanufacturers/private.h
+++ b/dlls/windows.system.profile.systemmanufacturers/private.h
@@ -30,6 +30,8 @@
 #define WIDL_using_Windows_System_Profile_SystemManufacturers
 #include "windows.system.profile.systemmanufacturers.h"
 
+#include "wbemcli.h"
+
 #define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
     static inline impl_type *impl_from( iface_type *iface )                                        \
     {                                                                                              \
diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
index 49e90216c42..8d02b2c423a 100644
--- a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
@@ -75,11 +75,11 @@ static void test_Smbios_Statics(void)
     if (0) /* Win8 Crash */
     {
         hr = ISmbiosInformationStatics_get_SerialNumber( smbios_statics, &serial );
-        todo_wine ok( hr == S_OK || broken(hr == E_UNEXPECTED), "got hr %#lx.\n", hr );
+        ok( hr == S_OK || broken(hr == E_UNEXPECTED), "got hr %#lx.\n", hr );
         if (hr == S_OK)
         {
             buf = WindowsGetStringRawBuffer( serial, &len );
-            todo_wine ok( buf != NULL && len > 0, "WindowsGetStringRawBuffer returned buf %p, len %u\n", buf, len );
+            ok( buf != NULL && len > 0, "WindowsGetStringRawBuffer returned buf %p, len %u\n", buf, len );
             WindowsDeleteString( serial );
         }
     }
-- 
GitLab

From 82010317528d56c623a3c4f243f43a94ddfc6b9d Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Wed, 23 Nov 2022 15:03:06 +0800
Subject: [PATCH] combase: Use SendMessageW() in
 ClientRpcChannelBuffer_SendReceive() for STAs.

An application has a thread 1 sending WM_DESTROY to windows in thread 2. When handling the message
in thread 2, RevokeDragDrop() is called to release a COM object in thread 1. Then deadlock happens
when using PostMessageW() because the DM_EXECUTERPC message will not be handled as thread 1 is still
waiting for thread 2 to finish handling WM_DESTROY.
---
 dlls/combase/rpc.c | 11 +----------
 1 file changed, 1 insertion(+), 10 deletions(-)

diff --git a/dlls/combase/rpc.c b/dlls/combase/rpc.c
index c51b59de4bf..1862c8bddca 100644
--- a/dlls/combase/rpc.c
+++ b/dlls/combase/rpc.c
@@ -1416,16 +1416,7 @@ static HRESULT WINAPI ClientRpcChannelBuffer_SendReceive(LPRPCCHANNELBUFFER ifac
 
         msg->ProcNum &= ~RPC_FLAGS_VALID_BIT;
 
-        if (!PostMessageW(message_state->target_hwnd, DM_EXECUTERPC, 0,
-                          (LPARAM)&message_state->params))
-        {
-            ERR("PostMessage failed with error %lu\n", GetLastError());
-
-            /* Note: message_state->params.iface doesn't have a reference and
-             * so doesn't need to be released */
-
-            hr = HRESULT_FROM_WIN32(GetLastError());
-        }
+        SendMessageW(message_state->target_hwnd, DM_EXECUTERPC, 0, (LPARAM)&message_state->params);
     }
     else
     {
-- 
GitLab

From e948fcce9ead52f955c1849c238040dce7cce250 Mon Sep 17 00:00:00 2001
From: Vladislav Timonin <timoninvlad@yandex.ru>
Date: Thu, 22 Dec 2022 02:41:17 +0700
Subject: [PATCH] comctl32/listview: Draw border and background separately in
 WM_NCPAINT.

Depending on the theme, if there was a header,
the border ends up painted lower than it should be,
and clipped by the header.
---
 dlls/comctl32/listview.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/dlls/comctl32/listview.c b/dlls/comctl32/listview.c
index 7c394d60273..13df8567c56 100644
--- a/dlls/comctl32/listview.c
+++ b/dlls/comctl32/listview.c
@@ -10701,6 +10701,7 @@ static LRESULT LISTVIEW_NCPaint(const LISTVIEW_INFO *infoPtr, HRGN region)
     HRGN cliprgn;
     int cxEdge = GetSystemMetrics (SM_CXEDGE),
         cyEdge = GetSystemMetrics (SM_CYEDGE);
+    DTBGOPTS dtbg_opts;
 
     if (!theme || !(exstyle & WS_EX_CLIENTEDGE))
        return DefWindowProcW (infoPtr->hwndSelf, WM_NCPAINT, (WPARAM)region, 0);
@@ -10713,17 +10714,24 @@ static LRESULT LISTVIEW_NCPaint(const LISTVIEW_INFO *infoPtr, HRGN region)
         CombineRgn (cliprgn, cliprgn, region, RGN_AND);
 
     OffsetRect(&r, -r.left, -r.top);
+
+    dc = GetDCEx(infoPtr->hwndSelf, region, DCX_WINDOW|DCX_INTERSECTRGN);
+
+    if (IsThemeBackgroundPartiallyTransparent (theme, 0, 0))
+        DrawThemeParentBackground(infoPtr->hwndSelf, dc, &r);
+
+    dtbg_opts.dwSize = sizeof(DTBGOPTS);
+    dtbg_opts.dwFlags = DTBG_OMITCONTENT;
+    DrawThemeBackgroundEx(theme, dc, 0, 0, &r, &dtbg_opts);
+
     if (infoPtr->hwndHeader && LISTVIEW_IsHeaderEnabled(infoPtr))
     {
         GetWindowRect(infoPtr->hwndHeader, &window_rect);
         r.top = min(r.bottom, r.top + window_rect.bottom - window_rect.top);
     }
+    dtbg_opts.dwFlags = DTBG_OMITBORDER;
+    DrawThemeBackgroundEx(theme, dc, 0, 0, &r, &dtbg_opts);
 
-    dc = GetDCEx(infoPtr->hwndSelf, region, DCX_WINDOW|DCX_INTERSECTRGN);
-
-    if (IsThemeBackgroundPartiallyTransparent (theme, 0, 0))
-        DrawThemeParentBackground(infoPtr->hwndSelf, dc, &r);
-    DrawThemeBackground (theme, dc, 0, 0, &r, 0);
     ReleaseDC(infoPtr->hwndSelf, dc);
 
     /* Call default proc to get the scrollbars etc. painted */
-- 
GitLab

From d7d94ed0df6931907d1c89d7d7551dd40f5214c5 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Fri, 3 Mar 2023 10:49:18 -0800
Subject: [PATCH] kernelbase: Implement DiscardVirtualMemory().

---
 dlls/kernel32/kernel32.spec     |  1 +
 dlls/kernelbase/kernelbase.spec |  2 +-
 dlls/kernelbase/memory.c        | 13 +++++++++++++
 include/memoryapi.h             |  1 +
 4 files changed, 16 insertions(+), 1 deletion(-)

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 47ff251067a..8da6321e8d0 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -371,6 +371,7 @@
 @ stdcall -import DeleteProcThreadAttributeList(ptr)
 # @ stub DisableThreadProfiling
 @ stdcall DisassociateCurrentThreadFromCallback(ptr) NTDLL.TpDisassociateCallback
+@ stdcall DiscardVirtualMemory(ptr long) kernelbase.DiscardVirtualMemory
 @ stdcall DeleteTimerQueue(long)
 @ stdcall -import DeleteTimerQueueEx(long long)
 @ stdcall -import DeleteTimerQueueTimer(long long long)
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index e3a0ad257f2..af3af8ecabe 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -269,7 +269,7 @@
 @ stdcall DisablePredefinedHandleTableInternal(long)
 @ stdcall DisableThreadLibraryCalls(long)
 @ stdcall DisassociateCurrentThreadFromCallback(ptr) ntdll.TpDisassociateCallback
-# @ stub DiscardVirtualMemory
+@ stdcall DiscardVirtualMemory(ptr long)
 @ stdcall DisconnectNamedPipe(long)
 @ stdcall DnsHostnameToComputerNameExW(wstr ptr ptr)
 # @ stub DsBindWithSpnExW
diff --git a/dlls/kernelbase/memory.c b/dlls/kernelbase/memory.c
index 4bcd4a639f6..a3ba79f3405 100644
--- a/dlls/kernelbase/memory.c
+++ b/dlls/kernelbase/memory.c
@@ -52,6 +52,19 @@ BOOLEAN WINAPI RtlSetUserValueHeap( HANDLE handle, ULONG flags, void *ptr, void
  ***********************************************************************/
 
 
+/***********************************************************************
+ *             DiscardVirtualMemory   (kernelbase.@)
+ */
+DWORD WINAPI DECLSPEC_HOTPATCH DiscardVirtualMemory( void *addr, SIZE_T size )
+{
+    NTSTATUS status;
+    LPVOID ret = addr;
+
+    status = NtAllocateVirtualMemory( GetCurrentProcess(), &ret, 0, &size, MEM_RESET, PAGE_NOACCESS );
+    return RtlNtStatusToDosError( status );
+}
+
+
 /***********************************************************************
  *             FlushViewOfFile   (kernelbase.@)
  */
diff --git a/include/memoryapi.h b/include/memoryapi.h
index 8743e67927c..6728b832fa7 100644
--- a/include/memoryapi.h
+++ b/include/memoryapi.h
@@ -41,5 +41,6 @@ typedef struct WIN32_MEMORY_REGION_INFORMATION
     SIZE_T CommitSize;
 } WIN32_MEMORY_REGION_INFORMATION;
 
+DWORD WINAPI DiscardVirtualMemory(void *addr, SIZE_T size);
 BOOL WINAPI QueryVirtualMemoryInformation(HANDLE process,const void *addr,
         WIN32_MEMORY_INFORMATION_CLASS info_class, void *info, SIZE_T size, SIZE_T *ret_size);
-- 
GitLab
