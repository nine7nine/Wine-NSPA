From 2832bd0d6d46372e9f7053e225f9c3c7e518200f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 18 Dec 2020 12:13:19 +0100
Subject: [PATCH 5/6] server: Use setpriority to update thread niceness when
 safe.

---
 configure.ac    | 10 ++++++++++
 server/main.c   |  1 +
 server/object.h |  4 ++++
 server/thread.c | 49 +++++++++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 64 insertions(+)

diff --git a/configure.ac b/configure.ac
index a8dbcb0795f..9a5f2152562 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2046,6 +2046,16 @@ then
   AC_DEFINE(HAVE_SCHED_SETAFFINITY, 1, [Define to 1 if you have the `sched_setaffinity' function.])
 fi
 
+AC_CACHE_CHECK([for setpriority],wine_cv_have_setpriority,
+                AC_LINK_IFELSE([AC_LANG_PROGRAM(
+[[#define _GNU_SOURCE
+#include <sys/resource.h>
+#include <sys/time.h>]], [[setpriority(0, 0, 0);]])],[wine_cv_have_setpriority=yes],[wine_cv_have_setpriority=no]))
+if test "$wine_cv_have_setpriority" = "yes"
+then
+  AC_DEFINE(HAVE_SETPRIORITY, 1, [Define to 1 if you have the `setpriority' function.])
+fi
+
 dnl **** Check for types ****
 
 AC_C_INLINE
diff --git a/server/main.c b/server/main.c
index 4021d55d52c..b9357e23941 100644
--- a/server/main.c
+++ b/server/main.c
@@ -233,6 +233,7 @@ int main( int argc, char *argv[] )
     set_current_time();
     init_signals();
     init_directories( load_intl_file() );
+    init_threading();
     init_registry();
     main_loop();
     return 0;
diff --git a/server/object.h b/server/object.h
index f156f1d2f13..5a1cd9f5c95 100644
--- a/server/object.h
+++ b/server/object.h
@@ -277,6 +277,10 @@ extern struct object *get_directory_obj( struct process *process, obj_handle_t h
 extern int directory_link_name( struct object *obj, struct object_name *name, struct object *parent );
 extern void init_directories( struct fd *intl_fd );
 
+/* thread functions */
+
+extern void init_threading(void);
+
 /* symbolic link functions */
 
 extern struct object *create_root_symlink( struct object *root, const struct unicode_str *name,
diff --git a/server/thread.c b/server/thread.c
index fc37852533f..521b371530c 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -224,6 +224,23 @@ static const struct fd_ops thread_fd_ops =
 };
 
 static struct list thread_list = LIST_INIT(thread_list);
+static int nice_limit;
+
+void init_threading(void)
+{
+#ifdef RLIMIT_NICE
+    struct rlimit rlimit;
+    if (!getrlimit( RLIMIT_NICE, &rlimit ))
+    {
+        rlimit.rlim_cur = rlimit.rlim_max;
+        setrlimit( RLIMIT_NICE, &rlimit );
+        if (rlimit.rlim_max <= 40) nice_limit = 20 - rlimit.rlim_max;
+        else if (rlimit.rlim_max == -1) nice_limit = -20;
+        if (nice_limit >= 0) fprintf(stderr, "wine: RLIMIT_NICE is <= 20, unable to use setpriority safely\n");
+    }
+#endif
+    //if (nice_limit < 0) fprintf(stderr, "wine: Using setpriority to control niceness in the [%d,%d] range\n", nice_limit, -nice_limit );
+}
 
 /* initialize the structure for a newly allocated thread */
 static inline void init_thread_structure( struct thread *thread )
@@ -616,6 +633,21 @@ affinity_t get_thread_affinity( struct thread *thread )
     return mask;
 }
 
+static int get_base_priority( int priority_class, int priority )
+{
+    static const int class_offsets[] = { 4, 8, 13, 24, 6, 10 };
+    assert(priority_class <= ARRAY_SIZE(class_offsets));
+    if (priority == THREAD_PRIORITY_IDLE) return (priority_class == PROCESS_PRIOCLASS_REALTIME ? 16 : 1);
+    else if (priority == THREAD_PRIORITY_TIME_CRITICAL) return (priority_class == PROCESS_PRIOCLASS_REALTIME ? 31 : 15);
+    else return class_offsets[priority_class - 1] + priority;
+}
+
+static int get_unix_niceness( int base_priority, int limit )
+{
+    int min = -limit, max = limit, range = max - min;
+    return min + (base_priority - 1) * range / 14;
+}
+
 #define THREAD_PRIORITY_REALTIME_HIGHEST 6
 #define THREAD_PRIORITY_REALTIME_LOWEST -7
 
@@ -630,6 +662,8 @@ static void delayed_set_thread_priority( void *private )
 
 static void apply_thread_priority( struct thread *thread, int priority_class, int priority, int delayed )
 {
+    int niceness, limit = min( nice_limit, thread->process->nice_limit );
+
     if (!delayed && thread->delay_priority) remove_timeout_user( thread->delay_priority );
     thread->delay_priority = NULL;
 
@@ -638,6 +672,21 @@ static void apply_thread_priority( struct thread *thread, int priority_class, in
         thread->delay_priority = add_timeout_user( -TICKS_PER_SEC, delayed_set_thread_priority, thread );
         return;
     }
+
+    /* FIXME: handle REALTIME class using SCHED_RR if possible, for now map it to HIGH */
+    if (priority_class == PROCESS_PRIOCLASS_REALTIME) priority_class = PROCESS_PRIOCLASS_HIGH;
+
+#ifdef __linux__
+#ifdef HAVE_SETPRIORITY
+    if (limit < 0)
+    {
+        niceness = get_unix_niceness( get_base_priority( priority_class, priority ), limit );
+        if (setpriority( PRIO_PROCESS, thread->unix_tid, niceness ) != 0)
+            fprintf( stderr, "wine: setpriority %d for pid %d failed: %d\n", niceness, thread->unix_tid, errno );
+        return;
+    }
+#endif
+#endif
 }
 
 int set_thread_priority( struct thread *thread, int priority_class, int priority )

