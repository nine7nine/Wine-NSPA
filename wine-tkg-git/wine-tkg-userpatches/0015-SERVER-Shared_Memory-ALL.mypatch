From 5afe6de435796ffe23be98efde2c63deca1ad436 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 6 Mar 2021 00:05:36 +0100
Subject: [PATCH 01/44] server: Create a desktop shared mapping.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/directory.c  | 17 +++++++++++++++++
 server/file.h       |  6 ++++++
 server/mapping.c    | 19 ++++++++++++++++++-
 server/protocol.def |  5 +++++
 server/user.h       | 28 +++++++++++++++-------------
 server/winstation.c | 22 ++++++++++++++++++++++
 6 files changed, 83 insertions(+), 14 deletions(-)

diff --git a/server/directory.c b/server/directory.c
index 11111111111..11111111111 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -37,6 +37,7 @@
 #include "process.h"
 #include "file.h"
 #include "unicode.h"
+#include "user.h"
 
 #define HASH_SIZE 7  /* default hash size */
 
@@ -283,6 +284,22 @@ struct object *get_directory_obj( struct process *process, obj_handle_t handle )
     return get_handle_obj( process, handle, 0, &directory_ops );
 }
 
+struct object *create_desktop_map_directory( struct winstation *winstation )
+{
+    static const WCHAR dir_desktop_mapsW[] = {'_','_','w','i','n','e','_','d','e','s','k','t','o','p','_','m','a','p','p','i','n','g','s'};
+    static const struct unicode_str dir_desktop_maps_str = {dir_desktop_mapsW, sizeof(dir_desktop_mapsW)};
+    struct object *root;
+    struct directory *mapping_root, *ret;
+    const struct unicode_str winsta_name = {winstation->obj.name->name, winstation->obj.name->len};
+
+    root = winstation->obj.name->parent;
+    mapping_root = create_directory( root, &dir_desktop_maps_str, OBJ_OPENIF, HASH_SIZE, NULL );
+    ret = create_directory( &mapping_root->obj, &winsta_name, OBJ_OPENIF, HASH_SIZE, NULL );
+    release_object( &mapping_root->obj );
+
+    return &ret->obj;
+}
+
 /* Global initialization */
 
 static void create_session( unsigned int id )
diff --git a/server/file.h b/server/file.h
index 11111111111..11111111111 100644
--- a/server/file.h
+++ b/server/file.h
@@ -167,6 +167,10 @@ extern struct timeout_user *add_timeout_user( timeout_t when, timeout_callback f
 extern void remove_timeout_user( struct timeout_user *user );
 extern const char *get_timeout_str( timeout_t timeout );
 
+/* directory functions */
+
+extern struct object *create_desktop_map_directory( struct winstation *winstation );
+
 /* file functions */
 
 extern struct file *get_file_obj( struct process *process, obj_handle_t handle,
@@ -201,6 +205,8 @@ extern struct object *create_user_data_mapping( struct object *root, const struc
                                                 unsigned int attr, const struct security_descriptor *sd );
 extern struct object *create_hypervisor_data_mapping( struct object *root, const struct unicode_str *name,
                                                       unsigned int attr, const struct security_descriptor *sd );
+extern struct object *create_shared_mapping( struct object *root, const struct unicode_str *name,
+                                             mem_size_t size, const struct security_descriptor *sd, void **ptr );
 
 /* device functions */
 
diff --git a/server/mapping.c b/server/mapping.c
index 11111111111..11111111111 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -1107,7 +1107,7 @@ int get_page_size(void)
 }
 
 struct object *create_user_data_mapping( struct object *root, const struct unicode_str *name,
-                                        unsigned int attr, const struct security_descriptor *sd )
+                                         unsigned int attr, const struct security_descriptor *sd )
 {
     void *ptr;
     struct mapping *mapping;
@@ -1137,6 +1137,23 @@ struct object *create_hypervisor_data_mapping( struct object *root, const struct
     return &mapping->obj;
 }
 
+struct object *create_shared_mapping( struct object *root, const struct unicode_str *name,
+                                      mem_size_t size, const struct security_descriptor *sd, void **ptr )
+{
+    struct mapping *mapping;
+
+    if (!(mapping = create_mapping( root, name, OBJ_OPENIF, size, SEC_COMMIT, 0,
+                                    FILE_READ_DATA | FILE_WRITE_DATA, sd ))) return NULL;
+    *ptr = mmap( NULL, mapping->size, PROT_WRITE, MAP_SHARED, get_unix_fd( mapping->fd ), 0 );
+    if (*ptr == MAP_FAILED)
+    {
+        release_object( &mapping->obj );
+        return NULL;
+    }
+
+    return &mapping->obj;
+}
+
 /* create a file mapping */
 DECL_HANDLER(create_mapping)
 {
diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -853,6 +853,11 @@ struct cpu_topology_override
     unsigned char host_cpu_id[64];
 };
 
+struct desktop_shared_memory
+{
+    int placeholder;
+};
+
 /****************************************************************/
 /* Request declarations */
 
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -64,19 +64,21 @@ struct global_cursor
 
 struct desktop
 {
-    struct object        obj;              /* object header */
-    unsigned int         flags;            /* desktop flags */
-    struct winstation   *winstation;       /* winstation this desktop belongs to */
-    struct list          entry;            /* entry in winstation list of desktops */
-    struct window       *top_window;       /* desktop window for this desktop */
-    struct window       *msg_window;       /* HWND_MESSAGE top window */
-    struct hook_table   *global_hooks;     /* table of global hooks on this desktop */
-    struct list          hotkeys;          /* list of registered hotkeys */
-    struct timeout_user *close_timeout;    /* timeout before closing the desktop */
-    struct thread_input *foreground_input; /* thread input of foreground thread */
-    unsigned int         users;            /* processes and threads using this desktop */
-    struct global_cursor cursor;           /* global cursor information */
-    unsigned char        keystate[256];    /* asynchronous key state */
+    struct object                          obj;              /* object header */
+    unsigned int                           flags;            /* desktop flags */
+    struct winstation                     *winstation;       /* winstation this desktop belongs to */
+    struct list                            entry;            /* entry in winstation list of desktops */
+    struct window                         *top_window;       /* desktop window for this desktop */
+    struct window                         *msg_window;       /* HWND_MESSAGE top window */
+    struct hook_table                     *global_hooks;     /* table of global hooks on this desktop */
+    struct list                            hotkeys;          /* list of registered hotkeys */
+    struct timeout_user                   *close_timeout;    /* timeout before closing the desktop */
+    struct thread_input                   *foreground_input; /* thread input of foreground thread */
+    unsigned int                           users;            /* processes and threads using this desktop */
+    struct global_cursor                   cursor;           /* global cursor information */
+    struct object                         *shared_mapping;   /* desktop shared memory mapping */
+    volatile struct desktop_shared_memory *shared;           /* desktop shared memory ptr */
+    unsigned char                          keystate[256];    /* asynchronous key state */
 };
 
 /* user handles functions */
diff --git a/server/winstation.c b/server/winstation.c
index 11111111111..11111111111 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -222,6 +222,22 @@ struct desktop *get_desktop_obj( struct process *process, obj_handle_t handle, u
     return (struct desktop *)get_handle_obj( process, handle, access, &desktop_ops );
 }
 
+static volatile void *init_desktop_mapping( struct desktop *desktop, const struct unicode_str *name )
+{
+    struct object *dir = create_desktop_map_directory( desktop->winstation );
+
+    desktop->shared = NULL;
+    desktop->shared_mapping = NULL;
+
+    if (!dir) return NULL;
+
+    desktop->shared_mapping = create_shared_mapping( dir, name, sizeof(struct desktop_shared_memory),
+                                                     NULL, (void **)&desktop->shared );
+    release_object( dir );
+    if (desktop->shared) memset( (void *)desktop->shared, 0, sizeof(*desktop->shared) );
+    return desktop->shared;
+}
+
 /* create a desktop object */
 static struct desktop *create_desktop( const struct unicode_str *name, unsigned int attr,
                                        unsigned int flags, struct winstation *winstation )
@@ -245,6 +261,11 @@ static struct desktop *create_desktop( const struct unicode_str *name, unsigned
             memset( desktop->keystate, 0, sizeof(desktop->keystate) );
             list_add_tail( &winstation->desktops, &desktop->entry );
             list_init( &desktop->hotkeys );
+            if (!init_desktop_mapping( desktop, name ))
+            {
+                release_object( desktop );
+                return NULL;
+            }
         }
         else clear_error();
     }
@@ -298,6 +319,7 @@ static void desktop_destroy( struct object *obj )
     if (desktop->global_hooks) release_object( desktop->global_hooks );
     if (desktop->close_timeout) remove_timeout_user( desktop->close_timeout );
     list_remove( &desktop->entry );
+    release_object( desktop->shared_mapping );
     release_object( desktop->winstation );
 }
 

From 190c4318f084935ec756d0e9f545e70878ea4127 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Mon, 29 Jun 2020 11:12:12 +0100
Subject: [PATCH 02/44] server: Use the helper to update the cursor last change
 time.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/queue.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -1895,7 +1895,7 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         WM_MOUSEHWHEEL   /* 0x1000 = MOUSEEVENTF_HWHEEL */
     };
 
-    desktop->cursor.last_change = get_tick_count();
+    update_desktop_cursor_pos( desktop, desktop->cursor.x, desktop->cursor.y ); /* Update last change time */
     flags = input->mouse.flags;
     time  = input->mouse.time;
     if (!time) time = desktop->cursor.last_change;

From ca63abe8cd0110b9421dfd08c570b217356c482e Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Mon, 29 Jun 2020 11:30:14 +0100
Subject: [PATCH 03/44] server: Move the cursor position and last change time
 to the shared data.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/protocol.def |  9 ++++++-
 server/queue.c      | 58 ++++++++++++++++++++++-----------------------
 server/user.h       |  3 ---
 3 files changed, 37 insertions(+), 33 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -853,9 +853,16 @@ struct cpu_topology_override
     unsigned char host_cpu_id[64];
 };
 
+struct shared_cursor
+{
+    int                  x;                /* cursor position */
+    int                  y;
+    unsigned int         last_change;      /* time of last position change */
+};
+
 struct desktop_shared_memory
 {
-    int placeholder;
+    struct shared_cursor cursor;           /* global cursor information */
 };
 
 /****************************************************************/
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -440,10 +440,10 @@ static int update_desktop_cursor_pos( struct desktop *desktop, int x, int y )
 
     x = max( min( x, desktop->cursor.clip.right - 1 ), desktop->cursor.clip.left );
     y = max( min( y, desktop->cursor.clip.bottom - 1 ), desktop->cursor.clip.top );
-    updated = (desktop->cursor.x != x || desktop->cursor.y != y);
-    desktop->cursor.x = x;
-    desktop->cursor.y = y;
-    desktop->cursor.last_change = get_tick_count();
+    updated = (desktop->shared->cursor.x != x || desktop->shared->cursor.y != y);
+    desktop->shared->cursor.x = x;
+    desktop->shared->cursor.y = y;
+    desktop->shared->cursor.last_change = get_tick_count();
 
     return updated;
 }
@@ -474,8 +474,8 @@ static void get_message_defaults( struct msg_queue *queue, int *x, int *y, unsig
 {
     struct desktop *desktop = queue->input->desktop;
 
-    *x = desktop->cursor.x;
-    *y = desktop->cursor.y;
+    *x = desktop->shared->cursor.x;
+    *y = desktop->shared->cursor.y;
     *time = get_tick_count();
 }
 
@@ -502,9 +502,9 @@ static void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect
         post_desktop_message( desktop, desktop->cursor.clip_msg, rect != NULL, 0 );
 
     /* warp the mouse to be inside the clip rect */
-    x = max( min( desktop->cursor.x, desktop->cursor.clip.right - 1 ), desktop->cursor.clip.left );
-    y = max( min( desktop->cursor.y, desktop->cursor.clip.bottom - 1 ), desktop->cursor.clip.top );
-    if (x != desktop->cursor.x || y != desktop->cursor.y) set_cursor_pos( desktop, x, y );
+    x = max( min( desktop->shared->cursor.x, desktop->cursor.clip.right - 1 ), desktop->cursor.clip.left );
+    y = max( min( desktop->shared->cursor.y, desktop->cursor.clip.bottom - 1 ), desktop->cursor.clip.top );
+    if (x != desktop->shared->cursor.x || y != desktop->shared->cursor.y) set_cursor_pos( desktop, x, y );
 }
 
 /* change the foreground input and reset the cursor clip rect */
@@ -1701,8 +1701,8 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
         if (desktop->keystate[VK_XBUTTON1] & 0x80) msg->wparam |= MK_XBUTTON1;
         if (desktop->keystate[VK_XBUTTON2] & 0x80) msg->wparam |= MK_XBUTTON2;
     }
-    msg->x = desktop->cursor.x;
-    msg->y = desktop->cursor.y;
+    msg->x = desktop->shared->cursor.x;
+    msg->y = desktop->shared->cursor.y;
 
     if (msg->win && (thread = get_window_thread( msg->win )))
     {
@@ -1895,10 +1895,10 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         WM_MOUSEHWHEEL   /* 0x1000 = MOUSEEVENTF_HWHEEL */
     };
 
-    update_desktop_cursor_pos( desktop, desktop->cursor.x, desktop->cursor.y ); /* Update last change time */
+    update_desktop_cursor_pos( desktop, desktop->shared->cursor.x, desktop->shared->cursor.y ); /* Update last change time */
     flags = input->mouse.flags;
     time  = input->mouse.time;
-    if (!time) time = desktop->cursor.last_change;
+    if (!time) time = desktop->shared->cursor.last_change;
 
     if (flags & MOUSEEVENTF_MOVE)
     {
@@ -1907,19 +1907,19 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
             x = input->mouse.x;
             y = input->mouse.y;
             if (flags & ~(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE) &&
-                x == desktop->cursor.x && y == desktop->cursor.y)
+                x == desktop->shared->cursor.x && y == desktop->shared->cursor.y)
                 flags &= ~MOUSEEVENTF_MOVE;
         }
         else
         {
-            x = desktop->cursor.x + input->mouse.x;
-            y = desktop->cursor.y + input->mouse.y;
+            x = desktop->shared->cursor.x + input->mouse.x;
+            y = desktop->shared->cursor.y + input->mouse.y;
         }
     }
     else
     {
-        x = desktop->cursor.x;
-        y = desktop->cursor.y;
+        x = desktop->shared->cursor.x;
+        y = desktop->shared->cursor.y;
     }
 
     if ((req_flags & SEND_HWMSG_RAWINPUT) && (foreground = get_foreground_thread( desktop, win )))
@@ -2168,8 +2168,8 @@ static void queue_custom_hardware_message( struct desktop *desktop, user_handle_
     msg->msg       = input->hw.msg;
     msg->wparam    = 0;
     msg->lparam    = input->hw.lparam;
-    msg->x         = desktop->cursor.x;
-    msg->y         = desktop->cursor.y;
+    msg->x         = desktop->shared->cursor.x;
+    msg->y         = desktop->shared->cursor.y;
 
     queue_hardware_message( desktop, msg, 1 );
 }
@@ -2707,8 +2707,8 @@ DECL_HANDLER(send_hardware_message)
         }
     }
 
-    reply->prev_x = desktop->cursor.x;
-    reply->prev_y = desktop->cursor.y;
+    reply->prev_x = desktop->shared->cursor.x;
+    reply->prev_y = desktop->shared->cursor.y;
 
     switch (req->input.type)
     {
@@ -2726,8 +2726,8 @@ DECL_HANDLER(send_hardware_message)
     }
     if (thread) release_object( thread );
 
-    reply->new_x = desktop->cursor.x;
-    reply->new_y = desktop->cursor.y;
+    reply->new_x = desktop->shared->cursor.x;
+    reply->new_y = desktop->shared->cursor.y;
     set_reply_data( desktop->keystate, size );
     release_object( desktop );
 }
@@ -3441,8 +3441,8 @@ DECL_HANDLER(set_cursor)
 
     reply->prev_handle = input->cursor;
     reply->prev_count  = input->cursor_count;
-    reply->prev_x      = input->desktop->cursor.x;
-    reply->prev_y      = input->desktop->cursor.y;
+    reply->prev_x      = input->desktop->shared->cursor.x;
+    reply->prev_y      = input->desktop->shared->cursor.y;
 
     if (req->flags & SET_CURSOR_HANDLE)
     {
@@ -3473,10 +3473,10 @@ DECL_HANDLER(set_cursor)
         set_clip_rectangle( desktop, (req->flags & SET_CURSOR_NOCLIP) ? NULL : &req->clip, 0 );
     }
 
-    reply->new_x       = input->desktop->cursor.x;
-    reply->new_y       = input->desktop->cursor.y;
+    reply->new_x       = input->desktop->shared->cursor.x;
+    reply->new_y       = input->desktop->shared->cursor.y;
     reply->new_clip    = input->desktop->cursor.clip;
-    reply->last_change = input->desktop->cursor.last_change;
+    reply->last_change = input->desktop->shared->cursor.last_change;
 }
 
 /* Get the history of the 64 last cursor positions */
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -54,11 +54,8 @@ struct winstation
 
 struct global_cursor
 {
-    int                  x;                /* cursor position */
-    int                  y;
     rectangle_t          clip;             /* cursor clip rectangle */
     unsigned int         clip_msg;         /* message to post for cursor clip changes */
-    unsigned int         last_change;      /* time of last position change */
     user_handle_t        win;              /* window that contains the cursor */
 };
 

From e94799cae183654611e931cea0f7555729840621 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Mon, 29 Jun 2020 12:57:39 +0100
Subject: [PATCH 04/44] server: Add a sequence number to the shared data.

The client should check that the lower SEQUENCE_MASK_BITS are zero before
reading the data and confirm that the number is unchanged when it's finished.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/protocol.def |  5 +++++
 server/queue.c      | 46 ++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 50 insertions(+), 1 deletion(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -862,9 +862,14 @@ struct shared_cursor
 
 struct desktop_shared_memory
 {
+    unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     struct shared_cursor cursor;           /* global cursor information */
 };
 
+/* Bits that must be clear for client to read */
+#define SEQUENCE_MASK_BITS  4
+#define SEQUENCE_MASK ((1UL << SEQUENCE_MASK_BITS) - 1)
+
 /****************************************************************/
 /* Request declarations */
 
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -434,16 +434,60 @@ static struct message *alloc_hardware_message( lparam_t info, struct hw_msg_sour
     return msg;
 }
 
+#if defined(__i386__) || defined(__x86_64__)
+
+#define SHARED_WRITE_BEGIN( x )                                  \
+    do {                                                         \
+        volatile unsigned int __seq = *(x);                      \
+        assert( (__seq & SEQUENCE_MASK) != SEQUENCE_MASK );      \
+        *(x) = ++__seq;                                          \
+    } while(0)
+
+#define SHARED_WRITE_END( x )                                    \
+    do {                                                         \
+        volatile unsigned int __seq = *(x);                      \
+        assert( (__seq & SEQUENCE_MASK) != 0 );                  \
+        if ((__seq & SEQUENCE_MASK) > 1) __seq--;                \
+        else __seq += SEQUENCE_MASK;                             \
+        *(x) = __seq;                                            \
+    } while(0)
+
+#else
+
+#define SHARED_WRITE_BEGIN( x )                                         \
+    do {                                                                \
+        assert( (*(x) & SEQUENCE_MASK) != SEQUENCE_MASK );              \
+        if ((__atomic_add_fetch( x, 1, __ATOMIC_RELAXED ) & SEQUENCE_MASK) == 1) \
+            __atomic_thread_fence( __ATOMIC_RELEASE );                  \
+    } while(0)
+
+#define SHARED_WRITE_END( x )                                           \
+    do {                                                                \
+        assert( (*(x) & SEQUENCE_MASK) != 0 );                          \
+        if ((*(x) & SEQUENCE_MASK) > 1)                                 \
+            __atomic_sub_fetch( x, 1, __ATOMIC_RELAXED );               \
+        else {                                                          \
+            __atomic_thread_fence( __ATOMIC_RELEASE );                  \
+            __atomic_add_fetch( x, SEQUENCE_MASK, __ATOMIC_RELAXED );   \
+        }                                                               \
+    } while(0)
+
+#endif
+
 static int update_desktop_cursor_pos( struct desktop *desktop, int x, int y )
 {
     int updated;
+    unsigned int time = get_tick_count();
 
     x = max( min( x, desktop->cursor.clip.right - 1 ), desktop->cursor.clip.left );
     y = max( min( y, desktop->cursor.clip.bottom - 1 ), desktop->cursor.clip.top );
     updated = (desktop->shared->cursor.x != x || desktop->shared->cursor.y != y);
+
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
     desktop->shared->cursor.x = x;
     desktop->shared->cursor.y = y;
-    desktop->shared->cursor.last_change = get_tick_count();
+    desktop->shared->cursor.last_change = time;
+    SHARED_WRITE_END( &desktop->shared->seq );
 
     return updated;
 }

From c687ba0ba20a7352ec8913308d9784f41a9c92f4 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 11:24:53 +0100
Subject: [PATCH 05/44] win32u: Use the desktop shared data for GetCursorPos().

---
 dlls/win32u/input.c          | 20 +++++-----
 dlls/win32u/ntuser_private.h |  2 +
 dlls/win32u/sysparams.c      |  7 ++++
 dlls/win32u/win32u_private.h | 23 ++++++++++++
 dlls/win32u/winstation.c     | 72 ++++++++++++++++++++++++++++++++++++
 5 files changed, 113 insertions(+), 11 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -113,25 +113,23 @@ BOOL WINAPI NtUserSetCursorPos( INT x, INT y )
  */
 BOOL get_cursor_pos( POINT *pt )
 {
-    BOOL ret;
+    BOOL ret = TRUE;
     DWORD last_change;
     UINT dpi;
+    volatile struct desktop_shared_memory *shared = get_desktop_shared_memory();
 
-    if (!pt) return FALSE;
+    if (!pt || !shared) return FALSE;
 
-    SERVER_START_REQ( set_cursor )
+    SHARED_READ_BEGIN( &shared->seq )
     {
-        if ((ret = !wine_server_call( req )))
-        {
-            pt->x = reply->new_x;
-            pt->y = reply->new_y;
-            last_change = reply->last_change;
-        }
+        pt->x = shared->cursor.x;
+        pt->y = shared->cursor.y;
+        last_change = shared->cursor.last_change;
     }
-    SERVER_END_REQ;
+    SHARED_READ_END( &shared->seq );
 
     /* query new position from graphics driver if we haven't updated recently */
-    if (ret && NtGetTickCount() - last_change > 100) ret = user_driver->pGetCursorPos( pt );
+    if (NtGetTickCount() - last_change > 100) ret = user_driver->pGetCursorPos( pt );
     if (ret && (dpi = get_thread_dpi()))
     {
         HMONITOR monitor = monitor_from_point( *pt, MONITOR_DEFAULTTOPRIMARY, 0 );
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -161,6 +161,8 @@ struct user_thread_info
     HWND                          msg_window;             /* HWND_MESSAGE parent window */
     struct rawinput_thread_data  *rawinput;               /* RawInput thread local data / buffer */
     UINT                          spy_indent;             /* Current spy indent */
+    HANDLE                        desktop_shared_map;     /* HANDLE to server's desktop shared memory */
+    struct desktop_shared_memory *desktop_shared_memory;  /* Ptr to server's desktop shared memory */
 };
 
 C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo) );
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4613,6 +4613,13 @@ static void thread_detach(void)
     destroy_thread_windows();
     NtClose( thread_info->server_queue );
 
+    if (thread_info->desktop_shared_map)
+    {
+        NtClose( thread_info->desktop_shared_map );
+        thread_info->desktop_shared_map = NULL;
+        thread_info->desktop_shared_memory = NULL;
+    }
+
     exiting_thread_id = 0;
 }
 
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -408,6 +408,9 @@ static inline void release_win_ptr( struct tagWND *ptr )
     user_unlock();
 }
 
+/* winstation.c */
+extern volatile struct desktop_shared_memory *get_desktop_shared_memory( void ) DECLSPEC_HIDDEN;
+
 extern void wrappers_init( unixlib_handle_t handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS gdi_init(void) DECLSPEC_HIDDEN;
 extern NTSTATUS callbacks_init( void *args ) DECLSPEC_HIDDEN;
@@ -587,4 +590,24 @@ static inline const char *debugstr_us( const UNICODE_STRING *us )
     return debugstr_wn( us->Buffer, us->Length / sizeof(WCHAR) );
 }
 
+#if defined(__i386__) || defined(__x86_64__)
+#define __SHARED_READ_SEQ( x ) (*(x))
+#define __SHARED_READ_FENCE do {} while(0)
+#else
+#define __SHARED_READ_SEQ( x ) __atomic_load_n( x, __ATOMIC_RELAXED )
+#define __SHARED_READ_FENCE __atomic_thread_fence( __ATOMIC_ACQUIRE )
+#endif
+
+#define SHARED_READ_BEGIN( x )                                          \
+    do {                                                                \
+        unsigned int __seq;                                             \
+        do {                                                            \
+            while ((__seq = __SHARED_READ_SEQ( x )) & SEQUENCE_MASK) NtYieldExecution(); \
+            __SHARED_READ_FENCE;
+
+#define SHARED_READ_END( x )                       \
+            __SHARED_READ_FENCE;                   \
+        } while (__SHARED_READ_SEQ( x ) != __seq); \
+    } while(0)
+
 #endif /* __WINE_WIN32U_PRIVATE */
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -242,6 +242,12 @@ BOOL WINAPI NtUserSetThreadDesktop( HDESK handle )
         thread_info->top_window = 0;
         thread_info->msg_window = 0;
         if (key_state_info) key_state_info->time = 0;
+        if (thread_info->desktop_shared_map)
+        {
+            NtClose( thread_info->desktop_shared_map );
+            thread_info->desktop_shared_map = NULL;
+            thread_info->desktop_shared_memory = NULL;
+        }
     }
     return ret;
 }
@@ -566,6 +572,72 @@ static const WCHAR *get_default_desktop( void *buf, size_t buf_size )
     return defaultW;
 }
 
+
+static void map_shared_memory_section( const WCHAR *name, SIZE_T size, HANDLE root, HANDLE *handle, void **ptr )
+{
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING section_str;
+    NTSTATUS status;
+
+    section_str.Length = wcslen(name) * sizeof(WCHAR);
+    section_str.MaximumLength = section_str.Length + sizeof(WCHAR);
+    section_str.Buffer = (WCHAR *)name;
+    InitializeObjectAttributes( &attr, &section_str, 0, root, NULL );
+    status = NtOpenSection( handle, SECTION_ALL_ACCESS, &attr );
+    if (status)
+    {
+        ERR( "failed to open section %s: %08x\n", debugstr_w(name), status );
+        *ptr = NULL;
+        *handle = NULL;
+        return;
+    }
+
+    *ptr = NULL;
+    status = NtMapViewOfSection( *handle, GetCurrentProcess(), ptr, 0, 0, NULL,
+                                 &size, ViewUnmap, 0, PAGE_READONLY );
+    if (status)
+    {
+        ERR( "failed to map view of section %s: %08x\n", debugstr_w(name), status );
+        NtClose( *handle );
+        *ptr = NULL;
+        *handle = NULL;
+    }
+}
+
+
+volatile struct desktop_shared_memory *get_desktop_shared_memory( void )
+{
+    static const WCHAR dir_desktop_mapsW[] = {'_','_','w','i','n','e','_','d','e','s','k','t','o','p','_','m','a','p','p','i','n','g','s','\\',0};
+    struct user_thread_info *thread_info = get_user_thread_info();
+    HANDLE root, handles[2];
+    WCHAR buf[MAX_PATH], *ptr;
+    DWORD i, needed;
+
+    if (thread_info->desktop_shared_memory) return thread_info->desktop_shared_memory;
+
+    root = get_winstations_dir_handle();
+
+    handles[0] = NtUserGetProcessWindowStation();
+    handles[1] = NtUserGetThreadDesktop( GetCurrentThreadId() );
+
+    memcpy( buf, dir_desktop_mapsW, sizeof(dir_desktop_mapsW) );
+    ptr = buf + ARRAY_SIZE(dir_desktop_mapsW) - 1;
+
+    for (i = 0; i < 2; i++)
+    {
+        NtUserGetObjectInformation( handles[i], UOI_NAME, (void *)ptr, sizeof(buf) - (ptr - buf) * sizeof(WCHAR), &needed );
+        ptr += needed / sizeof(WCHAR);
+        if (i == 0) *(ptr - 1) = '\\';
+    }
+
+    map_shared_memory_section( buf, sizeof(struct desktop_shared_memory), root,
+                               &thread_info->desktop_shared_map, (void **)&thread_info->desktop_shared_memory );
+
+    NtClose( root );
+    return thread_info->desktop_shared_memory;
+}
+
+
 /***********************************************************************
  *           winstation_init
  *

From c7f9447aeafb896ecaaba9e4344b3d1d0d35630e Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 13:58:26 +0100
Subject: [PATCH 06/44] server: Use the helper to reset the clip rect when the
 desktop size changes.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/queue.c  | 2 +-
 server/user.h   | 1 +
 server/window.c | 2 +-
 3 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -524,7 +524,7 @@ static void get_message_defaults( struct msg_queue *queue, int *x, int *y, unsig
 }
 
 /* set the cursor clip rectangle */
-static void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect, int send_clip_msg )
+void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect, int send_clip_msg )
 {
     rectangle_t top_rect;
     int x, y;
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -119,6 +119,7 @@ extern void post_win_event( struct thread *thread, unsigned int event,
                             const WCHAR *module, data_size_t module_size,
                             user_handle_t handle );
 extern void free_hotkeys( struct desktop *desktop, user_handle_t window );
+extern void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect, int send_clip_msg );
 
 /* region functions */
 
diff --git a/server/window.c b/server/window.c
index 11111111111..11111111111 100644
--- a/server/window.c
+++ b/server/window.c
@@ -1806,7 +1806,7 @@ static void set_window_pos( struct window *win, struct window *previous,
     }
 
     /* reset cursor clip rectangle when the desktop changes size */
-    if (win == win->desktop->top_window) win->desktop->cursor.clip = *window_rect;
+    if (win == win->desktop->top_window) set_clip_rectangle( win->desktop, NULL, 0 );
 
     /* if the window is not visible, everything is easy */
     if (!visible) return;

From ae06f12836cabcde908734a907351e98a8327bfa Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 14:12:52 +0100
Subject: [PATCH 07/44] server: Store the cursor clip rect in the shared data.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/protocol.def |  1 +
 server/queue.c      | 21 ++++++++++++---------
 server/user.h       |  1 -
 3 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -858,6 +858,7 @@ struct shared_cursor
     int                  x;                /* cursor position */
     int                  y;
     unsigned int         last_change;      /* time of last position change */
+    rectangle_t          clip;             /* cursor clip rectangle */
 };
 
 struct desktop_shared_memory
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -479,8 +479,8 @@ static int update_desktop_cursor_pos( struct desktop *desktop, int x, int y )
     int updated;
     unsigned int time = get_tick_count();
 
-    x = max( min( x, desktop->cursor.clip.right - 1 ), desktop->cursor.clip.left );
-    y = max( min( y, desktop->cursor.clip.bottom - 1 ), desktop->cursor.clip.top );
+    x = max( min( x, desktop->shared->cursor.clip.right - 1 ), desktop->shared->cursor.clip.left );
+    y = max( min( y, desktop->shared->cursor.clip.bottom - 1 ), desktop->shared->cursor.clip.top );
     updated = (desktop->shared->cursor.x != x || desktop->shared->cursor.y != y);
 
     SHARED_WRITE_BEGIN( &desktop->shared->seq );
@@ -526,29 +526,32 @@ static void get_message_defaults( struct msg_queue *queue, int *x, int *y, unsig
 /* set the cursor clip rectangle */
 void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect, int send_clip_msg )
 {
-    rectangle_t top_rect;
+    rectangle_t top_rect, new_rect;
     int x, y;
 
     get_top_window_rectangle( desktop, &top_rect );
     if (rect)
     {
-        rectangle_t new_rect = *rect;
+        new_rect = *rect;
         if (new_rect.left   < top_rect.left)   new_rect.left   = top_rect.left;
         if (new_rect.right  > top_rect.right)  new_rect.right  = top_rect.right;
         if (new_rect.top    < top_rect.top)    new_rect.top    = top_rect.top;
         if (new_rect.bottom > top_rect.bottom) new_rect.bottom = top_rect.bottom;
         if (new_rect.left > new_rect.right || new_rect.top > new_rect.bottom) new_rect = top_rect;
-        desktop->cursor.clip = new_rect;
     }
-    else desktop->cursor.clip = top_rect;
+    else new_rect = top_rect;
+
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
+    desktop->shared->cursor.clip = new_rect;
 
     if (desktop->cursor.clip_msg && send_clip_msg)
         post_desktop_message( desktop, desktop->cursor.clip_msg, rect != NULL, 0 );
 
     /* warp the mouse to be inside the clip rect */
-    x = max( min( desktop->shared->cursor.x, desktop->cursor.clip.right - 1 ), desktop->cursor.clip.left );
-    y = max( min( desktop->shared->cursor.y, desktop->cursor.clip.bottom - 1 ), desktop->cursor.clip.top );
+    x = max( min( desktop->shared->cursor.x, desktop->shared->cursor.clip.right - 1 ), desktop->shared->cursor.clip.left );
+    y = max( min( desktop->shared->cursor.y, desktop->shared->cursor.clip.bottom - 1 ), desktop->shared->cursor.clip.top );
     if (x != desktop->shared->cursor.x || y != desktop->shared->cursor.y) set_cursor_pos( desktop, x, y );
+    SHARED_WRITE_END( &desktop->shared->seq );
 }
 
 /* change the foreground input and reset the cursor clip rect */
@@ -3519,7 +3522,7 @@ DECL_HANDLER(set_cursor)
 
     reply->new_x       = input->desktop->shared->cursor.x;
     reply->new_y       = input->desktop->shared->cursor.y;
-    reply->new_clip    = input->desktop->cursor.clip;
+    reply->new_clip    = input->desktop->shared->cursor.clip;
     reply->last_change = input->desktop->shared->cursor.last_change;
 }
 
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -54,7 +54,6 @@ struct winstation
 
 struct global_cursor
 {
-    rectangle_t          clip;             /* cursor clip rectangle */
     unsigned int         clip_msg;         /* message to post for cursor clip changes */
     user_handle_t        win;              /* window that contains the cursor */
 };

From ae8ad0149a554db1b9e4b658ce36df1430045c4a Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 14:28:15 +0100
Subject: [PATCH 08/44] win32u: Use the desktop shared data for
 GetClipCursor().

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 dlls/win32u/cursoricon.c | 24 ++++++++++--------------
 1 file changed, 10 insertions(+), 14 deletions(-)

diff --git a/dlls/win32u/cursoricon.c b/dlls/win32u/cursoricon.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/cursoricon.c
+++ b/dlls/win32u/cursoricon.c
@@ -200,30 +200,26 @@ BOOL WINAPI NtUserClipCursor( const RECT *rect )
 
 BOOL get_clip_cursor( RECT *rect )
 {
+    volatile struct desktop_shared_memory *shared = get_desktop_shared_memory();
     UINT dpi;
-    BOOL ret;
 
-    if (!rect) return FALSE;
+    if (!rect || !shared) return FALSE;
 
-    SERVER_START_REQ( set_cursor )
+    SHARED_READ_BEGIN( &shared->seq )
     {
-        req->flags = 0;
-        if ((ret = !wine_server_call( req )))
-        {
-            rect->left   = reply->new_clip.left;
-            rect->top    = reply->new_clip.top;
-            rect->right  = reply->new_clip.right;
-            rect->bottom = reply->new_clip.bottom;
-        }
+        rect->left   = shared->cursor.clip.left;
+        rect->top    = shared->cursor.clip.top;
+        rect->right  = shared->cursor.clip.right;
+        rect->bottom = shared->cursor.clip.bottom;
     }
-    SERVER_END_REQ;
+    SHARED_READ_END( &shared->seq );
 
-    if (ret && (dpi = get_thread_dpi()))
+    if ((dpi = get_thread_dpi()))
     {
         HMONITOR monitor = monitor_from_rect( rect, MONITOR_DEFAULTTOPRIMARY, 0 );
         *rect = map_dpi_rect( *rect, get_monitor_dpi( monitor ), dpi );
     }
-    return ret;
+    return TRUE;
 }

 
 HICON alloc_cursoricon_handle( BOOL is_icon )
From c9bd87fe6413b5873818280b71695d8868a1a754 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 14:41:57 +0100
Subject: [PATCH 09/44] server: Get rid of the global cursor structure.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/queue.c      | 10 +++++-----
 server/user.h       |  9 ++-------
 server/winstation.c |  3 ++-
 3 files changed, 9 insertions(+), 13 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -544,8 +544,8 @@ void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect, int s
     SHARED_WRITE_BEGIN( &desktop->shared->seq );
     desktop->shared->cursor.clip = new_rect;
 
-    if (desktop->cursor.clip_msg && send_clip_msg)
-        post_desktop_message( desktop, desktop->cursor.clip_msg, rect != NULL, 0 );
+    if (desktop->cursor_clip_msg && send_clip_msg)
+        post_desktop_message( desktop, desktop->cursor_clip_msg, rect != NULL, 0 );
 
     /* warp the mouse to be inside the clip rect */
     x = max( min( desktop->shared->cursor.x, desktop->shared->cursor.clip.right - 1 ), desktop->shared->cursor.clip.left );
@@ -1767,8 +1767,8 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
     }
     input = thread->queue->input;
 
-    if (win != desktop->cursor.win) always_queue = 1;
-    desktop->cursor.win = win;
+    if (win != desktop->cursor_win) always_queue = 1;
+    desktop->cursor_win = win;
 
     if (!always_queue || merge_message( input, msg )) free_message( msg );
     else
@@ -3515,7 +3515,7 @@ DECL_HANDLER(set_cursor)
 
         /* only the desktop owner can set the message */
         if (req->clip_msg && get_top_window_owner(desktop) == current->process)
-            desktop->cursor.clip_msg = req->clip_msg;
+            desktop->cursor_clip_msg = req->clip_msg;
 
         set_clip_rectangle( desktop, (req->flags & SET_CURSOR_NOCLIP) ? NULL : &req->clip, 0 );
     }
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -52,12 +52,6 @@ struct winstation
     struct namespace  *desktop_names;      /* namespace for desktops of this winstation */
 };
 
-struct global_cursor
-{
-    unsigned int         clip_msg;         /* message to post for cursor clip changes */
-    user_handle_t        win;              /* window that contains the cursor */
-};
-
 struct desktop
 {
     struct object                          obj;              /* object header */
@@ -71,7 +65,8 @@ struct desktop
     struct timeout_user                   *close_timeout;    /* timeout before closing the desktop */
     struct thread_input                   *foreground_input; /* thread input of foreground thread */
     unsigned int                           users;            /* processes and threads using this desktop */
-    struct global_cursor                   cursor;           /* global cursor information */
+    unsigned int                           cursor_clip_msg;  /* message to post for cursor clip changes */
+    user_handle_t                          cursor_win;       /* window that contains the cursor */
     struct object                         *shared_mapping;   /* desktop shared memory mapping */
     volatile struct desktop_shared_memory *shared;           /* desktop shared memory ptr */
     unsigned char                          keystate[256];    /* asynchronous key state */
diff --git a/server/winstation.c b/server/winstation.c
index 11111111111..11111111111 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -257,7 +257,8 @@ static struct desktop *create_desktop( const struct unicode_str *name, unsigned
             desktop->close_timeout = NULL;
             desktop->foreground_input = NULL;
             desktop->users = 0;
-            memset( &desktop->cursor, 0, sizeof(desktop->cursor) );
+            desktop->cursor_clip_msg = 0;
+            desktop->cursor_win = 0;
             memset( desktop->keystate, 0, sizeof(desktop->keystate) );
             list_add_tail( &winstation->desktops, &desktop->entry );
             list_init( &desktop->hotkeys );

From 652000a24b990e79e8143ed40c31dae8af151969 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 15:42:25 +0100
Subject: [PATCH 10/44] server: Use a separate variable to determine the
 message on Alt release.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/queue.c      | 11 +++++------
 server/user.h       |  1 +
 server/winstation.c |  1 +
 3 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2072,17 +2072,16 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         if (input->kbd.flags & KEYEVENTF_KEYUP)
         {
             /* send WM_SYSKEYUP if Alt still pressed and no other key in between */
-            /* we use 0x02 as a flag to track if some other SYSKEYUP was sent already */
-            if ((desktop->keystate[VK_MENU] & 0x82) != 0x82) break;
+            if (!(desktop->keystate[VK_MENU] & 0x80) || !desktop->last_press_alt) break;
             message_code = WM_SYSKEYUP;
-            desktop->keystate[VK_MENU] &= ~0x02;
+            desktop->last_press_alt = 0;
         }
         else
         {
             /* send WM_SYSKEYDOWN for Alt except with Ctrl */
             if (desktop->keystate[VK_CONTROL] & 0x80) break;
             message_code = WM_SYSKEYDOWN;
-            desktop->keystate[VK_MENU] |= 0x02;
+            desktop->last_press_alt = 1;
         }
         break;
 
@@ -2092,7 +2091,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         if (!(input->kbd.flags & KEYEVENTF_KEYUP)) break;
         if (!(desktop->keystate[VK_MENU] & 0x80)) break;
         message_code = WM_SYSKEYUP;
-        desktop->keystate[VK_MENU] &= ~0x02;
+        desktop->last_press_alt = 0;
         break;
 
     default:
@@ -2102,7 +2101,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         /* fall through */
     case VK_F10:
         message_code = (input->kbd.flags & KEYEVENTF_KEYUP) ? WM_SYSKEYUP : WM_SYSKEYDOWN;
-        desktop->keystate[VK_MENU] &= ~0x02;
+        desktop->last_press_alt = 0;
         break;
     }
 
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -69,6 +69,7 @@ struct desktop
     user_handle_t                          cursor_win;       /* window that contains the cursor */
     struct object                         *shared_mapping;   /* desktop shared memory mapping */
     volatile struct desktop_shared_memory *shared;           /* desktop shared memory ptr */
+    unsigned int                           last_press_alt:1; /* last key press was Alt (used to determine msg on Alt release) */
     unsigned char                          keystate[256];    /* asynchronous key state */
 };
 
diff --git a/server/winstation.c b/server/winstation.c
index 11111111111..11111111111 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -259,6 +259,7 @@ static struct desktop *create_desktop( const struct unicode_str *name, unsigned
             desktop->users = 0;
             desktop->cursor_clip_msg = 0;
             desktop->cursor_win = 0;
+            desktop->last_press_alt = 0;
             memset( desktop->keystate, 0, sizeof(desktop->keystate) );
             list_add_tail( &winstation->desktops, &desktop->entry );
             list_init( &desktop->hotkeys );

From 85136576cfcd7072af128efcee044a83a7e4c15c Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 7 Jul 2020 13:35:21 +0100
Subject: [PATCH 11/44] server: Simplify update_input_key_state().

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/queue.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -1469,7 +1469,7 @@ static struct timer *set_timer( struct msg_queue *queue, unsigned int rate )
 }
 
 /* change the input key state for a given key */
-static void set_input_key_state( unsigned char *keystate, unsigned char key, int down )
+static void set_input_key_state( unsigned char *keystate, unsigned char key, unsigned char down )
 {
     if (down)
     {
@@ -1483,31 +1483,30 @@ static void set_input_key_state( unsigned char *keystate, unsigned char key, int
 static void update_input_key_state( struct desktop *desktop, unsigned char *keystate,
                                     unsigned int msg, lparam_t wparam )
 {
-    unsigned char key;
-    int down = 0;
+    unsigned char key, down = 0, down_val = (keystate == desktop->keystate) ? 0xc0 : 0x80;
 
     switch (msg)
     {
     case WM_LBUTTONDOWN:
-        down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+        down = down_val;
         /* fall through */
     case WM_LBUTTONUP:
         set_input_key_state( keystate, VK_LBUTTON, down );
         break;
     case WM_MBUTTONDOWN:
-        down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+        down = down_val;
         /* fall through */
     case WM_MBUTTONUP:
         set_input_key_state( keystate, VK_MBUTTON, down );
         break;
     case WM_RBUTTONDOWN:
-        down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+        down = down_val;
         /* fall through */
     case WM_RBUTTONUP:
         set_input_key_state( keystate, VK_RBUTTON, down );
         break;
     case WM_XBUTTONDOWN:
-        down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+        down = down_val;
         /* fall through */
     case WM_XBUTTONUP:
         if (wparam >> 16 == XBUTTON1) set_input_key_state( keystate, VK_XBUTTON1, down );
@@ -1515,7 +1514,7 @@ static void update_input_key_state( struct desktop *desktop, unsigned char *keys
         break;
     case WM_KEYDOWN:
     case WM_SYSKEYDOWN:
-        down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+        down = down_val;
         /* fall through */
     case WM_KEYUP:
     case WM_SYSKEYUP:

From a7d607a25d72c77a56e3f158502d1e34b3f1b6e9 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Wed, 8 Jul 2020 13:39:49 +0100
Subject: [PATCH 12/44] server: Use separate functions to update the desktop
 and input keystates.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/queue.c | 44 +++++++++++++++++++++++++++-----------------
 1 file changed, 27 insertions(+), 17 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -1480,10 +1480,10 @@ static void set_input_key_state( unsigned char *keystate, unsigned char key, uns
 }
 
 /* update the input key state for a keyboard message */
-static void update_input_key_state( struct desktop *desktop, unsigned char *keystate,
-                                    unsigned int msg, lparam_t wparam )
+static void update_key_state( unsigned char *keystate, unsigned int msg,
+                              lparam_t wparam, int desktop )
 {
-    unsigned char key, down = 0, down_val = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+    unsigned char key, down = 0, down_val = desktop ? 0xc0 : 0x80;
 
     switch (msg)
     {
@@ -1542,6 +1542,16 @@ static void update_input_key_state( struct desktop *desktop, unsigned char *keys
     }
 }
 
+static void update_input_key_state( struct thread_input *input, unsigned int msg, lparam_t wparam )
+{
+    update_key_state( input->keystate, msg, wparam, 0 );
+}
+
+static void update_desktop_key_state( struct desktop *desktop, unsigned int msg, lparam_t wparam )
+{
+    update_key_state( desktop->keystate, msg, wparam, 1 );
+}
+
 /* update the desktop key state according to a mouse message flags */
 static void update_desktop_mouse_state( struct desktop *desktop, unsigned int flags,
                                         int x, int y, lparam_t wparam )
@@ -1549,21 +1559,21 @@ static void update_desktop_mouse_state( struct desktop *desktop, unsigned int fl
     if (flags & MOUSEEVENTF_MOVE)
         update_desktop_cursor_pos( desktop, x, y );
     if (flags & MOUSEEVENTF_LEFTDOWN)
-        update_input_key_state( desktop, desktop->keystate, WM_LBUTTONDOWN, wparam );
+        update_desktop_key_state( desktop, WM_LBUTTONDOWN, wparam );
     if (flags & MOUSEEVENTF_LEFTUP)
-        update_input_key_state( desktop, desktop->keystate, WM_LBUTTONUP, wparam );
+        update_desktop_key_state( desktop, WM_LBUTTONUP, wparam );
     if (flags & MOUSEEVENTF_RIGHTDOWN)
-        update_input_key_state( desktop, desktop->keystate, WM_RBUTTONDOWN, wparam );
+        update_desktop_key_state( desktop, WM_RBUTTONDOWN, wparam );
     if (flags & MOUSEEVENTF_RIGHTUP)
-        update_input_key_state( desktop, desktop->keystate, WM_RBUTTONUP, wparam );
+        update_desktop_key_state( desktop, WM_RBUTTONUP, wparam );
     if (flags & MOUSEEVENTF_MIDDLEDOWN)
-        update_input_key_state( desktop, desktop->keystate, WM_MBUTTONDOWN, wparam );
+        update_desktop_key_state( desktop, WM_MBUTTONDOWN, wparam );
     if (flags & MOUSEEVENTF_MIDDLEUP)
-        update_input_key_state( desktop, desktop->keystate, WM_MBUTTONUP, wparam );
+        update_desktop_key_state( desktop, WM_MBUTTONUP, wparam );
     if (flags & MOUSEEVENTF_XDOWN)
-        update_input_key_state( desktop, desktop->keystate, WM_XBUTTONDOWN, wparam );
+        update_desktop_key_state( desktop, WM_XBUTTONDOWN, wparam );
     if (flags & MOUSEEVENTF_XUP)
-        update_input_key_state( desktop, desktop->keystate, WM_XBUTTONUP, wparam );
+        update_desktop_key_state( desktop, WM_XBUTTONUP, wparam );
 }
 
 /* release the hardware message currently being processed by the given thread */
@@ -1591,7 +1601,7 @@ static void release_hardware_message( struct msg_queue *queue, unsigned int hw_i
     }
     if (clr_bit) clear_queue_bits( queue, clr_bit );
 
-    update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
+    update_input_key_state( input, msg->msg, msg->wparam );
     list_remove( &msg->entry );
     free_message( msg );
 }
@@ -1721,7 +1731,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
     struct hardware_msg_data *msg_data = msg->data;
     unsigned int msg_code;
 
-    update_input_key_state( desktop, desktop->keystate, msg->msg, msg->wparam );
+    update_desktop_key_state( desktop, msg->msg, msg->wparam );
     last_input_time = get_tick_count();
     if (msg->msg != WM_MOUSEMOVE) always_queue = 1;
 
@@ -1760,7 +1770,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
     win = find_hardware_message_window( desktop, input, msg, &msg_code, &thread );
     if (!win || !thread)
     {
-        if (input) update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
+        if (input) update_input_key_state( input, msg->msg, msg->wparam );
         free_message( msg );
         return;
     }
@@ -2128,7 +2138,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
 
     if ((device = current->process->rawinput_kbd) && (device->flags & RIDEV_NOLEGACY))
     {
-        update_input_key_state( desktop, desktop->keystate, message_code, vkey );
+        update_desktop_key_state( desktop, message_code, vkey );
         return 0;
     }
 
@@ -2294,7 +2304,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
         if (!win || !win_thread)
         {
             /* no window at all, remove it */
-            update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
+            update_input_key_state( input, msg->msg, msg->wparam );
             list_remove( &msg->entry );
             free_message( msg );
             continue;
@@ -2310,7 +2320,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
             else
             {
                 /* for another thread input, drop it */
-                update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
+                update_input_key_state( input, msg->msg, msg->wparam );
                 list_remove( &msg->entry );
                 free_message( msg );
             }

From d967d8d4c8f5b9e51aa1467e543a964935d143d2 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Wed, 8 Jul 2020 08:26:21 +0100
Subject: [PATCH 13/44] server: Move the desktop keystate to shared memory.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/protocol.def |  1 +
 server/queue.c      | 68 +++++++++++++++++++++++++--------------------
 server/user.h       |  1 -
 server/winstation.c |  1 -
 4 files changed, 39 insertions(+), 32 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -865,6 +865,7 @@ struct desktop_shared_memory
 {
     unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     struct shared_cursor cursor;           /* global cursor information */
+    unsigned char        keystate[256];    /* asynchronous key state */
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -291,7 +291,8 @@ static struct thread_input *create_thread_input( struct thread *thread )
             release_object( input );
             return NULL;
         }
-        memcpy( input->desktop_keystate, input->desktop->keystate, sizeof(input->desktop_keystate) );
+        memcpy( input->desktop_keystate, (void *)input->desktop->shared->keystate,
+                sizeof(input->desktop_keystate) );
     }
     return input;
 }
@@ -368,8 +369,8 @@ static void sync_input_keystate( struct thread_input *input )
     if (!input->desktop || input->keystate_lock) return;
     for (i = 0; i < sizeof(input->keystate); ++i)
     {
-        if (input->desktop_keystate[i] == input->desktop->keystate[i]) continue;
-        input->keystate[i] = input->desktop_keystate[i] = input->desktop->keystate[i];
+        if (input->desktop_keystate[i] == input->desktop->shared->keystate[i]) continue;
+        input->keystate[i] = input->desktop_keystate[i] = input->desktop->shared->keystate[i];
     }
 }
 
@@ -1469,7 +1470,7 @@ static struct timer *set_timer( struct msg_queue *queue, unsigned int rate )
 }
 
 /* change the input key state for a given key */
-static void set_input_key_state( unsigned char *keystate, unsigned char key, unsigned char down )
+static void set_input_key_state( volatile unsigned char *keystate, unsigned char key, unsigned char down )
 {
     if (down)
     {
@@ -1480,7 +1481,7 @@ static void set_input_key_state( unsigned char *keystate, unsigned char key, uns
 }
 
 /* update the input key state for a keyboard message */
-static void update_key_state( unsigned char *keystate, unsigned int msg,
+static void update_key_state( volatile unsigned char *keystate, unsigned int msg,
                               lparam_t wparam, int desktop )
 {
     unsigned char key, down = 0, down_val = desktop ? 0xc0 : 0x80;
@@ -1549,7 +1550,9 @@ static void update_input_key_state( struct thread_input *input, unsigned int msg
 
 static void update_desktop_key_state( struct desktop *desktop, unsigned int msg, lparam_t wparam )
 {
-    update_key_state( desktop->keystate, msg, wparam, 1 );
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
+    update_key_state( desktop->shared->keystate, msg, wparam, 1 );
+    SHARED_WRITE_END( &desktop->shared->seq );
 }
 
 /* update the desktop key state according to a mouse message flags */
@@ -1613,10 +1616,10 @@ static int queue_hotkey_message( struct desktop *desktop, struct message *msg )
 
     if (msg->msg != WM_KEYDOWN && msg->msg != WM_SYSKEYDOWN) return 0;
 
-    if (desktop->keystate[VK_MENU] & 0x80) modifiers |= MOD_ALT;
-    if (desktop->keystate[VK_CONTROL] & 0x80) modifiers |= MOD_CONTROL;
-    if (desktop->keystate[VK_SHIFT] & 0x80) modifiers |= MOD_SHIFT;
-    if ((desktop->keystate[VK_LWIN] & 0x80) || (desktop->keystate[VK_RWIN] & 0x80)) modifiers |= MOD_WIN;
+    if (desktop->shared->keystate[VK_MENU] & 0x80) modifiers |= MOD_ALT;
+    if (desktop->shared->keystate[VK_CONTROL] & 0x80) modifiers |= MOD_CONTROL;
+    if (desktop->shared->keystate[VK_SHIFT] & 0x80) modifiers |= MOD_SHIFT;
+    if ((desktop->shared->keystate[VK_LWIN] & 0x80) || (desktop->shared->keystate[VK_RWIN] & 0x80)) modifiers |= MOD_WIN;
 
     LIST_FOR_EACH_ENTRY( hotkey, &desktop->hotkeys, struct hotkey, entry )
     {
@@ -1738,7 +1741,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
     if (is_keyboard_msg( msg ))
     {
         if (queue_hotkey_message( desktop, msg )) return;
-        if (desktop->keystate[VK_MENU] & 0x80) msg->lparam |= KF_ALTDOWN << 16;
+        if (desktop->shared->keystate[VK_MENU] & 0x80) msg->lparam |= KF_ALTDOWN << 16;
         if (msg->wparam == VK_SHIFT || msg->wparam == VK_LSHIFT || msg->wparam == VK_RSHIFT)
             msg->lparam &= ~(KF_EXTENDED << 16);
     }
@@ -1749,13 +1752,13 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
             prepend_cursor_history( msg->x, msg->y, msg->time, msg_data->info );
             if (update_desktop_cursor_pos( desktop, msg->x, msg->y )) always_queue = 1;
         }
-        if (desktop->keystate[VK_LBUTTON] & 0x80)  msg->wparam |= MK_LBUTTON;
-        if (desktop->keystate[VK_MBUTTON] & 0x80)  msg->wparam |= MK_MBUTTON;
-        if (desktop->keystate[VK_RBUTTON] & 0x80)  msg->wparam |= MK_RBUTTON;
-        if (desktop->keystate[VK_SHIFT] & 0x80)    msg->wparam |= MK_SHIFT;
-        if (desktop->keystate[VK_CONTROL] & 0x80)  msg->wparam |= MK_CONTROL;
-        if (desktop->keystate[VK_XBUTTON1] & 0x80) msg->wparam |= MK_XBUTTON1;
-        if (desktop->keystate[VK_XBUTTON2] & 0x80) msg->wparam |= MK_XBUTTON2;
+        if (desktop->shared->keystate[VK_LBUTTON] & 0x80)  msg->wparam |= MK_LBUTTON;
+        if (desktop->shared->keystate[VK_MBUTTON] & 0x80)  msg->wparam |= MK_MBUTTON;
+        if (desktop->shared->keystate[VK_RBUTTON] & 0x80)  msg->wparam |= MK_RBUTTON;
+        if (desktop->shared->keystate[VK_SHIFT] & 0x80)    msg->wparam |= MK_SHIFT;
+        if (desktop->shared->keystate[VK_CONTROL] & 0x80)  msg->wparam |= MK_CONTROL;
+        if (desktop->shared->keystate[VK_XBUTTON1] & 0x80) msg->wparam |= MK_XBUTTON1;
+        if (desktop->shared->keystate[VK_XBUTTON2] & 0x80) msg->wparam |= MK_XBUTTON2;
     }
     msg->x = desktop->shared->cursor.x;
     msg->y = desktop->shared->cursor.y;
@@ -2081,14 +2084,14 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         if (input->kbd.flags & KEYEVENTF_KEYUP)
         {
             /* send WM_SYSKEYUP if Alt still pressed and no other key in between */
-            if (!(desktop->keystate[VK_MENU] & 0x80) || !desktop->last_press_alt) break;
+            if (!(desktop->shared->keystate[VK_MENU] & 0x80) || !desktop->last_press_alt) break;
             message_code = WM_SYSKEYUP;
             desktop->last_press_alt = 0;
         }
         else
         {
             /* send WM_SYSKEYDOWN for Alt except with Ctrl */
-            if (desktop->keystate[VK_CONTROL] & 0x80) break;
+            if (desktop->shared->keystate[VK_CONTROL] & 0x80) break;
             message_code = WM_SYSKEYDOWN;
             desktop->last_press_alt = 1;
         }
@@ -2098,15 +2101,15 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
     case VK_RCONTROL:
         /* send WM_SYSKEYUP on release if Alt still pressed */
         if (!(input->kbd.flags & KEYEVENTF_KEYUP)) break;
-        if (!(desktop->keystate[VK_MENU] & 0x80)) break;
+        if (!(desktop->shared->keystate[VK_MENU] & 0x80)) break;
         message_code = WM_SYSKEYUP;
         desktop->last_press_alt = 0;
         break;
 
     default:
         /* send WM_SYSKEY for Alt-anykey and for F10 */
-        if (desktop->keystate[VK_CONTROL] & 0x80) break;
-        if (!(desktop->keystate[VK_MENU] & 0x80)) break;
+        if (desktop->shared->keystate[VK_CONTROL] & 0x80) break;
+        if (!(desktop->shared->keystate[VK_MENU] & 0x80)) break;
         /* fall through */
     case VK_F10:
         message_code = (input->kbd.flags & KEYEVENTF_KEYUP) ? WM_SYSKEYUP : WM_SYSKEYDOWN;
@@ -2160,7 +2163,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         if (input->kbd.flags & KEYEVENTF_EXTENDEDKEY) flags |= KF_EXTENDED;
         /* FIXME: set KF_DLGMODE and KF_MENUMODE when needed */
         if (input->kbd.flags & KEYEVENTF_KEYUP) flags |= KF_REPEAT | KF_UP;
-        else if (desktop->keystate[vkey] & 0x80) flags |= KF_REPEAT;
+        else if (desktop->shared->keystate[vkey] & 0x80) flags |= KF_REPEAT;
 
         msg->wparam = vkey;
         msg->lparam |= flags << 16;
@@ -2783,7 +2786,7 @@ DECL_HANDLER(send_hardware_message)
 
     reply->new_x = desktop->shared->cursor.x;
     reply->new_y = desktop->shared->cursor.y;
-    set_reply_data( desktop->keystate, size );
+    set_reply_data( (void *)desktop->shared->keystate, size );
     release_object( desktop );
 }
 
@@ -3292,10 +3295,12 @@ DECL_HANDLER(get_key_state)
         if (!(desktop = get_thread_desktop( current, 0 ))) return;
         if (req->key >= 0)
         {
-            reply->state = desktop->keystate[req->key & 0xff];
-            desktop->keystate[req->key & 0xff] &= ~0x40;
+            reply->state = desktop->shared->keystate[req->key & 0xff];
+            SHARED_WRITE_BEGIN( &desktop->shared->seq );
+            desktop->shared->keystate[req->key & 0xff] &= ~0x40;
+            SHARED_WRITE_END( &desktop->shared->seq );
         }
-        set_reply_data( desktop->keystate, size );
+        set_reply_data( (void *)desktop->shared->keystate, size );
         release_object( desktop );
     }
     else
@@ -3320,10 +3325,13 @@ DECL_HANDLER(set_key_state)
     data_size_t size = min( 256, get_req_data_size() );
 
     memcpy( queue->input->keystate, get_req_data(), size );
-    memcpy( queue->input->desktop_keystate, queue->input->desktop->keystate, 256 );
+    memcpy( queue->input->desktop_keystate, (void *)queue->input->desktop->shared->keystate,
+            sizeof(queue->input->desktop_keystate) );
     if (req->async && (desktop = get_thread_desktop( current, 0 )))
     {
-        memcpy( desktop->keystate, get_req_data(), size );
+        SHARED_WRITE_BEGIN( &desktop->shared->seq );
+        memcpy( (void *)desktop->shared->keystate, get_req_data(), size );
+        SHARED_WRITE_END( &desktop->shared->seq );
         release_object( desktop );
     }
 }
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -70,7 +70,6 @@ struct desktop
     struct object                         *shared_mapping;   /* desktop shared memory mapping */
     volatile struct desktop_shared_memory *shared;           /* desktop shared memory ptr */
     unsigned int                           last_press_alt:1; /* last key press was Alt (used to determine msg on Alt release) */
-    unsigned char                          keystate[256];    /* asynchronous key state */
 };
 
 /* user handles functions */
diff --git a/server/winstation.c b/server/winstation.c
index 11111111111..11111111111 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -260,7 +260,6 @@ static struct desktop *create_desktop( const struct unicode_str *name, unsigned
             desktop->cursor_clip_msg = 0;
             desktop->cursor_win = 0;
             desktop->last_press_alt = 0;
-            memset( desktop->keystate, 0, sizeof(desktop->keystate) );
             list_add_tail( &winstation->desktops, &desktop->entry );
             list_init( &desktop->hotkeys );
             if (!init_desktop_mapping( desktop, name ))

From 56cba0a75a2bcfaa7cb10f4d582c05b1eb608cdf Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Wed, 8 Jul 2020 15:45:24 +0100
Subject: [PATCH 14/44] user32: Use the shared data if possible for
 GetAsyncKeyState().

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 dlls/user32/message.c        | 16 ++-------------
 dlls/win32u/hook.c           |  2 --
 dlls/win32u/input.c          | 38 +++++++++---------------------------
 dlls/win32u/ntuser_private.h |  1 -
 dlls/win32u/sysparams.c      |  5 -----
 dlls/win32u/win32u_private.h |  1 -
 dlls/win32u/winstation.c     |  2 --
 include/ntuser.h             |  1 -
 8 files changed, 11 insertions(+), 55 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 11111111111..11111111111 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -3260,10 +3260,8 @@ static BOOL send_message( struct send_message_info *info, DWORD_PTR *res_ptr, BO
  */
 NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput, UINT flags )
 {
-    struct user_key_state_info *key_state_info = get_user_thread_info()->key_state;
     struct send_message_info info;
     int prev_x, prev_y, new_x, new_y;
-    INT counter = NtUserCallOneParam( 0, NtUserIncrementKeyStateCounter );
     USAGE hid_usage_page, hid_usage;
     NTSTATUS ret;
     BOOL wait;
@@ -3348,8 +3346,6 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *r
             }
             break;
         }
-        if (key_state_info) wine_server_set_reply( req, key_state_info->state,
-                                                   sizeof(key_state_info->state) );
         ret = wine_server_call( req );
         wait = reply->wait;
         prev_x = reply->prev_x;
@@ -3359,16 +3355,8 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *r
     }
     SERVER_END_REQ;
 
-    if (!ret)
-    {
-        if (key_state_info)
-        {
-            key_state_info->time    = GetTickCount();
-            key_state_info->counter = counter;
-        }
-        if ((flags & SEND_HWMSG_INJECTED) && (prev_x != new_x || prev_y != new_y))
-            USER_Driver->pSetCursorPos( new_x, new_y );
-    }
+    if (!ret && (flags & SEND_HWMSG_INJECTED) && (prev_x != new_x || prev_y != new_y))
+        USER_Driver->pSetCursorPos( new_x, new_y );
 
     if (wait)
     {
diff --git a/dlls/win32u/hook.c b/dlls/win32u/hook.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/hook.c
+++ b/dlls/win32u/hook.c
@@ -256,8 +256,6 @@ static LRESULT call_hook( struct win_hook_params *info )
         thread_info->hook_call_depth--;
     }
 
-    if (info->id == WH_KEYBOARD_LL || info->id == WH_MOUSE_LL)
-        InterlockedIncrement( &global_key_state_counter ); /* force refreshing the key state cache */
     return ret;
 }
 
diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -172,52 +172,32 @@ static void check_for_events( UINT flags )
  */
 SHORT WINAPI NtUserGetAsyncKeyState( INT key )
 {
-    struct user_key_state_info *key_state_info = get_user_thread_info()->key_state;
-    INT counter = global_key_state_counter;
-    BYTE prev_key_state;
+    volatile struct desktop_shared_memory *shared = get_desktop_shared_memory();
+    BYTE state;
     SHORT ret;
 
-    if (key < 0 || key >= 256) return 0;
+    if (key < 0 || key >= 256 || !shared) return 0;
 
     check_for_events( QS_INPUT );
 
-    if (key_state_info && !(key_state_info->state[key] & 0xc0) &&
-        key_state_info->counter == counter && NtGetTickCount() - key_state_info->time < 50)
-    {
-        /* use cached value */
-        return 0;
-    }
-    else if (!key_state_info)
+    SHARED_READ_BEGIN( &shared->seq )
     {
-        key_state_info = calloc( 1, sizeof(*key_state_info) );
-        get_user_thread_info()->key_state = key_state_info;
+        state = shared->keystate[key];
     }
+    SHARED_READ_END( &shared->seq );
 
+    if (!(state & 0x40)) return (state & 0x80) << 8;
+
+    /* Need to make a server call to reset the last pressed bit */
     ret = 0;
     SERVER_START_REQ( get_key_state )
     {
         req->async = 1;
         req->key = key;
-        if (key_state_info)
-        {
-            prev_key_state = key_state_info->state[key];
-            wine_server_set_reply( req, key_state_info->state, sizeof(key_state_info->state) );
-        }
         if (!wine_server_call( req ))
         {
             if (reply->state & 0x40) ret |= 0x0001;
             if (reply->state & 0x80) ret |= 0x8000;
-            if (key_state_info)
-            {
-                /* force refreshing the key state cache - some multithreaded programs
-                 * (like Adobe Photoshop CS5) expect that changes to the async key state
-                 * are also immediately available in other threads. */
-                if (prev_key_state != key_state_info->state[key])
-                    counter = InterlockedIncrement( &global_key_state_counter );
-
-                key_state_info->time    = NtGetTickCount();
-                key_state_info->counter = counter;
-            }
         }
     }
     SERVER_END_REQ;
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -154,7 +154,6 @@ struct user_thread_info
     DWORD                         GetMessageTimeVal;      /* Value for GetMessageTime */
     DWORD                         GetMessagePosVal;       /* Value for GetMessagePos */
     ULONG_PTR                     GetMessageExtraInfoVal; /* Value for GetMessageExtraInfo */
-    struct user_key_state_info   *key_state;              /* Cache of global key state */
     HKL                           kbd_layout;             /* Current keyboard layout */
     DWORD                         kbd_layout_id;          /* Current keyboard layout ID */
     HWND                          top_window;             /* Desktop window */
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4607,9 +4607,6 @@ static void thread_detach(void)
 
     user_driver->pThreadDetach();
 
-    free( thread_info->key_state );
-    thread_info->key_state = 0;
-
     destroy_thread_windows();
     NtClose( thread_info->server_queue );
 
@@ -4709,8 +4706,6 @@ ULONG_PTR WINAPI NtUserCallOneParam( ULONG_PTR arg, ULONG code )
             MSG *msg = (MSG *)arg;
             return handle_internal_message( msg->hwnd, msg->message, msg->wParam, msg->lParam );
         }
-    case NtUserIncrementKeyStateCounter:
-        return InterlockedAdd( &global_key_state_counter, arg );
     case NtUserLock:
         switch( arg )
         {
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -327,7 +327,6 @@ extern LRESULT call_hooks( INT id, INT code, WPARAM wparam, LPARAM lparam, BOOL
 extern BOOL unhook_windows_hook( INT id, HOOKPROC proc ) DECLSPEC_HIDDEN;
 
 /* input.c */
-extern LONG global_key_state_counter DECLSPEC_HIDDEN;
 extern HWND get_active_window(void) DECLSPEC_HIDDEN;
 extern BOOL get_cursor_pos( POINT *pt ) DECLSPEC_HIDDEN;
 extern HWND get_focus(void) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -238,10 +238,8 @@ BOOL WINAPI NtUserSetThreadDesktop( HDESK handle )
     if (ret)  /* reset the desktop windows */
     {
         struct user_thread_info *thread_info = get_user_thread_info();
-        struct user_key_state_info *key_state_info = thread_info->key_state;
         thread_info->top_window = 0;
         thread_info->msg_window = 0;
-        if (key_state_info) key_state_info->time = 0;
         if (thread_info->desktop_shared_map)
         {
             NtClose( thread_info->desktop_shared_map );
diff --git a/include/ntuser.h b/include/ntuser.h
index 11111111111..11111111111 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -154,7 +154,6 @@ enum
     NtUserGetDeskPattern,
     NtUserGetWinProcPtr,
     NtUserHandleInternalMessage,
-    NtUserIncrementKeyStateCounter,
     NtUserLock,
     NtUserSetCallbacks,


     NtUserSpyGetVKeyName,
From 567913044477b0f371118789b68cca735f3ef2ca Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Wed, 8 Jul 2020 16:07:08 +0100
Subject: [PATCH 15/44] server: Don't return the desktop keystate from the
 send_hardware_message request.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/protocol.def | 1 -
 server/queue.c      | 2 --
 2 files changed, 3 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2064,7 +2064,6 @@ enum message_type
     int             prev_y;
     int             new_x;     /* new cursor position */
     int             new_y;
-    VARARG(keystate,bytes);    /* global state array for all the keys */
 @END
 #define SEND_HWMSG_INJECTED    0x01
 #define SEND_HWMSG_RAWINPUT    0x02
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2750,7 +2750,6 @@ DECL_HANDLER(send_hardware_message)
     struct desktop *desktop;
     unsigned int origin = (req->flags & SEND_HWMSG_INJECTED ? IMO_INJECTED : IMO_HARDWARE);
     struct msg_queue *sender = get_current_queue();
-    data_size_t size = min( 256, get_reply_max_size() );
 
     if (!(desktop = get_thread_desktop( current, 0 ))) return;
 
@@ -2786,7 +2785,6 @@ DECL_HANDLER(send_hardware_message)
 
     reply->new_x = desktop->shared->cursor.x;
     reply->new_y = desktop->shared->cursor.y;
-    set_reply_data( (void *)desktop->shared->keystate, size );
     release_object( desktop );
 }
 

From fdc72bc8fc7ad22d51cbf604de174618640f7ff4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 23 Nov 2020 17:21:46 +0100
Subject: [PATCH 16/44] user32: Refresh active hook list only when needed.

Instead of doing it on every get_message request.
---
 dlls/user32/message.c |  4 +++-
 dlls/win32u/hook.c    | 27 +++++++++++++++++++++++----
 server/hook.c         |  8 +++++++-
 server/protocol.def   |  8 +++++++-
 server/queue.c        |  2 --
 server/user.h         |  1 -
 6 files changed, 40 insertions(+), 10 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 11111111111..11111111111 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2737,12 +2737,14 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                 info.msg.pt.x    = reply->x;
                 info.msg.pt.y    = reply->y;
                 hw_id            = 0;
-                thread_info->active_hooks = reply->active_hooks;
             }
             else buffer_size = reply->total;
         }
         SERVER_END_REQ;
 
+        /* force refreshing hooks */
+        thread_info->active_hooks = 0;
+
         if (res)
         {
             HeapFree( GetProcessHeap(), 0, buffer );
diff --git a/dlls/win32u/hook.c b/dlls/win32u/hook.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/hook.c
+++ b/dlls/win32u/hook.c
@@ -60,12 +60,31 @@ static const char *debugstr_hook_id( unsigned int id )
     return hook_names[id - WH_MINHOOK];
 }
 
-static BOOL is_hooked( INT id )
+/***********************************************************************
+ *      get_active_hooks
+ *
+ */
+static UINT get_active_hooks(void)
 {
     struct user_thread_info *thread_info = get_user_thread_info();
 
-    if (!thread_info->active_hooks) return TRUE;
-    return (thread_info->active_hooks & (1 << (id - WH_MINHOOK))) != 0;
+    if (!thread_info->active_hooks)
+    {
+        SERVER_START_REQ( get_active_hooks )
+        {
+            if (!wine_server_call( req )) thread_info->active_hooks = reply->active_hooks;
+        }
+        SERVER_END_REQ;
+    }
+
+    return thread_info->active_hooks;
+}
+
+static BOOL is_hooked( INT id )
+{
+    UINT active_hooks = get_active_hooks();
+    if (!active_hooks) return TRUE;
+    return (active_hooks & (1 << (id - WH_MINHOOK))) != 0;
 }
 
 /***********************************************************************
@@ -337,7 +356,7 @@ LRESULT call_hooks( INT id, INT code, WPARAM wparam, LPARAM lparam, BOOL unicode
 
     if (!is_hooked( id ))
     {
-        TRACE( "skipping hook %s mask %x\n", hook_names[id-WH_MINHOOK], thread_info->active_hooks );
+        TRACE( "skipping hook %s mask %x\n", hook_names[id-WH_MINHOOK], get_active_hooks() );
         return 0;
     }
 
diff --git a/server/hook.c b/server/hook.c
index 11111111111..11111111111 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -358,7 +358,7 @@ static int is_hook_active( struct hook_table *table, int index )
 }
 
 /* get a bitmap of all active hooks for the current thread */
-unsigned int get_active_hooks(void)
+static unsigned int get_active_hooks(void)
 {
     struct hook_table *table = get_queue_hooks( current );
     struct hook_table *global_hooks = get_global_hooks( current );
@@ -385,6 +385,12 @@ struct thread *get_first_global_hook( int id )
     return hook->owner;
 }
 
+/* get thread active hooks */
+DECL_HANDLER(get_active_hooks)
+{
+    reply->active_hooks = get_active_hooks();
+}
+
 /* set a window hook */
 DECL_HANDLER(set_hook)
 {
diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2087,7 +2087,6 @@ enum message_type
     int             x;         /* message x position */
     int             y;         /* message y position */
     unsigned int    time;      /* message time */
-    unsigned int    active_hooks; /* active hooks bitmap */
     data_size_t     total;     /* total size of extra data */
     VARARG(data,message_data); /* message data for sent messages */
 @END
@@ -2883,6 +2882,13 @@ enum caret_state
 };
 
 
+/* get thread active hooks */
+@REQ(get_active_hooks)
+@REPLY
+    unsigned int   active_hooks;   /* active hooks bitmap */
+@END
+
+
 /* Set a window hook */
 @REQ(set_hook)
     int            id;             /* id of the hook */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -2810,8 +2810,6 @@ DECL_HANDLER(get_message)
     user_handle_t get_win = get_user_full_handle( req->get_win );
     unsigned int filter = req->flags >> 16;
 
-    reply->active_hooks = get_active_hooks();
-
     if (get_win && get_win != 1 && get_win != -1 && !get_user_object( get_win, USER_WINDOW ))
     {
         set_win32_error( ERROR_INVALID_WINDOW_HANDLE );
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -90,7 +90,6 @@ extern void cleanup_clipboard_thread( struct thread *thread );
 /* hook functions */
 
 extern void remove_thread_hooks( struct thread *thread );
-extern unsigned int get_active_hooks(void);
 extern struct thread *get_first_global_hook( int id );
 
 /* queue functions */

From c206b344205a912b2e40f7e077bafadb86c63e9e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 21 Nov 2020 00:20:27 +0100
Subject: [PATCH 17/44] server: Create a thread queue shared mapping.

---
 server/directory.c  | 15 ++++++++
 server/file.h       |  1 +
 server/protocol.def |  6 ++++
 server/queue.c      | 85 ++++++++++++++++++++++++---------------------
 server/thread.c     | 32 +++++++++++++++++
 server/thread.h     |  2 ++
 6 files changed, 101 insertions(+), 40 deletions(-)

diff --git a/server/directory.c b/server/directory.c
index 11111111111..11111111111 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -300,6 +300,21 @@ struct object *create_desktop_map_directory( struct winstation *winstation )
     return &ret->obj;
 }
 
+struct object *create_thread_map_directory( void )
+{
+    static const WCHAR dir_kernelW[] = {'K','e','r','n','e','l','O','b','j','e','c','t','s'};
+    static const WCHAR dir_thread_mapsW[] = {'_','_','w','i','n','e','_','t','h','r','e','a','d','_','m','a','p','p','i','n','g','s'};
+    static const struct unicode_str dir_kernel_str = {dir_kernelW, sizeof(dir_kernelW)};
+    static const struct unicode_str dir_thread_maps_str = {dir_thread_mapsW, sizeof(dir_thread_mapsW)};
+    struct directory *mapping_root, *ret;
+
+    mapping_root = create_directory( &root_directory->obj, &dir_kernel_str, OBJ_OPENIF, HASH_SIZE, NULL );
+    ret = create_directory( &mapping_root->obj, &dir_thread_maps_str, OBJ_OPENIF, HASH_SIZE, NULL );
+    release_object( &mapping_root->obj );
+
+    return &ret->obj;
+}
+
 /* Global initialization */
 
 static void create_session( unsigned int id )
diff --git a/server/file.h b/server/file.h
index 11111111111..11111111111 100644
--- a/server/file.h
+++ b/server/file.h
@@ -170,6 +170,7 @@ extern const char *get_timeout_str( timeout_t timeout );
 /* directory functions */
 
 extern struct object *create_desktop_map_directory( struct winstation *winstation );
+extern struct object *create_thread_map_directory( void );
 
 /* file functions */
 
diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -868,6 +868,12 @@ struct desktop_shared_memory
     unsigned char        keystate[256];    /* asynchronous key state */
 };
 
+struct queue_shared_memory
+{
+    unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
+    int                  created;          /* queue has been created */
+};
+
 /* Bits that must be clear for client to read */
 #define SEQUENCE_MASK_BITS  4
 #define SEQUENCE_MASK ((1UL << SEQUENCE_MASK_BITS) - 1)
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -150,6 +150,7 @@ struct msg_queue
     int                    esync_in_msgwait; /* our thread is currently waiting on us */
     unsigned int           fsync_idx;
     int                    fsync_in_msgwait; /* our thread is currently waiting on us */
+    volatile struct queue_shared_memory *shared;  /* thread queue shared memory ptr */
 };
 
 struct hotkey
@@ -249,6 +250,46 @@ static unsigned int last_input_time;
 static cursor_pos_t cursor_history[64];
 static unsigned int cursor_history_latest;
 
+#if defined(__i386__) || defined(__x86_64__)
+
+#define SHARED_WRITE_BEGIN( x )                                  \
+    do {                                                         \
+        volatile unsigned int __seq = *(x);                      \
+        assert( (__seq & SEQUENCE_MASK) != SEQUENCE_MASK );      \
+        *(x) = ++__seq;                                          \
+    } while(0)
+
+#define SHARED_WRITE_END( x )                                    \
+    do {                                                         \
+        volatile unsigned int __seq = *(x);                      \
+        assert( (__seq & SEQUENCE_MASK) != 0 );                  \
+        if ((__seq & SEQUENCE_MASK) > 1) __seq--;                \
+        else __seq += SEQUENCE_MASK;                             \
+        *(x) = __seq;                                            \
+    } while(0)
+
+#else
+
+#define SHARED_WRITE_BEGIN( x )                                         \
+    do {                                                                \
+        assert( (*(x) & SEQUENCE_MASK) != SEQUENCE_MASK );              \
+        if ((__atomic_add_fetch( x, 1, __ATOMIC_RELAXED ) & SEQUENCE_MASK) == 1) \
+            __atomic_thread_fence( __ATOMIC_RELEASE );                  \
+    } while(0)
+
+#define SHARED_WRITE_END( x )                                           \
+    do {                                                                \
+        assert( (*(x) & SEQUENCE_MASK) != 0 );                          \
+        if ((*(x) & SEQUENCE_MASK) > 1)                                 \
+            __atomic_sub_fetch( x, 1, __ATOMIC_RELAXED );               \
+        else {                                                          \
+            __atomic_thread_fence( __ATOMIC_RELEASE );                  \
+            __atomic_add_fetch( x, SEQUENCE_MASK, __ATOMIC_RELAXED );   \
+        }                                                               \
+    } while(0)
+
+#endif
+
 static void queue_hardware_message( struct desktop *desktop, struct message *msg, int always_queue );
 static void free_message( struct message *msg );
 
@@ -335,6 +376,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->esync_in_msgwait = 0;
         queue->fsync_idx       = 0;
         queue->fsync_in_msgwait = 0;
+        queue->shared          = thread->queue_shared;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
@@ -347,6 +389,9 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         if (do_esync())
             queue->esync_fd = esync_create_fd( 0, 0 );
 
+        SHARED_WRITE_BEGIN( &queue->shared->seq );
+        queue->shared->created = TRUE;
+        SHARED_WRITE_END( &queue->shared->seq );
         thread->queue = queue;
     }
     if (new_input) release_object( new_input );
@@ -435,46 +480,6 @@ static struct message *alloc_hardware_message( lparam_t info, struct hw_msg_sour
     return msg;
 }
 
-#if defined(__i386__) || defined(__x86_64__)
-
-#define SHARED_WRITE_BEGIN( x )                                  \
-    do {                                                         \
-        volatile unsigned int __seq = *(x);                      \
-        assert( (__seq & SEQUENCE_MASK) != SEQUENCE_MASK );      \
-        *(x) = ++__seq;                                          \
-    } while(0)
-
-#define SHARED_WRITE_END( x )                                    \
-    do {                                                         \
-        volatile unsigned int __seq = *(x);                      \
-        assert( (__seq & SEQUENCE_MASK) != 0 );                  \
-        if ((__seq & SEQUENCE_MASK) > 1) __seq--;                \
-        else __seq += SEQUENCE_MASK;                             \
-        *(x) = __seq;                                            \
-    } while(0)
-
-#else
-
-#define SHARED_WRITE_BEGIN( x )                                         \
-    do {                                                                \
-        assert( (*(x) & SEQUENCE_MASK) != SEQUENCE_MASK );              \
-        if ((__atomic_add_fetch( x, 1, __ATOMIC_RELAXED ) & SEQUENCE_MASK) == 1) \
-            __atomic_thread_fence( __ATOMIC_RELEASE );                  \
-    } while(0)
-
-#define SHARED_WRITE_END( x )                                           \
-    do {                                                                \
-        assert( (*(x) & SEQUENCE_MASK) != 0 );                          \
-        if ((*(x) & SEQUENCE_MASK) > 1)                                 \
-            __atomic_sub_fetch( x, 1, __ATOMIC_RELAXED );               \
-        else {                                                          \
-            __atomic_thread_fence( __ATOMIC_RELEASE );                  \
-            __atomic_add_fetch( x, SEQUENCE_MASK, __ATOMIC_RELAXED );   \
-        }                                                               \
-    } while(0)
-
-#endif
-
 static int update_desktop_cursor_pos( struct desktop *desktop, int x, int y )
 {
     int updated;
diff --git a/server/thread.c b/server/thread.c
index 11111111111..11111111111 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -56,6 +56,7 @@
 #include "request.h"
 #include "user.h"
 #include "security.h"
+#include "unicode.h"
 #include "esync.h"
 #include "fsync.h"
 
@@ -361,6 +362,8 @@ static inline void init_thread_structure
     thread->desc            = NULL;
     thread->desc_len        = 0;
     thread->exit_poll       = NULL;
+    thread->queue_shared_mapping = NULL;
+    thread->queue_shared         = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -396,6 +399,28 @@ static struct context *create_thread_context( struct thread *thread )
 }
 
 
+static volatile void *init_queue_mapping( struct thread *thread )
+{
+    struct unicode_str name;
+    struct object *dir = create_thread_map_directory();
+    char nameA[MAX_PATH];
+    WCHAR *nameW;
+
+    if (!dir) return NULL;
+
+    sprintf( nameA, "%08x-queue", thread->id );
+    nameW = ascii_to_unicode_str( nameA, &name );
+
+    thread->queue_shared_mapping = create_shared_mapping( dir, &name, sizeof(struct queue_shared_memory),
+                                                          NULL, (void **)&thread->queue_shared );
+    release_object( dir );
+    if (thread->queue_shared) memset( (void *)thread->queue_shared, 0, sizeof(*thread->queue_shared) );
+
+    free( nameW );
+    return thread->queue_shared;
+}
+
+
 /* create a new thread */
 struct thread *create_thread( int fd, struct process *process, const struct security_descriptor *sd )
 {
@@ -484,6 +509,11 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
         thread->esync_fd = esync_create_fd( 0, 0 );
         thread->esync_apc_fd = esync_create_fd( 0, 0 );
     }
+    if (!init_queue_mapping( thread ))
+    {
+        release_object( thread );
+        return NULL;
+    }
 
     set_fd_events( thread->request_fd, POLLIN );  /* start listening to events */
     add_process_thread( thread->process, thread );
@@ -552,6 +582,8 @@ static void cleanup_thread( struct thread *thread )
         }
     }
     free( thread->desc );
+    if (thread->queue_shared_mapping) release_object( thread->queue_shared_mapping );
+    thread->queue_shared_mapping = NULL;
     thread->req_data = NULL;
     thread->reply_data = NULL;
     thread->request_fd = NULL;
diff --git a/server/thread.h b/server/thread.h
index 11111111111..11111111111 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -99,6 +99,8 @@ struct thread
     data_size_t            desc_len;      /* thread description length in bytes */
     WCHAR                 *desc;          /* thread description string */
     struct timeout_user   *exit_poll;     /* poll if the thread/process has exited already */
+    struct object         *queue_shared_mapping; /* thread queue shared memory mapping */
+    volatile struct queue_shared_memory *queue_shared;  /* thread queue shared memory ptr */
 };
 
 extern struct thread *current;

From 6b91d470b98666212f4d486ce6193148a8f2680c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 12 Dec 2021 13:15:26 +0100
Subject: [PATCH 18/44] user32: Use the thread queue shared data for
 peek_message.

---
 dlls/user32/message.c        | 33 ++++++++++++++++++++++++++++-
 dlls/win32u/ntuser_private.h | 22 ++++++++++++++++++++
 dlls/win32u/sysparams.c      |  9 ++++++++
 dlls/win32u/win32u_private.h | 21 +------------------
 dlls/win32u/winstation.c     | 23 ++++++++++++++++++---
 include/ntuser.h             |  1 +
 server/protocol.def          |  4 ++++
 server/queue.c               | 40 ++++++++++++++++++++++++++++++++++++
 8 files changed, 129 insertions(+), 24 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 11111111111..11111111111 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2695,12 +2695,14 @@ static inline void call_sendmsg_callback( SENDASYNCPROC callback, HWND hwnd, UIN
 static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags, UINT changed_mask )
 {
     LRESULT result;
+    volatile struct queue_shared_memory *shared = (void *)NtUserCallNoParam( NtUserGetQueueSharedMemory );
     struct user_thread_info *thread_info = get_user_thread_info();
     INPUT_MESSAGE_SOURCE prev_source = thread_info->msg_source;
     struct received_message_info info, *old_info;
     unsigned int hw_id = 0;  /* id of previous hardware message */
     void *buffer;
     size_t buffer_size = 1024;
+    BOOL skip = FALSE;
 
     if (!(buffer = HeapAlloc( GetProcessHeap(), 0, buffer_size ))) return -1;
 
@@ -2712,10 +2714,39 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
         NTSTATUS res;
         size_t size = 0;
         const message_data_t *msg_data = buffer;
+        UINT wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
+        DWORD clear_bits = 0, filter = flags >> 16 ? flags >> 16 : QS_ALLINPUT;
+        if (filter & QS_POSTMESSAGE)
+        {
+            clear_bits |= QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER;
+            if (first == 0 && last == ~0U) clear_bits |= QS_ALLPOSTMESSAGE;
+        }
+        if (filter & QS_INPUT) clear_bits |= QS_INPUT;
+        if (filter & QS_PAINT) clear_bits |= QS_PAINT;
 
         thread_info->msg_source = prev_source;
 
-        SERVER_START_REQ( get_message )
+        if (!shared) skip = FALSE;
+        else SHARED_READ_BEGIN( &shared->seq )
+        {
+            /* not created yet */
+            if (!shared->created) skip = FALSE;
+            /* if the masks need an update */
+            else if (shared->wake_mask != wake_mask) skip = FALSE;
+            else if (shared->changed_mask != changed_mask) skip = FALSE;
+            /* or if the queue is signaled */
+            else if (shared->wake_bits & wake_mask) skip = FALSE;
+            else if (shared->changed_bits & changed_mask) skip = FALSE;
+            /* or if the filter matches some bits */
+            else if (shared->wake_bits & filter) skip = FALSE;
+            /* or if we should clear some bits */
+            else if (shared->changed_bits & clear_bits) skip = FALSE;
+            else skip = TRUE;
+        }
+        SHARED_READ_END( &shared->seq );
+
+        if (skip) res = STATUS_PENDING;
+        else SERVER_START_REQ( get_message )
         {
             req->flags     = flags;
             req->get_win   = wine_server_user_handle( hwnd );
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -162,6 +162,8 @@ struct user_thread_info
     UINT                          spy_indent;             /* Current spy indent */
     HANDLE                        desktop_shared_map;     /* HANDLE to server's desktop shared memory */
     struct desktop_shared_memory *desktop_shared_memory;  /* Ptr to server's desktop shared memory */
+    HANDLE                        queue_shared_map;       /* HANDLE to server's thread queue shared memory */
+    struct queue_shared_memory   *queue_shared_memory;     /* Ptr to server's thread queue shared memory */
 };
 
 C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo) );
@@ -304,4 +306,24 @@ WND *get_win_ptr( HWND hwnd ) DECLSPEC_HIDDEN;
 BOOL is_child( HWND parent, HWND child );
 BOOL is_window( HWND hwnd ) DECLSPEC_HIDDEN;
 
+#if defined(__i386__) || defined(__x86_64__)
+#define __SHARED_READ_SEQ( x ) (*(x))
+#define __SHARED_READ_FENCE do {} while(0)
+#else
+#define __SHARED_READ_SEQ( x ) __atomic_load_n( x, __ATOMIC_RELAXED )
+#define __SHARED_READ_FENCE __atomic_thread_fence( __ATOMIC_ACQUIRE )
+#endif
+
+#define SHARED_READ_BEGIN( x )                                          \
+    do {                                                                \
+        unsigned int __seq;                                             \
+        do {                                                            \
+            while ((__seq = __SHARED_READ_SEQ( x )) & SEQUENCE_MASK) NtYieldExecution(); \
+            __SHARED_READ_FENCE;
+
+#define SHARED_READ_END( x )                       \
+            __SHARED_READ_FENCE;                   \
+        } while (__SHARED_READ_SEQ( x ) != __seq); \
+    } while(0)
+
 #endif /* __WINE_NTUSER_PRIVATE_H */
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4617,6 +4617,13 @@ static void thread_detach(void)
         thread_info->desktop_shared_memory = NULL;
     }
 
+    if (thread_info->queue_shared_map)
+    {
+        NtClose( thread_info->queue_shared_map );
+        thread_info->queue_shared_map = NULL;
+        thread_info->queue_shared_memory = NULL;
+    }
+
     exiting_thread_id = 0;
 }
 
@@ -4642,6 +4649,8 @@ ULONG_PTR WINAPI NtUserCallNoParam( ULONG code )
     case NtUserThreadDetach:
         thread_detach();
         return 0;
+    case NtUserGetQueueSharedMemory:
+        return get_queue_shared_memory();
     default:
         FIXME( "invalid code %u\n", code );
         return 0;
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -409,6 +409,7 @@ static inline void release_win_ptr( struct tagWND *ptr )
 
 /* winstation.c */
 extern volatile struct desktop_shared_memory *get_desktop_shared_memory( void ) DECLSPEC_HIDDEN;
+extern volatile struct queue_shared_memory *get_queue_shared_memory( void ) DECLSPEC_HIDDEN;
 
 extern void wrappers_init( unixlib_handle_t handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS gdi_init(void) DECLSPEC_HIDDEN;
@@ -589,24 +590,4 @@ static inline const char *debugstr_us( const UNICODE_STRING *us )
     return debugstr_wn( us->Buffer, us->Length / sizeof(WCHAR) );
 }
 
-#if defined(__i386__) || defined(__x86_64__)
-#define __SHARED_READ_SEQ( x ) (*(x))
-#define __SHARED_READ_FENCE do {} while(0)
-#else
-#define __SHARED_READ_SEQ( x ) __atomic_load_n( x, __ATOMIC_RELAXED )
-#define __SHARED_READ_FENCE __atomic_thread_fence( __ATOMIC_ACQUIRE )
-#endif
-
-#define SHARED_READ_BEGIN( x )                                          \
-    do {                                                                \
-        unsigned int __seq;                                             \
-        do {                                                            \
-            while ((__seq = __SHARED_READ_SEQ( x )) & SEQUENCE_MASK) NtYieldExecution(); \
-            __SHARED_READ_FENCE;
-
-#define SHARED_READ_END( x )                       \
-            __SHARED_READ_FENCE;                   \
-        } while (__SHARED_READ_SEQ( x ) != __seq); \
-    } while(0)
-
 #endif /* __WINE_WIN32U_PRIVATE */
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -571,13 +571,13 @@ static const WCHAR *get_default_desktop( void *buf, size_t buf_size )
 }
 
 
-static void map_shared_memory_section( const WCHAR *name, SIZE_T size, HANDLE root, HANDLE *handle, void **ptr )
+static void map_shared_memory_section( const WCHAR *name, UINT namelen, SIZE_T size, HANDLE root, HANDLE *handle, void **ptr )
 {
     OBJECT_ATTRIBUTES attr;
     UNICODE_STRING section_str;
     NTSTATUS status;
 
-    section_str.Length = wcslen(name) * sizeof(WCHAR);
+    section_str.Length = (namelen ? namelen : wcslen(name)) * sizeof(WCHAR);
     section_str.MaximumLength = section_str.Length + sizeof(WCHAR);
     section_str.Buffer = (WCHAR *)name;
     InitializeObjectAttributes( &attr, &section_str, 0, root, NULL );
@@ -628,7 +628,7 @@ volatile struct desktop_shared_memory *get_desktop_shared_memory( void )
         if (i == 0) *(ptr - 1) = '\\';
     }
 
-    map_shared_memory_section( buf, sizeof(struct desktop_shared_memory), root,
+    map_shared_memory_section( buf, ptr - buf - 1, sizeof(struct desktop_shared_memory), root,
                                &thread_info->desktop_shared_map, (void **)&thread_info->desktop_shared_memory );
 
     NtClose( root );
@@ -636,6 +636,23 @@ volatile struct desktop_shared_memory *get_desktop_shared_memory( void )
 }
 
 
+volatile struct queue_shared_memory *get_queue_shared_memory( void )
+{
+    struct user_thread_info *thread_info = get_user_thread_info();
+    char bufA[MAX_PATH];
+    WCHAR buf[MAX_PATH];
+    UINT len;
+
+    if (thread_info->queue_shared_memory) return thread_info->queue_shared_memory;
+
+    snprintf( bufA, ARRAY_SIZE(buf), "\\KernelObjects\\__wine_thread_mappings\\%08x-queue", GetCurrentThreadId() );
+    len = asciiz_to_unicode( buf, bufA ) / sizeof(WCHAR) - 1;
+    map_shared_memory_section( buf, len, sizeof(struct queue_shared_memory), NULL,
+                               &thread_info->queue_shared_map, (void **)&thread_info->queue_shared_memory );
+    return thread_info->queue_shared_memory;
+}
+
+
 /***********************************************************************
  *           winstation_init
  *
diff --git a/include/ntuser.h b/include/ntuser.h
index 11111111111..11111111111 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -128,6 +128,7 @@ enum
     /* temporary exports */
     NtUserExitingThread,
     NtUserThreadDetach,
+    NtUserGetQueueSharedMemory,
 };
 
 /* NtUserCallOneParam codes, not compatible with Windows */
diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -872,6 +872,10 @@ struct queue_shared_memory
 {
     unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     int                  created;          /* queue has been created */
+    unsigned int         wake_bits;
+    unsigned int         changed_bits;
+    unsigned int         wake_mask;
+    unsigned int         changed_mask;
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -593,6 +593,12 @@ static inline void set_queue_bits( struc
     }
     queue->wake_bits |= bits;
     queue->changed_bits |= bits;
+
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->wake_bits = queue->wake_bits;
+    queue->shared->changed_bits = queue->changed_bits;
+    SHARED_WRITE_END( &queue->shared->seq );
+
     if (is_signaled( queue )) wake_up( &queue->obj, 0 );
 }
 
@@ -612,6 +618,11 @@ static inline void clear_queue_bits( str
 
     if (do_esync() && !is_signaled( queue ))
         esync_clear( queue->esync_fd );
+
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->wake_bits = queue->wake_bits;
+    queue->shared->changed_bits = queue->changed_bits;
+    SHARED_WRITE_END( &queue->shared->seq );
 }
 
 /* check whether msg is a keyboard message */
@@ -1151,6 +1162,11 @@ static void msg_queue_satisfied( struct
     struct msg_queue *queue = (struct msg_queue *)obj;
     queue->wake_mask = 0;
     queue->changed_mask = 0;
+
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->wake_mask = queue->wake_mask;
+    queue->shared->changed_mask = queue->changed_mask;
+    SHARED_WRITE_END( &queue->shared->seq );
 }
 
 static void msg_queue_destroy( struct object *obj )
@@ -2592,10 +2608,23 @@ DECL_HANDLER(set_queue_mask)
         queue->changed_mask = req->changed_mask;
         reply->wake_bits    = queue->wake_bits;
         reply->changed_bits = queue->changed_bits;
+
+        SHARED_WRITE_BEGIN( &queue->shared->seq );
+        queue->shared->wake_mask = queue->wake_mask;
+        queue->shared->changed_mask = queue->changed_mask;
+        SHARED_WRITE_END( &queue->shared->seq );
+
         if (is_signaled( queue ))
         {
             /* if skip wait is set, do what would have been done in the subsequent wait */
-            if (req->skip_wait) queue->wake_mask = queue->changed_mask = 0;
+            if (req->skip_wait)
+            {   
+                queue->wake_mask = queue->changed_mask = 0;
+                SHARED_WRITE_BEGIN( &queue->shared->seq );
+                queue->shared->wake_mask = queue->wake_mask;
+                queue->shared->changed_mask = queue->changed_mask;
+                SHARED_WRITE_END( &queue->shared->seq );
+            }
             else wake_up( &queue->obj, 0 );
         }
         if (do_fsync() && !is_signaled( queue ))
@@ -2622,6 +2651,10 @@ DECL_HANDLER(get_queue_status)
 
         if (do_esync() && !is_signaled( queue ))
             esync_clear( queue->esync_fd );
+
+        SHARED_WRITE_BEGIN( &queue->shared->seq );
+        queue->shared->changed_bits = queue->changed_bits;
+        SHARED_WRITE_END( &queue->shared->seq );
     }
     else reply->wake_bits = reply->changed_bits = 0;
 }
@@ -2802,6 +2835,10 @@ DECL_HANDLER(get_message)
     if (filter & QS_INPUT) queue->changed_bits &= ~QS_INPUT;
     if (filter & QS_PAINT) queue->changed_bits &= ~QS_PAINT;
 
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->changed_bits = queue->changed_bits;
+    SHARED_WRITE_END( &queue->shared->seq );
+
     /* then check for posted messages */
     if ((filter & QS_POSTMESSAGE) &&
         get_posted_message( queue, queue->ignore_post_msg, get_win, req->get_first, req->get_last, req->flags, reply ))
@@ -2865,6 +2902,12 @@ DECL_HANDLER(get_message)
     if (get_win == -1 && current->process->idle_event) set_event( current->process->idle_event );
     queue->wake_mask = req->wake_mask;
     queue->changed_mask = req->changed_mask;
+
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->wake_mask = queue->wake_mask;
+    queue->shared->changed_mask = queue->changed_mask;
+    SHARED_WRITE_END( &queue->shared->seq );
+
     set_error( STATUS_PENDING );  /* FIXME */
 
     if (do_fsync() && !is_signaled( queue ))

From 7ea980634b9db3af7b8ac8a1994d6e96ccc3fdfc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 12 Dec 2021 13:15:45 +0100
Subject: [PATCH 19/44] user32: Don't check for driver events so often.

Now that PeekMessage may return quickly we don't want to check for
driver events on every call.
---
 dlls/user32/message.c        | 14 ++++++++++----
 dlls/win32u/ntuser_private.h |  1 +
 2 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 11111111111..11111111111 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -3779,7 +3779,8 @@ void WINAPI PostQuitMessage( INT exit_code )
 /* check for driver events if we detect that the app is not properly consuming messages */
 static inline void check_for_driver_events( UINT msg )
 {
-    if (get_user_thread_info()->message_count > 200)
+    struct user_thread_info *thread_info = get_user_thread_info();
+    if (thread_info->message_count > 200)
     {
         flush_window_surfaces( FALSE );
         USER_Driver->pMsgWaitForMultipleObjectsEx( 0, NULL, 0, QS_ALLINPUT, 0 );
@@ -3787,9 +3788,9 @@ static inline void check_for_driver_events( UINT msg )
     else if (msg == WM_TIMER || msg == WM_SYSTIMER)
     {
         /* driver events should have priority over timers, so make sure we'll check for them soon */
-        get_user_thread_info()->message_count += 100;
+        thread_info->message_count += 100;
     }
-    else get_user_thread_info()->message_count++;
+    else thread_info->message_count++;
 }
 
 /***********************************************************************
@@ -3797,17 +3798,21 @@ static inline void check_for_driver_events( UINT msg )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH PeekMessageW( MSG *msg_out, HWND hwnd, UINT first, UINT last, UINT flags )
 {
+    struct user_thread_info *thread_info = get_user_thread_info();
     MSG msg;
     int ret;
 
     USER_CheckNotLock();
-    check_for_driver_events( 0 );
+    if (thread_info->last_driver_time != GetTickCount())
+        check_for_driver_events( 0 );
 
     ret = peek_message( &msg, hwnd, first, last, flags, 0 );
     if (ret < 0) return FALSE;
 
     if (!ret)
     {
+        if (thread_info->last_driver_time == GetTickCount()) return FALSE;
+        thread_info->last_driver_time = GetTickCount();
         flush_window_surfaces( TRUE );
         ret = wow_handlers.wait_message( 0, NULL, 0, QS_ALLINPUT, 0 );
         /* if we received driver events, check again for a pending message */
@@ -3815,6 +3820,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH PeekMessageW( MSG *msg_out, HWND hwnd, UINT first,
     }
 
     check_for_driver_events( msg.message );
+    thread_info->last_driver_time = GetTickCount() - 1;
 
     /* copy back our internal safe copy of message data to msg_out.
      * msg_out is a variable from the *program*, so it can't be used
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -141,6 +141,7 @@ struct user_thread_info
     HANDLE                        server_queue;           /* Handle to server-side queue */
     DWORD                         wake_mask;              /* Current queue wake mask */
     DWORD                         changed_mask;           /* Current queue changed mask */
+    DWORD                         last_driver_time;       /* Get/PeekMessage driver event time */
     WORD                          recursion_count;        /* SendMessage recursion counter */
     WORD                          message_count;          /* Get/PeekMessage loop counter */
     WORD                          hook_call_depth;        /* Number of recursively called hook procs */

From 0ec3a8f613f4f90bec735b181712eb0d4f8c8940 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 24 Nov 2020 19:21:42 +0100
Subject: [PATCH 20/44] esync: user32: Always call get_message request after
 waiting.

Because with esync and fsync the wait happens on the client-side, so
we need to make the request to do the server side effects.
---
 dlls/user32/message.c | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 11111111111..11111111111 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2692,7 +2692,7 @@ static inline void call_sendmsg_callback( SENDASYNCPROC callback, HWND hwnd, UIN
  * available; -1 on error.
  * All pending sent messages are processed before returning.
  */
-static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags, UINT changed_mask )
+static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags, UINT changed_mask, BOOL waited )
 {
     LRESULT result;
     volatile struct queue_shared_memory *shared = (void *)NtUserCallNoParam( NtUserGetQueueSharedMemory );
@@ -2726,7 +2726,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
 
         thread_info->msg_source = prev_source;
 
-        if (!shared) skip = FALSE;
+        if (!shared || waited) skip = FALSE;
         else SHARED_READ_BEGIN( &shared->seq )
         {
             /* not created yet */
@@ -2922,7 +2922,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                 }
                 else
                     peek_message( msg, info.msg.hwnd, info.msg.message,
-                                  info.msg.message, flags | PM_REMOVE, changed_mask );
+                                  info.msg.message, flags | PM_REMOVE, changed_mask, TRUE );
                 continue;
             }
 	    if (info.msg.message >= WM_DDE_FIRST && info.msg.message <= WM_DDE_LAST)
@@ -2966,7 +2966,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
 static inline void process_sent_messages(void)
 {
     MSG msg;
-    peek_message( &msg, 0, 0, 0, PM_REMOVE | PM_QS_SENDMESSAGE, 0 );
+    peek_message( &msg, 0, 0, 0, PM_REMOVE | PM_QS_SENDMESSAGE, 0, FALSE );
 }
 
 
@@ -3806,7 +3806,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH PeekMessageW( MSG *msg_out, HWND hwnd, UINT first,
     if (thread_info->last_driver_time != GetTickCount())
         check_for_driver_events( 0 );
 
-    ret = peek_message( &msg, hwnd, first, last, flags, 0 );
+    ret = peek_message( &msg, hwnd, first, last, flags, 0, FALSE );
     if (ret < 0) return FALSE;
 
     if (!ret)
@@ -3816,7 +3816,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH PeekMessageW( MSG *msg_out, HWND hwnd, UINT first,
         flush_window_surfaces( TRUE );
         ret = wow_handlers.wait_message( 0, NULL, 0, QS_ALLINPUT, 0 );
         /* if we received driver events, check again for a pending message */
-        if (ret == WAIT_TIMEOUT || peek_message( &msg, hwnd, first, last, flags, 0 ) <= 0) return FALSE;
+        if (ret == WAIT_TIMEOUT || peek_message( &msg, hwnd, first, last, flags, 0, TRUE ) <= 0) return FALSE;
     }
 
     check_for_driver_events( msg.message );
@@ -3871,7 +3871,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetMessageW( MSG *msg, HWND hwnd, UINT first, UINT
     }
     else mask = QS_ALLINPUT;
 
-    while (!(ret = peek_message( msg, hwnd, first, last, PM_REMOVE | (mask << 16), mask )))
+    while (!(ret = peek_message( msg, hwnd, first, last, PM_REMOVE | (mask << 16), mask, TRUE )))
     {
         wait_objects( 1, &server_queue, INFINITE, mask & (QS_SENDMESSAGE | QS_SMRESULT), mask, 0 );
     }

From 19ff7b62ab6eefaaf1aad8ca342e118e133c9dc9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 12 Dec 2021 13:16:00 +0100
Subject: [PATCH 21/44] user32: Call get_message request at least once every
 3s.

So that the thread queue isn't incorrectly flagged as hung.
---
 dlls/user32/message.c        | 3 ++-
 dlls/win32u/ntuser_private.h | 1 +
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 11111111111..11111111111 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2726,7 +2726,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
 
         thread_info->msg_source = prev_source;
 
-        if (!shared || waited) skip = FALSE;
+        if (!shared || waited || GetTickCount() - thread_info->last_getmsg_time >= 3000) skip = FALSE;
         else SHARED_READ_BEGIN( &shared->seq )
         {
             /* not created yet */
@@ -2756,6 +2756,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
             req->wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
             req->changed_mask = changed_mask;
             wine_server_set_reply( req, buffer, buffer_size );
+            thread_info->last_getmsg_time = GetTickCount();
             if (!(res = wine_server_call( req )))
             {
                 size = wine_server_reply_size( reply );
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -142,6 +142,7 @@ struct user_thread_info
     DWORD                         wake_mask;              /* Current queue wake mask */
     DWORD                         changed_mask;           /* Current queue changed mask */
     DWORD                         last_driver_time;       /* Get/PeekMessage driver event time */
+    DWORD                         last_getmsg_time;       /* Get/PeekMessage last request time */
     WORD                          recursion_count;        /* SendMessage recursion counter */
     WORD                          message_count;          /* Get/PeekMessage loop counter */
     WORD                          hook_call_depth;        /* Number of recursively called hook procs */
From 5a7ff5331e0c29110417c02f2e494aaecf8b5794 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 29 Apr 2021 11:36:15 +0200
Subject: [PATCH 22/44] user32: Allocate heap in peek_message only when
 necessary.

---
 dlls/user32/message.c | 30 ++++++++++++++++++++++--------
 1 file changed, 22 insertions(+), 8 deletions(-)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 11111111111..11111111111 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2700,12 +2700,11 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
     INPUT_MESSAGE_SOURCE prev_source = thread_info->msg_source;
     struct received_message_info info, *old_info;
     unsigned int hw_id = 0;  /* id of previous hardware message */
-    void *buffer;
+    char buffer_init[1024];
     size_t buffer_size = 1024;
+    void *buffer = buffer_init;
     BOOL skip = FALSE;
 
-    if (!(buffer = HeapAlloc( GetProcessHeap(), 0, buffer_size ))) return -1;
-
     if (!first && !last) last = ~0;
     if (hwnd == HWND_BROADCAST) hwnd = HWND_TOPMOST;
 
@@ -2779,19 +2778,22 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
 
         if (res)
         {
-            HeapFree( GetProcessHeap(), 0, buffer );
             if (res == STATUS_PENDING)
             {
                 thread_info->wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
                 thread_info->changed_mask = changed_mask;
+                if (buffer != buffer_init) HeapFree( GetProcessHeap(), 0, buffer );
                 return 0;
             }
             if (res != STATUS_BUFFER_OVERFLOW)
             {
                 SetLastError( RtlNtStatusToDosError(res) );
+                if (buffer != buffer_init) HeapFree( GetProcessHeap(), 0, buffer );
                 return -1;
             }
-            if (!(buffer = HeapAlloc( GetProcessHeap(), 0, buffer_size ))) return -1;
+            if (buffer == buffer_init) buffer = HeapAlloc( GetProcessHeap(), 0, buffer_size );
+            else buffer = HeapReAlloc( GetProcessHeap(), 0, buffer, buffer_size );
+            if (!buffer) return -1;
             continue;
         }
 
@@ -2808,6 +2810,12 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
             break;
         case MSG_NOTIFY:
             info.flags = ISMEX_NOTIFY;
+            /* unpack_message may have to reallocate */
+            if (buffer == buffer_init)
+            {
+                buffer = HeapAlloc( GetProcessHeap(), 0, buffer_size );
+                memcpy( buffer, buffer_init, buffer_size );
+            }
             if (!unpack_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
                                  &info.msg.lParam, &buffer, size ))
                 continue;
@@ -2880,6 +2888,12 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
             continue;
         case MSG_OTHER_PROCESS:
             info.flags = ISMEX_SEND;
+            /* unpack_message may have to reallocate */
+            if (buffer == buffer_init)
+            {
+                buffer = HeapAlloc( GetProcessHeap(), 0, buffer_size );
+                memcpy( buffer, buffer_init, buffer_size );
+            }
             if (!unpack_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
                                  &info.msg.lParam, &buffer, size ))
             {
@@ -2902,7 +2916,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                 thread_info->GetMessagePosVal = MAKELONG( info.msg.pt.x, info.msg.pt.y );
                 thread_info->GetMessageTimeVal = info.msg.time;
                 thread_info->GetMessageExtraInfoVal = msg_data->hardware.info;
-                HeapFree( GetProcessHeap(), 0, buffer );
+                if (buffer != buffer_init) HeapFree( GetProcessHeap(), 0, buffer );
                 HOOK_CallHooks( WH_GETMESSAGE, HC_ACTION, flags & PM_REMOVE, (LPARAM)msg, TRUE );
                 return 1;
             }
@@ -2917,7 +2931,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                     /* if this is a nested call return right away */
                     if (first == info.msg.message && last == info.msg.message)
                     {
-                        HeapFree( GetProcessHeap(), 0, buffer );
+                        if (buffer != buffer_init) HeapFree( GetProcessHeap(), 0, buffer );
                         return 0;
                     }
                 }
@@ -2938,7 +2952,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
             thread_info->GetMessageTimeVal = info.msg.time;
             thread_info->GetMessageExtraInfoVal = 0;
             thread_info->msg_source = msg_source_unavailable;
-            HeapFree( GetProcessHeap(), 0, buffer );
+            if (buffer != buffer_init) HeapFree( GetProcessHeap(), 0, buffer );
             HOOK_CallHooks( WH_GETMESSAGE, HC_ACTION, flags & PM_REMOVE, (LPARAM)msg, TRUE );
             return 1;
         }

From f8230e1736c8f2b3ae25f2ab71b5bbb8172921ee Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 29 Apr 2021 20:07:16 +0200
Subject: [PATCH 23/44] user32: Yield thread in peek_message when no message
 was found.

---
 dlls/user32/message.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 11111111111..11111111111 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -2783,6 +2783,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                 thread_info->wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
                 thread_info->changed_mask = changed_mask;
                 if (buffer != buffer_init) HeapFree( GetProcessHeap(), 0, buffer );
+                SwitchToThread();
                 return 0;
             }
             if (res != STATUS_BUFFER_OVERFLOW)

From f5ae6d0a9a4217880d8f312b1687b5ec5fe89803 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 14 Jan 2021 15:22:05 +0100
Subject: [PATCH 24/44] server: Create a thread input shared mapping.

---
 server/protocol.def |  8 ++++++++
 server/queue.c      | 21 ++++++++++++++++++++-
 server/thread.c     | 41 ++++++++++++++++++++++++++++++++++++++++-
 server/thread.h     |  2 ++
 4 files changed, 70 insertions(+), 2 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -876,6 +876,14 @@ struct queue_shared_memory
     unsigned int         changed_bits;
     unsigned int         wake_mask;
     unsigned int         changed_mask;
+    thread_id_t          input_tid;
+};
+
+struct input_shared_memory
+{
+    unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
+    int                  created;
+    thread_id_t          tid;
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -116,6 +116,8 @@ struct thread_input
     unsigned char          keystate[256]; /* state of each key */
     unsigned char          desktop_keystate[256]; /* desktop keystate when keystate was synced */
     int                    keystate_lock; /* keystate is locked */
+    struct object         *shared_mapping; /* thread input shared memory mapping */
+    volatile struct input_shared_memory *shared;  /* thread input shared memory ptr */
 };
 
 struct msg_queue
@@ -315,6 +317,8 @@ static struct thread_input *create_thread_input( struct thread *thread )
 
     if ((input = alloc_object( &thread_input_ops )))
     {
+        input->shared_mapping = grab_object( thread->input_shared_mapping );
+        input->shared = thread->input_shared;
         input->focus        = 0;
         input->capture      = 0;
         input->active       = 0;
@@ -334,6 +338,10 @@ static struct thread_input *create_thread_input( struct thread *thread )
         }
         memcpy( input->desktop_keystate, (void *)input->desktop->shared->keystate,
                 sizeof(input->desktop_keystate) );
+
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        input->shared->created = TRUE;
+        SHARED_WRITE_END( &input->shared->seq );
     }
     return input;
 }
@@ -394,7 +402,13 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         SHARED_WRITE_END( &queue->shared->seq );
         thread->queue = queue;
     }
-    if (new_input) release_object( new_input );
+    if (new_input)
+    {
+        SHARED_WRITE_BEGIN( &queue->shared->seq );
+        queue->shared->input_tid = new_input->shared->tid;
+        SHARED_WRITE_END( &queue->shared->seq );
+        release_object( new_input );
+    }
     return queue;
 }
 
@@ -451,6 +465,10 @@ static int assign_thread_input( struct thread *thread, struct thread_input *new_
     queue->input = (struct thread_input *)grab_object( new_input );
     if (queue->keystate_lock) lock_input_keystate( queue->input );
     new_input->cursor_count += queue->cursor_count;
+
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->input_tid = queue->input->shared->tid;
+    SHARED_WRITE_END( &queue->shared->seq );
     return 1;
 }
 
@@ -1264,6 +1282,7 @@ static void thread_input_destroy( struct object *obj )
         if (input->desktop->foreground_input == input) set_foreground_input( input->desktop, NULL );
         release_object( input->desktop );
     }
+    release_object( input->shared_mapping );
 }
 
 /* fix the thread input data when a window is destroyed */
diff --git a/server/thread.c b/server/thread.c
index 11111111111..11111111111 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -349,6 +349,8 @@ static inline void init_thread_structure( struct thread *thread )
     thread->fast_sync       = NULL;
     thread->queue_shared_mapping = NULL;
     thread->queue_shared         = NULL;
+    thread->input_shared_mapping = NULL;
+    thread->input_shared         = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -414,13 +416,43 @@ static volatile void *init_queue_mapping( struct thread *thread )
     thread->queue_shared_mapping = create_shared_mapping( dir, &name, sizeof(struct queue_shared_memory),
                                                           NULL, (void **)&thread->queue_shared );
     release_object( dir );
-    if (thread->queue_shared) memset( (void *)thread->queue_shared, 0, sizeof(*thread->queue_shared) );
+    if (thread->queue_shared)
+    {
+        memset( (void *)thread->queue_shared, 0, sizeof(*thread->queue_shared) );
+        thread->queue_shared->input_tid = thread->id;
+    }
 
     free( nameW );
     return thread->queue_shared;
 }
 
 
+static volatile void *init_input_mapping( struct thread *thread )
+{
+    struct unicode_str name;
+    struct object *dir = create_thread_map_directory();
+    char nameA[MAX_PATH];
+    WCHAR *nameW;
+
+    if (!dir) return NULL;
+
+    sprintf( nameA, "%08x-input", thread->id );
+    nameW = ascii_to_unicode_str( nameA, &name );
+
+    thread->input_shared_mapping = create_shared_mapping( dir, &name, sizeof(struct input_shared_memory),
+                                                          NULL, (void **)&thread->input_shared );
+    release_object( dir );
+    if (thread->input_shared)
+    {
+        memset( (void *)thread->input_shared, 0, sizeof(*thread->input_shared) );
+        thread->input_shared->tid = thread->id;
+    }
+
+    free( nameW );
+    return thread->input_shared;
+}
+
+
 /* create a new thread */
 struct thread *create_thread( int fd, struct process *process, const struct security_descriptor *sd )
 {
@@ -514,6 +546,11 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
         release_object( thread );
         return NULL;
     }
+    if (!init_input_mapping( thread ))
+    {
+        release_object( thread );
+        return NULL;
+    }
 
     set_fd_events( thread->request_fd, POLLIN );  /* start listening to events */
     add_process_thread( thread->process, thread );
@@ -584,6 +621,8 @@ static void cleanup_thread( struct thread *thread )
     free( thread->desc );
     if (thread->queue_shared_mapping) release_object( thread->queue_shared_mapping );
     thread->queue_shared_mapping = NULL;
+    if (thread->input_shared_mapping) release_object( thread->input_shared_mapping );
+    thread->input_shared_mapping = NULL;
     thread->req_data = NULL;
     thread->reply_data = NULL;
     thread->request_fd = NULL;
diff --git a/server/thread.h b/server/thread.h
index 11111111111..11111111111 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -99,6 +99,8 @@ struct thread
     struct fast_sync      *fast_sync;     /* fast synchronization object */
     struct object         *queue_shared_mapping; /* thread queue shared memory mapping */
     volatile struct queue_shared_memory *queue_shared;  /* thread queue shared memory ptr */
+    struct object         *input_shared_mapping; /* thread input shared memory mapping */
+    volatile struct input_shared_memory *input_shared;  /* thread input shared memory ptr */
 };
 
 extern struct thread *current;

From 4faa990701250ede63fbe0565edfa81757db9289 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 17:35:50 +0100
Subject: [PATCH 25/44] server: Move active window to input shared memory.

---
 server/protocol.def |  1 +
 server/queue.c      | 44 ++++++++++++++++++++++++++++----------------
 2 files changed, 29 insertions(+), 16 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -884,6 +884,7 @@ struct input_shared_memory
     unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     int                  created;
     thread_id_t          tid;
+    user_handle_t        active;           /* handle to the active window */
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -103,7 +103,6 @@ struct thread_input
     struct desktop        *desktop;       /* desktop that this thread input belongs to */
     user_handle_t          focus;         /* focus window */
     user_handle_t          capture;       /* capture window */
-    user_handle_t          active;        /* active window */
     user_handle_t          menu_owner;    /* current menu owner window */
     user_handle_t          move_size;     /* current moving/resizing window */
     user_handle_t          caret;         /* caret window */
@@ -319,13 +318,15 @@ static struct thread_input *create_thread_input( struct thread *thread )
     {
         input->shared_mapping = grab_object( thread->input_shared_mapping );
         input->shared = thread->input_shared;
+        SHARED_WRITE_BEGIN( &input->shared->seq );
         input->focus        = 0;
         input->capture      = 0;
-        input->active       = 0;
+        input->shared->active       = 0;
         input->menu_owner   = 0;
         input->move_size    = 0;
         input->cursor       = 0;
         input->cursor_count = 0;
+        SHARED_WRITE_END( &input->shared->seq );
         list_init( &input->msg_list );
         set_caret_window( input, 0 );
         memset( input->keystate, 0, sizeof(input->keystate) );
@@ -1269,7 +1270,7 @@ static void thread_input_dump( struct object *obj, int verbose )
 {
     struct thread_input *input = (struct thread_input *)obj;
     fprintf( stderr, "Thread input focus=%08x capture=%08x active=%08x\n",
-             input->focus, input->capture, input->active );
+             input->focus, input->capture, input->shared->active );
 }
 
 static void thread_input_destroy( struct object *obj )
@@ -1290,12 +1291,14 @@ static inline void thread_input_cleanup_window( struct msg_queue *queue, user_ha
 {
     struct thread_input *input = queue->input;
 
+    SHARED_WRITE_BEGIN( &input->shared->seq );
     if (window == input->focus) input->focus = 0;
     if (window == input->capture) input->capture = 0;
-    if (window == input->active) input->active = 0;
+    if (window == input->shared->active) input->shared->active = 0;
     if (window == input->menu_owner) input->menu_owner = 0;
     if (window == input->move_size) input->move_size = 0;
     if (window == input->caret) set_caret_window( input, 0 );
+    SHARED_WRITE_END( &input->shared->seq );
 }
 
 /* check if the specified window can be set in the input data of a given queue */
@@ -1328,7 +1331,7 @@ int init_thread_queue( struct thread *thread )
 int attach_thread_input( struct thread *thread_from, struct thread *thread_to )
 {
     struct desktop *desktop;
-    struct thread_input *input;
+    struct thread_input *input, *old_input;
     int ret;
 
     if (!thread_to->queue && !(thread_to->queue = create_msg_queue( thread_to, NULL ))) return 0;
@@ -1345,8 +1348,11 @@ int attach_thread_input( struct thread *thread_from, struct thread *thread_to )
 
     if (thread_from->queue)
     {
-        if (!input->focus) input->focus = thread_from->queue->input->focus;
-        if (!input->active) input->active = thread_from->queue->input->active;
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        old_input = thread_from->queue->input;
+        if (!input->focus) input->focus = old_input->focus;
+        if (!input->shared->active) input->shared->active = old_input->shared->active;
+        SHARED_WRITE_END( &input->shared->seq );
     }
 
     ret = assign_thread_input( thread_from, input );
@@ -1372,12 +1378,16 @@ void detach_thread_input( struct thread *thread_from )
             }
             release_object( thread );
         }
-        if (old_input->active && (thread = get_window_thread( old_input->active )))
+        if (old_input->shared->active && (thread = get_window_thread( old_input->shared->active )))
         {
             if (thread == thread_from)
             {
-                input->active = old_input->active;
-                old_input->active = 0;
+                SHARED_WRITE_BEGIN( &input->shared->seq );
+                input->shared->active = old_input->shared->active;
+                SHARED_WRITE_END( &input->shared->seq );
+                SHARED_WRITE_BEGIN( &old_input->shared->seq );
+                old_input->shared->active = 0;
+                SHARED_WRITE_END( &old_input->shared->seq );
             }
             release_object( thread );
         }
@@ -1704,7 +1714,7 @@ static user_handle_t find_hardware_message_window( struct desktop *desktop, stru
     {
         if (input && !(win = input->focus))
         {
-            win = input->active;
+            win = input->shared->active;
             if (*msg_code < WM_SYSKEYDOWN) *msg_code += WM_SYSKEYDOWN - WM_KEYDOWN;
         }
     }
@@ -3328,7 +3338,7 @@ DECL_HANDLER(get_thread_input)
     {
         reply->focus      = input->focus;
         reply->capture    = input->capture;
-        reply->active     = input->active;
+        reply->active     = input->shared->active;
         reply->menu_owner = input->menu_owner;
         reply->move_size  = input->move_size;
         reply->caret      = input->caret;
@@ -3338,7 +3348,7 @@ DECL_HANDLER(get_thread_input)
     }
 
     /* foreground window is active window of foreground thread */
-    reply->foreground = desktop->foreground_input ? desktop->foreground_input->active : 0;
+    reply->foreground = desktop->foreground_input ? desktop->foreground_input->shared->active : 0;
     if (thread) release_object( thread );
     release_object( desktop );
 }
@@ -3405,7 +3415,7 @@ DECL_HANDLER(set_foreground_window)
     struct msg_queue *queue = get_current_queue();
 
     if (!(desktop = get_thread_desktop( current, 0 ))) return;
-    reply->previous = desktop->foreground_input ? desktop->foreground_input->active : 0;
+    reply->previous = desktop->foreground_input ? desktop->foreground_input->shared->active : 0;
     reply->send_msg_old = (reply->previous && desktop->foreground_input != queue->input);
     reply->send_msg_new = FALSE;
 
@@ -3447,8 +3457,10 @@ DECL_HANDLER(set_active_window)
     {
         if (!req->handle || make_window_active( req->handle ))
         {
-            reply->previous = queue->input->active;
-            queue->input->active = get_user_full_handle( req->handle );
+            reply->previous = queue->input->shared->active;
+            SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+            queue->input->shared->active = get_user_full_handle( req->handle );
+            SHARED_WRITE_END( &queue->input->shared->seq );
         }
         else set_error( STATUS_INVALID_HANDLE );
     }

From e5b6abb3a523b76484f845038ac8c4d7cd251647 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 22:09:12 +0100
Subject: [PATCH 27/44] server: Move focus window to input shared memory.

---
 server/protocol.def |  1 +
 server/queue.c      | 33 +++++++++++++++++++--------------
 2 files changed, 20 insertions(+), 14 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -884,6 +884,7 @@ struct input_shared_memory
     unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     int                  created;
     thread_id_t          tid;
+    user_handle_t        focus;            /* handle to the focus window */
     user_handle_t        active;           /* handle to the active window */
 };
 
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -101,7 +101,6 @@ struct thread_input
 {
     struct object          obj;           /* object header */
     struct desktop        *desktop;       /* desktop that this thread input belongs to */
-    user_handle_t          focus;         /* focus window */
     user_handle_t          capture;       /* capture window */
     user_handle_t          menu_owner;    /* current menu owner window */
     user_handle_t          move_size;     /* current moving/resizing window */
@@ -319,7 +318,7 @@ static struct thread_input *create_thread_input( struct thread *thread )
         input->shared_mapping = grab_object( thread->input_shared_mapping );
         input->shared = thread->input_shared;
         SHARED_WRITE_BEGIN( &input->shared->seq );
-        input->focus        = 0;
+        input->shared->focus        = 0;
         input->capture      = 0;
         input->shared->active       = 0;
         input->menu_owner   = 0;
@@ -1270,7 +1269,7 @@ static void thread_input_dump( struct object *obj, int verbose )
 {
     struct thread_input *input = (struct thread_input *)obj;
     fprintf( stderr, "Thread input focus=%08x capture=%08x active=%08x\n",
-             input->focus, input->capture, input->shared->active );
+             input->shared->focus, input->capture, input->shared->active );
 }
 
 static void thread_input_destroy( struct object *obj )
@@ -1292,7 +1291,7 @@ static inline void thread_input_cleanup_window( struct msg_queue *queue, user_ha
     struct thread_input *input = queue->input;
 
     SHARED_WRITE_BEGIN( &input->shared->seq );
-    if (window == input->focus) input->focus = 0;
+    if (window == input->shared->focus) input->shared->focus = 0;
     if (window == input->capture) input->capture = 0;
     if (window == input->shared->active) input->shared->active = 0;
     if (window == input->menu_owner) input->menu_owner = 0;
@@ -1350,7 +1349,7 @@ int attach_thread_input( struct thread *thread_from, struct thread *thread_to )
     {
         SHARED_WRITE_BEGIN( &input->shared->seq );
         old_input = thread_from->queue->input;
-        if (!input->focus) input->focus = old_input->focus;
+        if (!input->shared->focus) input->shared->focus = old_input->shared->focus;
         if (!input->shared->active) input->shared->active = old_input->shared->active;
         SHARED_WRITE_END( &input->shared->seq );
     }
@@ -1369,12 +1368,16 @@ void detach_thread_input( struct thread *thread_from )
 
     if ((input = create_thread_input( thread_from )))
     {
-        if (old_input->focus && (thread = get_window_thread( old_input->focus )))
+        if (old_input->shared->focus && (thread = get_window_thread( old_input->shared->focus )))
         {
             if (thread == thread_from)
             {
-                input->focus = old_input->focus;
-                old_input->focus = 0;
+                SHARED_WRITE_BEGIN( &input->shared->seq );
+                input->shared->focus = old_input->shared->focus;
+                SHARED_WRITE_END( &input->shared->seq );
+                SHARED_WRITE_BEGIN( &old_input->shared->seq );
+                old_input->shared->focus = 0;
+                SHARED_WRITE_END( &old_input->shared->seq );
             }
             release_object( thread );
         }
@@ -1708,11 +1711,11 @@ static user_handle_t find_hardware_message_window( struct desktop *desktop, stru
     *msg_code = msg->msg;
     if (msg->msg == WM_INPUT || msg->msg == WM_INPUT_DEVICE_CHANGE)
     {
-        if (!(win = msg->win) && input) win = input->focus;
+        if (!(win = msg->win) && input) win = input->shared->focus;
     }
     else if (is_keyboard_msg( msg ))
     {
-        if (input && !(win = input->focus))
+        if (input && !(win = input->shared->focus))
         {
             win = input->shared->active;
             if (*msg_code < WM_SYSKEYDOWN) *msg_code += WM_SYSKEYDOWN - WM_KEYDOWN;
@@ -1892,7 +1895,7 @@ static int send_hook_ll_message( struct desktop *desktop, struct message *hardwa
 static struct thread *get_foreground_thread( struct desktop *desktop, user_handle_t window )
 {
     /* if desktop has no foreground process, assume the receiving window is */
-    if (desktop->foreground_input) return get_window_thread( desktop->foreground_input->focus );
+    if (desktop->foreground_input) return get_window_thread( desktop->foreground_input->shared->focus );
     if (window) return get_window_thread( window );
     return NULL;
 }
@@ -3336,7 +3339,7 @@ DECL_HANDLER(get_thread_input)
 
     if (input)
     {
-        reply->focus      = input->focus;
+        reply->focus      = input->shared->focus;
         reply->capture    = input->capture;
         reply->active     = input->shared->active;
         reply->menu_owner = input->menu_owner;
@@ -3441,8 +3444,10 @@ DECL_HANDLER(set_focus_window)
     reply->previous = 0;
     if (queue && check_queue_input_window( queue, req->handle ))
     {
-        reply->previous = queue->input->focus;
-        queue->input->focus = get_user_full_handle( req->handle );
+        reply->previous = queue->input->shared->focus;
+        SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+        queue->input->shared->focus = get_user_full_handle( req->handle );
+        SHARED_WRITE_END( &queue->input->shared->seq );
     }
 }
 

From ce9855cbfc8a40565f1087b3e52612d0616747f2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 17:58:36 +0100
Subject: [PATCH 29/44] server: Add foreground TID to desktop shared memory.

---
 server/protocol.def | 1 +
 server/queue.c      | 3 +++
 2 files changed, 4 insertions(+)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -866,6 +866,7 @@ struct desktop_shared_memory
     unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     struct shared_cursor cursor;           /* global cursor information */
     unsigned char        keystate[256];    /* asynchronous key state */
+    thread_id_t          foreground_tid;   /* tid of the foreground thread */
 };
 
 struct queue_shared_memory
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -584,6 +584,9 @@ static void set_foreground_input( struct desktop *desktop, struct thread_input *
     if (desktop->foreground_input == input) return;
     set_clip_rectangle( desktop, NULL, 1 );
     desktop->foreground_input = input;
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
+    desktop->shared->foreground_tid = input ? input->shared->tid : 0;
+    SHARED_WRITE_END( &desktop->shared->seq );
 }
 
 /* get the hook table for a given thread */

From ca77e4d54b94134ede5fd155e8af5eda7ae36a0c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 17:58:36 +0100
Subject: [PATCH 30/44] win32u: Use desktop shared memory for
 GetForegroundWindow.

---
 dlls/win32u/input.c          |  9 +++++----
 dlls/win32u/ntuser_private.h |  2 ++
 dlls/win32u/sysparams.c      |  9 +++++++++
 dlls/win32u/win32u_private.h |  1 +
 dlls/win32u/winstation.c     | 37 ++++++++++++++++++++++++++++++++++++
 include/ntuser.h             |  1 +
 6 files changed, 55 insertions(+), 4 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -1089,14 +1089,15 @@ BOOL WINAPI release_capture(void)
  */
 HWND WINAPI NtUserGetForegroundWindow(void)
 {
+    volatile struct input_shared_memory *shared = (void *)NtUserCallNoParam( NtUserGetForegroundSharedMemory );
     HWND ret = 0;
 
-    SERVER_START_REQ( get_thread_input )
+    if (!shared) return 0;
+    SHARED_READ_BEGIN( &shared->seq )
     {
-        req->tid = 0;
-        if (!wine_server_call_err( req )) ret = wine_server_ptr_handle( reply->foreground );
+        ret = wine_server_ptr_handle( shared->active );
     }
-    SERVER_END_REQ;
+    SHARED_READ_END( &shared->seq );
     return ret;
 }
 
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -166,6 +166,8 @@ struct user_thread_info
     struct desktop_shared_memory *desktop_shared_memory;  /* Ptr to server's desktop shared memory */
     HANDLE                        queue_shared_map;       /* HANDLE to server's thread queue shared memory */
     struct queue_shared_memory   *queue_shared_memory;     /* Ptr to server's thread queue shared memory */
+    HANDLE                        foreground_shared_map;    /* HANDLE to server's thread input shared memory */
+    struct input_shared_memory   *foreground_shared_memory; /* Ptr to server's thread input shared memory */
 };
 
 C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo) );
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4624,6 +4624,13 @@ static void thread_detach(void)
         thread_info->queue_shared_memory = NULL;
     }
 
+    if (thread_info->foreground_shared_memory)
+    {
+        NtClose( thread_info->foreground_shared_map );
+        thread_info->foreground_shared_map = NULL;
+        thread_info->foreground_shared_memory = NULL;
+    }
+
     exiting_thread_id = 0;
 }
 
@@ -4651,6 +4658,8 @@ ULONG_PTR WINAPI NtUserCallNoParam( ULONG code )
         return 0;
     case NtUserGetQueueSharedMemory:
         return get_queue_shared_memory();
+    case NtUserGetForegroundSharedMemory:
+        return get_foreground_shared_memory();
     default:
         FIXME( "invalid code %u\n", code );
         return 0;
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -410,6 +410,7 @@ static inline void release_win_ptr( struct tagWND *ptr )
 /* winstation.c */
 extern volatile struct desktop_shared_memory *get_desktop_shared_memory( void ) DECLSPEC_HIDDEN;
 extern volatile struct queue_shared_memory *get_queue_shared_memory( void ) DECLSPEC_HIDDEN;
+extern volatile struct input_shared_memory *get_foreground_shared_memory( void ) DECLSPEC_HIDDEN;
 
 extern void wrappers_init( unixlib_handle_t handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS gdi_init(void) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -653,6 +653,43 @@ volatile struct queue_shared_memory *get_queue_shared_memory( void )
 }
 
 
+static volatile struct input_shared_memory *get_thread_input_shared_memory( DWORD tid, HANDLE *handle,
+                                                                            struct input_shared_memory **ptr )
+{
+    char bufA[MAX_PATH];
+    WCHAR buf[MAX_PATH];
+    UINT len;
+
+    if (*ptr && (*ptr)->tid == tid) return *ptr;
+    if (*ptr) NtClose( *handle );
+
+    snprintf( bufA, ARRAY_SIZE(buf), "\\KernelObjects\\__wine_thread_mappings\\%08x-input", tid );
+    len = asciiz_to_unicode( buf, bufA ) / sizeof(WCHAR) - 1;
+    map_shared_memory_section( buf, len, sizeof(struct input_shared_memory), NULL,
+                               handle, (void **)ptr );
+    return *ptr;
+}
+
+
+volatile struct input_shared_memory *get_foreground_shared_memory( void )
+{
+    volatile struct desktop_shared_memory *desktop = get_desktop_shared_memory();
+    struct user_thread_info *thread_info = get_user_thread_info();
+    DWORD tid;
+
+    if (!desktop) return NULL;
+    SHARED_READ_BEGIN( &desktop->seq )
+    {
+        tid = desktop->foreground_tid;
+    }
+    SHARED_READ_END( &desktop->seq );
+
+    if (!tid) return NULL;
+    return get_thread_input_shared_memory( tid, &thread_info->foreground_shared_map,
+                                           &thread_info->foreground_shared_memory );
+}
+
+
 /***********************************************************************
  *           winstation_init
  *
diff --git a/include/ntuser.h b/include/ntuser.h
index 11111111111..11111111111 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -129,6 +129,7 @@ enum
     NtUserExitingThread,
     NtUserThreadDetach,
     NtUserGetQueueSharedMemory,
+    NtUserGetForegroundSharedMemory,
 };
 
 /* NtUserCallOneParam codes, not compatible with Windows */

From cde69743bd41781e7399d28340170fdd53f41ed0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 22:10:36 +0100
Subject: [PATCH 31/44] server: Move capture window to input shared memory.

As well as menu owner / menu size window handles.
---
 server/protocol.def |  3 +++
 server/queue.c      | 39 +++++++++++++++++++--------------------
 2 files changed, 22 insertions(+), 20 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -886,7 +886,10 @@ struct input_shared_memory
     int                  created;
     thread_id_t          tid;
     user_handle_t        focus;            /* handle to the focus window */
+    user_handle_t        capture;          /* handle to the capture window */
     user_handle_t        active;           /* handle to the active window */
+    user_handle_t        menu_owner;       /* handle to the menu owner */
+    user_handle_t        move_size;        /* handle to the moving/resizing window */
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -101,9 +101,6 @@ struct thread_input
 {
     struct object          obj;           /* object header */
     struct desktop        *desktop;       /* desktop that this thread input belongs to */
-    user_handle_t          capture;       /* capture window */
-    user_handle_t          menu_owner;    /* current menu owner window */
-    user_handle_t          move_size;     /* current moving/resizing window */
     user_handle_t          caret;         /* caret window */
     rectangle_t            caret_rect;    /* caret rectangle */
     int                    caret_hide;    /* caret hide count */
@@ -319,10 +316,10 @@ static struct thread_input *create_thread_input( struct thread *thread )
         input->shared = thread->input_shared;
         SHARED_WRITE_BEGIN( &input->shared->seq );
         input->shared->focus        = 0;
-        input->capture      = 0;
+        input->shared->capture      = 0;
         input->shared->active       = 0;
-        input->menu_owner   = 0;
-        input->move_size    = 0;
+        input->shared->menu_owner   = 0;
+        input->shared->move_size    = 0;
         input->cursor       = 0;
         input->cursor_count = 0;
         SHARED_WRITE_END( &input->shared->seq );
@@ -1272,7 +1269,7 @@ static void thread_input_dump( struct object *obj, int verbose )
 {
     struct thread_input *input = (struct thread_input *)obj;
     fprintf( stderr, "Thread input focus=%08x capture=%08x active=%08x\n",
-             input->shared->focus, input->capture, input->shared->active );
+             input->shared->focus, input->shared->capture, input->shared->active );
 }
 
 static void thread_input_destroy( struct object *obj )
@@ -1295,10 +1292,10 @@ static inline void thread_input_cleanup_window( struct msg_queue *queue, user_ha
 
     SHARED_WRITE_BEGIN( &input->shared->seq );
     if (window == input->shared->focus) input->shared->focus = 0;
-    if (window == input->capture) input->capture = 0;
+    if (window == input->shared->capture) input->shared->capture = 0;
     if (window == input->shared->active) input->shared->active = 0;
-    if (window == input->menu_owner) input->menu_owner = 0;
-    if (window == input->move_size) input->move_size = 0;
+    if (window == input->shared->menu_owner) input->shared->menu_owner = 0;
+    if (window == input->shared->move_size) input->shared->move_size = 0;
     if (window == input->caret) set_caret_window( input, 0 );
     SHARED_WRITE_END( &input->shared->seq );
 }
@@ -1724,7 +1721,7 @@ static user_handle_t find_hardware_message_window( struct desktop *desktop, stru
             if (*msg_code < WM_SYSKEYDOWN) *msg_code += WM_SYSKEYDOWN - WM_KEYDOWN;
         }
     }
-    else if (!input || !(win = input->capture)) /* mouse message */
+    else if (!input || !(win = input->shared->capture)) /* mouse message */
     {
         if (is_window_visible( msg->win ) && !is_window_transparent( msg->win )) win = msg->win;
         else win = shallow_window_from_point( desktop, msg->x, msg->y );
@@ -3343,10 +3340,10 @@ DECL_HANDLER(get_thread_input)
     if (input)
     {
         reply->focus      = input->shared->focus;
-        reply->capture    = input->capture;
+        reply->capture    = input->shared->capture;
         reply->active     = input->shared->active;
-        reply->menu_owner = input->menu_owner;
-        reply->move_size  = input->move_size;
+        reply->menu_owner = input->shared->menu_owner;
+        reply->move_size  = input->shared->move_size;
         reply->caret      = input->caret;
         reply->cursor     = input->cursor;
         reply->show_count = input->cursor_count;
@@ -3486,16 +3483,18 @@ DECL_HANDLER(set_capture_window)
         struct thread_input *input = queue->input;
 
         /* if in menu mode, reject all requests to change focus, except if the menu bit is set */
-        if (input->menu_owner && !(req->flags & CAPTURE_MENU))
+        if (input->shared->menu_owner && !(req->flags & CAPTURE_MENU))
         {
             set_error(STATUS_ACCESS_DENIED);
             return;
         }
-        reply->previous = input->capture;
-        input->capture = get_user_full_handle( req->handle );
-        input->menu_owner = (req->flags & CAPTURE_MENU) ? input->capture : 0;
-        input->move_size = (req->flags & CAPTURE_MOVESIZE) ? input->capture : 0;
-        reply->full_handle = input->capture;
+        reply->previous = input->shared->capture;
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        input->shared->capture = get_user_full_handle( req->handle );
+        input->shared->menu_owner = (req->flags & CAPTURE_MENU) ? input->shared->capture : 0;
+        input->shared->move_size = (req->flags & CAPTURE_MOVESIZE) ? input->shared->capture : 0;
+        SHARED_WRITE_END( &input->shared->seq );
+        reply->full_handle = input->shared->capture;
     }
 }
 

From 2f7d72a74d8a8f1fcb9721e7f9abe484dbb4e015 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 18:44:03 +0100
Subject: [PATCH 33/44] server: Move caret window and rect to input shared
 memory.

---
 server/protocol.def |  2 ++
 server/queue.c      | 48 ++++++++++++++++++++++++---------------------
 2 files changed, 28 insertions(+), 22 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -890,6 +890,8 @@ struct input_shared_memory
     user_handle_t        active;           /* handle to the active window */
     user_handle_t        menu_owner;       /* handle to the menu owner */
     user_handle_t        move_size;        /* handle to the moving/resizing window */
+    user_handle_t        caret;            /* handle to the caret window */
+    rectangle_t          caret_rect;       /* caret rectangle */
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -101,8 +101,6 @@ struct thread_input
 {
     struct object          obj;           /* object header */
     struct desktop        *desktop;       /* desktop that this thread input belongs to */
-    user_handle_t          caret;         /* caret window */
-    rectangle_t            caret_rect;    /* caret rectangle */
     int                    caret_hide;    /* caret hide count */
     int                    caret_state;   /* caret on/off state */
     user_handle_t          cursor;        /* current cursor */
@@ -293,16 +291,18 @@ static void free_message( struct message *msg );
 /* set the caret window in a given thread input */
 static void set_caret_window( struct thread_input *input, user_handle_t win )
 {
-    if (!win || win != input->caret)
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    if (!win || win != input->shared->caret)
     {
-        input->caret_rect.left   = 0;
-        input->caret_rect.top    = 0;
-        input->caret_rect.right  = 0;
-        input->caret_rect.bottom = 0;
+        input->shared->caret_rect.left   = 0;
+        input->shared->caret_rect.top    = 0;
+        input->shared->caret_rect.right  = 0;
+        input->shared->caret_rect.bottom = 0;
     }
-    input->caret             = win;
+    input->shared->caret     = win;
     input->caret_hide        = 1;
     input->caret_state       = 0;
+    SHARED_WRITE_END( &input->shared->seq );
 }
 
 /* create a thread input object */
@@ -1296,7 +1296,7 @@ static inline void thread_input_cleanup_window( struct msg_queue *queue, user_ha
     if (window == input->shared->active) input->shared->active = 0;
     if (window == input->shared->menu_owner) input->shared->menu_owner = 0;
     if (window == input->shared->move_size) input->shared->move_size = 0;
-    if (window == input->caret) set_caret_window( input, 0 );
+    if (window == input->shared->caret) set_caret_window( input, 0 );
     SHARED_WRITE_END( &input->shared->seq );
 }
 
@@ -3344,10 +3344,10 @@ DECL_HANDLER(get_thread_input)
         reply->active     = input->shared->active;
         reply->menu_owner = input->shared->menu_owner;
         reply->move_size  = input->shared->move_size;
-        reply->caret      = input->caret;
+        reply->caret      = input->shared->caret;
         reply->cursor     = input->cursor;
         reply->show_count = input->cursor_count;
-        reply->rect       = input->caret_rect;
+        reply->rect       = input->shared->caret_rect;
     }
 
     /* foreground window is active window of foreground thread */
@@ -3509,14 +3509,16 @@ DECL_HANDLER(set_caret_window)
     {
         struct thread_input *input = queue->input;
 
-        reply->previous  = input->caret;
-        reply->old_rect  = input->caret_rect;
+        reply->previous  = input->shared->caret;
+        reply->old_rect  = input->shared->caret_rect;
         reply->old_hide  = input->caret_hide;
         reply->old_state = input->caret_state;
 
+        SHARED_WRITE_BEGIN( &input->shared->seq );
         set_caret_window( input, get_user_full_handle(req->handle) );
-        input->caret_rect.right  = input->caret_rect.left + req->width;
-        input->caret_rect.bottom = input->caret_rect.top + req->height;
+        input->shared->caret_rect.right  = input->shared->caret_rect.left + req->width;
+        input->shared->caret_rect.bottom = input->shared->caret_rect.top + req->height;
+        SHARED_WRITE_END( &input->shared->seq );
     }
 }
 
@@ -3529,22 +3531,24 @@ DECL_HANDLER(set_caret_info)
 
     if (!queue) return;
     input = queue->input;
-    reply->full_handle = input->caret;
-    reply->old_rect    = input->caret_rect;
+    reply->full_handle = input->shared->caret;
+    reply->old_rect    = input->shared->caret_rect;
     reply->old_hide    = input->caret_hide;
     reply->old_state   = input->caret_state;
 
-    if (req->handle && get_user_full_handle(req->handle) != input->caret)
+    if (req->handle && get_user_full_handle(req->handle) != input->shared->caret)
     {
         set_error( STATUS_ACCESS_DENIED );
         return;
     }
     if (req->flags & SET_CARET_POS)
     {
-        input->caret_rect.right  += req->x - input->caret_rect.left;
-        input->caret_rect.bottom += req->y - input->caret_rect.top;
-        input->caret_rect.left = req->x;
-        input->caret_rect.top  = req->y;
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        input->shared->caret_rect.right  += req->x - input->shared->caret_rect.left;
+        input->shared->caret_rect.bottom += req->y - input->shared->caret_rect.top;
+        input->shared->caret_rect.left = req->x;
+        input->shared->caret_rect.top  = req->y;
+        SHARED_WRITE_END( &input->shared->seq );
     }
     if (req->flags & SET_CARET_HIDE)
     {

From c2f5ed4a58ea39c4672edbf98138dbab7da54361 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 19:05:34 +0100
Subject: [PATCH 34/44] win32u: Use input shared memory for GetGUIThreadInfo.

When the current thread is requested.
---
 dlls/win32u/message.c        | 28 ++++++++++++++++++++++++++++
 dlls/win32u/ntuser_private.h |  2 ++
 dlls/win32u/sysparams.c      |  9 +++++++++
 dlls/win32u/win32u_private.h |  1 +
 dlls/win32u/winstation.c     | 18 ++++++++++++++++++
 include/ntuser.h             |  1 +
 6 files changed, 59 insertions(+)

diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -167,6 +167,7 @@ DWORD WINAPI NtUserWaitForInputIdle( HANDLE process, DWORD timeout, BOOL wow )
  */
 BOOL WINAPI NtUserGetGUIThreadInfo( DWORD id, GUITHREADINFO *info )
 {
+    volatile struct input_shared_memory *shared;
     BOOL ret;
 
     if (info->cbSize != sizeof(*info))
@@ -175,6 +176,33 @@ BOOL WINAPI NtUserGetGUIThreadInfo( DWORD id, GUITHREADINFO *info )
         return FALSE;
     }
 
+    if (id == GetCurrentThreadId()) shared = get_input_shared_memory();
+    else if (id == 0) shared = get_foreground_shared_memory();
+    else shared = NULL;
+
+    if (shared)
+    {
+        SHARED_READ_BEGIN( &shared->seq )
+        {
+            info->flags          = 0;
+            info->hwndActive     = wine_server_ptr_handle( shared->active );
+            info->hwndFocus      = wine_server_ptr_handle( shared->focus );
+            info->hwndCapture    = wine_server_ptr_handle( shared->capture );
+            info->hwndMenuOwner  = wine_server_ptr_handle( shared->menu_owner );
+            info->hwndMoveSize   = wine_server_ptr_handle( shared->move_size );
+            info->hwndCaret      = wine_server_ptr_handle( shared->caret );
+            info->rcCaret.left   = shared->caret_rect.left;
+            info->rcCaret.top    = shared->caret_rect.top;
+            info->rcCaret.right  = shared->caret_rect.right;
+            info->rcCaret.bottom = shared->caret_rect.bottom;
+        }
+        SHARED_READ_END( &shared->seq );
+        if (info->hwndMenuOwner) info->flags |= GUI_INMENUMODE;
+        if (info->hwndMoveSize) info->flags |= GUI_INMOVESIZE;
+        if (info->hwndCaret) info->flags |= GUI_CARETBLINKING;
+        return TRUE;
+    }
+
     SERVER_START_REQ( get_thread_input )
     {
         req->tid = id;
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -166,6 +166,8 @@ struct user_thread_info
     struct desktop_shared_memory *desktop_shared_memory;  /* Ptr to server's desktop shared memory */
     HANDLE                        queue_shared_map;       /* HANDLE to server's thread queue shared memory */
     struct queue_shared_memory   *queue_shared_memory;     /* Ptr to server's thread queue shared memory */
+    HANDLE                        input_shared_map;       /* HANDLE to server's thread input shared memory */
+    struct input_shared_memory   *input_shared_memory;    /* Ptr to server's thread input shared memory */
     HANDLE                        foreground_shared_map;    /* HANDLE to server's thread input shared memory */
     struct input_shared_memory   *foreground_shared_memory; /* Ptr to server's thread input shared memory */
 };
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4631,6 +4631,13 @@ static void thread_detach(void)
         thread_info->foreground_shared_memory = NULL;
     }
 
+    if (thread_info->input_shared_map)
+    {
+        NtClose( thread_info->input_shared_map );
+        thread_info->input_shared_map = NULL;
+        thread_info->input_shared_memory = NULL;
+    }
+
     exiting_thread_id = 0;
 }
 
@@ -4658,6 +4665,8 @@ ULONG_PTR WINAPI NtUserCallNoParam( ULONG code )
         return 0;
     case NtUserGetQueueSharedMemory:
         return get_queue_shared_memory();
+    case NtUserGetInputSharedMemory:
+        return get_input_shared_memory();
     case NtUserGetForegroundSharedMemory:
         return get_foreground_shared_memory();
     default:
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -410,6 +410,7 @@ static inline void release_win_ptr( struct tagWND *ptr )
 /* winstation.c */
 extern volatile struct desktop_shared_memory *get_desktop_shared_memory( void ) DECLSPEC_HIDDEN;
 extern volatile struct queue_shared_memory *get_queue_shared_memory( void ) DECLSPEC_HIDDEN;
+extern volatile struct input_shared_memory *get_input_shared_memory( void ) DECLSPEC_HIDDEN;
 extern volatile struct input_shared_memory *get_foreground_shared_memory( void ) DECLSPEC_HIDDEN;
 
 extern void wrappers_init( unixlib_handle_t handle ) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -671,6 +671,24 @@ static volatile struct input_shared_memory *get_thread_input_shared_memory( DWOR
 }
 
 
+volatile struct input_shared_memory *get_input_shared_memory( void )
+{
+    volatile struct queue_shared_memory *queue = get_queue_shared_memory();
+    struct user_thread_info *thread_info = get_user_thread_info();
+    DWORD tid;
+
+    if (!queue) return NULL;
+    SHARED_READ_BEGIN( &queue->seq )
+    {
+        tid = queue->input_tid;
+    }
+    SHARED_READ_END( &queue->seq );
+
+    return get_thread_input_shared_memory( tid, &thread_info->input_shared_map,
+                                           &thread_info->input_shared_memory );
+}
+
+
 volatile struct input_shared_memory *get_foreground_shared_memory( void )
 {
     volatile struct desktop_shared_memory *desktop = get_desktop_shared_memory();
diff --git a/include/ntuser.h b/include/ntuser.h
index 11111111111..11111111111 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -129,6 +129,7 @@ enum
     NtUserExitingThread,
     NtUserThreadDetach,
     NtUserGetQueueSharedMemory,
+    NtUserGetInputSharedMemory,
     NtUserGetForegroundSharedMemory,
 };
 

From 5dff1abe64d7bf7101719238bea1b38503674e7f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 22:11:03 +0100
Subject: [PATCH 35/44] server: Add cursor handle and count to desktop shared
 memory.

---
 server/protocol.def |  2 ++
 server/queue.c      | 44 ++++++++++++++++++++++++++------------------
 2 files changed, 28 insertions(+), 18 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -891,7 +891,9 @@ struct input_shared_memory
     user_handle_t        menu_owner;       /* handle to the menu owner */
     user_handle_t        move_size;        /* handle to the moving/resizing window */
     user_handle_t        caret;            /* handle to the caret window */
+    user_handle_t        cursor;           /* handle to the cursor */
     rectangle_t          caret_rect;       /* caret rectangle */
+    int                  cursor_count;     /* cursor show count */
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -103,8 +103,6 @@ struct thread_input
     struct desktop        *desktop;       /* desktop that this thread input belongs to */
     int                    caret_hide;    /* caret hide count */
     int                    caret_state;   /* caret on/off state */
-    user_handle_t          cursor;        /* current cursor */
-    int                    cursor_count;  /* cursor show count */
     struct list            msg_list;      /* list of hardware messages */
     unsigned char          keystate[256]; /* state of each key */
     unsigned char          desktop_keystate[256]; /* desktop keystate when keystate was synced */
@@ -320,8 +318,8 @@ static struct thread_input *create_thread_input( struct thread *thread )
         input->shared->active       = 0;
         input->shared->menu_owner   = 0;
         input->shared->move_size    = 0;
-        input->cursor       = 0;
-        input->cursor_count = 0;
+        input->shared->cursor       = 0;
+        input->shared->cursor_count = 0;
         SHARED_WRITE_END( &input->shared->seq );
         list_init( &input->msg_list );
         set_caret_window( input, 0 );
@@ -455,13 +453,17 @@ static int assign_thread_input( struct thread *thread, struct thread_input *new_
     }
     if (queue->input)
     {
-        queue->input->cursor_count -= queue->cursor_count;
+        SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+        queue->input->shared->cursor_count -= queue->cursor_count;
+        SHARED_WRITE_END( &queue->input->shared->seq );
         if (queue->keystate_lock) unlock_input_keystate( queue->input );
         release_object( queue->input );
     }
     queue->input = (struct thread_input *)grab_object( new_input );
     if (queue->keystate_lock) lock_input_keystate( queue->input );
-    new_input->cursor_count += queue->cursor_count;
+    SHARED_WRITE_BEGIN( &new_input->shared->seq );
+    new_input->shared->cursor_count += queue->cursor_count;
+    SHARED_WRITE_END( &new_input->shared->seq );
 
     SHARED_WRITE_BEGIN( &queue->shared->seq );
     queue->shared->input_tid = queue->input->shared->tid;
@@ -1246,7 +1248,9 @@ static void msg_queue_destroy( struct object *obj )
         free( timer );
     }
     if (queue->timeout) remove_timeout_user( queue->timeout );
-    queue->input->cursor_count -= queue->cursor_count;
+    SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+    queue->input->shared->cursor_count -= queue->cursor_count;
+    SHARED_WRITE_END( &queue->input->shared->seq );
     if (queue->keystate_lock) unlock_input_keystate( queue->input );
     release_object( queue->input );
     if (queue->hooks) release_object( queue->hooks );
@@ -3345,8 +3349,8 @@ DECL_HANDLER(get_thread_input)
         reply->menu_owner = input->shared->menu_owner;
         reply->move_size  = input->shared->move_size;
         reply->caret      = input->shared->caret;
-        reply->cursor     = input->cursor;
-        reply->show_count = input->cursor_count;
+        reply->cursor     = input->shared->cursor;
+        reply->show_count = input->shared->cursor_count;
         reply->rect       = input->shared->caret_rect;
     }
 
@@ -3585,25 +3589,29 @@ DECL_HANDLER(set_cursor)
     if (!queue) return;
     input = queue->input;
 
-    reply->prev_handle = input->cursor;
-    reply->prev_count  = input->cursor_count;
+    reply->prev_handle = input->shared->cursor;
+    reply->prev_count  = input->shared->cursor_count;
     reply->prev_x      = input->desktop->shared->cursor.x;
     reply->prev_y      = input->desktop->shared->cursor.y;
 
+    if ((req->flags & SET_CURSOR_HANDLE) && req->handle &&
+        !get_user_object( req->handle, USER_CLIENT ))
+    {
+        set_win32_error( ERROR_INVALID_CURSOR_HANDLE );
+        return;
+    }
+
+    SHARED_WRITE_BEGIN( &input->shared->seq );
     if (req->flags & SET_CURSOR_HANDLE)
     {
-        if (req->handle && !get_user_object( req->handle, USER_CLIENT ))
-        {
-            set_win32_error( ERROR_INVALID_CURSOR_HANDLE );
-            return;
-        }
-        input->cursor = req->handle;
+        input->shared->cursor = req->handle;
     }
     if (req->flags & SET_CURSOR_COUNT)
     {
         queue->cursor_count += req->show_count;
-        input->cursor_count += req->show_count;
+        input->shared->cursor_count += req->show_count;
     }
+    SHARED_WRITE_END( &input->shared->seq );
     if (req->flags & SET_CURSOR_POS)
     {
         set_cursor_pos( input->desktop, req->x, req->y );

From 767573f9d1e60eda9bd96a967087be7833711883 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 19:19:51 +0100
Subject: [PATCH 36/44] win32u: Use input shared memory for GetCursorInfo.

---
 dlls/win32u/input.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -143,20 +143,19 @@ BOOL get_cursor_pos( POINT *pt )
  */
 BOOL WINAPI NtUserGetCursorInfo( CURSORINFO *info )
 {
+    volatile struct input_shared_memory *shared = get_foreground_shared_memory();
     BOOL ret;
 
     if (!info) return FALSE;
 
-    SERVER_START_REQ( get_thread_input )
+    if (!shared) ret = FALSE;
+    else SHARED_READ_BEGIN( &shared->seq )
     {
-        req->tid = 0;
-        if ((ret = !wine_server_call( req )))
-        {
-            info->hCursor = wine_server_ptr_handle( reply->cursor );
-            info->flags = reply->show_count >= 0 ? CURSOR_SHOWING : 0;
-        }
+        info->hCursor = wine_server_ptr_handle( shared->cursor );
+        info->flags = (shared->cursor_count >= 0) ? CURSOR_SHOWING : 0;
+        ret = TRUE;
     }
-    SERVER_END_REQ;
+    SHARED_READ_END( &shared->seq );
     get_cursor_pos( &info->ptScreenPos );
     return ret;
 }

From be54be762ed7aedc15d980c6702470d0e1ddeb52 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 19:21:09 +0100
Subject: [PATCH 37/44] server: Remove cursor and show_count from
 get_thread_input.

---
 server/protocol.def | 2 --
 server/queue.c      | 2 --
 2 files changed, 4 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2808,8 +2808,6 @@ enum coords_relative
     user_handle_t  menu_owner;    /* handle to the menu owner */
     user_handle_t  move_size;     /* handle to the moving/resizing window */
     user_handle_t  caret;         /* handle to the caret window */
-    user_handle_t  cursor;        /* handle to the cursor */
-    int            show_count;    /* cursor show count */
     rectangle_t    rect;          /* caret rectangle */
 @END
 
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -3349,8 +3349,6 @@ DECL_HANDLER(get_thread_input)
         reply->menu_owner = input->shared->menu_owner;
         reply->move_size  = input->shared->move_size;
         reply->caret      = input->shared->caret;
-        reply->cursor     = input->shared->cursor;
-        reply->show_count = input->shared->cursor_count;
         reply->rect       = input->shared->caret_rect;
     }
 

From 39b9c877184c02da92579ce802a6065b5f13a318 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 22:12:08 +0100
Subject: [PATCH 38/44] server: Remove foreground window from get_thread_input.

---
 server/protocol.def | 1 -
 server/queue.c      | 2 --
 2 files changed, 3 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2804,7 +2804,6 @@ enum coords_relative
     user_handle_t  focus;         /* handle to the focus window */
     user_handle_t  capture;       /* handle to the capture window */
     user_handle_t  active;        /* handle to the active window */
-    user_handle_t  foreground;    /* handle to the global foreground window */
     user_handle_t  menu_owner;    /* handle to the menu owner */
     user_handle_t  move_size;     /* handle to the moving/resizing window */
     user_handle_t  caret;         /* handle to the caret window */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -3352,8 +3352,6 @@ DECL_HANDLER(get_thread_input)
         reply->rect       = input->shared->caret_rect;
     }
 
-    /* foreground window is active window of foreground thread */
-    reply->foreground = desktop->foreground_input ? desktop->foreground_input->shared->active : 0;
     if (thread) release_object( thread );
     release_object( desktop );
 }

From 220995052ae29bf019797b94acda32edea1ef2ac Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 1 Mar 2021 20:19:52 +0100
Subject: [PATCH 39/44] HACK: win32u: Always pretend that GetAsyncKeyState
 recent bit is 0.

---
 dlls/win32u/input.c | 19 +------------------
 1 file changed, 1 insertion(+), 18 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -173,7 +173,6 @@ SHORT WINAPI NtUserGetAsyncKeyState( INT key )
 {
     volatile struct desktop_shared_memory *shared = get_desktop_shared_memory();
     BYTE state;
-    SHORT ret;
 
     if (key < 0 || key >= 256 || !shared) return 0;
 
@@ -185,23 +184,7 @@ SHORT WINAPI NtUserGetAsyncKeyState( INT key )
     }
     SHARED_READ_END( &shared->seq );
 
-    if (!(state & 0x40)) return (state & 0x80) << 8;
-
-    /* Need to make a server call to reset the last pressed bit */
-    ret = 0;
-    SERVER_START_REQ( get_key_state )
-    {
-        req->async = 1;
-        req->key = key;
-        if (!wine_server_call( req ))
-        {
-            if (reply->state & 0x40) ret |= 0x0001;
-            if (reply->state & 0x80) ret |= 0x8000;
-        }
-    }
-    SERVER_END_REQ;
-
-    return ret;
+    return (state & 0x80) << 8;
 }
 

 /***********************************************************************
From 1fc99ceb6a3d1adfcd0330be374ba6abe50543f7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 17 Aug 2021 16:25:35 +0200
Subject: [PATCH 40/44] server: Only return full keystate when requested.

---
 server/queue.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -3373,7 +3373,7 @@ DECL_HANDLER(get_key_state)
             desktop->shared->keystate[req->key & 0xff] &= ~0x40;
             SHARED_WRITE_END( &desktop->shared->seq );
         }
-        set_reply_data( (void *)desktop->shared->keystate, size );
+        else set_reply_data( (void *)desktop->shared->keystate, size );
         release_object( desktop );
     }
     else
@@ -3385,7 +3385,7 @@ DECL_HANDLER(get_key_state)
             sync_input_keystate( queue->input );
             reply->state = keystate[req->key & 0xff];
         }
-        set_reply_data( keystate, size );
+        else set_reply_data( keystate, size );
     }
 }
 

From f3f46208febe592baf64c9e475556cbe6ae03fcf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 17 Aug 2021 17:14:13 +0200
Subject: [PATCH 41/44] server: Expose thread input keystate through shared
 memory.

---
 server/protocol.def |  1 +
 server/queue.c      | 26 ++++++++++++++++++--------
 2 files changed, 19 insertions(+), 8 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -894,6 +894,7 @@ struct input_shared_memory
     user_handle_t        cursor;           /* handle to the cursor */
     rectangle_t          caret_rect;       /* caret rectangle */
     int                  cursor_count;     /* cursor show count */
+    unsigned char        keystate[256];    /* key state */
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -104,7 +104,6 @@ struct thread_input
     int                    caret_hide;    /* caret hide count */
     int                    caret_state;   /* caret on/off state */
     struct list            msg_list;      /* list of hardware messages */
-    unsigned char          keystate[256]; /* state of each key */
     unsigned char          desktop_keystate[256]; /* desktop keystate when keystate was synced */
     int                    keystate_lock; /* keystate is locked */
     struct object         *shared_mapping; /* thread input shared memory mapping */
@@ -320,10 +319,10 @@ static struct thread_input *create_thread_input( struct thread *thread )
         input->shared->move_size    = 0;
         input->shared->cursor       = 0;
         input->shared->cursor_count = 0;
+        memset( (void *)input->shared->keystate, 0, sizeof(input->shared->keystate) );
         SHARED_WRITE_END( &input->shared->seq );
         list_init( &input->msg_list );
         set_caret_window( input, 0 );
-        memset( input->keystate, 0, sizeof(input->keystate) );
         input->keystate_lock = 0;
 
         if (!(input->desktop = get_thread_desktop( thread, 0 /* FIXME: access rights */ )))
@@ -421,11 +420,13 @@ static void sync_input_keystate( struct thread_input *input )
 {
     int i;
     if (!input->desktop || input->keystate_lock) return;
-    for (i = 0; i < sizeof(input->keystate); ++i)
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    for (i = 0; i < sizeof(input->shared->keystate); ++i)
     {
         if (input->desktop_keystate[i] == input->desktop->shared->keystate[i]) continue;
-        input->keystate[i] = input->desktop_keystate[i] = input->desktop->shared->keystate[i];
+        input->shared->keystate[i] = input->desktop_keystate[i] = input->desktop->shared->keystate[i];
     }
+    SHARED_WRITE_END( &input->shared->seq );
 }
 
 /* locks thread input keystate to prevent synchronization */
@@ -1359,7 +1360,12 @@ int attach_thread_input( struct thread *thread_from, struct thread *thread_to )
     }
 
     ret = assign_thread_input( thread_from, input );
-    if (ret) memset( input->keystate, 0, sizeof(input->keystate) );
+    if (ret)
+    {
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        memset( (void *)input->shared->keystate, 0, sizeof(input->shared->keystate) );
+        SHARED_WRITE_END( &input->shared->seq );
+    }
     release_object( input );
     return ret;
 }
@@ -1602,7 +1608,9 @@ static void update_key_state( volatile unsigned char *keystate, unsigned int msg
 
 static void update_input_key_state( struct thread_input *input, unsigned int msg, lparam_t wparam )
 {
-    update_key_state( input->keystate, msg, wparam, 0 );
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    update_key_state( input->shared->keystate, msg, wparam, 0 );
+    SHARED_WRITE_END( &input->shared->seq );
 }
 
 static void update_desktop_key_state( struct desktop *desktop, unsigned int msg, lparam_t wparam )
@@ -3379,7 +3387,7 @@ DECL_HANDLER(get_key_state)
     else
     {
         struct msg_queue *queue = get_current_queue();
-        unsigned char *keystate = queue->input->keystate;
+        unsigned char *keystate = (void *)queue->input->shared->keystate;
         if (req->key >= 0)
         {
             sync_input_keystate( queue->input );
@@ -3397,7 +3405,9 @@ DECL_HANDLER(set_key_state)
     struct msg_queue *queue = get_current_queue();
     data_size_t size = min( 256, get_req_data_size() );
 
-    memcpy( queue->input->keystate, get_req_data(), size );
+    SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+    memcpy( (void *)queue->input->shared->keystate, get_req_data(), size );
+    SHARED_WRITE_END( &queue->input->shared->seq );
     memcpy( queue->input->desktop_keystate, (void *)queue->input->desktop->shared->keystate,
             sizeof(queue->input->desktop_keystate) );
     if (req->async && (desktop = get_thread_desktop( current, 0 )))

From e66e0313040007eb2a31ea150b80d48ede512fb0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 12 Dec 2021 13:19:34 +0100
Subject: [PATCH 42/44] user32: Use input shared memory in GetKeyboardState.

---
 dlls/user32/input.c     | 22 ++++++++++++++++++++++
 dlls/user32/user32.spec |  2 +-
 2 files changed, 23 insertions(+), 1 deletion(-)

diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index 11111111111..11111111111 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -502,6 +502,28 @@ BOOL WINAPI GetKeyboardLayoutNameA(LPSTR pszKLID)
     return FALSE;
 }
 
+/**********************************************************************
+ *       GetKeyboardState    (USER32.@)
+ */
+BOOL WINAPI GetKeyboardState( BYTE *state )
+{
+    volatile struct input_shared_memory *shared = (void *)NtUserCallNoParam( NtUserGetInputSharedMemory );
+    BOOL skip = TRUE;
+
+    TRACE("(%p)\n", state);
+
+    if (!shared) skip = FALSE;
+    else SHARED_READ_BEGIN( &shared->seq )
+    {
+        if (!shared->created) skip = FALSE; /* server needs to create the queue */
+        else memcpy( state, (const void *)shared->keystate, 256 );
+    }
+    SHARED_READ_END( &shared->seq );
+
+    if (skip) return TRUE;
+    return NtUserGetKeyboardState( state );
+}
+
 /****************************************************************************
  *		GetKeyNameTextA (USER32.@)
  */
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index 11111111111..11111111111 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -321,7 +321,7 @@
 @ stdcall GetKeyboardLayoutList(long ptr) NtUserGetKeyboardLayoutList
 @ stdcall GetKeyboardLayoutNameA(ptr)
 @ stdcall GetKeyboardLayoutNameW(ptr) NtUserGetKeyboardLayoutName
-@ stdcall -import GetKeyboardState(ptr) NtUserGetKeyboardState
+@ stdcall GetKeyboardState(ptr)
 @ stdcall GetKeyboardType(long)
 @ stdcall GetLastActivePopup(long)
 @ stdcall GetLastInputInfo(ptr)

From c0ab0960e7741fda399f0faea953fc713b02b3df Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 17 Aug 2021 17:22:26 +0200
Subject: [PATCH 43/44] server: Expose thread input keystate lock through
 shared memory.

---
 server/protocol.def |  1 +
 server/queue.c      | 15 +++++++++------
 2 files changed, 10 insertions(+), 6 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -895,6 +895,7 @@ struct input_shared_memory
     rectangle_t          caret_rect;       /* caret rectangle */
     int                  cursor_count;     /* cursor show count */
     unsigned char        keystate[256];    /* key state */
+    int                  keystate_lock;    /* keystate is locked */
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -105,7 +105,6 @@ struct thread_input
     int                    caret_state;   /* caret on/off state */
     struct list            msg_list;      /* list of hardware messages */
     unsigned char          desktop_keystate[256]; /* desktop keystate when keystate was synced */
-    int                    keystate_lock; /* keystate is locked */
     struct object         *shared_mapping; /* thread input shared memory mapping */
     volatile struct input_shared_memory *shared;  /* thread input shared memory ptr */
 };
@@ -319,11 +318,11 @@ static struct thread_input *create_thread_input( struct thread *thread )
         input->shared->move_size    = 0;
         input->shared->cursor       = 0;
         input->shared->cursor_count = 0;
+        input->shared->keystate_lock = 0;
         memset( (void *)input->shared->keystate, 0, sizeof(input->shared->keystate) );
         SHARED_WRITE_END( &input->shared->seq );
         list_init( &input->msg_list );
         set_caret_window( input, 0 );
-        input->keystate_lock = 0;
 
         if (!(input->desktop = get_thread_desktop( thread, 0 /* FIXME: access rights */ )))
         {
@@ -419,7 +418,7 @@ void free_msg_queue( struct thread *thread )
 static void sync_input_keystate( struct thread_input *input )
 {
     int i;
-    if (!input->desktop || input->keystate_lock) return;
+    if (!input->desktop || input->shared->keystate_lock) return;
     SHARED_WRITE_BEGIN( &input->shared->seq );
     for (i = 0; i < sizeof(input->shared->keystate); ++i)
     {
@@ -432,14 +431,18 @@ static void sync_input_keystate( struct thread_input *input )
 /* locks thread input keystate to prevent synchronization */
 static void lock_input_keystate( struct thread_input *input )
 {
-    input->keystate_lock++;
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    input->shared->keystate_lock++;
+    SHARED_WRITE_END( &input->shared->seq );
 }
 
 /* unlock the thread input keystate and synchronize it again */
 static void unlock_input_keystate( struct thread_input *input )
 {
-    input->keystate_lock--;
-    if (!input->keystate_lock) sync_input_keystate( input );
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    input->shared->keystate_lock--;
+    SHARED_WRITE_END( &input->shared->seq );
+    if (!input->shared->keystate_lock) sync_input_keystate( input );
 }
 
 /* change the thread input data of a given thread */

From a7f521cf905de021e1c65fb567e4284c24179cb1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 12 Dec 2021 13:20:22 +0100
Subject: [PATCH 44/44] user32: Use input shared memory for GetKeyState.

---
 dlls/user32/input.c     | 27 +++++++++++++++++++++++++++
 dlls/user32/user32.spec |  2 +-
 2 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index 11111111111..11111111111 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -502,6 +502,33 @@ BOOL WINAPI GetKeyboardLayoutNameA(LPSTR pszKLID)
     return FALSE;
 }
 
+/**********************************************************************
+ *       GetKeyState    (USER32.@)
+ *
+ * An application calls the GetKeyState function in response to a
+ * keyboard-input message.  This function retrieves the state of the key
+ * at the time the input message was generated.
+ */
+SHORT WINAPI GetKeyState( INT vkey )
+{
+    volatile struct input_shared_memory *shared = (void *)NtUserCallNoParam( NtUserGetInputSharedMemory );
+    SHORT retval = 0;
+    BOOL skip = TRUE;
+
+    if (!shared) skip = FALSE;
+    else SHARED_READ_BEGIN( &shared->seq )
+    {
+        if (!shared->created) skip = FALSE; /* server needs to create the queue */
+        else if (!shared->keystate_lock) skip = FALSE; /* server needs to call sync_input_keystate */
+        else retval = (signed char)(shared->keystate[vkey & 0xff] & 0x81);
+    }
+    SHARED_READ_END( &shared->seq );
+
+    if (!skip) retval = NtUserGetKeyState( vkey );
+    TRACE("key (0x%x) -> %x\n", vkey, retval);
+    return retval;
+}
+
 /**********************************************************************
  *       GetKeyboardState    (USER32.@)
  */
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index 11111111111..11111111111 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -316,7 +316,7 @@
 @ stdcall GetKBCodePage()
 @ stdcall GetKeyNameTextA(long ptr long)
 @ stdcall GetKeyNameTextW(long ptr long) NtUserGetKeyNameText
-@ stdcall -import GetKeyState(long) NtUserGetKeyState
+@ stdcall GetKeyState(long)
 @ stdcall GetKeyboardLayout(long) NtUserGetKeyboardLayout
 @ stdcall GetKeyboardLayoutList(long ptr) NtUserGetKeyboardLayoutList
 @ stdcall GetKeyboardLayoutNameA(ptr)
