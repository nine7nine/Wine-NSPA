From 9953b7184f4f5383f025a16ecab96ea8db6ef3aa Mon Sep 17 00:00:00 2001
From: =?utf-8?q?J=C3=B6rg=20H=C3=B6hle?= <hoehle@users.sourceforge.net>
Date: Sun, 20 Jan 2013 23:48:14 +0100
Subject: [PATCH 4/7] winmm: midiOutLong allows sysex continuations. It does not add F0/F7 bytes.

---
 dlls/winealsa.drv/midi.c      |   46 +++++++++++-----------------------------
 dlls/winecoreaudio.drv/midi.c |   24 ++------------------
 dlls/wineoss.drv/midi.c       |   26 ++--------------------
 dlls/winmm/winmm.c            |    4 +++
 4 files changed, 23 insertions(+), 77 deletions(-)

diff --git a/dlls/winealsa.drv/midi.c b/dlls/winealsa.drv/midi.c
index 7bd0fe6..825514a 100644
--- a/dlls/winealsa.drv/midi.c
+++ b/dlls/winealsa.drv/midi.c
@@ -994,11 +994,12 @@ static DWORD modData(WORD wDevID, DWORD
 
 /**************************************************************************
  *		modLongData					[internal]
+ *
+ * FIXME: Must handle SysEx as well as simple concatenated channel messages
  */
 static DWORD modLongData(WORD wDevID, LPMIDIHDR lpMidiHdr, DWORD dwSize)
 {
-    int len_add = 0;
-    BYTE *lpData, *lpNewData = NULL;
+    BYTE *lpData;
     snd_seq_event_t event;
 
     TRACE("(%04X, %p, %08X);\n", wDevID, lpMidiHdr, dwSize);
@@ -1027,57 +1028,36 @@ static DWORD modLongData(WORD wDevID, LP
     lpMidiHdr->dwFlags &= ~MHDR_DONE;
     lpMidiHdr->dwFlags |= MHDR_INQUEUE;
 
-    /* FIXME: MS doc is not 100% clear. Will lpData only contain system exclusive
-     * data, or can it also contain raw MIDI data, to be split up and sent to
-     * modShortData() ?
-     * If the latest is true, then the following WARNing will fire up
-     */
-    if (lpData[0] != 0xF0 || lpData[lpMidiHdr->dwBufferLength - 1] != 0xF7) {
-	WARN("Alleged system exclusive buffer is not correct\n\tPlease report with MIDI file\n");
-	lpNewData = HeapAlloc(GetProcessHeap(), 0, lpMidiHdr->dwBufferLength + 2);
-    }
-
-    TRACE("dwBufferLength=%u !\n", lpMidiHdr->dwBufferLength);
-    TRACE("                 %02X %02X %02X ... %02X %02X %02X\n",
+    /* FIXME: Recognize and split channel messages */
+    if (lpData[0] != 0xF0 || lpData[lpMidiHdr->dwBufferLength - 1] != 0xF7)
+	FIXME("divided SysEx\n");
+    TRACE("%u bytes %02X %02X %02X ... %02X %02X %02X\n", lpMidiHdr->dwBufferLength,
 	  lpData[0], lpData[1], lpData[2], lpData[lpMidiHdr->dwBufferLength-3],
 	  lpData[lpMidiHdr->dwBufferLength-2], lpData[lpMidiHdr->dwBufferLength-1]);
 
     switch (MidiOutDev[wDevID].caps.wTechnology) {
     case MOD_FMSYNTH:
         /* FIXME: I don't think there is much to do here */
-        HeapFree(GetProcessHeap(), 0, lpNewData);
         break;
     case MOD_MIDIPORT:
-        if (lpData[0] != 0xF0) {
-            /* Send start of System Exclusive */
-            len_add = 1;
-            lpNewData[0] = 0xF0;
-            memcpy(lpNewData + 1, lpData, lpMidiHdr->dwBufferLength);
-            WARN("Adding missing 0xF0 marker at the beginning of system exclusive byte stream\n");
-        }
-        if (lpData[lpMidiHdr->dwBufferLength-1] != 0xF7) {
-            /* Send end of System Exclusive */
-            if (!len_add)
-                memcpy(lpNewData, lpData, lpMidiHdr->dwBufferLength);
-            lpNewData[lpMidiHdr->dwBufferLength + len_add] = 0xF7;
-            len_add++;
-            WARN("Adding missing 0xF7 marker at the end of system exclusive byte stream\n");
-        }
 	snd_seq_ev_clear(&event);
 	snd_seq_ev_set_direct(&event);
 	snd_seq_ev_set_source(&event, MidiOutDev[wDevID].port_out);
 	snd_seq_ev_set_dest(&event, MidiOutDev[wDevID].addr.client, MidiOutDev[wDevID].addr.port);
 	TRACE("destination %d:%d\n", MidiOutDev[wDevID].addr.client, MidiOutDev[wDevID].addr.port);
-	snd_seq_ev_set_sysex(&event, lpMidiHdr->dwBufferLength + len_add, lpNewData ? lpNewData : lpData);
+	/* The ALSA documentation erroneously states:
+	 * "the sysex data must contain the start byte 0xf0 and the end byte 0xf7."
+	 * Actually SysEx continuations are acceptable.  The first
+	 * message must start with F0 and the last one end with F7.
+	 */
+	snd_seq_ev_set_sysex(&event, lpMidiHdr->dwBufferLength, lpData);
         EnterCriticalSection(&midiSeqLock);
 	snd_seq_event_output_direct(midiSeq, &event);
         LeaveCriticalSection(&midiSeqLock);
-        HeapFree(GetProcessHeap(), 0, lpNewData);
         break;
     default:
 	WARN("Technology not supported (yet) %d !\n",
 	     MidiOutDev[wDevID].caps.wTechnology);
-	HeapFree(GetProcessHeap(), 0, lpNewData);
 	return MMSYSERR_NOTENABLED;
     }
 

