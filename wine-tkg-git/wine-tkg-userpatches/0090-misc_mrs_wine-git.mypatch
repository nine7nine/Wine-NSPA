From 3ec22629d2154e75fe88148595d1640d5310fced Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sat, 22 Oct 2022 13:52:37 -0400
Subject: [PATCH] kernelbase: Implement various transacted file APIs.

fix missing new lines

fix more formatting issues

more formatting fixes

Link: https://gitlab.winehq.org/wine/wine/-/merge_requests/1145

CW-Bug-Id: #21447
---
 dlls/kernel32/kernel32.spec     |  22 ++++---
 dlls/kernelbase/file.c          | 112 ++++++++++++++++++++++++++++++++
 dlls/kernelbase/kernelbase.spec |  12 ++++
 3 files changed, 136 insertions(+), 10 deletions(-)

diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index a03ebc1eb6f..156b7433046 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -272,8 +272,8 @@
 @ stdcall -import CreateDirectoryA(str ptr)
 @ stdcall CreateDirectoryExA(str str ptr)
 @ stdcall -import CreateDirectoryExW(wstr wstr ptr)
-# @ stub CreateDirectoryTransactedA
-# @ stub CreateDirectoryTransactedW
+@ stdcall -import CreateDirectoryTransactedA(str str ptr ptr)
+@ stdcall -import CreateDirectoryTransactedW(wstr wstr ptr ptr)
 @ stdcall -import CreateDirectoryW(wstr ptr)
 @ stdcall -import CreateEventA(ptr long long str)
 @ stdcall -import CreateEventExA(ptr str long long)
@@ -283,11 +283,13 @@
 @ stdcall -import CreateFiberEx(long long long ptr ptr)
 @ stdcall -import CreateFile2(wstr long long long ptr)
 @ stdcall -import CreateFileA(str long long ptr long long long)
+@ stdcall -import CreateFileTransactedA(str long long ptr long long long ptr ptr ptr)
 @ stdcall CreateFileMappingA(long ptr long long long str)
 # @ stub CreateFileMappingNumaA
 @ stdcall -import CreateFileMappingNumaW(long ptr long long long wstr long)
 @ stdcall -import CreateFileMappingW(long ptr long long long wstr)
 @ stdcall -import CreateFileW(wstr long long ptr long long long)
+@ stdcall -import CreateFileTransactedW(wstr long long ptr long long long ptr ptr ptr)
 @ stdcall -import CreateHardLinkA(str str ptr)
 @ stdcall CreateHardLinkTransactedA(str str ptr ptr)
 @ stdcall CreateHardLinkTransactedW(wstr wstr ptr ptr)
@@ -364,8 +366,8 @@
 @ stdcall DeleteCriticalSection(ptr) NTDLL.RtlDeleteCriticalSection
 @ stdcall -import DeleteFiber(ptr)
 @ stdcall -import DeleteFileA(str)
-# @ stub DeleteFileTransactedA
-# @ stub DeleteFileTransactedW
+@ stdcall -import DeleteFileTransactedA(str ptr)
+@ stdcall -import DeleteFileTransactedW(wstr ptr)
 @ stdcall -import DeleteFileW(wstr)
 @ stdcall -import DeleteProcThreadAttributeList(ptr)
 # @ stub DisableThreadProfiling
@@ -486,8 +488,8 @@
 @ stdcall -import FindFirstFileExW(wstr long ptr long ptr long)
 # @ stub FindFirstFileNameTransactedW
 # @ stub FindFirstFileNameW
-# @ stub FindFirstFileTransactedA
-# @ stub FindFirstFileTransactedW
+@ stdcall -import FindFirstFileTransactedA(str long ptr long ptr long ptr)
+@ stdcall -import FindFirstFileTransactedW(wstr long ptr long ptr long ptr)
 @ stdcall -import FindFirstFileW(wstr ptr)
 # @ stub FindFirstStreamTransactedW
 @ stdcall -import FindFirstStreamW(wstr long ptr long)
@@ -675,8 +677,8 @@
 @ stdcall -import GetFileAttributesA(str)
 @ stdcall -import GetFileAttributesExA(str long ptr)
 @ stdcall -import GetFileAttributesExW(wstr long ptr)
-# @ stub GetFileAttributesTransactedA
-# @ stub GetFileAttributesTransactedW
+@ stdcall -import GetFileAttributesTransactedA(str long ptr ptr)
+@ stdcall -import GetFileAttributesTransactedW(wstr long ptr ptr)
 @ stdcall -import GetFileAttributesW(wstr)
 # @ stub GetFileBandwidthReservation
 @ stdcall -import GetFileInformationByHandle(long ptr)
@@ -1290,8 +1292,8 @@
 @ stdcall -import ReplaceFile(wstr wstr wstr long ptr ptr) ReplaceFileW
 @ stdcall ReplaceFileA(str str str long ptr ptr)
 @ stdcall -import ReplaceFileW(wstr wstr wstr long ptr ptr)
-# @ stub RemoveDirectoryTransactedA
-# @ stub RemoveDirectoryTransactedW
+@ stdcall -import RemoveDirectoryTransactedA(str ptr)
+@ stdcall -import RemoveDirectoryTransactedW(wstr ptr)
 @ stdcall -import RemoveDllDirectory(ptr)
 # @ stub RemoveSecureMemoryCacheCallback
 # @ stub ReplacePartitionUnit
diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index 56b855482ce..fa886aca87e 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -594,6 +594,14 @@ BOOL WINAPI DECLSPEC_HOTPATCH CopyFileW( const WCHAR *source, const WCHAR *dest,
     return CopyFileExW( source, dest, NULL, NULL, NULL, fail_if_exists ? COPY_FILE_FAIL_IF_EXISTS : 0 );
 }
 
+/***********************************************************************
+ *	CreateDirectoryTransactedA   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH CreateDirectoryTransactedA(LPCSTR template, LPCSTR path, LPSECURITY_ATTRIBUTES sa, HANDLE hTransaction)
+{
+    FIXME("(%s %s %p %p), semi-stub\n", debugstr_a(template), debugstr_a(path), sa, hTransaction);
+    return CreateDirectoryA(path, sa);
+}
 
 /***********************************************************************
  *	CreateDirectoryA   (kernelbase.@)
@@ -606,6 +614,14 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateDirectoryA( LPCSTR path, LPSECURITY_ATTRIBUT
     return CreateDirectoryW( pathW, sa );
 }
 
+/***********************************************************************
+ *	CreateDirectoryTransactedW   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH CreateDirectoryTransactedW(LPCWSTR template, LPCWSTR path, LPSECURITY_ATTRIBUTES sa, HANDLE hTransaction)
+{
+    FIXME("(%s %s %p %p), semi-stub\n", debugstr_w(template), debugstr_w(path), sa, hTransaction);
+    return CreateDirectoryW(path, sa);
+}
 
 /***********************************************************************
  *	CreateDirectoryW   (kernelbase.@)
@@ -693,6 +709,20 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFile2( LPCWSTR name, DWORD access, DWORD s
     return CreateFileW( name, access, sharing, sa, creation, flags | attributes, template );
 }
 
+/*************************************************************************
+ *	CreateFileTransactedA   (kernelbase.@)
+ */
+HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileTransactedA( LPCSTR name, DWORD access, DWORD sharing,
+                                                       LPSECURITY_ATTRIBUTES sa, DWORD creation,
+                                                       DWORD attributes, HANDLE template,
+                                                       HANDLE transaction, PUSHORT pusMiniVersion,
+                                                       PVOID pExtendedParameter )
+{
+    FIXME( "(%s %lx %lx %p %lx %lx %p %p %p %p), semi-stub\n", debugstr_a(name), access, sharing, sa,
+           creation, attributes, template, transaction, pusMiniVersion, pExtendedParameter );
+    
+    return CreateFileA( name, access, sharing, sa, creation, attributes, template );
+}
 
 /*************************************************************************
  *	CreateFileA   (kernelbase.@)
@@ -731,6 +761,20 @@ static UINT get_nt_file_options( DWORD attributes )
     return options;
 }
 
+/*************************************************************************
+ *	CreateFileTransactedW   (kernelbase.@)
+ */
+HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileTransactedW( LPCWSTR name, DWORD access, DWORD sharing,
+                                                       LPSECURITY_ATTRIBUTES sa, DWORD creation,
+                                                       DWORD attributes, HANDLE template, HANDLE transaction,
+                                                       PUSHORT pusMiniVersion, PVOID pExtendedParameter )
+{
+    FIXME( "(%s %lx %lx %p %lx %lx %p %p %p %p), semi-stub\n", debugstr_w(name), access, sharing, sa,
+           creation, attributes, template, transaction, pusMiniVersion, pExtendedParameter );
+
+    return CreateFileW( name, access, sharing, sa, creation, attributes, template );
+}
+
 /*************************************************************************
  *	CreateFileW   (kernelbase.@)
  */
@@ -943,6 +987,14 @@ BOOLEAN WINAPI /* DECLSPEC_HOTPATCH */ CreateSymbolicLinkW( LPCWSTR link, LPCWST
     return TRUE;
 }
 
+/***********************************************************************
+ *	DeleteFileTransactedA   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH DeleteFileTransactedA(LPCSTR path, HANDLE hTransaction)
+{
+    FIXME("(%s %p): semi-stub\n", debugstr_a(path), hTransaction);
+    return DeleteFileA(path);
+}
 
 /***********************************************************************
  *	DeleteFileA   (kernelbase.@)
@@ -955,6 +1007,14 @@ BOOL WINAPI DECLSPEC_HOTPATCH DeleteFileA( LPCSTR path )
     return DeleteFileW( pathW );
 }
 
+/***********************************************************************
+ *	DeleteFileTransactedW   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH DeleteFileTransactedW(LPCWSTR path, HANDLE hTransaction)
+{
+    FIXME("(%s %p): semi-stub\n", debugstr_w(path), hTransaction);
+    return DeleteFileW(path);
+}
 
 /***********************************************************************
  *	DeleteFileW   (kernelbase.@)
@@ -1074,6 +1134,16 @@ BOOL WINAPI DECLSPEC_HOTPATCH FindNextChangeNotification( HANDLE handle )
     return set_ntstatus( status );
 }
 
+/******************************************************************************
+ *	FindFirstFileTransactedA   (kernelbase.@)
+ */
+HANDLE WINAPI DECLSPEC_HOTPATCH FindFirstFileTransactedA(LPCSTR filename, FINDEX_INFO_LEVELS level,
+                                                  LPVOID data, FINDEX_SEARCH_OPS search_op,
+                                                  LPVOID filter, DWORD flags, HANDLE hTransaction)
+{
+    FIXME( "(%s %d %p %d %p %lx %p): semi-stub\n", debugstr_a(filename), level, data, search_op, filter, flags, hTransaction );
+    return FindFirstFileExA(filename, level, data, search_op, filter, flags);
+}
 
 /******************************************************************************
  *	FindFirstFileExA   (kernelbase.@)
@@ -1104,6 +1174,16 @@ HANDLE WINAPI DECLSPEC_HOTPATCH FindFirstFileExA( const char *filename, FINDEX_I
     return handle;
 }
 
+/******************************************************************************
+ *	FindFirstFileTransactedW   (kernelbase.@)
+ */
+HANDLE WINAPI DECLSPEC_HOTPATCH FindFirstFileTransactedW(LPCWSTR filename, FINDEX_INFO_LEVELS level,
+                                                  LPVOID data, FINDEX_SEARCH_OPS search_op,
+                                                  LPVOID filter, DWORD flags, HANDLE hTransaction)
+{
+    FIXME( "(%s %d %p %d %p %lx %p): semi-stub\n", debugstr_w(filename), level, data, search_op, filter, flags, hTransaction );
+    return FindFirstFileExW(filename, level, data, search_op, filter, flags);
+}
 
 /******************************************************************************
  *	FindFirstFileExW   (kernelbase.@)
@@ -1563,6 +1643,14 @@ UINT WINAPI DECLSPEC_HOTPATCH GetCurrentDirectoryW( UINT buflen, LPWSTR buf )
     return RtlGetCurrentDirectory_U( buflen * sizeof(WCHAR), buf ) / sizeof(WCHAR);
 }
 
+/**************************************************************************
+ *	GetFileAttributesTransactedA   (kernelbase.@)
+ */
+DWORD WINAPI DECLSPEC_HOTPATCH GetFileAttributesTransactedA(LPCSTR name, GET_FILEEX_INFO_LEVELS level, void *ptr, HANDLE hTransaction)
+{
+    FIXME("(%s %p): semi-stub\n", debugstr_a(name), hTransaction);
+    return GetFileAttributesExA(name, level, ptr);
+}
 
 /**************************************************************************
  *	GetFileAttributesA   (kernelbase.@)
@@ -1575,6 +1663,14 @@ DWORD WINAPI DECLSPEC_HOTPATCH GetFileAttributesA( LPCSTR name )
     return GetFileAttributesW( nameW );
 }
 
+/**************************************************************************
+ *	GetFileAttributesTransactedW   (kernelbase.@)
+ */
+DWORD WINAPI DECLSPEC_HOTPATCH GetFileAttributesTransactedW(LPCWSTR name, GET_FILEEX_INFO_LEVELS level, void *ptr, HANDLE hTransaction)
+{
+    FIXME("(%s %p): semi-stub\n", debugstr_w(name), hTransaction);
+    return GetFileAttributesExW(name, level, ptr);
+}
 
 /**************************************************************************
  *	GetFileAttributesW   (kernelbase.@)
@@ -3458,6 +3554,14 @@ BOOL WINAPI DECLSPEC_HOTPATCH ReadFileScatter( HANDLE file, FILE_SEGMENT_ELEMENT
                                             segments, count, &offset, NULL ));
 }
 
+/***********************************************************************
+ *	RemoveDirectoryTransactedA   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH RemoveDirectoryTransactedA( LPCSTR path, HANDLE hTransaction )
+{
+    FIXME("(%s %p), semi-stub\n", debugstr_a(path), hTransaction);
+    return RemoveDirectoryA(path);
+}
 
 /***********************************************************************
  *	RemoveDirectoryA   (kernelbase.@)
@@ -3470,6 +3574,14 @@ BOOL WINAPI DECLSPEC_HOTPATCH RemoveDirectoryA( LPCSTR path )
     return RemoveDirectoryW( pathW );
 }
 
+/***********************************************************************
+ *	RemoveDirectoryTransactedW   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH RemoveDirectoryTransactedW( LPCWSTR path, HANDLE hTransaction )
+{
+    FIXME("(%s %p), semi-stub\n", debugstr_w(path), hTransaction);
+    return RemoveDirectoryW(path);
+}
 
 /***********************************************************************
  *	RemoveDirectoryW   (kernelbase.@)
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index b8b301cba3e..61945e4ce65 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -177,7 +177,9 @@
 @ stdcall CreateBoundaryDescriptorW(wstr long)
 @ stdcall CreateConsoleScreenBuffer(long long ptr long ptr)
 @ stdcall CreateDirectoryA(str ptr)
+@ stdcall CreateDirectoryTransactedA(str str ptr ptr)
 @ stdcall CreateDirectoryExW(wstr wstr ptr)
+@ stdcall CreateDirectoryTransactedW(wstr wstr ptr ptr)
 @ stdcall CreateDirectoryW(wstr ptr)
 # @ stub CreateEnclave
 @ stdcall CreateEventA(ptr long long str)
@@ -188,10 +190,12 @@
 @ stdcall CreateFiberEx(long long long ptr ptr)
 @ stdcall CreateFile2(wstr long long long ptr)
 @ stdcall CreateFileA(str long long ptr long long long)
+@ stdcall CreateFileTransactedA(str long long ptr long long long ptr ptr ptr)
 @ stdcall CreateFileMappingFromApp(long ptr long int64 wstr)
 @ stdcall CreateFileMappingNumaW(long ptr long long long wstr long)
 @ stdcall CreateFileMappingW(long ptr long long long wstr)
 @ stdcall CreateFileW(wstr long long ptr long long long)
+@ stdcall CreateFileTransactedW(wstr long long ptr long long long ptr ptr ptr)
 @ stdcall CreateHardLinkA(str str ptr)
 @ stdcall CreateHardLinkW(wstr wstr ptr)
 @ stdcall CreateIoCompletionPort(long long long long)
@@ -253,7 +257,9 @@
 @ stdcall DeleteCriticalSection(ptr) ntdll.RtlDeleteCriticalSection
 @ stdcall DeleteFiber(ptr)
 @ stdcall DeleteFileA(str)
+@ stdcall DeleteFileTransactedA(str ptr)
 @ stdcall DeleteFileW(wstr)
+@ stdcall DeleteFileTransactedW(wstr ptr)
 @ stdcall DeleteProcThreadAttributeList(ptr)
 # @ stub DeleteStateAtomValue
 # @ stub DeleteStateContainer
@@ -358,7 +364,9 @@
 @ stdcall FindFirstChangeNotificationW(wstr long long)
 @ stdcall FindFirstFileA(str ptr)
 @ stdcall FindFirstFileExA(str long ptr long ptr long)
+@ stdcall FindFirstFileTransactedA(str long ptr long ptr long ptr)
 @ stdcall FindFirstFileExW(wstr long ptr long ptr long)
+@ stdcall FindFirstFileTransactedW(wstr long ptr long ptr long ptr)
 # @ stub FindFirstFileNameW
 @ stdcall FindFirstFileW(wstr ptr)
 @ stdcall FindFirstFreeAce(ptr ptr)
@@ -507,7 +515,9 @@
 @ stub GetFallbackDisplayName
 @ stdcall GetFileAttributesA(str)
 @ stdcall GetFileAttributesExA(str long ptr)
+@ stdcall GetFileAttributesTransactedA(str long ptr ptr)
 @ stdcall GetFileAttributesExW(wstr long ptr)
+@ stdcall GetFileAttributesTransactedW(wstr long ptr ptr)
 @ stdcall GetFileAttributesW(wstr)
 @ stdcall GetFileInformationByHandle(long ptr)
 @ stdcall GetFileInformationByHandleEx(long long ptr long)
@@ -1338,6 +1348,8 @@
 @ stdcall RemapPredefinedHandleInternal(long long)
 @ stdcall RemoveDirectoryA(str)
 @ stdcall RemoveDirectoryW(wstr)
+@ stdcall RemoveDirectoryTransactedA(str ptr)
+@ stdcall RemoveDirectoryTransactedW(wstr ptr)
 @ stdcall RemoveDllDirectory(ptr)
 # @ stub RemovePackageStatus
 # @ stub RemovePackageStatusForUser


From 9d9da40155bbca0c3cf525a461bf5e3ccbace031 Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sun, 30 Oct 2022 22:22:56 +0100
Subject: [PATCH 1/8] msvcp90: Add _Cin_func implementation.

Wine-bug: https://bugs.winehq.org/show_bug.cgi?id=47304
---
 dlls/msvcp80/msvcp80.spec | 4 ++--
 dlls/msvcp90/ios.c        | 7 +++++++
 dlls/msvcp90/msvcp90.spec | 4 ++--
 3 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/dlls/msvcp80/msvcp80.spec b/dlls/msvcp80/msvcp80.spec
index 020e8d26fc7..8cf90ea4d50 100644
--- a/dlls/msvcp80/msvcp80.spec
+++ b/dlls/msvcp80/msvcp80.spec
@@ -2117,8 +2117,8 @@
 @ cdecl -arch=win64 ?_Chassign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IEAAX_K0G@Z(ptr long long long) MSVCP_basic_string_wchar_Chassign
 @ thiscall -arch=win32 ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII_W@Z(ptr long long long) MSVCP_basic_string_wchar_Chassign
 @ cdecl -arch=win64 ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAX_K0_W@Z(ptr long long long) MSVCP_basic_string_wchar_Chassign
-@ stub -arch=win32 ?_Cin_func@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@1@XZ
-@ stub -arch=win64 ?_Cin_func@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@1@XZ
+@ cdecl -arch=win32 ?_Cin_func@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@1@XZ() _Cin_func
+@ cdecl -arch=win64 ?_Cin_func@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@1@XZ() _Cin_func
 # extern -arch=win64 ?_Cl@?5???$log@M@std@@YA?AV?$complex@M@1@AEBV21@@Z@4MB
 # extern -arch=win32 ?_Cl@?5???$log@N@std@@YA?AV?$complex@N@1@ABV21@@Z@4NB
 # extern -arch=win64 ?_Cl@?5???$log@N@std@@YA?AV?$complex@N@1@AEBV21@@Z@4NB
diff --git a/dlls/msvcp90/ios.c b/dlls/msvcp90/ios.c
index d176dffa802..c5dc43f3cb4 100644
--- a/dlls/msvcp90/ios.c
+++ b/dlls/msvcp90/ios.c
@@ -15959,3 +15959,10 @@ void free_io(void)
     basic_ostream_wchar_vbase_dtor(&wclog.obj);
     basic_filebuf_wchar_dtor(&filebuf_wchar_log);
 }
+
+/* ?_Cin_func@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@1@XZ */
+/* ?_Cin_func@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@1@XZ */
+basic_istream_char* __cdecl _Cin_func(void)
+{
+    return &cin.obj;
+}
diff --git a/dlls/msvcp90/msvcp90.spec b/dlls/msvcp90/msvcp90.spec
index 1e79400e469..532c477294c 100644
--- a/dlls/msvcp90/msvcp90.spec
+++ b/dlls/msvcp90/msvcp90.spec
@@ -2380,8 +2380,8 @@
 @ cdecl -arch=win64 ?_Chassign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IEAAX_K0G@Z(ptr long long long) MSVCP_basic_string_wchar_Chassign
 @ thiscall -arch=win32 ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IAEXII_W@Z(ptr long long long) MSVCP_basic_string_wchar_Chassign
 @ cdecl -arch=win64 ?_Chassign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@IEAAX_K0_W@Z(ptr long long long) MSVCP_basic_string_wchar_Chassign
-@ stub -arch=win32 ?_Cin_func@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@1@XZ
-@ stub -arch=win64 ?_Cin_func@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@1@XZ
+@ cdecl -arch=win32 ?_Cin_func@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@1@XZ() _Cin_func
+@ cdecl -arch=win64 ?_Cin_func@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@1@XZ() _Cin_func
 # extern -arch=win64 ?_Cl@?5???$log@M@std@@YA?AV?$complex@M@1@AEBV21@@Z@4MB
 # extern -arch=win32 ?_Cl@?5???$log@N@std@@YA?AV?$complex@N@1@ABV21@@Z@4NB
 # extern -arch=win64 ?_Cl@?5???$log@N@std@@YA?AV?$complex@N@1@AEBV21@@Z@4NB
-- 
GitLab


From 60c2bd7b620ebd657ce09ea4121cf10f7ee73da0 Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sun, 30 Oct 2022 22:22:57 +0100
Subject: [PATCH 2/8] msvcp90: Add _Wcin_func implementation.

---
 dlls/msvcp80/msvcp80.spec |  8 ++++----
 dlls/msvcp90/ios.c        | 14 ++++++++++++++
 dlls/msvcp90/msvcp90.spec |  8 ++++----
 3 files changed, 22 insertions(+), 8 deletions(-)

diff --git a/dlls/msvcp80/msvcp80.spec b/dlls/msvcp80/msvcp80.spec
index 8cf90ea4d50..87bc70e57fe 100644
--- a/dlls/msvcp80/msvcp80.spec
+++ b/dlls/msvcp80/msvcp80.spec
@@ -2824,10 +2824,10 @@
 @ stub -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
 @ stub -arch=win32 ?_Wcerr_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
 @ stub -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ
+@ cdecl -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ() _Wcin_func_short
+@ cdecl -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ() _Wcin_func_short
+@ cdecl -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ() _Wcin_func
+@ cdecl -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ() _Wcin_func
 @ stub -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
 @ stub -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
 @ stub -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
diff --git a/dlls/msvcp90/ios.c b/dlls/msvcp90/ios.c
index c5dc43f3cb4..a58ff709a46 100644
--- a/dlls/msvcp90/ios.c
+++ b/dlls/msvcp90/ios.c
@@ -15966,3 +15966,17 @@ basic_istream_char* __cdecl _Cin_func(void)
 {
     return &cin.obj;
 }
+
+/* ?_Wcin_func@std@@YAAAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ */
+/* ?_Wcin_func@std@@YAAEAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ */
+basic_istream_wchar* __cdecl _Wcin_func_short(void)
+{
+    return &ucin.obj;
+}
+
+/* ?_Wcin_func@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ */
+/* ?_Wcin_func@std@@YAAEAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ */
+basic_istream_wchar* __cdecl _Wcin_func(void)
+{
+    return &wcin.obj;
+}
diff --git a/dlls/msvcp90/msvcp90.spec b/dlls/msvcp90/msvcp90.spec
index 532c477294c..b2488763131 100644
--- a/dlls/msvcp90/msvcp90.spec
+++ b/dlls/msvcp90/msvcp90.spec
@@ -3167,10 +3167,10 @@
 @ stub -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
 @ stub -arch=win32 ?_Wcerr_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
 @ stub -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ
+@ cdecl -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ() _Wcin_func_short
+@ cdecl -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ() _Wcin_func_short
+@ cdecl -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ() _Wcin_func
+@ cdecl -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ() _Wcin_func
 @ stub -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
 @ stub -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
 @ stub -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-- 
GitLab


From ad964cd5b8ea9883077c39b6b950d3d58cbced8d Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sun, 30 Oct 2022 22:22:58 +0100
Subject: [PATCH 3/8] msvcp90: Add _Cout_func implementation.

---
 dlls/msvcp80/msvcp80.spec | 4 ++--
 dlls/msvcp90/ios.c        | 7 +++++++
 dlls/msvcp90/msvcp90.spec | 4 ++--
 3 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/dlls/msvcp80/msvcp80.spec b/dlls/msvcp80/msvcp80.spec
index 87bc70e57fe..179b9329447 100644
--- a/dlls/msvcp80/msvcp80.spec
+++ b/dlls/msvcp80/msvcp80.spec
@@ -2151,8 +2151,8 @@
 @ stub ?_Cosh@?$_Ctraits@M@std@@SAMMM@Z
 @ stub ?_Cosh@?$_Ctraits@N@std@@SANNN@Z
 @ stub ?_Cosh@?$_Ctraits@O@std@@SAOOO@Z
-@ stub -arch=win32 ?_Cout_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
-@ stub -arch=win64 ?_Cout_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
+@ cdecl -arch=win32 ?_Cout_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Cout_func
+@ cdecl -arch=win64 ?_Cout_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Cout_func
 @ stub -arch=win32 ?_Debug_message@std@@YAXPBD0@Z
 @ stub -arch=win64 ?_Debug_message@std@@YAXPEBD0@Z
 @ thiscall -arch=win32 ?_Decref@facet@locale@std@@QAEPAV123@XZ(ptr) locale_facet__Decref
diff --git a/dlls/msvcp90/ios.c b/dlls/msvcp90/ios.c
index a58ff709a46..c13ed6b4e36 100644
--- a/dlls/msvcp90/ios.c
+++ b/dlls/msvcp90/ios.c
@@ -15980,3 +15980,10 @@ basic_istream_wchar* __cdecl _Wcin_func(void)
 {
     return &wcin.obj;
 }
+
+/* ?_Cout_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ */
+/* ?_Cout_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ */
+basic_ostream_char* __cdecl _Cout_func(void)
+{
+    return &cout.obj;
+}
diff --git a/dlls/msvcp90/msvcp90.spec b/dlls/msvcp90/msvcp90.spec
index b2488763131..6740e47b93f 100644
--- a/dlls/msvcp90/msvcp90.spec
+++ b/dlls/msvcp90/msvcp90.spec
@@ -2414,8 +2414,8 @@
 @ stub ?_Cosh@?$_Ctraits@M@std@@SAMMM@Z
 @ stub ?_Cosh@?$_Ctraits@N@std@@SANNN@Z
 @ stub ?_Cosh@?$_Ctraits@O@std@@SAOOO@Z
-@ stub -arch=win32 ?_Cout_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
-@ stub -arch=win64 ?_Cout_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
+@ cdecl -arch=win32 ?_Cout_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Cout_func
+@ cdecl -arch=win64 ?_Cout_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Cout_func
 @ stub -arch=win32 ?_Debug_message@std@@YAXPBD0@Z
 @ stub -arch=win64 ?_Debug_message@std@@YAXPEBD0@Z
 @ thiscall -arch=win32 ?_Decref@facet@locale@std@@QAEPAV123@XZ(ptr) locale_facet__Decref
-- 
GitLab


From ef746b306a078c1cd4893bf9e161f23a4b918540 Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sun, 30 Oct 2022 22:22:59 +0100
Subject: [PATCH 4/8] msvcp90: Add _Clog_func implementation.

---
 dlls/msvcp80/msvcp80.spec | 4 ++--
 dlls/msvcp90/ios.c        | 7 +++++++
 dlls/msvcp90/msvcp90.spec | 4 ++--
 3 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/dlls/msvcp80/msvcp80.spec b/dlls/msvcp80/msvcp80.spec
index 179b9329447..8aecaad284b 100644
--- a/dlls/msvcp80/msvcp80.spec
+++ b/dlls/msvcp80/msvcp80.spec
@@ -2126,8 +2126,8 @@
 @ extern -arch=win64 ?_Clocptr@_Locimp@locale@std@@0PEAV123@EA locale__Locimp__Clocptr
 @ cdecl -arch=win32 ?_Clocptr_func@_Locimp@locale@std@@CAAAPAV123@XZ() locale__Locimp__Clocptr_func
 @ cdecl -arch=win64 ?_Clocptr_func@_Locimp@locale@std@@CAAEAPEAV123@XZ() locale__Locimp__Clocptr_func
-@ stub -arch=win32 ?_Clog_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
-@ stub -arch=win64 ?_Clog_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
+@ cdecl -arch=win32 ?_Clog_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Clog_func
+@ cdecl -arch=win64 ?_Clog_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Clog_func
 @ stub -arch=win64 ?_Cm@?5???$log@M@std@@YA?AV?$complex@M@1@AEBV21@@Z@4MB
 @ stub -arch=win64 ?_Cm@?5???$log@N@std@@YA?AV?$complex@N@1@AEBV21@@Z@4NB
 @ thiscall -arch=win32 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z(ptr long long) basic_string_char__Copy
diff --git a/dlls/msvcp90/ios.c b/dlls/msvcp90/ios.c
index c13ed6b4e36..8eedf0fe23b 100644
--- a/dlls/msvcp90/ios.c
+++ b/dlls/msvcp90/ios.c
@@ -15987,3 +15987,10 @@ basic_ostream_char* __cdecl _Cout_func(void)
 {
     return &cout.obj;
 }
+
+/* ?_Clog_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ */
+/* ?_Clog_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ */
+basic_ostream_char* __cdecl _Clog_func(void)
+{
+    return &MSVCP_clog.obj;
+}
diff --git a/dlls/msvcp90/msvcp90.spec b/dlls/msvcp90/msvcp90.spec
index 6740e47b93f..d0861437cc6 100644
--- a/dlls/msvcp90/msvcp90.spec
+++ b/dlls/msvcp90/msvcp90.spec
@@ -2389,8 +2389,8 @@
 @ extern -arch=win64 ?_Clocptr@_Locimp@locale@std@@0PEAV123@EA locale__Locimp__Clocptr
 @ cdecl -arch=win32 ?_Clocptr_func@_Locimp@locale@std@@CAAAPAV123@XZ() locale__Locimp__Clocptr_func
 @ cdecl -arch=win64 ?_Clocptr_func@_Locimp@locale@std@@CAAEAPEAV123@XZ() locale__Locimp__Clocptr_func
-@ stub -arch=win32 ?_Clog_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
-@ stub -arch=win64 ?_Clog_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
+@ cdecl -arch=win32 ?_Clog_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Clog_func
+@ cdecl -arch=win64 ?_Clog_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Clog_func
 @ stub -arch=win64 ?_Cm@?5???$log@M@std@@YA?AV?$complex@M@1@AEBV21@@Z@4MB
 @ stub -arch=win64 ?_Cm@?5???$log@N@std@@YA?AV?$complex@N@1@AEBV21@@Z@4NB
 @ thiscall -arch=win32 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z(ptr long long) basic_string_char__Copy
-- 
GitLab


From dfef29596b42f8744794d203d9e05e29fa58871d Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sun, 30 Oct 2022 22:23:00 +0100
Subject: [PATCH 5/8] msvcp90: Add _Cerr_func implementation.

---
 dlls/msvcp80/msvcp80.spec | 4 ++--
 dlls/msvcp90/ios.c        | 7 +++++++
 dlls/msvcp90/msvcp90.spec | 4 ++--
 3 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/dlls/msvcp80/msvcp80.spec b/dlls/msvcp80/msvcp80.spec
index 8aecaad284b..2bc65d9d65b 100644
--- a/dlls/msvcp80/msvcp80.spec
+++ b/dlls/msvcp80/msvcp80.spec
@@ -2109,8 +2109,8 @@
 @ cdecl -arch=win64 ?_BADOFF_func@std@@YAAEB_JXZ() std_BADOFF_func
 @ thiscall -arch=i386 ?_Callfns@ios_base@std@@AAEXW4event@12@@Z(ptr long) ios_base_Callfns
 @ cdecl -arch=win64 ?_Callfns@ios_base@std@@AEAAXW4event@12@@Z(ptr long) ios_base_Callfns
-@ stub -arch=win32 ?_Cerr_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
-@ stub -arch=win64 ?_Cerr_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
+@ cdecl -arch=win32 ?_Cerr_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Cerr_func
+@ cdecl -arch=win64 ?_Cerr_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Cerr_func
 @ thiscall -arch=win32 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z(ptr long long long) MSVCP_basic_string_char_Chassign
 @ cdecl -arch=win64 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX_K0D@Z(ptr long long long) MSVCP_basic_string_char_Chassign
 @ thiscall -arch=win32 ?_Chassign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXIIG@Z(ptr long long long) MSVCP_basic_string_wchar_Chassign
diff --git a/dlls/msvcp90/ios.c b/dlls/msvcp90/ios.c
index 8eedf0fe23b..6f791084099 100644
--- a/dlls/msvcp90/ios.c
+++ b/dlls/msvcp90/ios.c
@@ -15994,3 +15994,10 @@ basic_ostream_char* __cdecl _Clog_func(void)
 {
     return &MSVCP_clog.obj;
 }
+
+/* ?_Cerr_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ */
+/* ?_Cerr_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ */
+basic_ostream_char* __cdecl _Cerr_func(void)
+{
+    return &cerr.obj;
+}
diff --git a/dlls/msvcp90/msvcp90.spec b/dlls/msvcp90/msvcp90.spec
index d0861437cc6..52f9c9be014 100644
--- a/dlls/msvcp90/msvcp90.spec
+++ b/dlls/msvcp90/msvcp90.spec
@@ -2372,8 +2372,8 @@
 @ cdecl -arch=arm ?_Callfns@ios_base@std@@AAAXW4event@12@@Z(ptr long) ios_base_Callfns
 @ thiscall -arch=i386 ?_Callfns@ios_base@std@@AAEXW4event@12@@Z(ptr long) ios_base_Callfns
 @ cdecl -arch=win64 ?_Callfns@ios_base@std@@AEAAXW4event@12@@Z(ptr long) ios_base_Callfns
-@ stub -arch=win32 ?_Cerr_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
-@ stub -arch=win64 ?_Cerr_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ
+@ cdecl -arch=win32 ?_Cerr_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Cerr_func
+@ cdecl -arch=win64 ?_Cerr_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ() _Cerr_func
 @ thiscall -arch=win32 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXIID@Z(ptr long long long) MSVCP_basic_string_char_Chassign
 @ cdecl -arch=win64 ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAX_K0D@Z(ptr long long long) MSVCP_basic_string_char_Chassign
 @ thiscall -arch=win32 ?_Chassign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@IAEXIIG@Z(ptr long long long) MSVCP_basic_string_wchar_Chassign
-- 
GitLab


From 2f45744d9a1733ccc1410f21c4a77d269e92f2b2 Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sun, 30 Oct 2022 22:23:02 +0100
Subject: [PATCH 6/8] msvcp90: Add _Wcout_func implementation.

---
 dlls/msvcp80/msvcp80.spec |  8 ++++----
 dlls/msvcp90/ios.c        | 15 +++++++++++++++
 dlls/msvcp90/msvcp90.spec |  8 ++++----
 3 files changed, 23 insertions(+), 8 deletions(-)

diff --git a/dlls/msvcp80/msvcp80.spec b/dlls/msvcp80/msvcp80.spec
index 2bc65d9d65b..423e703d34c 100644
--- a/dlls/msvcp80/msvcp80.spec
+++ b/dlls/msvcp80/msvcp80.spec
@@ -2832,10 +2832,10 @@
 @ stub -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
 @ stub -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
 @ stub -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win64 ?_Wcout_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win64 ?_Wcout_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
+@ cdecl -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcout_func_short
+@ cdecl -arch=win64 ?_Wcout_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcout_func_short
+@ cdecl -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wcout_func
+@ cdecl -arch=win64 ?_Wcout_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wcout_func
 @ thiscall -arch=win32 ?_Widen_s@?$ctype@D@std@@QBEPBDPBD0PADI@Z(ptr ptr ptr ptr long) ctype_char__Widen_s
 @ cdecl -arch=win64 ?_Widen_s@?$ctype@D@std@@QEBAPEBDPEBD0PEAD_K@Z(ptr ptr ptr ptr long) ctype_char__Widen_s
 @ thiscall -arch=win32 ?_Widen_s@?$ctype@G@std@@QBEPBDPBD0PAGI@Z(ptr ptr ptr ptr long) ctype_wchar__Widen_s
diff --git a/dlls/msvcp90/ios.c b/dlls/msvcp90/ios.c
index 6f791084099..a6231af7257 100644
--- a/dlls/msvcp90/ios.c
+++ b/dlls/msvcp90/ios.c
@@ -15988,6 +15988,21 @@ basic_ostream_char* __cdecl _Cout_func(void)
     return &cout.obj;
 }
 
+/* ?_Wcout_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ */
+/* ?_Wcout_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ */
+basic_ostream_wchar* __cdecl _Wcout_func_short(void)
+{
+    return &ucout.obj;
+}
+
+
+/* ?_Wcout_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ */
+/* ?_Wcout_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ */
+basic_ostream_wchar* __cdecl _Wcout_func(void)
+{
+    return &wcout.obj;
+}
+
 /* ?_Clog_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ */
 /* ?_Clog_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ */
 basic_ostream_char* __cdecl _Clog_func(void)
diff --git a/dlls/msvcp90/msvcp90.spec b/dlls/msvcp90/msvcp90.spec
index 52f9c9be014..7194dfb477c 100644
--- a/dlls/msvcp90/msvcp90.spec
+++ b/dlls/msvcp90/msvcp90.spec
@@ -3175,10 +3175,10 @@
 @ stub -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
 @ stub -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
 @ stub -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win64 ?_Wcout_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win64 ?_Wcout_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
+@ cdecl -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcout_func_short
+@ cdecl -arch=win64 ?_Wcout_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcout_func_short
+@ cdecl -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wcout_func
+@ cdecl -arch=win64 ?_Wcout_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wcout_func
 @ thiscall -arch=win32 ?_Widen_s@?$ctype@D@std@@QBEPBDPBD0PADI@Z(ptr ptr ptr ptr long) ctype_char__Widen_s
 @ cdecl -arch=win64 ?_Widen_s@?$ctype@D@std@@QEBAPEBDPEBD0PEAD_K@Z(ptr ptr ptr ptr long) ctype_char__Widen_s
 @ thiscall -arch=win32 ?_Widen_s@?$ctype@G@std@@QBEPBDPBD0PAGI@Z(ptr ptr ptr ptr long) ctype_wchar__Widen_s
-- 
GitLab


From 40fdf9edc8845bd38b0bec7555db0929871469ba Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sun, 30 Oct 2022 22:23:03 +0100
Subject: [PATCH 7/8] msvcp90: Add _Wclog_func implementation.

---
 dlls/msvcp80/msvcp80.spec |  8 ++++----
 dlls/msvcp90/ios.c        | 14 ++++++++++++++
 dlls/msvcp90/msvcp90.spec |  8 ++++----
 3 files changed, 22 insertions(+), 8 deletions(-)

diff --git a/dlls/msvcp80/msvcp80.spec b/dlls/msvcp80/msvcp80.spec
index 423e703d34c..b5fdab98fde 100644
--- a/dlls/msvcp80/msvcp80.spec
+++ b/dlls/msvcp80/msvcp80.spec
@@ -2828,10 +2828,10 @@
 @ cdecl -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ() _Wcin_func_short
 @ cdecl -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ() _Wcin_func
 @ cdecl -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ() _Wcin_func
-@ stub -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
+@ cdecl -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wclog_func_short
+@ cdecl -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wclog_func_short
+@ cdecl -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wclog_func
+@ cdecl -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wclog_func
 @ cdecl -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcout_func_short
 @ cdecl -arch=win64 ?_Wcout_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcout_func_short
 @ cdecl -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wcout_func
diff --git a/dlls/msvcp90/ios.c b/dlls/msvcp90/ios.c
index a6231af7257..662c159fcc3 100644
--- a/dlls/msvcp90/ios.c
+++ b/dlls/msvcp90/ios.c
@@ -16010,6 +16010,20 @@ basic_ostream_char* __cdecl _Clog_func(void)
     return &MSVCP_clog.obj;
 }
 
+/* ?_Wclog_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ */
+/* ?_Wclog_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ */
+basic_ostream_wchar* __cdecl _Wclog_func_short(void)
+{
+    return &uclog.obj;
+}
+
+/* ?_Wclog_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ */
+/* ?_Wclog_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ */
+basic_ostream_wchar* __cdecl _Wclog_func(void)
+{
+    return &wclog.obj;
+}
+
 /* ?_Cerr_func@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ */
 /* ?_Cerr_func@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@1@XZ */
 basic_ostream_char* __cdecl _Cerr_func(void)
diff --git a/dlls/msvcp90/msvcp90.spec b/dlls/msvcp90/msvcp90.spec
index 7194dfb477c..a42a296d320 100644
--- a/dlls/msvcp90/msvcp90.spec
+++ b/dlls/msvcp90/msvcp90.spec
@@ -3171,10 +3171,10 @@
 @ cdecl -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ() _Wcin_func_short
 @ cdecl -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ() _Wcin_func
 @ cdecl -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ() _Wcin_func
-@ stub -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
+@ cdecl -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wclog_func_short
+@ cdecl -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wclog_func_short
+@ cdecl -arch=win32 ?_Wclog_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wclog_func
+@ cdecl -arch=win64 ?_Wclog_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wclog_func
 @ cdecl -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcout_func_short
 @ cdecl -arch=win64 ?_Wcout_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcout_func_short
 @ cdecl -arch=win32 ?_Wcout_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wcout_func
-- 
GitLab


From 698a066a821c0e457f7b0ec06019ee00c45e805d Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sun, 30 Oct 2022 22:23:04 +0100
Subject: [PATCH 8/8] msvcp90: Add _Wcerr_func implementation.

---
 dlls/msvcp80/msvcp80.spec |  8 ++++----
 dlls/msvcp90/ios.c        | 14 ++++++++++++++
 dlls/msvcp90/msvcp90.spec |  8 ++++----
 3 files changed, 22 insertions(+), 8 deletions(-)

diff --git a/dlls/msvcp80/msvcp80.spec b/dlls/msvcp80/msvcp80.spec
index b5fdab98fde..06816896d06 100644
--- a/dlls/msvcp80/msvcp80.spec
+++ b/dlls/msvcp80/msvcp80.spec
@@ -2820,10 +2820,10 @@
 @ cdecl -arch=win64 ?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAXXZ(ptr) basic_streambuf_wchar__Unlock
 @ thiscall -arch=win32 ?_Unlock@_Mutex@std@@QAEXXZ(ptr) mutex_unlock
 @ cdecl -arch=win64 ?_Unlock@_Mutex@std@@QEAAXXZ(ptr) mutex_unlock
-@ stub -arch=win32 ?_Wcerr_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win32 ?_Wcerr_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
+@ cdecl -arch=win32 ?_Wcerr_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcerr_func_short
+@ cdecl -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcerr_func_short
+@ cdecl -arch=win32 ?_Wcerr_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wcerr_func
+@ cdecl -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wcerr_func
 @ cdecl -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ() _Wcin_func_short
 @ cdecl -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ() _Wcin_func_short
 @ cdecl -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ() _Wcin_func
diff --git a/dlls/msvcp90/ios.c b/dlls/msvcp90/ios.c
index 662c159fcc3..1240bb537c9 100644
--- a/dlls/msvcp90/ios.c
+++ b/dlls/msvcp90/ios.c
@@ -16030,3 +16030,17 @@ basic_ostream_char* __cdecl _Cerr_func(void)
 {
     return &cerr.obj;
 }
+
+/* ?_Wcerr_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ */
+/* ?_Wcerr_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ */
+basic_ostream_wchar* __cdecl _Wcerr_func_short(void)
+{
+    return &ucerr.obj;
+}
+
+/* ?_Wcerr_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ */
+/* ?_Wcerr_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ */
+basic_ostream_wchar* __cdecl _Wcerr_func(void)
+{
+    return &wcerr.obj;
+}
diff --git a/dlls/msvcp90/msvcp90.spec b/dlls/msvcp90/msvcp90.spec
index a42a296d320..766f248aaa6 100644
--- a/dlls/msvcp90/msvcp90.spec
+++ b/dlls/msvcp90/msvcp90.spec
@@ -3163,10 +3163,10 @@
 @ cdecl -arch=win64 ?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QEAAXXZ(ptr) basic_streambuf_wchar__Unlock
 @ thiscall -arch=win32 ?_Unlock@_Mutex@std@@QAEXXZ(ptr) mutex_unlock
 @ cdecl -arch=win64 ?_Unlock@_Mutex@std@@QEAAXXZ(ptr) mutex_unlock
-@ stub -arch=win32 ?_Wcerr_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ
-@ stub -arch=win32 ?_Wcerr_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
-@ stub -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ
+@ cdecl -arch=win32 ?_Wcerr_func@std@@YAAAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcerr_func_short
+@ cdecl -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@GU?$char_traits@G@std@@@1@XZ() _Wcerr_func_short
+@ cdecl -arch=win32 ?_Wcerr_func@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wcerr_func
+@ cdecl -arch=win64 ?_Wcerr_func@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@1@XZ() _Wcerr_func
 @ cdecl -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ() _Wcin_func_short
 @ cdecl -arch=win64 ?_Wcin_func@std@@YAAEAV?$basic_istream@GU?$char_traits@G@std@@@1@XZ() _Wcin_func_short
 @ cdecl -arch=win32 ?_Wcin_func@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@1@XZ() _Wcin_func
-- 
GitLab

From 3aa65bd020f7e75eb098db684c7f693f8ddd1d07 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 1 Nov 2022 15:03:01 +0100
Subject: [PATCH] winecrt0: Move loading of __wine_unix_call to an inline
 function.

This improves performance of unix calls a little by removing one level
of indirection and a branch.
---
 dlls/winecrt0/Makefile.in |  1 -
 dlls/winecrt0/unix_lib.c  | 56 ---------------------------------------
 include/wine/unixlib.h    | 32 ++++++++++++++++++++--
 3 files changed, 30 insertions(+), 59 deletions(-)
 delete mode 100644 dlls/winecrt0/unix_lib.c

diff --git a/dlls/winecrt0/Makefile.in b/dlls/winecrt0/Makefile.in
index 6915e69eb4b..db68f399ec3 100644
--- a/dlls/winecrt0/Makefile.in
+++ b/dlls/winecrt0/Makefile.in
@@ -18,4 +18,3 @@ C_SRCS = \
 	register.c \
 	setjmp.c \
 	stub.c \
-	unix_lib.c
diff --git a/dlls/winecrt0/unix_lib.c b/dlls/winecrt0/unix_lib.c
deleted file mode 100644
index c86897b9905..00000000000
--- a/dlls/winecrt0/unix_lib.c
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Support for the Unix part of builtin dlls
- *
- * Copyright 2019 Alexandre Julliard
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#ifdef __WINE_PE_BUILD
-
-#include <stdarg.h>
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winbase.h"
-#include "winternl.h"
-#include "wine/unixlib.h"
-
-static NTSTATUS (WINAPI *p__wine_unix_call)( unixlib_handle_t, unsigned int, void * );
-
-static void load_func( void **func, const char *name, void *def )
-{
-    if (!*func)
-    {
-        HMODULE module = GetModuleHandleA( "ntdll.dll" );
-        void *proc = GetProcAddress( module, name );
-        InterlockedExchangePointer( func, proc ? proc : def );
-    }
-}
-#define LOAD_FUNC(name) load_func( (void **)&p ## name, #name, fallback ## name )
-
-static NTSTATUS __cdecl fallback__wine_unix_call( unixlib_handle_t handle, unsigned int code, void *args )
-{
-    return STATUS_DLL_NOT_FOUND;
-}
-
-NTSTATUS WINAPI __wine_unix_call( unixlib_handle_t handle, unsigned int code, void *args )
-{
-    LOAD_FUNC( __wine_unix_call );
-    return p__wine_unix_call( handle, code, args );
-}
-
-#endif  /* __WINE_PE_BUILD */
diff --git a/include/wine/unixlib.h b/include/wine/unixlib.h
index ef60b32184c..fe7a08effbd 100644
--- a/include/wine/unixlib.h
+++ b/include/wine/unixlib.h
@@ -24,10 +24,10 @@
 typedef NTSTATUS (*unixlib_entry_t)( void *args );
 typedef UINT64 unixlib_handle_t;
 
-extern NTSTATUS WINAPI __wine_unix_call( unixlib_handle_t handle, unsigned int code, void *args );
-
 #ifdef WINE_UNIX_LIB
 
+extern NTSTATUS WINAPI __wine_unix_call( unixlib_handle_t handle, unsigned int code, void *args );
+
 /* some useful helpers from ntdll */
 extern const char *ntdll_get_build_dir(void);
 extern const char *ntdll_get_data_dir(void);
@@ -264,6 +264,34 @@ static inline ULONG ntdll_wcstoul( const WCHAR *s, WCHAR **end, int base )
 #define wcstol(str,e,b)    ntdll_wcstol(str,e,b)
 #define wcstoul(str,e,b)   ntdll_wcstoul(str,e,b)
 
+#else
+
+#include "winternl.h"
+
+static inline NTSTATUS WINAPI delayload__wine_unix_call( unixlib_handle_t handle, unsigned int code, void *args );
+static NTSTATUS (WINAPI *__wine_unix_call)( unixlib_handle_t, unsigned int, void * ) = delayload__wine_unix_call;
+static inline NTSTATUS WINAPI fallback__wine_unix_call( unixlib_handle_t handle, unsigned int code, void *args )
+{
+    return STATUS_DLL_NOT_FOUND;
+}
+
+static inline NTSTATUS WINAPI delayload__wine_unix_call( unixlib_handle_t handle, unsigned int code, void *args )
+{
+    UNICODE_STRING ntdll_str;
+    ANSI_STRING name_str;
+    HMODULE module;
+    void *proc;
+
+    RtlInitUnicodeString( &ntdll_str, L"ntdll.dll" );
+    RtlInitAnsiString( &name_str, "__wine_unix_call" );
+
+    if (LdrGetDllHandleEx( LDR_GET_DLL_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT, NULL, NULL, &ntdll_str, &module )) proc = NULL;
+    else if (LdrGetProcedureAddress( module, &name_str, 0, &proc )) proc = NULL;
+
+    InterlockedExchangePointer( (void *)&__wine_unix_call, proc ? proc : fallback__wine_unix_call );
+    return __wine_unix_call( handle, code, args );
+}
+
 #endif /* WINE_UNIX_LIB */
 
 #endif  /* __WINE_WINE_UNIXLIB_H */
-- 
GitLab

From fc5cb9b577a66eab38ea61290bdac60ec36f80ec Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 28 Jun 2022 17:13:47 +0300
Subject: [PATCH 1/2] ntdll: Partially implement MemoryRegionInformation query.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/ntdll/tests/virtual.c |  97 +++++++++++++++++++++++++++++++
 dlls/ntdll/unix/virtual.c  | 115 +++++++++++++++++++++++++------------
 dlls/wow64/struct32.h      |  11 ++++
 dlls/wow64/virtual.c       |  23 ++++++++
 include/winternl.h         |  24 ++++++++
 5 files changed, 233 insertions(+), 37 deletions(-)

diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index d8b888aa49e..422d717b00d 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -4080,48 +4080,13 @@ static int get_free_mem_state_callback( void *start, SIZE_T size, void *arg )
     return 1;
 }
 
-/* get basic information about a memory block */
-static NTSTATUS get_basic_memory_info( HANDLE process, LPCVOID addr,
-                                       MEMORY_BASIC_INFORMATION *info,
-                                       SIZE_T len, SIZE_T *res_len )
+static NTSTATUS fill_basic_memory_info( const void *addr, MEMORY_BASIC_INFORMATION *info )
 {
-    struct file_view *view;
     char *base, *alloc_base = 0, *alloc_end = working_set_limit;
     struct wine_rb_entry *ptr;
+    struct file_view *view;
     sigset_t sigset;
 
-    if (len < sizeof(MEMORY_BASIC_INFORMATION))
-        return STATUS_INFO_LENGTH_MISMATCH;
-
-    if (process != NtCurrentProcess())
-    {
-        NTSTATUS status;
-        apc_call_t call;
-        apc_result_t result;
-
-        memset( &call, 0, sizeof(call) );
-
-        call.virtual_query.type = APC_VIRTUAL_QUERY;
-        call.virtual_query.addr = wine_server_client_ptr( addr );
-        status = server_queue_process_apc( process, &call, &result );
-        if (status != STATUS_SUCCESS) return status;
-
-        if (result.virtual_query.status == STATUS_SUCCESS)
-        {
-            info->BaseAddress       = wine_server_get_ptr( result.virtual_query.base );
-            info->AllocationBase    = wine_server_get_ptr( result.virtual_query.alloc_base );
-            info->RegionSize        = result.virtual_query.size;
-            info->Protect           = result.virtual_query.prot;
-            info->AllocationProtect = result.virtual_query.alloc_prot;
-            info->State             = (DWORD)result.virtual_query.state << 12;
-            info->Type              = (DWORD)result.virtual_query.alloc_type << 16;
-            if (info->RegionSize != result.virtual_query.size)  /* truncated */
-                return STATUS_INVALID_PARAMETER;  /* FIXME */
-            if (res_len) *res_len = sizeof(*info);
-        }
-        return result.virtual_query.status;
-    }
-
     base = ROUND_ADDR( addr, page_mask );
 
     if (is_beyond_limit( base, 1, working_set_limit )) return STATUS_INVALID_PARAMETER;
@@ -4195,6 +4160,79 @@ static NTSTATUS get_basic_memory_info( HANDLE process, LPCVOID addr,
     }
     server_leave_uninterrupted_section( &virtual_mutex, &sigset );
 
+    return STATUS_SUCCESS;
+}
+
+/* get basic information about a memory block */
+static NTSTATUS get_basic_memory_info( HANDLE process, LPCVOID addr,
+                                       MEMORY_BASIC_INFORMATION *info,
+                                       SIZE_T len, SIZE_T *res_len )
+{
+    NTSTATUS status;
+
+    if (len < sizeof(*info))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (process != NtCurrentProcess())
+    {
+        NTSTATUS status;
+        apc_call_t call;
+        apc_result_t result;
+
+        memset( &call, 0, sizeof(call) );
+
+        call.virtual_query.type = APC_VIRTUAL_QUERY;
+        call.virtual_query.addr = wine_server_client_ptr( addr );
+        status = server_queue_process_apc( process, &call, &result );
+        if (status != STATUS_SUCCESS) return status;
+
+        if (result.virtual_query.status == STATUS_SUCCESS)
+        {
+            info->BaseAddress       = wine_server_get_ptr( result.virtual_query.base );
+            info->AllocationBase    = wine_server_get_ptr( result.virtual_query.alloc_base );
+            info->RegionSize        = result.virtual_query.size;
+            info->Protect           = result.virtual_query.prot;
+            info->AllocationProtect = result.virtual_query.alloc_prot;
+            info->State             = (DWORD)result.virtual_query.state << 12;
+            info->Type              = (DWORD)result.virtual_query.alloc_type << 16;
+            if (info->RegionSize != result.virtual_query.size)  /* truncated */
+                return STATUS_INVALID_PARAMETER;  /* FIXME */
+            if (res_len) *res_len = sizeof(*info);
+        }
+        return result.virtual_query.status;
+    }
+
+    if ((status = fill_basic_memory_info( addr, info ))) return status;
+
+    if (res_len) *res_len = sizeof(*info);
+    return STATUS_SUCCESS;
+}
+
+static NTSTATUS get_memory_region_info( HANDLE process, LPCVOID addr, MEMORY_REGION_INFORMATION *info,
+        SIZE_T len, SIZE_T *res_len )
+{
+    MEMORY_BASIC_INFORMATION basic_info;
+    NTSTATUS status;
+
+    if (len < FIELD_OFFSET(MEMORY_REGION_INFORMATION, CommitSize))
+        return STATUS_INFO_LENGTH_MISMATCH;
+
+    if (process != NtCurrentProcess())
+    {
+        FIXME("Unimplemented for other processes.\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    if ((status = fill_basic_memory_info( addr, &basic_info ))) return status;
+
+    info->AllocationBase = basic_info.AllocationBase;
+    info->AllocationProtect = basic_info.AllocationProtect;
+    info->RegionType = 0; /* FIXME */
+    if (len >= FIELD_OFFSET(MEMORY_REGION_INFORMATION, CommitSize))
+        info->RegionSize = basic_info.RegionSize;
+    if (len >= FIELD_OFFSET(MEMORY_REGION_INFORMATION, PartitionId))
+        info->CommitSize = basic_info.State == MEM_COMMIT ? basic_info.RegionSize : 0;
+
     if (res_len) *res_len = sizeof(*info);
     return STATUS_SUCCESS;
 }
@@ -4371,6 +4409,9 @@ NTSTATUS WINAPI NtQueryVirtualMemory( HANDLE process, LPCVOID addr,
         case MemoryMappedFilenameInformation:
             return get_memory_section_name( process, addr, buffer, len, res_len );
 
+        case MemoryRegionInformation:
+            return get_memory_region_info( process, addr, buffer, len, res_len );
+
         case MemoryWineUnixFuncs:
         case MemoryWineUnixWow64Funcs:
             if (len != sizeof(unixlib_handle_t)) return STATUS_INFO_LENGTH_MISMATCH;
diff --git a/dlls/wow64/struct32.h b/dlls/wow64/struct32.h
index 91acc26436f..0a0324a22f3 100644
--- a/dlls/wow64/struct32.h
+++ b/dlls/wow64/struct32.h
@@ -156,6 +156,17 @@ typedef struct
     DWORD    Type;
 } MEMORY_BASIC_INFORMATION32;
 
+typedef struct
+{
+    ULONG AllocationBase;
+    ULONG AllocationProtect;
+    ULONG RegionType;
+    ULONG RegionSize;
+    ULONG CommitSize;
+    ULONG PartitionId;
+    ULONG NodePreference;
+} MEMORY_REGION_INFORMATION32;
+
 typedef struct
 {
     UNICODE_STRING32 SectionFileName;
diff --git a/dlls/wow64/virtual.c b/dlls/wow64/virtual.c
index 8b7d022301f..4d3bb90386a 100644
--- a/dlls/wow64/virtual.c
+++ b/dlls/wow64/virtual.c
@@ -422,6 +422,29 @@ NTSTATUS WINAPI wow64_NtQueryVirtualMemory( UINT *args )
         break;
     }
 
+    case MemoryRegionInformation: /* MEMORY_REGION_INFORMATION */
+    {
+        if (len >= sizeof(MEMORY_REGION_INFORMATION32))
+        {
+            MEMORY_REGION_INFORMATION info;
+            MEMORY_REGION_INFORMATION32 *info32 = ptr;
+
+            if (!(status = NtQueryVirtualMemory( handle, addr, class, &info, sizeof(info), &res_len )))
+            {
+                info32->AllocationBase = PtrToUlong( info.AllocationBase );
+                info32->AllocationProtect = info.AllocationProtect;
+                info32->RegionType = info.RegionType;
+                info32->RegionSize = info.RegionSize;
+                info32->CommitSize = info.CommitSize;
+                info32->PartitionId = info.PartitionId;
+                info32->NodePreference = info.NodePreference;
+            }
+        }
+        else status = STATUS_INFO_LENGTH_MISMATCH;
+        res_len = sizeof(MEMORY_REGION_INFORMATION32);
+        break;
+    }
+
     case MemoryWorkingSetExInformation:  /* MEMORY_WORKING_SET_EX_INFORMATION */
     {
         MEMORY_WORKING_SET_EX_INFORMATION32 *info32 = ptr;
diff --git a/include/winternl.h b/include/winternl.h
index 5c564373fed..c64ff0f9082 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -1971,6 +1971,30 @@ typedef struct _MEMORY_WORKING_SET_EX_INFORMATION {
     MEMORY_WORKING_SET_EX_BLOCK VirtualAttributes;
 } MEMORY_WORKING_SET_EX_INFORMATION, *PMEMORY_WORKING_SET_EX_INFORMATION;
 
+typedef struct _MEMORY_REGION_INFORMATION
+{
+    PVOID AllocationBase;
+    ULONG AllocationProtect;
+    union
+    {
+        ULONG RegionType;
+        struct
+        {
+            ULONG Private : 1;
+            ULONG MappedDataFile : 1;
+            ULONG MappedImage : 1;
+            ULONG MappedPageFile : 1;
+            ULONG MappedPhysical : 1;
+            ULONG DirectMapped : 1;
+            ULONG Reserved : 26;
+        } DUMMYSTRUCTNAME;
+    } DUMMYUNIONNAME;
+    SIZE_T RegionSize;
+    SIZE_T CommitSize;
+    ULONG_PTR PartitionId;
+    ULONG_PTR NodePreference;
+} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;
+
 typedef enum _MUTANT_INFORMATION_CLASS
 {
     MutantBasicInformation
-- 
GitLab


From 9cd5bc0d86d53c2db32c8025df99a487dad94850 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Tue, 28 Jun 2022 18:13:54 +0300
Subject: [PATCH 2/2] kernelbase: Add QueryVirtualMemoryInformation().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/kernelbase/kernelbase.spec |  2 +-
 dlls/kernelbase/memory.c        | 17 +++++++++++++
 include/Makefile.in             |  1 +
 include/memoryapi.h             | 45 +++++++++++++++++++++++++++++++++
 include/winbase.h               |  1 +
 5 files changed, 65 insertions(+), 1 deletion(-)
 create mode 100644 include/memoryapi.h

diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index cbce448d3e9..c51dbd6bc73 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -1250,7 +1250,7 @@
 @ stdcall QueryThreadpoolStackInformation(ptr ptr)
 @ stdcall QueryUnbiasedInterruptTime(ptr) ntdll.RtlQueryUnbiasedInterruptTime
 # @ stub QueryUnbiasedInterruptTimePrecise
-# @ stub QueryVirtualMemoryInformation
+@ stdcall QueryVirtualMemoryInformation(long ptr long ptr long ptr)
 @ stdcall QueryWorkingSet(long ptr long)
 @ stdcall QueryWorkingSetEx(long ptr long)
 @ stdcall QueueUserAPC(ptr long long)
diff --git a/dlls/kernelbase/memory.c b/dlls/kernelbase/memory.c
index 412d80f5cfd..19b1d0a3a1a 100644
--- a/dlls/kernelbase/memory.c
+++ b/dlls/kernelbase/memory.c
@@ -1411,6 +1411,23 @@ LPVOID WINAPI DECLSPEC_HOTPATCH VirtualAllocExNuma( HANDLE process, void *addr,
 }
 
 
+/***********************************************************************
+ *             QueryVirtualMemoryInformation   (kernelbase.@)
+ */
+BOOL WINAPI DECLSPEC_HOTPATCH QueryVirtualMemoryInformation( HANDLE process, const void *addr,
+        WIN32_MEMORY_INFORMATION_CLASS info_class, void *info, SIZE_T size, SIZE_T *ret_size)
+{
+    switch (info_class)
+    {
+        case MemoryRegionInfo:
+            return set_ntstatus( NtQueryVirtualMemory( process, addr, MemoryRegionInformation, info, size, ret_size ));
+        default:
+            FIXME("Unsupported info class %u.\n", info_class);
+            return FALSE;
+    }
+}
+
+
 /***********************************************************************
  * CPU functions
  ***********************************************************************/
diff --git a/include/Makefile.in b/include/Makefile.in
index 1c04f9a298b..28ac4b3f2dc 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -411,6 +411,7 @@ SOURCES = \
 	mcx.h \
 	mediaerr.h \
 	mediaobj.idl \
+	memoryapi.h \
 	metahost.idl \
 	mfapi.h \
 	mfd3d12.idl \
diff --git a/include/memoryapi.h b/include/memoryapi.h
new file mode 100644
index 00000000000..8743e67927c
--- /dev/null
+++ b/include/memoryapi.h
@@ -0,0 +1,45 @@
+/*
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+typedef enum WIN32_MEMORY_INFORMATION_CLASS
+{
+    MemoryRegionInfo
+} WIN32_MEMORY_INFORMATION_CLASS;
+
+typedef struct WIN32_MEMORY_REGION_INFORMATION
+{
+    PVOID AllocationBase;
+    ULONG AllocationProtect;
+    union
+    {
+        ULONG Flags;
+        struct
+        {
+            ULONG Private : 1;
+            ULONG MappedDataFile : 1;
+            ULONG MappedImage : 1;
+            ULONG MappedPageFile : 1;
+            ULONG MappedPhysical : 1;
+            ULONG DirectMapped : 1;
+            ULONG Reserved : 26;
+        } DUMMYSTRUCTNAME;
+    } DUMMYUNIONNAME;
+    SIZE_T RegionSize;
+    SIZE_T CommitSize;
+} WIN32_MEMORY_REGION_INFORMATION;
+
+BOOL WINAPI QueryVirtualMemoryInformation(HANDLE process,const void *addr,
+        WIN32_MEMORY_INFORMATION_CLASS info_class, void *info, SIZE_T size, SIZE_T *ret_size);
diff --git a/include/winbase.h b/include/winbase.h
index 58f21a1361a..7c0d8afd36c 100644
--- a/include/winbase.h
+++ b/include/winbase.h
@@ -43,6 +43,7 @@ extern "C" {
 #include <processthreadsapi.h>
 #include <synchapi.h>
 #include <threadpoolapiset.h>
+#include <memoryapi.h>
 
   /* Windows Exit Procedure flag values */
 #define	WEP_FREE_DLL        0
-- 
GitLab

From 404e590e06b4443d76bedfa1bc9f3c25dda6d8cb Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 27 Oct 2022 19:48:01 +0300
Subject: [PATCH 1/3] kernelbase: Forward some directory info classes in
 GetFileInformationByHandleEx().

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=53590
Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/kernelbase/file.c | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index 3e1fd5aec4e..c0cdfdcdf84 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -2967,12 +2967,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetFileInformationByHandleEx( HANDLE handle, FILE_
     case FileStreamInfo:
     case FileCompressionInfo:
     case FileRemoteProtocolInfo:
-    case FileFullDirectoryInfo:
-    case FileFullDirectoryRestartInfo:
     case FileStorageInfo:
     case FileAlignmentInfo:
-    case FileIdExtdDirectoryInfo:
-    case FileIdExtdDirectoryRestartInfo:
         FIXME( "%p, %u, %p, %lu\n", handle, class, info, size );
         SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
         return FALSE;
@@ -3004,6 +3000,20 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetFileInformationByHandleEx( HANDLE handle, FILE_
                                        (class == FileIdBothDirectoryRestartInfo) );
         break;
 
+    case FileFullDirectoryInfo:
+    case FileFullDirectoryRestartInfo:
+        status = NtQueryDirectoryFile( handle, NULL, NULL, NULL, &io, info, size,
+                                       FileFullDirectoryInformation, FALSE, NULL,
+                                       (class == FileFullDirectoryRestartInfo) );
+        break;
+
+    case FileIdExtdDirectoryInfo:
+    case FileIdExtdDirectoryRestartInfo:
+        status = NtQueryDirectoryFile( handle, NULL, NULL, NULL, &io, info, size,
+                                       FileIdExtdDirectoryInformation, FALSE, NULL,
+                                       (class == FileIdExtdDirectoryRestartInfo) );
+        break;
+
     case FileRenameInfo:
     case FileDispositionInfo:
     case FileAllocationInfo:
-- 
GitLab


From f054d2ab58a6fc129583775e683d84bbdd421425 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 27 Oct 2022 21:41:38 +0300
Subject: [PATCH 2/3] kernelbase: Make sure to provide a message for missing
 information classes in GetFileInformationByHandleEx().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/kernelbase/file.c | 4 ++++
 include/winbase.h      | 4 ++++
 2 files changed, 8 insertions(+)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index c0cdfdcdf84..5e6d271c3b0 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -2969,6 +2969,10 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetFileInformationByHandleEx( HANDLE handle, FILE_
     case FileRemoteProtocolInfo:
     case FileStorageInfo:
     case FileAlignmentInfo:
+    case FileDispositionInfoEx:
+    case FileRenameInfoEx:
+    case FileCaseSensitiveInfo:
+    case FileNormalizedNameInfo:
         FIXME( "%p, %u, %p, %lu\n", handle, class, info, size );
         SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
         return FALSE;
diff --git a/include/winbase.h b/include/winbase.h
index 277f981982d..58f21a1361a 100644
--- a/include/winbase.h
+++ b/include/winbase.h
@@ -802,6 +802,10 @@ typedef enum _FILE_INFO_BY_HANDLE_CLASS {
     FileIdInfo,
     FileIdExtdDirectoryInfo,
     FileIdExtdDirectoryRestartInfo,
+    FileDispositionInfoEx,
+    FileRenameInfoEx,
+    FileCaseSensitiveInfo,
+    FileNormalizedNameInfo,
     MaximumFileInfoByHandlesClass
 } FILE_INFO_BY_HANDLE_CLASS, *PFILE_INFO_BY_HANDLE_CLASS;
 
-- 
GitLab


From 69cff16d696bc2270f26826b3f2be64abf425725 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Thu, 27 Oct 2022 23:02:37 +0300
Subject: [PATCH 3/3] kernelbase: Forward some more classes in
 GetFileInformationByHandleEx().

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/kernelbase/file.c | 15 ++++++++++++---
 1 file changed, 12 insertions(+), 3 deletions(-)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index 5e6d271c3b0..661bc0c2778 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -2964,11 +2964,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetFileInformationByHandleEx( HANDLE handle, FILE_
 
     switch (class)
     {
-    case FileStreamInfo:
-    case FileCompressionInfo:
     case FileRemoteProtocolInfo:
     case FileStorageInfo:
-    case FileAlignmentInfo:
     case FileDispositionInfoEx:
     case FileRenameInfoEx:
     case FileCaseSensitiveInfo:
@@ -2977,6 +2974,18 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetFileInformationByHandleEx( HANDLE handle, FILE_
         SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
         return FALSE;
 
+    case FileStreamInfo:
+        status = NtQueryInformationFile( handle, &io, info, size, FileStreamInformation );
+        break;
+
+    case FileCompressionInfo:
+        status = NtQueryInformationFile( handle, &io, info, size, FileCompressionInformation );
+        break;
+
+    case FileAlignmentInfo:
+        status = NtQueryInformationFile( handle, &io, info, size, FileAlignmentInformation );
+        break;
+
     case FileAttributeTagInfo:
         status = NtQueryInformationFile( handle, &io, info, size, FileAttributeTagInformation );
         break;
-- 
GitLab

From 046bed65d46b5b096f473b9929784d2cd2409272 Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sun, 23 Oct 2022 23:31:40 +0200
Subject: [PATCH 3/4] msvcrt: Fix error handling for strcat_s.

---
 dlls/msvcrt/string.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/msvcrt/string.c b/dlls/msvcrt/string.c
index ba2f4fa4357..b787061d789 100644
--- a/dlls/msvcrt/string.c
+++ b/dlls/msvcrt/string.c
@@ -1350,9 +1350,9 @@ int CDECL strcpy_s( char* dst, size_t elem, const char* src )
 int CDECL strcat_s( char* dst, size_t elem, const char* src )
 {
     size_t i, j;
-    if(!dst) return EINVAL;
-    if(elem == 0) return EINVAL;
-    if(!src)
+    if (!MSVCRT_CHECK_PMT(dst != 0)) return EINVAL;
+    if (!MSVCRT_CHECK_PMT(elem != 0)) return EINVAL;
+    if (!MSVCRT_CHECK_PMT(src != NULL))
     {
         dst[0] = '\0';
         return EINVAL;
@@ -1369,6 +1369,7 @@ int CDECL strcat_s( char* dst, size_t elem, const char* src )
         }
     }
     /* Set the first element to 0, not the first element after the skipped part */
+    MSVCRT_INVALID_PMT("dst[elem] is too small", ERANGE);
     dst[0] = '\0';
     return ERANGE;
 }
-- 
GitLab


From 5b435796399a4bda28b41c0fca35b3e7d5d2df44 Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sun, 23 Oct 2022 23:33:16 +0200
Subject: [PATCH 4/4] msvcrt: Fix error handling for strcpy_s.

---
 dlls/msvcrt/string.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/msvcrt/string.c b/dlls/msvcrt/string.c
index b787061d789..d58a21406b1 100644
--- a/dlls/msvcrt/string.c
+++ b/dlls/msvcrt/string.c
@@ -1328,9 +1328,9 @@ char* CDECL strcpy(char *dst, const char *src)
 int CDECL strcpy_s( char* dst, size_t elem, const char* src )
 {
     size_t i;
-    if(!elem) return EINVAL;
-    if(!dst) return EINVAL;
-    if(!src)
+    if (!MSVCRT_CHECK_PMT(dst != 0)) return EINVAL;
+    if (!MSVCRT_CHECK_PMT(elem != 0)) return EINVAL;
+    if (!MSVCRT_CHECK_PMT(src != NULL))
     {
         dst[0] = '\0';
         return EINVAL;
@@ -1340,6 +1340,7 @@ int CDECL strcpy_s( char* dst, size_t elem, const char* src )
     {
         if((dst[i] = src[i]) == '\0') return 0;
     }
+    MSVCRT_INVALID_PMT("dst[elem] is too small", ERANGE);
     dst[0] = '\0';
     return ERANGE;
 }
-- 
GitLab

From 927a9a5a04c9c7d8dbcfbe887594a87887911ce3 Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Thu, 20 Oct 2022 00:55:59 +0200
Subject: [PATCH 4/6] msvcrt: Fix error handling for _mbscmp_l.

---
 dlls/msvcrt/mbcs.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/msvcrt/mbcs.c b/dlls/msvcrt/mbcs.c
index 49109943665..1754a732cb6 100644
--- a/dlls/msvcrt/mbcs.c
+++ b/dlls/msvcrt/mbcs.c
@@ -982,7 +982,8 @@ int CDECL _mbscmp_l(const unsigned char* str, const unsigned char* cmp, _locale_
 {
   pthreadmbcinfo mbcinfo;
 
-  if (!str || !cmp) return INT_MAX;
+  if (!MSVCRT_CHECK_PMT(str && cmp))
+    return _NLSCMPERROR;
 
   mbcinfo = locale ? locale->mbcinfo : get_mbcinfo();
 
-- 
GitLab

From f943d4497226e69265a8a278f5795756ba1b2f47 Mon Sep 17 00:00:00 2001
From: Piotr Caban <piotr@codeweavers.com>
Date: Sat, 22 Oct 2022 14:32:30 +0200
Subject: [PATCH] msvcrt: Fix _wputenv_s invalid argument handling.

---
 dlls/msvcrt/environ.c       |  4 ++--
 dlls/msvcrt/tests/environ.c | 39 +++++++++++++++++++++++++++++++++++--
 2 files changed, 39 insertions(+), 4 deletions(-)

diff --git a/dlls/msvcrt/environ.c b/dlls/msvcrt/environ.c
index 9800a1b66b1..e541bd5bff0 100644
--- a/dlls/msvcrt/environ.c
+++ b/dlls/msvcrt/environ.c
@@ -197,8 +197,8 @@ errno_t CDECL _wputenv_s(const wchar_t *name, const wchar_t *value)
 
     TRACE("%s %s\n", debugstr_w(name), debugstr_w(value));
 
-    if (!MSVCRT_CHECK_PMT(name != NULL)) return -1;
-    if (!MSVCRT_CHECK_PMT(value != NULL)) return -1;
+    if (!MSVCRT_CHECK_PMT(name != NULL)) return EINVAL;
+    if (!MSVCRT_CHECK_PMT(value != NULL)) return EINVAL;
 
     if (!SetEnvironmentVariableW(name, value[0] ? value : NULL))
     {
diff --git a/dlls/msvcrt/tests/environ.c b/dlls/msvcrt/tests/environ.c
index 62e4f3133cf..03129dcbf14 100644
--- a/dlls/msvcrt/tests/environ.c
+++ b/dlls/msvcrt/tests/environ.c
@@ -19,6 +19,7 @@
  */
 
 #include "wine/test.h"
+#include <errno.h>
 #include <stdlib.h>
 #include <process.h>
 
@@ -45,8 +46,10 @@ static const char *a_very_long_env_string =
 
 static char ***(__cdecl *p__p__environ)(void);
 static WCHAR ***(__cdecl *p__p__wenviron)(void);
-static void (*p_get_environ)(char ***);
-static void (*p_get_wenviron)(WCHAR ***);
+static void (__cdecl *p_get_environ)(char ***);
+static void (__cdecl *p_get_wenviron)(WCHAR ***);
+static errno_t (__cdecl *p_putenv_s)(const char*, const char*);
+static errno_t (__cdecl *p_wputenv_s)(const wchar_t*, const wchar_t*);
 
 static char ***p_environ;
 static WCHAR ***p_wenviron;
@@ -61,6 +64,8 @@ static void init(void)
     p_wenviron = (void *)GetProcAddress(hmod, "_wenviron");
     p_get_environ = (void *)GetProcAddress(hmod, "_get_environ");
     p_get_wenviron = (void *)GetProcAddress(hmod, "_get_wenviron");
+    p_putenv_s = (void *)GetProcAddress(hmod, "_putenv_s");
+    p_wputenv_s = (void *)GetProcAddress(hmod, "_wputenv_s");
 }
 
 static void test_system(void)
@@ -237,6 +242,8 @@ static void test__wenviron(void)
 
 static void test_environment_manipulation(void)
 {
+    errno_t ret;
+
     ok( _putenv("cat=") == 0, "_putenv failed on deletion of nonexistent environment variable\n" );
     ok( _putenv("cat=dog") == 0, "failed setting cat=dog\n" );
     ok( strcmp(getenv("cat"), "dog") == 0, "getenv did not return 'dog'\n" );
@@ -247,6 +254,34 @@ static void test_environment_manipulation(void)
     ok( _putenv(a_very_long_env_string) == 0, "_putenv failed for long environment string\n");
 
     ok( getenv("nonexistent") == NULL, "getenv should fail with nonexistent var name\n" );
+
+    if (p_putenv_s)
+    {
+        ret = p_putenv_s(NULL, "dog");
+        ok( ret == EINVAL, "_putenv_s returned %d\n", ret);
+        ret = p_putenv_s("cat", NULL);
+        ok( ret == EINVAL, "_putenv_s returned %d\n", ret);
+        ret = p_putenv_s("a=b", NULL);
+        ok( ret == EINVAL, "_putenv_s returned %d\n", ret);
+        ret = p_putenv_s("cat", "a=b");
+        ok( !ret, "_putenv_s returned %d\n", ret);
+        ret = p_putenv_s("cat", "");
+        ok( !ret, "_putenv_s returned %d\n", ret);
+    }
+
+    if (p_wputenv_s)
+    {
+        ret = p_wputenv_s(NULL, L"dog");
+        ok( ret == EINVAL, "_wputenv_s returned %d\n", ret);
+        ret = p_wputenv_s(L"cat", NULL);
+        ok( ret == EINVAL, "_wputenv_s returned %d\n", ret);
+        ret = p_wputenv_s(L"a=b", NULL);
+        ok( ret == EINVAL, "_wputenv_s returned %d\n", ret);
+        ret = p_wputenv_s(L"cat", L"a=b");
+        ok( !ret, "_wputenv_s returned %d\n", ret);
+        ret = p_wputenv_s(L"cat", L"");
+        ok( !ret, "_wputenv_s returned %d\n", ret);
+    }
 }
 
 START_TEST(environ)
-- 
GitLab

From 53acb6e736d6feb10b19fd609771ecfa33f7d1e9 Mon Sep 17 00:00:00 2001
From: Piotr Caban <piotr@codeweavers.com>
Date: Fri, 21 Oct 2022 13:28:23 +0200
Subject: [PATCH 1/2] msvcrt: Fix _putenv_s return value on error.

---
 dlls/msvcrt/environ.c | 19 ++++++++++++-------
 1 file changed, 12 insertions(+), 7 deletions(-)

diff --git a/dlls/msvcrt/environ.c b/dlls/msvcrt/environ.c
index 83a493c1a9a..a35d0877891 100644
--- a/dlls/msvcrt/environ.c
+++ b/dlls/msvcrt/environ.c
@@ -165,17 +165,22 @@ finish:
  */
 errno_t CDECL _putenv_s(const char *name, const char *value)
 {
-    int ret;
+    errno_t ret = 0;
 
     TRACE("%s %s\n", debugstr_a(name), debugstr_a(value));
 
-    if (!MSVCRT_CHECK_PMT(name != NULL)) return -1;
-    if (!MSVCRT_CHECK_PMT(value != NULL)) return -1;
+    if (!MSVCRT_CHECK_PMT(name != NULL)) return EINVAL;
+    if (!MSVCRT_CHECK_PMT(value != NULL)) return EINVAL;
 
-    ret = SetEnvironmentVariableA(name, value[0] ? value : NULL) ? 0 : -1;
-
-    /* _putenv returns success on deletion of nonexistent variable, unlike [Rtl]SetEnvironmentVariable */
-    if ((ret == -1) && (GetLastError() == ERROR_ENVVAR_NOT_FOUND)) ret = 0;
+    if (!SetEnvironmentVariableA(name, value[0] ? value : NULL))
+    {
+        /* _putenv returns success on deletion of nonexistent variable */
+        if (GetLastError() != ERROR_ENVVAR_NOT_FOUND)
+        {
+            msvcrt_set_errno(GetLastError());
+            ret = *_errno();
+        }
+    }
 
     MSVCRT__environ = msvcrt_SnapshotOfEnvironmentA(MSVCRT__environ);
     MSVCRT__wenviron = msvcrt_SnapshotOfEnvironmentW(MSVCRT__wenviron);
-- 
GitLab


From f0e6447b7fc10c21bf6aa04f70a5094f16a294a5 Mon Sep 17 00:00:00 2001
From: Piotr Caban <piotr@codeweavers.com>
Date: Fri, 21 Oct 2022 13:30:19 +0200
Subject: [PATCH 2/2] msvcrt: Fix _wputenv_s return value on error.

---
 dlls/msvcrt/environ.c | 17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/dlls/msvcrt/environ.c b/dlls/msvcrt/environ.c
index a35d0877891..9800a1b66b1 100644
--- a/dlls/msvcrt/environ.c
+++ b/dlls/msvcrt/environ.c
@@ -191,19 +191,24 @@ int CDECL _putenv_s(const char *name, co
 /*********************************************************************
  *		_wputenv_s (MSVCRT.@)
  */
-int CDECL _wputenv_s(const wchar_t *name, const wchar_t *value)
+errno_t CDECL _wputenv_s(const wchar_t *name, const wchar_t *value)
 {
-    int ret;
+    errno_t ret = 0;
 
     TRACE("%s %s\n", debugstr_w(name), debugstr_w(value));
 
     if (!MSVCRT_CHECK_PMT(name != NULL)) return EINVAL;
     if (!MSVCRT_CHECK_PMT(value != NULL)) return EINVAL;
 
-    ret = SetEnvironmentVariableW(name, value[0] ? value : NULL) ? 0 : -1;
-
-    /* _putenv returns success on deletion of nonexistent variable, unlike [Rtl]SetEnvironmentVariable */
-    if ((ret == -1) && (GetLastError() == ERROR_ENVVAR_NOT_FOUND)) ret = 0;
+    if (!SetEnvironmentVariableW(name, value[0] ? value : NULL))
+    {
+        /* _putenv returns success on deletion of nonexistent variable */
+        if (GetLastError() != ERROR_ENVVAR_NOT_FOUND)
+        {
+            msvcrt_set_errno(GetLastError());
+            ret = *_errno();
+        }
+    }
 
     MSVCRT__environ = msvcrt_SnapshotOfEnvironmentA(MSVCRT__environ);
     MSVCRT__wenviron = msvcrt_SnapshotOfEnvironmentW(MSVCRT__wenviron);
-- 
GitLab

From 0d21e1cbcf705bb2cba3d59571bb8b730ba2feac Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Tue, 15 Feb 2022 12:09:25 -0800
Subject: [PATCH] server: Only require THREAD_SET_LIMITED_INFORMATION access to
 set thread description.

---
 dlls/kernel32/tests/thread.c | 2 --
 server/thread.c              | 4 +++-
 2 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
index 0274cb6e266..25e5a0dc1da 100644
--- a/dlls/kernel32/tests/thread.c
+++ b/dlls/kernel32/tests/thread.c
@@ -2538,13 +2538,11 @@ static void test_thread_description(void)
     thread = OpenThread(THREAD_SET_LIMITED_INFORMATION, FALSE, GetCurrentThreadId());
 
     hr = pSetThreadDescription(thread, desc);
-    todo_wine
     ok(hr == HRESULT_FROM_NT(STATUS_SUCCESS), "Failed to set thread description, hr %#lx.\n", hr);
 
     ptr = NULL;
     hr = pGetThreadDescription(GetCurrentThread(), &ptr);
     ok(hr == HRESULT_FROM_NT(STATUS_SUCCESS), "Failed to get thread description, hr %#lx.\n", hr);
-    todo_wine
     ok(!lstrcmpW(ptr, desc), "Unexpected description %s.\n", wine_dbgstr_w(ptr));
     LocalFree(ptr);
 
diff --git a/server/thread.c b/server/thread.c
index f49fbf40b78..c0fb0eef637 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -1534,8 +1534,10 @@ DECL_HANDLER(get_thread_times)
 DECL_HANDLER(set_thread_info)
 {
     struct thread *thread;
+    unsigned int access = (req->mask == SET_THREAD_INFO_DESCRIPTION) ? THREAD_SET_LIMITED_INFORMATION
+                                                                     : THREAD_SET_INFORMATION;
 
-    if ((thread = get_thread_from_handle( req->handle, THREAD_SET_INFORMATION )))
+    if ((thread = get_thread_from_handle( req->handle, access )))
     {
         set_thread_info( thread, req );
         release_object( thread );
-- 
GitLab

From f37c1d491d4da9f97a0634e0bb4944463d804d12 Mon Sep 17 00:00:00 2001
From: Etaash Mathamsetty <etaash.mathamsetty@gmail.com>
Date: Sun, 6 Nov 2022 19:37:33 -0500
Subject: [PATCH] ntoskrnl.exe: Implement ExInterlockedInsertTailList.

---
 dlls/ntoskrnl.exe/ntoskrnl.exe.spec |  2 +-
 dlls/ntoskrnl.exe/sync.c            | 28 ++++++++++++++++++++++++++++
 2 files changed, 29 insertions(+), 1 deletion(-)

diff --git a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
index 0a484829ca3..23770e54367 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
+++ b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
@@ -167,7 +167,7 @@
 @ stub ExInterlockedExtendZone
 @ stub ExInterlockedIncrementLong
 @ stub ExInterlockedInsertHeadList
-@ stub ExInterlockedInsertTailList
+@ stdcall ExInterlockedInsertTailList(ptr ptr ptr)
 @ stub ExInterlockedPopEntryList
 @ stub ExInterlockedPushEntryList
 @ stdcall ExInterlockedRemoveHeadList(ptr ptr)
diff --git a/dlls/ntoskrnl.exe/sync.c b/dlls/ntoskrnl.exe/sync.c
index d9b5726b920..c83372401da 100644
--- a/dlls/ntoskrnl.exe/sync.c
+++ b/dlls/ntoskrnl.exe/sync.c
@@ -778,6 +778,34 @@ LIST_ENTRY * WINAPI ExInterlockedRemoveHeadList( LIST_ENTRY *list, KSPIN_LOCK *l
     return ret;
 }
 
+/***********************************************************************
+ *           ExInterlockedInsertTailList   (NTOSKRNL.EXE.@)
+ */
+LIST_ENTRY * WINAPI ExInterlockedInsertTailList( LIST_ENTRY *head, LIST_ENTRY *entry, KSPIN_LOCK *lock )
+{
+    LIST_ENTRY *ret;
+    KIRQL irql;
+
+    TRACE( "(%p %p %p)\n", head, entry, lock );
+
+    if ( !head || !entry || !lock )
+        return NULL;
+
+    KeAcquireSpinLock( lock, &irql );
+
+    if ( !head->Blink )
+    {
+        KeReleaseSpinLock( lock, irql );
+        return NULL;
+    }
+
+    ret = head->Blink;
+    InsertTailList( head, entry );
+
+    KeReleaseSpinLock( lock, irql );
+
+    return ret;
+}
 
 /***********************************************************************
  *           InterlockedPopEntrySList   (NTOSKRNL.EXE.@)
-- 
GitLab

From 6f7fd462b5882bb47271d050366291b0b244deb7 Mon Sep 17 00:00:00 2001
From: Ivo Ivanov <logos128@gmail.com>
Date: Thu, 18 Aug 2022 15:23:29 +0300
Subject: [PATCH 1/3] ntdll: Cancel any pending callbacks on a timer re-set.

---
 dlls/ntdll/threadpool.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 99525f831e1..0d88ebd34a0 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -2963,6 +2963,9 @@ VOID WINAPI TpSetTimer( TP_TIMER *timer,
     ULONGLONG timestamp;
 
     TRACE( "%p %p %u %u\n", timer, timeout, period, window_length );
+    
+    /* If the timer has any pending callbacks, cancel them first. */
+    tp_object_cancel( this );
 
     enter_critical_section( &timerqueue.cs );
 
-- 
GitLab


From 4b98beb3c10fd7ba0b4f2a91630030d229079c59 Mon Sep 17 00:00:00 2001
From: Ivo Ivanov <logos128@gmail.com>
Date: Thu, 18 Aug 2022 15:48:08 +0300
Subject: [PATCH 2/3] ntoskrnl.exe: Prevent blocking if timer is reset in DPC.

Fixes NaturalPoint's TrackIR5 app hanging indefinitely on exit,
while waiting synchronously on an IRP to complete. The blocking
happens in the app's npusbio_x64 driver, while it tries to reset
a timer in its DPC.
Probably fixes other drivers/apps in such situations.
---
 dlls/ntoskrnl.exe/sync.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/dlls/ntoskrnl.exe/sync.c b/dlls/ntoskrnl.exe/sync.c
index d9b5726b920..0b101158eb6 100644
--- a/dlls/ntoskrnl.exe/sync.c
+++ b/dlls/ntoskrnl.exe/sync.c
@@ -493,10 +493,14 @@ BOOLEAN WINAPI KeSetTimerEx( KTIMER *timer, LARGE_INTEGER duetime, LONG period,
 
     EnterCriticalSection( &sync_cs );
 
-    if ((ret = timer->Header.Inserted))
-        KeCancelTimer(timer);
-
+    ret = timer->Header.Inserted;
     timer->Header.Inserted = TRUE;
+    timer->Header.SignalState = FALSE;
+    if (timer->Header.WaitListHead.Blink && !*((ULONG_PTR *)&timer->Header.WaitListHead.Flink))
+    {
+        CloseHandle(timer->Header.WaitListHead.Blink);
+        timer->Header.WaitListHead.Blink = NULL;
+    }
 
     if (!timer->TimerListEntry.Blink)
         timer->TimerListEntry.Blink = (void *)CreateThreadpoolTimer(ke_timer_complete_proc, timer, NULL);
-- 
GitLab

From d61cc801e7f4bcaefb23cb0c9a39788dc8ee669a Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Wed, 30 Nov 2022 19:06:36 -0700
Subject: [PATCH] services: Use standard C functions for memory allocation.

---
 programs/services/rpc.c      |  71 ++++++++++++------------
 programs/services/services.c | 101 +++++++++++++++++------------------
 programs/services/services.h |   1 -
 programs/services/utils.c    |  29 +++-------
 4 files changed, 92 insertions(+), 110 deletions(-)

diff --git a/programs/services/rpc.c b/programs/services/rpc.c
index 7e09abaab12..de918d33b1f 100644
--- a/programs/services/rpc.c
+++ b/programs/services/rpc.c
@@ -102,8 +102,8 @@ static void sc_notify_release(struct sc_notify_handle *notify)
     if (r == 0)
     {
         CloseHandle(notify->event);
-        HeapFree(GetProcessHeap(), 0, notify->params_list);
-        HeapFree(GetProcessHeap(), 0, notify);
+        free(notify->params_list);
+        free(notify);
     }
 }
 
@@ -197,22 +197,22 @@ static void free_service_strings(struct service_entry *old, struct service_entry
     QUERY_SERVICE_CONFIGW *new_cfg = &new->config;
 
     if (old_cfg->lpBinaryPathName != new_cfg->lpBinaryPathName)
-        HeapFree(GetProcessHeap(), 0, old_cfg->lpBinaryPathName);
+        free(old_cfg->lpBinaryPathName);
 
     if (old_cfg->lpLoadOrderGroup != new_cfg->lpLoadOrderGroup)
-        HeapFree(GetProcessHeap(), 0, old_cfg->lpLoadOrderGroup);
+        free(old_cfg->lpLoadOrderGroup);
 
     if (old_cfg->lpServiceStartName != new_cfg->lpServiceStartName)
-        HeapFree(GetProcessHeap(), 0, old_cfg->lpServiceStartName);
+        free(old_cfg->lpServiceStartName);
 
     if (old_cfg->lpDisplayName != new_cfg->lpDisplayName)
-        HeapFree(GetProcessHeap(), 0, old_cfg->lpDisplayName);
+        free(old_cfg->lpDisplayName);
 
     if (old->dependOnServices != new->dependOnServices)
-        HeapFree(GetProcessHeap(), 0, old->dependOnServices);
+        free(old->dependOnServices);
 
     if (old->dependOnGroups != new->dependOnGroups)
-        HeapFree(GetProcessHeap(), 0, old->dependOnGroups);
+        free(old->dependOnGroups);
 }
 
 /* Check if the given handle is of the required type and allows the requested access. */
@@ -281,7 +281,7 @@ DWORD __cdecl svcctl_OpenSCManagerW(
             return ERROR_INVALID_NAME;
     }
 
-    if (!(manager = HeapAlloc(GetProcessHeap(), 0, sizeof(*manager))))
+    if (!(manager = malloc(sizeof(*manager))))
         return ERROR_NOT_ENOUGH_SERVER_MEMORY;
 
     manager->hdr.type = SC_HTYPE_MANAGER;
@@ -304,7 +304,7 @@ static void SC_RPC_HANDLE_destroy(SC_RPC_HANDLE handle)
         case SC_HTYPE_MANAGER:
         {
             struct sc_manager_handle *manager = (struct sc_manager_handle *)hdr;
-            HeapFree(GetProcessHeap(), 0, manager);
+            free(manager);
             break;
         }
         case SC_HTYPE_SERVICE:
@@ -319,7 +319,7 @@ static void SC_RPC_HANDLE_destroy(SC_RPC_HANDLE handle)
             }
             service_unlock(service->service_entry);
             release_service(service->service_entry);
-            HeapFree(GetProcessHeap(), 0, service);
+            free(service);
             break;
         }
         default:
@@ -418,7 +418,7 @@ static DWORD create_handle_for_service(struct service_entry *entry, DWORD dwDesi
 {
     struct sc_service_handle *service;
 
-    if (!(service = HeapAlloc(GetProcessHeap(), 0, sizeof(*service))))
+    if (!(service = malloc(sizeof(*service))))
     {
         release_service(entry);
         return ERROR_NOT_ENOUGH_SERVER_MEMORY;
@@ -494,7 +494,7 @@ static DWORD parse_dependencies(const WCHAR *dependencies, struct service_entry
     if (!len_services) entry->dependOnServices = NULL;
     else
     {
-        services = HeapAlloc(GetProcessHeap(), 0, (len_services + 1) * sizeof(WCHAR));
+        services = malloc((len_services + 1) * sizeof(WCHAR));
         if (!services)
             return ERROR_OUTOFMEMORY;
 
@@ -516,10 +516,10 @@ static DWORD parse_dependencies(const WCHAR *dependencies, struct service_entry
     if (!len_groups) entry->dependOnGroups = NULL;
     else
     {
-        groups = HeapAlloc(GetProcessHeap(), 0, (len_groups + 1) * sizeof(WCHAR));
+        groups = malloc((len_groups + 1) * sizeof(WCHAR));
         if (!groups)
         {
-            HeapFree(GetProcessHeap(), 0, services);
+            free(services);
             return ERROR_OUTOFMEMORY;
         }
         s = groups;
@@ -591,10 +591,10 @@ static DWORD create_serviceW(
     entry->config.dwServiceType = entry->status.dwServiceType = dwServiceType;
     entry->config.dwStartType = dwStartType;
     entry->config.dwErrorControl = dwErrorControl;
-    entry->config.lpBinaryPathName = strdupW(lpBinaryPathName);
-    entry->config.lpLoadOrderGroup = strdupW(lpLoadOrderGroup);
-    entry->config.lpServiceStartName = strdupW(lpServiceStartName);
-    entry->config.lpDisplayName = strdupW(lpDisplayName);
+    entry->config.lpBinaryPathName = wcsdup(lpBinaryPathName);
+    entry->config.lpLoadOrderGroup = wcsdup(lpLoadOrderGroup);
+    entry->config.lpServiceStartName = wcsdup(lpServiceStartName);
+    entry->config.lpDisplayName = wcsdup(lpDisplayName);
 
     if (lpdwTagId)      /* TODO: In most situations a non-NULL TagId will generate an ERROR_INVALID_PARAMETER. */
         entry->config.dwTagId = *lpdwTagId;
@@ -702,12 +702,12 @@ DWORD __cdecl svcctl_QueryServiceConfigW(
     config->dwServiceType = service->service_entry->config.dwServiceType;
     config->dwStartType = service->service_entry->config.dwStartType;
     config->dwErrorControl = service->service_entry->config.dwErrorControl;
-    config->lpBinaryPathName = strdupW(service->service_entry->config.lpBinaryPathName);
-    config->lpLoadOrderGroup = strdupW(service->service_entry->config.lpLoadOrderGroup);
+    config->lpBinaryPathName = wcsdup(service->service_entry->config.lpBinaryPathName);
+    config->lpLoadOrderGroup = wcsdup(service->service_entry->config.lpLoadOrderGroup);
     config->dwTagId = service->service_entry->config.dwTagId;
     config->lpDependencies = NULL; /* TODO */
-    config->lpServiceStartName = strdupW(service->service_entry->config.lpServiceStartName);
-    config->lpDisplayName = strdupW(service->service_entry->config.lpDisplayName);
+    config->lpServiceStartName = wcsdup(service->service_entry->config.lpServiceStartName);
+    config->lpDisplayName = wcsdup(service->service_entry->config.lpDisplayName);
     service_unlock(service->service_entry);
 
     return ERROR_SUCCESS;
@@ -802,16 +802,16 @@ DWORD __cdecl svcctl_ChangeServiceConfigW(
 
     /* configuration OK. The strings needs to be duplicated */
     if (lpBinaryPathName != NULL)
-        new_entry.config.lpBinaryPathName = strdupW(lpBinaryPathName);
+        new_entry.config.lpBinaryPathName = wcsdup(lpBinaryPathName);
 
     if (lpLoadOrderGroup != NULL)
-        new_entry.config.lpLoadOrderGroup = strdupW(lpLoadOrderGroup);
+        new_entry.config.lpLoadOrderGroup = wcsdup(lpLoadOrderGroup);
 
     if (lpServiceStartName != NULL)
-        new_entry.config.lpServiceStartName = strdupW(lpServiceStartName);
+        new_entry.config.lpServiceStartName = wcsdup(lpServiceStartName);
 
     if (lpDisplayName != NULL)
-        new_entry.config.lpDisplayName = strdupW(lpDisplayName);
+        new_entry.config.lpDisplayName = wcsdup(lpDisplayName);
 
     /* try to save to Registry, commit or rollback depending on success */
     err = save_service_config(&new_entry);
@@ -841,8 +841,7 @@ static void fill_notify(struct sc_notify_handle *notify, struct service_entry *s
     SC_RPC_NOTIFY_PARAMS_LIST *list;
     SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2 *cparams;
 
-    list = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(SC_RPC_NOTIFY_PARAMS_LIST) + sizeof(SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2));
+    list = calloc(1, sizeof(SC_RPC_NOTIFY_PARAMS_LIST) + sizeof(SERVICE_NOTIFY_STATUS_CHANGE_PARAMS_2));
     if (!list)
         return;
 
@@ -937,13 +936,13 @@ DWORD __cdecl svcctl_ChangeServiceConfig2W( SC_RPC_HANDLE hService, SC_RPC_CONFI
 
             if (config.descr->lpDescription[0])
             {
-                if (!(descr = strdupW( config.descr->lpDescription )))
+                if (!(descr = wcsdup( config.descr->lpDescription )))
                     return ERROR_NOT_ENOUGH_MEMORY;
             }
 
             WINE_TRACE( "changing service %p descr to %s\n", service, wine_dbgstr_w(descr) );
             service_lock( service->service_entry );
-            HeapFree( GetProcessHeap(), 0, service->service_entry->description );
+            free( service->service_entry->description );
             service->service_entry->description = descr;
             save_service_config( service->service_entry );
             service_unlock( service->service_entry );
@@ -1197,7 +1196,7 @@ BOOL process_send_control(struct process_entry *process, BOOL shared_process, co
     /* calculate how much space we need to send the startup info */
     len = (lstrlenW(name) + 1) * sizeof(WCHAR) + data_size;
 
-    ssi = HeapAlloc(GetProcessHeap(),0,FIELD_OFFSET(service_start_info, data[len]));
+    ssi = malloc(FIELD_OFFSET(service_start_info, data[len]));
     ssi->magic = SERVICE_PROTOCOL_MAGIC;
     ssi->control = control;
     ssi->total_size = FIELD_OFFSET(service_start_info, data[len]);
@@ -1206,7 +1205,7 @@ BOOL process_send_control(struct process_entry *process, BOOL shared_process, co
     if (data_size) memcpy(&ssi->data[ssi->name_size * sizeof(WCHAR)], data, data_size);
 
     r = process_send_command(process, ssi, ssi->total_size, result);
-    HeapFree( GetProcessHeap(), 0, ssi );
+    free(ssi);
     return r;
 }
 
@@ -1705,7 +1704,7 @@ DWORD __cdecl svcctl_NotifyServiceStatusChange(
         return ERROR_CALL_NOT_IMPLEMENTED;
     }
 
-    notify = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*notify));
+    notify = calloc(1, sizeof(*notify));
     if (!notify)
         return ERROR_NOT_ENOUGH_SERVER_MEMORY;
 
@@ -2160,10 +2159,10 @@ void __RPC_USER SC_NOTIFY_RPC_HANDLE_rundown(SC_NOTIFY_RPC_HANDLE handle)
 
 void  __RPC_FAR * __RPC_USER MIDL_user_allocate(SIZE_T len)
 {
-    return HeapAlloc(GetProcessHeap(), 0, len);
+    return malloc(len);
 }
 
 void __RPC_USER MIDL_user_free(void __RPC_FAR * ptr)
 {
-    HeapFree(GetProcessHeap(), 0, ptr);
+    free(ptr);
 }
diff --git a/programs/services/services.c b/programs/services/services.c
index 2edc02d300c..6bda0a4008b 100644
--- a/programs/services/services.c
+++ b/programs/services/services.c
@@ -31,7 +31,6 @@
 #include <setupapi.h>
 
 #include "wine/debug.h"
-#include "wine/heap.h"
 #include "svcctl.h"
 
 #include "services.h"
@@ -78,7 +77,7 @@ static DWORD process_create(const WCHAR *name, struct process_entry **entry)
 {
     DWORD err;
 
-    *entry = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(**entry));
+    *entry = calloc(1, sizeof(**entry));
     if (!*entry)
         return ERROR_NOT_ENOUGH_SERVER_MEMORY;
     (*entry)->ref_count = 1;
@@ -101,7 +100,7 @@ error:
         CloseHandle((*entry)->control_mutex);
     if ((*entry)->overlapped_event)
         CloseHandle((*entry)->overlapped_event);
-    HeapFree(GetProcessHeap(), 0, *entry);
+    free(*entry);
     return err;
 }
 
@@ -111,26 +110,26 @@ static void free_process_entry(struct process_entry *entry)
     CloseHandle(entry->control_mutex);
     CloseHandle(entry->control_pipe);
     CloseHandle(entry->overlapped_event);
-    HeapFree(GetProcessHeap(), 0, entry);
+    free(entry);
 }
 
 DWORD service_create(LPCWSTR name, struct service_entry **entry)
 {
-    *entry = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(**entry));
+    *entry = calloc(1, sizeof(**entry));
     if (!*entry)
         return ERROR_NOT_ENOUGH_SERVER_MEMORY;
-    (*entry)->name = strdupW(name);
+    (*entry)->name = wcsdup(name);
     list_init(&(*entry)->handles);
     if (!(*entry)->name)
     {
-        HeapFree(GetProcessHeap(), 0, *entry);
+        free(*entry);
         return ERROR_NOT_ENOUGH_SERVER_MEMORY;
     }
     (*entry)->status_changed_event = CreateEventW(NULL, TRUE, FALSE, NULL);
     if (!(*entry)->status_changed_event)
     {
-        HeapFree(GetProcessHeap(), 0, (*entry)->name);
-        HeapFree(GetProcessHeap(), 0, *entry);
+        free((*entry)->name);
+        free(*entry);
         return GetLastError();
     }
     (*entry)->ref_count = 1;
@@ -145,17 +144,17 @@ void free_service_entry(struct service_entry *entry)
 {
     assert(list_empty(&entry->handles));
     CloseHandle(entry->status_changed_event);
-    HeapFree(GetProcessHeap(), 0, entry->name);
-    HeapFree(GetProcessHeap(), 0, entry->config.lpBinaryPathName);
-    HeapFree(GetProcessHeap(), 0, entry->config.lpDependencies);
-    HeapFree(GetProcessHeap(), 0, entry->config.lpLoadOrderGroup);
-    HeapFree(GetProcessHeap(), 0, entry->config.lpServiceStartName);
-    HeapFree(GetProcessHeap(), 0, entry->config.lpDisplayName);
-    HeapFree(GetProcessHeap(), 0, entry->description);
-    HeapFree(GetProcessHeap(), 0, entry->dependOnServices);
-    HeapFree(GetProcessHeap(), 0, entry->dependOnGroups);
+    free(entry->name);
+    free(entry->config.lpBinaryPathName);
+    free(entry->config.lpDependencies);
+    free(entry->config.lpLoadOrderGroup);
+    free(entry->config.lpServiceStartName);
+    free(entry->config.lpDisplayName);
+    free(entry->description);
+    free(entry->dependOnServices);
+    free(entry->dependOnGroups);
     if (entry->process) release_process(entry->process);
-    HeapFree(GetProcessHeap(), 0, entry);
+    free(entry);
 }
 
 static DWORD load_service_config(HKEY hKey, struct service_entry *entry)
@@ -349,8 +348,8 @@ static void CALLBACK delayed_autostart_cancel_callback(void *object, void *userd
     struct delayed_autostart_params *params = object;
     while(params->count--)
         release_service(params->services[params->count]);
-    heap_free(params->services);
-    heap_free(params);
+    free(params->services);
+    free(params);
 }
 
 static void CALLBACK delayed_autostart_callback(TP_CALLBACK_INSTANCE *instance, void *context,
@@ -379,8 +378,8 @@ static void CALLBACK delayed_autostart_callback(TP_CALLBACK_INSTANCE *instance,
 
     scmdatabase_unlock_startup(active_database);
 
-    heap_free(params->services);
-    heap_free(params);
+    free(params->services);
+    free(params);
     CloseThreadpoolTimer(timer);
 }
 
@@ -398,7 +397,7 @@ static BOOL schedule_delayed_autostart(struct service_entry **services, unsigned
         return FALSE;
     }
 
-    if (!(params = heap_alloc(sizeof(*params)))) return FALSE;
+    if (!(params = malloc(sizeof(*params)))) return FALSE;
     params->count = count;
     params->services = services;
 
@@ -414,7 +413,7 @@ static BOOL schedule_delayed_autostart(struct service_entry **services, unsigned
     if (!(timer = CreateThreadpoolTimer(delayed_autostart_callback, params, &environment)))
     {
         ERR("CreateThreadpoolWait failed: %lu\n", GetLastError());
-        heap_free(params);
+        free(params);
         return FALSE;
     }
 
@@ -451,7 +450,7 @@ static void scmdatabase_autostart_services(struct scmdatabase *db)
     struct service_entry *service;
     HDEVINFO set;
 
-    services_list = HeapAlloc(GetProcessHeap(), 0, size * sizeof(services_list[0]));
+    services_list = malloc(size * sizeof(services_list[0]));
     if (!services_list)
         return;
 
@@ -471,7 +470,7 @@ static void scmdatabase_autostart_services(struct scmdatabase *db)
             {
                 struct service_entry **slist_new;
                 size *= 2;
-                slist_new = HeapReAlloc(GetProcessHeap(), 0, services_list, size * sizeof(services_list[0]));
+                slist_new = realloc(services_list, size * sizeof(services_list[0]));
                 if (!slist_new)
                     break;
                 services_list = slist_new;
@@ -505,7 +504,7 @@ static void scmdatabase_autostart_services(struct scmdatabase *db)
     scmdatabase_unlock_startup(db);
 
     if (!delayed_cnt || !schedule_delayed_autostart(services_list, delayed_cnt))
-        heap_free(services_list);
+        free(services_list);
     SetupDiDestroyDeviceInfoList(set);
 }
 
@@ -583,7 +582,7 @@ BOOL validate_service_config(struct service_entry *entry)
     }
 
     if (entry->config.lpServiceStartName == NULL)
-        entry->config.lpServiceStartName = strdupW(SZ_LOCAL_SYSTEM);
+        entry->config.lpServiceStartName = wcsdup(SZ_LOCAL_SYSTEM);
 
     return TRUE;
 }
@@ -659,7 +658,7 @@ static DWORD scmdatabase_create(struct scmdatabase **db)
 {
     DWORD err;
 
-    *db = HeapAlloc(GetProcessHeap(), 0, sizeof(**db));
+    *db = malloc(sizeof(**db));
     if (!*db)
         return ERROR_NOT_ENOUGH_SERVER_MEMORY;
 
@@ -674,7 +673,7 @@ static DWORD scmdatabase_create(struct scmdatabase **db)
                           REG_OPTION_NON_VOLATILE, MAXIMUM_ALLOWED, NULL,
                           &(*db)->root_key, NULL);
     if (err != ERROR_SUCCESS)
-        HeapFree(GetProcessHeap(), 0, *db);
+        free(*db);
 
     return err;
 }
@@ -684,7 +683,7 @@ static void scmdatabase_destroy(struct scmdatabase *db)
     RegCloseKey(db->root_key);
     db->cs.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&db->cs);
-    HeapFree(GetProcessHeap(), 0, db);
+    free(db);
 }
 
 static DWORD scmdatabase_load_services(struct scmdatabase *db)
@@ -818,7 +817,7 @@ static DWORD get_service_binary_path(const struct service_entry *service_entry,
 {
     DWORD size = ExpandEnvironmentStringsW(service_entry->config.lpBinaryPathName, NULL, 0);
 
-    *path = HeapAlloc(GetProcessHeap(), 0, size*sizeof(WCHAR));
+    *path = malloc(size * sizeof(WCHAR));
     if (!*path)
         return ERROR_NOT_ENOUGH_SERVER_MEMORY;
 
@@ -838,16 +837,16 @@ static DWORD get_service_binary_path(const struct service_entry *service_entry,
 
         GetSystemWow64DirectoryW( system_dir, MAX_PATH );
 
-        redirected = HeapAlloc( GetProcessHeap(), 0, (lstrlenW( *path ) + lstrlenW( system_dir ))*sizeof(WCHAR));
+        redirected = malloc( (wcslen( *path ) + wcslen( system_dir )) * sizeof(WCHAR) );
         if (!redirected)
         {
-            HeapFree( GetProcessHeap(), 0, *path );
+            free( *path );
             return ERROR_NOT_ENOUGH_SERVER_MEMORY;
         }
 
         lstrcpyW( redirected, system_dir );
         lstrcatW( redirected, &(*path)[len] );
-        HeapFree( GetProcessHeap(), 0, *path );
+        free( *path );
         *path = redirected;
         TRACE("redirected to %s\n", debugstr_w(redirected));
     }
@@ -869,8 +868,8 @@ static DWORD get_winedevice_binary_path(struct service_entry *service_entry, WCH
         *is_wow64 = service_entry->is_wow64;
 
     GetSystemDirectoryW(system_dir, MAX_PATH);
-    HeapFree(GetProcessHeap(), 0, *path);
-    if (!(*path = HeapAlloc(GetProcessHeap(), 0, lstrlenW(system_dir) * sizeof(WCHAR) + sizeof(winedeviceW))))
+    free(*path);
+    if (!(*path = malloc(wcslen(system_dir) * sizeof(WCHAR) + sizeof(winedeviceW))))
        return ERROR_NOT_ENOUGH_SERVER_MEMORY;
 
     lstrcpyW(*path, system_dir);
@@ -928,14 +927,14 @@ static DWORD add_winedevice_service(const struct service_entry *service, WCHAR *
     (*entry)->config.dwStartType        = SERVICE_DEMAND_START;
     (*entry)->status.dwServiceType      = (*entry)->config.dwServiceType;
 
-    if (!((*entry)->config.lpBinaryPathName = strdupW(path)))
+    if (!((*entry)->config.lpBinaryPathName = wcsdup(path)))
         goto error;
-    if (!((*entry)->config.lpServiceStartName = strdupW(SZ_LOCAL_SYSTEM)))
+    if (!((*entry)->config.lpServiceStartName = wcsdup(SZ_LOCAL_SYSTEM)))
         goto error;
-    if (!((*entry)->config.lpDisplayName = strdupW(name)))
+    if (!((*entry)->config.lpDisplayName = wcsdup(name)))
         goto error;
     if (service->config.lpLoadOrderGroup &&
-        !((*entry)->config.lpLoadOrderGroup = strdupW(service->config.lpLoadOrderGroup)))
+        !((*entry)->config.lpLoadOrderGroup = wcsdup(service->config.lpLoadOrderGroup)))
         goto error;
 
     (*entry)->db = db;
@@ -992,29 +991,29 @@ static DWORD service_start_process(struct service_entry *service_entry, struct p
         if ((err = get_winedevice_binary_path(service_entry, &path, &is_wow64)))
         {
             service_unlock(service_entry);
-            HeapFree(GetProcessHeap(), 0, path);
+            free(path);
             return err;
         }
 
         if ((process = get_winedevice_process(service_entry, path, is_wow64)))
         {
-            HeapFree(GetProcessHeap(), 0, path);
+            free(path);
             goto found;
         }
 
         err = add_winedevice_service(service_entry, path, is_wow64, &winedevice_entry);
-        HeapFree(GetProcessHeap(), 0, path);
+        free(path);
         if (err != ERROR_SUCCESS)
         {
             service_unlock(service_entry);
             return err;
         }
 
-        group = strdupW(winedevice_entry->config.lpLoadOrderGroup);
+        group = wcsdup(winedevice_entry->config.lpLoadOrderGroup);
         service_unlock(service_entry);
 
         err = service_start(winedevice_entry, group != NULL, (const WCHAR **)&group);
-        HeapFree(GetProcessHeap(), 0, group);
+        free(group);
         if (err != ERROR_SUCCESS)
         {
             release_service(winedevice_entry);
@@ -1057,7 +1056,7 @@ found:
         WINE_ERR("failed to create process object for %s, error = %lu\n",
                  wine_dbgstr_w(service_entry->name), err);
         service_unlock(service_entry);
-        HeapFree(GetProcessHeap(), 0, path);
+        free(path);
         return err;
     }
 
@@ -1095,7 +1094,7 @@ found:
     service_unlock(service_entry);
 
     r = CreateProcessW(NULL, path, NULL, NULL, FALSE, CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS, environment, NULL, &si, &pi);
-    HeapFree(GetProcessHeap(), 0, path);
+    free(path);
     if (!r)
     {
         err = GetLastError();
@@ -1169,7 +1168,7 @@ static DWORD process_send_start_message(struct process_entry *process, BOOL shar
         len += lstrlenW(argv[i])+1;
     len = (len + 1) * sizeof(WCHAR);
 
-    if (!(str = HeapAlloc(GetProcessHeap(), 0, len)))
+    if (!(str = malloc(len)))
         return ERROR_NOT_ENOUGH_SERVER_MEMORY;
 
     p = str;
@@ -1186,7 +1185,7 @@ static DWORD process_send_start_message(struct process_entry *process, BOOL shar
                               SERVICE_CONTROL_START, (const BYTE *)str, len, &result))
         result = ERROR_SERVICE_REQUEST_TIMEOUT;
 
-    HeapFree(GetProcessHeap(), 0, str);
+    free(str);
     return result;
 }
 
diff --git a/programs/services/services.h b/programs/services/services.h
index 0d400e59183..908a36e6514 100644
--- a/programs/services/services.h
+++ b/programs/services/services.h
@@ -110,7 +110,6 @@ DWORD RPC_Init(void);
 void RPC_Stop(void);
 
 /* from utils.c */
-LPWSTR strdupW(LPCWSTR str);
 
 BOOL check_multisz(LPCWSTR lpMultiSz, DWORD cbSize);
 
diff --git a/programs/services/utils.c b/programs/services/utils.c
index 357217b4926..69bd26df814 100644
--- a/programs/services/utils.c
+++ b/programs/services/utils.c
@@ -29,21 +29,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(service);
 
-LPWSTR strdupW(LPCWSTR str)
-{
-    int len;
-    WCHAR *buf;
-
-    if (str == NULL)
-        return NULL;
-    len = lstrlenW(str);
-    buf = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*(len+1));
-    if (buf == NULL)
-        return NULL;
-    lstrcpyW(buf, str);
-    return buf;
-}
-
 BOOL check_multisz(LPCWSTR lpMultiSz, DWORD cbSize)
 {
     if (cbSize == 0 || (cbSize == sizeof(WCHAR) && lpMultiSz[0] == 0))
@@ -73,7 +58,7 @@ DWORD load_reg_string(HKEY hKey, LPCWSTR szValue, BOOL bExpand, LPWSTR *output)
         err = ERROR_INVALID_DATATYPE;
         goto failed;
     }
-    buf = HeapAlloc(GetProcessHeap(), 0, size + sizeof(WCHAR));
+    buf = malloc(size + sizeof(WCHAR));
     if ((err = RegQueryValueExW(hKey, szValue, 0, &type, (LPBYTE)buf, &size)) != 0)
         goto failed;
     buf[size/sizeof(WCHAR)] = 0;
@@ -86,9 +71,9 @@ DWORD load_reg_string(HKEY hKey, LPCWSTR szValue, BOOL bExpand, LPWSTR *output)
             err = GetLastError();
             goto failed;
         }
-        str = HeapAlloc(GetProcessHeap(), 0, size * sizeof(WCHAR));
+        str = malloc(size * sizeof(WCHAR));
         ExpandEnvironmentStringsW(buf, str, size);
-        HeapFree(GetProcessHeap(), 0, buf);
+        free(buf);
         *output = str;
     }
     else
@@ -97,7 +82,7 @@ DWORD load_reg_string(HKEY hKey, LPCWSTR szValue, BOOL bExpand, LPWSTR *output)
 
 failed:
     WINE_ERR("Error %ld while reading value %s\n", err, wine_dbgstr_w(szValue));
-    HeapFree(GetProcessHeap(), 0, buf);
+    free(buf);
     return err;
 }
 
@@ -112,7 +97,7 @@ DWORD load_reg_multisz(HKEY hKey, LPCWSTR szValue, BOOL bAllowSingle, LPWSTR *ou
     {
         if (err == ERROR_FILE_NOT_FOUND)
         {
-            *output = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(WCHAR));
+            *output = calloc(1, sizeof(WCHAR));
             return ERROR_SUCCESS;
         }
         goto failed;
@@ -122,7 +107,7 @@ DWORD load_reg_multisz(HKEY hKey, LPCWSTR szValue, BOOL bAllowSingle, LPWSTR *ou
         err = ERROR_INVALID_DATATYPE;
         goto failed;
     }
-    buf = HeapAlloc(GetProcessHeap(), 0, size + 2*sizeof(WCHAR));
+    buf = malloc(size + 2 * sizeof(WCHAR));
     if ((err = RegQueryValueExW(hKey, szValue, 0, &type, (LPBYTE)buf, &size)) != 0)
         goto failed;
     buf[size/sizeof(WCHAR)] = 0;
@@ -132,7 +117,7 @@ DWORD load_reg_multisz(HKEY hKey, LPCWSTR szValue, BOOL bAllowSingle, LPWSTR *ou
 
 failed:
     WINE_ERR("Error %ld while reading value %s\n", err, wine_dbgstr_w(szValue));
-    HeapFree(GetProcessHeap(), 0, buf);
+    free(buf);
     return err;
 }
 
-- 
GitLab

From dddccb9bce15935f5905f9adeeba86b92d7bb557 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Wed, 30 Nov 2022 23:34:58 -0700
Subject: [PATCH] server: Fix buffer overrun in map_view handler.

Because of padding at the end of the struct, sizeof(*view) is greater
than offsetof(struct memory_view, name[0]). Change the allocation to
overallocate slightly instead of underallocating slightly.
---
 server/mapping.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/mapping.c b/server/mapping.c
index 8d4332d240f..ed81a718bbe 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -1212,7 +1212,7 @@ DECL_HANDLER(map_view)
     if (!req->mapping)  /* image mapping for a .so dll */
     {
         if (get_req_data_size() > sizeof(view->image)) namelen = get_req_data_size() - sizeof(view->image);
-        if (!(view = mem_alloc( offsetof( struct memory_view, name[namelen] )))) return;
+        if (!(view = mem_alloc( sizeof(struct memory_view) + namelen * sizeof(WCHAR) ))) return;
         memset( view, 0, sizeof(*view) );
         view->base    = req->base;
         view->size    = req->size;
-- 
GitLab

From e5c6f915bbd7290641ea43fb41429317bc7e7a80 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Wed, 30 Nov 2022 12:28:10 +0800
Subject: [PATCH] winex11.drv: Release window data before calling
 sync_window_cursor().

This prevents a deadlock between the window data lock and the ntdll loader lock because
sync_window_cursor() eventually may grab the ntdll loader lock. So if another thread already
grabbed the ntdll loader lock and wants to enter the same window data critical section, it will
deadlock.

Fix Youropa (SteamID: 640120) OpenGL launch option launching to a black screen.
---
 dlls/winex11.drv/mouse.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index ebc8be643af..d1ade2eda68 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -644,6 +644,7 @@ static void map_event_coords( HWND hwnd, Window window, Window event_root, int x
 static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPUT *input )
 {
     struct x11drv_win_data *data;
+    Window win = 0;
 
     input->type = INPUT_MOUSE;
 
@@ -665,13 +666,14 @@ static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPU
     }
 
     if (!(data = get_win_data( hwnd ))) return;
+    win = data->whole_window;
+    release_win_data( data );
     if (InterlockedExchangePointer( (void **)&cursor_window, hwnd ) != hwnd ||
         input->u.mi.time - last_cursor_change > 100)
     {
-        sync_window_cursor( data->whole_window );
+        sync_window_cursor( win );
         last_cursor_change = input->u.mi.time;
     }
-    release_win_data( data );
 
     if (hwnd != NtUserGetDesktopWindow())
     {
-- 
GitLab

From 996c115217f18654747cd1c4baeda54d9342c808 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 2 Dec 2022 08:16:30 +0100
Subject: [PATCH] msvcrt: Use operator_delete to free _Condition_variable queue
 nodes.

---
 dlls/msvcrt/concurrency.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/msvcrt/concurrency.c b/dlls/msvcrt/concurrency.c
index f7f7adb86ed..c5db2868d58 100644
--- a/dlls/msvcrt/concurrency.c
+++ b/dlls/msvcrt/concurrency.c
@@ -2656,7 +2656,7 @@ void __thiscall _Condition_variable_dtor(_Condition_variable *this)
         cv_queue *next = this->queue->next;
         if(!this->queue->expired)
             ERR("there's an active wait\n");
-        HeapFree(GetProcessHeap(), 0, this->queue);
+        operator_delete(this->queue);
         this->queue = next;
     }
     critical_section_dtor(&this->lock);
@@ -2753,7 +2753,7 @@ void __thiscall _Condition_variable_notify_one(_Condition_variable *this)
             RtlWakeAddressSingle(&node->next);
             return;
         } else {
-            HeapFree(GetProcessHeap(), 0, node);
+            operator_delete(node);
         }
     }
 }
@@ -2782,7 +2782,7 @@ void __thiscall _Condition_variable_notify_all(_Condition_variable *this)
         if(!InterlockedExchange(&ptr->expired, TRUE))
             RtlWakeAddressSingle(&ptr->next);
         else
-            HeapFree(GetProcessHeap(), 0, ptr);
+            operator_delete(ptr);
         ptr = next;
     }
 }
-- 
GitLab

From 3bfc4493cb886d767e48b2677b07fef409a2db11 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Wed, 30 Nov 2022 07:53:59 -0700
Subject: [PATCH] rpcrt4: Use standard C functions for memory allocation.

---
 dlls/rpcrt4/cproxy.c            |   6 +-
 dlls/rpcrt4/cstub.c             |  17 ++-
 dlls/rpcrt4/ndr_contexthandle.c |   8 +-
 dlls/rpcrt4/ndr_es.c            |  13 +-
 dlls/rpcrt4/ndr_fullpointer.c   |  47 ++++----
 dlls/rpcrt4/ndr_ole.c           |   4 +-
 dlls/rpcrt4/ndr_stubless.c      |  15 ++-
 dlls/rpcrt4/ndr_typelib.c       |  67 ++++++-----
 dlls/rpcrt4/rpc_assoc.c         |  31 ++---
 dlls/rpcrt4/rpc_binding.c       | 202 ++++++++++++++++----------------
 dlls/rpcrt4/rpc_binding.h       |   4 -
 dlls/rpcrt4/rpc_epmap.c         |  20 ++--
 dlls/rpcrt4/rpc_message.c       |  79 ++++++-------
 dlls/rpcrt4/rpc_message.h       |   1 -
 dlls/rpcrt4/rpc_server.c        | 102 ++++++++--------
 dlls/rpcrt4/rpc_transport.c     | 195 +++++++++++++++---------------
 dlls/rpcrt4/rpcrt4_main.c       |  28 ++---
 17 files changed, 407 insertions(+), 432 deletions(-)

diff --git a/dlls/rpcrt4/cproxy.c b/dlls/rpcrt4/cproxy.c
index 426b1425d3a..b2c86d54422 100644
--- a/dlls/rpcrt4/cproxy.c
+++ b/dlls/rpcrt4/cproxy.c
@@ -329,7 +329,7 @@ HRESULT StdProxy_Construct(REFIID riid,
     return RPC_E_UNEXPECTED;
   }
 
-  This = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(StdProxyImpl));
+  This = calloc(1, sizeof(StdProxyImpl));
   if (!This) return E_OUTOFMEMORY;
 
   if (!pUnkOuter) pUnkOuter = (IUnknown *)This;
@@ -351,7 +351,7 @@ HRESULT StdProxy_Construct(REFIID riid,
                                 &This->base_proxy, (void **)&This->base_object );
       if (FAILED(r))
       {
-          HeapFree( GetProcessHeap(), 0, This );
+          free( This );
           return r;
       }
   }
@@ -411,7 +411,7 @@ static ULONG WINAPI StdProxy_Release(LPRPCPROXYBUFFER iface)
     if (This->base_proxy) IRpcProxyBuffer_Release( This->base_proxy );
 
     IPSFactoryBuffer_Release(This->pPSFactory);
-    HeapFree(GetProcessHeap(),0,This);
+    free(This);
   }
 
   return refs;
diff --git a/dlls/rpcrt4/cstub.c b/dlls/rpcrt4/cstub.c
index a6ec4caaadf..47d5e301c0f 100644
--- a/dlls/rpcrt4/cstub.c
+++ b/dlls/rpcrt4/cstub.c
@@ -75,7 +75,7 @@ HRESULT CStdStubBuffer_Construct(REFIID riid,
   if(FAILED(r))
     return r;
 
-  This = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(CStdStubBuffer));
+  This = calloc(1, sizeof(CStdStubBuffer));
   if (!This) {
     IUnknown_Release(pvServer);
     return E_OUTOFMEMORY;
@@ -296,8 +296,7 @@ IUnknownVtbl *get_delegating_vtbl(DWORD num_methods)
 
     if(!current_vtbl || num_methods > current_vtbl->size)
     {
-        ref_counted_vtbl *table = HeapAlloc(GetProcessHeap(), 0,
-                                            FIELD_OFFSET(ref_counted_vtbl, vtbl) + num_methods * sizeof(void*));
+        ref_counted_vtbl *table = malloc(FIELD_OFFSET(ref_counted_vtbl, vtbl) + num_methods * sizeof(void *));
         if (!table)
         {
             LeaveCriticalSection(&delegating_vtbl_section);
@@ -311,7 +310,7 @@ IUnknownVtbl *get_delegating_vtbl(DWORD num_methods)
         if (current_vtbl && current_vtbl->ref == 0)
         {
             TRACE("freeing old table\n");
-            HeapFree(GetProcessHeap(), 0, current_vtbl);
+            free(current_vtbl);
         }
         current_vtbl = table;
     }
@@ -332,7 +331,7 @@ void release_delegating_vtbl(IUnknownVtbl *vtbl)
     if(table->ref == 0 && table != current_vtbl)
     {
         TRACE("... and we're not current so free'ing\n");
-        HeapFree(GetProcessHeap(), 0, table);
+        free(table);
     }
     LeaveCriticalSection(&delegating_vtbl_section);
 }
@@ -362,7 +361,7 @@ HRESULT CStdStubBuffer_Delegating_Construct(REFIID riid,
     r = IUnknown_QueryInterface(pUnkServer, riid, (void**)&pvServer);
     if(FAILED(r)) return r;
 
-    This = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*This));
+    This = calloc(1, sizeof(*This));
     if (!This)
     {
         IUnknown_Release(pvServer);
@@ -374,7 +373,7 @@ HRESULT CStdStubBuffer_Delegating_Construct(REFIID riid,
     if(FAILED(r))
     {
         release_delegating_vtbl(This->base_obj);
-        HeapFree(GetProcessHeap(), 0, This);
+        free(This);
         IUnknown_Release(pvServer);
         return r;
     }
@@ -430,7 +429,7 @@ ULONG WINAPI NdrCStdStubBuffer_Release(LPRPCSTUBBUFFER iface,
     IRpcStubBuffer_Disconnect(iface);
 
     IPSFactoryBuffer_Release(pPSF);
-    HeapFree(GetProcessHeap(),0,This);
+    free(This);
   }
   return refs;
 }
@@ -454,7 +453,7 @@ ULONG WINAPI NdrCStdStubBuffer2_Release(LPRPCSTUBBUFFER iface,
         release_delegating_vtbl(This->base_obj);
 
         IPSFactoryBuffer_Release(pPSF);
-        HeapFree(GetProcessHeap(), 0, This);
+        free(This);
     }
 
     return refs;
diff --git a/dlls/rpcrt4/ndr_contexthandle.c b/dlls/rpcrt4/ndr_contexthandle.c
index 00057508753..1bff1e82936 100644
--- a/dlls/rpcrt4/ndr_contexthandle.c
+++ b/dlls/rpcrt4/ndr_contexthandle.c
@@ -19,6 +19,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <stdlib.h>
+
 #include "ndr_misc.h"
 #include "rpc_assoc.h"
 #include "rpcndr.h"
@@ -140,7 +142,7 @@ RPC_STATUS WINAPI RpcSmDestroyClientContext(void **ContextHandle)
     if (che)
     {
         RpcBindingFree(&che->handle);
-        HeapFree(GetProcessHeap(), 0, che);
+        free(che);
     }
 
     return status;
@@ -180,14 +182,14 @@ static RPC_STATUS ndr_update_context_handle(NDR_CCONTEXT *CContext,
                 return RPC_X_SS_CONTEXT_MISMATCH;
             list_remove(&che->entry);
             RpcBindingFree(&che->handle);
-            HeapFree(GetProcessHeap(), 0, che);
+            free(che);
             che = NULL;
         }
     }
     /* if there's no existing entry matching the GUID, allocate one */
     else if (!(che = context_entry_from_guid(&chi->uuid)))
     {
-        che = HeapAlloc(GetProcessHeap(), 0, sizeof *che);
+        che = malloc(sizeof *che);
         if (!che)
             return RPC_X_NO_MEMORY;
         che->magic = NDR_CONTEXT_HANDLE_MAGIC;
diff --git a/dlls/rpcrt4/ndr_es.c b/dlls/rpcrt4/ndr_es.c
index f7fb45feee1..3f08f134214 100644
--- a/dlls/rpcrt4/ndr_es.c
+++ b/dlls/rpcrt4/ndr_es.c
@@ -20,6 +20,7 @@
 
 #include <stdarg.h>
 #include <stdio.h>
+#include <stdlib.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -55,7 +56,7 @@ RPC_STATUS WINAPI MesEncodeIncrementalHandleCreate(
 
     TRACE("(%p, %p, %p, %p)\n", UserState, AllocFn, WriteFn, pHandle);
 
-    pEsMsg = HeapAlloc(GetProcessHeap(), 0, sizeof(*pEsMsg));
+    pEsMsg = malloc(sizeof(*pEsMsg));
     if (!pEsMsg)
         return RPC_S_OUT_OF_MEMORY;
 
@@ -82,7 +83,7 @@ RPC_STATUS WINAPI MesDecodeIncrementalHandleCreate(
 
     TRACE("(%p, %p, %p)\n", UserState, ReadFn, pHandle);
 
-    pEsMsg = HeapAlloc(GetProcessHeap(), 0, sizeof(*pEsMsg));
+    pEsMsg = malloc(sizeof(*pEsMsg));
     if (!pEsMsg)
         return RPC_S_OUT_OF_MEMORY;
 
@@ -162,7 +163,7 @@ RPC_STATUS WINAPI MesBufferHandleReset(handle_t Handle, ULONG HandleStyle,
 RPC_STATUS WINAPI MesHandleFree(handle_t Handle)
 {
     TRACE("(%p)\n", Handle);
-    HeapFree(GetProcessHeap(), 0, Handle);
+    free(Handle);
     return RPC_S_OK;
 }
 
@@ -196,7 +197,7 @@ RPC_STATUS RPC_ENTRY MesEncodeFixedBufferHandleCreate(
 
     /* FIXME: check BufferSize too */
 
-    pEsMsg = HeapAlloc(GetProcessHeap(), 0, sizeof(*pEsMsg));
+    pEsMsg = malloc(sizeof(*pEsMsg));
     if (!pEsMsg)
         return RPC_S_OUT_OF_MEMORY;
 
@@ -226,7 +227,7 @@ RPC_STATUS RPC_ENTRY MesEncodeDynBufferHandleCreate(char **Buffer,
     if (!pEncodedSize)
         return RPC_S_INVALID_ARG;
 
-    pEsMsg = HeapAlloc(GetProcessHeap(), 0, sizeof(*pEsMsg));
+    pEsMsg = malloc(sizeof(*pEsMsg));
     if (!pEsMsg)
         return RPC_S_OUT_OF_MEMORY;
 
@@ -256,7 +257,7 @@ RPC_STATUS RPC_ENTRY MesDecodeBufferHandleCreate(
     if ((status = validate_mes_buffer_pointer(Buffer)))
         return status;
 
-    pEsMsg = HeapAlloc(GetProcessHeap(), 0, sizeof(*pEsMsg));
+    pEsMsg = malloc(sizeof(*pEsMsg));
     if (!pEsMsg)
         return RPC_S_OUT_OF_MEMORY;
 
diff --git a/dlls/rpcrt4/ndr_fullpointer.c b/dlls/rpcrt4/ndr_fullpointer.c
index e4c959ce90a..39e1b18c828 100644
--- a/dlls/rpcrt4/ndr_fullpointer.c
+++ b/dlls/rpcrt4/ndr_fullpointer.c
@@ -19,6 +19,7 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -33,25 +34,19 @@ PFULL_PTR_XLAT_TABLES WINAPI NdrFullPointerXlatInit(ULONG NumberOfPointers,
                                                     XLAT_SIDE XlatSide)
 {
     ULONG NumberOfBuckets;
-    PFULL_PTR_XLAT_TABLES pXlatTables = HeapAlloc(GetProcessHeap(), 0, sizeof(*pXlatTables));
+    FULL_PTR_XLAT_TABLES *pXlatTables = malloc(sizeof(*pXlatTables));
 
     TRACE("(%ld, %d)\n", NumberOfPointers, XlatSide);
 
     if (!NumberOfPointers) NumberOfPointers = 512;
     NumberOfBuckets = ((NumberOfPointers + 3) & ~3) - 1;
 
-    pXlatTables->RefIdToPointer.XlatTable =
-        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(void *) * NumberOfPointers);
-    pXlatTables->RefIdToPointer.StateTable =
-        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(unsigned char) * NumberOfPointers);
+    pXlatTables->RefIdToPointer.XlatTable = calloc(NumberOfPointers, sizeof(void *));
+    pXlatTables->RefIdToPointer.StateTable = calloc(NumberOfPointers, sizeof(unsigned char));
     pXlatTables->RefIdToPointer.NumberOfEntries = NumberOfPointers;
 
     TRACE("NumberOfBuckets = %ld\n", NumberOfBuckets);
-    pXlatTables->PointerToRefId.XlatTable =
-        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(PFULL_PTR_TO_REFID_ELEMENT) * NumberOfBuckets);
+    pXlatTables->PointerToRefId.XlatTable = calloc(NumberOfBuckets, sizeof(FULL_PTR_TO_REFID_ELEMENT *));
     pXlatTables->PointerToRefId.NumberOfBuckets = NumberOfBuckets;
     pXlatTables->PointerToRefId.HashMask = NumberOfBuckets - 1;
 
@@ -75,34 +70,36 @@ void WINAPI NdrFullPointerXlatFree(PFULL_PTR_XLAT_TABLES pXlatTables)
             XlatTableEntry; )
         {
             PFULL_PTR_TO_REFID_ELEMENT Next = XlatTableEntry->Next;
-            HeapFree(GetProcessHeap(), 0, XlatTableEntry);
+            free(XlatTableEntry);
             XlatTableEntry = Next;
         }
     }
 
-    HeapFree(GetProcessHeap(), 0, pXlatTables->RefIdToPointer.XlatTable);
-    HeapFree(GetProcessHeap(), 0, pXlatTables->RefIdToPointer.StateTable);
-    HeapFree(GetProcessHeap(), 0, pXlatTables->PointerToRefId.XlatTable);
+    free(pXlatTables->RefIdToPointer.XlatTable);
+    free(pXlatTables->RefIdToPointer.StateTable);
+    free(pXlatTables->PointerToRefId.XlatTable);
 
-    HeapFree(GetProcessHeap(), 0, pXlatTables);
+    free(pXlatTables);
 }
 
 static void expand_pointer_table_if_necessary(PFULL_PTR_XLAT_TABLES pXlatTables, ULONG RefId)
 {
     if (RefId >= pXlatTables->RefIdToPointer.NumberOfEntries)
     {
-        pXlatTables->RefIdToPointer.NumberOfEntries = RefId * 2;
         pXlatTables->RefIdToPointer.XlatTable =
-            HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-                pXlatTables->RefIdToPointer.XlatTable,
-                sizeof(void *) * pXlatTables->RefIdToPointer.NumberOfEntries);
+            realloc(pXlatTables->RefIdToPointer.XlatTable, sizeof(void *) * RefId * 2);
         pXlatTables->RefIdToPointer.StateTable =
-            HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-                pXlatTables->RefIdToPointer.StateTable,
-                sizeof(unsigned char) * pXlatTables->RefIdToPointer.NumberOfEntries);
-
+            realloc(pXlatTables->RefIdToPointer.StateTable, RefId * 2);
         if (!pXlatTables->RefIdToPointer.XlatTable || !pXlatTables->RefIdToPointer.StateTable)
+        {
             pXlatTables->RefIdToPointer.NumberOfEntries = 0;
+            return;
+        }
+        memset(pXlatTables->RefIdToPointer.XlatTable + pXlatTables->RefIdToPointer.NumberOfEntries, 0,
+            (RefId * 2 - pXlatTables->RefIdToPointer.NumberOfEntries) * sizeof(void *));
+        memset(pXlatTables->RefIdToPointer.StateTable + pXlatTables->RefIdToPointer.NumberOfEntries, 0,
+            RefId * 2 - pXlatTables->RefIdToPointer.NumberOfEntries);
+        pXlatTables->RefIdToPointer.NumberOfEntries = RefId * 2;
     }
 }
 
@@ -137,7 +134,7 @@ int WINAPI NdrFullPointerQueryPointer(PFULL_PTR_XLAT_TABLES pXlatTables,
             return 0;
         }
 
-    XlatTableEntry = HeapAlloc(GetProcessHeap(), 0, sizeof(*XlatTableEntry));
+    XlatTableEntry = malloc(sizeof(*XlatTableEntry));
     XlatTableEntry->Next = pXlatTables->PointerToRefId.XlatTable[Hash & pXlatTables->PointerToRefId.HashMask];
     XlatTableEntry->Pointer = pPointer;
     XlatTableEntry->RefId = *pRefId = pXlatTables->NextRefId++;
@@ -198,7 +195,7 @@ void WINAPI NdrFullPointerInsertRefId(PFULL_PTR_XLAT_TABLES pXlatTables,
     for (i = 0; i < sizeof(pPointer); i++)
         Hash = (Hash * 3) ^ ((unsigned char *)&pPointer)[i];
 
-    XlatTableEntry = HeapAlloc(GetProcessHeap(), 0, sizeof(*XlatTableEntry));
+    XlatTableEntry = malloc(sizeof(*XlatTableEntry));
     XlatTableEntry->Next = pXlatTables->PointerToRefId.XlatTable[Hash & pXlatTables->PointerToRefId.HashMask];
     XlatTableEntry->Pointer = pPointer;
     XlatTableEntry->RefId = RefId;
diff --git a/dlls/rpcrt4/ndr_ole.c b/dlls/rpcrt4/ndr_ole.c
index c5e0b34ecc5..2fdc7b55335 100644
--- a/dlls/rpcrt4/ndr_ole.c
+++ b/dlls/rpcrt4/ndr_ole.c
@@ -118,7 +118,7 @@ static ULONG WINAPI RpcStream_Release(LPSTREAM iface)
   if (!ref) {
     TRACE("size=%ld\n", *This->size);
     This->pMsg->Buffer = This->data + *This->size;
-    HeapFree(GetProcessHeap(),0,This);
+    free(This);
   }
   return ref;
 }
@@ -267,7 +267,7 @@ static HRESULT RpcStream_Create(PMIDL_STUB_MESSAGE pStubMsg, BOOL init, ULONG *s
   RpcStreamImpl *This;
 
   *stream = NULL;
-  This = HeapAlloc(GetProcessHeap(), 0, sizeof(RpcStreamImpl));
+  This = malloc(sizeof(RpcStreamImpl));
   if (!This) return E_OUTOFMEMORY;
   This->IStream_iface.lpVtbl = &RpcStream_Vtbl;
   This->RefCount = 1;
diff --git a/dlls/rpcrt4/ndr_stubless.c b/dlls/rpcrt4/ndr_stubless.c
index bf9313d818c..8fc5fd41ca6 100644
--- a/dlls/rpcrt4/ndr_stubless.c
+++ b/dlls/rpcrt4/ndr_stubless.c
@@ -1248,7 +1248,7 @@ static LONG_PTR *stub_do_args(MIDL_STUB_MESSAGE *pStubMsg,
         case STUBLESS_FREE:
             if (params[i].attr.ServerAllocSize)
             {
-                HeapFree(GetProcessHeap(), 0, *(void **)pArg);
+                free(*(void **)pArg);
             }
             else if (param_needs_alloc(params[i].attr) &&
                      (!params[i].attr.MustFree || params[i].attr.IsSimpleRef))
@@ -1279,8 +1279,7 @@ static LONG_PTR *stub_do_args(MIDL_STUB_MESSAGE *pStubMsg,
             break;
         case STUBLESS_UNMARSHAL:
             if (params[i].attr.ServerAllocSize)
-                *(void **)pArg = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-                                           params[i].attr.ServerAllocSize * 8);
+                *(void **)pArg = calloc(params[i].attr.ServerAllocSize, 8);
 
             if (params[i].attr.IsIn)
                 call_unmarshaller(pStubMsg, &pArg, &params[i], 0);
@@ -1417,7 +1416,7 @@ LONG WINAPI NdrStubCall2(
 
     TRACE("allocating memory for stack of size %x\n", stack_size);
 
-    args = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, stack_size);
+    args = calloc(1, stack_size);
     stubMsg.StackTop = args; /* used by conformance of top-level objects */
 
     /* add the implicit This pointer as the first arg to the function if we
@@ -1556,7 +1555,7 @@ LONG WINAPI NdrStubCall2(
         NdrFullPointerXlatFree(stubMsg.FullPtrXlatTables);
 
     /* free server function stack */
-    HeapFree(GetProcessHeap(), 0, args);
+    free(args);
 
     return S_OK;
 }
@@ -2042,7 +2041,7 @@ void RPC_ENTRY NdrAsyncServerCall(PRPC_MESSAGE pRpcMsg)
 
     TRACE("allocating memory for stack of size %x\n", async_call_data->stack_size);
 
-    args = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, async_call_data->stack_size);
+    args = calloc(1, async_call_data->stack_size);
     async_call_data->pStubMsg->StackTop = args; /* used by conformance of top-level objects */
 
     pAsync = I_RpcAllocate(sizeof(*pAsync));
@@ -2160,7 +2159,7 @@ RPC_STATUS NdrpCompleteAsyncServerCall(RPC_ASYNC_STATE *pAsync, void *Reply)
             if (async_call_data->pProcHeader->Oi_flags & Oi_OBJECT_PROC)
             {
                 ERR("objects not supported\n");
-                HeapFree(GetProcessHeap(), 0, async_call_data->pStubMsg->StackTop);
+                free(async_call_data->pStubMsg->StackTop);
                 I_RpcFree(async_call_data);
                 I_RpcFree(pAsync);
                 RpcRaiseException(RPC_X_BAD_STUB_DATA);
@@ -2206,7 +2205,7 @@ RPC_STATUS NdrpCompleteAsyncServerCall(RPC_ASYNC_STATE *pAsync, void *Reply)
 #endif
 
     /* free server function stack */
-    HeapFree(GetProcessHeap(), 0, async_call_data->pStubMsg->StackTop);
+    free(async_call_data->pStubMsg->StackTop);
     I_RpcFree(async_call_data);
     I_RpcFree(pAsync);
 
diff --git a/dlls/rpcrt4/ndr_typelib.c b/dlls/rpcrt4/ndr_typelib.c
index ff1d1025838..5dd721dc5dc 100644
--- a/dlls/rpcrt4/ndr_typelib.c
+++ b/dlls/rpcrt4/ndr_typelib.c
@@ -26,7 +26,6 @@
 #include "rpcproxy.h"
 #include "ndrtypes.h"
 #include "wine/debug.h"
-#include "wine/heap.h"
 
 #include "cpsf.h"
 #include "initguid.h"
@@ -1187,9 +1186,9 @@ static HRESULT build_format_strings(ITypeInfo *typeinfo, WORD funcs,
     hr = write_iface_fs(typeinfo, funcs, parentfuncs, NULL, &typelen, NULL, &proclen, NULL);
     if (FAILED(hr)) return hr;
 
-    type = heap_alloc(typelen);
-    proc = heap_alloc(proclen);
-    offset = heap_alloc((parentfuncs + funcs - 3) * sizeof(*offset));
+    type = malloc(typelen);
+    proc = malloc(proclen);
+    offset = malloc((parentfuncs + funcs - 3) * sizeof(*offset));
     if (!type || !proc || !offset)
     {
         ERR("Failed to allocate format strings.\n");
@@ -1211,9 +1210,9 @@ static HRESULT build_format_strings(ITypeInfo *typeinfo, WORD funcs,
     }
 
 err:
-    heap_free(type);
-    heap_free(proc);
-    heap_free(offset);
+    free(type);
+    free(proc);
+    free(offset);
     return hr;
 }
 
@@ -1328,11 +1327,11 @@ static ULONG WINAPI typelib_proxy_Release(IRpcProxyBuffer *iface)
             IUnknown_Release(proxy->proxy.base_object);
         if (proxy->proxy.base_proxy)
             IRpcProxyBuffer_Release(proxy->proxy.base_proxy);
-        heap_free((void *)proxy->stub_desc.pFormatTypes);
-        heap_free((void *)proxy->proxy_info.ProcFormatString);
-        heap_free(proxy->offset_table);
-        heap_free(proxy->proxy_vtbl);
-        heap_free(proxy);
+        free((void *)proxy->stub_desc.pFormatTypes);
+        free((void *)proxy->proxy_info.ProcFormatString);
+        free(proxy->offset_table);
+        free(proxy->proxy_vtbl);
+        free(proxy);
     }
     return refcount;
 }
@@ -1390,7 +1389,7 @@ HRESULT WINAPI CreateProxyFromTypeInfo(ITypeInfo *typeinfo, IUnknown *outer,
     if (FAILED(hr))
         return hr;
 
-    if (!(proxy = heap_alloc_zero(sizeof(*proxy))))
+    if (!(proxy = calloc(1, sizeof(*proxy))))
     {
         ERR("Failed to allocate proxy object.\n");
         ITypeInfo_Release(real_typeinfo);
@@ -1400,11 +1399,11 @@ HRESULT WINAPI CreateProxyFromTypeInfo(ITypeInfo *typeinfo, IUnknown *outer,
     init_stub_desc(&proxy->stub_desc);
     proxy->proxy_info.pStubDesc = &proxy->stub_desc;
 
-    proxy->proxy_vtbl = heap_alloc_zero(sizeof(proxy->proxy_vtbl->header) + (funcs + parentfuncs) * sizeof(void *));
+    proxy->proxy_vtbl = calloc(1, sizeof(proxy->proxy_vtbl->header) + (funcs + parentfuncs) * sizeof(void *));
     if (!proxy->proxy_vtbl)
     {
         ERR("Failed to allocate proxy vtbl.\n");
-        heap_free(proxy);
+        free(proxy);
         ITypeInfo_Release(real_typeinfo);
         return E_OUTOFMEMORY;
     }
@@ -1420,8 +1419,8 @@ HRESULT WINAPI CreateProxyFromTypeInfo(ITypeInfo *typeinfo, IUnknown *outer,
     ITypeInfo_Release(real_typeinfo);
     if (FAILED(hr))
     {
-        heap_free(proxy->proxy_vtbl);
-        heap_free(proxy);
+        free(proxy->proxy_vtbl);
+        free(proxy);
         return hr;
     }
     proxy->proxy_info.FormatStringOffset = &proxy->offset_table[-3];
@@ -1429,11 +1428,11 @@ HRESULT WINAPI CreateProxyFromTypeInfo(ITypeInfo *typeinfo, IUnknown *outer,
     hr = typelib_proxy_init(proxy, outer, funcs + parentfuncs, &parentiid, proxy_buffer, out);
     if (FAILED(hr))
     {
-        heap_free((void *)proxy->stub_desc.pFormatTypes);
-        heap_free((void *)proxy->proxy_info.ProcFormatString);
-        heap_free((void *)proxy->offset_table);
-        heap_free(proxy->proxy_vtbl);
-        heap_free(proxy);
+        free((void *)proxy->stub_desc.pFormatTypes);
+        free((void *)proxy->proxy_info.ProcFormatString);
+        free((void *)proxy->offset_table);
+        free(proxy->proxy_vtbl);
+        free(proxy);
     }
 
     return hr;
@@ -1467,13 +1466,13 @@ static ULONG WINAPI typelib_stub_Release(IRpcStubBuffer *iface)
         {
             IRpcStubBuffer_Release(stub->stub.base_stub);
             release_delegating_vtbl(stub->stub.base_obj);
-            heap_free(stub->dispatch_table);
+            free(stub->dispatch_table);
         }
 
-        heap_free((void *)stub->stub_desc.pFormatTypes);
-        heap_free((void *)stub->server_info.ProcString);
-        heap_free(stub->offset_table);
-        heap_free(stub);
+        free((void *)stub->stub_desc.pFormatTypes);
+        free((void *)stub->server_info.ProcString);
+        free(stub->offset_table);
+        free(stub);
     }
 
     return refcount;
@@ -1529,7 +1528,7 @@ HRESULT WINAPI CreateStubFromTypeInfo(ITypeInfo *typeinfo, REFIID iid,
     if (FAILED(hr))
         return hr;
 
-    if (!(stub = heap_alloc_zero(sizeof(*stub))))
+    if (!(stub = calloc(1, sizeof(*stub))))
     {
         ERR("Failed to allocate stub object.\n");
         ITypeInfo_Release(real_typeinfo);
@@ -1544,7 +1543,7 @@ HRESULT WINAPI CreateStubFromTypeInfo(ITypeInfo *typeinfo, REFIID iid,
     ITypeInfo_Release(real_typeinfo);
     if (FAILED(hr))
     {
-        heap_free(stub);
+        free(stub);
         return hr;
     }
     stub->server_info.FmtStringOffset = &stub->offset_table[-3];
@@ -1556,7 +1555,7 @@ HRESULT WINAPI CreateStubFromTypeInfo(ITypeInfo *typeinfo, REFIID iid,
 
     if (!IsEqualGUID(&parentiid, &IID_IUnknown))
     {
-        stub->dispatch_table = heap_alloc((funcs + parentfuncs) * sizeof(void *));
+        stub->dispatch_table = malloc((funcs + parentfuncs) * sizeof(void *));
         for (i = 3; i < parentfuncs; i++)
             stub->dispatch_table[i - 3] = NdrStubForwardingFunction;
         for (; i < funcs + parentfuncs; i++)
@@ -1571,10 +1570,10 @@ HRESULT WINAPI CreateStubFromTypeInfo(ITypeInfo *typeinfo, REFIID iid,
     hr = typelib_stub_init(stub, server, &parentiid, stub_buffer);
     if (FAILED(hr))
     {
-        heap_free((void *)stub->stub_desc.pFormatTypes);
-        heap_free((void *)stub->server_info.ProcString);
-        heap_free(stub->offset_table);
-        heap_free(stub);
+        free((void *)stub->stub_desc.pFormatTypes);
+        free((void *)stub->server_info.ProcString);
+        free(stub->offset_table);
+        free(stub);
     }
 
     return hr;
diff --git a/dlls/rpcrt4/rpc_assoc.c b/dlls/rpcrt4/rpc_assoc.c
index 80851c8cddd..6a6768e1677 100644
--- a/dlls/rpcrt4/rpc_assoc.c
+++ b/dlls/rpcrt4/rpc_assoc.c
@@ -20,6 +20,7 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 #include <assert.h>
 
 #include "rpc.h"
@@ -65,7 +66,7 @@ static RPC_STATUS RpcAssoc_Alloc(LPCSTR Protseq, LPCSTR NetworkAddr,
                                  RpcAssoc **assoc_out)
 {
     RpcAssoc *assoc;
-    assoc = HeapAlloc(GetProcessHeap(), 0, sizeof(*assoc));
+    assoc = malloc(sizeof(*assoc));
     if (!assoc)
         return RPC_S_OUT_OF_RESOURCES;
     assoc->refs = 1;
@@ -73,10 +74,10 @@ static RPC_STATUS RpcAssoc_Alloc(LPCSTR Protseq, LPCSTR NetworkAddr,
     list_init(&assoc->context_handle_list);
     InitializeCriticalSection(&assoc->cs);
     assoc->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": RpcAssoc.cs");
-    assoc->Protseq = RPCRT4_strdupA(Protseq);
-    assoc->NetworkAddr = RPCRT4_strdupA(NetworkAddr);
-    assoc->Endpoint = RPCRT4_strdupA(Endpoint);
-    assoc->NetworkOptions = NetworkOptions ? RPCRT4_strdupW(NetworkOptions) : NULL;
+    assoc->Protseq = strdup(Protseq);
+    assoc->NetworkAddr = strdup(NetworkAddr);
+    assoc->Endpoint = strdup(Endpoint);
+    assoc->NetworkOptions = wcsdup(NetworkOptions);
     assoc->assoc_group_id = 0;
     assoc->connection_cnt = 0;
     UuidCreate(&assoc->http_uuid);
@@ -209,15 +210,15 @@ ULONG RpcAssoc_Release(RpcAssoc *assoc)
         LIST_FOR_EACH_ENTRY_SAFE(context_handle, context_handle_cursor, &assoc->context_handle_list, RpcContextHandle, entry)
             RpcContextHandle_Destroy(context_handle);
 
-        HeapFree(GetProcessHeap(), 0, assoc->NetworkOptions);
-        HeapFree(GetProcessHeap(), 0, assoc->Endpoint);
-        HeapFree(GetProcessHeap(), 0, assoc->NetworkAddr);
-        HeapFree(GetProcessHeap(), 0, assoc->Protseq);
+        free(assoc->NetworkOptions);
+        free(assoc->Endpoint);
+        free(assoc->NetworkAddr);
+        free(assoc->Protseq);
 
         assoc->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&assoc->cs);
 
-        HeapFree(GetProcessHeap(), 0, assoc);
+        free(assoc);
     }
 
     return refs;
@@ -244,7 +245,7 @@ static RPC_STATUS RpcAssoc_BindConnection(const RpcAssoc *assoc, RpcConnection *
                                  InterfaceId, TransferSyntax);
 
     status = RPCRT4_Send(conn, hdr, NULL, 0);
-    RPCRT4_FreeHeader(hdr);
+    free(hdr);
     if (status != RPC_S_OK)
         return status;
 
@@ -355,8 +356,8 @@ static RPC_STATUS RpcAssoc_BindConnection(const RpcAssoc *assoc, RpcConnection *
     }
 
     I_RpcFree(msg.Buffer);
-    RPCRT4_FreeHeader(response_hdr);
-    HeapFree(GetProcessHeap(), 0, auth_data);
+    free(response_hdr);
+    free(auth_data);
     return status;
 }
 
@@ -457,7 +458,7 @@ RPC_STATUS RpcServerAssoc_AllocateContextHandle(RpcAssoc *assoc, void *CtxGuard,
 {
     RpcContextHandle *context_handle;
 
-    context_handle = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*context_handle));
+    context_handle = calloc(1, sizeof(*context_handle));
     if (!context_handle)
         return RPC_S_OUT_OF_MEMORY;
 
@@ -558,7 +559,7 @@ static void RpcContextHandle_Destroy(RpcContextHandle *context_handle)
     context_handle->lock.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&context_handle->lock);
 
-    HeapFree(GetProcessHeap(), 0, context_handle);
+    free(context_handle);
 }
 
 unsigned int RpcServerAssoc_ReleaseContextHandle(RpcAssoc *assoc, NDR_SCONTEXT SContext, BOOL release_lock)
diff --git a/dlls/rpcrt4/rpc_binding.c b/dlls/rpcrt4/rpc_binding.c
index 8c2d34f8a21..fec9aa999aa 100644
--- a/dlls/rpcrt4/rpc_binding.c
+++ b/dlls/rpcrt4/rpc_binding.c
@@ -23,6 +23,7 @@
 
 #include <stdarg.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <assert.h>
 
@@ -49,7 +50,7 @@ LPSTR RPCRT4_strndupA(LPCSTR src, INT slen)
   if (!src) return NULL;
   if (slen == -1) slen = strlen(src);
   len = slen;
-  s = HeapAlloc(GetProcessHeap(), 0, len+1);
+  s = malloc(len + 1);
   memcpy(s, src, len);
   s[len] = 0;
   return s;
@@ -61,7 +62,7 @@ LPSTR RPCRT4_strdupWtoA(LPCWSTR src)
   LPSTR s;
   if (!src) return NULL;
   len = WideCharToMultiByte(CP_ACP, 0, src, -1, NULL, 0, NULL, NULL);
-  s = HeapAlloc(GetProcessHeap(), 0, len);
+  s = malloc(len);
   WideCharToMultiByte(CP_ACP, 0, src, -1, s, len, NULL, NULL);
   return s;
 }
@@ -72,7 +73,7 @@ LPWSTR RPCRT4_strdupAtoW(LPCSTR src)
   LPWSTR s;
   if (!src) return NULL;
   len = MultiByteToWideChar(CP_ACP, 0, src, -1, NULL, 0);
-  s = HeapAlloc(GetProcessHeap(), 0, len*sizeof(WCHAR));
+  s = malloc(len * sizeof(WCHAR));
   MultiByteToWideChar(CP_ACP, 0, src, -1, s, len);
   return s;
 }
@@ -83,7 +84,7 @@ static LPWSTR RPCRT4_strndupAtoW(LPCSTR src, INT slen)
   LPWSTR s;
   if (!src) return NULL;
   len = MultiByteToWideChar(CP_ACP, 0, src, slen, NULL, 0);
-  s = HeapAlloc(GetProcessHeap(), 0, len*sizeof(WCHAR));
+  s = malloc(len * sizeof(WCHAR));
   MultiByteToWideChar(CP_ACP, 0, src, slen, s, len);
   return s;
 }
@@ -95,22 +96,17 @@ LPWSTR RPCRT4_strndupW(LPCWSTR src, INT slen)
   if (!src) return NULL;
   if (slen == -1) slen = lstrlenW(src);
   len = slen;
-  s = HeapAlloc(GetProcessHeap(), 0, (len+1)*sizeof(WCHAR));
+  s = malloc((len + 1) * sizeof(WCHAR));
   memcpy(s, src, len*sizeof(WCHAR));
   s[len] = 0;
   return s;
 }
 
-void RPCRT4_strfree(LPSTR src)
-{
-  HeapFree(GetProcessHeap(), 0, src);
-}
-
 static RPC_STATUS RPCRT4_AllocBinding(RpcBinding** Binding, BOOL server)
 {
   RpcBinding* NewBinding;
 
-  NewBinding = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(RpcBinding));
+  NewBinding = calloc(1, sizeof(RpcBinding));
   NewBinding->refs = 1;
   NewBinding->server = server;
 
@@ -124,7 +120,7 @@ static RPC_STATUS RPCRT4_CreateBindingA(RpcBinding** Binding, BOOL server, LPCST
   RpcBinding* NewBinding;
 
   RPCRT4_AllocBinding(&NewBinding, server);
-  NewBinding->Protseq = RPCRT4_strdupA(Protseq);
+  NewBinding->Protseq = strdup(Protseq);
 
   TRACE("binding: %p\n", NewBinding);
   *Binding = NewBinding;
@@ -153,11 +149,11 @@ static RPC_STATUS RPCRT4_CompleteBindingA(RpcBinding* Binding, LPCSTR NetworkAdd
   TRACE("(RpcBinding == ^%p, NetworkAddr == %s, EndPoint == %s, NetworkOptions == %s)\n", Binding,
    debugstr_a(NetworkAddr), debugstr_a(Endpoint), debugstr_a(NetworkOptions));
 
-  RPCRT4_strfree(Binding->NetworkAddr);
-  Binding->NetworkAddr = RPCRT4_strdupA(NetworkAddr);
-  RPCRT4_strfree(Binding->Endpoint);
-  Binding->Endpoint = RPCRT4_strdupA(Endpoint);
-  HeapFree(GetProcessHeap(), 0, Binding->NetworkOptions);
+  free(Binding->NetworkAddr);
+  Binding->NetworkAddr = strdup(NetworkAddr);
+  free(Binding->Endpoint);
+  Binding->Endpoint = strdup(Endpoint);
+  free(Binding->NetworkOptions);
   Binding->NetworkOptions = RPCRT4_strdupAtoW(NetworkOptions);
 
   /* only attempt to get an association if the binding is complete */
@@ -181,12 +177,12 @@ static RPC_STATUS RPCRT4_CompleteBindingW(RpcBinding* Binding, LPCWSTR NetworkAd
   TRACE("(RpcBinding == ^%p, NetworkAddr == %s, EndPoint == %s, NetworkOptions == %s)\n", Binding, 
    debugstr_w(NetworkAddr), debugstr_w(Endpoint), debugstr_w(NetworkOptions));
 
-  RPCRT4_strfree(Binding->NetworkAddr);
+  free(Binding->NetworkAddr);
   Binding->NetworkAddr = RPCRT4_strdupWtoA(NetworkAddr);
-  RPCRT4_strfree(Binding->Endpoint);
+  free(Binding->Endpoint);
   Binding->Endpoint = RPCRT4_strdupWtoA(Endpoint);
-  HeapFree(GetProcessHeap(), 0, Binding->NetworkOptions);
-  Binding->NetworkOptions = RPCRT4_strdupW(NetworkOptions);
+  free(Binding->NetworkOptions);
+  Binding->NetworkOptions = wcsdup(NetworkOptions);
 
   /* only attempt to get an association if the binding is complete */
   if (Endpoint && Endpoint[0] != '\0')
@@ -207,8 +203,8 @@ RPC_STATUS RPCRT4_ResolveBinding(RpcBinding* Binding, LPCSTR Endpoint)
 
   TRACE("(RpcBinding == ^%p, EndPoint == \"%s\"\n", Binding, Endpoint);
 
-  RPCRT4_strfree(Binding->Endpoint);
-  Binding->Endpoint = RPCRT4_strdupA(Endpoint);
+  free(Binding->Endpoint);
+  Binding->Endpoint = strdup(Endpoint);
 
   if (Binding->Assoc) RpcAssoc_Release(Binding->Assoc);
   Binding->Assoc = NULL;
@@ -235,9 +231,9 @@ RPC_STATUS RPCRT4_MakeBinding(RpcBinding** Binding, RpcConnection* Connection)
   TRACE("(RpcBinding == ^%p, Connection == ^%p)\n", Binding, Connection);
 
   RPCRT4_AllocBinding(&NewBinding, Connection->server);
-  NewBinding->Protseq = RPCRT4_strdupA(rpcrt4_conn_get_name(Connection));
-  NewBinding->NetworkAddr = RPCRT4_strdupA(Connection->NetworkAddr);
-  NewBinding->Endpoint = RPCRT4_strdupA(Connection->Endpoint);
+  NewBinding->Protseq = strdup(rpcrt4_conn_get_name(Connection));
+  NewBinding->NetworkAddr = strdup(Connection->NetworkAddr);
+  NewBinding->Endpoint = strdup(Connection->Endpoint);
   NewBinding->FromConn = Connection;
 
   TRACE("binding: %p\n", NewBinding);
@@ -258,14 +254,14 @@ RPC_STATUS RPCRT4_ReleaseBinding(RpcBinding* Binding)
 
   TRACE("binding: %p\n", Binding);
   if (Binding->Assoc) RpcAssoc_Release(Binding->Assoc);
-  RPCRT4_strfree(Binding->Endpoint);
-  RPCRT4_strfree(Binding->NetworkAddr);
-  RPCRT4_strfree(Binding->Protseq);
-  HeapFree(GetProcessHeap(), 0, Binding->NetworkOptions);
-  HeapFree(GetProcessHeap(), 0, Binding->CookieAuth);
+  free(Binding->Endpoint);
+  free(Binding->NetworkAddr);
+  free(Binding->Protseq);
+  free(Binding->NetworkOptions);
+  free(Binding->CookieAuth);
   if (Binding->AuthInfo) RpcAuthInfo_Release(Binding->AuthInfo);
   if (Binding->QOS) RpcQualityOfService_Release(Binding->QOS);
-  HeapFree(GetProcessHeap(), 0, Binding);
+  free(Binding);
   return RPC_S_OK;
 }
 
@@ -308,10 +304,10 @@ RPC_STATUS RPCRT4_CloseBinding(RpcBinding* Binding, RpcConnection* Connection)
 static LPSTR RPCRT4_strconcatA(LPSTR dst, LPCSTR src)
 {
   DWORD len = strlen(dst), slen = strlen(src);
-  LPSTR ndst = HeapReAlloc(GetProcessHeap(), 0, dst, (len+slen+2)*sizeof(CHAR));
+  char *ndst = realloc(dst, len + slen + 2);
   if (!ndst)
   {
-    HeapFree(GetProcessHeap(), 0, dst);
+    free(dst);
     return NULL;
   }
   ndst[len] = ',';
@@ -322,10 +318,10 @@ static LPSTR RPCRT4_strconcatA(LPSTR dst, LPCSTR src)
 static LPWSTR RPCRT4_strconcatW(LPWSTR dst, LPCWSTR src)
 {
   DWORD len = lstrlenW(dst), slen = lstrlenW(src);
-  LPWSTR ndst = HeapReAlloc(GetProcessHeap(), 0, dst, (len+slen+2)*sizeof(WCHAR));
-  if (!ndst) 
+  WCHAR *ndst = realloc(dst, (len + slen + 2) * sizeof(WCHAR));
+  if (!ndst)
   {
-    HeapFree(GetProcessHeap(), 0, dst);
+    free(dst);
     return NULL;
   }
   ndst[len] = ',';
@@ -414,7 +410,7 @@ static RPC_CSTR unescape_string_binding_component(
 
   if (len == -1) len = strlen((const char *)string_binding);
 
-  component = HeapAlloc(GetProcessHeap(), 0, (len + 1) * sizeof(*component));
+  component = malloc((len + 1) * sizeof(*component));
   if (!component) return NULL;
   for (p = component; len > 0; string_binding++, len--) {
     if (*string_binding == '\\') {
@@ -436,7 +432,7 @@ static RPC_WSTR unescape_string_binding_componentW(
 
   if (len == -1) len = lstrlenW(string_binding);
 
-  component = HeapAlloc(GetProcessHeap(), 0, (len + 1) * sizeof(*component));
+  component = malloc((len + 1) * sizeof(*component));
   if (!component) return NULL;
   for (p = component; len > 0; string_binding++, len--) {
     if (*string_binding == '\\') {
@@ -473,7 +469,7 @@ RPC_STATUS WINAPI RpcStringBindingComposeA(RPC_CSTR ObjUuid, RPC_CSTR Protseq,
   if (Endpoint && *Endpoint) len += strlen((char*)Endpoint) * 2 + 2;
   if (Options && *Options) len += strlen((char*)Options) * 2 + 2;
 
-  data = HeapAlloc(GetProcessHeap(), 0, len);
+  data = malloc(len);
   *StringBinding = data;
 
   if (ObjUuid && *ObjUuid) {
@@ -526,7 +522,7 @@ RPC_STATUS WINAPI RpcStringBindingComposeW( RPC_WSTR ObjUuid, RPC_WSTR Protseq,
   if (Endpoint && *Endpoint) len += lstrlenW(Endpoint) * 2 + 2;
   if (Options && *Options) len += lstrlenW(Options) * 2 + 2;
 
-  data = HeapAlloc(GetProcessHeap(), 0, len*sizeof(WCHAR));
+  data = malloc(len * sizeof(WCHAR));
   *StringBinding = data;
 
   if (ObjUuid && *ObjUuid) {
@@ -587,13 +583,13 @@ RPC_STATUS WINAPI RpcStringBindingParseA( RPC_CSTR StringBinding, RPC_CSTR *ObjU
     RPC_CSTR str_uuid = unescape_string_binding_component(data, next - data);
     status = UuidFromStringA(str_uuid, &uuid);
     if (status != RPC_S_OK) {
-      HeapFree(GetProcessHeap(), 0, str_uuid);
+      free(str_uuid);
       return status;
     }
     if (ObjUuid)
       *ObjUuid = str_uuid;
     else
-      HeapFree(GetProcessHeap(), 0, str_uuid);
+      free(str_uuid);
     data = next+1;
   }
 
@@ -627,14 +623,14 @@ RPC_STATUS WINAPI RpcStringBindingParseA( RPC_CSTR StringBinding, RPC_CSTR *ObjU
         /* not an option, must be an endpoint */
         if (endpoint_already_found) goto fail;
         if (Endpoint) *Endpoint = opt;
-        else HeapFree(GetProcessHeap(), 0, opt);
+        else free(opt);
         endpoint_already_found = TRUE;
       } else {
         if (strncmp((const char *)opt, ep_opt, strlen(ep_opt)) == 0) {
           /* endpoint option */
           if (endpoint_already_found) goto fail;
           if (Endpoint) *Endpoint = unescape_string_binding_component(next+1, -1);
-          HeapFree(GetProcessHeap(), 0, opt);
+          free(opt);
           endpoint_already_found = TRUE;
         } else {
           /* network option */
@@ -642,11 +638,11 @@ RPC_STATUS WINAPI RpcStringBindingParseA( RPC_CSTR StringBinding, RPC_CSTR *ObjU
             if (*Options) {
               /* FIXME: this is kind of inefficient */
               *Options = (unsigned char*) RPCRT4_strconcatA( (char*)*Options, (char *)opt);
-              HeapFree(GetProcessHeap(), 0, opt);
+              free(opt);
             } else
               *Options = opt;
           } else
-            HeapFree(GetProcessHeap(), 0, opt);
+            free(opt);
         }
       }
     }
@@ -696,13 +692,13 @@ RPC_STATUS WINAPI RpcStringBindingParseW( RPC_WSTR StringBinding, RPC_WSTR *ObjU
     RPC_WSTR str_uuid = unescape_string_binding_componentW(data, next - data);
     status = UuidFromStringW(str_uuid, &uuid);
     if (status != RPC_S_OK) {
-      HeapFree(GetProcessHeap(), 0, str_uuid);
+      free(str_uuid);
       return status;
     }
     if (ObjUuid)
       *ObjUuid = str_uuid;
     else
-      HeapFree(GetProcessHeap(), 0, str_uuid);
+      free(str_uuid);
     data = next+1;
   }
 
@@ -736,14 +732,14 @@ RPC_STATUS WINAPI RpcStringBindingParseW( RPC_WSTR StringBinding, RPC_WSTR *ObjU
         /* not an option, must be an endpoint */
         if (endpoint_already_found) goto fail;
         if (Endpoint) *Endpoint = opt;
-        else HeapFree(GetProcessHeap(), 0, opt);
+        else free(opt);
         endpoint_already_found = TRUE;
       } else {
         if (wcsncmp(opt, L"endpoint=", lstrlenW(L"endpoint=")) == 0) {
           /* endpoint option */
           if (endpoint_already_found) goto fail;
           if (Endpoint) *Endpoint = unescape_string_binding_componentW(next+1, -1);
-          HeapFree(GetProcessHeap(), 0, opt);
+          free(opt);
           endpoint_already_found = TRUE;
         } else {
           /* network option */
@@ -751,11 +747,11 @@ RPC_STATUS WINAPI RpcStringBindingParseW( RPC_WSTR StringBinding, RPC_WSTR *ObjU
             if (*Options) {
               /* FIXME: this is kind of inefficient */
               *Options = RPCRT4_strconcatW(*Options, opt);
-              HeapFree(GetProcessHeap(), 0, opt);
+              free(opt);
             } else
               *Options = opt;
           } else
-            HeapFree(GetProcessHeap(), 0, opt);
+            free(opt);
         }
       }
     }
@@ -800,7 +796,7 @@ RPC_STATUS WINAPI RpcBindingVectorFree( RPC_BINDING_VECTOR** BindingVector )
 
   TRACE("(%p)\n", BindingVector);
   for (c=0; c<(*BindingVector)->Count; c++) RpcBindingFree(&(*BindingVector)->BindingH[c]);
-  HeapFree(GetProcessHeap(), 0, *BindingVector);
+  free(*BindingVector);
   *BindingVector = NULL;
   return RPC_S_OK;
 }
@@ -999,8 +995,8 @@ RPC_STATUS RPC_ENTRY RpcBindingCopy(
   DestBinding->Protseq = RPCRT4_strndupA(SrcBinding->Protseq, -1);
   DestBinding->NetworkAddr = RPCRT4_strndupA(SrcBinding->NetworkAddr, -1);
   DestBinding->Endpoint = RPCRT4_strndupA(SrcBinding->Endpoint, -1);
-  DestBinding->NetworkOptions = RPCRT4_strdupW(SrcBinding->NetworkOptions);
-  DestBinding->CookieAuth = RPCRT4_strdupW(SrcBinding->CookieAuth);
+  DestBinding->NetworkOptions = wcsdup(SrcBinding->NetworkOptions);
+  DestBinding->CookieAuth = wcsdup(SrcBinding->CookieAuth);
   if (SrcBinding->Assoc) SrcBinding->Assoc->refs++;
   DestBinding->Assoc = SrcBinding->Assoc;
 
@@ -1022,7 +1018,7 @@ RPC_STATUS RPC_ENTRY RpcBindingReset(RPC_BINDING_HANDLE Binding)
 
     TRACE("(%p)\n", Binding);
 
-    RPCRT4_strfree(bind->Endpoint);
+    free(bind->Endpoint);
     bind->Endpoint = NULL;
     if (bind->Assoc) RpcAssoc_Release(bind->Assoc);
     bind->Assoc = NULL;
@@ -1115,7 +1111,7 @@ RPC_STATUS RpcAuthInfo_Create(ULONG AuthnLevel, ULONG AuthnSvc,
                               RPC_AUTH_IDENTITY_HANDLE identity,
                               RpcAuthInfo **ret)
 {
-    RpcAuthInfo *AuthInfo = HeapAlloc(GetProcessHeap(), 0, sizeof(*AuthInfo));
+    RpcAuthInfo *AuthInfo = malloc(sizeof(*AuthInfo));
     if (!AuthInfo)
         return RPC_S_OUT_OF_MEMORY;
 
@@ -1133,10 +1129,10 @@ RPC_STATUS RpcAuthInfo_Create(ULONG AuthnLevel, ULONG AuthnSvc,
     if (identity && has_nt_auth_identity(AuthnSvc))
     {
         const SEC_WINNT_AUTH_IDENTITY_W *nt_identity = identity;
-        AuthInfo->nt_identity = HeapAlloc(GetProcessHeap(), 0, sizeof(*AuthInfo->nt_identity));
+        AuthInfo->nt_identity = malloc(sizeof(*AuthInfo->nt_identity));
         if (!AuthInfo->nt_identity)
         {
-            HeapFree(GetProcessHeap(), 0, AuthInfo);
+            free(AuthInfo);
             return RPC_S_OUT_OF_MEMORY;
         }
 
@@ -1161,11 +1157,11 @@ RPC_STATUS RpcAuthInfo_Create(ULONG AuthnLevel, ULONG AuthnSvc,
             (nt_identity->Domain && !AuthInfo->nt_identity->Domain) ||
             (nt_identity->Password && !AuthInfo->nt_identity->Password))
         {
-            HeapFree(GetProcessHeap(), 0, AuthInfo->nt_identity->User);
-            HeapFree(GetProcessHeap(), 0, AuthInfo->nt_identity->Domain);
-            HeapFree(GetProcessHeap(), 0, AuthInfo->nt_identity->Password);
-            HeapFree(GetProcessHeap(), 0, AuthInfo->nt_identity);
-            HeapFree(GetProcessHeap(), 0, AuthInfo);
+            free(AuthInfo->nt_identity->User);
+            free(AuthInfo->nt_identity->Domain);
+            free(AuthInfo->nt_identity->Password);
+            free(AuthInfo->nt_identity);
+            free(AuthInfo);
             return RPC_S_OUT_OF_MEMORY;
         }
     }
@@ -1189,13 +1185,13 @@ ULONG RpcAuthInfo_Release(RpcAuthInfo *AuthInfo)
         FreeCredentialsHandle(&AuthInfo->cred);
         if (AuthInfo->nt_identity)
         {
-            HeapFree(GetProcessHeap(), 0, AuthInfo->nt_identity->User);
-            HeapFree(GetProcessHeap(), 0, AuthInfo->nt_identity->Domain);
-            HeapFree(GetProcessHeap(), 0, AuthInfo->nt_identity->Password);
-            HeapFree(GetProcessHeap(), 0, AuthInfo->nt_identity);
+            free(AuthInfo->nt_identity->User);
+            free(AuthInfo->nt_identity->Domain);
+            free(AuthInfo->nt_identity->Password);
+            free(AuthInfo->nt_identity);
         }
-        HeapFree(GetProcessHeap(), 0, AuthInfo->server_principal_name);
-        HeapFree(GetProcessHeap(), 0, AuthInfo);
+        free(AuthInfo->server_principal_name);
+        free(AuthInfo);
     }
 
     return refs;
@@ -1244,13 +1240,13 @@ BOOL RpcAuthInfo_IsEqual(const RpcAuthInfo *AuthInfo1, const RpcAuthInfo *AuthIn
 
 static RPC_STATUS RpcQualityOfService_Create(const RPC_SECURITY_QOS *qos_src, BOOL unicode, RpcQualityOfService **qos_dst)
 {
-    RpcQualityOfService *qos = HeapAlloc(GetProcessHeap(), 0, sizeof(*qos));
+    RpcQualityOfService *qos = malloc(sizeof(*qos));
 
     if (!qos)
         return RPC_S_OUT_OF_RESOURCES;
 
     qos->refs = 1;
-    qos->qos = HeapAlloc(GetProcessHeap(), 0, sizeof(*qos->qos));
+    qos->qos = malloc(sizeof(*qos->qos));
     if (!qos->qos) goto error;
     qos->qos->Version = qos_src->Version;
     qos->qos->Capabilities = qos_src->Capabilities;
@@ -1267,7 +1263,7 @@ static RPC_STATUS RpcQualityOfService_Create(const RPC_SECURITY_QOS *qos_src, BO
             const RPC_HTTP_TRANSPORT_CREDENTIALS_W *http_credentials_src = qos_src2->u.HttpCredentials;
             RPC_HTTP_TRANSPORT_CREDENTIALS_W *http_credentials_dst;
 
-            http_credentials_dst = HeapAlloc(GetProcessHeap(), 0, sizeof(*http_credentials_dst));
+            http_credentials_dst = malloc(sizeof(*http_credentials_dst));
             qos->qos->u.HttpCredentials = http_credentials_dst;
             if (!http_credentials_dst) goto error;
             http_credentials_dst->TransportCredentials = NULL;
@@ -1279,7 +1275,7 @@ static RPC_STATUS RpcQualityOfService_Create(const RPC_SECURITY_QOS *qos_src, BO
             if (http_credentials_src->TransportCredentials)
             {
                 SEC_WINNT_AUTH_IDENTITY_W *cred_dst;
-                cred_dst = http_credentials_dst->TransportCredentials = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cred_dst));
+                cred_dst = http_credentials_dst->TransportCredentials = calloc(1, sizeof(*cred_dst));
                 if (!cred_dst) goto error;
                 cred_dst->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
                 if (unicode)
@@ -1298,9 +1294,9 @@ static RPC_STATUS RpcQualityOfService_Create(const RPC_SECURITY_QOS *qos_src, BO
                     cred_dst->UserLength = MultiByteToWideChar(CP_ACP, 0, (char *)cred_src->User, cred_src->UserLength, NULL, 0);
                     cred_dst->DomainLength = MultiByteToWideChar(CP_ACP, 0, (char *)cred_src->Domain, cred_src->DomainLength, NULL, 0);
                     cred_dst->PasswordLength = MultiByteToWideChar(CP_ACP, 0, (char *)cred_src->Password, cred_src->PasswordLength, NULL, 0);
-                    cred_dst->User = HeapAlloc(GetProcessHeap(), 0, cred_dst->UserLength * sizeof(WCHAR));
-                    cred_dst->Password = HeapAlloc(GetProcessHeap(), 0, cred_dst->PasswordLength * sizeof(WCHAR));
-                    cred_dst->Domain = HeapAlloc(GetProcessHeap(), 0, cred_dst->DomainLength * sizeof(WCHAR));
+                    cred_dst->User = malloc(cred_dst->UserLength * sizeof(WCHAR));
+                    cred_dst->Password = malloc(cred_dst->PasswordLength * sizeof(WCHAR));
+                    cred_dst->Domain = malloc(cred_dst->DomainLength * sizeof(WCHAR));
                     if (!cred_dst->Password || !cred_dst->Domain) goto error;
                     MultiByteToWideChar(CP_ACP, 0, (char *)cred_src->User, cred_src->UserLength, cred_dst->User, cred_dst->UserLength);
                     MultiByteToWideChar(CP_ACP, 0, (char *)cred_src->Domain, cred_src->DomainLength, cred_dst->Domain, cred_dst->DomainLength);
@@ -1309,7 +1305,7 @@ static RPC_STATUS RpcQualityOfService_Create(const RPC_SECURITY_QOS *qos_src, BO
             }
             if (http_credentials_src->NumberOfAuthnSchemes)
             {
-                http_credentials_dst->AuthnSchemes = HeapAlloc(GetProcessHeap(), 0, http_credentials_src->NumberOfAuthnSchemes * sizeof(*http_credentials_dst->AuthnSchemes));
+                http_credentials_dst->AuthnSchemes = malloc(http_credentials_src->NumberOfAuthnSchemes * sizeof(*http_credentials_dst->AuthnSchemes));
                 if (!http_credentials_dst->AuthnSchemes) goto error;
                 memcpy(http_credentials_dst->AuthnSchemes, http_credentials_src->AuthnSchemes, http_credentials_src->NumberOfAuthnSchemes * sizeof(*http_credentials_dst->AuthnSchemes));
             }
@@ -1337,18 +1333,18 @@ error:
         {
             if (qos->qos->u.HttpCredentials->TransportCredentials)
             {
-                HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->TransportCredentials->User);
-                HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->TransportCredentials->Domain);
-                HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->TransportCredentials->Password);
-                HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->TransportCredentials);
+                free(qos->qos->u.HttpCredentials->TransportCredentials->User);
+                free(qos->qos->u.HttpCredentials->TransportCredentials->Domain);
+                free(qos->qos->u.HttpCredentials->TransportCredentials->Password);
+                free(qos->qos->u.HttpCredentials->TransportCredentials);
             }
-            HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->AuthnSchemes);
-            HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->ServerCertificateSubject);
-            HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials);
+            free(qos->qos->u.HttpCredentials->AuthnSchemes);
+            free(qos->qos->u.HttpCredentials->ServerCertificateSubject);
+            free(qos->qos->u.HttpCredentials);
         }
-        HeapFree(GetProcessHeap(), 0, qos->qos);
+        free(qos->qos);
     }
-    HeapFree(GetProcessHeap(), 0, qos);
+    free(qos);
     return RPC_S_OUT_OF_RESOURCES;
 }
 
@@ -1367,17 +1363,17 @@ ULONG RpcQualityOfService_Release(RpcQualityOfService *qos)
         {
             if (qos->qos->u.HttpCredentials->TransportCredentials)
             {
-                HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->TransportCredentials->User);
-                HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->TransportCredentials->Domain);
-                HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->TransportCredentials->Password);
-                HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->TransportCredentials);
+                free(qos->qos->u.HttpCredentials->TransportCredentials->User);
+                free(qos->qos->u.HttpCredentials->TransportCredentials->Domain);
+                free(qos->qos->u.HttpCredentials->TransportCredentials->Password);
+                free(qos->qos->u.HttpCredentials->TransportCredentials);
             }
-            HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->AuthnSchemes);
-            HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials->ServerCertificateSubject);
-            HeapFree(GetProcessHeap(), 0, qos->qos->u.HttpCredentials);
+            free(qos->qos->u.HttpCredentials->AuthnSchemes);
+            free(qos->qos->u.HttpCredentials->ServerCertificateSubject);
+            free(qos->qos->u.HttpCredentials);
         }
-        HeapFree(GetProcessHeap(), 0, qos->qos);
-        HeapFree(GetProcessHeap(), 0, qos);
+        free(qos->qos);
+        free(qos);
     }
     return refs;
 }
@@ -1521,7 +1517,7 @@ RpcBindingInqAuthInfoExW( RPC_BINDING_HANDLE Binding, RPC_WSTR *ServerPrincName,
     {
         if (bind->AuthInfo->server_principal_name)
         {
-            *ServerPrincName = RPCRT4_strdupW(bind->AuthInfo->server_principal_name);
+            *ServerPrincName = wcsdup(bind->AuthInfo->server_principal_name);
             if (!*ServerPrincName) return RPC_S_OUT_OF_MEMORY;
         }
         else *ServerPrincName = NULL;
@@ -1650,8 +1646,8 @@ RpcBindingServerFromClient(RPC_BINDING_HANDLE ClientBinding, RPC_BINDING_HANDLE*
         return RPC_S_INVALID_BINDING;
 
     RPCRT4_AllocBinding(&NewBinding, TRUE);
-    NewBinding->Protseq = RPCRT4_strdupA(bind->Protseq);
-    NewBinding->NetworkAddr = RPCRT4_strdupA(bind->NetworkAddr);
+    NewBinding->Protseq = strdup(bind->Protseq);
+    NewBinding->NetworkAddr = strdup(bind->NetworkAddr);
 
     *ServerBinding = NewBinding;
 
@@ -1898,7 +1894,7 @@ RpcBindingSetAuthInfoExW( RPC_BINDING_HANDLE Binding, RPC_WSTR ServerPrincName,
                            AuthIdentity, &new_auth_info);
     if (r == RPC_S_OK)
     {
-      new_auth_info->server_principal_name = RPCRT4_strdupW(ServerPrincName);
+      new_auth_info->server_principal_name = wcsdup(ServerPrincName);
       if (!ServerPrincName || new_auth_info->server_principal_name)
       {
         if (bind->AuthInfo) RpcAuthInfo_Release(bind->AuthInfo);
@@ -1961,10 +1957,10 @@ RPC_STATUS WINAPI RpcBindingSetOption(RPC_BINDING_HANDLE BindingHandle, ULONG Op
         int len = MultiByteToWideChar(CP_ACP, 0, cookie->Buffer, cookie->BufferSize, NULL, 0);
         WCHAR *str;
 
-        if (!(str = HeapAlloc(GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR)))) return RPC_S_OUT_OF_MEMORY;
+        if (!(str = malloc((len + 1) * sizeof(WCHAR)))) return RPC_S_OUT_OF_MEMORY;
         MultiByteToWideChar(CP_ACP, 0, cookie->Buffer, cookie->BufferSize, str, len);
         str[len] = 0;
-        HeapFree(GetProcessHeap(), 0, binding->CookieAuth);
+        free(binding->CookieAuth);
         binding->CookieAuth = str;
         break;
     }
diff --git a/dlls/rpcrt4/rpc_binding.h b/dlls/rpcrt4/rpc_binding.h
index c79451f4894..d742c68eda9 100644
--- a/dlls/rpcrt4/rpc_binding.h
+++ b/dlls/rpcrt4/rpc_binding.h
@@ -147,10 +147,6 @@ LPSTR RPCRT4_strndupA(LPCSTR src, INT len) DECLSPEC_HIDDEN;
 LPWSTR RPCRT4_strndupW(LPCWSTR src, INT len) DECLSPEC_HIDDEN;
 LPSTR RPCRT4_strdupWtoA(LPCWSTR src) DECLSPEC_HIDDEN;
 LPWSTR RPCRT4_strdupAtoW(LPCSTR src) DECLSPEC_HIDDEN;
-void RPCRT4_strfree(LPSTR src) DECLSPEC_HIDDEN;
-
-#define RPCRT4_strdupA(x) RPCRT4_strndupA((x),-1)
-#define RPCRT4_strdupW(x) RPCRT4_strndupW((x),-1)
 
 RPC_STATUS RpcAuthInfo_Create(ULONG AuthnLevel, ULONG AuthnSvc, CredHandle cred, TimeStamp exp, ULONG cbMaxToken, RPC_AUTH_IDENTITY_HANDLE identity, RpcAuthInfo **ret) DECLSPEC_HIDDEN;
 ULONG RpcAuthInfo_AddRef(RpcAuthInfo *AuthInfo) DECLSPEC_HIDDEN;
diff --git a/dlls/rpcrt4/rpc_epmap.c b/dlls/rpcrt4/rpc_epmap.c
index 2ef5f6a8860..1c1fa84eb75 100644
--- a/dlls/rpcrt4/rpc_epmap.c
+++ b/dlls/rpcrt4/rpc_epmap.c
@@ -216,14 +216,14 @@ static RPC_STATUS epm_register( RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR *Bindin
 
   if (!BindingVector->Count) return RPC_S_OK;
 
-  entries = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*entries) * BindingVector->Count * (UuidVector ? UuidVector->Count : 1));
+  entries = calloc(BindingVector->Count * (UuidVector ? UuidVector->Count : 1), sizeof(*entries));
   if (!entries)
       return RPC_S_OUT_OF_MEMORY;
 
   status = get_epm_handle_server(&handle);
   if (status != RPC_S_OK)
   {
-    HeapFree(GetProcessHeap(), 0, entries);
+    free(entries);
     return status;
   }
 
@@ -284,7 +284,7 @@ static RPC_STATUS epm_register( RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR *Bindin
           I_RpcFree(entries[i*(UuidVector ? UuidVector->Count : 1) + j].tower);
   }
 
-  HeapFree(GetProcessHeap(), 0, entries);
+  free(entries);
 
   return status;
 }
@@ -318,7 +318,7 @@ RPC_STATUS WINAPI RpcEpRegisterW( RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR *Bind
 
   status = epm_register(IfSpec, BindingVector, UuidVector, (RPC_CSTR)annA, TRUE);
 
-  HeapFree(GetProcessHeap(), 0, annA);
+  free(annA);
   return status;
 }
 
@@ -333,7 +333,7 @@ RPC_STATUS WINAPI RpcEpRegisterNoReplaceW( RPC_IF_HANDLE IfSpec, RPC_BINDING_VEC
 
   status = epm_register(IfSpec, BindingVector, UuidVector, (RPC_CSTR)annA, FALSE);
 
-  HeapFree(GetProcessHeap(), 0, annA);
+  free(annA);
   return status;
 }
 
@@ -362,14 +362,14 @@ RPC_STATUS WINAPI RpcEpUnregister( RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR *Bin
       TRACE(" obj[%ld]=%s\n", i, debugstr_guid(UuidVector->Uuid[i]));
   }
 
-  entries = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*entries) * BindingVector->Count * (UuidVector ? UuidVector->Count : 1));
+  entries = calloc(BindingVector->Count * (UuidVector ? UuidVector->Count : 1), sizeof(*entries));
   if (!entries)
       return RPC_S_OUT_OF_MEMORY;
 
   status = get_epm_handle_server(&handle);
   if (status != RPC_S_OK)
   {
-    HeapFree(GetProcessHeap(), 0, entries);
+    free(entries);
     return status;
   }
 
@@ -419,7 +419,7 @@ RPC_STATUS WINAPI RpcEpUnregister( RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR *Bin
           I_RpcFree(entries[i*(UuidVector ? UuidVector->Count : 1) + j].tower);
   }
 
-  HeapFree(GetProcessHeap(), 0, entries);
+  free(entries);
 
   return status;
 }
@@ -655,10 +655,10 @@ RPC_STATUS WINAPI TowerConstruct(
 
 void __RPC_FAR * __RPC_USER MIDL_user_allocate(SIZE_T len)
 {
-    return HeapAlloc(GetProcessHeap(), 0, len);
+    return malloc(len);
 }
 
 void __RPC_USER MIDL_user_free(void __RPC_FAR * ptr)
 {
-    HeapFree(GetProcessHeap(), 0, ptr);
+    free(ptr);
 }
diff --git a/dlls/rpcrt4/rpc_message.c b/dlls/rpcrt4/rpc_message.c
index 4a6ebf434f2..a799064e8e9 100644
--- a/dlls/rpcrt4/rpc_message.c
+++ b/dlls/rpcrt4/rpc_message.c
@@ -22,6 +22,7 @@
 
 #include <stdarg.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 
 #include "windef.h"
@@ -131,8 +132,7 @@ static RpcPktHdr *RPCRT4_BuildRequestHeader(ULONG DataRepresentation,
   RPC_STATUS status;
 
   has_object = (ObjectUuid != NULL && !UuidIsNil(ObjectUuid, &status));
-  header = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-                     sizeof(header->request) + (has_object ? sizeof(UUID) : 0));
+  header = calloc(1, sizeof(header->request) + (has_object ? sizeof(UUID) : 0));
   if (header == NULL) {
     return NULL;
   }
@@ -155,7 +155,7 @@ RpcPktHdr *RPCRT4_BuildResponseHeader(ULONG DataRepresentation, ULONG BufferLeng
 {
   RpcPktHdr *header;
 
-  header = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(header->response));
+  header = calloc(1, sizeof(header->response));
   if (header == NULL) {
     return NULL;
   }
@@ -171,7 +171,7 @@ RpcPktHdr *RPCRT4_BuildFaultHeader(ULONG DataRepresentation, RPC_STATUS Status)
 {
   RpcPktHdr *header;
 
-  header = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(header->fault));
+  header = calloc(1, sizeof(header->fault));
   if (header == NULL) {
     return NULL;
   }
@@ -193,8 +193,7 @@ RpcPktHdr *RPCRT4_BuildBindHeader(ULONG DataRepresentation,
   RpcPktHdr *header;
   RpcContextElement *ctxt_elem;
 
-  header = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-                     sizeof(header->bind) + FIELD_OFFSET(RpcContextElement, transfer_syntaxes[1]));
+  header = calloc(1, sizeof(header->bind) + FIELD_OFFSET(RpcContextElement, transfer_syntaxes[1]));
   if (header == NULL) {
     return NULL;
   }
@@ -217,8 +216,7 @@ static RpcPktHdr *RPCRT4_BuildAuthHeader(ULONG DataRepresentation)
 {
   RpcPktHdr *header;
 
-  header = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-                     sizeof(header->auth3));
+  header = calloc(1, sizeof(header->auth3));
   if (header == NULL)
     return NULL;
 
@@ -235,7 +233,7 @@ RpcPktHdr *RPCRT4_BuildBindNackHeader(ULONG DataRepresentation,
 {
   RpcPktHdr *header;
 
-  header = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, FIELD_OFFSET(RpcPktHdr, bind_nack.protocols[1]));
+  header = calloc(1, FIELD_OFFSET(RpcPktHdr, bind_nack.protocols[1]));
   if (header == NULL) {
     return NULL;
   }
@@ -267,7 +265,7 @@ RpcPktHdr *RPCRT4_BuildBindAckHeader(ULONG DataRepresentation,
                 ROUND_UP(FIELD_OFFSET(RpcAddressString, string[strlen(ServerAddress) + 1]), 4) +
                 FIELD_OFFSET(RpcResultList, results[ResultCount]);
 
-  header = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, header_size);
+  header = calloc(1, header_size);
   if (header == NULL) {
     return NULL;
   }
@@ -295,7 +293,7 @@ RpcPktHdr *RPCRT4_BuildHttpHeader(ULONG DataRepresentation,
 {
   RpcPktHdr *header;
 
-  header = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(header->http) + payload_size);
+  header = calloc(1, sizeof(header->http) + payload_size);
   if (header == NULL) {
       ERR("failed to allocate memory\n");
     return NULL;
@@ -400,11 +398,6 @@ RpcPktHdr *RPCRT4_BuildHttpFlowControlHeader(BOOL server, ULONG bytes_transmitte
   return header;
 }
 
-VOID RPCRT4_FreeHeader(RpcPktHdr *Header)
-{
-  HeapFree(GetProcessHeap(), 0, Header);
-}
-
 NCA_STATUS RPC2NCA_STATUS(RPC_STATUS status)
 {
     switch (status)
@@ -806,7 +799,7 @@ RPC_STATUS RPCRT4_SendWithAuth(RpcConnection *Connection, RpcPktHdr *Header,
         hdr_size + alen;
     }
 
-    pkt = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, Header->common.frag_len);
+    pkt = calloc(1, Header->common.frag_len);
 
     memcpy(pkt, Header, hdr_size);
 
@@ -839,7 +832,7 @@ RPC_STATUS RPCRT4_SendWithAuth(RpcConnection *Connection, RpcPktHdr *Header,
             (unsigned char *)(auth_hdr + 1), Header->common.auth_len);
         if (status != RPC_S_OK)
         {
-          HeapFree(GetProcessHeap(), 0, pkt);
+          free(pkt);
           RPCRT4_SetThreadCurrentConnection(NULL);
           return status;
         }
@@ -848,7 +841,7 @@ RPC_STATUS RPCRT4_SendWithAuth(RpcConnection *Connection, RpcPktHdr *Header,
 
 write:
     count = rpcrt4_conn_write(Connection, pkt, Header->common.frag_len);
-    HeapFree(GetProcessHeap(), 0, pkt);
+    free(pkt);
     if (count<0) {
       WARN("rpcrt4_conn_write failed (auth)\n");
       RPCRT4_SetThreadCurrentConnection(NULL);
@@ -1001,7 +994,7 @@ RPC_STATUS RPCRT4_ClientConnectionAuth(RpcConnection* conn, BYTE *challenge,
 
   status = rpcrt4_conn_authorize(conn, FALSE, challenge, count, NULL, &out_len);
   if (status) return status;
-  out_buffer = HeapAlloc(GetProcessHeap(), 0, out_len);
+  out_buffer = malloc(out_len);
   if (!out_buffer) return RPC_S_OUT_OF_RESOURCES;
   status = rpcrt4_conn_authorize(conn, FALSE, challenge, count, out_buffer, &out_len);
   if (status) return status;
@@ -1013,8 +1006,8 @@ RPC_STATUS RPCRT4_ClientConnectionAuth(RpcConnection* conn, BYTE *challenge,
   else
     status = RPC_S_OUT_OF_RESOURCES;
 
-  HeapFree(GetProcessHeap(), 0, out_buffer);
-  RPCRT4_FreeHeader(resp_hdr);
+  free(out_buffer);
+  free(resp_hdr);
 
   return status;
 }
@@ -1086,7 +1079,7 @@ RPC_STATUS RPCRT4_ServerConnectionAuth(RpcConnection* conn,
         auth_length_in - sizeof(RpcAuthVerifier), NULL, &out_size);
     if (status) return status;
 
-    out_buffer = HeapAlloc(GetProcessHeap(), 0, out_size);
+    out_buffer = malloc(out_size);
     if (!out_buffer) return RPC_S_OUT_OF_RESOURCES;
 
     status = rpcrt4_conn_authorize(
@@ -1094,7 +1087,7 @@ RPC_STATUS RPCRT4_ServerConnectionAuth(RpcConnection* conn,
         auth_length_in - sizeof(RpcAuthVerifier), out_buffer, &out_size);
     if (status != RPC_S_OK)
     {
-        HeapFree(GetProcessHeap(), 0, out_buffer);
+        free(out_buffer);
         return status;
     }
 
@@ -1102,7 +1095,7 @@ RPC_STATUS RPCRT4_ServerConnectionAuth(RpcConnection* conn,
     {
         ERR("expected authentication to be complete but SSP returned data of "
             "%u bytes to be sent back to client\n", out_size);
-        HeapFree(GetProcessHeap(), 0, out_buffer);
+        free(out_buffer);
         return RPC_S_SEC_PKG_ERROR;
     }
     else
@@ -1199,7 +1192,7 @@ RPC_STATUS RPCRT4_default_inquire_auth_client(
     }
     if (server_princ_name)
     {
-        *server_princ_name = RPCRT4_strdupW(conn->AuthInfo->server_principal_name);
+        *server_princ_name = wcsdup(conn->AuthInfo->server_principal_name);
         if (!*server_princ_name) return ERROR_OUTOFMEMORY;
     }
     if (authn_level) *authn_level = conn->AuthInfo->AuthnLevel;
@@ -1235,7 +1228,7 @@ RPC_STATUS RPCRT4_Send(RpcConnection *Connection, RpcPktHdr *Header,
       r = rpcrt4_conn_authorize(Connection, TRUE, NULL, 0, NULL, &out_size);
       if (r != RPC_S_OK) return r;
 
-      out_buffer = HeapAlloc(GetProcessHeap(), 0, out_size);
+      out_buffer = malloc(out_size);
       if (!out_buffer) return RPC_S_OUT_OF_RESOURCES;
 
       /* tack on a negotiate packet */
@@ -1243,7 +1236,7 @@ RPC_STATUS RPCRT4_Send(RpcConnection *Connection, RpcPktHdr *Header,
       if (r == RPC_S_OK)
           r = RPCRT4_SendWithAuth(Connection, Header, Buffer, BufferLength, out_buffer, out_size);
 
-      HeapFree(GetProcessHeap(), 0, out_buffer);
+      free(out_buffer);
   }
   else
     r = RPCRT4_SendWithAuth(Connection, Header, Buffer, BufferLength, NULL, 0);
@@ -1315,7 +1308,7 @@ static RPC_STATUS RPCRT4_default_receive_fragment(RpcConnection *Connection, Rpc
     goto fail;
   }
 
-  *Header = HeapAlloc(GetProcessHeap(), 0, hdr_length);
+  *Header = malloc(hdr_length);
   memcpy(*Header, &common_hdr, sizeof(common_hdr));
 
   /* read the rest of packet header */
@@ -1328,7 +1321,7 @@ static RPC_STATUS RPCRT4_default_receive_fragment(RpcConnection *Connection, Rpc
 
   if (common_hdr.frag_len - hdr_length)
   {
-    *Payload = HeapAlloc(GetProcessHeap(), 0, common_hdr.frag_len - hdr_length);
+    *Payload = malloc(common_hdr.frag_len - hdr_length);
     if (!*Payload)
     {
       status = RPC_S_OUT_OF_RESOURCES;
@@ -1351,9 +1344,9 @@ static RPC_STATUS RPCRT4_default_receive_fragment(RpcConnection *Connection, Rpc
 
 fail:
   if (status != RPC_S_OK) {
-    RPCRT4_FreeHeader(*Header);
+    free(*Header);
     *Header = NULL;
-    HeapFree(GetProcessHeap(), 0, *Payload);
+    free(*Payload);
     *Payload = NULL;
   }
   return status;
@@ -1426,7 +1419,7 @@ RPC_STATUS RPCRT4_ReceiveWithAuth(RpcConnection *Connection, RpcPktHdr **Header,
   first_flag = RPC_FLG_FIRST;
   auth_length = (*Header)->common.auth_len;
   if (auth_length) {
-    auth_data = HeapAlloc(GetProcessHeap(), 0, RPC_AUTH_VERIFIER_LEN(&(*Header)->common));
+    auth_data = malloc(RPC_AUTH_VERIFIER_LEN(&(*Header)->common));
     if (!auth_data) {
       status = RPC_S_OUT_OF_RESOURCES;
       goto fail;
@@ -1507,10 +1500,10 @@ RPC_STATUS RPCRT4_ReceiveWithAuth(RpcConnection *Connection, RpcPktHdr **Header,
 
       if (*Header != CurrentHeader)
       {
-          RPCRT4_FreeHeader(CurrentHeader);
+          free(CurrentHeader);
           CurrentHeader = NULL;
       }
-      HeapFree(GetProcessHeap(), 0, payload);
+      free(payload);
       payload = NULL;
 
       status = RPCRT4_receive_fragment(Connection, &CurrentHeader, &payload);
@@ -1529,11 +1522,11 @@ RPC_STATUS RPCRT4_ReceiveWithAuth(RpcConnection *Connection, RpcPktHdr **Header,
 fail:
   RPCRT4_SetThreadCurrentConnection(NULL);
   if (CurrentHeader != *Header)
-    RPCRT4_FreeHeader(CurrentHeader);
+    free(CurrentHeader);
   if (status != RPC_S_OK) {
     I_RpcFree(pMsg->Buffer);
     pMsg->Buffer = NULL;
-    RPCRT4_FreeHeader(*Header);
+    free(*Header);
     *Header = NULL;
   }
   if (auth_data_out && status == RPC_S_OK) {
@@ -1541,8 +1534,8 @@ fail:
     *auth_data_out = auth_data;
   }
   else
-    HeapFree(GetProcessHeap(), 0, auth_data);
-  HeapFree(GetProcessHeap(), 0, payload);
+    free(auth_data);
+  free(payload);
   return status;
 }
 
@@ -1672,7 +1665,7 @@ RPC_STATUS WINAPI I_RpcGetBuffer(PRPC_MESSAGE pMsg)
 static RPC_STATUS I_RpcReAllocateBuffer(PRPC_MESSAGE pMsg)
 {
   TRACE("(%p): BufferLength=%d\n", pMsg, pMsg->BufferLength);
-  pMsg->Buffer = HeapReAlloc(GetProcessHeap(), 0, pMsg->Buffer, pMsg->BufferLength);
+  pMsg->Buffer = realloc(pMsg->Buffer, pMsg->BufferLength);
 
   TRACE("Buffer=%p\n", pMsg->Buffer);
   return pMsg->Buffer ? RPC_S_OK : ERROR_OUTOFMEMORY;
@@ -1811,7 +1804,7 @@ RPC_STATUS WINAPI I_RpcSend(PRPC_MESSAGE pMsg)
 
       hdr->common.call_id = conn->NextCallId++;
       status = RPCRT4_Send(conn, hdr, pMsg->Buffer, pMsg->BufferLength);
-      RPCRT4_FreeHeader(hdr);
+      free(hdr);
       if (status == RPC_S_OK || conn->server || !from_cache)
           break;
 
@@ -1887,11 +1880,11 @@ RPC_STATUS WINAPI I_RpcReceive(PRPC_MESSAGE pMsg)
   }
 
   /* success */
-  RPCRT4_FreeHeader(hdr);
+  free(hdr);
   return status;
 
 fail:
-  RPCRT4_FreeHeader(hdr);
+  free(hdr);
   RPCRT4_ReleaseConnection(conn);
   pMsg->ReservedForRuntime = NULL;
   return status;
diff --git a/dlls/rpcrt4/rpc_message.h b/dlls/rpcrt4/rpc_message.h
index a3729cc784d..964d1162427 100644
--- a/dlls/rpcrt4/rpc_message.h
+++ b/dlls/rpcrt4/rpc_message.h
@@ -33,7 +33,6 @@ RpcPktHdr *RPCRT4_BuildBindAckHeader(ULONG DataRepresentation, unsigned short Ma
 RpcPktHdr *RPCRT4_BuildHttpHeader(ULONG DataRepresentation, unsigned short flags, unsigned short num_data_items, unsigned int payload_size) DECLSPEC_HIDDEN;
 RpcPktHdr *RPCRT4_BuildHttpConnectHeader(int out_pipe, const UUID *connection_uuid, const UUID *pipe_uuid, const UUID *association_uuid) DECLSPEC_HIDDEN;
 RpcPktHdr *RPCRT4_BuildHttpFlowControlHeader(BOOL server, ULONG bytes_transmitted, ULONG flow_control_increment, const UUID *pipe_uuid) DECLSPEC_HIDDEN;
-VOID RPCRT4_FreeHeader(RpcPktHdr *Header) DECLSPEC_HIDDEN;
 RPC_STATUS RPCRT4_Send(RpcConnection *Connection, RpcPktHdr *Header, void *Buffer, unsigned int BufferLength) DECLSPEC_HIDDEN;
 RPC_STATUS RPCRT4_SendWithAuth(RpcConnection *Connection, RpcPktHdr *Header, void *Buffer, unsigned int BufferLength, const void *Auth, unsigned int AuthLength) DECLSPEC_HIDDEN;
 RPC_STATUS RPCRT4_ReceiveWithAuth(RpcConnection *Connection, RpcPktHdr **Header, PRPC_MESSAGE pMsg, unsigned char **auth_data_out, ULONG *auth_length_out) DECLSPEC_HIDDEN;
diff --git a/dlls/rpcrt4/rpc_server.c b/dlls/rpcrt4/rpc_server.c
index 30ff585ad50..41431ebca02 100644
--- a/dlls/rpcrt4/rpc_server.c
+++ b/dlls/rpcrt4/rpc_server.c
@@ -22,6 +22,7 @@
 
 #include <stdarg.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include <string.h>
 #include <assert.h>
 
@@ -164,7 +165,7 @@ static void RPCRT4_release_server_interface(RpcServerInterface *sif)
      * CallsCompletedEvent is set */
     if (sif->CallsCompletedEvent)
       SetEvent(sif->CallsCompletedEvent);
-    HeapFree(GetProcessHeap(), 0, sif);
+    free(sif);
   }
 }
 
@@ -234,8 +235,7 @@ static RPC_STATUS process_bind_packet_no_send(
     return RPC_S_INVALID_BOUND;
   }
 
-  results = HeapAlloc(GetProcessHeap(), 0,
-                      hdr->num_elements * sizeof(*results));
+  results = malloc(hdr->num_elements * sizeof(*results));
   if (!results)
     return RPC_S_OUT_OF_RESOURCES;
 
@@ -290,7 +290,7 @@ static RPC_STATUS process_bind_packet_no_send(
   status = RPCRT4_MakeBinding(&conn->server_binding, conn);
   if (status != RPC_S_OK)
   {
-      HeapFree(GetProcessHeap(), 0, results);
+      free(results);
       return status;
   }
 
@@ -301,7 +301,7 @@ static RPC_STATUS process_bind_packet_no_send(
                                          &conn->server_binding->Assoc);
   if (status != RPC_S_OK)
   {
-      HeapFree(GetProcessHeap(), 0, results);
+      free(results);
       return status;
   }
 
@@ -313,7 +313,7 @@ static RPC_STATUS process_bind_packet_no_send(
                                            auth_length_out);
       if (status != RPC_S_OK)
       {
-          HeapFree(GetProcessHeap(), 0, results);
+          free(results);
           return status;
       }
   }
@@ -324,7 +324,7 @@ static RPC_STATUS process_bind_packet_no_send(
                                             conn->server_binding->Assoc->assoc_group_id,
                                             conn->Endpoint, hdr->num_elements,
                                             results);
-  HeapFree(GetProcessHeap(), 0, results);
+  free(results);
 
   if (*ack_response)
       conn->MaxTransmissionSize = hdr->max_tsize;
@@ -353,7 +353,7 @@ static RPC_STATUS process_bind_packet(RpcConnection *conn, RpcPktBindHdr *hdr,
         status = RPCRT4_SendWithAuth(conn, response, NULL, 0, auth_data_out, auth_length_out);
     else
         status = ERROR_OUTOFMEMORY;
-    RPCRT4_FreeHeader(response);
+    free(response);
 
     return status;
 }
@@ -377,7 +377,7 @@ static RPC_STATUS process_request_packet(RpcConnection *conn, RpcPktRequestHdr *
                                        status);
 
     RPCRT4_Send(conn, response, NULL, 0);
-    RPCRT4_FreeHeader(response);
+    free(response);
     return RPC_S_OK;
   }
 
@@ -394,7 +394,7 @@ static RPC_STATUS process_request_packet(RpcConnection *conn, RpcPktRequestHdr *
                                        NCA_S_UNK_IF);
 
     RPCRT4_Send(conn, response, NULL, 0);
-    RPCRT4_FreeHeader(response);
+    free(response);
     return RPC_S_OK;
   }
   msg->RpcInterfaceInformation = sif->If;
@@ -417,7 +417,7 @@ static RPC_STATUS process_request_packet(RpcConnection *conn, RpcPktRequestHdr *
                                          NCA_S_OP_RNG_ERROR);
 
       RPCRT4_Send(conn, response, NULL, 0);
-      RPCRT4_FreeHeader(response);
+      free(response);
     }
     func = sif->If->DispatchTable->DispatchTable[msg->ProcNum];
   }
@@ -458,7 +458,7 @@ static RPC_STATUS process_request_packet(RpcConnection *conn, RpcPktRequestHdr *
   if (response) {
     status = RPCRT4_Send(conn, response, exception ? NULL : msg->Buffer,
                          exception ? 0 : msg->BufferLength);
-    RPCRT4_FreeHeader(response);
+    free(response);
   } else
     ERR("out of memory\n");
 
@@ -525,9 +525,9 @@ static void RPCRT4_process_packet(RpcConnection* conn, RpcPktHdr* hdr,
 
   /* clean up */
   I_RpcFree(msg->Buffer);
-  RPCRT4_FreeHeader(hdr);
-  HeapFree(GetProcessHeap(), 0, msg);
-  HeapFree(GetProcessHeap(), 0, auth_data);
+  free(hdr);
+  free(msg);
+  free(auth_data);
 }
 
 static DWORD CALLBACK RPCRT4_worker_thread(LPVOID the_arg)
@@ -536,7 +536,7 @@ static DWORD CALLBACK RPCRT4_worker_thread(LPVOID the_arg)
   RPCRT4_process_packet(pkt->conn, pkt->hdr, pkt->msg, pkt->auth_data,
                         pkt->auth_length);
   RPCRT4_ReleaseConnection(pkt->conn);
-  HeapFree(GetProcessHeap(), 0, pkt);
+  free(pkt);
   return 0;
 }
 
@@ -554,13 +554,13 @@ static DWORD CALLBACK RPCRT4_io_thread(LPVOID the_arg)
   SetThreadDescription(GetCurrentThread(), L"wine_rpcrt4_io");
 
   for (;;) {
-    msg = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(RPC_MESSAGE));
+    msg = calloc(1, sizeof(RPC_MESSAGE));
     if (!msg) break;
 
     status = RPCRT4_ReceiveWithAuth(conn, &hdr, msg, &auth_data, &auth_length);
     if (status != RPC_S_OK) {
       WARN("receive failed with error %lx\n", status);
-      HeapFree(GetProcessHeap(), 0, msg);
+      free(msg);
       break;
     }
 
@@ -575,12 +575,12 @@ static DWORD CALLBACK RPCRT4_io_thread(LPVOID the_arg)
     case PKT_REQUEST:
       TRACE("got request packet\n");
 
-      packet = HeapAlloc(GetProcessHeap(), 0, sizeof(RpcPacket));
+      packet = malloc(sizeof(RpcPacket));
       if (!packet) {
         I_RpcFree(msg->Buffer);
-        RPCRT4_FreeHeader(hdr);
-        HeapFree(GetProcessHeap(), 0, msg);
-        HeapFree(GetProcessHeap(), 0, auth_data);
+        free(hdr);
+        free(msg);
+        free(auth_data);
         goto exit;
       }
       packet->conn = RPCRT4_GrabConnection( conn );
@@ -590,7 +590,7 @@ static DWORD CALLBACK RPCRT4_io_thread(LPVOID the_arg)
       packet->auth_length = auth_length;
       if (!QueueUserWorkItem(RPCRT4_worker_thread, packet, WT_EXECUTELONGFUNCTION)) {
         ERR("couldn't queue work item for worker thread, error was %ld\n", GetLastError());
-        HeapFree(GetProcessHeap(), 0, packet);
+        free(packet);
         status = RPC_S_OUT_OF_RESOURCES;
       } else {
         continue;
@@ -609,9 +609,9 @@ static DWORD CALLBACK RPCRT4_io_thread(LPVOID the_arg)
     }
 
     I_RpcFree(msg->Buffer);
-    RPCRT4_FreeHeader(hdr);
-    HeapFree(GetProcessHeap(), 0, msg);
-    HeapFree(GetProcessHeap(), 0, auth_data);
+    free(hdr);
+    free(msg);
+    free(auth_data);
 
     if (status != RPC_S_OK) {
       WARN("processing packet failed with error %lu\n", status);
@@ -887,9 +887,7 @@ RPC_STATUS WINAPI RpcServerInqBindings( RPC_BINDING_VECTOR** BindingVector )
   }
   if (count) {
     /* export bindings */
-    *BindingVector = HeapAlloc(GetProcessHeap(), 0,
-                              sizeof(RPC_BINDING_VECTOR) +
-                              sizeof(RPC_BINDING_HANDLE)*(count-1));
+    *BindingVector = malloc(sizeof(RPC_BINDING_VECTOR) + sizeof(RPC_BINDING_HANDLE) * (count - 1));
     (*BindingVector)->Count = count;
     count = 0;
     LIST_FOR_EACH_ENTRY(ps, &protseqs, RpcServerProtseq, entry) {
@@ -963,7 +961,7 @@ static RPC_STATUS alloc_serverprotoseq(UINT MaxCalls, const char *Protseq, RpcSe
   if (!*ps)
     return RPC_S_OUT_OF_RESOURCES;
   (*ps)->MaxCalls = MaxCalls;
-  (*ps)->Protseq = RPCRT4_strdupA(Protseq);
+  (*ps)->Protseq = strdup(Protseq);
   (*ps)->ops = ops;
   list_init(&(*ps)->listeners);
   list_init(&(*ps)->connections);
@@ -980,13 +978,13 @@ static RPC_STATUS alloc_serverprotoseq(UINT MaxCalls, const char *Protseq, RpcSe
 /* must be called with server_cs held */
 static void destroy_serverprotoseq(RpcServerProtseq *ps)
 {
-    RPCRT4_strfree(ps->Protseq);
+    free(ps->Protseq);
     ps->cs.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&ps->cs);
     CloseHandle(ps->mgr_mutex);
     CloseHandle(ps->server_ready_event);
     list_remove(&ps->entry);
-    HeapFree(GetProcessHeap(), 0, ps);
+    free(ps);
 }
 
 /* Finds a given protseq or creates a new one if one doesn't already exist */
@@ -1050,13 +1048,13 @@ RPC_STATUS WINAPI RpcServerUseProtseqEpExW( RPC_WSTR Protseq, UINT MaxCalls, RPC
 
   ProtseqA = RPCRT4_strdupWtoA(Protseq);
   status = RPCRT4_get_or_create_serverprotseq(MaxCalls, ProtseqA, &ps);
-  RPCRT4_strfree(ProtseqA);
+  free(ProtseqA);
   if (status != RPC_S_OK)
     return status;
 
   EndpointA = RPCRT4_strdupWtoA(Endpoint);
   status = RPCRT4_use_protseq(ps, EndpointA);
-  RPCRT4_strfree(EndpointA);
+  free(EndpointA);
   return status;
 }
 
@@ -1090,7 +1088,7 @@ RPC_STATUS WINAPI RpcServerUseProtseqW(RPC_WSTR Protseq, unsigned int MaxCalls,
 
   ProtseqA = RPCRT4_strdupWtoA(Protseq);
   status = RPCRT4_get_or_create_serverprotseq(MaxCalls, ProtseqA, &ps);
-  RPCRT4_strfree(ProtseqA);
+  free(ProtseqA);
   if (status != RPC_S_OK)
     return status;
 
@@ -1178,7 +1176,7 @@ RPC_STATUS WINAPI RpcServerRegisterIf3( RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid,
   TRACE(" default manager epv: %p\n", If->DefaultManagerEpv);
   TRACE(" interpreter info: %p\n", If->InterpreterInfo);
 
-  sif = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(RpcServerInterface));
+  sif = calloc(1, sizeof(RpcServerInterface));
   sif->If           = If;
   if (MgrTypeUuid) {
     sif->MgrTypeUuid = *MgrTypeUuid;
@@ -1242,7 +1240,7 @@ RPC_STATUS WINAPI RpcServerUnregisterIf( RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid
   }
 
   if (completed)
-    HeapFree(GetProcessHeap(), 0, cif);
+    free(cif);
   else if (event) {
     /* sif will be freed when the last call is completed, so be careful not to
      * touch that memory here as that could happen before we get here */
@@ -1308,14 +1306,14 @@ RPC_STATUS WINAPI RpcObjectSetType( UUID* ObjUuid, UUID* TypeUuid )
         prev->next = map->next;
       else
         RpcObjTypeMaps = map->next;
-      HeapFree(GetProcessHeap(), 0, map);
+      free(map);
     }
   } else {
     /* ... , fail if we found it ... */
     if (map)
       return RPC_S_ALREADY_REGISTERED;
     /* ... otherwise create a new one and add it in. */
-    map = HeapAlloc(GetProcessHeap(), 0, sizeof(RpcObjTypeMap));
+    map = malloc(sizeof(RpcObjTypeMap));
     map->Object = *ObjUuid;
     map->Type = *TypeUuid;
     map->next = NULL;
@@ -1406,9 +1404,9 @@ void RPCRT4_ServerFreeAllRegisteredAuthInfo(void)
     EnterCriticalSection(&server_auth_info_cs);
     LIST_FOR_EACH_ENTRY_SAFE(auth_info, cursor2, &server_registered_auth_info, struct rpc_server_registered_auth_info, entry)
     {
-        HeapFree(GetProcessHeap(), 0, auth_info->package_name);
-        HeapFree(GetProcessHeap(), 0, auth_info->principal);
-        HeapFree(GetProcessHeap(), 0, auth_info);
+        free(auth_info->package_name);
+        free(auth_info->principal);
+        free(auth_info);
     }
     LeaveCriticalSection(&server_auth_info_cs);
     DeleteCriticalSection(&server_auth_info_cs);
@@ -1430,7 +1428,7 @@ RPC_STATUS WINAPI RpcServerRegisterAuthInfoA( RPC_CSTR ServerPrincName, ULONG Au
 
     status = RpcServerRegisterAuthInfoW(principal_name, AuthnSvc, GetKeyFn, Arg);
 
-    HeapFree(GetProcessHeap(), 0, principal_name);
+    free(principal_name);
     return status;
 }
 
@@ -1452,21 +1450,21 @@ RPC_STATUS WINAPI RpcServerRegisterAuthInfoW( RPC_WSTR ServerPrincName, ULONG Au
     if (status != RPC_S_OK)
         return status;
 
-    package_name = RPCRT4_strdupW(package->Name);
+    package_name = wcsdup(package->Name);
     max_token = package->cbMaxToken;
     FreeContextBuffer(packages);
     if (!package_name)
         return RPC_S_OUT_OF_RESOURCES;
 
-    auth_info = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*auth_info));
+    auth_info = calloc(1, sizeof(*auth_info));
     if (!auth_info) {
-        HeapFree(GetProcessHeap(), 0, package_name);
+        free(package_name);
         return RPC_S_OUT_OF_RESOURCES;
     }
 
-    if (ServerPrincName && !(auth_info->principal = RPCRT4_strdupW(ServerPrincName))) {
-        HeapFree(GetProcessHeap(), 0, package_name);
-        HeapFree(GetProcessHeap(), 0, auth_info);
+    if (ServerPrincName && !(auth_info->principal = wcsdup(ServerPrincName))) {
+        free(package_name);
+        free(auth_info);
         return RPC_S_OUT_OF_RESOURCES;
     }
 
@@ -1513,7 +1511,7 @@ RPC_STATUS RPC_ENTRY RpcServerInqDefaultPrincNameW(ULONG AuthnSvc, RPC_WSTR *Pri
     GetUserNameExW( NameSamCompatible, NULL, &len );
     if (GetLastError() != ERROR_MORE_DATA) return RPC_S_INTERNAL_ERROR;
 
-    if (!(*PrincName = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+    if (!(*PrincName = malloc(len * sizeof(WCHAR))))
         return RPC_S_OUT_OF_MEMORY;
 
     GetUserNameExW( NameSamCompatible, *PrincName, &len );
@@ -1664,7 +1662,7 @@ RPC_STATUS WINAPI RpcMgmtInqStats(RPC_BINDING_HANDLE Binding, RPC_STATS_VECTOR *
 
   FIXME("(%p,%p)\n", Binding, Statistics);
 
-  if ((stats = HeapAlloc(GetProcessHeap(), 0, sizeof(RPC_STATS_VECTOR))))
+  if ((stats = malloc(sizeof(RPC_STATS_VECTOR))))
   {
     stats->Count = 1;
     stats->Stats[0] = 0;
@@ -1683,7 +1681,7 @@ RPC_STATUS WINAPI RpcMgmtStatsVectorFree(RPC_STATS_VECTOR **StatsVector)
 
   if (StatsVector)
   {
-    HeapFree(GetProcessHeap(), 0, *StatsVector);
+    free(*StatsVector);
     *StatsVector = NULL;
   }
   return RPC_S_OK;
diff --git a/dlls/rpcrt4/rpc_transport.c b/dlls/rpcrt4/rpc_transport.c
index 9509b2850b6..62bbd9f2939 100644
--- a/dlls/rpcrt4/rpc_transport.c
+++ b/dlls/rpcrt4/rpc_transport.c
@@ -72,7 +72,7 @@ typedef struct _RpcConnection_np
 
 static RpcConnection *rpcrt4_conn_np_alloc(void)
 {
-  RpcConnection_np *npc = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(RpcConnection_np));
+  RpcConnection_np *npc = calloc(1, sizeof(RpcConnection_np));
   return &npc->common;
 }
 
@@ -314,7 +314,7 @@ static RPC_STATUS rpcrt4_ncacn_np_handoff(RpcConnection *old_conn, RpcConnection
 
   /* Store the local computer name as the NetworkAddr for ncacn_np as long as
    * we don't support named pipes over the network. */
-  new_conn->NetworkAddr = HeapAlloc(GetProcessHeap(), 0, len);
+  new_conn->NetworkAddr = malloc(len);
   if (!GetComputerNameA(new_conn->NetworkAddr, &len))
   {
     ERR("Failed to retrieve the computer name, error %lu\n", GetLastError());
@@ -362,7 +362,7 @@ static RPC_STATUS rpcrt4_ncalrpc_handoff(RpcConnection *old_conn, RpcConnection
   status = rpcrt4_conn_create_pipe(old_conn);
 
   /* Store the local computer name as the NetworkAddr for ncalrpc. */
-  new_conn->NetworkAddr = HeapAlloc(GetProcessHeap(), 0, len);
+  new_conn->NetworkAddr = malloc(len);
   if (!GetComputerNameA(new_conn->NetworkAddr, &len))
   {
     ERR("Failed to retrieve the computer name, error %lu\n", GetLastError());
@@ -631,7 +631,7 @@ typedef struct _RpcServerProtseq_np
 
 static RpcServerProtseq *rpcrt4_protseq_np_alloc(void)
 {
-    RpcServerProtseq_np *ps = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ps));
+    RpcServerProtseq_np *ps = calloc(1, sizeof(*ps));
     if (ps)
         ps->mgr_event = CreateEventW(NULL, FALSE, FALSE, NULL);
     return &ps->common;
@@ -687,10 +687,7 @@ static void *rpcrt4_protseq_np_get_wait_array(RpcServerProtseq *protseq, void *p
     }
     
     /* make array of connections */
-    if (objs)
-        objs = HeapReAlloc(GetProcessHeap(), 0, objs, *count*sizeof(HANDLE));
-    else
-        objs = HeapAlloc(GetProcessHeap(), 0, *count*sizeof(HANDLE));
+    objs = realloc(objs, *count * sizeof(HANDLE));
     if (!objs)
     {
         ERR("couldn't allocate objs\n");
@@ -711,7 +708,7 @@ static void *rpcrt4_protseq_np_get_wait_array(RpcServerProtseq *protseq, void *p
 
 static void rpcrt4_protseq_np_free_wait_array(RpcServerProtseq *protseq, void *array)
 {
-    HeapFree(GetProcessHeap(), 0, array);
+    free(array);
 }
 
 static int rpcrt4_protseq_np_wait_for_new_connection(RpcServerProtseq *protseq, unsigned int count, void *wait_array)
@@ -1116,13 +1113,13 @@ static BOOL rpcrt4_sock_wait_for_send(RpcConnection_tcp *tcpc)
 static RpcConnection *rpcrt4_conn_tcp_alloc(void)
 {
   RpcConnection_tcp *tcpc;
-  tcpc = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(RpcConnection_tcp));
+  tcpc = calloc(1, sizeof(RpcConnection_tcp));
   if (tcpc == NULL)
     return NULL;
   tcpc->sock = -1;
   if (!rpcrt4_sock_wait_init(tcpc))
   {
-    HeapFree(GetProcessHeap(), 0, tcpc);
+    free(tcpc);
     return NULL;
   }
   return &tcpc->common;
@@ -1377,7 +1374,7 @@ static RPC_STATUS rpcrt4_conn_tcp_handoff(RpcConnection *old_conn, RpcConnection
   ioctlsocket(ret, FIONBIO, &nonblocking);
   client->sock = ret;
 
-  client->common.NetworkAddr = HeapAlloc(GetProcessHeap(), 0, INET6_ADDRSTRLEN);
+  client->common.NetworkAddr = malloc(INET6_ADDRSTRLEN);
   ret = getnameinfo((struct sockaddr*)&address, addrsize, client->common.NetworkAddr, INET6_ADDRSTRLEN, NULL, 0, NI_NUMERICHOST);
   if (ret != 0)
   {
@@ -1504,7 +1501,7 @@ typedef struct _RpcServerProtseq_sock
 
 static RpcServerProtseq *rpcrt4_protseq_sock_alloc(void)
 {
-    RpcServerProtseq_sock *ps = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ps));
+    RpcServerProtseq_sock *ps = calloc(1, sizeof(*ps));
     if (ps)
     {
         static BOOL wsa_inited;
@@ -1544,10 +1541,7 @@ static void *rpcrt4_protseq_sock_get_wait_array(RpcServerProtseq *protseq, void
     }
 
     /* make array of connections */
-    if (objs)
-        objs = HeapReAlloc(GetProcessHeap(), 0, objs, *count*sizeof(HANDLE));
-    else
-        objs = HeapAlloc(GetProcessHeap(), 0, *count*sizeof(HANDLE));
+    objs = realloc(objs, *count * sizeof(HANDLE));
     if (!objs)
     {
         ERR("couldn't allocate objs\n");
@@ -1577,7 +1571,7 @@ static void *rpcrt4_protseq_sock_get_wait_array(RpcServerProtseq *protseq, void
 
 static void rpcrt4_protseq_sock_free_wait_array(RpcServerProtseq *protseq, void *array)
 {
-    HeapFree(GetProcessHeap(), 0, array);
+    free(array);
 }
 
 static int rpcrt4_protseq_sock_wait_for_new_connection(RpcServerProtseq *protseq, unsigned int count, void *wait_array)
@@ -1670,10 +1664,10 @@ static ULONG RpcHttpAsyncData_Release(RpcHttpAsyncData *data)
     {
         TRACE("destroying async data %p\n", data);
         CloseHandle(data->completion_event);
-        HeapFree(GetProcessHeap(), 0, data->inet_buffers.lpvBuffer);
+        free(data->inet_buffers.lpvBuffer);
         data->cs.DebugInfo->Spare[0] = 0;
         DeleteCriticalSection(&data->cs);
-        HeapFree(GetProcessHeap(), 0, data);
+        free(data);
     }
     return refs;
 }
@@ -1750,12 +1744,12 @@ typedef struct _RpcConnection_http
 static RpcConnection *rpcrt4_ncacn_http_alloc(void)
 {
     RpcConnection_http *httpc;
-    httpc = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*httpc));
+    httpc = calloc(1, sizeof(*httpc));
     if (!httpc) return NULL;
-    httpc->async_data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(RpcHttpAsyncData));
+    httpc->async_data = calloc(1, sizeof(RpcHttpAsyncData));
     if (!httpc->async_data)
     {
-        HeapFree(GetProcessHeap(), 0, httpc);
+        free(httpc);
         return NULL;
     }
     TRACE("async data = %p\n", httpc->async_data);
@@ -1785,7 +1779,7 @@ static VOID rpcrt4_http_keep_connection_active_timer_proc(PVOID param, BOOLEAN d
     {
         DWORD bytes_written;
         InternetWriteFile(in_request, idle_pkt, idle_pkt->common.frag_len, &bytes_written);
-        RPCRT4_FreeHeader(idle_pkt);
+        free(idle_pkt);
     }
 }
 
@@ -1805,7 +1799,7 @@ static DWORD CALLBACK rpcrt4_http_timer_thread(PVOID param)
     SetThreadDescription(GetCurrentThread(), L"wine_rpcrt4_http_timer");
 
     data = *data_in;
-    HeapFree(GetProcessHeap(), 0, data_in);
+    free(data_in);
 
     for (timeout = HTTP_IDLE_TIME;
          WaitForSingleObject(data.timer_cancelled, timeout) == WAIT_TIMEOUT;
@@ -1868,12 +1862,12 @@ static RPC_STATUS rpcrt4_http_check_response(HINTERNET hor)
     ret = HttpQueryInfoW(hor, HTTP_QUERY_STATUS_TEXT, status_text, &size, &index);
     if (!ret && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
     {
-        status_text = HeapAlloc(GetProcessHeap(), 0, size);
+        status_text = malloc(size);
         ret = HttpQueryInfoW(hor, HTTP_QUERY_STATUS_TEXT, status_text, &size, &index);
     }
 
     ERR("server returned: %ld %s\n", status_code, ret ? debugstr_w(status_text) : "<status text unavailable>");
-    if(status_text != buf) HeapFree(GetProcessHeap(), 0, status_text);
+    if(status_text != buf) free(status_text);
 
     if (status_code == HTTP_STATUS_DENIED)
         return ERROR_ACCESS_DENIED;
@@ -1898,7 +1892,7 @@ static RPC_STATUS rpcrt4_http_internet_connect(RpcConnection_http *httpc)
             WCHAR *p;
             const SEC_WINNT_AUTH_IDENTITY_W *cred = http_cred->TransportCredentials;
             ULONG len = cred->DomainLength + 1 + cred->UserLength;
-            user = HeapAlloc(GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR));
+            user = malloc((len + 1) * sizeof(WCHAR));
             if (!user)
                 return RPC_S_OUT_OF_RESOURCES;
             p = user;
@@ -1957,10 +1951,10 @@ static RPC_STATUS rpcrt4_http_internet_connect(RpcConnection_http *httpc)
                                     NULL, NULL, INTERNET_FLAG_ASYNC);
     if (!httpc->app_info)
     {
-        HeapFree(GetProcessHeap(), 0, password);
-        HeapFree(GetProcessHeap(), 0, user);
-        HeapFree(GetProcessHeap(), 0, proxy);
-        HeapFree(GetProcessHeap(), 0, servername);
+        free(password);
+        free(user);
+        free(proxy);
+        free(servername);
         ERR("InternetOpenW failed with error %ld\n", GetLastError());
         return RPC_S_SERVER_UNAVAILABLE;
     }
@@ -1970,12 +1964,12 @@ static RPC_STATUS rpcrt4_http_internet_connect(RpcConnection_http *httpc)
      * RPC server address */
     if (!servername)
     {
-        servername = HeapAlloc(GetProcessHeap(), 0, (strlen(httpc->common.NetworkAddr) + 1)*sizeof(WCHAR));
+        servername = malloc((strlen(httpc->common.NetworkAddr) + 1) * sizeof(WCHAR));
         if (!servername)
         {
-            HeapFree(GetProcessHeap(), 0, password);
-            HeapFree(GetProcessHeap(), 0, user);
-            HeapFree(GetProcessHeap(), 0, proxy);
+            free(password);
+            free(user);
+            free(proxy);
             return RPC_S_OUT_OF_RESOURCES;
         }
         MultiByteToWideChar(CP_ACP, 0, httpc->common.NetworkAddr, -1, servername, strlen(httpc->common.NetworkAddr) + 1);
@@ -1989,14 +1983,14 @@ static RPC_STATUS rpcrt4_http_internet_connect(RpcConnection_http *httpc)
     httpc->session = InternetConnectW(httpc->app_info, servername, port, user, password,
                                       INTERNET_SERVICE_HTTP, 0, 0);
 
-    HeapFree(GetProcessHeap(), 0, password);
-    HeapFree(GetProcessHeap(), 0, user);
-    HeapFree(GetProcessHeap(), 0, proxy);
+    free(password);
+    free(user);
+    free(proxy);
 
     if (!httpc->session)
     {
         ERR("InternetConnectW failed with error %ld\n", GetLastError());
-        HeapFree(GetProcessHeap(), 0, servername);
+        free(servername);
         return RPC_S_SERVER_UNAVAILABLE;
     }
     httpc->servername = servername;
@@ -2011,7 +2005,7 @@ static int rpcrt4_http_async_read(HINTERNET req, RpcHttpAsyncData *async_data, H
     unsigned int bytes_left = count;
     RPC_STATUS status = RPC_S_OK;
 
-    async_data->inet_buffers.lpvBuffer = HeapAlloc(GetProcessHeap(), 0, count);
+    async_data->inet_buffers.lpvBuffer = malloc(count);
 
     while (bytes_left)
     {
@@ -2035,7 +2029,7 @@ static int rpcrt4_http_async_read(HINTERNET req, RpcHttpAsyncData *async_data, H
         buf += async_data->inet_buffers.dwBufferLength;
     }
 
-    HeapFree(GetProcessHeap(), 0, async_data->inet_buffers.lpvBuffer);
+    free(async_data->inet_buffers.lpvBuffer);
     async_data->inet_buffers.lpvBuffer = NULL;
 
     TRACE("%p %p %u -> %lu\n", req, buffer, count, status);
@@ -2106,7 +2100,7 @@ static RPC_STATUS rpcrt4_http_prepare_in_pipe(HINTERNET in_request, RpcHttpAsync
     hdr = RPCRT4_BuildHttpConnectHeader(FALSE, connection_uuid, in_pipe_uuid, association_uuid);
     if (!hdr) return RPC_S_OUT_OF_RESOURCES;
     ret = InternetWriteFile(in_request, hdr, hdr->common.frag_len, &bytes_written);
-    RPCRT4_FreeHeader(hdr);
+    free(hdr);
     if (!ret)
     {
         ERR("InternetWriteFile failed with error %ld\n", GetLastError());
@@ -2138,12 +2132,12 @@ static RPC_STATUS rpcrt4_http_read_http_packet(HINTERNET request, RpcHttpAsyncDa
     data_len = hdr->common.frag_len - sizeof(hdr->http);
     if (data_len)
     {
-        *data = HeapAlloc(GetProcessHeap(), 0, data_len);
+        *data = malloc(data_len);
         if (!*data)
             return RPC_S_OUT_OF_RESOURCES;
         if (rpcrt4_http_async_read(request, async_data, cancel_event, *data, data_len) < 0)
         {
-            HeapFree(GetProcessHeap(), 0, *data);
+            free(*data);
             return RPC_S_SERVER_UNAVAILABLE;
         }
     }
@@ -2153,7 +2147,7 @@ static RPC_STATUS rpcrt4_http_read_http_packet(HINTERNET request, RpcHttpAsyncDa
     if (!RPCRT4_IsValidHttpPacket(hdr, *data, data_len))
     {
         ERR("invalid http packet\n");
-        HeapFree(GetProcessHeap(), 0, *data);
+        free(*data);
         return RPC_S_PROTOCOL_ERROR;
     }
 
@@ -2189,7 +2183,7 @@ static RPC_STATUS rpcrt4_http_prepare_out_pipe(HINTERNET out_request, RpcHttpAsy
     status = insert_content_length_header(out_request, hdr->common.frag_len);
     if (status != RPC_S_OK)
     {
-        RPCRT4_FreeHeader(hdr);
+        free(hdr);
         return status;
     }
 
@@ -2197,7 +2191,7 @@ static RPC_STATUS rpcrt4_http_prepare_out_pipe(HINTERNET out_request, RpcHttpAsy
     prepare_async_request(async_data);
     ret = HttpSendRequestW(out_request, NULL, 0, hdr, hdr->common.frag_len);
     status = wait_async_request(async_data, ret, cancel_event);
-    RPCRT4_FreeHeader(hdr);
+    free(hdr);
     if (status != RPC_S_OK) return status;
 
     status = rpcrt4_http_check_response(out_request);
@@ -2208,7 +2202,7 @@ static RPC_STATUS rpcrt4_http_prepare_out_pipe(HINTERNET out_request, RpcHttpAsy
     if (status != RPC_S_OK) return status;
     status = RPCRT4_ParseHttpPrepareHeader1(&pkt_from_server, data_from_server,
                                             &field1);
-    HeapFree(GetProcessHeap(), 0, data_from_server);
+    free(data_from_server);
     if (status != RPC_S_OK) return status;
     TRACE("received (%ld) from first prepare header\n", field1);
 
@@ -2220,7 +2214,7 @@ static RPC_STATUS rpcrt4_http_prepare_out_pipe(HINTERNET out_request, RpcHttpAsy
         if (pkt_from_server.http.flags != 0x0001) break;
 
         TRACE("http idle packet, waiting for real packet\n");
-        HeapFree(GetProcessHeap(), 0, data_from_server);
+        free(data_from_server);
         if (pkt_from_server.http.num_data_items != 0)
         {
             ERR("HTTP idle packet should have no data items instead of %d\n",
@@ -2231,7 +2225,7 @@ static RPC_STATUS rpcrt4_http_prepare_out_pipe(HINTERNET out_request, RpcHttpAsy
     status = RPCRT4_ParseHttpPrepareHeader2(&pkt_from_server, data_from_server,
                                             &field1, flow_control_increment,
                                             &field3);
-    HeapFree(GetProcessHeap(), 0, data_from_server);
+    free(data_from_server);
     if (status != RPC_S_OK) return status;
     TRACE("received (0x%08lx 0x%08lx %ld) from second prepare header\n", field1, *flow_control_increment, field3);
 
@@ -2354,7 +2348,7 @@ static struct authinfo *alloc_authinfo(void)
 {
     struct authinfo *ret;
 
-    if (!(ret = HeapAlloc(GetProcessHeap(), 0, sizeof(*ret) ))) return NULL;
+    if (!(ret = malloc(sizeof(*ret)))) return NULL;
 
     SecInvalidateHandle(&ret->cred);
     SecInvalidateHandle(&ret->ctx);
@@ -2377,8 +2371,8 @@ static void destroy_authinfo(struct authinfo *info)
     if (SecIsValidHandle(&info->cred))
         FreeCredentialsHandle(&info->cred);
 
-    HeapFree(GetProcessHeap(), 0, info->data);
-    HeapFree(GetProcessHeap(), 0, info);
+    free(info->data);
+    free(info);
 }
 
 static const struct
@@ -2436,7 +2430,7 @@ static RPC_STATUS do_authorization(HINTERNET request, SEC_WCHAR *servername,
         int passlen = WideCharToMultiByte(CP_UTF8, 0, id->Password, id->PasswordLength, NULL, 0, NULL, NULL);
 
         info->data_len = userlen + passlen + 1;
-        if (!(info->data = HeapAlloc(GetProcessHeap(), 0, info->data_len)))
+        if (!(info->data = malloc(info->data_len)))
         {
             status = RPC_S_OUT_OF_MEMORY;
             break;
@@ -2507,14 +2501,14 @@ static RPC_STATUS do_authorization(HINTERNET request, SEC_WCHAR *servername,
         {
             int len = lstrlenW(++p);
             in.cbBuffer = decode_base64(p, len, NULL);
-            if (!(in.pvBuffer = HeapAlloc(GetProcessHeap(), 0, in.cbBuffer))) break;
+            if (!(in.pvBuffer = malloc(in.cbBuffer))) break;
             decode_base64(p, len, in.pvBuffer);
         }
         out.BufferType = SECBUFFER_TOKEN;
         out.cbBuffer   = info->max_token;
-        if (!(out.pvBuffer = HeapAlloc(GetProcessHeap(), 0, out.cbBuffer)))
+        if (!(out.pvBuffer = malloc(out.cbBuffer)))
         {
-            HeapFree(GetProcessHeap(), 0, in.pvBuffer);
+            free(in.pvBuffer);
             break;
         }
         out_desc.ulVersion = 0;
@@ -2525,10 +2519,10 @@ static RPC_STATUS do_authorization(HINTERNET request, SEC_WCHAR *servername,
                                          first ? servername : NULL, flags, 0, SECURITY_NETWORK_DREP,
                                          in.pvBuffer ? &in_desc : NULL, 0, &info->ctx, &out_desc,
                                          &info->attr, &info->exp);
-        HeapFree(GetProcessHeap(), 0, in.pvBuffer);
+        free(in.pvBuffer);
         if (ret == SEC_E_OK)
         {
-            HeapFree(GetProcessHeap(), 0, info->data);
+            free(info->data);
             info->data     = out.pvBuffer;
             info->data_len = out.cbBuffer;
             info->finished = TRUE;
@@ -2537,7 +2531,7 @@ static RPC_STATUS do_authorization(HINTERNET request, SEC_WCHAR *servername,
         }
         else if (ret == SEC_I_CONTINUE_NEEDED)
         {
-            HeapFree(GetProcessHeap(), 0, info->data);
+            free(info->data);
             info->data     = out.pvBuffer;
             info->data_len = out.cbBuffer;
             TRACE("sending next auth packet\n");
@@ -2546,7 +2540,7 @@ static RPC_STATUS do_authorization(HINTERNET request, SEC_WCHAR *servername,
         else
         {
             ERR("InitializeSecurityContextW failed with error 0x%08lx\n", ret);
-            HeapFree(GetProcessHeap(), 0, out.pvBuffer);
+            free(out.pvBuffer);
             break;
         }
         info->scheme = creds->AuthnSchemes[0];
@@ -2596,7 +2590,7 @@ static RPC_STATUS insert_authorization_header(HINTERNET request, ULONG scheme, c
         ERR("unknown scheme %lu\n", scheme);
         return RPC_S_SERVER_UNAVAILABLE;
     }
-    if ((header = HeapAlloc(GetProcessHeap(), 0, (auth_len + scheme_len + len + 2) * sizeof(WCHAR))))
+    if ((header = malloc((auth_len + scheme_len + len + 2) * sizeof(WCHAR))))
     {
         memcpy(header, authW, auth_len * sizeof(WCHAR));
         ptr = header + auth_len;
@@ -2608,7 +2602,7 @@ static RPC_STATUS insert_authorization_header(HINTERNET request, ULONG scheme, c
         ptr[len] = 0;
         if (HttpAddRequestHeadersW(request, header, -1, HTTP_ADDREQ_FLAG_ADD|HTTP_ADDREQ_FLAG_REPLACE))
             status = RPC_S_OK;
-        HeapFree(GetProcessHeap(), 0, header);
+        free(header);
     }
     return status;
 }
@@ -2713,17 +2707,17 @@ static RPC_STATUS set_auth_cookie(RpcConnection_http *httpc, const WCHAR *value)
     if (!InternetCreateUrlW(&uc, 0, NULL, &len) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
         return RPC_S_SERVER_UNAVAILABLE;
 
-    if (!(url = HeapAlloc(GetProcessHeap(), 0, len))) return RPC_S_OUT_OF_MEMORY;
+    if (!(url = malloc(len))) return RPC_S_OUT_OF_MEMORY;
 
     len = len / sizeof(WCHAR) - 1;
     if (!InternetCreateUrlW(&uc, 0, url, &len))
     {
-        HeapFree(GetProcessHeap(), 0, url);
+        free(url);
         return RPC_S_SERVER_UNAVAILABLE;
     }
 
     ret = InternetSetCookieW(url, NULL, value);
-    HeapFree(GetProcessHeap(), 0, url);
+    free(url);
     if (!ret) return RPC_S_SERVER_UNAVAILABLE;
 
     return RPC_S_OK;
@@ -2762,7 +2756,8 @@ static RPC_STATUS rpcrt4_ncacn_http_open(RpcConnection* Connection)
     if (status != RPC_S_OK)
         return status;
 
-    url = HeapAlloc(GetProcessHeap(), 0, sizeof(wszRpcProxyPrefix) + (strlen(Connection->NetworkAddr) + 1 + strlen(Connection->Endpoint))*sizeof(WCHAR));
+    url = malloc(sizeof(wszRpcProxyPrefix) +
+                 (strlen(Connection->NetworkAddr) + 1 + strlen(Connection->Endpoint)) * sizeof(WCHAR));
     if (!url)
         return RPC_S_OUT_OF_MEMORY;
     memcpy(url, wszRpcProxyPrefix, sizeof(wszRpcProxyPrefix));
@@ -2782,7 +2777,7 @@ static RPC_STATUS rpcrt4_ncacn_http_open(RpcConnection* Connection)
     status = set_auth_cookie(httpc, Connection->CookieAuth);
     if (status != RPC_S_OK)
     {
-        HeapFree(GetProcessHeap(), 0, url);
+        free(url);
         return status;
     }
     httpc->in_request = HttpOpenRequestW(httpc->session, L"RPC_IN_DATA", url, NULL, NULL, wszAcceptTypes,
@@ -2790,7 +2785,7 @@ static RPC_STATUS rpcrt4_ncacn_http_open(RpcConnection* Connection)
     if (!httpc->in_request)
     {
         ERR("HttpOpenRequestW failed with error %ld\n", GetLastError());
-        HeapFree(GetProcessHeap(), 0, url);
+        free(url);
         return RPC_S_SERVER_UNAVAILABLE;
     }
 
@@ -2799,13 +2794,13 @@ static RPC_STATUS rpcrt4_ncacn_http_open(RpcConnection* Connection)
         status = authorize_request(httpc, httpc->in_request);
         if (status != RPC_S_OK)
         {
-            HeapFree(GetProcessHeap(), 0, url);
+            free(url);
             return status;
         }
         status = rpcrt4_http_check_response(httpc->in_request);
         if (status != RPC_S_OK)
         {
-            HeapFree(GetProcessHeap(), 0, url);
+            free(url);
             return status;
         }
         drain_content(httpc->in_request, httpc->async_data, httpc->cancel_event);
@@ -2813,7 +2808,7 @@ static RPC_STATUS rpcrt4_ncacn_http_open(RpcConnection* Connection)
 
     httpc->out_request = HttpOpenRequestW(httpc->session, L"RPC_OUT_DATA", url, NULL, NULL, wszAcceptTypes,
                                           flags, (DWORD_PTR)httpc->async_data);
-    HeapFree(GetProcessHeap(), 0, url);
+    free(url);
     if (!httpc->out_request)
     {
         ERR("HttpOpenRequestW failed with error %ld\n", GetLastError());
@@ -2843,7 +2838,7 @@ static RPC_STATUS rpcrt4_ncacn_http_open(RpcConnection* Connection)
     httpc->last_sent_time = GetTickCount();
     httpc->timer_cancelled = CreateEventW(NULL, FALSE, FALSE, NULL);
 
-    timer_data = HeapAlloc(GetProcessHeap(), 0, sizeof(*timer_data));
+    timer_data = malloc(sizeof(*timer_data));
     if (!timer_data)
         return ERROR_OUTOFMEMORY;
     timer_data->timer_param = httpc->in_request;
@@ -2853,7 +2848,7 @@ static RPC_STATUS rpcrt4_ncacn_http_open(RpcConnection* Connection)
     thread = CreateThread(NULL, 0, rpcrt4_http_timer_thread, timer_data, 0, NULL);
     if (!thread)
     {
-        HeapFree(GetProcessHeap(), 0, timer_data);
+        free(timer_data);
         return GetLastError();
     }
     CloseHandle(thread);
@@ -2912,7 +2907,7 @@ again:
     goto fail;
   }
 
-  *Header = HeapAlloc(GetProcessHeap(), 0, hdr_length);
+  *Header = malloc(hdr_length);
   if (!*Header)
   {
     status = RPC_S_OUT_OF_RESOURCES;
@@ -2930,7 +2925,7 @@ again:
 
   if (common_hdr.frag_len - hdr_length)
   {
-    *Payload = HeapAlloc(GetProcessHeap(), 0, common_hdr.frag_len - hdr_length);
+    *Payload = malloc(common_hdr.frag_len - hdr_length);
     if (!*Payload)
     {
       status = RPC_S_OUT_OF_RESOURCES;
@@ -2988,9 +2983,9 @@ again:
       status = RPC_S_PROTOCOL_ERROR;
       goto fail;
     }
-    RPCRT4_FreeHeader(*Header);
+    free(*Header);
     *Header = NULL;
-    HeapFree(GetProcessHeap(), 0, *Payload);
+    free(*Payload);
     *Payload = NULL;
     goto again;
   }
@@ -3014,7 +3009,7 @@ again:
       BOOL ret2;
       TRACE("sending flow control packet at 0x%lx\n", httpc->bytes_received);
       ret2 = InternetWriteFile(httpc->in_request, hdr, hdr->common.frag_len, &bytes_written);
-      RPCRT4_FreeHeader(hdr);
+      free(hdr);
       if (ret2)
         httpc->flow_control_mark = httpc->bytes_received + httpc->flow_control_increment / 2;
     }
@@ -3022,9 +3017,9 @@ again:
 
 fail:
   if (status != RPC_S_OK) {
-    RPCRT4_FreeHeader(*Header);
+    free(*Header);
     *Header = NULL;
-    HeapFree(GetProcessHeap(), 0, *Payload);
+    free(*Payload);
     *Payload = NULL;
   }
   return status;
@@ -3066,7 +3061,7 @@ static int rpcrt4_ncacn_http_close(RpcConnection *Connection)
   RpcHttpAsyncData_Release(httpc->async_data);
   if (httpc->cancel_event)
     CloseHandle(httpc->cancel_event);
-  HeapFree(GetProcessHeap(), 0, httpc->servername);
+  free(httpc->servername);
   httpc->servername = NULL;
 
   return 0;
@@ -3307,10 +3302,10 @@ RPC_STATUS RPCRT4_CreateConnection(RpcConnection** Connection, BOOL server,
   NewConnection->ref = 1;
   NewConnection->server = server;
   NewConnection->ops = ops;
-  NewConnection->NetworkAddr = RPCRT4_strdupA(NetworkAddr);
-  NewConnection->Endpoint = RPCRT4_strdupA(Endpoint);
-  NewConnection->NetworkOptions = RPCRT4_strdupW(NetworkOptions);
-  NewConnection->CookieAuth = RPCRT4_strdupW(CookieAuth);
+  NewConnection->NetworkAddr = strdup(NetworkAddr);
+  NewConnection->Endpoint = strdup(Endpoint);
+  NewConnection->NetworkOptions = wcsdup(NetworkOptions);
+  NewConnection->CookieAuth = wcsdup(CookieAuth);
   NewConnection->MaxTransmissionSize = RPC_MAX_PACKET_SIZE;
   NewConnection->NextCallId = 1;
 
@@ -3401,10 +3396,10 @@ void RPCRT4_ReleaseConnection(RpcConnection *connection)
     if (!ref)
     {
         RPCRT4_CloseConnection(connection);
-        RPCRT4_strfree(connection->Endpoint);
-        RPCRT4_strfree(connection->NetworkAddr);
-        HeapFree(GetProcessHeap(), 0, connection->NetworkOptions);
-        HeapFree(GetProcessHeap(), 0, connection->CookieAuth);
+        free(connection->Endpoint);
+        free(connection->NetworkAddr);
+        free(connection->NetworkOptions);
+        free(connection->CookieAuth);
         if (connection->AuthInfo) RpcAuthInfo_Release(connection->AuthInfo);
         if (connection->QOS) RpcQualityOfService_Release(connection->QOS);
 
@@ -3414,7 +3409,7 @@ void RPCRT4_ReleaseConnection(RpcConnection *connection)
 
         if (connection->wait_release) SetEvent(connection->wait_release);
 
-        HeapFree(GetProcessHeap(), 0, connection);
+        free(connection);
     }
 }
 
@@ -3568,8 +3563,8 @@ RPC_STATUS WINAPI RpcProtseqVectorFreeA(RPC_PROTSEQ_VECTORA **protseqs)
   {
     unsigned int i;
     for (i = 0; i < (*protseqs)->Count; i++)
-      HeapFree(GetProcessHeap(), 0, (*protseqs)->Protseq[i]);
-    HeapFree(GetProcessHeap(), 0, *protseqs);
+      free((*protseqs)->Protseq[i]);
+    free(*protseqs);
     *protseqs = NULL;
   }
   return RPC_S_OK;
@@ -3586,8 +3581,8 @@ RPC_STATUS WINAPI RpcProtseqVectorFreeW(RPC_PROTSEQ_VECTORW **protseqs)
   {
     unsigned int i;
     for (i = 0; i < (*protseqs)->Count; i++)
-      HeapFree(GetProcessHeap(), 0, (*protseqs)->Protseq[i]);
-    HeapFree(GetProcessHeap(), 0, *protseqs);
+      free((*protseqs)->Protseq[i]);
+    free(*protseqs);
     *protseqs = NULL;
   }
   return RPC_S_OK;
@@ -3604,14 +3599,14 @@ RPC_STATUS WINAPI RpcNetworkInqProtseqsW( RPC_PROTSEQ_VECTORW** protseqs )
 
   TRACE("(%p)\n", protseqs);
 
-  *protseqs = HeapAlloc(GetProcessHeap(), 0, sizeof(RPC_PROTSEQ_VECTORW)+(sizeof(unsigned short*)*ARRAY_SIZE(protseq_list)));
+  *protseqs = malloc(sizeof(RPC_PROTSEQ_VECTORW) + sizeof(unsigned short*) * ARRAY_SIZE(protseq_list));
   if (!*protseqs)
     goto end;
   pvector = *protseqs;
   pvector->Count = 0;
   for (i = 0; i < ARRAY_SIZE(protseq_list); i++)
   {
-    pvector->Protseq[i] = HeapAlloc(GetProcessHeap(), 0, (strlen(protseq_list[i].name)+1)*sizeof(unsigned short));
+    pvector->Protseq[i] = malloc((strlen(protseq_list[i].name) + 1) * sizeof(unsigned short));
     if (pvector->Protseq[i] == NULL)
       goto end;
     MultiByteToWideChar(CP_ACP, 0, (CHAR*)protseq_list[i].name, -1,
@@ -3637,14 +3632,14 @@ RPC_STATUS WINAPI RpcNetworkInqProtseqsA(RPC_PROTSEQ_VECTORA** protseqs)
 
   TRACE("(%p)\n", protseqs);
 
-  *protseqs = HeapAlloc(GetProcessHeap(), 0, sizeof(RPC_PROTSEQ_VECTORW)+(sizeof(unsigned char*)*ARRAY_SIZE(protseq_list)));
+  *protseqs = malloc(sizeof(RPC_PROTSEQ_VECTORW) + sizeof(unsigned char*) * ARRAY_SIZE(protseq_list));
   if (!*protseqs)
     goto end;
   pvector = *protseqs;
   pvector->Count = 0;
   for (i = 0; i < ARRAY_SIZE(protseq_list); i++)
   {
-    pvector->Protseq[i] = HeapAlloc(GetProcessHeap(), 0, strlen(protseq_list[i].name)+1);
+    pvector->Protseq[i] = malloc(strlen(protseq_list[i].name) + 1);
     if (pvector->Protseq[i] == NULL)
       goto end;
     strcpy((char*)pvector->Protseq[i], protseq_list[i].name);
diff --git a/dlls/rpcrt4/rpcrt4_main.c b/dlls/rpcrt4/rpcrt4_main.c
index d7073b550dd..122ab94f17c 100644
--- a/dlls/rpcrt4/rpcrt4_main.c
+++ b/dlls/rpcrt4/rpcrt4_main.c
@@ -136,7 +136,7 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
                 ERR("tdata->connection should be NULL but is still set to %p\n", tdata->connection);
             if (tdata->server_binding)
                 ERR("tdata->server_binding should be NULL but is still set to %p\n", tdata->server_binding);
-            HeapFree(GetProcessHeap(), 0, tdata);
+            free(tdata);
         }
         break;
 
@@ -163,7 +163,7 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
  */
 RPC_STATUS WINAPI RpcStringFreeA(RPC_CSTR* String)
 {
-  HeapFree( GetProcessHeap(), 0, *String);
+  free(*String);
 
   return RPC_S_OK;
 }
@@ -179,7 +179,7 @@ RPC_STATUS WINAPI RpcStringFreeA(RPC_CSTR* String)
  */
 RPC_STATUS WINAPI RpcStringFreeW(RPC_WSTR* String)
 {
-  HeapFree( GetProcessHeap(), 0, *String);
+  free(*String);
 
   return RPC_S_OK;
 }
@@ -370,11 +370,11 @@ static RPC_STATUS RPC_UuidGetNodeAddress(BYTE *address)
     DWORD status = RPC_S_OK;
 
     ULONG buflen = sizeof(IP_ADAPTER_INFO);
-    PIP_ADAPTER_INFO adapter = HeapAlloc(GetProcessHeap(), 0, buflen);
+    PIP_ADAPTER_INFO adapter = malloc(buflen);
 
     if (GetAdaptersInfo(adapter, &buflen) == ERROR_BUFFER_OVERFLOW) {
-        HeapFree(GetProcessHeap(), 0, adapter);
-        adapter = HeapAlloc(GetProcessHeap(), 0, buflen);
+        free(adapter);
+        adapter = malloc(buflen);
     }
 
     if (GetAdaptersInfo(adapter, &buflen) == NO_ERROR) {
@@ -390,7 +390,7 @@ static RPC_STATUS RPC_UuidGetNodeAddress(BYTE *address)
         status = RPC_S_UUID_LOCAL_ONLY;
     }
 
-    HeapFree(GetProcessHeap(), 0, adapter);
+    free(adapter);
     return status;
 }
 
@@ -536,7 +536,7 @@ unsigned short WINAPI UuidHash(UUID *uuid, RPC_STATUS *Status)
  */
 RPC_STATUS WINAPI UuidToStringA(UUID *Uuid, RPC_CSTR* StringUuid)
 {
-  *StringUuid = HeapAlloc( GetProcessHeap(), 0, sizeof(char) * 37);
+  *StringUuid = malloc(37);
 
   if(!(*StringUuid))
     return RPC_S_OUT_OF_MEMORY;
@@ -728,7 +728,7 @@ RPC_STATUS RPC_ENTRY DceErrorInqTextA (RPC_STATUS e, RPC_CSTR buffer)
  */
 void * WINAPI I_RpcAllocate(unsigned int Size)
 {
-    return HeapAlloc(GetProcessHeap(), 0, Size);
+    return malloc(Size);
 }
 
 /******************************************************************************
@@ -736,7 +736,7 @@ void * WINAPI I_RpcAllocate(unsigned int Size)
  */
 void WINAPI I_RpcFree(void *Object)
 {
-    HeapFree(GetProcessHeap(), 0, Object);
+    free(Object);
 }
 
 /******************************************************************************
@@ -947,7 +947,7 @@ static struct threaddata *get_or_create_threaddata(void)
     struct threaddata *tdata = NtCurrentTeb()->ReservedForNtRpc;
     if (!tdata)
     {
-        tdata = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*tdata));
+        tdata = calloc(1, sizeof(*tdata));
         if (!tdata) return NULL;
 
         InitializeCriticalSection(&tdata->cs);
@@ -997,7 +997,7 @@ void RPCRT4_PushThreadContextHandle(NDR_SCONTEXT SContext)
 
     if (!tdata) return;
 
-    context_handle_list = HeapAlloc(GetProcessHeap(), 0, sizeof(*context_handle_list));
+    context_handle_list = malloc(sizeof(*context_handle_list));
     if (!context_handle_list) return;
 
     context_handle_list->context_handle = SContext;
@@ -1020,7 +1020,7 @@ void RPCRT4_RemoveThreadContextHandle(NDR_SCONTEXT SContext)
                 prev->next = current->next;
             else
                 tdata->context_handle_list = current->next;
-            HeapFree(GetProcessHeap(), 0, current);
+            free(current);
             return;
         }
     }
@@ -1039,7 +1039,7 @@ NDR_SCONTEXT RPCRT4_PopThreadContextHandle(void)
     tdata->context_handle_list = context_handle_list->next;
 
     context_handle = context_handle_list->context_handle;
-    HeapFree(GetProcessHeap(), 0, context_handle_list);
+    free(context_handle_list);
     return context_handle;
 }
 
-- 
GitLab

From 6de5f46fa0b5b1b793a5a2ca2dfd648cc059c052 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 5 Dec 2022 15:06:42 -0600
Subject: [PATCH] ddraw: Sync draw textures even for hardware device.

Fixes a regression introduced by commit
d2d9f713df7932aac4b137ec3bf647d5da7faaef.
---
 dlls/ddraw/ddraw_private.h |  1 +
 dlls/ddraw/device.c        | 30 +++++++++++++++++++++++++-----
 2 files changed, 26 insertions(+), 5 deletions(-)

diff --git a/dlls/ddraw/ddraw_private.h b/dlls/ddraw/ddraw_private.h
index 6693a650394..09e8133350b 100644
--- a/dlls/ddraw/ddraw_private.h
+++ b/dlls/ddraw/ddraw_private.h
@@ -328,6 +328,7 @@ struct d3d_device
     LONG ref;
     UINT version;
     BOOL hardware_device;
+    BOOL have_draw_textures;
 
     IUnknown *outer_unknown;
     struct wined3d_device *wined3d_device;
diff --git a/dlls/ddraw/device.c b/dlls/ddraw/device.c
index ac6647b8dad..1cfef5007d5 100644
--- a/dlls/ddraw/device.c
+++ b/dlls/ddraw/device.c
@@ -3409,11 +3409,11 @@ void d3d_device_sync_surfaces(struct d3d_device *device)
     struct ddraw_surface *surface;
     unsigned int i, j;
 
-    if (device->hardware_device)
-        return;
-
     d3d_device_sync_rendertarget(device);
 
+    if (!device->have_draw_textures)
+        return;
+
     for (i = 0; i < ARRAY_SIZE(state->textures); ++i)
     {
         if (!state->textures[i])
@@ -4642,7 +4642,17 @@ static HRESULT d3d_device7_SetTexture(IDirect3DDevice7 *iface,
     TRACE("iface %p, stage %lu, texture %p.\n", iface, stage, texture);
 
     if (surf && (surf->surface_desc.ddsCaps.dwCaps & DDSCAPS_TEXTURE))
-        wined3d_texture = surf->draw_texture ? surf->draw_texture : surf->wined3d_texture;
+    {
+        if (surf->draw_texture)
+        {
+            wined3d_texture = surf->draw_texture;
+            device->have_draw_textures = TRUE;
+        }
+        else
+        {
+            wined3d_texture = surf->wined3d_texture;
+        }
+    }
 
     wined3d_mutex_lock();
     wined3d_stateblock_set_texture(device->update_state, stage, wined3d_texture);
@@ -4682,7 +4692,17 @@ static HRESULT WINAPI d3d_device3_SetTexture(IDirect3DDevice3 *iface,
     wined3d_mutex_lock();
 
     if (tex && ((tex->surface_desc.ddsCaps.dwCaps & DDSCAPS_TEXTURE) || !device->hardware_device))
-        wined3d_texture = tex->draw_texture ? tex->draw_texture : tex->wined3d_texture;
+    {
+        if (tex->draw_texture)
+        {
+            wined3d_texture = tex->draw_texture;
+            device->have_draw_textures = TRUE;
+        }
+        else
+        {
+            wined3d_texture = tex->wined3d_texture;
+        }
+    }
 
     wined3d_stateblock_set_texture(device->state, stage, wined3d_texture);
     fixup_texture_alpha_op(device);
-- 
GitLab

From 8fe1c2282e92fb455c55d4c999133b10aa927ed9 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 23 Nov 2022 08:49:03 +0300
Subject: [PATCH 1/5] comctl32/header: Use CRT allocation functions.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/comctl32/header.c | 41 ++++++++++++++++++++---------------------
 1 file changed, 20 insertions(+), 21 deletions(-)

diff --git a/dlls/comctl32/header.c b/dlls/comctl32/header.c
index be4c5616bb7..e905d18e2fa 100644
--- a/dlls/comctl32/header.c
+++ b/dlls/comctl32/header.c
@@ -41,7 +41,6 @@
 #include "vssym32.h"
 #include "uxtheme.h"
 #include "wine/debug.h"
-#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(header);
 
@@ -141,7 +140,7 @@ static void HEADER_StoreHDItemInHeader(HEADER_ITEM *lpItem, UINT mask, const HDI
 
     if (mask & HDI_TEXT)
     {
-        heap_free(lpItem->pszText);
+        free(lpItem->pszText);
         lpItem->pszText = NULL;
 
         if (phdi->pszText != LPSTR_TEXTCALLBACKW) /* covers != TEXTCALLBACKA too */
@@ -336,7 +335,7 @@ static HRGN create_sort_arrow( INT x, INT y, INT h, BOOL is_up )
 
     if (size > sizeof(buffer))
     {
-        data = heap_alloc( size );
+        data = malloc( size );
         if (!data) return NULL;
     }
     data->rdh.dwSize = sizeof(data->rdh);
@@ -362,7 +361,7 @@ static HRGN create_sort_arrow( INT x, INT y, INT h, BOOL is_up )
         data->rdh.nCount++;
     }
     rgn = ExtCreateRegion( NULL, size, data );
-    if (data != (RGNDATA *)buffer) heap_free( data );
+    if (data != (RGNDATA *)buffer) free( data );
     return rgn;
 }
 
@@ -983,7 +982,7 @@ HEADER_PrepareCallbackItems(const HEADER_INFO *infoPtr, INT iItem, INT reqMask)
     if (mask&HDI_TEXT && lpItem->pszText != NULL)
     {
         ERR("(): function called without a call to FreeCallbackItems\n");
-        heap_free(lpItem->pszText);
+        free(lpItem->pszText);
         lpItem->pszText = NULL;
     }
     
@@ -994,13 +993,13 @@ HEADER_PrepareCallbackItems(const HEADER_INFO *infoPtr, INT iItem, INT reqMask)
     {
         dispInfo.hdr.code = HDN_GETDISPINFOW;
         if (mask & HDI_TEXT)
-            pvBuffer = heap_alloc_zero(MAX_HEADER_TEXT_LEN * sizeof(WCHAR));
+            pvBuffer = calloc(MAX_HEADER_TEXT_LEN, sizeof(WCHAR));
     }
     else
     {
         dispInfo.hdr.code = HDN_GETDISPINFOA;
         if (mask & HDI_TEXT)
-            pvBuffer = heap_alloc_zero(MAX_HEADER_TEXT_LEN * sizeof(CHAR));
+            pvBuffer = calloc(MAX_HEADER_TEXT_LEN, sizeof(CHAR));
     }
     dispInfo.pszText      = pvBuffer;
     dispInfo.cchTextMax   = (pvBuffer!=NULL?MAX_HEADER_TEXT_LEN:0);
@@ -1031,7 +1030,7 @@ HEADER_PrepareCallbackItems(const HEADER_INFO *infoPtr, INT iItem, INT reqMask)
         else
         {
             Str_SetPtrAtoW(&lpItem->pszText, (LPSTR)dispInfo.pszText);
-            heap_free(pvBuffer);
+            free(pvBuffer);
         }
     }
         
@@ -1057,7 +1056,7 @@ HEADER_FreeCallbackItems(HEADER_ITEM *lpItem)
 {
     if (lpItem->callbackMask&HDI_TEXT)
     {
-        heap_free(lpItem->pszText);
+        free(lpItem->pszText);
         lpItem->pszText = NULL;
     }
 
@@ -1179,15 +1178,15 @@ HEADER_DeleteItem (HEADER_INFO *infoPtr, INT iItem)
        TRACE("%d: order=%d, iOrder=%d, ->iOrder=%d\n", i, infoPtr->order[i], infoPtr->items[i].iOrder, infoPtr->items[infoPtr->order[i]].iOrder);
 
     iOrder = infoPtr->items[iItem].iOrder;
-    heap_free(infoPtr->items[iItem].pszText);
+    free(infoPtr->items[iItem].pszText);
 
     infoPtr->uNumItem--;
     memmove(&infoPtr->items[iItem], &infoPtr->items[iItem + 1],
             (infoPtr->uNumItem - iItem) * sizeof(HEADER_ITEM));
     memmove(&infoPtr->order[iOrder], &infoPtr->order[iOrder + 1],
             (infoPtr->uNumItem - iOrder) * sizeof(INT));
-    infoPtr->items = heap_realloc(infoPtr->items, sizeof(HEADER_ITEM) * infoPtr->uNumItem);
-    infoPtr->order = heap_realloc(infoPtr->order, sizeof(INT) * infoPtr->uNumItem);
+    infoPtr->items = realloc(infoPtr->items, sizeof(HEADER_ITEM) * infoPtr->uNumItem);
+    infoPtr->order = realloc(infoPtr->order, sizeof(INT) * infoPtr->uNumItem);
         
     /* Correct the orders */
     for (i = 0; i < infoPtr->uNumItem; i++)
@@ -1417,8 +1416,8 @@ HEADER_InsertItemT (HEADER_INFO *infoPtr, INT nItem, const HDITEMW *phdi, BOOL b
         iOrder = infoPtr->uNumItem;
 
     infoPtr->uNumItem++;
-    infoPtr->items = heap_realloc(infoPtr->items, sizeof(HEADER_ITEM) * infoPtr->uNumItem);
-    infoPtr->order = heap_realloc(infoPtr->order, sizeof(INT) * infoPtr->uNumItem);
+    infoPtr->items = realloc(infoPtr->items, sizeof(HEADER_ITEM) * infoPtr->uNumItem);
+    infoPtr->order = realloc(infoPtr->order, sizeof(INT) * infoPtr->uNumItem);
     
     /* make space for the new item */
     memmove(&infoPtr->items[nItem + 1], &infoPtr->items[nItem],
@@ -1537,7 +1536,7 @@ HEADER_SetItemT (HEADER_INFO *infoPtr, INT nItem, const HDITEMW *phdi, BOOL bUni
     HEADER_CopyHDItemForNotify(infoPtr, &hdNotify, phdi, bUnicode, &pvScratch);
     if (HEADER_SendNotifyWithHDItemT(infoPtr, HDN_ITEMCHANGINGW, nItem, &hdNotify))
     {
-        heap_free(pvScratch);
+        free(pvScratch);
         return FALSE;
     }
 
@@ -1554,7 +1553,7 @@ HEADER_SetItemT (HEADER_INFO *infoPtr, INT nItem, const HDITEMW *phdi, BOOL bUni
 
     InvalidateRect(infoPtr->hwndSelf, NULL, FALSE);
 
-    heap_free(pvScratch);
+    free(pvScratch);
     return TRUE;
 }
 
@@ -1577,7 +1576,7 @@ HEADER_Create (HWND hwnd, const CREATESTRUCTW *lpcs)
     HFONT hOldFont;
     HDC   hdc;
 
-    infoPtr = heap_alloc_zero (sizeof(*infoPtr));
+    infoPtr = calloc(1, sizeof(*infoPtr));
     SetWindowLongPtrW (hwnd, 0, (DWORD_PTR)infoPtr);
 
     infoPtr->hwndSelf = hwnd;
@@ -1632,14 +1631,14 @@ HEADER_NCDestroy (HEADER_INFO *infoPtr)
     if (infoPtr->items) {
         lpItem = infoPtr->items;
         for (nItem = 0; nItem < infoPtr->uNumItem; nItem++, lpItem++)
-            heap_free(lpItem->pszText);
-        heap_free(infoPtr->items);
+            free(lpItem->pszText);
+        free(infoPtr->items);
     }
 
-    heap_free(infoPtr->order);
+    free(infoPtr->order);
 
     SetWindowLongPtrW (infoPtr->hwndSelf, 0, 0);
-    heap_free(infoPtr);
+    free(infoPtr);
 
     return 0;
 }
-- 
GitLab


From a1f4a2d13ab33fa82bc42ae14e7f6c39ef4ddca5 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 23 Nov 2022 08:51:28 +0300
Subject: [PATCH 2/5] comctl32/monthcal: Use CRT allocation functions.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/comctl32/monthcal.c | 28 +++++++++++++---------------
 1 file changed, 13 insertions(+), 15 deletions(-)

diff --git a/dlls/comctl32/monthcal.c b/dlls/comctl32/monthcal.c
index 4fc984f6f4b..ea220136182 100644
--- a/dlls/comctl32/monthcal.c
+++ b/dlls/comctl32/monthcal.c
@@ -46,7 +46,6 @@
 #include "uxtheme.h"
 #include "vssym32.h"
 #include "wine/debug.h"
-#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(monthcal);
 
@@ -1946,7 +1945,7 @@ static void MONTHCAL_NotifyDayState(MONTHCAL_INFO *infoPtr)
   nmds.nmhdr.idFrom   = GetWindowLongPtrW(infoPtr->hwndSelf, GWLP_ID);
   nmds.nmhdr.code     = MCN_GETDAYSTATE;
   nmds.cDayState      = MONTHCAL_GetMonthRange(infoPtr, GMR_DAYSTATE, 0);
-  nmds.prgDayState    = state = heap_alloc_zero(nmds.cDayState * sizeof(MONTHDAYSTATE));
+  nmds.prgDayState    = state = calloc(nmds.cDayState, sizeof(MONTHDAYSTATE));
 
   MONTHCAL_GetMinDate(infoPtr, &nmds.stStart);
   nmds.stStart.wDay = 1;
@@ -1955,7 +1954,7 @@ static void MONTHCAL_NotifyDayState(MONTHCAL_INFO *infoPtr)
   memcpy(infoPtr->monthdayState, nmds.prgDayState,
       MONTHCAL_GetMonthRange(infoPtr, GMR_DAYSTATE, 0)*sizeof(MONTHDAYSTATE));
 
-  heap_free(state);
+  free(state);
 }
 
 /* no valid range check performed */
@@ -2593,9 +2592,9 @@ static void MONTHCAL_UpdateSize(MONTHCAL_INFO *infoPtr)
   {
       infoPtr->dim.cx = x;
       infoPtr->dim.cy = y;
-      infoPtr->calendars = heap_realloc(infoPtr->calendars, MONTHCAL_GetCalCount(infoPtr)*sizeof(CALENDAR_INFO));
+      infoPtr->calendars = realloc(infoPtr->calendars, MONTHCAL_GetCalCount(infoPtr)*sizeof(CALENDAR_INFO));
 
-      infoPtr->monthdayState = heap_realloc(infoPtr->monthdayState,
+      infoPtr->monthdayState = realloc(infoPtr->monthdayState,
           MONTHCAL_GetMonthRange(infoPtr, GMR_DAYSTATE, 0)*sizeof(MONTHDAYSTATE));
       MONTHCAL_NotifyDayState(infoPtr);
 
@@ -2750,7 +2749,7 @@ MONTHCAL_Create(HWND hwnd, LPCREATESTRUCTW lpcs)
   MONTHCAL_INFO *infoPtr;
 
   /* allocate memory for info structure */
-  infoPtr = heap_alloc_zero(sizeof(*infoPtr));
+  infoPtr = calloc(1, sizeof(*infoPtr));
   SetWindowLongPtrW(hwnd, 0, (DWORD_PTR)infoPtr);
 
   if (infoPtr == NULL) {
@@ -2762,9 +2761,9 @@ MONTHCAL_Create(HWND hwnd, LPCREATESTRUCTW lpcs)
   infoPtr->hwndNotify = lpcs->hwndParent;
   infoPtr->dwStyle = GetWindowLongW(hwnd, GWL_STYLE);
   infoPtr->dim.cx = infoPtr->dim.cy = 1;
-  infoPtr->calendars = heap_alloc_zero(sizeof(CALENDAR_INFO));
+  infoPtr->calendars = calloc(1, sizeof(*infoPtr->calendars));
   if (!infoPtr->calendars) goto fail;
-  infoPtr->monthdayState = heap_alloc_zero(3 * sizeof(MONTHDAYSTATE));
+  infoPtr->monthdayState = calloc(3, sizeof(*infoPtr->monthdayState));
   if (!infoPtr->monthdayState) goto fail;
 
   /* initialize info structure */
@@ -2805,9 +2804,9 @@ MONTHCAL_Create(HWND hwnd, LPCREATESTRUCTW lpcs)
   return 0;
 
 fail:
-  heap_free(infoPtr->monthdayState);
-  heap_free(infoPtr->calendars);
-  heap_free(infoPtr);
+  free(infoPtr->monthdayState);
+  free(infoPtr->calendars);
+  free(infoPtr);
   return 0;
 }
 
@@ -2816,9 +2815,8 @@ MONTHCAL_Destroy(MONTHCAL_INFO *infoPtr)
 {
   INT i;
 
-  /* free month calendar info data */
-  heap_free(infoPtr->monthdayState);
-  heap_free(infoPtr->calendars);
+  free(infoPtr->monthdayState);
+  free(infoPtr->calendars);
   SetWindowLongPtrW(infoPtr->hwndSelf, 0, 0);
 
   CloseThemeData (GetWindowTheme (infoPtr->hwndSelf));
@@ -2826,7 +2824,7 @@ MONTHCAL_Destroy(MONTHCAL_INFO *infoPtr)
   for (i = 0; i < BrushLast; i++) DeleteObject(infoPtr->brushes[i]);
   for (i = 0; i < PenLast; i++) DeleteObject(infoPtr->pens[i]);
 
-  heap_free(infoPtr);
+  free(infoPtr);
   return 0;
 }
 
-- 
GitLab


From 7ef99635fbbec9c553bfb70f945730aa43e9ed0f Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 23 Nov 2022 08:53:32 +0300
Subject: [PATCH 3/5] comctl32/static: Use CRT allocation functions.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/comctl32/static.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/dlls/comctl32/static.c b/dlls/comctl32/static.c
index 25eee289204..cab0235b8d3 100644
--- a/dlls/comctl32/static.c
+++ b/dlls/comctl32/static.c
@@ -29,6 +29,7 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -37,7 +38,6 @@
 #include "commctrl.h"
 #include "uxtheme.h"
 
-#include "wine/heap.h"
 #include "wine/debug.h"
 
 #include "comctl32.h"
@@ -94,7 +94,7 @@ static struct static_extra_info *get_extra_ptr( HWND hwnd, BOOL force )
     struct static_extra_info *extra = (struct static_extra_info *)GetWindowLongPtrW( hwnd, 0 );
     if (!extra && force)
     {
-        extra = heap_alloc_zero( sizeof(*extra) );
+        extra = calloc( 1, sizeof(*extra) );
         if (extra)
             SetWindowLongPtrW( hwnd, 0, (ULONG_PTR)extra );
     }
@@ -470,7 +470,7 @@ static LRESULT CALLBACK STATIC_WindowProc( HWND hwnd, UINT uMsg, WPARAM wParam,
             {
                 if (extra->image_has_alpha)
                     DeleteObject( extra->image.hbitmap );
-                heap_free( extra );
+                free( extra );
             }
 /*
  * FIXME
@@ -751,13 +751,13 @@ static void STATIC_PaintTextfn( HWND hwnd, HDC hdc, HBRUSH hbrush, DWORD style )
     }
 
     buf_size = 256;
-    if (!(text = HeapAlloc( GetProcessHeap(), 0, buf_size * sizeof(WCHAR) )))
+    if (!(text = malloc( buf_size * sizeof(WCHAR) )))
         goto no_TextOut;
 
     while ((len = InternalGetWindowText( hwnd, text, buf_size )) == buf_size - 1)
     {
         buf_size *= 2;
-        if (!(text = HeapReAlloc( GetProcessHeap(), 0, text, buf_size * sizeof(WCHAR) )))
+        if (!(text = realloc( text, buf_size * sizeof(WCHAR) )))
             goto no_TextOut;
     }
 
@@ -777,7 +777,7 @@ static void STATIC_PaintTextfn( HWND hwnd, HDC hdc, HBRUSH hbrush, DWORD style )
     }
 
 no_TextOut:
-    HeapFree( GetProcessHeap(), 0, text );
+    free( text );
 
     if (hFont)
         SelectObject( hdc, hOldFont );
-- 
GitLab


From aa98d43c45d3c0d71dfd2f28c4f89ca108a8614c Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 23 Nov 2022 11:43:49 +0300
Subject: [PATCH 4/5] comctl32/button: Use CRT allocation functions.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/comctl32/button.c | 33 ++++++++++++++++-----------------
 1 file changed, 16 insertions(+), 17 deletions(-)

diff --git a/dlls/comctl32/button.c b/dlls/comctl32/button.c
index 6c04c458a6a..d4196b144ed 100644
--- a/dlls/comctl32/button.c
+++ b/dlls/comctl32/button.c
@@ -55,7 +55,6 @@
 #include "uxtheme.h"
 #include "vssym32.h"
 #include "wine/debug.h"
-#include "wine/heap.h"
 
 #include "comctl32.h"
 
@@ -255,7 +254,7 @@ static inline void paint_button( BUTTON_INFO *infoPtr, LONG style, UINT action )
 static inline WCHAR *get_button_text( const BUTTON_INFO *infoPtr )
 {
     INT len = GetWindowTextLengthW( infoPtr->hwnd );
-    WCHAR *buffer = heap_alloc( (len + 1) * sizeof(WCHAR) );
+    WCHAR *buffer = malloc( (len + 1) * sizeof(WCHAR) );
     if (buffer)
         GetWindowTextW( infoPtr->hwnd, buffer, len + 1 );
     return buffer;
@@ -335,7 +334,7 @@ HRGN set_control_clipping( HDC hdc, const RECT *rect )
 static WCHAR *heap_strndupW(const WCHAR *src, size_t length)
 {
     size_t size = (length + 1) * sizeof(WCHAR);
-    WCHAR *dst = heap_alloc(size);
+    WCHAR *dst = malloc(size);
     if (dst) memcpy(dst, src, size);
     return dst;
 }
@@ -504,7 +503,7 @@ static LRESULT CALLBACK BUTTON_WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, L
     {
         CREATESTRUCTW *cs = (CREATESTRUCTW *)lParam;
 
-        infoPtr = heap_alloc_zero( sizeof(*infoPtr) );
+        infoPtr = calloc( 1, sizeof(*infoPtr) );
         SetWindowLongPtrW( hWnd, 0, (LONG_PTR)infoPtr );
         infoPtr->hwnd = hWnd;
         infoPtr->parent = cs->hwndParent;
@@ -521,8 +520,8 @@ static LRESULT CALLBACK BUTTON_WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, L
             DeleteObject(infoPtr->u.bitmap);
         else if (infoPtr->image_type == IMAGE_ICON)
             DestroyIcon(infoPtr->u.icon);
-        heap_free(infoPtr->note);
-        heap_free(infoPtr);
+        free(infoPtr->note);
+        free(infoPtr);
         break;
 
     case WM_CREATE:
@@ -782,7 +781,7 @@ static LRESULT CALLBACK BUTTON_WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, L
             return FALSE;
         }
 
-        heap_free(infoPtr->note);
+        free(infoPtr->note);
         if (note)
         {
             infoPtr->note_length = lstrlenW(note);
@@ -792,7 +791,7 @@ static LRESULT CALLBACK BUTTON_WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, L
         if (!note || !infoPtr->note)
         {
             infoPtr->note_length = 0;
-            infoPtr->note = heap_alloc_zero(sizeof(WCHAR));
+            infoPtr->note = calloc(1, sizeof(WCHAR));
         }
 
         SetLastError(NO_ERROR);
@@ -1289,7 +1288,7 @@ static void BUTTON_GetTextIdealSize(BUTTON_INFO *infoPtr, LONG maxWidth, SIZE *s
     hdc = GetDC(infoPtr->hwnd);
     rect = BUTTON_GetTextRect(infoPtr, hdc, text, maxWidth);
     ReleaseDC(infoPtr->hwnd, hdc);
-    heap_free(text);
+    free(text);
 
     size->cx = rect.right - rect.left + margin->left + margin->right;
     size->cy = rect.bottom - rect.top + margin->top + margin->bottom;
@@ -1489,7 +1488,7 @@ static BOOL CL_GetIdealSize(BUTTON_INFO *infoPtr, SIZE *size)
             RECT r;
             GetThemeTextExtent(theme, hdc, BP_COMMANDLINK, CMDLS_NORMAL,
                                text, -1, flags, &text_bound, &r);
-            heap_free(text);
+            free(text);
             text_w = r.right - r.left;
             text_h = r.bottom - r.top;
         }
@@ -1527,7 +1526,7 @@ static BOOL CL_GetIdealSize(BUTTON_INFO *infoPtr, SIZE *size)
                     RECT r = text_bound;
                     old_font = SelectObject(hdc, font);
                     DrawTextW(hdc, text, -1, &r, flags | DT_CALCRECT);
-                    heap_free(text);
+                    free(text);
 
                     text_w = r.right - r.left;
                     text_h = r.bottom - r.top;
@@ -1596,7 +1595,7 @@ static UINT BUTTON_CalcLayoutRects(const BUTTON_INFO *infoPtr, HDC hdc, RECT *la
        SetRectEmpty(labelRc);
        SetRectEmpty(imageRc);
        SetRectEmpty(textRc);
-       heap_free(text);
+       free(text);
        return (UINT)-1;
    }
 
@@ -1699,7 +1698,7 @@ static UINT BUTTON_CalcLayoutRects(const BUTTON_INFO *infoPtr, HDC hdc, RECT *la
            SetRectEmpty(&imageRect);
        }
    }
-   heap_free(text);
+   free(text);
 
    CopyRect(labelRc, &labelRect);
    CopyRect(imageRc, &imageRect);
@@ -1792,7 +1791,7 @@ static void BUTTON_DrawLabel(const BUTTON_INFO *infoPtr, HDC hdc, UINT dtFlags,
    if (!(text = get_button_text(infoPtr))) return;
    DrawStateW(hdc, hbr, BUTTON_DrawTextCallback, (LPARAM)text, dtFlags, textRect->left, textRect->top,
               textRect->right - textRect->left, textRect->bottom - textRect->top, flags);
-   heap_free(text);
+   free(text);
 }
 
 static void BUTTON_DrawThemedLabel(const BUTTON_INFO *info, HDC hdc, UINT text_flags,
@@ -1824,7 +1823,7 @@ static void BUTTON_DrawThemedLabel(const BUTTON_INFO *info, HDC hdc, UINT text_f
        return;
 
    DrawThemeText(theme, hdc, part, state, text, lstrlenW(text), text_flags, 0, text_rect);
-   heap_free(text);
+   free(text);
 }
 
 /**********************************************************************
@@ -2660,7 +2659,7 @@ static void CL_Paint( const BUTTON_INFO *infoPtr, HDC hDC, UINT action )
                     SelectObject(hDC, font);
                     txt_h = DrawTextW(hDC, text, -1, &r,
                                       DT_TOP | DT_LEFT | DT_WORDBREAK | DT_END_ELLIPSIS);
-                    heap_free(text);
+                    free(text);
                 }
                 DeleteObject(font);
             }
@@ -3153,7 +3152,7 @@ static void CL_ThemedPaint(HTHEME theme, const BUTTON_INFO *infoPtr, HDC hDC, in
             DrawThemeText(theme, hDC, part, state, text, len, dtFlags | DT_END_ELLIPSIS, 0, &r);
 
             txt_h = text_rect.bottom - text_rect.top;
-            heap_free(text);
+            free(text);
         }
 
         /* Draw the note */
-- 
GitLab


From 0002cb89ec511b1ba0193a78bc46e7b2cae40ae8 Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 23 Nov 2022 11:50:29 +0300
Subject: [PATCH 5/5] comctl32/listview: Use CRT allocation functions.

Signed-off-by: Nikolay Sivov <nsivov@codeweavers.com>
---
 dlls/comctl32/listview.c | 91 ++++++++++++++++++++--------------------
 1 file changed, 45 insertions(+), 46 deletions(-)

diff --git a/dlls/comctl32/listview.c b/dlls/comctl32/listview.c
index d060fd5c977..116c3c5cf94 100644
--- a/dlls/comctl32/listview.c
+++ b/dlls/comctl32/listview.c
@@ -485,7 +485,7 @@ static inline LPWSTR textdupTtoW(LPCWSTR text, BOOL isW)
     if (!isW && is_text(text))
     {
 	INT len = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)text, -1, NULL, 0);
-	wstr = Alloc(len * sizeof(WCHAR));
+	wstr = calloc(len, sizeof(WCHAR));
 	if (wstr) MultiByteToWideChar(CP_ACP, 0, (LPCSTR)text, -1, wstr, len);
     }
     TRACE("   wstr=%s\n", text == LPSTR_TEXTCALLBACKW ?  "(callback)" : debugstr_w(wstr));
@@ -494,7 +494,7 @@ static inline LPWSTR textdupTtoW(LPCWSTR text, BOOL isW)
 
 static inline void textfreeT(LPWSTR wstr, BOOL isW)
 {
-    if (!isW && is_text(wstr)) Free (wstr);
+    if (!isW && is_text(wstr)) free (wstr);
 }
 
 /*
@@ -507,7 +507,7 @@ static BOOL textsetptrT(LPWSTR *dest, LPCWSTR src, BOOL isW)
     
     if (src == LPSTR_TEXTCALLBACKW)
     {
-	if (is_text(*dest)) Free(*dest);
+	if (is_text(*dest)) free(*dest);
 	*dest = LPSTR_TEXTCALLBACKW;
     }
     else
@@ -808,12 +808,12 @@ static LRESULT notify_forward_header(const LISTVIEW_INFO *infoPtr, NMHEADERW *lp
     /* cleanup */
     if(text)
     {
-        Free(lpnmh->pitem->pszText);
+        free(lpnmh->pitem->pszText);
         lpnmh->pitem->pszText = (LPSTR)text;
     }
     if(filter)
     {
-        Free(((HD_TEXTFILTERA*)lpnmh->pitem->pvFilter)->pszText);
+        free(((HD_TEXTFILTERA*)lpnmh->pitem->pvFilter)->pszText);
         ((HD_TEXTFILTERA*)lpnmh->pitem->pvFilter)->pszText = (LPSTR)filter;
     }
 
@@ -958,7 +958,7 @@ static BOOL notify_dispinfoT(const LISTVIEW_INFO *infoPtr, UINT code, LPNMLVDISP
             *pdi->item.pszText = 0; /* make sure we don't process garbage */
         }
 
-        buffer = Alloc( (return_ansi ? sizeof(WCHAR) : sizeof(CHAR)) * length);
+        buffer = calloc( length, return_ansi ? sizeof(WCHAR) : sizeof(CHAR) );
         if (!buffer) return FALSE;
 
         if (return_ansi)
@@ -1001,7 +1001,7 @@ static BOOL notify_dispinfoT(const LISTVIEW_INFO *infoPtr, UINT code, LPNMLVDISP
         pdi->item.pszText = ret_text; /* restores our buffer */
         pdi->item.cchTextMax = ret_length;
 
-        Free(buffer);
+        free(buffer);
         return ret;
     }
 
@@ -1010,14 +1010,14 @@ static BOOL notify_dispinfoT(const LISTVIEW_INFO *infoPtr, UINT code, LPNMLVDISP
     {
         length = WideCharToMultiByte(CP_ACP, 0, pdi->item.pszText, -1, NULL, 0, NULL, NULL);
 
-        buffer = Alloc(length * sizeof(CHAR));
+        buffer = calloc(length, sizeof(CHAR));
         if (!buffer) return FALSE;
 
         WideCharToMultiByte(CP_ACP, 0, pdi->item.pszText, -1, (LPSTR) buffer,
                 ret_length, NULL, NULL);
 
         strcpy((LPSTR)pdi->item.pszText, (LPSTR)buffer);
-        Free(buffer);
+        free(buffer);
     }
 
     return ret;
@@ -3118,11 +3118,11 @@ static void ranges_assert(RANGES ranges, LPCSTR desc, const char *file, int line
 
 static RANGES ranges_create(int count)
 {
-    RANGES ranges = Alloc(sizeof(struct tagRANGES));
+    RANGES ranges = calloc(1, sizeof(*ranges));
     if (!ranges) return NULL;
     ranges->hdpa = DPA_Create(count);
     if (ranges->hdpa) return ranges;
-    Free(ranges);
+    free(ranges);
     return NULL;
 }
 
@@ -3131,7 +3131,7 @@ static void ranges_clear(RANGES ranges)
     INT i;
 	
     for(i = 0; i < DPA_GetPtrCount(ranges->hdpa); i++)
-	Free(DPA_GetPtr(ranges->hdpa, i));
+        free(DPA_GetPtr(ranges->hdpa, i));
     DPA_DeleteAllPtrs(ranges->hdpa);
 }
 
@@ -3141,7 +3141,7 @@ static void ranges_destroy(RANGES ranges)
     if (!ranges) return;
     ranges_clear(ranges);
     DPA_Destroy(ranges->hdpa);
-    Free(ranges);
+    free(ranges);
 }
 
 static RANGES ranges_clone(RANGES ranges)
@@ -3153,12 +3153,12 @@ static RANGES ranges_clone(RANGES ranges)
 
     for (i = 0; i < DPA_GetPtrCount(ranges->hdpa); i++)
     {
-        RANGE *newrng = Alloc(sizeof(RANGE));
+        RANGE *newrng = calloc(1, sizeof(*newrng));
 	if (!newrng) goto fail;
 	*newrng = *((RANGE*)DPA_GetPtr(ranges->hdpa, i));
         if (!DPA_SetPtr(clone->hdpa, i, newrng))
         {
-            Free(newrng);
+            free(newrng);
             goto fail;
         }
     }
@@ -3249,7 +3249,7 @@ static BOOL ranges_add(RANGES ranges, RANGE range)
 	TRACE("Adding new range\n");
 
 	/* create the brand new range to insert */	
-        newrgn = Alloc(sizeof(RANGE));
+        newrgn = calloc(1, sizeof(*newrgn));
 	if(!newrgn) goto fail;
 	*newrgn = range;
 	
@@ -3261,7 +3261,7 @@ static BOOL ranges_add(RANGES ranges, RANGE range)
 	/* and get it over with */
 	if (DPA_InsertPtr(ranges->hdpa, index, newrgn) == -1)
 	{
-	    Free(newrgn);
+	    free(newrgn);
 	    goto fail;
 	}
     }
@@ -3298,7 +3298,7 @@ static BOOL ranges_add(RANGES ranges, RANGE range)
 	    mrgrgn = DPA_GetPtr(ranges->hdpa, mergeindex);
 	    chkrgn->lower = min(chkrgn->lower, mrgrgn->lower);
 	    chkrgn->upper = max(chkrgn->upper, mrgrgn->upper);
-	    Free(mrgrgn);
+	    free(mrgrgn);
 	    DPA_DeletePtr(ranges->hdpa, mergeindex);
 	    if (mergeindex < index) index --;
 	} while(1);
@@ -3334,7 +3334,7 @@ static BOOL ranges_del(RANGES ranges, RANGE range)
 	     (chkrgn->lower == range.lower) )
 	{
 	    DPA_DeletePtr(ranges->hdpa, index);
-	    Free(chkrgn);
+	    free(chkrgn);
 	    break;
 	}
 	/* case 2: engulf */
@@ -3342,7 +3342,7 @@ static BOOL ranges_del(RANGES ranges, RANGE range)
 		  (chkrgn->lower >= range.lower) )
 	{
 	    DPA_DeletePtr(ranges->hdpa, index);
-	    Free(chkrgn);
+	    free(chkrgn);
 	}
 	/* case 3: overlap upper */
 	else if ( (chkrgn->upper <= range.upper) &&
@@ -3362,13 +3362,13 @@ static BOOL ranges_del(RANGES ranges, RANGE range)
 	{
 	    RANGE *newrgn;
 
-	    if (!(newrgn = Alloc(sizeof(RANGE)))) goto fail;
+	    if (!(newrgn = calloc(1, sizeof(*newrgn)))) goto fail;
 	    newrgn->lower = chkrgn->lower;
 	    newrgn->upper = range.lower;
 	    chkrgn->lower = range.upper;
 	    if (DPA_InsertPtr(ranges->hdpa, index, newrgn) == -1)
 	    {
-		Free(newrgn);
+		free(newrgn);
 		goto fail;
 	    }
 	    break;
@@ -4422,7 +4422,7 @@ static BOOL set_sub_item(const LISTVIEW_INFO *infoPtr, const LVITEMW *lpLVItem,
 	SUBITEM_INFO *tmpSubItem;
 	INT i;
 
-	lpSubItem = Alloc(sizeof(SUBITEM_INFO));
+	lpSubItem = calloc(1, sizeof(*lpSubItem));
 	if (!lpSubItem) return FALSE;
 	/* we could binary search here, if need be...*/
   	for (i = 1; i < DPA_GetPtrCount(hdpaSubItems); i++)
@@ -4432,7 +4432,7 @@ static BOOL set_sub_item(const LISTVIEW_INFO *infoPtr, const LVITEMW *lpLVItem,
   	}
 	if (DPA_InsertPtr(hdpaSubItems, i, lpSubItem) == -1)
 	{
-	    Free(lpSubItem);
+	    free(lpSubItem);
 	    return FALSE;
 	}
         lpSubItem->iSubItem = lpLVItem->iSubItem;
@@ -5568,13 +5568,13 @@ static BOOL LISTVIEW_DeleteAllItems(LISTVIEW_INFO *infoPtr, BOOL destroy)
 	    j = DPA_GetPtrIndex(infoPtr->hdpaItemIds, lpItem->id);
 	    lpID = DPA_GetPtr(infoPtr->hdpaItemIds, j);
 	    DPA_DeletePtr(infoPtr->hdpaItemIds, j);
-	    Free(lpID);
+	    free(lpID);
 	    /* both item and subitem start with ITEMHDR header */
 	    for (j = 0; j < DPA_GetPtrCount(hdpaSubItems); j++)
 	    {
 	        hdrItem = DPA_GetPtr(hdpaSubItems, j);
-		if (is_text(hdrItem->pszText)) Free(hdrItem->pszText);
-		Free(hdrItem);
+		if (is_text(hdrItem->pszText)) free(hdrItem->pszText);
+		free(hdrItem);
 	    }
 	    DPA_Destroy(hdpaSubItems);
 	    DPA_DeletePtr(infoPtr->hdpaItems, i);
@@ -5683,7 +5683,7 @@ static BOOL LISTVIEW_DeleteColumn(LISTVIEW_INFO *infoPtr, INT nColumn)
     if (!SendMessageW(infoPtr->hwndHeader, HDM_DELETEITEM, nColumn, 0))
 	return FALSE;
 
-    Free(DPA_GetPtr(infoPtr->hdpaColumns, nColumn));
+    free(DPA_GetPtr(infoPtr->hdpaColumns, nColumn));
     DPA_DeletePtr(infoPtr->hdpaColumns, nColumn);
   
     if (!(infoPtr->dwStyle & LVS_OWNERDATA) && nColumn)
@@ -5716,10 +5716,10 @@ static BOOL LISTVIEW_DeleteColumn(LISTVIEW_INFO *infoPtr, INT nColumn)
 	    {
 		/* free string */
 		if (is_text(lpDelItem->hdr.pszText))
-		    Free(lpDelItem->hdr.pszText);
+		    free(lpDelItem->hdr.pszText);
 
 		/* free item */
-		Free(lpDelItem);
+		free(lpDelItem);
 
 		/* free dpa memory */
 		DPA_DeletePtr(hdpaSubItems, nSubItem);
@@ -5858,12 +5858,12 @@ static BOOL LISTVIEW_DeleteItem(LISTVIEW_INFO *infoPtr, INT nItem)
 	i = DPA_GetPtrIndex(infoPtr->hdpaItemIds, lpItem->id);
 	lpID = DPA_GetPtr(infoPtr->hdpaItemIds, i);
 	DPA_DeletePtr(infoPtr->hdpaItemIds, i);
-	Free(lpID);
+	free(lpID);
 	for (i = 0; i < DPA_GetPtrCount(hdpaSubItems); i++)
     	{
             hdrItem = DPA_GetPtr(hdpaSubItems, i);
-	    if (is_text(hdrItem->pszText)) Free(hdrItem->pszText);
-            Free(hdrItem);
+	    if (is_text(hdrItem->pszText)) free(hdrItem->pszText);
+            free(hdrItem);
         }
         DPA_Destroy(hdpaSubItems);
     }
@@ -5914,7 +5914,7 @@ static BOOL LISTVIEW_EndEditLabelT(LISTVIEW_INFO *infoPtr, BOOL storeText, BOOL
 
         if (len++)
         {
-            if (!(pszText = Alloc(len * (isW ? sizeof(WCHAR) : sizeof(CHAR)))))
+            if (!(pszText = calloc(len, isW ? sizeof(WCHAR) : sizeof(CHAR))))
                 return FALSE;
 
             if (isW)
@@ -5998,7 +5998,7 @@ static BOOL LISTVIEW_EndEditLabelT(LISTVIEW_INFO *infoPtr, BOOL storeText, BOOL
     res = LISTVIEW_SetItemT(infoPtr, &dispInfo.item, isW);
 
 cleanup:
-    Free(pszText);
+    free(pszText);
 
     return res;
 }
@@ -7788,14 +7788,14 @@ static INT LISTVIEW_InsertItemT(LISTVIEW_INFO *infoPtr, const LVITEMW *lpLVItem,
 
     if (!is_assignable_item(lpLVItem, infoPtr->dwStyle)) return -1;
 
-    if (!(lpItem = Alloc(sizeof(ITEM_INFO)))) return -1;
+    if (!(lpItem = calloc(1, sizeof(*lpItem)))) return -1;
     
     /* insert item in listview control data structure */
     if ( !(hdpaSubItems = DPA_Create(8)) ) goto fail;
     if ( !DPA_SetPtr(hdpaSubItems, 0, lpItem) ) assert (FALSE);
 
     /* link with id struct */
-    if (!(lpID = Alloc(sizeof(ITEM_ID)))) goto fail;
+    if (!(lpID = calloc(1, sizeof(*lpID)))) goto fail;
     lpItem->id = lpID;
     lpID->item = hdpaSubItems;
     lpID->id = get_next_itemid(infoPtr);
@@ -7923,7 +7923,7 @@ undo:
 fail:
     DPA_DeletePtr(hdpaSubItems, 0);
     DPA_Destroy (hdpaSubItems);
-    Free (lpItem);
+    free (lpItem);
     return -1;
 }
 
@@ -8248,7 +8248,7 @@ static INT LISTVIEW_InsertColumnT(LISTVIEW_INFO *infoPtr, INT nColumn,
     if (nNewColumn != nColumn) ERR("nColumn=%d, nNewColumn=%d\n", nColumn, nNewColumn);
    
     /* create our own column info */ 
-    if (!(lpColumnInfo = Alloc(sizeof(COLUMN_INFO)))) goto fail;
+    if (!(lpColumnInfo = calloc(1, sizeof(*lpColumnInfo)))) goto fail;
     if (DPA_InsertPtr(infoPtr->hdpaColumns, nNewColumn, lpColumnInfo) == -1) goto fail;
 
     if (lpColumn->mask & LVCF_FMT) lpColumnInfo->fmt = lpColumn->fmt;
@@ -8296,8 +8296,8 @@ fail:
     if (nNewColumn != -1) SendMessageW(infoPtr->hwndHeader, HDM_DELETEITEM, nNewColumn, 0);
     if (lpColumnInfo)
     {
-	DPA_DeletePtr(infoPtr->hdpaColumns, nNewColumn);
-	Free(lpColumnInfo);
+        DPA_DeletePtr(infoPtr->hdpaColumns, nNewColumn);
+        free(lpColumnInfo);
     }
     return -1;
 }
@@ -9546,7 +9546,7 @@ static LRESULT LISTVIEW_NCCreate(HWND hwnd, WPARAM wParam, const CREATESTRUCTW *
   TRACE("(lpcs=%p)\n", lpcs);
 
   /* initialize info pointer */
-  infoPtr = Alloc(sizeof(LISTVIEW_INFO));
+  infoPtr = calloc(1, sizeof(*infoPtr));
   if (!infoPtr) return FALSE;
 
   SetWindowLongPtrW(hwnd, 0, (DWORD_PTR)infoPtr);
@@ -9609,7 +9609,7 @@ fail:
     DPA_Destroy(infoPtr->hdpaPosX);
     DPA_Destroy(infoPtr->hdpaPosY);
     DPA_Destroy(infoPtr->hdpaColumns);
-    Free(infoPtr);
+    free(infoPtr);
     return FALSE;
 }
 
@@ -10485,7 +10485,7 @@ static LRESULT LISTVIEW_NCDestroy(LISTVIEW_INFO *infoPtr)
   DPA_Destroy(infoPtr->hdpaPosY);
   /* columns */
   for (i = 0; i < DPA_GetPtrCount(infoPtr->hdpaColumns); i++)
-      Free(DPA_GetPtr(infoPtr->hdpaColumns, i));
+      free(DPA_GetPtr(infoPtr->hdpaColumns, i));
   DPA_Destroy(infoPtr->hdpaColumns);
   ranges_destroy(infoPtr->selectionRanges);
 
@@ -10505,8 +10505,7 @@ static LRESULT LISTVIEW_NCDestroy(LISTVIEW_INFO *infoPtr)
 
   SetWindowLongPtrW(infoPtr->hwndSelf, 0, 0);
 
-  /* free listview info pointer*/
-  Free(infoPtr);
+  free(infoPtr);
 
   return 0;
 }
-- 
GitLab

From a97911fdfe77dac2996d9bb3c1a56acc47bd3fa3 Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Thu, 1 Dec 2022 01:22:07 +0100
Subject: [PATCH 1/2] gdiplus: Improve performance of GdipScaleMatrix.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=53947
---
 dlls/gdiplus/matrix.c       | 25 ++++++++++++----------
 dlls/gdiplus/tests/matrix.c | 41 +++++++++++++++++++++++++++++++++++++
 2 files changed, 55 insertions(+), 11 deletions(-)

diff --git a/dlls/gdiplus/matrix.c b/dlls/gdiplus/matrix.c
index 40abbc93e21..13e7aa05e11 100644
--- a/dlls/gdiplus/matrix.c
+++ b/dlls/gdiplus/matrix.c
@@ -287,24 +287,27 @@ GpStatus WINGDIPAPI GdipRotateMatrix(GpMatrix *matrix, REAL angle,
 GpStatus WINGDIPAPI GdipScaleMatrix(GpMatrix *matrix, REAL scaleX, REAL scaleY,
     GpMatrixOrder order)
 {
-    REAL scale[6];
-
     TRACE("(%p, %.2f, %.2f, %d)\n", matrix, scaleX, scaleY, order);
 
     if(!matrix)
         return InvalidParameter;
 
-    scale[0] = scaleX;
-    scale[1] = 0.0;
-    scale[2] = 0.0;
-    scale[3] = scaleY;
-    scale[4] = 0.0;
-    scale[5] = 0.0;
-
     if(order == MatrixOrderAppend)
-        matrix_multiply(matrix->matrix, scale, matrix->matrix);
+    {
+        matrix->matrix[0] *= scaleX;
+        matrix->matrix[1] *= scaleY;
+        matrix->matrix[2] *= scaleX;
+        matrix->matrix[3] *= scaleY;
+        matrix->matrix[4] *= scaleX;
+        matrix->matrix[5] *= scaleY;
+    }
     else if (order == MatrixOrderPrepend)
-        matrix_multiply(scale, matrix->matrix, matrix->matrix);
+    {
+        matrix->matrix[0] *= scaleX;
+        matrix->matrix[1] *= scaleX;
+        matrix->matrix[2] *= scaleY;
+        matrix->matrix[3] *= scaleY;
+    }
     else
         return InvalidParameter;
 
From 13b16116bfdebf5e198827ad02661db7cffadbcd Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Thu, 1 Dec 2022 18:16:02 +0100
Subject: [PATCH 2/2] gdiplus: Improve performance of matrix multiplication by
 unrolling loop.

---
 dlls/gdiplus/matrix.c | 16 +++++++---------
 1 file changed, 7 insertions(+), 9 deletions(-)

diff --git a/dlls/gdiplus/matrix.c b/dlls/gdiplus/matrix.c
index 13e7aa05e11..d790daab2af 100644
--- a/dlls/gdiplus/matrix.c
+++ b/dlls/gdiplus/matrix.c
@@ -39,17 +39,15 @@ WINE_DEFAULT_DEBUG_CHANNEL(gdiplus);
  *
  * and puts the output in out.
  * */
-static void matrix_multiply(GDIPCONST REAL * left, GDIPCONST REAL * right, REAL * out)
+static inline void matrix_multiply(GDIPCONST REAL * left, GDIPCONST REAL * right, REAL * out)
 {
     REAL temp[6];
-    int i, odd;
-
-    for(i = 0; i < 6; i++){
-        odd = i % 2;
-        temp[i] = left[i - odd] * right[odd] + left[i - odd + 1] * right[odd + 2] +
-                  (i >= 4 ? right[odd + 4] : 0.0);
-    }
-
+    temp[0] = left[0] * right[0] + left[1] * right[2];
+    temp[1] = left[0] * right[1] + left[1] * right[3];
+    temp[2] = left[2] * right[0] + left[3] * right[2];
+    temp[3] = left[2] * right[1] + left[3] * right[3];
+    temp[4] = left[4] * right[0] + left[5] * right[2] + right[4];
+    temp[5] = left[4] * right[1] + left[5] * right[3] + right[5];
     memcpy(out, temp, 6 * sizeof(REAL));
 }
 
-- 
GitLab

From 8f06447075fda39858b0fa5bc867b210bec0dbf8 Mon Sep 17 00:00:00 2001
From: Bartosz Kosiorek <gang65@poczta.onet.pl>
Date: Sat, 3 Dec 2022 00:48:53 +0100
Subject: [PATCH] gdiplus: improve performance of GdipTranslateMatrix

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=53947
---
 dlls/gdiplus/matrix.c       | 21 ++++++++++---------
 dlls/gdiplus/tests/matrix.c | 40 +++++++++++++++++++++++++++++++++++++
 2 files changed, 50 insertions(+), 11 deletions(-)

diff --git a/dlls/gdiplus/matrix.c b/dlls/gdiplus/matrix.c
index d790daab2af..d69672bddcf 100644
--- a/dlls/gdiplus/matrix.c
+++ b/dlls/gdiplus/matrix.c
@@ -417,24 +417,23 @@ GpStatus WINGDIPAPI GdipTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts, I
 GpStatus WINGDIPAPI GdipTranslateMatrix(GpMatrix *matrix, REAL offsetX,
     REAL offsetY, GpMatrixOrder order)
 {
-    REAL translate[6];
-
     TRACE("(%p, %.2f, %.2f, %d)\n", matrix, offsetX, offsetY, order);
 
     if(!matrix)
         return InvalidParameter;
 
-    translate[0] = 1.0;
-    translate[1] = 0.0;
-    translate[2] = 0.0;
-    translate[3] = 1.0;
-    translate[4] = offsetX;
-    translate[5] = offsetY;
-
     if(order == MatrixOrderAppend)
-        matrix_multiply(matrix->matrix, translate, matrix->matrix);
+    {
+        matrix->matrix[4] += offsetX;
+        matrix->matrix[5] += offsetY;
+    }
     else if (order == MatrixOrderPrepend)
-        matrix_multiply(translate, matrix->matrix, matrix->matrix);
+    {
+        matrix->matrix[4] = offsetX * matrix->matrix[0] + offsetY * matrix->matrix[2]
+            + matrix->matrix[4];
+        matrix->matrix[5] = offsetX * matrix->matrix[1] + offsetY * matrix->matrix[3]
+            + matrix->matrix[5];
+    }
     else
         return InvalidParameter;
 
From e2c081a8ebc0722df08e85e32fc26bd42c23ae46 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 18 Nov 2022 20:08:09 -0600
Subject: [PATCH] ntdll: Trace the name of critical sections which are released
 while not acquired.

---
 dlls/ntdll/sync.c | 14 ++++++++++----
 1 file changed, 10 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index f9f906df723..4f5ee820286 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -155,6 +155,13 @@ static BOOL crit_section_has_debuginfo( const RTL_CRITICAL_SECTION *crit )
     return crit->DebugInfo != NULL && crit->DebugInfo != no_debug_info_marker;
 }
 
+static const char *crit_section_get_name( const RTL_CRITICAL_SECTION *crit )
+{
+    if (crit_section_has_debuginfo( crit ))
+        return (char *)crit->DebugInfo->Spare[0];
+    return "?";
+}
+
 static inline HANDLE get_semaphore( RTL_CRITICAL_SECTION *crit )
 {
     HANDLE ret = crit->LockSemaphore;
@@ -328,9 +335,8 @@ NTSTATUS WINAPI RtlpWaitForCriticalSecti
 
         if ( status == STATUS_TIMEOUT )
         {
-            const char *name = NULL;
-            if (crit_section_has_debuginfo( crit )) name = (char *)crit->DebugInfo->Spare[0];
-            if (!name) name = "?";
+            const char *name = crit_section_get_name( crit );
+            
             ERR( "section %p %s wait timed out in thread %04x, blocked by %04x, retrying (60 sec)\n",
                  crit, debugstr_a(name), GetCurrentThreadId(), HandleToULong(crit->OwningThread) );
             status = wait_semaphore( crit, 60 );
@@ -461,7 +467,7 @@ NTSTATUS WINAPI RtlLeaveCriticalSection( RTL_CRITICAL_SECTION *crit )
     if (--crit->RecursionCount)
     {
         if (crit->RecursionCount > 0) InterlockedDecrement( &crit->LockCount );
-        else ERR( "section %p is not acquired\n", crit );
+        else ERR( "section %p %s is not acquired\n", crit, debugstr_a( crit_section_get_name( crit )));
     }
     else
     {
-- 
GitLab

From 750e5ee33cb85c1d95a2642919b87f7f4176097a Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Thu, 22 Dec 2022 01:20:59 +0900
Subject: [PATCH 1/2] user32/tests: Add tests for CS_HREDRAW and CS_VREDRAW.

---
 dlls/user32/tests/msg.c | 130 ++++++++++++++++++++++++++++++++++++++++
 1 file changed, 130 insertions(+)

diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
index 50bfc9855dd..461d79d9a5d 100644
--- a/dlls/user32/tests/msg.c
+++ b/dlls/user32/tests/msg.c
@@ -9416,6 +9416,120 @@ static void test_swp_paint_regions(void)
     subtest_swp_paint_regions( 0, "SimpleWindowClassWithParentDC", "SimpleWindowClass" );
 }
 
+static void subtest_hvredraw(HWND hparent, const char *classname, DWORD style)
+{
+    static const struct movesize_test {
+        int dx, dy, dw, dh;
+    } movesize_tests[] = {
+        {   0,   0,   0,  50 },
+        {   0,   0,  50,   0 },
+        {   0,   0,  50,  50 },
+        {   0,   0, -50, -50 },
+        { -50, -50,   0,  50 }
+        { -50, -50,  50,   0 },
+        { -50, -50,  50,  50 },
+    };
+    HRGN hrgn_old_vis = CreateRectRgn( 0, 0, 0, 0 );
+    HRGN hrgn_new_vis = CreateRectRgn( 0, 0, 0, 0 );
+    HRGN hrgn_expect = CreateRectRgn( 0, 0, 0, 0 );
+    HRGN hrgn_actual = CreateRectRgn( 0, 0, 0, 0 );
+    const int x0 = 100, y0 = 100, w0 = 200, h0 = 200;
+    size_t i;
+    HWND hwnd;
+    UINT class_style;
+
+    hwnd = CreateWindowExA( 0, classname, "Test window", style, x0, y0, w0, h0, hparent, 0, 0, NULL );
+    ok(hwnd != NULL, "Failed to create the window\n");
+
+    class_style = GetClassLongA( hwnd, GCL_STYLE );
+
+    ShowWindow( hwnd, SW_SHOW );
+    UpdateWindow( hwnd );
+
+    for (i = 0; i < ARRAY_SIZE(movesize_tests); i++)
+    {
+        const struct movesize_test *test = &movesize_tests[i];
+        int is_redraw = (test->dw != 0 && (class_style & CS_HREDRAW)) ||
+                        (test->dh != 0 && (class_style & CS_VREDRAW));
+        RECT rect_old_vis, rect_new_vis;
+        BOOL rgn_ok;
+
+        winetest_push_context( "%s %08lx SetWindowPos redraw #%Id (%d, %d, %d, %d)",
+                               classname, style, i, test->dx, test->dy, test->dw, test->dh );
+
+        SetWindowPos( hwnd, HWND_TOP, x0, y0, w0, h0, SWP_NOACTIVATE );
+
+        GetClientRect( hwnd, &rect_old_vis );
+        SetRectRgn( hrgn_old_vis, rect_old_vis.left, rect_old_vis.top, rect_old_vis.right, rect_old_vis.bottom );
+
+        UpdateWindow( hparent );
+        flush_events();
+
+        SetWindowPos( hwnd, HWND_TOP,
+                      x0 + test->dx, y0 + test->dy,
+                      w0 + test->dw, h0 + test->dh, SWP_NOACTIVATE );
+        ok( GetUpdateRgn( hwnd, hrgn_actual, FALSE ) != ERROR, "GetUpdateRgn shall succeed\n" );
+
+        GetClientRect( hwnd, &rect_new_vis );
+        SetRectRgn( hrgn_new_vis, rect_new_vis.left, rect_new_vis.top, rect_new_vis.right, rect_new_vis.bottom );
+        CombineRgn( hrgn_expect, hrgn_new_vis, hrgn_old_vis, is_redraw ? RGN_COPY : RGN_DIFF );
+
+        rgn_ok = EqualRgn( hrgn_expect, hrgn_actual );
+        todo_wine_if( is_redraw )
+        ok( !!rgn_ok, "Update region shall match expected region\n" );
+
+        if (!rgn_ok && winetest_debug > 1)
+        {
+            trace( "Expected update region: " );
+            dump_region( hrgn_expect );
+            trace( "Actual update region: " );
+            dump_region( hrgn_actual );
+            trace( "Old window visible area: %s\n", wine_dbgstr_rect( &rect_old_vis ) );
+            trace( "New window visible area: %s\n", wine_dbgstr_rect( &rect_new_vis ) );
+        }
+
+        if (winetest_interactive)
+        {
+            if (!rgn_ok)
+            {
+                visualize_region_differences( hwnd, NULL, hrgn_expect, hrgn_actual );
+            }
+
+            /* Let the position change be visible to the user */
+            flush_events();
+        }
+
+        winetest_pop_context();
+    }
+
+    DestroyWindow( hwnd );
+    DeleteObject( hrgn_actual );
+    DeleteObject( hrgn_expect );
+    DeleteObject( hrgn_new_vis );
+    DeleteObject( hrgn_old_vis );
+}
+
+
+static void test_hvredraw(void)
+{
+    HWND htoplevel;
+
+    subtest_hvredraw( NULL, "SimpleWindowClassWithHRedraw", WS_OVERLAPPEDWINDOW );
+    subtest_hvredraw( NULL, "SimpleWindowClassWithVRedraw", WS_OVERLAPPEDWINDOW );
+    subtest_hvredraw( NULL, "SimpleWindowClassWithHVRedraw", WS_OVERLAPPEDWINDOW );
+
+    htoplevel = CreateWindowExA( 0, "SimpleWindowClass", "Test toplevel",
+                                 WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_VISIBLE,
+                                 100, 100, 400, 400, 0, 0, 0, NULL );
+    ok( htoplevel != 0, "Failed to create top-level window: %lu\n", GetLastError() );
+
+    subtest_hvredraw( htoplevel, "SimpleWindowClassWithHRedraw", WS_CHILD | WS_BORDER );
+    subtest_hvredraw( htoplevel, "SimpleWindowClassWithVRedraw", WS_CHILD | WS_BORDER );
+    subtest_hvredraw( htoplevel, "SimpleWindowClassWithHVRedraw", WS_CHILD | WS_BORDER );
+
+    DestroyWindow( htoplevel );
+}
+
 struct wnd_event
 {
     HWND hwnd;
@@ -10766,6 +10880,21 @@ static BOOL RegisterWindowClasses(void)
     cls.lpszClassName = "SimpleWindowClassWithParentDC";
     if(!RegisterClassA(&cls)) return FALSE;
 
+    cls.lpfnWndProc = DefWindowProcA;
+    cls.style = CS_HREDRAW;
+    cls.lpszClassName = "SimpleWindowClassWithHRedraw";
+    if(!RegisterClassA(&cls)) return FALSE;
+
+    cls.lpfnWndProc = DefWindowProcA;
+    cls.style = CS_VREDRAW;
+    cls.lpszClassName = "SimpleWindowClassWithVRedraw";
+    if(!RegisterClassA(&cls)) return FALSE;
+
+    cls.lpfnWndProc = DefWindowProcA;
+    cls.style = CS_HREDRAW | CS_VREDRAW;
+    cls.lpszClassName = "SimpleWindowClassWithHVRedraw";
+    if(!RegisterClassA(&cls)) return FALSE;
+
     clsW.style = 0;
     clsW.lpfnWndProc = MsgCheckProcW;
     clsW.cbClsExtra = 0;
@@ -19521,6 +19650,7 @@ START_TEST(msg)
     test_wmime_keydown_message();
     test_paint_messages();
     test_swp_paint_regions();
+    test_hvredraw();
     test_interthread_messages();
     test_message_conversion();
     test_accelerators();
-- 
GitLab


From 3946d01eecd1658fca9968368b2da40ef5f47f6b Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Thu, 22 Dec 2022 01:21:48 +0900
Subject: [PATCH 2/2] win32u: Honor CS_HREDRAW and CS_VREDRAW when resizing
 window.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52903
---
 dlls/user32/tests/msg.c | 1 -
 dlls/win32u/window.c    | 7 ++++++-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
index 461d79d9a5d..35e4f0dd1f8 100644
--- a/dlls/user32/tests/msg.c
+++ b/dlls/user32/tests/msg.c
@@ -9475,7 +9475,6 @@ static void subtest_hvredraw(HWND hparent, const char *classname, DWORD style)
         CombineRgn( hrgn_expect, hrgn_new_vis, hrgn_old_vis, is_redraw ? RGN_COPY : RGN_DIFF );
 
         rgn_ok = EqualRgn( hrgn_expect, hrgn_actual );
-        todo_wine_if( is_redraw )
         ok( !!rgn_ok, "Update region shall match expected region\n" );
 
         if (!rgn_ok && winetest_debug > 1)
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 19348338c46..a3ff0647dcd 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -3116,6 +3116,7 @@ static UINT calc_ncsize( WINDOWPOS *winpos, const RECT *old_window_rect, const R
     {
         NCCALCSIZE_PARAMS params;
         WINDOWPOS winposCopy;
+        UINT class_style;
 
         params.rgrc[0] = *new_window_rect;
         params.rgrc[1] = *old_window_rect;
@@ -3135,7 +3136,11 @@ static UINT calc_ncsize( WINDOWPOS *winpos, const RECT *old_window_rect, const R
             winposCopy.cy = old_window_rect->bottom - old_window_rect->top;
         }
 
-        wvr_flags = send_message( winpos->hwnd, WM_NCCALCSIZE, TRUE, (LPARAM)&params );
+        class_style = get_class_long( winpos->hwnd, GCL_STYLE, FALSE );
+        if (class_style & CS_VREDRAW) wvr_flags |= WVR_VREDRAW;
+        if (class_style & CS_HREDRAW) wvr_flags |= WVR_HREDRAW;
+
+        wvr_flags |= send_message( winpos->hwnd, WM_NCCALCSIZE, TRUE, (LPARAM)&params );
 
         *new_client_rect = params.rgrc[0];
 
-- 
GitLab

From 354c9b2ad4ffaabaa2de5914b190baa0aa3d0a2c Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Fri, 18 Nov 2022 02:15:39 -0500
Subject: [PATCH 1/5] include: Add
 windows.system.profile.systemmanufacturers.idl file.

---
 include/Makefile.in                           |  1 +
 ...ows.system.profile.systemmanufacturers.idl | 60 +++++++++++++++++++
 2 files changed, 61 insertions(+)
 create mode 100644 include/windows.system.profile.systemmanufacturers.idl

diff --git a/include/Makefile.in b/include/Makefile.in
index 23a4265a437..c15c4db6f11 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -802,6 +802,7 @@ SOURCES = \
 	windows.storage.streams.idl \
 	windows.system.idl \
 	windows.system.power.idl \
+	windows.system.profile.systemmanufacturers.idl \
 	windows.system.userprofile.idl \
 	windowscontracts.idl \
 	windowsx.h \
diff --git a/include/windows.system.profile.systemmanufacturers.idl b/include/windows.system.profile.systemmanufacturers.idl
new file mode 100644
index 00000000000..644a664020b
--- /dev/null
+++ b/include/windows.system.profile.systemmanufacturers.idl
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "asyncinfo.idl";
+import "eventtoken.idl";
+import "windowscontracts.idl";
+import "windows.foundation.idl";
+
+namespace Windows.System.Profile.SystemManufacturers
+{
+    apicontract SystemManufacturersContract;
+    interface ISmbiosInformationStatics;
+    runtimeclass SmbiosInformation;
+
+    [
+        contractversion(3.0)
+    ]
+    apicontract SystemManufacturersContract
+    {
+    }
+
+    [
+        contract(Windows.System.Profile.SystemManufacturers.SystemManufacturersContract, 1.0),
+        exclusiveto(Windows.System.Profile.SystemManufacturers.SmbiosInformation),
+        uuid(080cca7c-637c-48c4-b728-f9273812db8e)
+    ]
+    interface ISmbiosInformationStatics : IInspectable
+    {
+        [propget] HRESULT SerialNumber([out, retval] HSTRING *value);
+    }
+
+    [
+        contract(Windows.System.Profile.SystemManufacturers.SystemManufacturersContract, 1.0),
+        marshaling_behavior(agile),
+        static(Windows.System.Profile.SystemManufacturers.ISmbiosInformationStatics, Windows.System.Profile.SystemManufacturers.SystemManufacturersContract, 1.0)
+    ]
+    runtimeclass SmbiosInformation
+    {
+    }
+}
-- 
GitLab


From 41bff7dfa360936494067284a2947e61f5ef6640 Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Sat, 19 Nov 2022 20:42:14 -0500
Subject: [PATCH 2/5] windows.system.profile.systemmanufacturers: Add stub DLL.

---
 configure.ac                                  |   2 +
 .../Makefile.in                               |   8 +
 .../classes.idl                               |  23 +++
 .../main.c                                    | 148 ++++++++++++++++++
 .../private.h                                 |  31 ++++
 .../tests/Makefile.in                         |   5 +
 .../tests/smbios.c                            |  83 ++++++++++
 ...ws.system.profile.systemmanufacturers.spec |   3 +
 8 files changed, 303 insertions(+)
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/Makefile.in
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/classes.idl
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/main.c
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/private.h
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
 create mode 100644 dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec

diff --git a/configure.ac b/configure.ac
index 9115244cb78..80bd78678e6 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3190,6 +3190,8 @@ WINE_CONFIG_MAKEFILE(dlls/windows.media.
 WINE_CONFIG_MAKEFILE(dlls/windows.media.speech)
 WINE_CONFIG_MAKEFILE(dlls/windows.media.speech/tests)
 WINE_CONFIG_MAKEFILE(dlls/windows.networking.connectivity)
+WINE_CONFIG_MAKEFILE(dlls/windows.system.profile.systemmanufacturers)
+WINE_CONFIG_MAKEFILE(dlls/windows.system.profile.systemmanufacturers/tests)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecs)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecs/tests)
 WINE_CONFIG_MAKEFILE(dlls/windowscodecsext)
diff --git a/dlls/windows.system.profile.systemmanufacturers/Makefile.in b/dlls/windows.system.profile.systemmanufacturers/Makefile.in
new file mode 100644
index 00000000000..a2d6076740f
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/Makefile.in
@@ -0,0 +1,8 @@
+MODULE  = windows.system.profile.systemmanufacturers.dll
+IMPORTS = combase
+
+C_SRCS = \
+	main.c
+
+IDL_SRCS = \
+	classes.idl
diff --git a/dlls/windows.system.profile.systemmanufacturers/classes.idl b/dlls/windows.system.profile.systemmanufacturers/classes.idl
new file mode 100644
index 00000000000..6072a782222
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/classes.idl
@@ -0,0 +1,23 @@
+/*
+ * Runtime Classes for windows.system.profile.systemmanufacturers.dll
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#pragma makedep register
+
+#include "windows.system.profile.systemmanufacturers.idl"
diff --git a/dlls/windows.system.profile.systemmanufacturers/main.c b/dlls/windows.system.profile.systemmanufacturers/main.c
new file mode 100644
index 00000000000..3f5e937392e
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/main.c
@@ -0,0 +1,148 @@
+/* WinRT Windows.System.Profile.SystemManufacturers Implementation
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "initguid.h"
+#include "private.h"
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(smbios);
+
+static const char *debugstr_hstring( HSTRING hstr )
+{
+    const WCHAR *str;
+    UINT32 len;
+    if (hstr && !((ULONG_PTR)hstr >> 16)) return "(invalid)";
+    str = WindowsGetStringRawBuffer(hstr, &len);
+    return wine_dbgstr_wn(str, len);
+}
+
+struct smbios_statics
+{
+    IActivationFactory IActivationFactory_iface;
+    LONG ref;
+};
+
+static inline struct smbios_statics *impl_from_IActivationFactory( IActivationFactory *iface )
+{
+    return CONTAINING_RECORD( iface, struct smbios_statics, IActivationFactory_iface );
+}
+
+static HRESULT WINAPI factory_QueryInterface( IActivationFactory *iface, REFIID iid, void **out )
+{
+    struct smbios_statics *impl = impl_from_IActivationFactory( iface );
+
+    TRACE( "iface %p, iid %s, out %p.\n", iface, debugstr_guid( iid ), out );
+
+    if (IsEqualGUID( iid, &IID_IUnknown ) ||
+        IsEqualGUID( iid, &IID_IInspectable ) ||
+        IsEqualGUID( iid, &IID_IAgileObject ) ||
+        IsEqualGUID( iid, &IID_IActivationFactory ))
+    {
+        *out = &impl->IActivationFactory_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
+    FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI factory_AddRef( IActivationFactory *iface )
+{
+    struct smbios_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedIncrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static ULONG WINAPI factory_Release( IActivationFactory *iface )
+{
+    struct smbios_statics *impl = impl_from_IActivationFactory( iface );
+    ULONG ref = InterlockedDecrement( &impl->ref );
+    TRACE( "iface %p, ref %lu.\n", iface, ref );
+    return ref;
+}
+
+static HRESULT WINAPI factory_GetIids( IActivationFactory *iface, ULONG *iid_count, IID **iids )
+{
+    FIXME( "iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetRuntimeClassName( IActivationFactory *iface, HSTRING *class_name )
+{
+    FIXME( "iface %p, class_name %p stub!\n", iface, class_name );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_GetTrustLevel( IActivationFactory *iface, TrustLevel *trust_level )
+{
+    FIXME( "iface %p, trust_level %p stub!\n", iface, trust_level );
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI factory_ActivateInstance( IActivationFactory *iface, IInspectable **instance )
+{
+    FIXME( "iface %p, instance %p stub!\n", iface, instance );
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl factory_vtbl =
+{
+    factory_QueryInterface,
+    factory_AddRef,
+    factory_Release,
+    /* IInspectable methods */
+    factory_GetIids,
+    factory_GetRuntimeClassName,
+    factory_GetTrustLevel,
+    /* IActivationFactory methods */
+    factory_ActivateInstance,
+};
+
+static struct smbios_statics smbios_statics =
+{
+    {&factory_vtbl},
+    1,
+};
+
+static IActivationFactory *smbios_factory = &smbios_statics.IActivationFactory_iface;
+
+HRESULT WINAPI DllGetClassObject( REFCLSID clsid, REFIID riid, void **out )
+{
+    FIXME( "clsid %s, riid %s, out %p stub!\n", debugstr_guid(clsid), debugstr_guid(riid), out );
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
+
+HRESULT WINAPI DllGetActivationFactory( HSTRING classid, IActivationFactory **factory )
+{
+    const WCHAR *name = WindowsGetStringRawBuffer( classid, NULL );
+
+    TRACE( "classid %s, factory %p.\n", debugstr_hstring(classid), factory );
+
+    *factory = NULL;
+
+    if (!wcscmp( name, RuntimeClass_Windows_System_Profile_SystemManufacturers_SmbiosInformation ))
+        IActivationFactory_QueryInterface( smbios_factory, &IID_IActivationFactory, (void **)factory );
+
+    if (*factory) return S_OK;
+    return CLASS_E_CLASSNOTAVAILABLE;
+}
diff --git a/dlls/windows.system.profile.systemmanufacturers/private.h b/dlls/windows.system.profile.systemmanufacturers/private.h
new file mode 100644
index 00000000000..e3672c3aec5
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/private.h
@@ -0,0 +1,31 @@
+/* WinRT Windows.System.Profile.SystemManufacturers Implementation
+ *
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <stddef.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "activation.h"
+
+#define WIDL_using_Windows_System_Profile_SystemManufacturers
+#include "windows.system.profile.systemmanufacturers.h"
diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in b/dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in
new file mode 100644
index 00000000000..ade0c6b12dd
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/Makefile.in
@@ -0,0 +1,5 @@
+TESTDLL = windows.system.profile.systemmanufacturers.dll
+IMPORTS = combase
+
+C_SRCS = \
+	smbios.c
diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
new file mode 100644
index 00000000000..fa3308f21ab
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2022 Mohamad Al-Jaf
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#define COBJMACROS
+#include "initguid.h"
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+
+#include "roapi.h"
+
+#define WIDL_using_Windows_System_Profile_SystemManufacturers
+#include "windows.system.profile.systemmanufacturers.h"
+
+#include "wine/test.h"
+
+#define check_interface( obj, iid ) check_interface_( __LINE__, obj, iid )
+static void check_interface_( unsigned int line, void *obj, const IID *iid )
+{
+    IUnknown *iface = obj;
+    IUnknown *unk;
+    HRESULT hr;
+
+    hr = IUnknown_QueryInterface( iface, iid, (void **)&unk );
+    ok_(__FILE__, line)( hr == S_OK, "got hr %#lx.\n", hr );
+    IUnknown_Release( unk );
+}
+
+static void test_Smbios_Statics(void)
+{
+    static const WCHAR *smbios_statics_name = L"Windows.System.Profile.SystemManufacturers.SmbiosInformation";
+    IActivationFactory *factory;
+    HSTRING str;
+    HRESULT hr;
+    LONG ref;
+
+    hr = WindowsCreateString( smbios_statics_name, wcslen( smbios_statics_name ), &str );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    hr = RoGetActivationFactory( str, &IID_IActivationFactory, (void **)&factory );
+    WindowsDeleteString( str );
+    ok( hr == S_OK || broken( hr == REGDB_E_CLASSNOTREG ), "got hr %#lx.\n", hr );
+    if (hr == REGDB_E_CLASSNOTREG)
+    {
+        win_skip( "%s runtimeclass not registered, skipping tests.\n", wine_dbgstr_w( smbios_statics_name ) );
+        return;
+    }
+
+    check_interface( factory, &IID_IUnknown );
+    check_interface( factory, &IID_IInspectable );
+    check_interface( factory, &IID_IAgileObject );
+
+    ref = IActivationFactory_Release( factory );
+    ok( ref == 1, "got ref %ld.\n", ref );
+}
+
+START_TEST(smbios)
+{
+    HRESULT hr;
+
+    hr = RoInitialize( RO_INIT_MULTITHREADED );
+    ok( hr == S_OK, "RoInitialize failed, hr %#lx\n", hr );
+
+    test_Smbios_Statics();
+
+    RoUninitialize();
+}
diff --git a/dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec b/dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec
new file mode 100644
index 00000000000..31a5eafe950
--- /dev/null
+++ b/dlls/windows.system.profile.systemmanufacturers/windows.system.profile.systemmanufacturers.spec
@@ -0,0 +1,3 @@
+@ stdcall -private DllGetActivationFactory(ptr ptr)
+@ stdcall -private DllCanUnloadNow()
+@ stdcall -private DllGetClassObject(ptr ptr ptr)
-- 
GitLab


From 9275a848fef628cf50eea34cadb8921055dfb4cc Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Mon, 28 Nov 2022 03:15:39 -0500
Subject: [PATCH 3/5] windows.system.profile.systemmanufacturers: Stub
 ISmbiosInformationStatics interface.

---
 .../main.c                                    | 30 +++++++++++++++
 .../private.h                                 | 38 +++++++++++++++++++
 .../tests/smbios.c                            |  7 ++++
 3 files changed, 75 insertions(+)

diff --git a/dlls/windows.system.profile.systemmanufacturers/main.c b/dlls/windows.system.profile.systemmanufacturers/main.c
index 3f5e937392e..35b4529ad7a 100644
--- a/dlls/windows.system.profile.systemmanufacturers/main.c
+++ b/dlls/windows.system.profile.systemmanufacturers/main.c
@@ -36,6 +36,7 @@ static const char *debugstr_hstring( HSTRING hstr )
 struct smbios_statics
 {
     IActivationFactory IActivationFactory_iface;
+    ISmbiosInformationStatics ISmbiosInformationStatics_iface;
     LONG ref;
 };
 
@@ -60,6 +61,13 @@ static HRESULT WINAPI factory_QueryInterface( IActivationFactory *iface, REFIID
         return S_OK;
     }
 
+    if (IsEqualGUID( iid, &IID_ISmbiosInformationStatics ))
+    {
+        *out = &impl->ISmbiosInformationStatics_iface;
+        IInspectable_AddRef( *out );
+        return S_OK;
+    }
+
     FIXME( "%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid( iid ) );
     *out = NULL;
     return E_NOINTERFACE;
@@ -118,9 +126,31 @@ static const struct IActivationFactoryVtbl factory_vtbl =
     factory_ActivateInstance,
 };
 
+DEFINE_IINSPECTABLE( statics, ISmbiosInformationStatics, struct smbios_statics, IActivationFactory_iface )
+
+static HRESULT WINAPI statics_get_SerialNumber( ISmbiosInformationStatics *iface, HSTRING *value )
+{
+    FIXME( "iface %p, value %p stub!\n", iface, value );
+    return E_NOTIMPL;
+}
+
+static const struct ISmbiosInformationStaticsVtbl statics_vtbl =
+{
+    statics_QueryInterface,
+    statics_AddRef,
+    statics_Release,
+    /* IInspectable methods */
+    statics_GetIids,
+    statics_GetRuntimeClassName,
+    statics_GetTrustLevel,
+    /* ISmbiosInformationStatics methods */
+    statics_get_SerialNumber,
+};
+
 static struct smbios_statics smbios_statics =
 {
     {&factory_vtbl},
+    {&statics_vtbl},
     1,
 };
 
diff --git a/dlls/windows.system.profile.systemmanufacturers/private.h b/dlls/windows.system.profile.systemmanufacturers/private.h
index e3672c3aec5..42c19710dcb 100644
--- a/dlls/windows.system.profile.systemmanufacturers/private.h
+++ b/dlls/windows.system.profile.systemmanufacturers/private.h
@@ -29,3 +29,41 @@
 
 #define WIDL_using_Windows_System_Profile_SystemManufacturers
 #include "windows.system.profile.systemmanufacturers.h"
+
+#define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
+    static inline impl_type *impl_from( iface_type *iface )                                        \
+    {                                                                                              \
+        return CONTAINING_RECORD( iface, impl_type, iface_mem );                                   \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_QueryInterface( iface_type *iface, REFIID iid, void **out )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_QueryInterface( (IInspectable *)(expr), iid, out );                    \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_AddRef( iface_type *iface )                                          \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_AddRef( (IInspectable *)(expr) );                                      \
+    }                                                                                              \
+    static ULONG WINAPI pfx##_Release( iface_type *iface )                                         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_Release( (IInspectable *)(expr) );                                     \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetIids( iface_type *iface, ULONG *iid_count, IID **iids )         \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetIids( (IInspectable *)(expr), iid_count, iids );                    \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetRuntimeClassName( iface_type *iface, HSTRING *class_name )      \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetRuntimeClassName( (IInspectable *)(expr), class_name );             \
+    }                                                                                              \
+    static HRESULT WINAPI pfx##_GetTrustLevel( iface_type *iface, TrustLevel *trust_level )        \
+    {                                                                                              \
+        impl_type *impl = impl_from( iface );                                                      \
+        return IInspectable_GetTrustLevel( (IInspectable *)(expr), trust_level );                  \
+    }
+#define DEFINE_IINSPECTABLE( pfx, iface_type, impl_type, base_iface )                              \
+    DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from_##iface_type, iface_type##_iface, &impl->base_iface )
diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
index fa3308f21ab..e23a4d9adb7 100644
--- a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
@@ -45,6 +45,7 @@ static void check_interface_( unsigned int line, void *obj, const IID *iid )
 static void test_Smbios_Statics(void)
 {
     static const WCHAR *smbios_statics_name = L"Windows.System.Profile.SystemManufacturers.SmbiosInformation";
+    ISmbiosInformationStatics *smbios_statics;
     IActivationFactory *factory;
     HSTRING str;
     HRESULT hr;
@@ -66,6 +67,12 @@ static void test_Smbios_Statics(void)
     check_interface( factory, &IID_IInspectable );
     check_interface( factory, &IID_IAgileObject );
 
+    hr = IActivationFactory_QueryInterface( factory, &IID_ISmbiosInformationStatics, (void **)&smbios_statics );
+    ok( hr == S_OK, "got hr %#lx.\n", hr );
+
+    ref = ISmbiosInformationStatics_Release( smbios_statics );
+    ok( ref == 2, "got ref %ld.\n", ref );
+
     ref = IActivationFactory_Release( factory );
     ok( ref == 1, "got ref %ld.\n", ref );
 }
-- 
GitLab


From ef1f8b7ff12a791b1f38dd05c07763d2a41524c5 Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Mon, 28 Nov 2022 23:20:30 -0500
Subject: [PATCH 4/5] windows.system.profile.systemmanufacturers/tests: Add
 ISmbiosInformationStatics_get_SerialNumber tests.

---
 .../tests/smbios.c                               | 16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
index e23a4d9adb7..49e90216c42 100644
--- a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
@@ -47,8 +47,10 @@ static void test_Smbios_Statics(void)
     static const WCHAR *smbios_statics_name = L"Windows.System.Profile.SystemManufacturers.SmbiosInformation";
     ISmbiosInformationStatics *smbios_statics;
     IActivationFactory *factory;
-    HSTRING str;
+    HSTRING str, serial;
+    const WCHAR *buf;
     HRESULT hr;
+    UINT32 len;
     LONG ref;
 
     hr = WindowsCreateString( smbios_statics_name, wcslen( smbios_statics_name ), &str );
@@ -70,6 +72,18 @@ static void test_Smbios_Statics(void)
     hr = IActivationFactory_QueryInterface( factory, &IID_ISmbiosInformationStatics, (void **)&smbios_statics );
     ok( hr == S_OK, "got hr %#lx.\n", hr );
 
+    if (0) /* Win8 Crash */
+    {
+        hr = ISmbiosInformationStatics_get_SerialNumber( smbios_statics, &serial );
+        todo_wine ok( hr == S_OK || broken(hr == E_UNEXPECTED), "got hr %#lx.\n", hr );
+        if (hr == S_OK)
+        {
+            buf = WindowsGetStringRawBuffer( serial, &len );
+            todo_wine ok( buf != NULL && len > 0, "WindowsGetStringRawBuffer returned buf %p, len %u\n", buf, len );
+            WindowsDeleteString( serial );
+        }
+    }
+
     ref = ISmbiosInformationStatics_Release( smbios_statics );
     ok( ref == 2, "got ref %ld.\n", ref );
 
-- 
GitLab


From a02795ffcc9470e603d64f0e90e644a32142b6a5 Mon Sep 17 00:00:00 2001
From: Mohamad Al-Jaf <mohamadaljaf@gmail.com>
Date: Mon, 28 Nov 2022 23:22:34 -0500
Subject: [PATCH 5/5] windows.system.profile.systemmanufacturers: Implement
 ISmbiosInformationStatics_get_SerialNumber.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=53747
---
 .../Makefile.in                               |  2 +-
 .../main.c                                    | 62 ++++++++++++++++++-
 .../private.h                                 |  2 +
 .../tests/smbios.c                            |  4 +-
 4 files changed, 65 insertions(+), 5 deletions(-)

diff --git a/dlls/windows.system.profile.systemmanufacturers/Makefile.in b/dlls/windows.system.profile.systemmanufacturers/Makefile.in
index a2d6076740f..9d07caa287c 100644
--- a/dlls/windows.system.profile.systemmanufacturers/Makefile.in
+++ b/dlls/windows.system.profile.systemmanufacturers/Makefile.in
@@ -1,5 +1,5 @@
 MODULE  = windows.system.profile.systemmanufacturers.dll
-IMPORTS = combase
+IMPORTS = combase oleaut32
 
 C_SRCS = \
 	main.c
diff --git a/dlls/windows.system.profile.systemmanufacturers/main.c b/dlls/windows.system.profile.systemmanufacturers/main.c
index 35b4529ad7a..d2feb32054e 100644
--- a/dlls/windows.system.profile.systemmanufacturers/main.c
+++ b/dlls/windows.system.profile.systemmanufacturers/main.c
@@ -128,10 +128,68 @@ static const struct IActivationFactoryVtbl factory_vtbl =
 
 DEFINE_IINSPECTABLE( statics, ISmbiosInformationStatics, struct smbios_statics, IActivationFactory_iface )
 
+static HRESULT get_bios_serialnumber( BSTR *value )
+{
+    const WCHAR *class = L"Win32_BIOS";
+    IEnumWbemClassObject *wbem_enum;
+    IWbemClassObject *wbem_class;
+    IWbemServices *wbem_service;
+    IWbemLocator *wbem_locator;
+    VARIANT serial;
+    ULONG count;
+    HRESULT hr;
+    BSTR bstr;
+
+    hr = CoCreateInstance( &CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, &IID_IWbemLocator, (void**)&wbem_locator );
+    if (FAILED(hr)) return hr;
+
+    bstr = SysAllocString( L"ROOT\\CIMV2" );
+    if (!bstr)
+    {
+        IWbemLocator_Release( wbem_locator );
+        return E_OUTOFMEMORY;
+    }
+    hr = IWbemLocator_ConnectServer( wbem_locator, bstr, NULL, NULL, NULL, 0, NULL, NULL, &wbem_service );
+    IWbemLocator_Release( wbem_locator );
+    SysFreeString( bstr );
+    if (FAILED(hr)) return hr;
+
+    bstr = SysAllocString( class );
+    if (!bstr)
+    {
+        IWbemServices_Release( wbem_service );
+        return E_OUTOFMEMORY;
+    }
+    hr = IWbemServices_CreateInstanceEnum( wbem_service, bstr, WBEM_FLAG_SYSTEM_ONLY, NULL, &wbem_enum );
+    IWbemServices_Release( wbem_service );
+    SysFreeString( bstr );
+    if (FAILED(hr)) return hr;
+
+    hr = IEnumWbemClassObject_Next( wbem_enum, 1000, 1, &wbem_class, &count );
+    IEnumWbemClassObject_Release( wbem_enum );
+    if (FAILED(hr)) return hr;
+
+    hr = IWbemClassObject_Get( wbem_class, L"SerialNumber", 0, &serial, NULL, NULL );
+    IWbemClassObject_Release( wbem_class );
+    if (FAILED(hr)) return hr;
+
+    *value = V_BSTR( &serial );
+    VariantClear( &serial );
+    return hr;
+}
+
 static HRESULT WINAPI statics_get_SerialNumber( ISmbiosInformationStatics *iface, HSTRING *value )
 {
-    FIXME( "iface %p, value %p stub!\n", iface, value );
-    return E_NOTIMPL;
+    BSTR serial;
+    HRESULT hr;
+
+    TRACE( "iface %p, value %p.\n", iface, value );
+
+    if (FAILED( hr = get_bios_serialnumber( &serial ) )) return hr;
+    if (FAILED( hr = WindowsCreateString( serial, wcslen(serial), value ) )) return hr;
+
+    TRACE( "Returning serial number: %s.\n", debugstr_w( serial ) );
+    return hr;
 }
 
 static const struct ISmbiosInformationStaticsVtbl statics_vtbl =
diff --git a/dlls/windows.system.profile.systemmanufacturers/private.h b/dlls/windows.system.profile.systemmanufacturers/private.h
index 42c19710dcb..374a2829130 100644
--- a/dlls/windows.system.profile.systemmanufacturers/private.h
+++ b/dlls/windows.system.profile.systemmanufacturers/private.h
@@ -30,6 +30,8 @@
 #define WIDL_using_Windows_System_Profile_SystemManufacturers
 #include "windows.system.profile.systemmanufacturers.h"
 
+#include "wbemcli.h"
+
 #define DEFINE_IINSPECTABLE_( pfx, iface_type, impl_type, impl_from, iface_mem, expr )             \
     static inline impl_type *impl_from( iface_type *iface )                                        \
     {                                                                                              \
diff --git a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
index 49e90216c42..8d02b2c423a 100644
--- a/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
+++ b/dlls/windows.system.profile.systemmanufacturers/tests/smbios.c
@@ -75,11 +75,11 @@ static void test_Smbios_Statics(void)
     if (0) /* Win8 Crash */
     {
         hr = ISmbiosInformationStatics_get_SerialNumber( smbios_statics, &serial );
-        todo_wine ok( hr == S_OK || broken(hr == E_UNEXPECTED), "got hr %#lx.\n", hr );
+        ok( hr == S_OK || broken(hr == E_UNEXPECTED), "got hr %#lx.\n", hr );
         if (hr == S_OK)
         {
             buf = WindowsGetStringRawBuffer( serial, &len );
-            todo_wine ok( buf != NULL && len > 0, "WindowsGetStringRawBuffer returned buf %p, len %u\n", buf, len );
+            ok( buf != NULL && len > 0, "WindowsGetStringRawBuffer returned buf %p, len %u\n", buf, len );
             WindowsDeleteString( serial );
         }
     }
-- 
GitLab

From 82010317528d56c623a3c4f243f43a94ddfc6b9d Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Wed, 23 Nov 2022 15:03:06 +0800
Subject: [PATCH] combase: Use SendMessageW() in
 ClientRpcChannelBuffer_SendReceive() for STAs.

An application has a thread 1 sending WM_DESTROY to windows in thread 2. When handling the message
in thread 2, RevokeDragDrop() is called to release a COM object in thread 1. Then deadlock happens
when using PostMessageW() because the DM_EXECUTERPC message will not be handled as thread 1 is still
waiting for thread 2 to finish handling WM_DESTROY.
---
 dlls/combase/rpc.c | 11 +----------
 1 file changed, 1 insertion(+), 10 deletions(-)

diff --git a/dlls/combase/rpc.c b/dlls/combase/rpc.c
index c51b59de4bf..1862c8bddca 100644
--- a/dlls/combase/rpc.c
+++ b/dlls/combase/rpc.c
@@ -1416,16 +1416,7 @@ static HRESULT WINAPI ClientRpcChannelBuffer_SendReceive(LPRPCCHANNELBUFFER ifac
 
         msg->ProcNum &= ~RPC_FLAGS_VALID_BIT;
 
-        if (!PostMessageW(message_state->target_hwnd, DM_EXECUTERPC, 0,
-                          (LPARAM)&message_state->params))
-        {
-            ERR("PostMessage failed with error %lu\n", GetLastError());
-
-            /* Note: message_state->params.iface doesn't have a reference and
-             * so doesn't need to be released */
-
-            hr = HRESULT_FROM_WIN32(GetLastError());
-        }
+        SendMessageW(message_state->target_hwnd, DM_EXECUTERPC, 0, (LPARAM)&message_state->params);
     }
     else
     {
-- 
GitLab

From e948fcce9ead52f955c1849c238040dce7cce250 Mon Sep 17 00:00:00 2001
From: Vladislav Timonin <timoninvlad@yandex.ru>
Date: Thu, 22 Dec 2022 02:41:17 +0700
Subject: [PATCH] comctl32/listview: Draw border and background separately in
 WM_NCPAINT.

Depending on the theme, if there was a header,
the border ends up painted lower than it should be,
and clipped by the header.
---
 dlls/comctl32/listview.c | 18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/dlls/comctl32/listview.c b/dlls/comctl32/listview.c
index 7c394d60273..13df8567c56 100644
--- a/dlls/comctl32/listview.c
+++ b/dlls/comctl32/listview.c
@@ -10701,6 +10701,7 @@ static LRESULT LISTVIEW_NCPaint(const LISTVIEW_INFO *infoPtr, HRGN region)
     HRGN cliprgn;
     int cxEdge = GetSystemMetrics (SM_CXEDGE),
         cyEdge = GetSystemMetrics (SM_CYEDGE);
+    DTBGOPTS dtbg_opts;
 
     if (!theme || !(exstyle & WS_EX_CLIENTEDGE))
        return DefWindowProcW (infoPtr->hwndSelf, WM_NCPAINT, (WPARAM)region, 0);
@@ -10713,17 +10714,24 @@ static LRESULT LISTVIEW_NCPaint(const LISTVIEW_INFO *infoPtr, HRGN region)
         CombineRgn (cliprgn, cliprgn, region, RGN_AND);
 
     OffsetRect(&r, -r.left, -r.top);
+
+    dc = GetDCEx(infoPtr->hwndSelf, region, DCX_WINDOW|DCX_INTERSECTRGN);
+
+    if (IsThemeBackgroundPartiallyTransparent (theme, 0, 0))
+        DrawThemeParentBackground(infoPtr->hwndSelf, dc, &r);
+
+    dtbg_opts.dwSize = sizeof(DTBGOPTS);
+    dtbg_opts.dwFlags = DTBG_OMITCONTENT;
+    DrawThemeBackgroundEx(theme, dc, 0, 0, &r, &dtbg_opts);
+
     if (infoPtr->hwndHeader && LISTVIEW_IsHeaderEnabled(infoPtr))
     {
         GetWindowRect(infoPtr->hwndHeader, &window_rect);
         r.top = min(r.bottom, r.top + window_rect.bottom - window_rect.top);
     }
+    dtbg_opts.dwFlags = DTBG_OMITBORDER;
+    DrawThemeBackgroundEx(theme, dc, 0, 0, &r, &dtbg_opts);
 
-    dc = GetDCEx(infoPtr->hwndSelf, region, DCX_WINDOW|DCX_INTERSECTRGN);
-
-    if (IsThemeBackgroundPartiallyTransparent (theme, 0, 0))
-        DrawThemeParentBackground(infoPtr->hwndSelf, dc, &r);
-    DrawThemeBackground (theme, dc, 0, 0, &r, 0);
     ReleaseDC(infoPtr->hwndSelf, dc);
 
     /* Call default proc to get the scrollbars etc. painted */
-- 
GitLab

