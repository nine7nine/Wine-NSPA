From 7b44906361ab9c3fbc2d27bbdd6efdc2ae9e99f6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 22 May 2022 17:13:36 +0200
Subject: [PATCH] msi: Avoid using pointer value after free.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: RÃ©mi Bernon <rbernon@codeweavers.com>
---
 dlls/msi/handle.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/msi/handle.c b/dlls/msi/handle.c
index 7be64da9bfef..f0a55956fce6 100644
--- a/dlls/msi/handle.c
+++ b/dlls/msi/handle.c
@@ -256,8 +256,8 @@ int msiobj_release( MSIOBJECTHDR *info )
     {
         if( info->destructor )
             info->destructor( info );
-        msi_free( info );
         TRACE("object %p destroyed\n", info);
+        msi_free( info );
     }
 
     return ret;
From a58c6251870dfb7d214464e709bbbc9ca649b900 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 27 Sep 2022 13:36:49 -0500
Subject: [PATCH] msi: Disable FS redirection for temporary file in
 cabinet_copy_file().

---
 dlls/msi/files.c   | 9 +++++++++
 dlls/msi/media.c   | 6 +++---
 dlls/msi/msipriv.h | 1 +
 3 files changed, 13 insertions(+), 3 deletions(-)

diff --git a/dlls/msi/files.c b/dlls/msi/files.c
index 1b8e4fd7d906..94c733fca8fa 100644
--- a/dlls/msi/files.c
+++ b/dlls/msi/files.c
@@ -48,6 +48,15 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msi);
 
+BOOL msi_get_temp_file_name( MSIPACKAGE *package, const WCHAR *tmp_path, const WCHAR *prefix, WCHAR *tmp_filename )
+{
+    BOOL ret;
+    msi_disable_fs_redirection( package );
+    ret = GetTempFileNameW( tmp_path, prefix, 0, tmp_filename );
+    msi_revert_fs_redirection( package );
+    return ret;
+}
+
 HANDLE msi_create_file( MSIPACKAGE *package, const WCHAR *filename, DWORD access, DWORD sharing, DWORD creation,
                         DWORD flags )
 {
diff --git a/dlls/msi/media.c b/dlls/msi/media.c
index 6aeb948de518..db65a282b93d 100644
--- a/dlls/msi/media.c
+++ b/dlls/msi/media.c
@@ -468,10 +468,10 @@ static INT_PTR cabinet_copy_file(FDINOTIFICATIONTYPE fdint,
                 msi_free( tmppathW );
                 return ERROR_OUTOFMEMORY;
             }
-            if (!GetTempFileNameW(tmppathW, L"msi", 0, tmpfileW)) tmpfileW[0] = 0;
+            if (!msi_get_temp_file_name( data->package, tmppathW, L"msi", tmpfileW )) tmpfileW[0] = 0;
             msi_free( tmppathW );
 
-            handle = CreateFileW(tmpfileW, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, attrs, NULL);
+            handle = msi_create_file( data->package, tmpfileW, GENERIC_READ | GENERIC_WRITE, 0, CREATE_ALWAYS, attrs );
 
             if (handle != INVALID_HANDLE_VALUE &&
                 msi_move_file( data->package, path, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) &&
@@ -482,7 +482,7 @@ static INT_PTR cabinet_copy_file(FDINOTIFICATIONTYPE fdint,
             else
             {
                 WARN( "failed to schedule rename operation %s (error %lu)\n", debugstr_w(path), GetLastError() );
-                DeleteFileW( tmpfileW );
+                msi_delete_file( data->package, tmpfileW );
             }
             msi_free(tmpfileW);
         }
diff --git a/dlls/msi/msipriv.h b/dlls/msi/msipriv.h
index b5838bad6fe2..d63c6f244ff6 100644
--- a/dlls/msi/msipriv.h
+++ b/dlls/msi/msipriv.h
@@ -1073,6 +1073,7 @@ static inline void msi_revert_fs_redirection( MSIPACKAGE *package )
 {
     if (is_wow64 && package->platform == PLATFORM_X64) Wow64RevertWow64FsRedirection( package->cookie );
 }
+extern BOOL msi_get_temp_file_name( MSIPACKAGE *, const WCHAR *, const WCHAR *, WCHAR * ) DECLSPEC_HIDDEN;
 extern HANDLE msi_create_file( MSIPACKAGE *, const WCHAR *, DWORD, DWORD, DWORD, DWORD ) DECLSPEC_HIDDEN;
 extern BOOL msi_delete_file( MSIPACKAGE *, const WCHAR * ) DECLSPEC_HIDDEN;
 extern BOOL msi_remove_directory( MSIPACKAGE *, const WCHAR * ) DECLSPEC_HIDDEN;
From 7cc7a6defc08d4de7574b7a75d574c3ab1f32db8 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Wed, 30 Nov 2022 22:23:19 -0700
Subject: [PATCH] msi: Use the wcsdup function instead of reimplementing it.

---
 dlls/msi/action.c    | 36 +++++++++++++++----------------
 dlls/msi/appsearch.c | 18 ++++++++--------
 dlls/msi/assembly.c  |  6 +++---
 dlls/msi/classes.c   | 10 ++++-----
 dlls/msi/cond.y      |  4 ++--
 dlls/msi/custom.c    | 28 ++++++++++++-------------
 dlls/msi/database.c  | 14 ++++++-------
 dlls/msi/dialog.c    | 50 ++++++++++++++++++++++----------------------
 dlls/msi/files.c     | 24 ++++++++++-----------
 dlls/msi/font.c      |  6 +++---
 dlls/msi/format.c    |  8 +++----
 dlls/msi/install.c   |  4 ++--
 dlls/msi/media.c     | 20 +++++++++---------
 dlls/msi/msi.c       | 22 +++++++++----------
 dlls/msi/msipriv.h   | 10 ---------
 dlls/msi/package.c   | 16 +++++++-------
 dlls/msi/patch.c     |  6 +++---
 dlls/msi/record.c    |  2 +-
 dlls/msi/source.c    |  4 ++--
 dlls/msi/storages.c  |  2 +-
 dlls/msi/table.c     |  2 +-
 21 files changed, 141 insertions(+), 151 deletions(-)

diff --git a/dlls/msi/action.c b/dlls/msi/action.c
index 06cd582a389e..64032071a5f5 100644
--- a/dlls/msi/action.c
+++ b/dlls/msi/action.c
@@ -1051,7 +1051,7 @@ static UINT load_file(MSIRECORD *row, LPVOID param)
     msi_reduce_to_long_filename( file->FileName );
 
     file->ShortName = msi_dup_record_field( row, 3 );
-    file->LongName = strdupW( folder_split_path(file->ShortName, '|'));
+    file->LongName = wcsdup( folder_split_path(file->ShortName, '|') );
 
     file->FileSize = MSI_RecordGetInteger( row, 4 );
     file->Version = msi_dup_record_field( row, 5 );
@@ -1307,9 +1307,9 @@ static UINT load_folder( MSIRECORD *row, LPVOID param )
         src_long = src_short;
 
     /* FIXME: use the target short path too */
-    folder->TargetDefault = strdupW(tgt_long);
-    folder->SourceShortPath = strdupW(src_short);
-    folder->SourceLongPath = strdupW(src_long);
+    folder->TargetDefault = wcsdup(tgt_long);
+    folder->SourceShortPath = wcsdup(src_short);
+    folder->SourceLongPath = wcsdup(src_long);
     msi_free(p);
 
     TRACE("TargetDefault = %s\n",debugstr_w( folder->TargetDefault ));
@@ -1960,7 +1960,7 @@ static WCHAR *create_temp_dir( MSIDATABASE *db )
         {
             GetTempPathW( MAX_PATH, tmp );
         }
-        if (!(db->tempfolder = strdupW( tmp ))) return NULL;
+        if (!(db->tempfolder = wcsdup( tmp ))) return NULL;
     }
 
     if ((ret = msi_alloc( (lstrlenW( db->tempfolder ) + 20) * sizeof(WCHAR) )))
@@ -2480,7 +2480,7 @@ static HKEY open_key( const MSICOMPONENT *comp, HKEY root, const WCHAR *path, BO
 
     access |= get_registry_view( comp );
 
-    if (!(subkey = strdupW( path ))) return NULL;
+    if (!(subkey = wcsdup( path ))) return NULL;
     p = subkey;
     if ((q = wcschr( p, '\\' ))) *q = 0;
     if (create)
@@ -2525,7 +2525,7 @@ static WCHAR **split_multi_string_values( const WCHAR *str, DWORD len, DWORD *co
     p = str;
     while ((p - str) < len)
     {
-        if (!(ret[i] = strdupW( p )))
+        if (!(ret[i] = wcsdup( p )))
         {
             for (; i >= 0; i--) msi_free( ret[i] );
             msi_free( ret );
@@ -2823,7 +2823,7 @@ static void delete_key( const MSICOMPONENT *comp, HKEY root, const WCHAR *path )
     WCHAR *subkey, *p;
     HKEY hkey;
 
-    if (!(subkey = strdupW( path ))) return;
+    if (!(subkey = wcsdup( path ))) return;
     do
     {
         if ((p = wcsrchr( subkey, '\\' )))
@@ -3128,7 +3128,7 @@ static LPWSTR resolve_keypath( MSIPACKAGE* package, MSICOMPONENT *cmp )
 {
 
     if (!cmp->KeyPath)
-        return strdupW( msi_get_target_folder( package, cmp->Directory ) );
+        return wcsdup( msi_get_target_folder( package, cmp->Directory ) );
 
     if (cmp->Attributes & msidbComponentAttributesRegistryKeyPath)
     {
@@ -3174,7 +3174,7 @@ static LPWSTR resolve_keypath( MSIPACKAGE* package, MSICOMPONENT *cmp )
         MSIFILE *file = msi_get_loaded_file( package, cmp->KeyPath );
 
         if (file)
-            return strdupW( file->TargetPath );
+            return wcsdup( file->TargetPath );
     }
     return NULL;
 }
@@ -3445,7 +3445,7 @@ static BOOL CALLBACK Typelib_EnumResNameProc( HMODULE hModule, LPCWSTR lpszType,
     sz = lstrlenW(tl_struct->source)+4;
 
     if ((INT_PTR)lpszName == 1)
-        tl_struct->path = strdupW(tl_struct->source);
+        tl_struct->path = wcsdup(tl_struct->source);
     else
     {
         tl_struct->path = msi_alloc(sz * sizeof(WCHAR));
@@ -3532,7 +3532,7 @@ static UINT ITERATE_RegisterTypeLibraries(MSIRECORD *row, LPVOID param)
         LPCWSTR guid;
         guid = MSI_RecordGetString(row,1);
         CLSIDFromString( guid, &tl_struct.clsid);
-        tl_struct.source = strdupW( file->TargetPath );
+        tl_struct.source = wcsdup( file->TargetPath );
         tl_struct.path = NULL;
 
         EnumResourceNamesW(module, L"TYPELIB", Typelib_EnumResNameProc,
@@ -4316,7 +4316,7 @@ static WCHAR *get_ini_file_name( MSIPACKAGE *package, MSIRECORD *row )
     dirprop = MSI_RecordGetString( row, 3 );
     if (dirprop)
     {
-        folder = strdupW( msi_get_target_folder( package, dirprop ) );
+        folder = wcsdup( msi_get_target_folder( package, dirprop ) );
         if (!folder) folder = msi_dup_property( package->db, dirprop );
     }
     else
@@ -5211,7 +5211,7 @@ static UINT ACTION_ResolveSource(MSIPACKAGE* package)
                     INSTALLPROPERTY_DISKPROMPTW,prompt,&size);
         }
         else
-            prompt = strdupW(package->db->path);
+            prompt = wcsdup(package->db->path);
 
         record = MSI_CreateRecord(2);
         MSI_RecordSetInteger(record, 1, MSIERR_INSERTDISK);
@@ -6272,7 +6272,7 @@ static UINT ITERATE_InstallODBCDriver( MSIRECORD *rec, LPVOID param )
         const WCHAR *dir = msi_get_target_folder( package, driver_file->Component->Directory );
         driver_file->TargetPath = msi_build_directory_name( 2, dir, driver_file->FileName );
     }
-    driver_path = strdupW(driver_file->TargetPath);
+    driver_path = wcsdup(driver_file->TargetPath);
     ptr = wcsrchr(driver_path, '\\');
     if (ptr) *ptr = '\0';
 
@@ -6355,7 +6355,7 @@ static UINT ITERATE_InstallODBCTranslator( MSIRECORD *rec, LPVOID param )
     }
     *ptr = '\0';
 
-    translator_path = strdupW(translator_file->TargetPath);
+    translator_path = wcsdup(translator_file->TargetPath);
     ptr = wcsrchr(translator_path, '\\');
     if (ptr) *ptr = '\0';
 
@@ -6841,7 +6841,7 @@ static UINT ITERATE_WriteEnvironmentString( MSIRECORD *rec, LPVOID param )
             goto done;
         }
         size = (lstrlenW(value) + 1) * sizeof(WCHAR);
-        newval = strdupW(value);
+        newval = wcsdup(value);
         if (!newval)
         {
             res = ERROR_OUTOFMEMORY;
@@ -7651,7 +7651,7 @@ UINT MSI_InstallPackage( MSIPACKAGE *package, LPCWSTR szPackagePath,
         LPWSTR p, dir;
         LPCWSTR file;
 
-        dir = strdupW(szPackagePath);
+        dir = wcsdup(szPackagePath);
         p = wcsrchr(dir, '\\');
         if (p)
         {
diff --git a/dlls/msi/appsearch.c b/dlls/msi/appsearch.c
index 77b12156ca8d..1c5113ba4eaa 100644
--- a/dlls/msi/appsearch.c
+++ b/dlls/msi/appsearch.c
@@ -169,7 +169,7 @@ static WCHAR *search_file( MSIPACKAGE *package, WCHAR *path, MSISIGNATURE *sig )
 
         attr = msi_get_file_attributes( package, path );
         if (attr != INVALID_FILE_ATTRIBUTES && (attr & FILE_ATTRIBUTE_DIRECTORY))
-            return strdupW(path);
+            return wcsdup(path);
 
         return NULL;
     }
@@ -180,7 +180,7 @@ static WCHAR *search_file( MSIPACKAGE *package, WCHAR *path, MSISIGNATURE *sig )
 
     size = msi_get_file_version_info( package, path, 0, NULL );
     if (!size)
-        return strdupW(path);
+        return wcsdup(path);
 
     buffer = msi_alloc(size);
     if (!buffer)
@@ -213,7 +213,7 @@ static WCHAR *search_file( MSIPACKAGE *package, WCHAR *path, MSISIGNATURE *sig )
             goto done;
     }
 
-    val = strdupW(path);
+    val = wcsdup(path);
 
 done:
     msi_free(buffer);
@@ -276,7 +276,7 @@ static UINT search_components( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATU
         else
             PathAddBackslashW(path);
 
-        *appValue = strdupW(path);
+        *appValue = wcsdup(path);
     }
     else if (sigpresent)
     {
@@ -285,7 +285,7 @@ static UINT search_components( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATU
 
         attr = msi_get_file_attributes( package, path );
         if (attr != INVALID_FILE_ATTRIBUTES && !(attr & FILE_ATTRIBUTE_DIRECTORY))
-            *appValue = strdupW(path);
+            *appValue = wcsdup(path);
     }
 
 done:
@@ -474,7 +474,7 @@ static LPWSTR get_ini_field(LPWSTR buf, int field)
     int i = 1;
 
     if (field == 0)
-        return strdupW(buf);
+        return wcsdup(buf);
 
     beg = buf;
     while ((end = wcschr(beg, ',')) && i < field)
@@ -491,7 +491,7 @@ static LPWSTR get_ini_field(LPWSTR buf, int field)
         end = beg + lstrlenW(beg);
 
     *end = '\0';
-    return strdupW(beg);
+    return wcsdup(beg);
 }
 
 static UINT search_ini( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig )
@@ -590,7 +590,7 @@ static void expand_any_path( MSIPACKAGE *package, WCHAR *src, WCHAR *dst, size_t
 static LANGID *parse_languages( const WCHAR *languages, DWORD *num_ids )
 {
     UINT i, count = 1;
-    WCHAR *str = strdupW( languages ), *p, *q;
+    WCHAR *str = wcsdup( languages ), *p, *q;
     LANGID *ret;
 
     if (!str) return NULL;
@@ -851,7 +851,7 @@ static UINT check_directory( MSIPACKAGE *package, const WCHAR *dir, WCHAR **appV
     if (attr != INVALID_FILE_ATTRIBUTES && (attr & FILE_ATTRIBUTE_DIRECTORY))
     {
         TRACE("directory exists, returning %s\n", debugstr_w(dir));
-        *appValue = strdupW(dir);
+        *appValue = wcsdup(dir);
     }
 
     return ERROR_SUCCESS;
diff --git a/dlls/msi/assembly.c b/dlls/msi/assembly.c
index 9f75a9c02815..670b0112a0c9 100644
--- a/dlls/msi/assembly.c
+++ b/dlls/msi/assembly.c
@@ -327,13 +327,13 @@ MSIASSEMBLY *msi_load_assembly( MSIPACKAGE *package, MSICOMPONENT *comp )
         msiobj_release( &rec->hdr );
         return NULL;
     }
-    a->feature = strdupW( MSI_RecordGetString( rec, 2 ) );
+    a->feature = wcsdup( MSI_RecordGetString( rec, 2 ) );
     TRACE("feature %s\n", debugstr_w(a->feature));
 
-    a->manifest = strdupW( MSI_RecordGetString( rec, 3 ) );
+    a->manifest = wcsdup( MSI_RecordGetString( rec, 3 ) );
     TRACE("manifest %s\n", debugstr_w(a->manifest));
 
-    a->application = strdupW( MSI_RecordGetString( rec, 4 ) );
+    a->application = wcsdup( MSI_RecordGetString( rec, 4 ) );
     TRACE("application %s\n", debugstr_w(a->application));
 
     a->attributes = MSI_RecordGetInteger( rec, 5 );
diff --git a/dlls/msi/classes.c b/dlls/msi/classes.c
index b2c94fa0ff59..5ba3f480071b 100644
--- a/dlls/msi/classes.c
+++ b/dlls/msi/classes.c
@@ -254,14 +254,14 @@ static MSICLASS *load_class( MSIPACKAGE* package, MSIRECORD *row )
             switch(i)
             {
                 case 1:
-                    cls->DefInprocHandler = strdupW(L"ole2.dll");
+                    cls->DefInprocHandler = wcsdup(L"ole2.dll");
                     break;
                 case 2:
-                    cls->DefInprocHandler32 = strdupW(L"ole32.dll");
+                    cls->DefInprocHandler32 = wcsdup(L"ole32.dll");
                     break;
                 case 3:
-                    cls->DefInprocHandler = strdupW(L"ole2.dll");
-                    cls->DefInprocHandler32 = strdupW(L"ole32.dll");
+                    cls->DefInprocHandler = wcsdup(L"ole2.dll");
+                    cls->DefInprocHandler32 = wcsdup(L"ole32.dll");
                     break;
             }
         }
@@ -333,7 +333,7 @@ static MSIMIME *load_mime( MSIPACKAGE* package, MSIRECORD *row )
 
     extension = MSI_RecordGetString( row, 2 );
     mt->Extension = load_given_extension( package, extension );
-    mt->suffix = strdupW( extension );
+    mt->suffix = wcsdup( extension );
 
     mt->clsid = msi_dup_record_field( row, 3 );
     mt->Class = load_given_class( package, mt->clsid );
diff --git a/dlls/msi/cond.y b/dlls/msi/cond.y
index c7c9045ff52e..cb6f4f40d5a2 100644
--- a/dlls/msi/cond.y
+++ b/dlls/msi/cond.y
@@ -413,8 +413,8 @@ static int COND_IsNumber( WCHAR x )
 static WCHAR *strstriW( const WCHAR *str, const WCHAR *sub )
 {
     LPWSTR strlower, sublower, r;
-    strlower = CharLowerW( strdupW( str ) );
-    sublower = CharLowerW( strdupW( sub ) );
+    strlower = CharLowerW( wcsdup( str ) );
+    sublower = CharLowerW( wcsdup( sub ) );
     r = wcsstr( strlower, sublower );
     if (r)
         r = (LPWSTR)str + (r - strlower);
diff --git a/dlls/msi/custom.c b/dlls/msi/custom.c
index 8ff3d90fa580..3ae7c6426caf 100644
--- a/dlls/msi/custom.c
+++ b/dlls/msi/custom.c
@@ -98,7 +98,7 @@ UINT msi_schedule_action( MSIPACKAGE *package, UINT script, const WCHAR *action
                                           package->script_actions_count[script] * sizeof(WCHAR *) );
     else newbuf = msi_alloc( sizeof(WCHAR *) );
 
-    newbuf[count] = strdupW( action );
+    newbuf[count] = wcsdup( action );
     package->script_actions[script] = newbuf;
     return ERROR_SUCCESS;
 }
@@ -116,7 +116,7 @@ UINT msi_register_unique_action( MSIPACKAGE *package, const WCHAR *action )
                                           package->unique_actions_count * sizeof(WCHAR *) );
     else newbuf = msi_alloc( sizeof(WCHAR *) );
 
-    newbuf[count] = strdupW( action );
+    newbuf[count] = wcsdup( action );
     package->unique_actions = newbuf;
     return ERROR_SUCCESS;
 }
@@ -178,7 +178,7 @@ static LPWSTR msi_get_deferred_action(LPCWSTR action, LPCWSTR actiondata,
     DWORD len;
 
     if (!actiondata)
-        return strdupW(action);
+        return wcsdup(action);
 
     len = lstrlenW(action) + lstrlenW(actiondata) +
           lstrlenW(usersid) + lstrlenW(prodcode) +
@@ -219,7 +219,7 @@ WCHAR *msi_create_temp_file( MSIDATABASE *db )
         {
             GetTempPathW( MAX_PATH, tmp );
         }
-        if (!(db->tempfolder = strdupW( tmp ))) return NULL;
+        if (!(db->tempfolder = wcsdup( tmp ))) return NULL;
     }
 
     if ((ret = msi_alloc( (lstrlenW( db->tempfolder ) + 20) * sizeof(WCHAR) )))
@@ -267,7 +267,7 @@ static MSIBINARY *create_temp_binary(MSIPACKAGE *package, LPCWSTR source)
     CloseHandle( file );
     if (r != ERROR_SUCCESS) goto error;
 
-    binary->source = strdupW( source );
+    binary->source = wcsdup( source );
     binary->tmpfile = tmpfile;
     list_add_tail( &package->binaries, &binary->entry );
 
@@ -304,7 +304,7 @@ static void file_running_action(MSIPACKAGE* package, HANDLE Handle,
 
     action->handle = Handle;
     action->process = process;
-    action->name = strdupW(name);
+    action->name = wcsdup(name);
 
     list_add_tail( &package->RunningActions, &action->entry );
 }
@@ -754,9 +754,9 @@ static msi_custom_action_info *do_msidbCustomActionTypeDll(
     msiobj_addref( &package->hdr );
     info->package = package;
     info->type = type;
-    info->target = strdupW( target );
-    info->source = strdupW( source );
-    info->action = strdupW( action );
+    info->target = wcsdup( target );
+    info->source = wcsdup( source );
+    info->action = wcsdup( action );
     CoCreateGuid( &info->guid );
 
     EnterCriticalSection( &msi_custom_action_cs );
@@ -1201,9 +1201,9 @@ static msi_custom_action_info *do_msidbCustomActionTypeScript(
     msiobj_addref( &package->hdr );
     info->package = package;
     info->type = type;
-    info->target = strdupW( function );
-    info->source = strdupW( script );
-    info->action = strdupW( action );
+    info->target = wcsdup( function );
+    info->source = wcsdup( script );
+    info->action = wcsdup( action );
     CoCreateGuid( &info->guid );
 
     EnterCriticalSection( &msi_custom_action_cs );
@@ -1615,10 +1615,10 @@ UINT __cdecl s_remote_GetActionInfo(const GUID *guid, WCHAR **name, int *type, W
     if (!info)
         return ERROR_INVALID_DATA;
 
-    *name = strdupW(info->action);
+    *name = wcsdup(info->action);
     *type = info->type;
     *hinst = alloc_msihandle(&info->package->hdr);
-    *dll = strdupW(info->source);
+    *dll = wcsdup(info->source);
     *func = strdupWtoA(info->target);
 
     return ERROR_SUCCESS;
diff --git a/dlls/msi/database.c b/dlls/msi/database.c
index f7305e661efd..46346c469db1 100644
--- a/dlls/msi/database.c
+++ b/dlls/msi/database.c
@@ -262,7 +262,7 @@ UINT MSI_OpenDatabaseW(LPCWSTR szDBPath, LPCWSTR szPersist, MSIDATABASE **pdb)
     else
         lstrcpyW( path, save_path );
 
-    db->path = strdupW( path );
+    db->path = wcsdup( path );
     db->media_transform_offset = MSI_INITIAL_MEDIA_TRANSFORM_OFFSET;
     db->media_transform_disk_id = MSI_INITIAL_MEDIA_TRANSFORM_DISKID;
 
@@ -272,7 +272,7 @@ UINT MSI_OpenDatabaseW(LPCWSTR szDBPath, LPCWSTR szPersist, MSIDATABASE **pdb)
     db->storage = stg;
     db->mode = mode;
     if (created)
-        db->deletefile = strdupW( szDBPath );
+        db->deletefile = wcsdup( szDBPath );
     list_init( &db->tables );
     list_init( &db->transforms );
 
@@ -1542,10 +1542,10 @@ static UINT msi_get_table_labels(MSIDATABASE *db, LPCWSTR table, LPWSTR **labels
         goto end;
     }
 
-    (*labels)[0] = strdupW(table);
+    (*labels)[0] = wcsdup(table);
     for (i=1; i<=count; i++ )
     {
-        (*labels)[i] = strdupW(MSI_RecordGetString(prec, i));
+        (*labels)[i] = wcsdup(MSI_RecordGetString(prec, i));
     }
 
 end:
@@ -1572,7 +1572,7 @@ static UINT msi_get_query_columns(MSIQUERY *query, LPWSTR **columns, DWORD *numc
 
     for (i=1; i<=count; i++ )
     {
-        (*columns)[i-1] = strdupW(MSI_RecordGetString(prec, i));
+        (*columns)[i-1] = wcsdup(MSI_RecordGetString(prec, i));
     }
 
     *numcolumns = count;
@@ -1602,7 +1602,7 @@ static UINT msi_get_query_types(MSIQUERY *query, LPWSTR **types, DWORD *numtypes
     *numtypes = count;
     for (i=1; i<=count; i++ )
     {
-        (*types)[i-1] = strdupW(MSI_RecordGetString(prec, i));
+        (*types)[i-1] = wcsdup(MSI_RecordGetString(prec, i));
     }
 
 end:
@@ -1689,7 +1689,7 @@ static UINT msi_get_merge_table (MSIDATABASE *db, LPCWSTR name, MERGETABLE **pta
 
     list_init(&table->rows);
 
-    table->name = strdupW(name);
+    table->name = wcsdup(name);
     table->numconflicts = 0;
 
     msiobj_release(&mergeview->hdr);
diff --git a/dlls/msi/dialog.c b/dlls/msi/dialog.c
index 9d82be8c2bd2..d5d0fd3f20dd 100644
--- a/dlls/msi/dialog.c
+++ b/dlls/msi/dialog.c
@@ -225,7 +225,7 @@ static LPWSTR msi_dialog_dup_property( msi_dialog *dialog, LPCWSTR property, BOO
         prop = msi_dup_property( dialog->package->db, property );
 
     if (!prop)
-        prop = strdupW( property );
+        prop = wcsdup( property );
 
     return prop;
 }
@@ -402,8 +402,8 @@ static msi_control *dialog_create_window( msi_dialog *dialog, MSIRECORD *rec, DW
     control->hIcon = NULL;
     control->hImageList = NULL;
     control->hDll = NULL;
-    control->tabnext = strdupW( MSI_RecordGetString( rec, 11) );
-    control->type = strdupW( MSI_RecordGetString( rec, 3 ) );
+    control->tabnext = wcsdup( MSI_RecordGetString( rec, 11 ) );
+    control->type = wcsdup( MSI_RecordGetString( rec, 3 ) );
     control->progress_current = 0;
     control->progress_max = 100;
     control->progress_backwards = FALSE;
@@ -446,7 +446,7 @@ static LPWSTR msi_dialog_get_uitext( msi_dialog *dialog, LPCWSTR key )
 
     rec = MSI_QueryGetRecord( dialog->package->db, L"SELECT * FROM `UIText` WHERE `Key` = '%s'", key );
     if (!rec) return NULL;
-    text = strdupW( MSI_RecordGetString( rec, 2 ) );
+    text = wcsdup( MSI_RecordGetString( rec, 2 ) );
     msiobj_release( &rec->hdr );
     return text;
 }
@@ -677,9 +677,9 @@ static void event_subscribe( msi_dialog *dialog, const WCHAR *event, const WCHAR
     }
     if (!(sub = msi_alloc( sizeof(*sub) ))) return;
     sub->dialog    = dialog;
-    sub->event     = strdupW( event );
-    sub->control   = strdupW( control );
-    sub->attribute = strdupW( attribute );
+    sub->event     = wcsdup( event );
+    sub->control   = wcsdup( control );
+    sub->attribute = wcsdup( attribute );
     list_add_tail( &dialog->package->subscriptions, &sub->entry );
 }
 
@@ -856,7 +856,7 @@ static WCHAR *msi_get_binary_name( MSIPACKAGE *package, MSIRECORD *rec )
     while (*p && *p != '}') p++;
     if (!*p++) return text;
 
-    p = strdupW( p );
+    p = wcsdup( p );
     msi_free( text );
     return p;
 }
@@ -1163,7 +1163,7 @@ static UINT msi_dialog_checkbox_control( msi_dialog *dialog, MSIRECORD *rec )
     prop = MSI_RecordGetString( rec, 9 );
     if (prop)
     {
-        control->property = strdupW( prop );
+        control->property = wcsdup( prop );
         control->value = msi_get_checkbox_value( dialog, prop );
         TRACE("control %s value %s\n", debugstr_w(control->property), debugstr_w(control->value));
     }
@@ -1207,8 +1207,8 @@ static UINT msi_dialog_line_control( msi_dialog *dialog, MSIRECORD *rec )
     control->hBitmap = NULL;
     control->hIcon = NULL;
     control->hDll = NULL;
-    control->tabnext = strdupW( MSI_RecordGetString( rec, 11) );
-    control->type = strdupW( MSI_RecordGetString( rec, 3 ) );
+    control->tabnext = wcsdup( MSI_RecordGetString( rec, 11 ) );
+    control->type = wcsdup( MSI_RecordGetString( rec, 3 ) );
     control->progress_current = 0;
     control->progress_max = 100;
     control->progress_backwards = FALSE;
@@ -1458,7 +1458,7 @@ static UINT msi_combobox_add_item( MSIRECORD *rec, LPVOID param )
     value = MSI_RecordGetString( rec, 3 );
     text = MSI_RecordGetString( rec, 4 );
 
-    info->items[info->addpos_items] = strdupW( value );
+    info->items[info->addpos_items] = wcsdup( value );
 
     pos = SendMessageW( info->hwnd, CB_ADDSTRING, 0, (LPARAM)text );
     SendMessageW( info->hwnd, CB_SETITEMDATA, pos, (LPARAM)info->items[info->addpos_items] );
@@ -1705,7 +1705,7 @@ static UINT msi_dialog_edit_control( msi_dialog *dialog, MSIRECORD *rec )
 
     prop = MSI_RecordGetString( rec, 9 );
     if( prop )
-        control->property = strdupW( prop );
+        control->property = wcsdup( prop );
 
     val = msi_dup_property( dialog->package->db, control->property );
     SetWindowTextW( control->hwnd, val );
@@ -1864,7 +1864,7 @@ msi_maskedit_set_text( struct msi_maskedit_info *info, LPCWSTR text )
     {
         if( info->group[i].len < lstrlenW( p ) )
         {
-            LPWSTR chunk = strdupW( p );
+            WCHAR *chunk = wcsdup( p );
             chunk[ info->group[i].len ] = 0;
             SetWindowTextW( info->group[i].hwnd, chunk );
             msi_free( chunk );
@@ -2035,7 +2035,7 @@ static UINT msi_dialog_maskedit_control( msi_dialog *dialog, MSIRECORD *rec )
 
     prop = MSI_RecordGetString( rec, 9 );
     if( prop )
-        info->prop = strdupW( prop );
+        info->prop = wcsdup( prop );
 
     msi_maskedit_create_children( info, font );
 
@@ -2245,7 +2245,7 @@ static UINT msi_dialog_create_radiobutton( MSIRECORD *rec, LPVOID param )
 
     prop = MSI_RecordGetString( rec, 1 );
     if( prop )
-        control->property = strdupW( prop );
+        control->property = wcsdup( prop );
 
     return ERROR_SUCCESS;
 }
@@ -2311,7 +2311,7 @@ static UINT msi_dialog_radiogroup_control( msi_dialog *dialog, MSIRECORD *rec )
     SetWindowLongPtrW( control->hwnd, GWL_EXSTYLE, WS_EX_CONTROLPARENT );
 
     if( prop )
-        control->property = strdupW( prop );
+        control->property = wcsdup( prop );
 
     /* query the Radio Button table for all control in this group */
     r = MSI_OpenQuery( package->db, &view, L"SELECT * FROM `RadioButton` WHERE `Property` = '%s'", prop );
@@ -2744,7 +2744,7 @@ static UINT msi_listbox_add_item( MSIRECORD *rec, LPVOID param )
     value = MSI_RecordGetString( rec, 3 );
     text = MSI_RecordGetString( rec, 4 );
 
-    info->items[info->addpos_items] = strdupW( value );
+    info->items[info->addpos_items] = wcsdup( value );
 
     pos = SendMessageW( info->hwnd, LB_ADDSTRING, 0, (LPARAM)text );
     SendMessageW( info->hwnd, LB_SETITEMDATA, pos, (LPARAM)info->items[info->addpos_items] );
@@ -3762,7 +3762,7 @@ static LRESULT msi_dialog_oncreate( HWND hwnd, LPCREATESTRUCTW cs )
     dialog->default_font = msi_dup_property( dialog->package->db, L"DefaultUIFont" );
     if (!dialog->default_font)
     {
-        dialog->default_font = strdupW( L"MS Shell Dlg" );
+        dialog->default_font = wcsdup( L"MS Shell Dlg" );
         if (!dialog->default_font)
         {
             msiobj_release( &rec->hdr );
@@ -4024,8 +4024,8 @@ static msi_dialog *dialog_create( MSIPACKAGE *package, const WCHAR *name, msi_di
         return NULL;
     }
     dialog->attributes = MSI_RecordGetInteger( rec, 6 );
-    dialog->control_default = strdupW( MSI_RecordGetString( rec, 9 ) );
-    dialog->control_cancel = strdupW( MSI_RecordGetString( rec, 10 ) );
+    dialog->control_default = wcsdup( MSI_RecordGetString( rec, 9 ) );
+    dialog->control_cancel = wcsdup( MSI_RecordGetString( rec, 10 ) );
     msiobj_release( &rec->hdr );
 
     rec = MSI_CreateRecord(2);
@@ -4372,7 +4372,7 @@ static UINT pending_event_end_dialog( msi_dialog *dialog, const WCHAR *argument
 {
     dialog->pending_event = event_end_dialog;
     msi_free( dialog->pending_argument );
-    dialog->pending_argument = strdupW( argument );
+    dialog->pending_argument = wcsdup( argument );
     return ERROR_SUCCESS;
 }
 
@@ -4380,7 +4380,7 @@ static UINT pending_event_end_dialog( msi_dialog *dialog, const WCHAR *argument
 static UINT event_new_dialog( msi_dialog *dialog, const WCHAR *argument )
 {
     /* store the name of the next dialog, and signal this one to end */
-    dialog->package->next_dialog = strdupW( argument );
+    dialog->package->next_dialog = wcsdup( argument );
     msi_event_cleanup_all_subscriptions( dialog->package );
     msi_dialog_end_dialog( dialog );
     return ERROR_SUCCESS;
@@ -4390,7 +4390,7 @@ static UINT pending_event_new_dialog( msi_dialog *dialog, const WCHAR *argument
 {
     dialog->pending_event = event_new_dialog;
     msi_free( dialog->pending_argument );
-    dialog->pending_argument = strdupW( argument );
+    dialog->pending_argument = wcsdup( argument );
     return ERROR_SUCCESS;
 }
 
@@ -4415,7 +4415,7 @@ static UINT pending_event_spawn_dialog( msi_dialog *dialog, const WCHAR *argumen
 {
     dialog->pending_event = event_spawn_dialog;
     msi_free( dialog->pending_argument );
-    dialog->pending_argument = strdupW( argument );
+    dialog->pending_argument = wcsdup( argument );
     return ERROR_SUCCESS;
 }
 
diff --git a/dlls/msi/files.c b/dlls/msi/files.c
index 94c733fca8fa..b335a511339d 100644
--- a/dlls/msi/files.c
+++ b/dlls/msi/files.c
@@ -443,7 +443,7 @@ static UINT copy_install_file(MSIPACKAGE *package, MSIFILE *file, LPWSTR source)
 
         TRACE("file in use, scheduling rename operation\n");
 
-        if (!(pathW = strdupW( file->TargetPath ))) return ERROR_OUTOFMEMORY;
+        if (!(pathW = wcsdup( file->TargetPath ))) return ERROR_OUTOFMEMORY;
         if ((p = wcsrchr(pathW, '\\'))) *p = 0;
         len = lstrlenW( pathW ) + 16;
         if (!(tmpfileW = msi_alloc(len * sizeof(WCHAR))))
@@ -522,7 +522,7 @@ static BOOL installfiles_cb(MSIPACKAGE *package, LPCWSTR filename, DWORD action,
         {
             create_directory( package, file->Component->Directory );
         }
-        *path = strdupW( file->TargetPath );
+        *path = wcsdup( file->TargetPath );
         *attrs = file->Attributes;
         *(MSIFILE **)user = file;
     }
@@ -706,7 +706,7 @@ static BOOL patchfiles_cb(MSIPACKAGE *package, LPCWSTR file, DWORD action,
         }
 
         patch->path = msi_create_temp_file( package->db );
-        *path = strdupW( patch->path );
+        *path = wcsdup( patch->path );
         *attrs = patch->File->Attributes;
         *(MSIFILEPATCH **)user = patch;
     }
@@ -971,7 +971,7 @@ static BOOL add_wildcard( FILE_LIST *files, const WCHAR *source, WCHAR *dest )
     if (!new)
         return FALSE;
 
-    new->source = strdupW(source);
+    new->source = wcsdup(source);
     ptr = wcsrchr(dest, '\\') + 1;
     filename = wcsrchr(new->source, '\\') + 1;
 
@@ -1125,7 +1125,7 @@ static UINT ITERATE_MoveFiles( MSIRECORD *rec, LPVOID param )
         if (msi_get_file_attributes( package, sourcedir ) == INVALID_FILE_ATTRIBUTES)
             goto done;
 
-        source = strdupW(sourcedir);
+        source = wcsdup(sourcedir);
         if (!source)
             goto done;
     }
@@ -1150,18 +1150,18 @@ static UINT ITERATE_MoveFiles( MSIRECORD *rec, LPVOID param )
         {
             WCHAR *p;
             if (sourcename)
-                destname = strdupW(sourcename);
+                destname = wcsdup(sourcename);
             else if ((p = wcsrchr(sourcedir, '\\')))
-                destname = strdupW(p + 1);
+                destname = wcsdup(p + 1);
             else
-                destname = strdupW(sourcedir);
+                destname = wcsdup(sourcedir);
             if (!destname)
                 goto done;
         }
     }
     else
     {
-        destname = strdupW(MSI_RecordGetString(rec, 4));
+        destname = wcsdup(MSI_RecordGetString(rec, 4));
         if (destname) msi_reduce_to_long_filename(destname);
     }
 
@@ -1251,7 +1251,7 @@ static WCHAR *get_duplicate_filename( MSIPACKAGE *package, MSIRECORD *row, const
     if (MSI_RecordIsNull( row, 5 ))
     {
         WCHAR *p;
-        dst_path = strdupW( src );
+        dst_path = wcsdup( src );
         p = wcsrchr( dst_path, '\\' );
         if (p) *p = 0;
     }
@@ -1259,7 +1259,7 @@ static WCHAR *get_duplicate_filename( MSIPACKAGE *package, MSIRECORD *row, const
     {
         const WCHAR *dst_key = MSI_RecordGetString( row, 5 );
 
-        dst_path = strdupW( msi_get_target_folder( package, dst_key ) );
+        dst_path = wcsdup( msi_get_target_folder( package, dst_key ) );
         if (!dst_path)
         {
             /* try a property */
@@ -1500,7 +1500,7 @@ static UINT ITERATE_RemoveFiles(MSIRECORD *row, LPVOID param)
         return ERROR_SUCCESS;
     }
     size = 0;
-    if ((filename = strdupW( MSI_RecordGetString(row, 3) )))
+    if ((filename = wcsdup( MSI_RecordGetString(row, 3) )))
     {
         msi_reduce_to_long_filename( filename );
         size = lstrlenW( filename );
diff --git a/dlls/msi/font.c b/dlls/msi/font.c
index 78d384b1654c..4dbddc4d72ac 100644
--- a/dlls/msi/font.c
+++ b/dlls/msi/font.c
@@ -152,7 +152,7 @@ static WCHAR *load_ttf_name_id( MSIPACKAGE *package, const WCHAR *filename, DWOR
                 goto end;
             }
             for (i = 0; i < dwRead / sizeof(WCHAR); i++) buf[i] = SWAPWORD(buf[i]);
-            ret = strdupW(buf);
+            ret = wcsdup(buf);
             msi_free(buf);
             break;
         }
@@ -260,7 +260,7 @@ static UINT ITERATE_RegisterFonts(MSIRECORD *row, LPVOID param)
 
     /* the UI chunk */
     uirow = MSI_CreateRecord( 1 );
-    uipath = strdupW( file->TargetPath );
+    uipath = wcsdup( file->TargetPath );
     p = wcsrchr(uipath,'\\');
     if (p) p++;
     else p = uipath;
@@ -341,7 +341,7 @@ static UINT ITERATE_UnregisterFonts( MSIRECORD *row, LPVOID param )
 
     /* the UI chunk */
     uirow = MSI_CreateRecord( 1 );
-    uipath = strdupW( file->TargetPath );
+    uipath = wcsdup( file->TargetPath );
     p = wcsrchr( uipath,'\\' );
     if (p) p++;
     else p = uipath;
diff --git a/dlls/msi/format.c b/dlls/msi/format.c
index fdfffabc22f9..f2be8db87fc8 100644
--- a/dlls/msi/format.c
+++ b/dlls/msi/format.c
@@ -219,7 +219,7 @@ static WCHAR *deformat_component( FORMAT *format, FORMSTR *str, int *ret_len )
     if (comp->Action == INSTALLSTATE_SOURCE)
         ret = msi_resolve_source_folder( format->package, comp->Directory, NULL );
     else
-        ret = strdupW( msi_get_target_folder( format->package, comp->Directory ) );
+        ret = wcsdup( msi_get_target_folder( format->package, comp->Directory ) );
 
     if (ret) *ret_len = lstrlenW( ret );
     else *ret_len = 0;
@@ -239,12 +239,12 @@ static WCHAR *deformat_file( FORMAT *format, FORMSTR *str, BOOL shortname, int *
     if (!(file = msi_get_loaded_file( format->package, key ))) goto done;
     if (!shortname)
     {
-        if ((ret = strdupW( file->TargetPath ))) len = lstrlenW( ret );
+        if ((ret = wcsdup( file->TargetPath ))) len = lstrlenW( ret );
         goto done;
     }
     if (!(len = GetShortPathNameW(file->TargetPath, NULL, 0)))
     {
-        if ((ret = strdupW( file->TargetPath ))) len = lstrlenW( ret );
+        if ((ret = wcsdup( file->TargetPath ))) len = lstrlenW( ret );
         goto done;
     }
     len++;
@@ -770,7 +770,7 @@ static DWORD deformat_string_internal(MSIPACKAGE *package, LPCWSTR ptr,
         return ERROR_SUCCESS;
     }
 
-    *data = strdupW(ptr);
+    *data = wcsdup(ptr);
     *len = lstrlenW(ptr);
 
     ZeroMemory(&format, sizeof(FORMAT));
diff --git a/dlls/msi/install.c b/dlls/msi/install.c
index bf60406f8ef3..b9e646be2476 100644
--- a/dlls/msi/install.c
+++ b/dlls/msi/install.c
@@ -379,7 +379,7 @@ WCHAR *msi_resolve_source_folder( MSIPACKAGE *package, const WCHAR *name, MSIFOL
     if (folder) *folder = f;
     if (f->ResolvedSource)
     {
-        path = strdupW( f->ResolvedSource );
+        path = wcsdup( f->ResolvedSource );
         TRACE("   already resolved to %s\n", debugstr_w(path));
         return path;
     }
@@ -397,7 +397,7 @@ WCHAR *msi_resolve_source_folder( MSIPACKAGE *package, const WCHAR *name, MSIFOL
         path = msi_build_directory_name( 3, p, f->SourceLongPath, NULL );
 
     TRACE("-> %s\n", debugstr_w(path));
-    f->ResolvedSource = strdupW( path );
+    f->ResolvedSource = wcsdup( path );
     msi_free( p );
 
     return path;
diff --git a/dlls/msi/media.c b/dlls/msi/media.c
index db65a282b93d..fb96014317b6 100644
--- a/dlls/msi/media.c
+++ b/dlls/msi/media.c
@@ -282,9 +282,9 @@ static UINT msi_media_get_disk_info(MSIPACKAGE *package, MSIMEDIAINFO *mi)
         return ERROR_FUNCTION_FAILED;
     }
 
-    mi->disk_prompt = strdupW(MSI_RecordGetString(row, 3));
-    mi->cabinet = strdupW(MSI_RecordGetString(row, 4));
-    mi->volume_label = strdupW(MSI_RecordGetString(row, 5));
+    mi->disk_prompt = wcsdup(MSI_RecordGetString(row, 3));
+    mi->cabinet = wcsdup(MSI_RecordGetString(row, 4));
+    mi->volume_label = wcsdup(MSI_RecordGetString(row, 5));
 
     msiobj_release(&row->hdr);
     return ERROR_SUCCESS;
@@ -460,7 +460,7 @@ static INT_PTR cabinet_copy_file(FDINOTIFICATIONTYPE fdint,
 
             TRACE("file in use, scheduling rename operation\n");
 
-            if (!(tmppathW = strdupW( path ))) return ERROR_OUTOFMEMORY;
+            if (!(tmppathW = wcsdup(path))) return ERROR_OUTOFMEMORY;
             if ((p = wcsrchr(tmppathW, '\\'))) *p = 0;
             len = lstrlenW( tmppathW ) + 16;
             if (!(tmpfileW = msi_alloc(len * sizeof(WCHAR))))
@@ -681,7 +681,7 @@ static UINT get_drive_type(const WCHAR *path)
 static WCHAR *get_base_url( MSIDATABASE *db )
 {
     WCHAR *p, *ret = NULL, *orig_db = msi_dup_property( db, L"OriginalDatabase" );
-    if (UrlIsW( orig_db, URLIS_URL ) && (ret = strdupW( orig_db )) && (p = wcsrchr( ret, '/'))) p[1] = 0;
+    if (UrlIsW( orig_db, URLIS_URL ) && (ret = wcsdup( orig_db )) && (p = wcsrchr( ret, '/' ))) p[1] = 0;
     msi_free( orig_db );
     return ret;
 }
@@ -706,11 +706,11 @@ UINT msi_load_media_info(MSIPACKAGE *package, UINT Sequence, MSIMEDIAINFO *mi)
     mi->disk_id = MSI_RecordGetInteger(row, 1);
     mi->last_sequence = MSI_RecordGetInteger(row, 2);
     msi_free(mi->disk_prompt);
-    mi->disk_prompt = strdupW(MSI_RecordGetString(row, 3));
+    mi->disk_prompt = wcsdup(MSI_RecordGetString(row, 3));
     msi_free(mi->cabinet);
-    mi->cabinet = strdupW(MSI_RecordGetString(row, 4));
+    mi->cabinet = wcsdup(MSI_RecordGetString(row, 4));
     msi_free(mi->volume_label);
-    mi->volume_label = strdupW(MSI_RecordGetString(row, 5));
+    mi->volume_label = wcsdup(MSI_RecordGetString(row, 5));
     msiobj_release(&row->hdr);
 
     msi_set_sourcedir_props(package, FALSE);
@@ -887,7 +887,7 @@ UINT ready_media( MSIPACKAGE *package, BOOL compressed, MSIMEDIAINFO *mi )
             lstrcpyW( mi->sourcedir, temppath );
             PathAddBackslashW( mi->sourcedir );
             msi_free( mi->cabinet );
-            mi->cabinet = strdupW( p + 1 );
+            mi->cabinet = wcsdup( p + 1 );
 
             msi_free( url );
             return ERROR_SUCCESS;
@@ -914,7 +914,7 @@ UINT ready_media( MSIPACKAGE *package, BOOL compressed, MSIMEDIAINFO *mi )
         }
 
         msi_free(mi->last_volume);
-        mi->last_volume = strdupW(mi->volume_label);
+        mi->last_volume = wcsdup(mi->volume_label);
     }
     if (mi->cabinet)
     {
diff --git a/dlls/msi/msi.c b/dlls/msi/msi.c
index 872c6cb66e26..56a4625febf4 100644
--- a/dlls/msi/msi.c
+++ b/dlls/msi/msi.c
@@ -1080,7 +1080,7 @@ static WCHAR *reg_get_value( HKEY hkey, const WCHAR *name, DWORD *type )
 
         if (!msi_reg_get_val_dword( hkey, name, &val )) return NULL;
         swprintf( temp, ARRAY_SIZE(temp), L"%u", val );
-        return strdupW( temp );
+        return wcsdup( temp );
     }
 
     ERR( "unhandled value type %lu\n", *type );
@@ -1210,7 +1210,7 @@ static UINT MSI_GetProductInfo(LPCWSTR szProduct, LPCWSTR szAttribute,
             {
                 unsquash_guid(val, packagecode);
                 msi_free(val);
-                val = strdupW(packagecode);
+                val = wcsdup(packagecode);
             }
         }
     }
@@ -1488,7 +1488,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
 
         val = reg_get_value(props, szProperty, &type);
         if (!val)
-            val = strdupW(L"");
+            val = wcsdup(L"");
 
         r = msi_copy_outval(val, szValue, pcchValue);
     }
@@ -1513,7 +1513,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
 
         val = reg_get_value(hkey, szProperty, &type);
         if (!val)
-            val = strdupW(L"");
+            val = wcsdup(L"");
 
         r = msi_copy_outval(val, szValue, pcchValue);
     }
@@ -1528,10 +1528,10 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
                     goto done;
 
                 msi_free(val);
-                val = strdupW(L"5");
+                val = wcsdup(L"5");
             }
             else
-                val = strdupW(L"1");
+                val = wcsdup(L"1");
 
             r = msi_copy_outval(val, szValue, pcchValue);
             goto done;
@@ -1539,13 +1539,13 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
         else if (props && (val = reg_get_value(props, package, &type)))
         {
             msi_free(val);
-            val = strdupW(L"5");
+            val = wcsdup(L"5");
             r = msi_copy_outval(val, szValue, pcchValue);
             goto done;
         }
 
         if (prod || managed)
-            val = strdupW(L"1");
+            val = wcsdup(L"1");
         else
             goto done;
 
@@ -1557,7 +1557,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
             goto done;
 
         /* FIXME */
-        val = strdupW(L"");
+        val = wcsdup(L"");
         r = msi_copy_outval(val, szValue, pcchValue);
     }
     else
@@ -1760,7 +1760,7 @@ UINT WINAPI MsiGetPatchInfoExW(LPCWSTR szPatchCode, LPCWSTR szProductCode,
 
     val = reg_get_value(datakey, szProperty, &type);
     if (!val)
-        val = strdupW(L"");
+        val = wcsdup(L"");
 
     r = ERROR_SUCCESS;
 
@@ -1915,7 +1915,7 @@ UINT WINAPI MsiEnableLogW( DWORD dwLogMode, const WCHAR *szLogFile, DWORD attrib
                            FILE_ATTRIBUTE_NORMAL, NULL);
         if (file != INVALID_HANDLE_VALUE)
         {
-            gszLogFile = strdupW(szLogFile);
+            gszLogFile = wcsdup(szLogFile);
             CloseHandle(file);
         }
         else ERR( "unable to enable log %s (%lu)\n", debugstr_w(szLogFile), GetLastError() );
diff --git a/dlls/msi/msipriv.h b/dlls/msi/msipriv.h
index d63c6f244ff6..20150cf5c466 100644
--- a/dlls/msi/msipriv.h
+++ b/dlls/msi/msipriv.h
@@ -1188,14 +1188,4 @@ static inline LPWSTR strdupAtoW( LPCSTR str )
     return ret;
 }
 
-static inline LPWSTR strdupW( LPCWSTR src )
-{
-    LPWSTR dest;
-    if (!src) return NULL;
-    dest = msi_alloc( (lstrlenW(src)+1)*sizeof(WCHAR) );
-    if (dest)
-        lstrcpyW(dest, src);
-    return dest;
-}
-
 #endif /* __WINE_MSI_PRIVATE__ */
diff --git a/dlls/msi/package.c b/dlls/msi/package.c
index ccbcdea6717f..024449180c70 100644
--- a/dlls/msi/package.c
+++ b/dlls/msi/package.c
@@ -987,7 +987,7 @@ MSIPACKAGE *MSI_CreatePackage( MSIDATABASE *db )
         package->LastActionTemplate = NULL;
         package->LastActionResult = MSI_NULL_INTEGER;
         package->WordCount = 0;
-        package->PackagePath = strdupW( db->path );
+        package->PackagePath = wcsdup( db->path );
 
         create_temp_property_table( package );
         msi_clone_properties( package->db );
@@ -1225,7 +1225,7 @@ static WCHAR *get_property( MSIDATABASE *db, const WCHAR *prop )
     }
     if (MSI_ViewFetch( view, &rec ) == ERROR_SUCCESS)
     {
-        ret = strdupW( MSI_RecordGetString( rec, 1 ) );
+        ret = wcsdup( MSI_RecordGetString( rec, 1 ) );
         msiobj_release( &rec->hdr );
     }
     MSI_ViewClose( view );
@@ -1431,7 +1431,7 @@ UINT MSI_OpenPackageW(LPCWSTR szPackage, DWORD dwOptions, MSIPACKAGE **pPackage)
     package = MSI_CreatePackage( db );
     msiobj_release( &db->hdr );
     if (!package) return ERROR_INSTALL_PACKAGE_INVALID;
-    package->localfile = strdupW( localfile );
+    package->localfile = wcsdup( localfile );
     package->delete_on_close = delete_on_close;
 
     r = msi_get_suminfo( db->storage, 0, &si );
@@ -1892,7 +1892,7 @@ INT MSI_ProcessMessage( MSIPACKAGE *package, INSTALLMESSAGE eMessageType, MSIREC
                 template_rec = msi_dup_record_field(record, 0);
 
             template_prefix = msi_get_error_message(package->db, eMessageType >> 24);
-            if (!template_prefix) template_prefix = strdupW(L"");
+            if (!template_prefix) template_prefix = wcsdup(L"");
 
             if (!template_rec)
             {
@@ -1924,7 +1924,7 @@ INT MSI_ProcessMessage( MSIPACKAGE *package, INSTALLMESSAGE eMessageType, MSIREC
         msi_free(package->LastAction);
         msi_free(package->LastActionTemplate);
         package->LastAction = msi_dup_record_field(record, 1);
-        if (!package->LastAction) package->LastAction = strdupW(L"");
+        if (!package->LastAction) package->LastAction = wcsdup(L"");
         package->LastActionTemplate = msi_dup_record_field(record, 3);
         break;
     }
@@ -2576,7 +2576,7 @@ UINT msi_package_add_info(MSIPACKAGE *package, DWORD context, DWORD options,
     info->context = context;
     info->options = options;
     info->property = property;
-    info->value = strdupW(value);
+    info->value = wcsdup(value);
     list_add_head(&package->sourcelist_info, &info->entry);
 
     return ERROR_SUCCESS;
@@ -2599,8 +2599,8 @@ UINT msi_package_add_media_disk(MSIPACKAGE *package, DWORD context, DWORD option
     disk->context = context;
     disk->options = options;
     disk->disk_id = disk_id;
-    disk->volume_label = strdupW(volume_label);
-    disk->disk_prompt = strdupW(disk_prompt);
+    disk->volume_label = wcsdup(volume_label);
+    disk->disk_prompt = wcsdup(disk_prompt);
     list_add_head(&package->sourcelist_media, &disk->entry);
 
     return ERROR_SUCCESS;
diff --git a/dlls/msi/patch.c b/dlls/msi/patch.c
index 35b2784ba857..84ba305d23e6 100644
--- a/dlls/msi/patch.c
+++ b/dlls/msi/patch.c
@@ -911,8 +911,8 @@ static UINT msi_apply_patch_package( MSIPACKAGE *package, const WCHAR *file )
 
     r = ERROR_OUTOFMEMORY;
     patch->registered = FALSE;
-    if (!(patch->filename = strdupW( file ))) goto done;
-    if (!(patch->localfile = strdupW( localfile ))) goto done;
+    if (!(patch->filename = wcsdup( file ))) goto done;
+    if (!(patch->localfile = wcsdup( localfile ))) goto done;
 
     r = msi_apply_patch_db( package, patch_db, patch );
     if (r != ERROR_SUCCESS) WARN("patch failed to apply %u\n", r);
@@ -1027,7 +1027,7 @@ UINT msi_apply_registered_patch( MSIPACKAGE *package, LPCWSTR patch_code )
         return r;
     }
     patch_info->registered = TRUE;
-    patch_info->localfile = strdupW( patch_file );
+    patch_info->localfile = wcsdup( patch_file );
     if (!patch_info->localfile)
     {
         msiobj_release( &patch_db->hdr );
diff --git a/dlls/msi/record.c b/dlls/msi/record.c
index 9e11752cc978..277e4c374fcc 100644
--- a/dlls/msi/record.c
+++ b/dlls/msi/record.c
@@ -1129,7 +1129,7 @@ struct wire_record *marshal_record(MSIHANDLE handle)
             ret->fields[i].u.iVal = rec->fields[i].u.iVal;
             break;
         case MSIFIELD_WSTR:
-            ret->fields[i].u.szwVal = strdupW(rec->fields[i].u.szwVal);
+            ret->fields[i].u.szwVal = wcsdup(rec->fields[i].u.szwVal);
             break;
         case MSIFIELD_STREAM:
             IStream_AddRef(rec->fields[i].u.stream);
diff --git a/dlls/msi/source.c b/dlls/msi/source.c
index 7ed0aabf142d..4f118c32cd52 100644
--- a/dlls/msi/source.c
+++ b/dlls/msi/source.c
@@ -1088,7 +1088,7 @@ UINT WINAPI MsiSourceListAddSourceExW( const WCHAR *szProduct, const WCHAR *szUs
 
     postfix = (dwOptions & MSISOURCETYPE_NETWORK) ? L"\\" : L"/";
     if (szSource[lstrlenW(szSource) - 1] == *postfix)
-        source = strdupW(szSource);
+        source = wcsdup(szSource);
     else
     {
         size = lstrlenW(szSource) + 2;
@@ -1125,7 +1125,7 @@ UINT WINAPI MsiSourceListAddSourceExW( const WCHAR *szProduct, const WCHAR *szUs
             goto done;
         }
 
-        info->path = strdupW(source);
+        info->path = wcsdup(source);
         lstrcpyW(info->szIndex, name);
         info->index = dwIndex;
         add_source_to_list(&sourcelist, info, &index);
diff --git a/dlls/msi/storages.c b/dlls/msi/storages.c
index 8262f601693d..652f5f4988e4 100644
--- a/dlls/msi/storages.c
+++ b/dlls/msi/storages.c
@@ -218,7 +218,7 @@ static UINT STORAGES_set_row(struct tagMSIVIEW *view, UINT row, MSIRECORD *rec,
         return r;
     }
 
-    name = strdupW(MSI_RecordGetString(rec, 1));
+    name = wcsdup(MSI_RecordGetString(rec, 1));
     if (!name)
     {
         r = ERROR_OUTOFMEMORY;
diff --git a/dlls/msi/table.c b/dlls/msi/table.c
index 8168e2f837db..36ad40590141 100644
--- a/dlls/msi/table.c
+++ b/dlls/msi/table.c
@@ -3419,7 +3419,7 @@ UINT msi_table_apply_transform( MSIDATABASE *db, IStorage *stg, int err_cond )
 
         list_add_tail( &transforms, &transform->entry );
 
-        transform->name = strdupW( name + 1 );
+        transform->name = wcsdup( name + 1 );
 
         if ( !wcscmp( transform->name, L"_Tables" ) )
             tables = transform;

From b07c95e79cdf6ae26c5170daa481ad160e0ce76a Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Mon, 5 Dec 2022 23:51:37 -0700
Subject: [PATCH] msi: Use _O_* constants from fcntl.h instead of redefining
 them.

---
 dlls/msi/media.c | 18 +-----------------
 1 file changed, 1 insertion(+), 17 deletions(-)

diff --git a/dlls/msi/media.c b/dlls/msi/media.c
index fb96014317b6..bc17e5fcb62f 100644
--- a/dlls/msi/media.c
+++ b/dlls/msi/media.c
@@ -18,6 +18,7 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <fcntl.h>
 #include <stdarg.h>
 
 #define COBJMACROS
@@ -35,23 +36,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msi);
 
-/* from msvcrt/fcntl.h */
-#define _O_RDONLY      0
-#define _O_WRONLY      1
-#define _O_RDWR        2
-#define _O_ACCMODE     (_O_RDONLY|_O_WRONLY|_O_RDWR)
-#define _O_APPEND      0x0008
-#define _O_RANDOM      0x0010
-#define _O_SEQUENTIAL  0x0020
-#define _O_TEMPORARY   0x0040
-#define _O_NOINHERIT   0x0080
-#define _O_CREAT       0x0100
-#define _O_TRUNC       0x0200
-#define _O_EXCL        0x0400
-#define _O_SHORT_LIVED 0x1000
-#define _O_TEXT        0x4000
-#define _O_BINARY      0x8000
-
 static BOOL source_matches_volume(MSIMEDIAINFO *mi, LPCWSTR source_root)
 {
     WCHAR volume_name[MAX_PATH + 1], root[MAX_PATH + 1];
From d920aa81ad0c4618c27ebd7e9863618e988328e0 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Tue, 6 Dec 2022 09:19:24 -0700
Subject: [PATCH] msi: Remove wrappers around CRT memory allocation functions.

---
 dlls/msi/action.c     | 453 +++++++++++++++++++++---------------------
 dlls/msi/alter.c      |   6 +-
 dlls/msi/appsearch.c  |  68 +++----
 dlls/msi/assembly.c   |  44 ++--
 dlls/msi/automation.c |  54 ++---
 dlls/msi/classes.c    |  80 ++++----
 dlls/msi/cond.y       |  14 +-
 dlls/msi/create.c     |   6 +-
 dlls/msi/custom.c     | 132 ++++++------
 dlls/msi/database.c   | 166 ++++++++--------
 dlls/msi/delete.c     |   4 +-
 dlls/msi/dialog.c     | 244 +++++++++++------------
 dlls/msi/distinct.c   |  14 +-
 dlls/msi/drop.c       |   6 +-
 dlls/msi/files.c      | 108 +++++-----
 dlls/msi/font.c       |  24 +--
 dlls/msi/format.c     |  96 ++++-----
 dlls/msi/handle.c     |  10 +-
 dlls/msi/insert.c     |   4 +-
 dlls/msi/install.c    |  50 ++---
 dlls/msi/media.c      | 104 +++++-----
 dlls/msi/msi.c        | 284 +++++++++++++-------------
 dlls/msi/msi_main.c   |   2 +-
 dlls/msi/msipriv.h    |  28 +--
 dlls/msi/msiquery.c   |  24 +--
 dlls/msi/package.c    | 334 +++++++++++++++----------------
 dlls/msi/patch.c      | 130 ++++++------
 dlls/msi/record.c     |  14 +-
 dlls/msi/registry.c   |  82 ++++----
 dlls/msi/script.c     |   4 +-
 dlls/msi/select.c     |   6 +-
 dlls/msi/source.c     | 108 +++++-----
 dlls/msi/sql.y        |   2 +-
 dlls/msi/storages.c   |  18 +-
 dlls/msi/streams.c    |  20 +-
 dlls/msi/string.c     |  46 ++---
 dlls/msi/suminfo.c    |  34 ++--
 dlls/msi/table.c      | 202 +++++++++----------
 dlls/msi/update.c     |   4 +-
 dlls/msi/upgrade.c    |   8 +-
 dlls/msi/where.c      |  36 ++--
 41 files changed, 1524 insertions(+), 1549 deletions(-)

diff --git a/dlls/msi/action.c b/dlls/msi/action.c
index 64032071a5f5..d856e94efa7f 100644
--- a/dlls/msi/action.c
+++ b/dlls/msi/action.c
@@ -80,7 +80,7 @@ static void ui_actioninfo(MSIPACKAGE *package, LPCWSTR action, BOOL start,
     row = MSI_CreateRecord(2);
     if (!row)
     {
-        msi_free(template);
+        free(template);
         return;
     }
     MSI_RecordSetStringW(row, 0, template);
@@ -88,7 +88,7 @@ static void ui_actioninfo(MSIPACKAGE *package, LPCWSTR action, BOOL start,
     MSI_RecordSetInteger(row, 2, start ? package->LastActionResult : rc);
     MSI_ProcessMessage(package, INSTALLMESSAGE_INFO, row);
     msiobj_release(&row->hdr);
-    msi_free(template);
+    free(template);
     if (!start) package->LastActionResult = rc;
 }
 
@@ -230,7 +230,7 @@ UINT msi_parse_command_line( MSIPACKAGE *package, LPCWSTR szCommandLine,
 
         while (ptr[len - 1] == ' ') len--;
 
-        prop = msi_alloc( (len + 1) * sizeof(WCHAR) );
+        prop = malloc( (len + 1) * sizeof(WCHAR) );
         memcpy( prop, ptr, len * sizeof(WCHAR) );
         prop[len] = 0;
         if (!preserve_case) wcsupr( prop );
@@ -239,13 +239,13 @@ UINT msi_parse_command_line( MSIPACKAGE *package, LPCWSTR szCommandLine,
         while (*ptr2 == ' ') ptr2++;
 
         num_quotes = 0;
-        val = msi_alloc( (lstrlenW( ptr2 ) + 1) * sizeof(WCHAR) );
+        val = malloc( (wcslen( ptr2 ) + 1) * sizeof(WCHAR) );
         len = parse_prop( ptr2, val, &num_quotes );
         if (num_quotes % 2)
         {
             WARN("unbalanced quotes\n");
-            msi_free( val );
-            msi_free( prop );
+            free( val );
+            free( prop );
             return ERROR_INVALID_COMMAND_LINE;
         }
         remove_quotes( val );
@@ -255,8 +255,8 @@ UINT msi_parse_command_line( MSIPACKAGE *package, LPCWSTR szCommandLine,
         if (r == ERROR_SUCCESS && !wcscmp( prop, L"SourceDir" ))
             msi_reset_source_folders( package );
 
-        msi_free( val );
-        msi_free( prop );
+        free( val );
+        free( prop );
 
         ptr = ptr2 + len;
     }
@@ -313,8 +313,7 @@ WCHAR **msi_split_string( const WCHAR *str, WCHAR sep )
     }
 
     /* allocate space for an array of substring pointers and the substrings */
-    ret = msi_alloc( (count+1) * sizeof (LPWSTR) +
-                     (lstrlenW(str)+1) * sizeof(WCHAR) );
+    ret = malloc( (count + 1) * sizeof(WCHAR *) + (wcslen(str) + 1) * sizeof(WCHAR) );
     if (!ret)
         return ret;
 
@@ -354,13 +353,13 @@ UINT msi_set_sourcedir_props(MSIPACKAGE *package, BOOL replace)
 
     if (!(p = wcsrchr( db, '\\' )) && !(p = wcsrchr( db, '/' )))
     {
-        msi_free(db);
+        free(db);
         return ERROR_SUCCESS;
     }
     len = p - db + 2;
-    source = msi_alloc( len * sizeof(WCHAR) );
+    source = malloc( len * sizeof(WCHAR) );
     lstrcpynW( source, db, len );
-    msi_free( db );
+    free( db );
 
     check = msi_dup_property( package->db, L"SourceDir" );
     if (!check || replace)
@@ -369,14 +368,14 @@ UINT msi_set_sourcedir_props(MSIPACKAGE *package, BOOL replace)
         if (r == ERROR_SUCCESS)
             msi_reset_source_folders( package );
     }
-    msi_free( check );
+    free( check );
 
     check = msi_dup_property( package->db, L"SOURCEDIR" );
     if (!check || replace)
         msi_set_property( package->db, L"SOURCEDIR", source, -1 );
 
-    msi_free( check );
-    msi_free( source );
+    free( check );
+    free( source );
 
     return ERROR_SUCCESS;
 }
@@ -774,7 +773,7 @@ static UINT load_component( MSIRECORD *row, LPVOID param )
     MSIPACKAGE *package = param;
     MSICOMPONENT *comp;
 
-    comp = msi_alloc_zero( sizeof(MSICOMPONENT) );
+    comp = calloc( 1, sizeof(MSICOMPONENT) );
     if (!comp)
         return ERROR_FUNCTION_FAILED;
 
@@ -825,7 +824,7 @@ static UINT add_feature_component( MSIFEATURE *feature, MSICOMPONENT *comp )
 {
     ComponentList *cl;
 
-    cl = msi_alloc( sizeof (*cl) );
+    cl = malloc( sizeof(*cl) );
     if ( !cl )
         return ERROR_NOT_ENOUGH_MEMORY;
     cl->component = comp;
@@ -838,7 +837,7 @@ static UINT add_feature_child( MSIFEATURE *parent, MSIFEATURE *child )
 {
     FeatureList *fl;
 
-    fl = msi_alloc( sizeof(*fl) );
+    fl = malloc( sizeof(*fl) );
     if ( !fl )
         return ERROR_NOT_ENOUGH_MEMORY;
     fl->feature = child;
@@ -878,7 +877,7 @@ static UINT load_feature(MSIRECORD *row, LPVOID param)
 
     /* fill in the data */
 
-    feature = msi_alloc_zero( sizeof (MSIFEATURE) );
+    feature = calloc( 1, sizeof(MSIFEATURE) );
     if (!feature)
         return ERROR_NOT_ENOUGH_MEMORY;
 
@@ -1030,7 +1029,7 @@ static UINT load_file(MSIRECORD *row, LPVOID param)
 
     /* fill in the data */
 
-    file = msi_alloc_zero( sizeof (MSIFILE) );
+    file = calloc( 1, sizeof(MSIFILE) );
     if (!file)
         return ERROR_NOT_ENOUGH_MEMORY;
 
@@ -1042,8 +1041,8 @@ static UINT load_file(MSIRECORD *row, LPVOID param)
     if (!file->Component)
     {
         WARN("Component not found: %s\n", debugstr_w(component));
-        msi_free(file->File);
-        msi_free(file);
+        free(file->File);
+        free(file);
         return ERROR_SUCCESS;
     }
 
@@ -1152,7 +1151,7 @@ static UINT load_patch(MSIRECORD *row, LPVOID param)
     MSIFILEPATCH *patch;
     const WCHAR *file_key;
 
-    patch = msi_alloc_zero( sizeof (MSIFILEPATCH) );
+    patch = calloc( 1, sizeof(MSIFILEPATCH) );
     if (!patch)
         return ERROR_NOT_ENOUGH_MEMORY;
 
@@ -1161,7 +1160,7 @@ static UINT load_patch(MSIRECORD *row, LPVOID param)
     if (!patch->File)
     {
         ERR("Failed to find target for patch in File table\n");
-        msi_free(patch);
+        free(patch);
         return ERROR_FUNCTION_FAILED;
     }
 
@@ -1273,7 +1272,7 @@ static UINT load_folder( MSIRECORD *row, LPVOID param )
     LPWSTR p, tgt_short, tgt_long, src_short, src_long;
     MSIFOLDER *folder;
 
-    if (!(folder = msi_alloc_zero( sizeof(*folder) ))) return ERROR_NOT_ENOUGH_MEMORY;
+    if (!(folder = calloc( 1, sizeof(*folder) ))) return ERROR_NOT_ENOUGH_MEMORY;
     list_init( &folder->children );
     folder->Directory = msi_dup_record_field( row, 1 );
     folder->Parent = msi_dup_record_field( row, 2 );
@@ -1310,7 +1309,7 @@ static UINT load_folder( MSIRECORD *row, LPVOID param )
     folder->TargetDefault = wcsdup(tgt_long);
     folder->SourceShortPath = wcsdup(src_short);
     folder->SourceLongPath = wcsdup(src_long);
-    msi_free(p);
+    free(p);
 
     TRACE("TargetDefault = %s\n",debugstr_w( folder->TargetDefault ));
     TRACE("SourceLong = %s\n", debugstr_w( folder->SourceLongPath ));
@@ -1326,7 +1325,7 @@ static UINT add_folder_child( MSIFOLDER *parent, MSIFOLDER *child )
 {
     FolderList *fl;
 
-    if (!(fl = msi_alloc( sizeof(*fl) ))) return ERROR_NOT_ENOUGH_MEMORY;
+    if (!(fl = malloc( sizeof(*fl) ))) return ERROR_NOT_ENOUGH_MEMORY;
     fl->folder = child;
     list_add_tail( &parent->children, &fl->entry );
     return ERROR_SUCCESS;
@@ -1555,7 +1554,7 @@ static BOOL process_state_property(MSIPACKAGE* package, int level,
             }
         }
     }
-    msi_free(override);
+    free(override);
     return TRUE;
 }
 
@@ -1963,13 +1962,13 @@ static WCHAR *create_temp_dir( MSIDATABASE *db )
         if (!(db->tempfolder = wcsdup( tmp ))) return NULL;
     }
 
-    if ((ret = msi_alloc( (lstrlenW( db->tempfolder ) + 20) * sizeof(WCHAR) )))
+    if ((ret = malloc( (wcslen( db->tempfolder ) + 20) * sizeof(WCHAR) )))
     {
         for (;;)
         {
             if (!GetTempFileNameW( db->tempfolder, L"msi", ++id, ret ))
             {
-                msi_free( ret );
+                free( ret );
                 return NULL;
             }
             if (CreateDirectoryW( ret, NULL )) break;
@@ -2012,7 +2011,7 @@ WCHAR * WINAPIV msi_build_directory_name( DWORD count, ... )
     }
     va_end( va );
 
-    dir = msi_alloc( sz * sizeof(WCHAR) );
+    dir = malloc( sz * sizeof(WCHAR) );
     dir[0] = 0;
 
     va_start( va, count );
@@ -2034,7 +2033,7 @@ BOOL msi_is_global_assembly( MSICOMPONENT *comp )
 
 static void set_target_path( MSIPACKAGE *package, MSIFILE *file )
 {
-    msi_free( file->TargetPath );
+    free( file->TargetPath );
     if (msi_is_global_assembly( file->Component ))
     {
         MSIASSEMBLY *assembly = file->Component->assembly;
@@ -2086,7 +2085,7 @@ static UINT calculate_file_cost( MSIPACKAGE *package )
                 {
                     comp->Cost += file->FileSize - file_size;
                 }
-                msi_free( file_version );
+                free( file_version );
                 continue;
             }
             else if ((font_version = msi_get_font_file_version( package, file->TargetPath )))
@@ -2095,7 +2094,7 @@ static UINT calculate_file_cost( MSIPACKAGE *package )
                 {
                     comp->Cost += file->FileSize - file_size;
                 }
-                msi_free( font_version );
+                free( font_version );
                 continue;
             }
         }
@@ -2114,7 +2113,7 @@ WCHAR *msi_normalize_path( const WCHAR *in )
     WCHAR *q, *ret;
     int n, len = lstrlenW( in ) + 2;
 
-    if (!(q = ret = msi_alloc( len * sizeof(WCHAR) ))) return NULL;
+    if (!(q = ret = malloc( len * sizeof(WCHAR) ))) return NULL;
 
     len = 0;
     while (1)
@@ -2161,7 +2160,7 @@ static WCHAR *get_install_location( MSIPACKAGE *package )
     if (MSIREG_OpenInstallProps( package->ProductCode, package->Context, NULL, &hkey, FALSE )) return NULL;
     if ((path = msi_reg_get_val_str( hkey, L"InstallLocation" )) && !path[0])
     {
-        msi_free( path );
+        free( path );
         path = NULL;
     }
     RegCloseKey( hkey );
@@ -2199,9 +2198,9 @@ void msi_resolve_target_folder( MSIPACKAGE *package, const WCHAR *name, BOOL loa
 
     normalized_path = msi_normalize_path( path );
     msi_set_property( package->db, folder->Directory, normalized_path, -1 );
-    msi_free( path );
+    free( path );
 
-    msi_free( folder->ResolvedTarget );
+    free( folder->ResolvedTarget );
     folder->ResolvedTarget = normalized_path;
 
     LIST_FOR_EACH_ENTRY( fl, &folder->children, FolderList, entry )
@@ -2272,7 +2271,7 @@ static UINT ACTION_CostFinalize(MSIPACKAGE *package)
     /* set default run level if not set */
     level = msi_dup_property( package->db, L"INSTALLLEVEL" );
     if (!level) msi_set_property( package->db, L"INSTALLLEVEL", L"1", -1 );
-    msi_free(level);
+    free(level);
 
     if ((rc = MSI_SetFeatureStates( package ))) return rc;
 
@@ -2301,9 +2300,9 @@ static UINT ACTION_CostFinalize(MSIPACKAGE *package)
                 msi_set_property( package->db, L"PrimaryVolumeSpaceRemaining", buf, -1 );
                 msi_set_property( package->db, L"PrimaryVolumePath", primary_folder, 2 );
             }
-            msi_free( primary_folder );
+            free( primary_folder );
         }
-        msi_free( primary_key );
+        free( primary_key );
     }
 
     /* FIXME: check volume disk space */
@@ -2321,7 +2320,7 @@ static BYTE *parse_value( MSIPACKAGE *package, const WCHAR *value, DWORD len, DW
     {
         *size = sizeof(WCHAR);
         *type = REG_SZ;
-        if ((data = msi_alloc( *size ))) *(WCHAR *)data = 0;
+        if ((data = malloc( *size ))) *(WCHAR *)data = 0;
         return data;
     }
     if (value[0]=='#' && value[1]!='#' && value[1]!='%')
@@ -2343,7 +2342,7 @@ static BYTE *parse_value( MSIPACKAGE *package, const WCHAR *value, DWORD len, DW
             else
                 *size = lstrlenW(ptr)/2;
 
-            data = msi_alloc(*size);
+            data = malloc(*size);
 
             byte[0] = '0'; 
             byte[1] = 'x'; 
@@ -2368,7 +2367,7 @@ static BYTE *parse_value( MSIPACKAGE *package, const WCHAR *value, DWORD len, DW
                 data[count] = (BYTE)strtol(byte,NULL,0);
                 count ++;
             }
-            msi_free(deformated);
+            free(deformated);
 
             TRACE( "data %lu bytes(%u)\n", *size, count );
         }
@@ -2381,7 +2380,7 @@ static BYTE *parse_value( MSIPACKAGE *package, const WCHAR *value, DWORD len, DW
 
             *type=REG_DWORD; 
             *size = sizeof(DWORD);
-            data = msi_alloc(*size);
+            data = malloc(*size);
             p = deformated;
             if (*p == '-')
                 p++;
@@ -2398,7 +2397,7 @@ static BYTE *parse_value( MSIPACKAGE *package, const WCHAR *value, DWORD len, DW
             *(DWORD *)data = d;
             TRACE( "DWORD %lu\n", *(DWORD *)data);
 
-            msi_free(deformated);
+            free(deformated);
         }
     }
     else
@@ -2490,7 +2489,7 @@ static HKEY open_key( const MSICOMPONENT *comp, HKEY root, const WCHAR *path, BO
     if (res)
     {
         TRACE( "failed to open key %s (%ld)\n", debugstr_w(subkey), res );
-        msi_free( subkey );
+        free( subkey );
         return NULL;
     }
     if (q && q[1])
@@ -2499,7 +2498,7 @@ static HKEY open_key( const MSICOMPONENT *comp, HKEY root, const WCHAR *path, BO
         RegCloseKey( hkey );
     }
     else ret = hkey;
-    msi_free( subkey );
+    free( subkey );
     return ret;
 }
 
@@ -2521,14 +2520,14 @@ static WCHAR **split_multi_string_values( const WCHAR *str, DWORD len, DWORD *co
         p += lstrlenW( p ) + 1;
         (*count)++;
     }
-    if (!(ret = msi_alloc( *count * sizeof(WCHAR *) ))) return NULL;
+    if (!(ret = malloc( *count * sizeof(WCHAR *) ))) return NULL;
     p = str;
     while ((p - str) < len)
     {
         if (!(ret[i] = wcsdup( p )))
         {
-            for (; i >= 0; i--) msi_free( ret[i] );
-            msi_free( ret );
+            for (; i >= 0; i--) free( ret[i] );
+            free( ret );
             return NULL;
         }
         p += lstrlenW( p ) + 1;
@@ -2547,7 +2546,7 @@ static WCHAR *flatten_multi_string_values( WCHAR **left, DWORD left_count,
     for (i = 0; i < left_count; i++) *size += (lstrlenW( left[i] ) + 1) * sizeof(WCHAR);
     for (i = 0; i < right_count; i++) *size += (lstrlenW( right[i] ) + 1) * sizeof(WCHAR);
 
-    if (!(ret = p = msi_alloc( *size ))) return NULL;
+    if (!(ret = p = malloc( *size ))) return NULL;
 
     for (i = 0; i < left_count; i++)
     {
@@ -2575,7 +2574,7 @@ static DWORD remove_duplicate_values( WCHAR **old, DWORD old_count,
         {
             if (old[j] && !wcscmp( new[i], old[j] ))
             {
-                msi_free( old[j] );
+                free( old[j] );
                 for (k = j; k < old_count - 1; k++) { old[k] = old[k + 1]; }
                 old[k] = NULL;
                 ret--;
@@ -2654,10 +2653,10 @@ static BYTE *build_multi_string_value( BYTE *old_value, DWORD old_size,
         old = split_multi_string_values( old_ptr, old_len, &old_count );
     }
     ret = (BYTE *)join_multi_string_values( op, old, old_count, new, new_count, size );
-    for (i = 0; i < old_count; i++) msi_free( old[i] );
-    for (i = 0; i < new_count; i++) msi_free( new[i] );
-    msi_free( old );
-    msi_free( new );
+    for (i = 0; i < old_count; i++) free( old[i] );
+    for (i = 0; i < new_count; i++) free( new[i] );
+    free( old );
+    free( new );
     return ret;
 }
 
@@ -2665,7 +2664,7 @@ static BYTE *reg_get_value( HKEY hkey, const WCHAR *name, DWORD *type, DWORD *si
 {
     BYTE *ret;
     if (RegQueryValueExW( hkey, name, NULL, NULL, NULL, size )) return NULL;
-    if (!(ret = msi_alloc( *size ))) return NULL;
+    if (!(ret = malloc( *size ))) return NULL;
     RegQueryValueExW( hkey, name, NULL, type, ret, size );
     return ret;
 }
@@ -2716,23 +2715,23 @@ static UINT ITERATE_WriteRegistryValues(MSIRECORD *row, LPVOID param)
         return ERROR_SUCCESS;
 
     deformat_string(package, key , &deformated);
-    uikey = msi_alloc( (lstrlenW(deformated) + lstrlenW(szRoot) + 1) * sizeof(WCHAR) );
+    uikey = malloc( (wcslen(deformated) + wcslen(szRoot) + 1) * sizeof(WCHAR) );
     lstrcpyW(uikey,szRoot);
     lstrcatW(uikey,deformated);
 
     if (!(hkey = open_key( comp, root_key, deformated, TRUE, KEY_QUERY_VALUE | KEY_SET_VALUE )))
     {
         ERR("Could not create key %s\n", debugstr_w(deformated));
-        msi_free(uikey);
-        msi_free(deformated);
+        free(uikey);
+        free(deformated);
         return ERROR_FUNCTION_FAILED;
     }
-    msi_free( deformated );
+    free( deformated );
     str = msi_record_get_string( row, 5, NULL );
     len = deformat_string( package, str, &deformated );
     new_value = parse_value( package, deformated, len, &type, &new_size );
 
-    msi_free( deformated );
+    free( deformated );
     deformat_string(package, name, &deformated);
 
     if (!is_special_entry( name ))
@@ -2743,12 +2742,12 @@ static UINT ITERATE_WriteRegistryValues(MSIRECORD *row, LPVOID param)
             BYTE *new;
             if (old_value && old_type != REG_MULTI_SZ)
             {
-                msi_free( old_value );
+                free( old_value );
                 old_value = NULL;
                 old_size = 0;
             }
             new = build_multi_string_value( old_value, old_size, new_value, new_size, &new_size );
-            msi_free( new_value );
+            free( new_value );
             new_value = new;
         }
         if (!check_first)
@@ -2776,10 +2775,10 @@ static UINT ITERATE_WriteRegistryValues(MSIRECORD *row, LPVOID param)
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free(new_value);
-    msi_free(old_value);
-    msi_free(deformated);
-    msi_free(uikey);
+    free(new_value);
+    free(old_value);
+    free(deformated);
+    free(uikey);
 
     return ERROR_SUCCESS;
 }
@@ -2848,7 +2847,7 @@ static void delete_key( const MSICOMPONENT *comp, HKEY root, const WCHAR *path )
             break;
         }
     } while (p);
-    msi_free( subkey );
+    free( subkey );
 }
 
 static void delete_value( const MSICOMPONENT *comp, HKEY root, const WCHAR *path, const WCHAR *value )
@@ -2929,7 +2928,7 @@ static UINT ITERATE_RemoveRegistryValuesOnUninstall( MSIRECORD *row, LPVOID para
 
     deformat_string( package, key_str, &deformated_key );
     size = lstrlenW( deformated_key ) + lstrlenW( root_key_str ) + 1;
-    ui_key_str = msi_alloc( size * sizeof(WCHAR) );
+    ui_key_str = malloc( size * sizeof(WCHAR) );
     lstrcpyW( ui_key_str, root_key_str );
     lstrcatW( ui_key_str, deformated_key );
 
@@ -2937,7 +2936,7 @@ static UINT ITERATE_RemoveRegistryValuesOnUninstall( MSIRECORD *row, LPVOID para
 
     if (delete_key) delete_tree( comp, hkey_root, deformated_key );
     else delete_value( comp, hkey_root, deformated_key, deformated_name );
-    msi_free( deformated_key );
+    free( deformated_key );
 
     uirow = MSI_CreateRecord( 2 );
     MSI_RecordSetStringW( uirow, 1, ui_key_str );
@@ -2945,8 +2944,8 @@ static UINT ITERATE_RemoveRegistryValuesOnUninstall( MSIRECORD *row, LPVOID para
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free( ui_key_str );
-    msi_free( deformated_name );
+    free( ui_key_str );
+    free( deformated_name );
     return ERROR_SUCCESS;
 }
 
@@ -2992,7 +2991,7 @@ static UINT ITERATE_RemoveRegistryValuesOnInstall( MSIRECORD *row, LPVOID param
 
     deformat_string( package, key_str, &deformated_key );
     size = lstrlenW( deformated_key ) + lstrlenW( root_key_str ) + 1;
-    ui_key_str = msi_alloc( size * sizeof(WCHAR) );
+    ui_key_str = malloc( size * sizeof(WCHAR) );
     lstrcpyW( ui_key_str, root_key_str );
     lstrcatW( ui_key_str, deformated_key );
 
@@ -3000,7 +2999,7 @@ static UINT ITERATE_RemoveRegistryValuesOnInstall( MSIRECORD *row, LPVOID param
 
     if (delete_key) delete_tree( comp, hkey_root, deformated_key );
     else delete_value( comp, hkey_root, deformated_key, deformated_name );
-    msi_free( deformated_key );
+    free( deformated_key );
 
     uirow = MSI_CreateRecord( 2 );
     MSI_RecordSetStringW( uirow, 1, ui_key_str );
@@ -3008,8 +3007,8 @@ static UINT ITERATE_RemoveRegistryValuesOnInstall( MSIRECORD *row, LPVOID param
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free( ui_key_str );
-    msi_free( deformated_name );
+    free( ui_key_str );
+    free( deformated_name );
     return ERROR_SUCCESS;
 }
 
@@ -3099,7 +3098,7 @@ static UINT ITERATE_LaunchConditions(MSIRECORD *row, LPVOID param)
             message = MSI_RecordGetString(row, 2);
             deformat_string(package, message, &deformated);
             MessageBoxW(NULL, deformated, L"Install Failed", MB_OK);
-            msi_free(deformated);
+            free(deformated);
         }
 
         return ERROR_INSTALL_FAILURE;
@@ -3151,15 +3150,15 @@ static LPWSTR resolve_keypath( MSIPACKAGE* package, MSICOMPONENT *cmp )
         if (deformated_name)
             len+=lstrlenW(deformated_name);
 
-        buffer = msi_alloc( len *sizeof(WCHAR));
+        buffer = malloc(len * sizeof(WCHAR));
 
         if (deformated_name)
             swprintf(buffer, len, L"%02d:\\%s\\%s", root, deformated, deformated_name);
         else
             swprintf(buffer, len, L"%02d:\\%s\\", root, deformated);
 
-        msi_free(deformated);
-        msi_free(deformated_name);
+        free(deformated);
+        free(deformated_name);
         msiobj_release(&row->hdr);
 
         return buffer;
@@ -3279,7 +3278,7 @@ static WCHAR *build_full_keypath( MSIPACKAGE *package, MSICOMPONENT *comp )
     if (comp->assembly)
     {
         DWORD len = lstrlenW( L"<\\" ) + lstrlenW( comp->assembly->display_name );
-        WCHAR *keypath = msi_alloc( (len + 1) * sizeof(WCHAR) );
+        WCHAR *keypath = malloc( (len + 1) * sizeof(WCHAR) );
 
         if (keypath)
         {
@@ -3317,7 +3316,7 @@ static UINT ACTION_ProcessComponents(MSIPACKAGE *package)
             continue;
 
         squash_guid( comp->ComponentId, squashed_cc );
-        msi_free( comp->FullKeypath );
+        free( comp->FullKeypath );
         comp->FullKeypath = build_full_keypath( package, comp );
 
         refcount_component( package, comp );
@@ -3372,7 +3371,7 @@ static UINT ACTION_ProcessComponents(MSIPACKAGE *package)
                 sourcepath = msi_resolve_file_source(package, file);
                 ptr = sourcepath + lstrlenW(base);
                 lstrcpyW(ptr2, ptr);
-                msi_free(sourcepath);
+                free(sourcepath);
 
                 msi_reg_set_val_str( hkey, squashed_pc, source );
             }
@@ -3448,7 +3447,7 @@ static BOOL CALLBACK Typelib_EnumResNameProc( HMODULE hModule, LPCWSTR lpszType,
         tl_struct->path = wcsdup(tl_struct->source);
     else
     {
-        tl_struct->path = msi_alloc(sz * sizeof(WCHAR));
+        tl_struct->path = malloc(sz * sizeof(WCHAR));
         swprintf(tl_struct->path, sz, L"%s\\%d", tl_struct->source, lpszName);
     }
 
@@ -3456,7 +3455,7 @@ static BOOL CALLBACK Typelib_EnumResNameProc( HMODULE hModule, LPCWSTR lpszType,
     res = LoadTypeLib(tl_struct->path,&tl_struct->ptLib);
     if (FAILED(res))
     {
-        msi_free(tl_struct->path);
+        free(tl_struct->path);
         tl_struct->path = NULL;
 
         return TRUE;
@@ -3469,7 +3468,7 @@ static BOOL CALLBACK Typelib_EnumResNameProc( HMODULE hModule, LPCWSTR lpszType,
         return FALSE;
     }
 
-    msi_free(tl_struct->path);
+    free(tl_struct->path);
     tl_struct->path = NULL;
 
     ITypeLib_ReleaseTLibAttr(tl_struct->ptLib, attr);
@@ -3554,12 +3553,12 @@ static UINT ITERATE_RegisterTypeLibraries(MSIRECORD *row, LPVOID param)
                 TRACE("Registered %s\n", debugstr_w(tl_struct.path));
 
             ITypeLib_Release(tl_struct.ptLib);
-            msi_free(tl_struct.path);
+            free(tl_struct.path);
         }
         else ERR("Failed to load type library %s\n", debugstr_w(tl_struct.source));
 
         FreeLibrary(module);
-        msi_free(tl_struct.source);
+        free(tl_struct.source);
     }
     else
     {
@@ -3676,11 +3675,11 @@ static WCHAR *get_link_file( MSIPACKAGE *package, MSIRECORD *row )
     if (!extension || wcsicmp( extension, L".lnk" ))
     {
         int len = lstrlenW( filename );
-        filename = msi_realloc( filename, len * sizeof(WCHAR) + sizeof(L".lnk") );
+        filename = realloc( filename, len * sizeof(WCHAR) + sizeof(L".lnk") );
         memcpy( filename + len, L".lnk", sizeof(L".lnk") );
     }
     link_file = msi_build_directory_name( 2, link_folder, filename );
-    msi_free( filename );
+    free( filename );
 
     return link_file;
 }
@@ -3695,13 +3694,13 @@ WCHAR *msi_build_icon_path( MSIPACKAGE *package, const WCHAR *icon_name )
     {
         WCHAR *appdata = msi_dup_property( package->db, L"AppDataFolder" );
         folder = msi_build_directory_name( 2, appdata, L"Microsoft\\" );
-        msi_free( appdata );
+        free( appdata );
     }
     dest = msi_build_directory_name( 3, folder, L"Installer\\", package->ProductCode );
     msi_create_full_path( package, dest );
     path = msi_build_directory_name( 2, dest, icon_name );
-    msi_free( folder );
-    msi_free( dest );
+    free( folder );
+    free( dest );
     return path;
 }
 
@@ -3750,14 +3749,14 @@ static UINT ITERATE_CreateShortcuts(MSIRECORD *row, LPVOID param)
         deformat_string( package, target, &path );
         TRACE("target path is %s\n", debugstr_w(path));
         IShellLinkW_SetPath( sl, path );
-        msi_free( path );
+        free( path );
     }
     else
     {
         FIXME("poorly handled shortcut format, advertised shortcut\n");
         path = resolve_keypath( package, comp );
         IShellLinkW_SetPath( sl, path );
-        msi_free( path );
+        free( path );
     }
 
     if (!MSI_RecordIsNull(row,6))
@@ -3765,7 +3764,7 @@ static UINT ITERATE_CreateShortcuts(MSIRECORD *row, LPVOID param)
         LPCWSTR arguments = MSI_RecordGetString(row, 6);
         deformat_string(package, arguments, &deformated);
         IShellLinkW_SetArguments(sl,deformated);
-        msi_free(deformated);
+        free(deformated);
     }
 
     if (!MSI_RecordIsNull(row,7))
@@ -3790,7 +3789,7 @@ static UINT ITERATE_CreateShortcuts(MSIRECORD *row, LPVOID param)
             index = 0;
 
         IShellLinkW_SetIconLocation(sl, path, index);
-        msi_free(path);
+        free(path);
     }
 
     if (!MSI_RecordIsNull(row,11))
@@ -3810,7 +3809,7 @@ static UINT ITERATE_CreateShortcuts(MSIRECORD *row, LPVOID param)
     IPersistFile_Save(pf, link_file, FALSE);
     msi_revert_fs_redirection( package );
 
-    msi_free(link_file);
+    free(link_file);
 
 err:
     if (pf)
@@ -3866,7 +3865,7 @@ static UINT ITERATE_RemoveShortcuts( MSIRECORD *row, LPVOID param )
     link_file = get_link_file( package, row );
     TRACE("Removing shortcut file %s\n", debugstr_w( link_file ));
     if (!msi_delete_file( package, link_file )) WARN( "failed to remove shortcut file %lu\n", GetLastError() );
-    msi_free( link_file );
+    free( link_file );
 
     return ERROR_SUCCESS;
 }
@@ -3913,7 +3912,7 @@ static UINT ITERATE_PublishIcon(MSIRECORD *row, LPVOID param)
     if (handle == INVALID_HANDLE_VALUE)
     {
         ERR("Unable to create file %s\n", debugstr_w(icon_path));
-        msi_free( icon_path );
+        free( icon_path );
         return ERROR_SUCCESS;
     }
 
@@ -3931,7 +3930,7 @@ static UINT ITERATE_PublishIcon(MSIRECORD *row, LPVOID param)
         WriteFile( handle, buffer, sz, &count, NULL );
     } while (sz == 1024);
 
-    msi_free( icon_path );
+    free( icon_path );
     CloseHandle( handle );
 
     return ERROR_SUCCESS;
@@ -4014,7 +4013,7 @@ static UINT msi_publish_product_properties(MSIPACKAGE *package, HKEY hkey)
 
     buffer = msi_dup_property(package->db, INSTALLPROPERTY_PRODUCTNAMEW);
     msi_reg_set_val_str(hkey, INSTALLPROPERTY_PRODUCTNAMEW, buffer);
-    msi_free(buffer);
+    free(buffer);
 
     langid = msi_get_property_int(package->db, L"ProductLanguage", 0);
     msi_reg_set_val_dword(hkey, INSTALLPROPERTY_LANGUAGEW, langid);
@@ -4027,8 +4026,8 @@ static UINT msi_publish_product_properties(MSIPACKAGE *package, HKEY hkey)
     {
         LPWSTR path = msi_build_icon_path(package, buffer);
         msi_reg_set_val_str(hkey, INSTALLPROPERTY_PRODUCTICONW, path);
-        msi_free(path);
-        msi_free(buffer);
+        free(path);
+        free(buffer);
     }
 
     buffer = msi_dup_property(package->db, L"ProductVersion");
@@ -4036,7 +4035,7 @@ static UINT msi_publish_product_properties(MSIPACKAGE *package, HKEY hkey)
     {
         DWORD verdword = msi_version_str_to_dword(buffer);
         msi_reg_set_val_dword(hkey, INSTALLPROPERTY_VERSIONW, verdword);
-        msi_free(buffer);
+        free(buffer);
     }
 
     msi_reg_set_val_dword(hkey, L"Assignment", 0);
@@ -4047,7 +4046,7 @@ static UINT msi_publish_product_properties(MSIPACKAGE *package, HKEY hkey)
     if (!(guids = msi_get_package_code(package->db))) return ERROR_OUTOFMEMORY;
     if ((ptr = wcschr(guids, ';'))) *ptr = 0;
     squash_guid(guids, packcode);
-    msi_free( guids);
+    free(guids);
     msi_reg_set_val_str(hkey, INSTALLPROPERTY_PACKAGECODEW, packcode);
 
     return ERROR_SUCCESS;
@@ -4071,13 +4070,13 @@ static UINT msi_publish_upgrade_code(MSIPACKAGE *package)
     if (r != ERROR_SUCCESS)
     {
         WARN("failed to open upgrade code key\n");
-        msi_free(upgrade);
+        free(upgrade);
         return ERROR_SUCCESS;
     }
     squash_guid(package->ProductCode, squashed_pc);
     msi_reg_set_val_str(hkey, squashed_pc, NULL);
     RegCloseKey(hkey);
-    msi_free(upgrade);
+    free(upgrade);
     return ERROR_SUCCESS;
 }
 
@@ -4140,7 +4139,7 @@ static UINT msi_publish_patches( MSIPACKAGE *package )
         len += lstrlenW( patch_squashed ) + 1;
     }
 
-    p = all_patches = msi_alloc( (len + 1) * sizeof(WCHAR) );
+    p = all_patches = malloc( (len + 1) * sizeof(WCHAR) );
     if (!all_patches)
         goto done;
 
@@ -4207,7 +4206,7 @@ static UINT msi_publish_patches( MSIPACKAGE *package )
     RegCloseKey( product_patches_key );
     RegCloseKey( patches_key );
     RegCloseKey( product_key );
-    msi_free( all_patches );
+    free( all_patches );
     return r;
 }
 
@@ -4245,14 +4244,14 @@ static UINT ACTION_PublishProduct(MSIPACKAGE *package)
                 WCHAR packed[SQUASHED_GUID_SIZE];
 
                 squash_guid(guid, packed);
-                msi_free(guid);
+                free(guid);
                 if (!wcscmp(packed, package_code))
                 {
                     TRACE("re-publishing product - new package\n");
                     republish = TRUE;
                 }
             }
-            msi_free(package_code);
+            free(package_code);
         }
     }
 
@@ -4325,14 +4324,14 @@ static WCHAR *get_ini_file_name( MSIPACKAGE *package, MSIRECORD *row )
     if (!folder)
     {
         ERR("Unable to resolve folder %s\n", debugstr_w(dirprop));
-        msi_free( filename );
+        free( filename );
         return NULL;
     }
 
     ret = msi_build_directory_name( 2, folder, ptr );
 
-    msi_free( filename );
-    msi_free( folder );
+    free( filename );
+    free( folder );
     return ret;
 }
 
@@ -4403,10 +4402,10 @@ static UINT ITERATE_WriteIniValues(MSIRECORD *row, LPVOID param)
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free(fullname);
-    msi_free(deformated_key);
-    msi_free(deformated_value);
-    msi_free(deformated_section);
+    free(fullname);
+    free(deformated_key);
+    free(deformated_value);
+    free(deformated_section);
     return ERROR_SUCCESS;
 }
 
@@ -4469,7 +4468,7 @@ static UINT ITERATE_RemoveIniValuesOnUninstall( MSIRECORD *row, LPVOID param )
         {
             WARN( "unable to remove key %lu\n", GetLastError() );
         }
-        msi_free( filename );
+        free( filename );
     }
     else
         FIXME("Unsupported action %d\n", action);
@@ -4483,9 +4482,9 @@ static UINT ITERATE_RemoveIniValuesOnUninstall( MSIRECORD *row, LPVOID param )
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free( deformated_key );
-    msi_free( deformated_value );
-    msi_free( deformated_section );
+    free( deformated_key );
+    free( deformated_value );
+    free( deformated_section );
     return ERROR_SUCCESS;
 }
 
@@ -4531,7 +4530,7 @@ static UINT ITERATE_RemoveIniValuesOnInstall( MSIRECORD *row, LPVOID param )
         {
             WARN( "unable to remove key %lu\n", GetLastError() );
         }
-        msi_free( filename );
+        free( filename );
     }
     else
         FIXME("Unsupported action %d\n", action);
@@ -4544,9 +4543,9 @@ static UINT ITERATE_RemoveIniValuesOnInstall( MSIRECORD *row, LPVOID param )
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free( deformated_key );
-    msi_free( deformated_value );
-    msi_free( deformated_section );
+    free( deformated_key );
+    free( deformated_value );
+    free( deformated_section );
     return ERROR_SUCCESS;
 }
 
@@ -4585,7 +4584,7 @@ static void register_dll( const WCHAR *dll, BOOL unregister )
     STARTUPINFOW si;
     WCHAR *cmd;
 
-    if (!(cmd = msi_alloc( lstrlenW(dll) * sizeof(WCHAR) + sizeof(unregW) ))) return;
+    if (!(cmd = malloc( wcslen(dll) * sizeof(WCHAR) + sizeof(unregW) ))) return;
 
     if (unregister) swprintf( cmd, lstrlenW(dll) + ARRAY_SIZE(unregW), unregW, dll );
     else swprintf( cmd, lstrlenW(dll) + ARRAY_SIZE(unregW), regW, dll );
@@ -4597,7 +4596,7 @@ static void register_dll( const WCHAR *dll, BOOL unregister )
         msi_dialog_check_messages( pi.hProcess );
         CloseHandle( pi.hProcess );
     }
-    msi_free( cmd );
+    free( cmd );
 }
 
 static UINT ITERATE_SelfRegModules(MSIRECORD *row, LPVOID param)
@@ -4748,7 +4747,7 @@ static UINT ACTION_PublishFeatures(MSIPACKAGE *package)
         if (feature->Feature_Parent)
             size += lstrlenW( feature->Feature_Parent )+2;
 
-        data = msi_alloc(size * sizeof(WCHAR));
+        data = malloc(size * sizeof(WCHAR));
 
         data[0] = 0;
         LIST_FOR_EACH_ENTRY( cl, &feature->Components, ComponentList, entry )
@@ -4774,7 +4773,7 @@ static UINT ACTION_PublishFeatures(MSIPACKAGE *package)
         }
 
         msi_reg_set_val_str( userdata, feature->Feature, data );
-        msi_free(data);
+        free(data);
 
         size = 0;
         if (feature->Feature_Parent)
@@ -4788,14 +4787,14 @@ static UINT ACTION_PublishFeatures(MSIPACKAGE *package)
         else
         {
             size += 2*sizeof(WCHAR);
-            data = msi_alloc(size);
+            data = malloc(size);
             data[0] = 0x6;
             data[1] = 0;
             if (feature->Feature_Parent)
                 lstrcpyW( &data[1], feature->Feature_Parent );
             RegSetValueExW(hkey,feature->Feature,0,REG_SZ,
                        (LPBYTE)data,size);
-            msi_free(data);
+            free(data);
         }
 
         /* the UI chunk */
@@ -4893,7 +4892,7 @@ static UINT msi_publish_install_properties(MSIPACKAGE *package, HKEY hkey)
         key = *p++;
         val = msi_dup_property(package->db, prop);
         msi_reg_set_val_str(hkey, key, val);
-        msi_free(val);
+        free(val);
     }
 
     msi_reg_set_val_dword(hkey, L"WindowsInstaller", 1);
@@ -4922,7 +4921,7 @@ static UINT msi_publish_install_properties(MSIPACKAGE *package, HKEY hkey)
         size = deformat_string(package, fmt, &buffer) * sizeof(WCHAR);
         RegSetValueExW(hkey, L"ModifyPath", 0, REG_EXPAND_SZ, (LPBYTE)buffer, size);
         RegSetValueExW(hkey, L"UninstallString", 0, REG_EXPAND_SZ, (LPBYTE)buffer, size);
-        msi_free(buffer);
+        free(buffer);
     }
 
     /* FIXME: Write real Estimated Size when we have it */
@@ -4944,7 +4943,7 @@ static UINT msi_publish_install_properties(MSIPACKAGE *package, HKEY hkey)
         msi_reg_set_val_dword(hkey, INSTALLPROPERTY_VERSIONW, verdword);
         msi_reg_set_val_dword(hkey, INSTALLPROPERTY_VERSIONMAJORW, verdword >> 24);
         msi_reg_set_val_dword(hkey, INSTALLPROPERTY_VERSIONMINORW, (verdword >> 16) & 0xFF);
-        msi_free(buffer);
+        free(buffer);
     }
 
     return ERROR_SUCCESS;
@@ -4991,7 +4990,7 @@ static UINT ACTION_RegisterProduct(MSIPACKAGE *package)
             msi_reg_set_val_str( upgrade_key, squashed_pc, NULL );
             RegCloseKey( upgrade_key );
         }
-        msi_free( upgrade_code );
+        free( upgrade_code );
     }
     msi_reg_set_val_str( props, INSTALLPROPERTY_LOCALPACKAGEW, package->localfile );
     package->delete_on_close = FALSE;
@@ -5027,7 +5026,7 @@ static UINT ITERATE_UnpublishIcon( MSIRECORD *row, LPVOID param )
             *p = 0;
             msi_remove_directory( package, icon_path );
         }
-        msi_free( icon_path );
+        free( icon_path );
     }
     return ERROR_SUCCESS;
 }
@@ -5083,7 +5082,7 @@ static void remove_product_upgrade_code( MSIPACKAGE *package )
         if (!res && !count) MSIREG_DeleteClassesUpgradeCodesKey( code );
     }
 
-    msi_free( code );
+    free( code );
 }
 
 static UINT ACTION_UnpublishProduct(MSIPACKAGE *package)
@@ -5205,7 +5204,7 @@ static UINT ACTION_ResolveSource(MSIPACKAGE* package)
                 INSTALLPROPERTY_DISKPROMPTW,NULL,&size);
         if (rc == ERROR_MORE_DATA)
         {
-            prompt = msi_alloc(size * sizeof(WCHAR));
+            prompt = malloc(size * sizeof(WCHAR));
             MsiSourceListGetInfoW(package->ProductCode, NULL, 
                     package->Context, MSICODE_PRODUCT,
                     INSTALLPROPERTY_DISKPROMPTW,prompt,&size);
@@ -5216,7 +5215,7 @@ static UINT ACTION_ResolveSource(MSIPACKAGE* package)
         record = MSI_CreateRecord(2);
         MSI_RecordSetInteger(record, 1, MSIERR_INSERTDISK);
         MSI_RecordSetStringW(record, 2, prompt);
-        msi_free(prompt);
+        free(prompt);
         while(attrib == INVALID_FILE_ATTRIBUTES)
         {
             MSI_RecordSetStringW(record, 0, NULL);
@@ -5276,7 +5275,7 @@ static UINT ACTION_RegisterUser(MSIPACKAGE *package)
     {
         buffer = msi_dup_property( package->db, szPropKeys[i] );
         msi_reg_set_val_str( hkey, szRegKeys[i], buffer );
-        msi_free( buffer );
+        free( buffer );
     }
 
 end:
@@ -5285,7 +5284,7 @@ static UINT ACTION_RegisterUser(MSIPACKAGE *package)
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free(productid);
+    free(productid);
     RegCloseKey(hkey);
     return rc;
 }
@@ -5335,7 +5334,7 @@ static UINT ACTION_ExecuteAction(MSIPACKAGE *package)
         }
         info_template = msi_get_error_message(package->db, MSIERR_INFO_LOGGINGSTART);
         MSI_RecordSetStringW(uirow_info, 0, info_template);
-        msi_free(info_template);
+        free(info_template);
         MSI_ProcessMessage(package, INSTALLMESSAGE_INFO|MB_ICONHAND, uirow_info);
         msiobj_release(&uirow_info->hdr);
     }
@@ -5417,8 +5416,8 @@ static UINT ACTION_ExecuteAction(MSIPACKAGE *package)
     msiobj_release(&uirow->hdr);
 
 end:
-    msi_free(productname);
-    msi_free(action);
+    free(productname);
+    free(action);
     return rc;
 }
 
@@ -5457,7 +5456,7 @@ WCHAR *msi_create_component_advertise_string( MSIPACKAGE *package, MSICOMPONENT
           debugstr_w(component_85));
 
     sz = 20 + lstrlenW( feature ) + 20 + 3;
-    ret = msi_alloc_zero( sz * sizeof(WCHAR) );
+    ret = calloc( 1, sz * sizeof(WCHAR) );
     if (ret) swprintf( ret, sz, L"%s%s%c%s", productid_85, feature, component ? '>' : '<', component_85 );
     return ret;
 }
@@ -5505,10 +5504,10 @@ static UINT ITERATE_PublishComponent(MSIRECORD *rec, LPVOID param)
     text = MSI_RecordGetString( rec, 4 );
     if (text)
     {
-        p = msi_alloc( (lstrlenW( advertise ) + lstrlenW( text ) + 1) * sizeof(WCHAR) );
+        p = malloc( (wcslen( advertise ) + wcslen( text ) + 1) * sizeof(WCHAR) );
         lstrcpyW( p, advertise );
         lstrcatW( p, text );
-        msi_free( advertise );
+        free( advertise );
         advertise = p;
     }
     existing = msi_reg_get_val_str( hkey, qualifier );
@@ -5522,7 +5521,7 @@ static UINT ITERATE_PublishComponent(MSIRECORD *rec, LPVOID param)
             if (wcscmp( advertise, p )) sz += len;
         }
     }
-    if (!(output = msi_alloc( (sz + 1) * sizeof(WCHAR) )))
+    if (!(output = malloc( (sz + 1) * sizeof(WCHAR) )))
     {
         rc = ERROR_OUTOFMEMORY;
         goto end;
@@ -5547,9 +5546,9 @@ static UINT ITERATE_PublishComponent(MSIRECORD *rec, LPVOID param)
     
 end:
     RegCloseKey(hkey);
-    msi_free( output );
-    msi_free( advertise );
-    msi_free( existing );
+    free( output );
+    free( advertise );
+    free( existing );
 
     /* the UI chunk */
     uirow = MSI_CreateRecord( 2 );
@@ -5730,7 +5729,7 @@ static UINT ITERATE_InstallService(MSIRECORD *rec, LPVOID param)
     else
     {
         int len = lstrlenW(file->TargetPath) + lstrlenW(args) + 2;
-        if (!(image_path = msi_alloc(len * sizeof(WCHAR))))
+        if (!(image_path = malloc(len * sizeof(WCHAR))))
         {
             ret = ERROR_OUTOFMEMORY;
             goto done;
@@ -5760,18 +5759,18 @@ static UINT ITERATE_InstallService(MSIRECORD *rec, LPVOID param)
             WARN( "failed to set service description %lu\n", GetLastError() );
     }
 
-    if (image_path != file->TargetPath) msi_free(image_path);
+    if (image_path != file->TargetPath) free(image_path);
 done:
     if (service) CloseServiceHandle(service);
     if (hscm) CloseServiceHandle(hscm);
-    msi_free(name);
-    msi_free(disp);
-    msi_free(sd.lpDescription);
-    msi_free(load_order);
-    msi_free(serv_name);
-    msi_free(pass);
-    msi_free(depends);
-    msi_free(args);
+    free(name);
+    free(disp);
+    free(sd.lpDescription);
+    free(load_order);
+    free(serv_name);
+    free(pass);
+    free(depends);
+    free(args);
 
     return ret;
 }
@@ -5806,7 +5805,7 @@ static LPCWSTR *msi_service_args_to_vector(LPWSTR args, DWORD *numargs)
     if (!args)
         return NULL;
 
-    vector = msi_alloc(sizeof(LPWSTR));
+    vector = malloc(sizeof(WCHAR *));
     if (!vector)
         return NULL;
 
@@ -5820,10 +5819,10 @@ static LPCWSTR *msi_service_args_to_vector(LPWSTR args, DWORD *numargs)
         {
             *q = '\0';
 
-            temp_vector = msi_realloc(vector, (*numargs + 1) * sizeof(LPWSTR));
+            temp_vector = realloc(vector, (*numargs + 1) * sizeof(WCHAR *));
             if (!temp_vector)
             {
-                msi_free(vector);
+                free(vector);
                 return NULL;
             }
             vector = temp_vector;
@@ -5861,7 +5860,7 @@ static UINT ITERATE_StartService(MSIRECORD *rec, LPVOID param)
         !(comp->Action == INSTALLSTATE_ABSENT && (event & msidbServiceControlEventUninstallStart)))
     {
         TRACE("not starting %s\n", debugstr_w(name));
-        msi_free( name );
+        free(name);
         return ERROR_SUCCESS;
     }
 
@@ -5879,7 +5878,7 @@ static UINT ITERATE_StartService(MSIRECORD *rec, LPVOID param)
     if (!GetServiceDisplayNameW( scm, name, NULL, &len ) &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER)
     {
-        if ((display_name = msi_alloc( ++len * sizeof(WCHAR ))))
+        if ((display_name = malloc(++len * sizeof(WCHAR))))
             GetServiceDisplayNameW( scm, name, display_name, &len );
     }
 
@@ -5938,10 +5937,10 @@ static UINT ITERATE_StartService(MSIRECORD *rec, LPVOID param)
     if (service) CloseServiceHandle(service);
     if (scm) CloseServiceHandle(scm);
 
-    msi_free(name);
-    msi_free(args);
-    msi_free(vector);
-    msi_free(display_name);
+    free(name);
+    free(args);
+    free(vector);
+    free(display_name);
     return r;
 }
 
@@ -5977,7 +5976,7 @@ static BOOL stop_service_dependents(SC_HANDLE scm, SC_HANDLE service)
     if (GetLastError() != ERROR_MORE_DATA)
         return FALSE;
 
-    dependencies = msi_alloc(needed);
+    dependencies = malloc(needed);
     if (!dependencies)
         return FALSE;
 
@@ -6001,7 +6000,7 @@ static BOOL stop_service_dependents(SC_HANDLE scm, SC_HANDLE service)
     ret = TRUE;
 
 done:
-    msi_free(dependencies);
+    free(dependencies);
     return ret;
 }
 
@@ -6070,7 +6069,7 @@ static UINT ITERATE_StopService( MSIRECORD *rec, LPVOID param )
         !(comp->Action == INSTALLSTATE_ABSENT && (event & msidbServiceControlEventUninstallStop)))
     {
         TRACE("not stopping %s\n", debugstr_w(name));
-        msi_free( name );
+        free( name );
         return ERROR_SUCCESS;
     }
 
@@ -6085,7 +6084,7 @@ static UINT ITERATE_StopService( MSIRECORD *rec, LPVOID param )
     if (!GetServiceDisplayNameW( scm, name, NULL, &len ) &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER)
     {
-        if ((display_name = msi_alloc( ++len * sizeof(WCHAR ))))
+        if ((display_name = malloc( ++len * sizeof(WCHAR ))))
             GetServiceDisplayNameW( scm, name, display_name, &len );
     }
     CloseServiceHandle( scm );
@@ -6099,8 +6098,8 @@ static UINT ITERATE_StopService( MSIRECORD *rec, LPVOID param )
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free( name );
-    msi_free( display_name );
+    free( name );
+    free( display_name );
     return ERROR_SUCCESS;
 }
 
@@ -6142,7 +6141,7 @@ static UINT ITERATE_DeleteService( MSIRECORD *rec, LPVOID param )
         !(comp->Action == INSTALLSTATE_ABSENT && (event & msidbServiceControlEventUninstallDelete)))
     {
         TRACE("service %s not scheduled for removal\n", debugstr_w(name));
-        msi_free( name );
+        free( name );
         return ERROR_SUCCESS;
     }
     stop_service( name );
@@ -6158,7 +6157,7 @@ static UINT ITERATE_DeleteService( MSIRECORD *rec, LPVOID param )
     if (!GetServiceDisplayNameW( scm, name, NULL, &len ) &&
         GetLastError() == ERROR_INSUFFICIENT_BUFFER)
     {
-        if ((display_name = msi_alloc( ++len * sizeof(WCHAR ))))
+        if ((display_name = malloc( ++len * sizeof(WCHAR ))))
             GetServiceDisplayNameW( scm, name, display_name, &len );
     }
 
@@ -6181,8 +6180,8 @@ static UINT ITERATE_DeleteService( MSIRECORD *rec, LPVOID param )
 
     if (service) CloseServiceHandle( service );
     if (scm) CloseServiceHandle( scm );
-    msi_free( name );
-    msi_free( display_name );
+    free( name );
+    free( display_name );
 
     return ERROR_SUCCESS;
 }
@@ -6246,7 +6245,7 @@ static UINT ITERATE_InstallODBCDriver( MSIRECORD *rec, LPVOID param )
         len += lstrlenW(L"Setup=%s") + lstrlenW(setup_file->FileName);
     len += lstrlenW(L"FileUsage=1") + 2; /* \0\0 */
 
-    driver = msi_alloc(len * sizeof(WCHAR));
+    driver = malloc(len * sizeof(WCHAR));
     if (!driver)
         return ERROR_OUTOFMEMORY;
 
@@ -6290,8 +6289,8 @@ static UINT ITERATE_InstallODBCDriver( MSIRECORD *rec, LPVOID param )
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free(driver);
-    msi_free(driver_path);
+    free(driver);
+    free(driver_path);
 
     return r;
 }
@@ -6337,7 +6336,7 @@ static UINT ITERATE_InstallODBCTranslator( MSIRECORD *rec, LPVOID param )
     if (setup_file)
         len += lstrlenW(L"Setup=%s") + lstrlenW(setup_file->FileName);
 
-    translator = msi_alloc(len * sizeof(WCHAR));
+    translator = malloc(len * sizeof(WCHAR));
     if (!translator)
         return ERROR_OUTOFMEMORY;
 
@@ -6373,8 +6372,8 @@ static UINT ITERATE_InstallODBCTranslator( MSIRECORD *rec, LPVOID param )
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free(translator);
-    msi_free(translator_path);
+    free(translator);
+    free(translator_path);
 
     return r;
 }
@@ -6411,7 +6410,7 @@ static UINT ITERATE_InstallODBCDataSource( MSIRECORD *rec, LPVOID param )
     else if (registration == msidbODBCDataSourceRegistrationPerUser) request = ODBC_ADD_DSN;
 
     len = lstrlenW(L"DSN=%s") + lstrlenW(desc) + 2; /* \0\0 */
-    attrs = msi_alloc(len * sizeof(WCHAR));
+    attrs = malloc(len * sizeof(WCHAR));
     if (!attrs)
         return ERROR_OUTOFMEMORY;
 
@@ -6428,7 +6427,7 @@ static UINT ITERATE_InstallODBCDataSource( MSIRECORD *rec, LPVOID param )
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free(attrs);
+    free(attrs);
 
     return r;
 }
@@ -6577,7 +6576,7 @@ static UINT ITERATE_RemoveODBCDataSource( MSIRECORD *rec, LPVOID param )
     else if (registration == msidbODBCDataSourceRegistrationPerUser) request = ODBC_REMOVE_DSN;
 
     len = lstrlenW( L"DSN=%s" ) + lstrlenW( desc ) + 2; /* \0\0 */
-    attrs = msi_alloc( len * sizeof(WCHAR) );
+    attrs = malloc( len * sizeof(WCHAR) );
     if (!attrs)
         return ERROR_OUTOFMEMORY;
 
@@ -6590,7 +6589,7 @@ static UINT ITERATE_RemoveODBCDataSource( MSIRECORD *rec, LPVOID param )
     {
         WARN("Failed to remove ODBC data source\n");
     }
-    msi_free( attrs );
+    free( attrs );
 
     uirow = MSI_CreateRecord( 3 );
     MSI_RecordSetStringW( uirow, 1, desc );
@@ -6859,9 +6858,9 @@ static UINT ITERATE_WriteEnvironmentString( MSIRECORD *rec, LPVOID param )
             goto done;
         }
 
-        if (!(p = q = data = msi_alloc( size )))
+        if (!(p = q = data = malloc( size )))
         {
-            msi_free(deformatted);
+            free(deformatted);
             RegCloseKey(env);
             return ERROR_OUTOFMEMORY;
         }
@@ -6900,7 +6899,7 @@ static UINT ITERATE_WriteEnvironmentString( MSIRECORD *rec, LPVOID param )
         }
 
         size = (len_value + 1 + lstrlenW( data ) + 1) * sizeof(WCHAR);
-        if (!(p = newval = msi_alloc( size )))
+        if (!(p = newval = malloc( size )))
         {
             res = ERROR_OUTOFMEMORY;
             goto done;
@@ -6940,9 +6939,9 @@ static UINT ITERATE_WriteEnvironmentString( MSIRECORD *rec, LPVOID param )
     msiobj_release( &uirow->hdr );
 
     if (env) RegCloseKey(env);
-    msi_free(deformatted);
-    msi_free(data);
-    msi_free(newval);
+    free(deformatted);
+    free(data);
+    free(newval);
     return res;
 }
 
@@ -7048,7 +7047,7 @@ static UINT ITERATE_RemoveEnvironmentString( MSIRECORD *rec, LPVOID param )
     if (res != ERROR_SUCCESS || (type != REG_SZ && type != REG_EXPAND_SZ))
         goto done;
 
-    if (!(new_value = msi_alloc( size ))) goto done;
+    if (!(new_value = malloc( size ))) goto done;
 
     res = RegQueryValueExW( env, name, NULL, &type, (BYTE *)new_value, &size );
     if (res != ERROR_SUCCESS)
@@ -7095,8 +7094,8 @@ static UINT ITERATE_RemoveEnvironmentString( MSIRECORD *rec, LPVOID param )
     msiobj_release( &uirow->hdr );
 
     if (env) RegCloseKey( env );
-    msi_free( deformatted );
-    msi_free( new_value );
+    free( deformatted );
+    free( new_value );
     return r;
 }
 
@@ -7125,7 +7124,7 @@ UINT msi_validate_product_id( MSIPACKAGE *package )
     id = msi_dup_property( package->db, L"ProductID" );
     if (id)
     {
-        msi_free( id );
+        free( id );
         return ERROR_SUCCESS;
     }
     template = msi_dup_property( package->db, L"PIDTemplate" );
@@ -7135,8 +7134,8 @@ UINT msi_validate_product_id( MSIPACKAGE *package )
         FIXME( "partial stub: template %s key %s\n", debugstr_w(template), debugstr_w(key) );
         r = msi_set_property( package->db, L"ProductID", key, -1 );
     }
-    msi_free( template );
-    msi_free( key );
+    free( template );
+    free( key );
     return r;
 }
 
@@ -7232,19 +7231,19 @@ static UINT ITERATE_RemoveExistingProducts( MSIRECORD *rec, LPVOID param )
     else
         len += ARRAY_SIZE( L"ALL" );
 
-    if (!(cmd = msi_alloc( len * sizeof(WCHAR) )))
+    if (!(cmd = malloc( len * sizeof(WCHAR) )))
     {
-        msi_free( product );
-        msi_free( features );
+        free( product );
+        free( features );
         return ERROR_OUTOFMEMORY;
     }
     swprintf( cmd, len, L"msiexec /qn /i %s REMOVE=%s", product, features ? features : L"ALL" );
-    msi_free( product );
-    msi_free( features );
+    free( product );
+    free( features );
 
     memset( &si, 0, sizeof(STARTUPINFOW) );
     ret = CreateProcessW( NULL, cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &info );
-    msi_free( cmd );
+    free( cmd );
     if (!ret) return GetLastError();
     CloseHandle( info.hThread );
 
@@ -7374,13 +7373,13 @@ static UINT ITERATE_BindImage( MSIRECORD *rec, LPVOID param )
             if ((pathA = strdupWtoA( pathW )))
             {
                 bind_image( package, filenameA, pathA );
-                msi_free( pathA );
+                free( pathA );
             }
-            msi_free( pathW );
+            free( pathW );
         }
     }
-    msi_free( path_list );
-    msi_free( filenameA );
+    free( path_list );
+    free( filenameA );
 
     return ERROR_SUCCESS;
 }
@@ -7660,24 +7659,24 @@ UINT MSI_InstallPackage( MSIPACKAGE *package, LPCWSTR szPackagePath,
         }
         else
         {
-            msi_free(dir);
-            dir = msi_alloc(MAX_PATH * sizeof(WCHAR));
+            free(dir);
+            dir = malloc(MAX_PATH * sizeof(WCHAR));
             GetCurrentDirectoryW(MAX_PATH, dir);
             lstrcatW(dir, L"\\");
             file = szPackagePath;
         }
 
-        msi_free( package->PackagePath );
-        package->PackagePath = msi_alloc((lstrlenW(dir) + lstrlenW(file) + 1) * sizeof(WCHAR));
+        free(package->PackagePath);
+        package->PackagePath = malloc((wcslen(dir) + wcslen(file) + 1) * sizeof(WCHAR));
         if (!package->PackagePath)
         {
-            msi_free(dir);
+            free(dir);
             return ERROR_OUTOFMEMORY;
         }
 
         lstrcpyW(package->PackagePath, dir);
         lstrcatW(package->PackagePath, file);
-        msi_free(dir);
+        free(dir);
 
         msi_set_sourcedir_props(package, FALSE);
     }
@@ -7703,10 +7702,10 @@ UINT MSI_InstallPackage( MSIPACKAGE *package, LPCWSTR szPackagePath,
     if (wcsicmp( productcode, package->ProductCode ))
     {
         TRACE( "product code changed %s -> %s\n", debugstr_w(package->ProductCode), debugstr_w(productcode) );
-        msi_free( package->ProductCode );
+        free( package->ProductCode );
         package->ProductCode = productcode;
     }
-    else msi_free( productcode );
+    else free( productcode );
 
     if (msi_get_property_int( package->db, L"DISABLEROLLBACK", 0 ))
     {
@@ -7740,8 +7739,8 @@ UINT MSI_InstallPackage( MSIPACKAGE *package, LPCWSTR szPackagePath,
         WARN("installation failed, running rollback script\n");
         execute_script( package, SCRIPT_ROLLBACK );
     }
-    msi_free( reinstall );
-    msi_free( action );
+    free( reinstall );
+    free( action );
 
     if (rc == ERROR_SUCCESS && package->need_reboot_at_end)
         return ERROR_SUCCESS_REBOOT_REQUIRED;
diff --git a/dlls/msi/alter.c b/dlls/msi/alter.c
index 7d272118537f..00ba4fce5909 100644
--- a/dlls/msi/alter.c
+++ b/dlls/msi/alter.c
@@ -129,7 +129,7 @@ static UINT ALTER_delete( struct tagMSIVIEW *view )
     TRACE("%p\n", av );
     if (av->table)
         av->table->ops->delete( av->table );
-    msi_free( av );
+    free( av );
 
     return ERROR_SUCCESS;
 }
@@ -164,14 +164,14 @@ UINT ALTER_CreateView( MSIDATABASE *db, MSIVIEW **view, LPCWSTR name, column_inf
 
     TRACE("%p %p %s %d\n", view, colinfo, debugstr_w(name), hold );
 
-    av = msi_alloc_zero( sizeof *av );
+    av = calloc( 1, sizeof *av );
     if( !av )
         return ERROR_FUNCTION_FAILED;
 
     r = TABLE_CreateView( db, name, &av->table );
     if (r != ERROR_SUCCESS)
     {
-        msi_free( av );
+        free( av );
         return r;
     }
 
diff --git a/dlls/msi/appsearch.c b/dlls/msi/appsearch.c
index 1c5113ba4eaa..9693fc92833a 100644
--- a/dlls/msi/appsearch.c
+++ b/dlls/msi/appsearch.c
@@ -109,13 +109,13 @@ static UINT get_signature( MSIPACKAGE *package, MSISIGNATURE *sig, const WCHAR *
     if (minVersion)
     {
         msi_parse_version_string( minVersion, &sig->MinVersionMS, &sig->MinVersionLS );
-        msi_free( minVersion );
+        free( minVersion );
     }
     maxVersion = msi_dup_record_field(row,4);
     if (maxVersion)
     {
         msi_parse_version_string( maxVersion, &sig->MaxVersionMS, &sig->MaxVersionLS );
-        msi_free( maxVersion );
+        free( maxVersion );
     }
     sig->MinSize = MSI_RecordGetInteger(row,5);
     if (sig->MinSize == MSI_NULL_INTEGER)
@@ -150,8 +150,8 @@ static UINT get_signature( MSIPACKAGE *package, MSISIGNATURE *sig, const WCHAR *
 /* Frees any memory allocated in sig */
 static void free_signature( MSISIGNATURE *sig )
 {
-    msi_free(sig->File);
-    msi_free(sig->Languages);
+    free(sig->File);
+    free(sig->Languages);
 }
 
 static WCHAR *search_file( MSIPACKAGE *package, WCHAR *path, MSISIGNATURE *sig )
@@ -182,7 +182,7 @@ static WCHAR *search_file( MSIPACKAGE *package, WCHAR *path, MSISIGNATURE *sig )
     if (!size)
         return wcsdup(path);
 
-    buffer = msi_alloc(size);
+    buffer = malloc(size);
     if (!buffer)
         return NULL;
 
@@ -216,7 +216,7 @@ static WCHAR *search_file( MSIPACKAGE *package, WCHAR *path, MSISIGNATURE *sig )
     val = wcsdup(path);
 
 done:
-    msi_free(buffer);
+    free(buffer);
     return val;
 }
 
@@ -305,13 +305,13 @@ static void convert_reg_value( DWORD regType, const BYTE *value, DWORD sz, WCHAR
             if (*(LPCWSTR)value == '#')
             {
                 /* escape leading pound with another */
-                *appValue = msi_alloc(sz + sizeof(WCHAR));
+                *appValue = malloc(sz + sizeof(WCHAR));
                 (*appValue)[0] = '#';
                 lstrcpyW(*appValue + 1, (LPCWSTR)value);
             }
             else
             {
-                *appValue = msi_alloc(sz);
+                *appValue = malloc(sz);
                 lstrcpyW(*appValue, (LPCWSTR)value);
             }
             break;
@@ -319,17 +319,17 @@ static void convert_reg_value( DWORD regType, const BYTE *value, DWORD sz, WCHAR
             /* 7 chars for digits, 1 for NULL, 1 for #, and 1 for sign
              * char if needed
              */
-            *appValue = msi_alloc(10 * sizeof(WCHAR));
+            *appValue = malloc(10 * sizeof(WCHAR));
             swprintf(*appValue, 10, L"#%d", *(const DWORD *)value);
             break;
         case REG_EXPAND_SZ:
             sz = ExpandEnvironmentStringsW((LPCWSTR)value, NULL, 0);
-            *appValue = msi_alloc(sz * sizeof(WCHAR));
+            *appValue = malloc(sz * sizeof(WCHAR));
             ExpandEnvironmentStringsW((LPCWSTR)value, *appValue, sz);
             break;
         case REG_BINARY:
             /* #x<nibbles>\0 */
-            *appValue = msi_alloc((sz * 2 + 3) * sizeof(WCHAR));
+            *appValue = malloc((sz * 2 + 3) * sizeof(WCHAR));
             lstrcpyW(*appValue, L"#x");
             ptr = *appValue + lstrlenW(L"#x");
             for (i = 0; i < sz; i++, ptr += 2)
@@ -401,7 +401,7 @@ static UINT search_reg( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig
         goto end;
     }
 
-    msi_free(deformatted);
+    free(deformatted);
     deformat_string(package, valueName, &deformatted);
 
     rc = RegQueryValueExW(key, deformatted, NULL, NULL, NULL, &sz);
@@ -413,7 +413,7 @@ static UINT search_reg( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig
     /* FIXME: sanity-check sz before allocating (is there an upper-limit
      * on the value of a property?)
      */
-    value = msi_alloc( sz );
+    value = malloc(sz);
     rc = RegQueryValueExW(key, deformatted, NULL, &regType, value, &sz);
     if (rc)
     {
@@ -431,9 +431,9 @@ static UINT search_reg( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig
         sz = ExpandEnvironmentStringsW((LPCWSTR)value, NULL, 0);
         if (sz)
         {
-            LPWSTR buf = msi_alloc(sz * sizeof(WCHAR));
+            WCHAR *buf = malloc(sz * sizeof(WCHAR));
             ExpandEnvironmentStringsW((LPCWSTR)value, buf, sz);
-            msi_free(value);
+            free(value);
             value = (LPBYTE)buf;
         }
     }
@@ -460,9 +460,9 @@ static UINT search_reg( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig
               type, debugstr_w(keyPath), debugstr_w(valueName));
     }
 end:
-    msi_free( value );
+    free( value );
     RegCloseKey( key );
-    msi_free( deformatted );
+    free( deformatted );
 
     msiobj_release(&row->hdr);
     return ERROR_SUCCESS;
@@ -539,9 +539,9 @@ static UINT search_ini( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig
         }
     }
 
-    msi_free(fileName);
-    msi_free(section);
-    msi_free(key);
+    free(fileName);
+    free(section);
+    free(key);
 
     msiobj_release(&row->hdr);
 
@@ -578,13 +578,13 @@ static void expand_any_path( MSIPACKAGE *package, WCHAR *src, WCHAR *dst, size_t
     deformat_string(package, ptr, &deformatted);
     if (!deformatted || lstrlenW(deformatted) > len - 1)
     {
-        msi_free(deformatted);
+        free(deformatted);
         return;
     }
 
     lstrcpyW(dst, deformatted);
     dst[lstrlenW(deformatted)] = '\0';
-    msi_free(deformatted);
+    free(deformatted);
 }
 
 static LANGID *parse_languages( const WCHAR *languages, DWORD *num_ids )
@@ -596,9 +596,9 @@ static LANGID *parse_languages( const WCHAR *languages, DWORD *num_ids )
     if (!str) return NULL;
     for (p = q = str; (q = wcschr( q, ',' )); q++) count++;
 
-    if (!(ret = msi_alloc( count * sizeof(LANGID) )))
+    if (!(ret = malloc( count * sizeof(LANGID) )))
     {
-        msi_free( str );
+        free( str );
         return NULL;
     }
     i = 0;
@@ -611,7 +611,7 @@ static LANGID *parse_languages( const WCHAR *languages, DWORD *num_ids )
         p = q + 1;
         i++;
     }
-    msi_free( str );
+    free( str );
     *num_ids = count;
     return ret;
 }
@@ -643,7 +643,7 @@ static BOOL match_languages( const void *version, const WCHAR *languages )
     }
 
 done:
-    msi_free( ids );
+    free( ids );
     return found;
 }
 
@@ -663,7 +663,7 @@ static UINT file_version_matches( MSIPACKAGE *package, const MSISIGNATURE *sig,
     *matches = FALSE;
 
     if (!size) return ERROR_SUCCESS;
-    if (!(version = msi_alloc( size ))) return ERROR_OUTOFMEMORY;
+    if (!(version = malloc( size ))) return ERROR_OUTOFMEMORY;
 
     if (msi_get_file_version_info( package, filePath, size, version ))
         VerQueryValueW( version, L"\\", (void **)&info, &len );
@@ -702,7 +702,7 @@ static UINT file_version_matches( MSIPACKAGE *package, const MSISIGNATURE *sig,
         }
         else *matches = TRUE;
     }
-    msi_free( version );
+    free( version );
     return ERROR_SUCCESS;
 }
 
@@ -779,7 +779,7 @@ static UINT recurse_search_directory( MSIPACKAGE *package, WCHAR **appValue, MSI
      * isn't backslash-terminated.
      */
     len = dirLen + max(fileLen, lstrlenW(L"*.*")) + 2;
-    buf = msi_alloc(len * sizeof(WCHAR));
+    buf = malloc(len * sizeof(WCHAR));
     if (!buf)
         return ERROR_OUTOFMEMORY;
 
@@ -839,7 +839,7 @@ static UINT recurse_search_directory( MSIPACKAGE *package, WCHAR **appValue, MSI
     }
 
     if (*appValue != buf)
-        msi_free(buf);
+        free(buf);
 
     return rc;
 }
@@ -920,7 +920,7 @@ static UINT search_directory( MSIPACKAGE *package, MSISIGNATURE *sig, const WCHA
     if (attr != INVALID_FILE_ATTRIBUTES && (attr & FILE_ATTRIBUTE_DIRECTORY) &&
         val && val[lstrlenW(val) - 1] != '\\')
     {
-        val = msi_realloc(val, (lstrlenW(val) + 2) * sizeof(WCHAR));
+        val = realloc(val, (wcslen(val) + 2) * sizeof(WCHAR));
         if (!val)
             rc = ERROR_OUTOFMEMORY;
         else
@@ -1004,7 +1004,7 @@ static UINT search_dr( MSIPACKAGE *package, WCHAR **appValue, MSISIGNATURE *sig
 
     rc = search_directory( package, sig, path, depth, appValue );
 
-    msi_free(parent);
+    free(parent);
     msiobj_release(&row->hdr);
     TRACE("returning %d\n", rc);
     return rc;
@@ -1055,7 +1055,7 @@ static UINT ITERATE_AppSearch(MSIRECORD *row, LPVOID param)
         if (r == ERROR_SUCCESS && !wcscmp( propName, L"SourceDir" ))
             msi_reset_source_folders( package );
 
-        msi_free(value);
+        free(value);
     }
     free_signature( &sig );
 
@@ -1107,7 +1107,7 @@ static UINT ITERATE_CCPSearch(MSIRECORD *row, LPVOID param)
     {
         TRACE("Found signature %s\n", debugstr_w(signature));
         msi_set_property( package->db, L"CCP_Success", L"1", -1 );
-        msi_free(value);
+        free(value);
         r = ERROR_NO_MORE_ITEMS;
     }
 
diff --git a/dlls/msi/assembly.c b/dlls/msi/assembly.c
index 670b0112a0c9..7f75d225be06 100644
--- a/dlls/msi/assembly.c
+++ b/dlls/msi/assembly.c
@@ -164,7 +164,7 @@ static UINT get_assembly_name_attribute( MSIRECORD *rec, LPVOID param )
     const WCHAR *value = MSI_RecordGetString( rec, 3 );
     int len = lstrlenW( L"%s=\"%s\"" ) + lstrlenW( attr ) + lstrlenW( value );
 
-    if (!(name->attrs[name->index] = msi_alloc( len * sizeof(WCHAR) )))
+    if (!(name->attrs[name->index] = malloc( len * sizeof(WCHAR) )))
         return ERROR_OUTOFMEMORY;
 
     if (!wcsicmp( attr, L"name" )) lstrcpyW( name->attrs[name->index++], value );
@@ -190,7 +190,7 @@ static WCHAR *get_assembly_display_name( MSIDATABASE *db, const WCHAR *comp, MSI
     MSI_IterateRecords( view, &name.count, NULL, NULL );
     if (!name.count) goto done;
 
-    name.attrs = msi_alloc( name.count * sizeof(WCHAR *) );
+    name.attrs = malloc( name.count * sizeof(WCHAR *) );
     if (!name.attrs) goto done;
 
     MSI_IterateRecords( view, NULL, get_assembly_name_attribute, &name );
@@ -198,7 +198,7 @@ static WCHAR *get_assembly_display_name( MSIDATABASE *db, const WCHAR *comp, MSI
     len = 0;
     for (i = 0; i < name.count; i++) len += lstrlenW( name.attrs[i] ) + 1;
 
-    display_name = msi_alloc( (len + 1) * sizeof(WCHAR) );
+    display_name = malloc( (len + 1) * sizeof(WCHAR) );
     if (display_name)
     {
         display_name[0] = 0;
@@ -213,8 +213,8 @@ static WCHAR *get_assembly_display_name( MSIDATABASE *db, const WCHAR *comp, MSI
     msiobj_release( &view->hdr );
     if (name.attrs)
     {
-        for (i = 0; i < name.count; i++) msi_free( name.attrs[i] );
-        msi_free( name.attrs );
+        for (i = 0; i < name.count; i++) free( name.attrs[i] );
+        free( name.attrs );
     }
     return display_name;
 }
@@ -250,12 +250,12 @@ WCHAR *msi_get_assembly_path( MSIPACKAGE *package, const WCHAR *displayname )
     hr = IAssemblyCache_QueryAssemblyInfo( cache, 0, displayname, &info );
     if (hr != E_NOT_SUFFICIENT_BUFFER) return NULL;
 
-    if (!(info.pszCurrentAssemblyPathBuf = msi_alloc( info.cchBuf * sizeof(WCHAR) ))) return NULL;
+    if (!(info.pszCurrentAssemblyPathBuf = malloc( info.cchBuf * sizeof(WCHAR) ))) return NULL;
 
     hr = IAssemblyCache_QueryAssemblyInfo( cache, 0, displayname, &info );
     if (FAILED( hr ))
     {
-        msi_free( info.pszCurrentAssemblyPathBuf );
+        free( info.pszCurrentAssemblyPathBuf );
         return NULL;
     }
     TRACE("returning %s\n", debugstr_w(info.pszCurrentAssemblyPathBuf));
@@ -276,7 +276,7 @@ IAssemblyEnum *msi_create_assembly_enum( MSIPACKAGE *package, const WCHAR *displ
     if (FAILED( hr )) return NULL;
 
     hr = IAssemblyName_GetName( name, &len, NULL );
-    if (hr != E_NOT_SUFFICIENT_BUFFER || !(str = msi_alloc( len * sizeof(WCHAR) )))
+    if (hr != E_NOT_SUFFICIENT_BUFFER || !(str = malloc( len * sizeof(WCHAR) )))
     {
         IAssemblyName_Release( name );
         return NULL;
@@ -286,12 +286,12 @@ IAssemblyEnum *msi_create_assembly_enum( MSIPACKAGE *package, const WCHAR *displ
     IAssemblyName_Release( name );
     if (FAILED( hr ))
     {
-        msi_free( str );
+        free( str );
         return NULL;
     }
 
     hr = package->pCreateAssemblyNameObject( &name, str, 0, NULL );
-    msi_free( str );
+    free( str );
     if (FAILED( hr )) return NULL;
 
     hr = package->pCreateAssemblyEnum( &ret, NULL, name, ASM_CACHE_GAC, NULL );
@@ -322,7 +322,7 @@ MSIASSEMBLY *msi_load_assembly( MSIPACKAGE *package, MSICOMPONENT *comp )
     MSIASSEMBLY *a;
 
     if (!(rec = get_assembly_record( package, comp->Component ))) return NULL;
-    if (!(a = msi_alloc_zero( sizeof(MSIASSEMBLY) )))
+    if (!(a = calloc( 1, sizeof(MSIASSEMBLY) )))
     {
         msiobj_release( &rec->hdr );
         return NULL;
@@ -343,10 +343,10 @@ MSIASSEMBLY *msi_load_assembly( MSIPACKAGE *package, MSICOMPONENT *comp )
     {
         WARN("can't get display name\n");
         msiobj_release( &rec->hdr );
-        msi_free( a->feature );
-        msi_free( a->manifest );
-        msi_free( a->application );
-        msi_free( a );
+        free( a->feature );
+        free( a->manifest );
+        free( a->application );
+        free( a );
         return NULL;
     }
     TRACE("display name %s\n", debugstr_w(a->display_name));
@@ -394,7 +394,7 @@ static enum clr_version get_clr_version( MSIPACKAGE *package, const WCHAR *filen
 
     hr = package->pGetFileVersion( filename, NULL, 0, &len );
     if (hr != E_NOT_SUFFICIENT_BUFFER) return CLR_VERSION_V11;
-    if ((strW = msi_alloc( len * sizeof(WCHAR) )))
+    if ((strW = malloc( len * sizeof(WCHAR) )))
     {
         hr = package->pGetFileVersion( filename, strW, len, &len );
         if (hr == S_OK)
@@ -403,7 +403,7 @@ static enum clr_version get_clr_version( MSIPACKAGE *package, const WCHAR *filen
             for (i = 0; i < CLR_VERSION_MAX; i++)
                 if (!wcscmp( strW, clr_version[i] )) version = i;
         }
-        msi_free( strW );
+        free( strW );
     }
     return version;
 }
@@ -500,7 +500,7 @@ static WCHAR *build_local_assembly_path( const WCHAR *filename )
     UINT i;
     WCHAR *ret;
 
-    if (!(ret = msi_alloc( (lstrlenW( filename ) + 1) * sizeof(WCHAR) )))
+    if (!(ret = malloc( (wcslen( filename ) + 1) * sizeof(WCHAR) )))
         return NULL;
 
     for (i = 0; filename[i]; i++)
@@ -543,12 +543,12 @@ static LONG open_local_assembly_key( UINT context, BOOL win32, const WCHAR *file
 
     if ((res = open_assemblies_key( context, win32, &root )))
     {
-        msi_free( path );
+        free( path );
         return res;
     }
     res = RegCreateKeyW( root, path, hkey );
     RegCloseKey( root );
-    msi_free( path );
+    free( path );
     return res;
 }
 
@@ -563,12 +563,12 @@ static LONG delete_local_assembly_key( UINT context, BOOL win32, const WCHAR *fi
 
     if ((res = open_assemblies_key( context, win32, &root )))
     {
-        msi_free( path );
+        free( path );
         return res;
     }
     res = RegDeleteKeyW( root, path );
     RegCloseKey( root );
-    msi_free( path );
+    free( path );
     return res;
 }
 
diff --git a/dlls/msi/automation.c b/dlls/msi/automation.c
index f8fd8cc14498..99852938b0e5 100644
--- a/dlls/msi/automation.c
+++ b/dlls/msi/automation.c
@@ -239,7 +239,7 @@ static ULONG WINAPI AutomationObject_Release(IDispatch* iface)
     {
         if (tid_ids[This->tid].fn_free) tid_ids[This->tid].fn_free(This);
         MsiCloseHandle(This->msiHandle);
-        msi_free(This);
+        free(This);
     }
 
     return ref;
@@ -607,7 +607,7 @@ static ULONG WINAPI ListEnumerator_Release(IEnumVARIANT* iface)
     if (!ref)
     {
         if (This->list) IDispatch_Release(&This->list->autoobj.IDispatch_iface);
-        msi_free(This);
+        free(This);
     }
 
     return ref;
@@ -703,7 +703,7 @@ static HRESULT create_list_enumerator(ListObject *list, void **ppObj)
 
     TRACE("(%p, %p)\n", list, ppObj);
 
-    object = msi_alloc(sizeof(ListEnumerator));
+    object = malloc(sizeof(ListEnumerator));
 
     /* Set all the VTable references */
     object->IEnumVARIANT_iface.lpVtbl = &ListEnumerator_Vtbl;
@@ -807,7 +807,7 @@ static HRESULT summaryinfo_invoke(
                         break;
 
                     case VT_LPSTR:
-                        if (!(str = msi_alloc(++size * sizeof(WCHAR))))
+                        if (!(str = malloc(++size * sizeof(WCHAR))))
                             ERR("Out of memory\n");
                         else if ((ret = MsiSummaryInfoGetPropertyW(This->msiHandle, V_I4(&varg0), &type, NULL,
                                                                    NULL, str, &size)) != ERROR_SUCCESS)
@@ -817,7 +817,7 @@ static HRESULT summaryinfo_invoke(
                             V_VT(pVarResult) = VT_BSTR;
                             V_BSTR(pVarResult) = SysAllocString(str);
                         }
-                        msi_free(str);
+                        free(str);
                         break;
 
                     case VT_FILETIME:
@@ -941,11 +941,11 @@ static HRESULT record_invoke(
                 V_BSTR(pVarResult) = NULL;
                 if ((ret = MsiRecordGetStringW(This->msiHandle, V_I4(&varg0), NULL, &dwLen)) == ERROR_SUCCESS)
                 {
-                    if (!(szString = msi_alloc((++dwLen)*sizeof(WCHAR))))
+                    if (!(szString = malloc((++dwLen) * sizeof(WCHAR))))
                         ERR("Out of memory\n");
                     else if ((ret = MsiRecordGetStringW(This->msiHandle, V_I4(&varg0), szString, &dwLen)) == ERROR_SUCCESS)
                         V_BSTR(pVarResult) = SysAllocString(szString);
-                    msi_free(szString);
+                    free(szString);
                 }
                 if (ret != ERROR_SUCCESS)
                     ERR("MsiRecordGetString returned %d\n", ret);
@@ -998,7 +998,7 @@ static HRESULT create_record(MSIHANDLE msiHandle, IDispatch **disp)
 {
     AutomationObject *record;
 
-    record = msi_alloc(sizeof(*record));
+    record = malloc(sizeof(*record));
     if (!record) return E_OUTOFMEMORY;
 
     init_automation_object(record, msiHandle, Record_tid);
@@ -1072,7 +1072,7 @@ static void list_free(AutomationObject *This)
 
     for (i = 0; i < list->count; i++)
         VariantClear(&list->data[i]);
-    msi_free(list->data);
+    free(list->data);
 }
 
 static HRESULT get_products_count(const WCHAR *product, int *len)
@@ -1109,7 +1109,7 @@ static HRESULT create_list(const WCHAR *product, IDispatch **dispatch)
     HRESULT hr;
     int i;
 
-    list = msi_alloc_zero(sizeof(ListObject));
+    list = calloc(1, sizeof(ListObject));
     if (!list) return E_OUTOFMEMORY;
 
     init_automation_object(&list->autoobj, 0, StringList_tid);
@@ -1123,7 +1123,7 @@ static HRESULT create_list(const WCHAR *product, IDispatch **dispatch)
         return hr;
     }
 
-    list->data = msi_alloc(list->count*sizeof(VARIANT));
+    list->data = malloc(list->count * sizeof(VARIANT));
     if (!list->data)
     {
         IDispatch_Release(*dispatch);
@@ -1382,11 +1382,11 @@ static HRESULT session_invoke(
                 V_BSTR(pVarResult) = NULL;
                 if ((ret = MsiGetPropertyW(This->msiHandle, V_BSTR(&varg0), NULL, &dwLen)) == ERROR_SUCCESS)
                 {
-                    if (!(szString = msi_alloc((++dwLen)*sizeof(WCHAR))))
+                    if (!(szString = malloc((++dwLen) * sizeof(WCHAR))))
                         ERR("Out of memory\n");
                     else if ((ret = MsiGetPropertyW(This->msiHandle, V_BSTR(&varg0), szString, &dwLen)) == ERROR_SUCCESS)
                         V_BSTR(pVarResult) = SysAllocString(szString);
-                    msi_free(szString);
+                    free(szString);
                 }
                 if (ret != ERROR_SUCCESS)
                     ERR("MsiGetProperty returned %d\n", ret);
@@ -1619,7 +1619,7 @@ static void variant_from_registry_value(VARIANT *pVarResult, DWORD dwType, LPBYT
         case REG_EXPAND_SZ:
             if (!(dwNewSize = ExpandEnvironmentStringsW(szString, szNewString, dwNewSize)))
                 ERR("ExpandEnvironmentStrings returned error %lu\n", GetLastError());
-            else if (!(szNewString = msi_alloc(dwNewSize * sizeof(WCHAR))))
+            else if (!(szNewString = malloc(dwNewSize * sizeof(WCHAR))))
                 ERR("Out of memory\n");
             else if (!(dwNewSize = ExpandEnvironmentStringsW(szString, szNewString, dwNewSize)))
                 ERR("ExpandEnvironmentStrings returned error %lu\n", GetLastError());
@@ -1628,7 +1628,7 @@ static void variant_from_registry_value(VARIANT *pVarResult, DWORD dwType, LPBYT
                 V_VT(pVarResult) = VT_BSTR;
                 V_BSTR(pVarResult) = SysAllocStringLen(szNewString, dwNewSize);
             }
-            msi_free(szNewString);
+            free(szNewString);
             break;
 
         case REG_DWORD:
@@ -2047,7 +2047,7 @@ static HRESULT InstallerImpl_RegistryValue(WORD wFlags,
                 goto done;
             }
 
-            szString = msi_alloc(size);
+            szString = malloc(size);
             if (!szString)
             {
                 hr = E_OUTOFMEMORY;
@@ -2058,14 +2058,14 @@ static HRESULT InstallerImpl_RegistryValue(WORD wFlags,
                                    &type, (LPBYTE)szString, &size);
             if (ret != ERROR_SUCCESS)
             {
-                msi_free(szString);
+                free(szString);
                 hr = DISP_E_BADINDEX;
                 goto done;
             }
 
             variant_from_registry_value(pVarResult, type,
                                         (LPBYTE)szString, size);
-            msi_free(szString);
+            free(szString);
             break;
 
         /* Try to make it into VT_I4, can use VariantChangeType for this. */
@@ -2093,7 +2093,7 @@ static HRESULT InstallerImpl_RegistryValue(WORD wFlags,
             if (ret != ERROR_SUCCESS)
                 goto done;
 
-            szString = msi_alloc(++size * sizeof(WCHAR));
+            szString = malloc(++size * sizeof(WCHAR));
             if (!szString)
             {
                 hr = E_OUTOFMEMORY;
@@ -2115,7 +2115,7 @@ static HRESULT InstallerImpl_RegistryValue(WORD wFlags,
                 V_BSTR(pVarResult) = SysAllocString(szString);
             }
 
-            msi_free(szString);
+            free(szString);
     }
 
 done:
@@ -2245,7 +2245,7 @@ static HRESULT InstallerImpl_ProductInfo(WORD wFlags,
         goto done;
     }
 
-    str = msi_alloc(++size * sizeof(WCHAR));
+    str = malloc(++size * sizeof(WCHAR));
     if (!str)
     {
         hr = E_OUTOFMEMORY;
@@ -2263,7 +2263,7 @@ static HRESULT InstallerImpl_ProductInfo(WORD wFlags,
     hr = S_OK;
 
 done:
-    msi_free(str);
+    free(str);
     VariantClear(&varg0);
     VariantClear(&varg1);
     return hr;
@@ -2427,7 +2427,7 @@ HRESULT create_msiserver(IUnknown *outer, void **ppObj)
     if (outer)
         return CLASS_E_NOAGGREGATION;
 
-    installer = msi_alloc(sizeof(AutomationObject));
+    installer = malloc(sizeof(AutomationObject));
     if (!installer) return E_OUTOFMEMORY;
 
     init_automation_object(installer, 0, Installer_tid);
@@ -2441,7 +2441,7 @@ HRESULT create_session(MSIHANDLE msiHandle, IDispatch *installer, IDispatch **di
 {
     SessionObject *session;
 
-    session = msi_alloc(sizeof(SessionObject));
+    session = malloc(sizeof(SessionObject));
     if (!session) return E_OUTOFMEMORY;
 
     init_automation_object(&session->autoobj, msiHandle, Session_tid);
@@ -2458,7 +2458,7 @@ static HRESULT create_database(MSIHANDLE msiHandle, IDispatch **dispatch)
 
     TRACE("%lu %p\n", msiHandle, dispatch);
 
-    database = msi_alloc(sizeof(AutomationObject));
+    database = malloc(sizeof(AutomationObject));
     if (!database) return E_OUTOFMEMORY;
 
     init_automation_object(database, msiHandle, Database_tid);
@@ -2474,7 +2474,7 @@ static HRESULT create_view(MSIHANDLE msiHandle, IDispatch **dispatch)
 
     TRACE("%lu %p\n", msiHandle, dispatch);
 
-    view = msi_alloc(sizeof(AutomationObject));
+    view = malloc(sizeof(AutomationObject));
     if (!view) return E_OUTOFMEMORY;
 
     init_automation_object(view, msiHandle, View_tid);
@@ -2488,7 +2488,7 @@ static HRESULT create_summaryinfo(MSIHANDLE msiHandle, IDispatch **disp)
 {
     AutomationObject *info;
 
-    info = msi_alloc(sizeof(*info));
+    info = malloc(sizeof(*info));
     if (!info) return E_OUTOFMEMORY;
 
     init_automation_object(info, msiHandle, SummaryInfo_tid);
diff --git a/dlls/msi/classes.c b/dlls/msi/classes.c
index 5ba3f480071b..ca0e59170e63 100644
--- a/dlls/msi/classes.c
+++ b/dlls/msi/classes.c
@@ -49,7 +49,7 @@ static MSIAPPID *load_appid( MSIPACKAGE* package, MSIRECORD *row )
 
     /* fill in the data */
 
-    appid = msi_alloc_zero( sizeof(MSIAPPID) );
+    appid = calloc( 1, sizeof(MSIAPPID) );
     if (!appid)
         return NULL;
 
@@ -108,7 +108,7 @@ static MSIPROGID *load_progid( MSIPACKAGE* package, MSIRECORD *row )
 
     /* fill in the data */
 
-    progid = msi_alloc_zero( sizeof(MSIPROGID) );
+    progid = calloc( 1, sizeof(MSIPROGID) );
     if (!progid)
         return NULL;
 
@@ -137,9 +137,9 @@ static MSIPROGID *load_progid( MSIPACKAGE* package, MSIRECORD *row )
 
         FilePath = msi_build_icon_path(package, FileName);
 
-        progid->IconPath = msi_alloc( (lstrlenW(FilePath) + 10) * sizeof(WCHAR) );
+        progid->IconPath = malloc( (wcslen(FilePath) + 10) * sizeof(WCHAR) );
         swprintf( progid->IconPath, lstrlenW(FilePath) + 10, L"%s,%d", FilePath, icon_index );
-        msi_free(FilePath);
+        free(FilePath);
     }
     else
     {
@@ -203,7 +203,7 @@ static MSICLASS *load_class( MSIPACKAGE* package, MSIRECORD *row )
 
     /* fill in the data */
 
-    cls = msi_alloc_zero( sizeof(MSICLASS) );
+    cls = calloc( 1, sizeof(MSICLASS) );
     if (!cls)
         return NULL;
 
@@ -235,9 +235,9 @@ static MSICLASS *load_class( MSIPACKAGE* package, MSIRECORD *row )
 
         FilePath = msi_build_icon_path(package, FileName);
 
-        cls->IconPath = msi_alloc( (lstrlenW(FilePath) + 5) * sizeof(WCHAR) );
+        cls->IconPath = malloc( (wcslen(FilePath) + 5) * sizeof(WCHAR) );
         swprintf( cls->IconPath, lstrlenW(FilePath) + 5, L"%s,%d", FilePath, icon_index );
-        msi_free(FilePath);
+        free(FilePath);
     }
     else
     {
@@ -324,7 +324,7 @@ static MSIMIME *load_mime( MSIPACKAGE* package, MSIRECORD *row )
 
     /* fill in the data */
 
-    mt = msi_alloc_zero( sizeof(MSIMIME) );
+    mt = calloc( 1, sizeof(MSIMIME) );
     if (!mt)
         return mt;
 
@@ -377,7 +377,7 @@ static MSIEXTENSION *load_extension( MSIPACKAGE* package, MSIRECORD *row )
 
     /* fill in the data */
 
-    ext = msi_alloc_zero( sizeof(MSIEXTENSION) );
+    ext = calloc( 1, sizeof(MSIEXTENSION) );
     if (!ext)
         return NULL;
 
@@ -454,7 +454,7 @@ static UINT iterate_load_verb(MSIRECORD *row, LPVOID param)
 
     /* fill in the data */
 
-    verb = msi_alloc_zero( sizeof(MSIVERB) );
+    verb = calloc( 1, sizeof(MSIVERB) );
     if (!verb)
         return ERROR_OUTOFMEMORY;
 
@@ -768,7 +768,7 @@ UINT ACTION_RegisterClassInfo(MSIPACKAGE *package)
         if (cls->Argument)
             size += lstrlenW(cls->Argument)+1;
 
-        argument = msi_alloc( size * sizeof(WCHAR) );
+        argument = malloc( size * sizeof(WCHAR) );
         lstrcpyW( argument, file->TargetPath );
 
         if (cls->Argument)
@@ -778,7 +778,7 @@ UINT ACTION_RegisterClassInfo(MSIPACKAGE *package)
         }
 
         msi_reg_set_val_str( hkey3, NULL, argument );
-        msi_free(argument);
+        free(argument);
 
         RegCloseKey(hkey3);
 
@@ -829,12 +829,12 @@ UINT ACTION_RegisterClassInfo(MSIPACKAGE *package)
                 ptr2 = wcschr(ptr,';');
                 if (ptr2)
                     *ptr2 = 0;
-                keyname = msi_alloc( (lstrlenW(L"FileType\\%s\\%d") + lstrlenW(cls->clsid) + 4) * sizeof(WCHAR));
+                keyname = malloc( sizeof(L"FileType\\%s\\%d") + (wcslen(cls->clsid) + 3) * sizeof(WCHAR) );
                 swprintf( keyname, lstrlenW(L"FileType\\%s\\%d") + lstrlenW(cls->clsid) + 4,
                           L"FileType\\%s\\%d", cls->clsid, index );
 
                 msi_reg_set_subkey_val( HKEY_CLASSES_ROOT, keyname, NULL, ptr );
-                msi_free(keyname);
+                free( keyname );
 
                 if (ptr2)
                     ptr = ptr2+1;
@@ -926,13 +926,13 @@ UINT ACTION_UnregisterClassInfo( MSIPACKAGE *package )
         }
         if (cls->FileTypeMask)
         {
-            filetype = msi_alloc( (lstrlenW( L"FileType\\" ) + lstrlenW( cls->clsid ) + 1) * sizeof(WCHAR) );
+            filetype = malloc( sizeof( L"FileType\\" ) + wcslen( cls->clsid ) * sizeof(WCHAR) );
             if (filetype)
             {
                 lstrcpyW( filetype, L"FileType\\" );
                 lstrcatW( filetype, cls->clsid );
                 res = RegDeleteTreeW( HKEY_CLASSES_ROOT, filetype );
-                msi_free( filetype );
+                free( filetype );
 
                 if (res != ERROR_SUCCESS)
                     WARN("failed to delete file type %ld\n", res);
@@ -1140,14 +1140,14 @@ static UINT register_verb(MSIPACKAGE *package, LPCWSTR progid,
         size += lstrlenW(verb->Argument);
      size += 4;
 
-     command = msi_alloc(size * sizeof (WCHAR));
+     command = malloc(size * sizeof(WCHAR));
      if (verb->Argument)
          swprintf(command, size, L"\"%s\" %s", component->FullKeypath, verb->Argument);
      else
          swprintf(command, size, L"\"%s\"", component->FullKeypath);
 
      msi_reg_set_val_str( key, NULL, command );
-     msi_free(command);
+     free(command);
 
      advertise = msi_create_component_advertise_string(package, component,
                                                        extension->Feature->Feature);
@@ -1157,7 +1157,7 @@ static UINT register_verb(MSIPACKAGE *package, LPCWSTR progid,
          size += lstrlenW(verb->Argument);
      size += 4;
 
-     command = msi_alloc_zero(size * sizeof (WCHAR));
+     command = calloc(size, sizeof(WCHAR));
 
      lstrcpyW(command,advertise);
      if (verb->Argument)
@@ -1169,15 +1169,15 @@ static UINT register_verb(MSIPACKAGE *package, LPCWSTR progid,
      msi_reg_set_val_multi_str( key, L"command", command );
 
      RegCloseKey(key);
-     msi_free(keyname);
-     msi_free(advertise);
-     msi_free(command);
+     free(keyname);
+     free(advertise);
+     free(command);
 
      if (verb->Command)
      {
         keyname = msi_build_directory_name( 3, progid, L"shell", verb->Verb );
         msi_reg_set_subkey_val( HKEY_CLASSES_ROOT, keyname, NULL, verb->Command );
-        msi_free(keyname);
+        free(keyname);
      }
 
      if (verb->Sequence != MSI_NULL_INTEGER)
@@ -1187,7 +1187,7 @@ static UINT register_verb(MSIPACKAGE *package, LPCWSTR progid,
             *Sequence = verb->Sequence;
             keyname = msi_build_directory_name( 2, progid, L"shell" );
             msi_reg_set_subkey_val( HKEY_CLASSES_ROOT, keyname, NULL, verb->Verb );
-            msi_free(keyname);
+            free(keyname);
         }
     }
     return ERROR_SUCCESS;
@@ -1248,13 +1248,13 @@ UINT ACTION_RegisterExtensionInfo(MSIPACKAGE *package)
 
         ext->action = INSTALLSTATE_LOCAL;
 
-        extension = msi_alloc( (lstrlenW( ext->Extension ) + 2) * sizeof(WCHAR) );
+        extension = malloc( (wcslen( ext->Extension ) + 2) * sizeof(WCHAR) );
         if (extension)
         {
             extension[0] = '.';
             lstrcpyW( extension + 1, ext->Extension );
             res = RegCreateKeyW( HKEY_CLASSES_ROOT, extension, &hkey );
-            msi_free( extension );
+            free( extension );
             if (res != ERROR_SUCCESS)
                 WARN("failed to create extension key %ld\n", res);
         }
@@ -1277,14 +1277,14 @@ UINT ACTION_RegisterExtensionInfo(MSIPACKAGE *package)
 
             msi_reg_set_val_str( hkey, NULL, progid );
 
-            newkey = msi_alloc( (lstrlenW(progid) + lstrlenW(L"\\ShellNew") + 1) * sizeof(WCHAR));
+            newkey = malloc( wcslen(progid) * sizeof(WCHAR) + sizeof(L"\\ShellNew") );
 
             lstrcpyW(newkey, progid);
             lstrcatW(newkey, L"\\ShellNew");
             RegCreateKeyW(hkey, newkey, &hkey2);
             RegCloseKey(hkey2);
 
-            msi_free(newkey);
+            free(newkey);
 
             /* do all the verbs */
             LIST_FOR_EACH_ENTRY( verb, &ext->verbs, MSIVERB, entry )
@@ -1347,13 +1347,13 @@ UINT ACTION_UnregisterExtensionInfo( MSIPACKAGE *package )
 
         ext->action = INSTALLSTATE_ABSENT;
 
-        extension = msi_alloc( (lstrlenW( ext->Extension ) + 2) * sizeof(WCHAR) );
+        extension = malloc( (wcslen( ext->Extension ) + 2) * sizeof(WCHAR) );
         if (extension)
         {
             extension[0] = '.';
             lstrcpyW( extension + 1, ext->Extension );
             res = RegDeleteTreeW( HKEY_CLASSES_ROOT, extension );
-            msi_free( extension );
+            free( extension );
             if (res != ERROR_SUCCESS)
                 WARN("failed to delete extension key %ld\n", res);
         }
@@ -1368,13 +1368,13 @@ UINT ACTION_UnregisterExtensionInfo( MSIPACKAGE *package )
             else
                 progid = ext->ProgIDText;
 
-            progid_shell = msi_alloc( (lstrlenW( progid ) + lstrlenW( L"\\shell" ) + 1) * sizeof(WCHAR) );
+            progid_shell = malloc( wcslen( progid ) * sizeof(WCHAR) + sizeof( L"\\shell" ) );
             if (progid_shell)
             {
                 lstrcpyW( progid_shell, progid );
                 lstrcatW( progid_shell, L"\\shell" );
                 res = RegDeleteTreeW( HKEY_CLASSES_ROOT, progid_shell );
-                msi_free( progid_shell );
+                free( progid_shell );
                 if (res != ERROR_SUCCESS)
                     WARN("failed to delete shell key %ld\n", res);
                 RegDeleteKeyW( HKEY_CLASSES_ROOT, progid );
@@ -1419,9 +1419,9 @@ UINT ACTION_RegisterMIMEInfo(MSIPACKAGE *package)
 
         TRACE("Registering MIME type %s\n", debugstr_w(mt->ContentType));
 
-        if (mt->Extension) extension = msi_alloc( (lstrlenW( mt->Extension->Extension ) + 2) * sizeof(WCHAR) );
-        key = msi_alloc( (lstrlenW( mt->ContentType ) +
-                          lstrlenW( L"MIME\\Database\\Content Type\\" ) + 1) * sizeof(WCHAR) );
+        if (mt->Extension) extension = malloc( (wcslen( mt->Extension->Extension ) + 2) * sizeof(WCHAR) );
+        key = malloc( sizeof( L"MIME\\Database\\Content Type\\" ) +
+                      wcslen( mt->ContentType ) * sizeof(WCHAR) );
 
         if (extension && key)
         {
@@ -1435,8 +1435,8 @@ UINT ACTION_RegisterMIMEInfo(MSIPACKAGE *package)
             if (mt->clsid)
                 msi_reg_set_subkey_val( HKEY_CLASSES_ROOT, key, L"CLSID", mt->clsid );
         }
-        msi_free( extension );
-        msi_free( key );
+        free( extension );
+        free( key );
 
         uirow = MSI_CreateRecord( 2 );
         MSI_RecordSetStringW( uirow, 1, mt->ContentType );
@@ -1474,8 +1474,8 @@ UINT ACTION_UnregisterMIMEInfo( MSIPACKAGE *package )
 
         TRACE("Unregistering MIME type %s\n", debugstr_w(mime->ContentType));
 
-        mime_key = msi_alloc( (lstrlenW( L"MIME\\Database\\Content Type\\" ) +
-                               lstrlenW( mime->ContentType ) + 1) * sizeof(WCHAR) );
+        mime_key = malloc( sizeof( L"MIME\\Database\\Content Type\\" ) +
+                           wcslen( mime->ContentType ) * sizeof(WCHAR) );
         if (mime_key)
         {
             lstrcpyW( mime_key, L"MIME\\Database\\Content Type\\" );
@@ -1483,7 +1483,7 @@ UINT ACTION_UnregisterMIMEInfo( MSIPACKAGE *package )
             res = RegDeleteKeyW( HKEY_CLASSES_ROOT, mime_key );
             if (res != ERROR_SUCCESS)
                 WARN("failed to delete MIME key %ld\n", res);
-            msi_free( mime_key );
+            free( mime_key );
         }
 
         uirow = MSI_CreateRecord( 2 );
diff --git a/dlls/msi/cond.y b/dlls/msi/cond.y
index cb6f4f40d5a2..b08c67447dd3 100644
--- a/dlls/msi/cond.y
+++ b/dlls/msi/cond.y
@@ -418,8 +418,8 @@ static WCHAR *strstriW( const WCHAR *str, const WCHAR *sub )
     r = wcsstr( strlower, sublower );
     if (r)
         r = (LPWSTR)str + (r - strlower);
-    msi_free( strlower );
-    msi_free( sublower );
+    free( strlower );
+    free( sublower );
     return r;
 }
 
@@ -755,7 +755,7 @@ static void *cond_alloc( COND_input *cond, unsigned int sz )
 {
     struct list *mem;
 
-    mem = msi_alloc( sizeof (struct list) + sz );
+    mem = malloc( sizeof (struct list) + sz );
     if( !mem )
         return NULL;
 
@@ -773,12 +773,12 @@ static void *cond_track_mem( COND_input *cond, void *ptr, unsigned int sz )
     new_ptr = cond_alloc( cond, sz );
     if( !new_ptr )
     {
-        msi_free( ptr );
+        free( ptr );
         return NULL;
     }
 
     memcpy( new_ptr, ptr, sz );
-    msi_free( ptr );
+    free( ptr );
     return new_ptr;
 }
 
@@ -789,7 +789,7 @@ static void cond_free( void *ptr )
     if( ptr )
     {
         list_remove( mem );
-        msi_free( mem );
+        free( mem );
     }
 }
 
@@ -878,6 +878,6 @@ MSICONDITION WINAPI MsiEvaluateConditionA( MSIHANDLE hInstall, LPCSTR szConditio
         return MSICONDITION_ERROR;
 
     r = MsiEvaluateConditionW( hInstall, szwCond );
-    msi_free( szwCond );
+    free( szwCond );
     return r;
 }
diff --git a/dlls/msi/create.c b/dlls/msi/create.c
index 3d6c5189f2bf..c9aa8f18f233 100644
--- a/dlls/msi/create.c
+++ b/dlls/msi/create.c
@@ -116,7 +116,7 @@ static UINT CREATE_delete( struct tagMSIVIEW *view )
     TRACE("%p\n", cv );
 
     msiobj_release( &cv->db->hdr );
-    msi_free( cv );
+    free( cv );
 
     return ERROR_SUCCESS;
 }
@@ -172,7 +172,7 @@ UINT CREATE_CreateView( MSIDATABASE *db, MSIVIEW **view, LPCWSTR table,
     if( r != ERROR_SUCCESS )
         return r;
 
-    cv = msi_alloc_zero( sizeof *cv );
+    cv = calloc( 1, sizeof *cv );
     if( !cv )
         return ERROR_FUNCTION_FAILED;
 
@@ -189,7 +189,7 @@ UINT CREATE_CreateView( MSIDATABASE *db, MSIVIEW **view, LPCWSTR table,
 
     if ( !temp && tempprim )
     {
-        msi_free( cv );
+        free( cv );
         return ERROR_FUNCTION_FAILED;
     }
 
diff --git a/dlls/msi/custom.c b/dlls/msi/custom.c
index 3ae7c6426caf..035b2dd2c0f5 100644
--- a/dlls/msi/custom.c
+++ b/dlls/msi/custom.c
@@ -94,9 +94,9 @@ UINT msi_schedule_action( MSIPACKAGE *package, UINT script, const WCHAR *action
 
     count = package->script_actions_count[script];
     package->script_actions_count[script]++;
-    if (count != 0) newbuf = msi_realloc( package->script_actions[script],
-                                          package->script_actions_count[script] * sizeof(WCHAR *) );
-    else newbuf = msi_alloc( sizeof(WCHAR *) );
+    if (count != 0) newbuf = realloc( package->script_actions[script],
+                                      package->script_actions_count[script] * sizeof(WCHAR *) );
+    else newbuf = malloc( sizeof(WCHAR *) );
 
     newbuf[count] = wcsdup( action );
     package->script_actions[script] = newbuf;
@@ -112,9 +112,9 @@ UINT msi_register_unique_action( MSIPACKAGE *package, const WCHAR *action )
 
     count = package->unique_actions_count;
     package->unique_actions_count++;
-    if (count != 0) newbuf = msi_realloc( package->unique_actions,
-                                          package->unique_actions_count * sizeof(WCHAR *) );
-    else newbuf = msi_alloc( sizeof(WCHAR *) );
+    if (count != 0) newbuf = realloc( package->unique_actions,
+                                      package->unique_actions_count * sizeof(WCHAR *) );
+    else newbuf = malloc( sizeof(WCHAR *) );
 
     newbuf[count] = wcsdup( action );
     package->unique_actions = newbuf;
@@ -183,7 +183,7 @@ static LPWSTR msi_get_deferred_action(LPCWSTR action, LPCWSTR actiondata,
     len = lstrlenW(action) + lstrlenW(actiondata) +
           lstrlenW(usersid) + lstrlenW(prodcode) +
           lstrlenW(L"[%s<=>%s<=>%s]%s") - 7;
-    deferred = msi_alloc(len * sizeof(WCHAR));
+    deferred = malloc(len * sizeof(WCHAR));
 
     swprintf(deferred, len, L"[%s<=>%s<=>%s]%s", actiondata, usersid, prodcode, action);
     return deferred;
@@ -222,11 +222,11 @@ WCHAR *msi_create_temp_file( MSIDATABASE *db )
         if (!(db->tempfolder = wcsdup( tmp ))) return NULL;
     }
 
-    if ((ret = msi_alloc( (lstrlenW( db->tempfolder ) + 20) * sizeof(WCHAR) )))
+    if ((ret = malloc( (wcslen( db->tempfolder ) + 20) * sizeof(WCHAR) )))
     {
         if (!GetTempFileNameW( db->tempfolder, L"msi", 0, ret ))
         {
-            msi_free( ret );
+            free( ret );
             return NULL;
         }
     }
@@ -247,7 +247,7 @@ static MSIBINARY *create_temp_binary(MSIPACKAGE *package, LPCWSTR source)
     if (!(tmpfile = msi_create_temp_file( package->db ))) return NULL;
 
     if (!(row = MSI_QueryGetRecord( package->db, L"SELECT * FROM `Binary` WHERE `Name` = '%s'", source ))) goto error;
-    if (!(binary = msi_alloc_zero( sizeof(MSIBINARY) ))) goto error;
+    if (!(binary = calloc( 1, sizeof(MSIBINARY) ))) goto error;
 
     file = CreateFileW( tmpfile, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
     if (file == INVALID_HANDLE_VALUE) goto error;
@@ -277,8 +277,8 @@ static MSIBINARY *create_temp_binary(MSIPACKAGE *package, LPCWSTR source)
 error:
     if (row) msiobj_release( &row->hdr );
     DeleteFileW( tmpfile );
-    msi_free( tmpfile );
-    msi_free( binary );
+    free( tmpfile );
+    free( binary );
     return NULL;
 }
 
@@ -300,7 +300,7 @@ static void file_running_action(MSIPACKAGE* package, HANDLE Handle,
 {
     MSIRUNNINGACTION *action;
 
-    action = msi_alloc( sizeof(MSIRUNNINGACTION) );
+    action = malloc( sizeof(MSIRUNNINGACTION) );
 
     action->handle = Handle;
     action->process = process;
@@ -392,11 +392,11 @@ static void free_custom_action_data( msi_custom_action_info *info )
     list_remove( &info->entry );
     if (info->handle)
         CloseHandle( info->handle );
-    msi_free( info->action );
-    msi_free( info->source );
-    msi_free( info->target );
+    free( info->action );
+    free( info->source );
+    free( info->target );
     msiobj_release( &info->package->hdr );
-    msi_free( info );
+    free( info );
 
     LeaveCriticalSection( &msi_custom_action_cs );
 }
@@ -747,7 +747,7 @@ static msi_custom_action_info *do_msidbCustomActionTypeDll(
     RPC_STATUS status;
     BOOL ret;
 
-    info = msi_alloc( sizeof *info );
+    info = malloc( sizeof *info );
     if (!info)
         return NULL;
 
@@ -838,25 +838,25 @@ static HANDLE execute_command( const WCHAR *app, WCHAR *arg, const WCHAR *dir )
         int len_arg = 0;
         DWORD len_exe;
 
-        if (!(exe = msi_alloc( MAX_PATH * sizeof(WCHAR) ))) return INVALID_HANDLE_VALUE;
+        if (!(exe = malloc( MAX_PATH * sizeof(WCHAR) ))) return INVALID_HANDLE_VALUE;
         len_exe = SearchPathW( NULL, app, L".exe", MAX_PATH, exe, NULL );
         if (len_exe >= MAX_PATH)
         {
-            msi_free( exe );
-            if (!(exe = msi_alloc( len_exe * sizeof(WCHAR) ))) return INVALID_HANDLE_VALUE;
+            free( exe );
+            if (!(exe = malloc( len_exe * sizeof(WCHAR) ))) return INVALID_HANDLE_VALUE;
             len_exe = SearchPathW( NULL, app, L".exe", len_exe, exe, NULL );
         }
         if (!len_exe)
         {
             ERR("can't find executable %lu\n", GetLastError());
-            msi_free( exe );
+            free( exe );
             return INVALID_HANDLE_VALUE;
         }
 
         if (arg) len_arg = lstrlenW( arg );
-        if (!(cmd = msi_alloc( (len_exe + len_arg + 4) * sizeof(WCHAR) )))
+        if (!(cmd = malloc( (len_exe + len_arg + 4) * sizeof(WCHAR) )))
         {
-            msi_free( exe );
+            free( exe );
             return INVALID_HANDLE_VALUE;
         }
         p = cmd;
@@ -882,8 +882,8 @@ static HANDLE execute_command( const WCHAR *app, WCHAR *arg, const WCHAR *dir )
     }
     memset( &si, 0, sizeof(STARTUPINFOW) );
     ret = CreateProcessW( exe, exe ? cmd : arg, NULL, NULL, FALSE, 0, NULL, dir, &si, &info );
-    msi_free( cmd );
-    msi_free( exe );
+    free( cmd );
+    free( exe );
     if (!ret)
     {
         ERR("unable to execute command %lu\n", GetLastError());
@@ -907,7 +907,7 @@ static UINT HANDLE_CustomType2( MSIPACKAGE *package, const WCHAR *source, const
     TRACE("exe %s arg %s\n", debugstr_w(binary->tmpfile), debugstr_w(arg));
 
     handle = execute_command( binary->tmpfile, arg, L"C:\\" );
-    msi_free( arg );
+    free( arg );
     if (handle == INVALID_HANDLE_VALUE) return ERROR_SUCCESS;
     return wait_process_handle( package, type, handle, action );
 }
@@ -945,7 +945,7 @@ static UINT HANDLE_CustomType18( MSIPACKAGE *package, const WCHAR *source, const
     TRACE("exe %s arg %s\n", debugstr_w(file->TargetPath), debugstr_w(arg));
 
     handle = execute_command( file->TargetPath, arg, L"C:\\" );
-    msi_free( arg );
+    free( arg );
     if (handle == INVALID_HANDLE_VALUE) return ERROR_SUCCESS;
     return wait_process_handle( package, type, handle, action );
 }
@@ -970,7 +970,7 @@ static UINT HANDLE_CustomType19( MSIPACKAGE *package, const WCHAR *source, const
     else if ((package->ui_level & INSTALLUILEVEL_MASK) != INSTALLUILEVEL_NONE)
         MessageBoxW( NULL, deformated, NULL, MB_OK );
 
-    msi_free( deformated );
+    free( deformated );
 
     return ERROR_INSTALL_FAILURE;
 }
@@ -981,7 +981,7 @@ static WCHAR *build_msiexec_args( const WCHAR *filename, const WCHAR *params )
     UINT len = ARRAY_SIZE(L"/qb /i ") - 1;
     WCHAR *ret;
 
-    if (!(ret = msi_alloc( (len + len_filename + len_params + 4) * sizeof(WCHAR) ))) return NULL;
+    if (!(ret = malloc( (len + len_filename + len_params + 4) * sizeof(WCHAR) ))) return NULL;
     memcpy( ret, L"/qb /i ", sizeof(L"/qb /i ") );
     ret[len++] = '"';
     memcpy( ret + len, filename, len_filename * sizeof(WCHAR) );
@@ -1002,14 +1002,14 @@ static UINT HANDLE_CustomType23( MSIPACKAGE *package, const WCHAR *source, const
     if (!(dir = msi_dup_property( package->db, L"OriginalDatabase" ))) return ERROR_OUTOFMEMORY;
     if (!(p = wcsrchr( dir, '\\' )) && !(p = wcsrchr( dir, '/' )))
     {
-        msi_free( dir );
+        free( dir );
         return ERROR_FUNCTION_FAILED;
     }
     *p = 0;
     len_dir = p - dir;
-    if (!(filename = msi_alloc( (len_dir + len_source + 2) * sizeof(WCHAR) )))
+    if (!(filename = malloc( (len_dir + len_source + 2) * sizeof(WCHAR) )))
     {
-        msi_free( dir );
+        free( dir );
         return ERROR_OUTOFMEMORY;
     }
     memcpy( filename, dir, len_dir * sizeof(WCHAR) );
@@ -1019,15 +1019,15 @@ static UINT HANDLE_CustomType23( MSIPACKAGE *package, const WCHAR *source, const
 
     if (!(args = build_msiexec_args( filename, target )))
     {
-        msi_free( dir );
+        free( dir );
         return ERROR_OUTOFMEMORY;
     }
 
     TRACE("installing %s concurrently\n", debugstr_w(source));
 
     handle = execute_command( L"msiexec", args, dir );
-    msi_free( dir );
-    msi_free( args );
+    free( dir );
+    free( args );
     if (handle == INVALID_HANDLE_VALUE) return ERROR_SUCCESS;
     return wait_process_handle( package, type, handle, action );
 }
@@ -1085,7 +1085,7 @@ static UINT HANDLE_CustomType7( MSIPACKAGE *package, const WCHAR *source, const
     if (r != ERROR_SUCCESS)
         goto error;
 
-    if (!(binary = msi_alloc( sizeof(*binary) ))) goto error;
+    if (!(binary = malloc( sizeof(*binary) ))) goto error;
     binary->source  = NULL;
     binary->tmpfile = tmpfile;
     list_add_tail( &package->binaries, &binary->entry );
@@ -1095,13 +1095,13 @@ static UINT HANDLE_CustomType7( MSIPACKAGE *package, const WCHAR *source, const
     TRACE("installing %s concurrently\n", debugstr_w(source));
 
     handle = execute_command( L"msiexec", args, L"C:\\" );
-    msi_free( args );
+    free( args );
     if (handle == INVALID_HANDLE_VALUE) return ERROR_SUCCESS;
     return wait_process_handle( package, type, handle, action );
 
 error:
     DeleteFileW( tmpfile );
-    msi_free( tmpfile );
+    free( tmpfile );
     return ERROR_FUNCTION_FAILED;
 }
 
@@ -1117,8 +1117,8 @@ static UINT HANDLE_CustomType50( MSIPACKAGE *package, const WCHAR *source, const
     TRACE("exe %s arg %s\n", debugstr_w(exe), debugstr_w(arg));
 
     handle = execute_command( exe, arg, L"C:\\" );
-    msi_free( exe );
-    msi_free( arg );
+    free( exe );
+    free( arg );
     if (handle == INVALID_HANDLE_VALUE) return ERROR_SUCCESS;
     return wait_process_handle( package, type, handle, action );
 }
@@ -1141,7 +1141,7 @@ static UINT HANDLE_CustomType34( MSIPACKAGE *package, const WCHAR *source, const
     TRACE("cmd %s dir %s\n", debugstr_w(cmd), debugstr_w(workingdir));
 
     handle = execute_command( NULL, cmd, workingdir );
-    msi_free( cmd );
+    free( cmd );
     if (handle == INVALID_HANDLE_VALUE) return ERROR_SUCCESS;
     return wait_process_handle( package, type, handle, action );
 }
@@ -1194,7 +1194,7 @@ static msi_custom_action_info *do_msidbCustomActionTypeScript(
 {
     msi_custom_action_info *info;
 
-    info = msi_alloc( sizeof *info );
+    info = malloc( sizeof *info );
     if (!info)
         return NULL;
 
@@ -1250,7 +1250,7 @@ static UINT HANDLE_CustomType5_6( MSIPACKAGE *package, const WCHAR *source, cons
     r = MSI_RecordReadStream(row, 2, NULL, &sz);
     if (r != ERROR_SUCCESS) goto done;
 
-    buffer = msi_alloc( sz + 1 );
+    buffer = malloc( sz + 1 );
     if (!buffer)
     {
        r = ERROR_FUNCTION_FAILED;
@@ -1273,8 +1273,8 @@ static UINT HANDLE_CustomType5_6( MSIPACKAGE *package, const WCHAR *source, cons
     r = wait_thread_handle( info );
 
 done:
-    msi_free(bufferw);
-    msi_free(buffer);
+    free(bufferw);
+    free(buffer);
     msiobj_release(&row->hdr);
     return r;
 }
@@ -1309,7 +1309,7 @@ static UINT HANDLE_CustomType21_22( MSIPACKAGE *package, const WCHAR *source, co
         CloseHandle(hFile);
         return ERROR_FUNCTION_FAILED;
     }
-    buffer = msi_alloc( sz + 1 );
+    buffer = malloc( sz + 1 );
     if (!buffer)
     {
         CloseHandle(hFile);
@@ -1333,8 +1333,8 @@ static UINT HANDLE_CustomType21_22( MSIPACKAGE *package, const WCHAR *source, co
     r = wait_thread_handle( info );
 
 done:
-    msi_free(bufferw);
-    msi_free(buffer);
+    free(bufferw);
+    free(buffer);
     return r;
 }
 
@@ -1350,7 +1350,7 @@ static UINT HANDLE_CustomType53_54( MSIPACKAGE *package, const WCHAR *source, co
     if (!prop) return ERROR_SUCCESS;
 
     info = do_msidbCustomActionTypeScript( package, type, prop, NULL, action );
-    msi_free(prop);
+    free(prop);
     return wait_thread_handle( info );
 }
 
@@ -1381,9 +1381,9 @@ static UINT defer_custom_action( MSIPACKAGE *package, const WCHAR *action, UINT
 
     if (!deferred)
     {
-        msi_free( actiondata );
-        msi_free( usersid );
-        msi_free( prodcode );
+        free( actiondata );
+        free( usersid );
+        free( prodcode );
         return ERROR_OUTOFMEMORY;
     }
     if (type & msidbCustomActionTypeCommit)
@@ -1402,10 +1402,10 @@ static UINT defer_custom_action( MSIPACKAGE *package, const WCHAR *action, UINT
         msi_schedule_action( package, SCRIPT_INSTALL, deferred );
     }
 
-    msi_free( actiondata );
-    msi_free( usersid );
-    msi_free( prodcode );
-    msi_free( deferred );
+    free( actiondata );
+    free( usersid );
+    free( prodcode );
+    free( deferred );
     return ERROR_SUCCESS;
 }
 
@@ -1470,7 +1470,7 @@ UINT ACTION_CustomAction(MSIPACKAGE *package, const WCHAR *action)
             else
                 msi_set_property( package->db, L"CustomActionData", L"", -1 );
 
-            msi_free(actiondata);
+            free(actiondata);
         }
     }
     else if (!check_execution_scheduling_options(package,action,type))
@@ -1494,7 +1494,7 @@ UINT ACTION_CustomAction(MSIPACKAGE *package, const WCHAR *action)
     case 7: /* Concurrent install from substorage */
         deformat_string( package, target, &deformated );
         rc = HANDLE_CustomType7( package, source, target, type, action );
-        msi_free( deformated );
+        free( deformated );
         break;
     case 17:
         rc = HANDLE_CustomType17( package, source, target, type, action );
@@ -1512,7 +1512,7 @@ UINT ACTION_CustomAction(MSIPACKAGE *package, const WCHAR *action)
     case 23: /* Installs another package in the source tree */
         deformat_string( package, target, &deformated );
         rc = HANDLE_CustomType23( package, source, deformated, type, action );
-        msi_free( deformated );
+        free( deformated );
         break;
     case 34: /* EXE to be run in specified directory */
         rc = HANDLE_CustomType34( package, source, target, type, action );
@@ -1520,7 +1520,7 @@ UINT ACTION_CustomAction(MSIPACKAGE *package, const WCHAR *action)
     case 35: /* Directory set with formatted text */
         deformat_string( package, target, &deformated );
         MSI_SetTargetPathW( package, source, deformated );
-        msi_free( deformated );
+        free( deformated );
         break;
     case 37: /* JScript/VBScript text stored in target column */
     case 38:
@@ -1534,7 +1534,7 @@ UINT ACTION_CustomAction(MSIPACKAGE *package, const WCHAR *action)
         len = deformat_string( package, target, &deformated );
         rc = msi_set_property( package->db, source, deformated, len );
         if (rc == ERROR_SUCCESS && !wcscmp( source, L"SourceDir" )) msi_reset_source_folders( package );
-        msi_free( deformated );
+        free( deformated );
         break;
     case 53: /* JScript/VBScript text specified by a property value */
     case 54:
@@ -1570,14 +1570,14 @@ void ACTION_FinishCustomActions(const MSIPACKAGE* package)
         msi_dialog_check_messages( action->handle );
 
         CloseHandle( action->handle );
-        msi_free( action->name );
-        msi_free( action );
+        free( action->name );
+        free( action );
     }
 
     EnterCriticalSection( &msi_custom_action_cs );
 
     handle_count = list_count( &msi_pending_custom_actions );
-    wait_handles = msi_alloc( handle_count * sizeof(HANDLE) );
+    wait_handles = malloc( handle_count * sizeof(HANDLE) );
 
     handle_count = 0;
     LIST_FOR_EACH_ENTRY_SAFE( info, cursor, &msi_pending_custom_actions, msi_custom_action_info, entry )
@@ -1596,7 +1596,7 @@ void ACTION_FinishCustomActions(const MSIPACKAGE* package)
         msi_dialog_check_messages( wait_handles[i] );
         CloseHandle( wait_handles[i] );
     }
-    msi_free( wait_handles );
+    free( wait_handles );
 
     EnterCriticalSection( &msi_custom_action_cs );
     LIST_FOR_EACH_ENTRY_SAFE( info, cursor, &msi_pending_custom_actions, msi_custom_action_info, entry )
diff --git a/dlls/msi/database.c b/dlls/msi/database.c
index 46346c469db1..c0845fbadcbb 100644
--- a/dlls/msi/database.c
+++ b/dlls/msi/database.c
@@ -59,7 +59,7 @@ static void free_transforms( MSIDATABASE *db )
         MSITRANSFORM *t = LIST_ENTRY( list_head( &db->transforms ), MSITRANSFORM, entry );
         list_remove( &t->entry );
         IStorage_Release( t->stg );
-        msi_free( t );
+        free( t );
     }
 }
 
@@ -70,14 +70,14 @@ static void free_streams( MSIDATABASE *db )
     {
         if (db->streams[i].stream) IStream_Release( db->streams[i].stream );
     }
-    msi_free( db->streams );
+    free( db->streams );
 }
 
 void append_storage_to_db( MSIDATABASE *db, IStorage *stg )
 {
     MSITRANSFORM *t;
 
-    t = msi_alloc( sizeof *t );
+    t = malloc( sizeof *t );
     t->stg = stg;
     IStorage_AddRef( stg );
     list_add_head( &db->transforms, &t->entry );
@@ -87,7 +87,7 @@ static VOID MSI_CloseDatabase( MSIOBJECTHDR *arg )
 {
     MSIDATABASE *db = (MSIDATABASE *) arg;
 
-    msi_free(db->path);
+    free( db->path );
     free_streams( db );
     free_cached_tables( db );
     free_transforms( db );
@@ -96,9 +96,9 @@ static VOID MSI_CloseDatabase( MSIOBJECTHDR *arg )
     if (db->deletefile)
     {
         DeleteFileW( db->deletefile );
-        msi_free( db->deletefile );
+        free( db->deletefile );
     }
-    msi_free( db->tempfolder );
+    free( db->tempfolder );
 }
 
 static HRESULT db_initialize( IStorage *stg, const GUID *clsid )
@@ -341,8 +341,8 @@ UINT WINAPI MsiOpenDatabaseA(LPCSTR szDBPath, LPCSTR szPersist, MSIHANDLE *phDB)
 
 end:
     if( !IS_INTMSIDBOPEN(szPersist) )
-        msi_free( szwPersist );
-    msi_free( szwDBPath );
+        free( szwPersist );
+    free( szwDBPath );
 
     return r;
 }
@@ -359,13 +359,13 @@ static LPWSTR msi_read_text_archive(LPCWSTR path, DWORD *len)
         return NULL;
 
     size = GetFileSize( file, NULL );
-    if (!(data = msi_alloc( size ))) goto done;
+    if (!(data = malloc( size ))) goto done;
 
     if (!ReadFile( file, data, size, &read, NULL ) || read != size) goto done;
 
     while (!data[size - 1]) size--;
     *len = MultiByteToWideChar( CP_ACP, 0, data, size, NULL, 0 );
-    if ((wdata = msi_alloc( (*len + 1) * sizeof(WCHAR) )))
+    if ((wdata = malloc( (*len + 1) * sizeof(WCHAR) )))
     {
         MultiByteToWideChar( CP_ACP, 0, data, size, wdata, *len );
         wdata[*len] = 0;
@@ -373,7 +373,7 @@ static LPWSTR msi_read_text_archive(LPCWSTR path, DWORD *len)
 
 done:
     CloseHandle( file );
-    msi_free( data );
+    free( data );
     return wdata;
 }
 
@@ -395,7 +395,7 @@ static void msi_parse_line(LPWSTR *line, LPWSTR **entries, DWORD *num_entries, D
         chars_left--;
     }
 
-    *entries = msi_alloc(count * sizeof(LPWSTR));
+    *entries = malloc(count * sizeof(WCHAR *));
     if (!*entries)
         return;
 
@@ -452,7 +452,7 @@ static LPWSTR msi_build_createsql_prelude(LPWSTR table)
     DWORD size;
 
     size = ARRAY_SIZE(L"CREATE TABLE `%s` ( ") + lstrlenW(table) - 2;
-    prelude = msi_alloc(size * sizeof(WCHAR));
+    prelude = malloc(size * sizeof(WCHAR));
     if (!prelude)
         return NULL;
 
@@ -468,7 +468,7 @@ static LPWSTR msi_build_createsql_columns(LPWSTR *columns_data, LPWSTR *types, D
     WCHAR expanded[128], *ptr;
     WCHAR size[10], comma[2], extra[30];
 
-    columns = msi_alloc_zero(sql_size * sizeof(WCHAR));
+    columns = calloc(sql_size, sizeof(WCHAR));
     if (!columns)
         return NULL;
 
@@ -514,7 +514,7 @@ static LPWSTR msi_build_createsql_columns(LPWSTR *columns_data, LPWSTR *types, D
                 else
                 {
                     WARN("invalid int width %lu\n", len);
-                    msi_free(columns);
+                    free(columns);
                     return NULL;
                 }
                 break;
@@ -526,17 +526,17 @@ static LPWSTR msi_build_createsql_columns(LPWSTR *columns_data, LPWSTR *types, D
                 break;
             default:
                 ERR("Unknown type: %c\n", types[i][0]);
-                msi_free(columns);
+                free(columns);
                 return NULL;
         }
 
         swprintf(expanded, ARRAY_SIZE(expanded), L"`%s` %s%s%s%s ", columns_data[i], type, size, extra, comma);
         sql_size += lstrlenW(expanded);
 
-        p = msi_realloc(columns, sql_size * sizeof(WCHAR));
+        p = realloc(columns, sql_size * sizeof(WCHAR));
         if (!p)
         {
-            msi_free(columns);
+            free(columns);
             return NULL;
         }
         columns = p;
@@ -555,7 +555,7 @@ static LPWSTR msi_build_createsql_postlude(LPWSTR *primary_keys, DWORD num_keys)
     for (i = 0, size = 1; i < num_keys; i++)
         size += lstrlenW(L"`%s`, ") + lstrlenW(primary_keys[i]) - 2;
 
-    keys = msi_alloc(size * sizeof(WCHAR));
+    keys = malloc(size * sizeof(WCHAR));
     if (!keys)
         return NULL;
 
@@ -568,14 +568,14 @@ static LPWSTR msi_build_createsql_postlude(LPWSTR *primary_keys, DWORD num_keys)
     *(ptr - 2) = '\0';
 
     size = lstrlenW(L"PRIMARY KEY %s)") + size - 1;
-    postlude = msi_alloc(size * sizeof(WCHAR));
+    postlude = malloc(size * sizeof(WCHAR));
     if (!postlude)
         goto done;
 
     swprintf(postlude, size, L"PRIMARY KEY %s)", keys);
 
 done:
-    msi_free(keys);
+    free(keys);
     return postlude;
 }
 
@@ -595,7 +595,7 @@ static UINT msi_add_table_to_db(MSIDATABASE *db, LPWSTR *columns, LPWSTR *types,
         goto done;
 
     size = lstrlenW(prelude) + lstrlenW(columns_sql) + lstrlenW(postlude) + 1;
-    create_sql = msi_alloc(size * sizeof(WCHAR));
+    create_sql = malloc(size * sizeof(WCHAR));
     if (!create_sql)
         goto done;
 
@@ -612,10 +612,10 @@ static UINT msi_add_table_to_db(MSIDATABASE *db, LPWSTR *columns, LPWSTR *types,
     msiobj_release(&view->hdr);
 
 done:
-    msi_free(prelude);
-    msi_free(columns_sql);
-    msi_free(postlude);
-    msi_free(create_sql);
+    free(prelude);
+    free(columns_sql);
+    free(postlude);
+    free(create_sql);
     return r;
 }
 
@@ -625,7 +625,7 @@ static LPWSTR msi_import_stream_filename(LPCWSTR path, LPCWSTR name)
     LPWSTR fullname, ptr;
 
     len = lstrlenW(path) + lstrlenW(name) + 1;
-    fullname = msi_alloc(len*sizeof(WCHAR));
+    fullname = malloc(len * sizeof(WCHAR));
     if (!fullname)
        return NULL;
 
@@ -635,7 +635,7 @@ static LPWSTR msi_import_stream_filename(LPCWSTR path, LPCWSTR name)
     ptr = wcsrchr(fullname, '.');
     if (!ptr)
     {
-        msi_free (fullname);
+        free(fullname);
         return NULL;
     }
     *ptr++ = '\\';
@@ -672,7 +672,7 @@ static UINT construct_record(DWORD num_columns, LPWSTR *types,
                         return ERROR_FUNCTION_FAILED;
 
                     r = MSI_RecordSetStreamFromFileW(*rec, i + 1, file);
-                    msi_free (file);
+                    free (file);
                     if (r != ERROR_SUCCESS)
                         return ERROR_FUNCTION_FAILED;
                 }
@@ -742,7 +742,7 @@ static UINT MSI_DatabaseImport(MSIDATABASE *db, LPCWSTR folder, LPCWSTR file)
         return ERROR_INVALID_PARAMETER;
 
     len = lstrlenW(folder) + lstrlenW(L"\\") + lstrlenW(file) + 1;
-    path = msi_alloc( len * sizeof(WCHAR) );
+    path = malloc( len * sizeof(WCHAR) );
     if (!path)
         return ERROR_OUTOFMEMORY;
 
@@ -753,7 +753,7 @@ static UINT MSI_DatabaseImport(MSIDATABASE *db, LPCWSTR folder, LPCWSTR file)
     data = msi_read_text_archive( path, &len );
     if (!data)
     {
-        msi_free(path);
+        free(path);
         return ERROR_FUNCTION_FAILED;
     }
 
@@ -775,7 +775,7 @@ static UINT MSI_DatabaseImport(MSIDATABASE *db, LPCWSTR folder, LPCWSTR file)
         goto done;
     }
 
-    records = msi_alloc(sizeof(WCHAR **));
+    records = malloc(sizeof(WCHAR **));
     if (!records)
     {
         r = ERROR_OUTOFMEMORY;
@@ -788,7 +788,7 @@ static UINT MSI_DatabaseImport(MSIDATABASE *db, LPCWSTR folder, LPCWSTR file)
         msi_parse_line( &ptr, &records[num_records], NULL, &len );
 
         num_records++;
-        temp_records = msi_realloc(records, (num_records + 1) * sizeof(WCHAR **));
+        temp_records = realloc(records, (num_records + 1) * sizeof(WCHAR **));
         if (!temp_records)
         {
             r = ERROR_OUTOFMEMORY;
@@ -822,16 +822,16 @@ static UINT MSI_DatabaseImport(MSIDATABASE *db, LPCWSTR folder, LPCWSTR file)
     }
 
 done:
-    msi_free(path);
-    msi_free(data);
-    msi_free(columns);
-    msi_free(types);
-    msi_free(labels);
+    free(path);
+    free(data);
+    free(columns);
+    free(types);
+    free(labels);
 
     for (i = 0; i < num_records; i++)
-        msi_free(records[i]);
+        free(records[i]);
 
-    msi_free(records);
+    free(records);
     return r;
 }
 
@@ -874,8 +874,8 @@ UINT WINAPI MsiDatabaseImportA( MSIHANDLE handle, const char *szFolder, const ch
     r = MsiDatabaseImportW( handle, path, file );
 
 end:
-    msi_free( path );
-    msi_free( file );
+    free( path );
+    free( file );
 
     return r;
 }
@@ -887,7 +887,7 @@ static UINT msi_export_field( HANDLE handle, MSIRECORD *row, UINT field )
     DWORD sz = 0x100;
     UINT r;
 
-    buffer = msi_alloc( sz );
+    buffer = malloc( sz );
     if (!buffer)
         return ERROR_OUTOFMEMORY;
 
@@ -897,10 +897,10 @@ static UINT msi_export_field( HANDLE handle, MSIRECORD *row, UINT field )
         char *tmp;
 
         sz++; /* leave room for NULL terminator */
-        tmp = msi_realloc( buffer, sz );
+        tmp = realloc( buffer, sz );
         if (!tmp)
         {
-            msi_free( buffer );
+            free( buffer );
             return ERROR_OUTOFMEMORY;
         }
         buffer = tmp;
@@ -908,18 +908,18 @@ static UINT msi_export_field( HANDLE handle, MSIRECORD *row, UINT field )
         r = MSI_RecordGetStringA( row, field, buffer, &sz );
         if (r != ERROR_SUCCESS)
         {
-            msi_free( buffer );
+            free( buffer );
             return r;
         }
     }
     else if (r != ERROR_SUCCESS)
     {
-        msi_free( buffer );
+        free( buffer );
         return r;
     }
 
     ret = WriteFile( handle, buffer, sz, &sz, NULL );
-    msi_free( buffer );
+    free( buffer );
     return ret ? ERROR_SUCCESS : ERROR_FUNCTION_FAILED;
 }
 
@@ -937,13 +937,13 @@ static UINT msi_export_stream( const WCHAR *folder, const WCHAR *table, MSIRECOR
         return r;
 
     len = sz + lstrlenW( folder ) + lstrlenW( table ) + ARRAY_SIZE( L"%s\\%s" ) + 1;
-    if (!(path = msi_alloc( len * sizeof(WCHAR) )))
+    if (!(path = malloc( len * sizeof(WCHAR) )))
         return ERROR_OUTOFMEMORY;
 
     len = swprintf( path, len, L"%s\\%s", folder, table );
     if (!CreateDirectoryW( path, NULL ) && GetLastError() != ERROR_ALREADY_EXISTS)
     {
-        msi_free( path );
+        free( path );
         return ERROR_FUNCTION_FAILED;
     }
 
@@ -951,7 +951,7 @@ static UINT msi_export_stream( const WCHAR *folder, const WCHAR *table, MSIRECOR
     lstrcpyW( path + len, stream );
     file = CreateFileW( path, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
                         NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
-    msi_free( path );
+    free( path );
     if (file == INVALID_HANDLE_VALUE)
         return ERROR_FUNCTION_FAILED;
 
@@ -1058,7 +1058,7 @@ static UINT MSI_DatabaseExport( MSIDATABASE *db, LPCWSTR table, LPCWSTR folder,
         return ERROR_INVALID_PARAMETER;
 
     len = lstrlenW(folder) + lstrlenW(file) + 2;
-    filename = msi_alloc(len * sizeof (WCHAR));
+    filename = malloc(len * sizeof(WCHAR));
     if (!filename)
         return ERROR_OUTOFMEMORY;
 
@@ -1068,7 +1068,7 @@ static UINT MSI_DatabaseExport( MSIDATABASE *db, LPCWSTR table, LPCWSTR folder,
 
     handle = CreateFileW( filename, GENERIC_READ | GENERIC_WRITE, 0,
                           NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
-    msi_free( filename );
+    free( filename );
     if (handle == INVALID_HANDLE_VALUE)
         return ERROR_FUNCTION_FAILED;
 
@@ -1186,9 +1186,9 @@ UINT WINAPI MsiDatabaseExportA( MSIHANDLE handle, const char *szTable, const cha
     r = MsiDatabaseExportW( handle, table, path, file );
 
 end:
-    msi_free( table );
-    msi_free( path );
-    msi_free( file );
+    free( table );
+    free( path );
+    free( file );
 
     return r;
 }
@@ -1203,7 +1203,7 @@ UINT WINAPI MsiDatabaseMergeA( MSIHANDLE hDatabase, MSIHANDLE hDatabaseMerge, co
     table = strdupAtoW(szTableName);
     r = MsiDatabaseMergeW(hDatabase, hDatabaseMerge, table);
 
-    msi_free(table);
+    free(table);
     return r;
 }
 
@@ -1367,7 +1367,7 @@ static LPWSTR get_key_value(MSIQUERY *view, LPCWSTR key, MSIRECORD *rec)
     {
         str = msi_dup_record_field(colnames, ++i);
         cmp = wcscmp( key, str );
-        msi_free(str);
+        free(str);
     } while (cmp);
 
     msiobj_release(&colnames->hdr);
@@ -1381,7 +1381,7 @@ static LPWSTR get_key_value(MSIQUERY *view, LPCWSTR key, MSIRECORD *rec)
     {
         /* quote string record fields */
         sz += 2;
-        val = msi_alloc(sz * sizeof(WCHAR));
+        val = malloc(sz * sizeof(WCHAR));
         if (!val)
             return NULL;
 
@@ -1392,7 +1392,7 @@ static LPWSTR get_key_value(MSIQUERY *view, LPCWSTR key, MSIRECORD *rec)
     else
     {
         /* do not quote integer record fields */
-        val = msi_alloc(sz * sizeof(WCHAR));
+        val = malloc(sz * sizeof(WCHAR));
         if (!val)
             return NULL;
 
@@ -1402,7 +1402,7 @@ static LPWSTR get_key_value(MSIQUERY *view, LPCWSTR key, MSIRECORD *rec)
     if (r != ERROR_SUCCESS)
     {
         ERR("failed to get string!\n");
-        msi_free(val);
+        free(val);
         return NULL;
     }
 
@@ -1422,7 +1422,7 @@ static LPWSTR create_diff_row_query(MSIDATABASE *merge, MSIQUERY *view,
     if (r != ERROR_SUCCESS)
         return NULL;
 
-    clause = msi_alloc_zero(sizeof(WCHAR));
+    clause = calloc(1, sizeof(WCHAR));
     if (!clause)
         goto done;
 
@@ -1440,26 +1440,26 @@ static LPWSTR create_diff_row_query(MSIDATABASE *merge, MSIQUERY *view,
 
         oldsize = size;
         size += lstrlenW(setptr) + lstrlenW(key) + lstrlenW(val) - 4;
-        clause = msi_realloc(clause, size * sizeof (WCHAR));
+        clause = realloc(clause, size * sizeof(WCHAR));
         if (!clause)
         {
-            msi_free(val);
+            free(val);
             goto done;
         }
 
         swprintf(clause + oldsize - 1, size - (oldsize - 1), setptr, key, val);
-        msi_free(val);
+        free(val);
     }
 
     size = lstrlenW(L"SELECT * FROM `%s` WHERE %s") + lstrlenW(table) + lstrlenW(clause) + 1;
-    query = msi_alloc(size * sizeof(WCHAR));
+    query = malloc(size * sizeof(WCHAR));
     if (!query)
         goto done;
 
     swprintf(query, size, L"SELECT * FROM `%s` WHERE %s", table, clause);
 
 done:
-    msi_free(clause);
+    free(clause);
     msiobj_release(&keys->hdr);
     return query;
 }
@@ -1500,7 +1500,7 @@ static UINT merge_diff_row(MSIRECORD *rec, LPVOID param)
         r = ERROR_SUCCESS;
     }
 
-    mergerow = msi_alloc(sizeof(MERGEROW));
+    mergerow = malloc(sizeof(MERGEROW));
     if (!mergerow)
     {
         r = ERROR_OUTOFMEMORY;
@@ -1511,14 +1511,14 @@ static UINT merge_diff_row(MSIRECORD *rec, LPVOID param)
     if (!mergerow->data)
     {
         r = ERROR_OUTOFMEMORY;
-        msi_free(mergerow);
+        free(mergerow);
         goto done;
     }
 
     list_add_tail(&table->rows, &mergerow->entry);
 
 done:
-    msi_free(query);
+    free(query);
     msiobj_release(&row->hdr);
     msiobj_release(&dbview->hdr);
     return r;
@@ -1535,7 +1535,7 @@ static UINT msi_get_table_labels(MSIDATABASE *db, LPCWSTR table, LPWSTR **labels
 
     count = MSI_RecordGetFieldCount(prec);
     *numlabels = count + 1;
-    *labels = msi_alloc((*numlabels)*sizeof(LPWSTR));
+    *labels = malloc((*numlabels) * sizeof(WCHAR *));
     if (!*labels)
     {
         r = ERROR_OUTOFMEMORY;
@@ -1563,7 +1563,7 @@ static UINT msi_get_query_columns(MSIQUERY *query, LPWSTR **columns, DWORD *numc
         return r;
 
     count = MSI_RecordGetFieldCount(prec);
-    *columns = msi_alloc(count*sizeof(LPWSTR));
+    *columns = malloc(count * sizeof(WCHAR *));
     if (!*columns)
     {
         r = ERROR_OUTOFMEMORY;
@@ -1592,7 +1592,7 @@ static UINT msi_get_query_types(MSIQUERY *query, LPWSTR **types, DWORD *numtypes
         return r;
 
     count = MSI_RecordGetFieldCount(prec);
-    *types = msi_alloc(count*sizeof(LPWSTR));
+    *types = malloc(count * sizeof(WCHAR *));
     if (!*types)
     {
         r = ERROR_OUTOFMEMORY;
@@ -1620,7 +1620,7 @@ static void merge_free_rows(MERGETABLE *table)
 
         list_remove(&row->entry);
         msiobj_release(&row->data->hdr);
-        msi_free(row);
+        free(row);
     }
 }
 
@@ -1631,31 +1631,31 @@ static void free_merge_table(MERGETABLE *table)
     if (table->labels != NULL)
     {
         for (i = 0; i < table->numlabels; i++)
-            msi_free(table->labels[i]);
+            free(table->labels[i]);
 
-        msi_free(table->labels);
+        free(table->labels);
     }
 
     if (table->columns != NULL)
     {
         for (i = 0; i < table->numcolumns; i++)
-            msi_free(table->columns[i]);
+            free(table->columns[i]);
 
-        msi_free(table->columns);
+        free(table->columns);
     }
 
     if (table->types != NULL)
     {
         for (i = 0; i < table->numtypes; i++)
-            msi_free(table->types[i]);
+            free(table->types[i]);
 
-        msi_free(table->types);
+        free(table->types);
     }
 
-    msi_free(table->name);
+    free(table->name);
     merge_free_rows(table);
 
-    msi_free(table);
+    free(table);
 }
 
 static UINT msi_get_merge_table (MSIDATABASE *db, LPCWSTR name, MERGETABLE **ptable)
@@ -1664,7 +1664,7 @@ static UINT msi_get_merge_table (MSIDATABASE *db, LPCWSTR name, MERGETABLE **pta
     MERGETABLE *table;
     MSIQUERY *mergeview = NULL;
 
-    table = msi_alloc_zero(sizeof(MERGETABLE));
+    table = calloc(1, sizeof(MERGETABLE));
     if (!table)
     {
        *ptable = NULL;
diff --git a/dlls/msi/delete.c b/dlls/msi/delete.c
index c101b56c2310..e0dafdd70686 100644
--- a/dlls/msi/delete.c
+++ b/dlls/msi/delete.c
@@ -159,7 +159,7 @@ static UINT DELETE_delete( struct tagMSIVIEW *view )
     if( dv->table )
         dv->table->ops->delete( dv->table );
 
-    msi_free( dv );
+    free( dv );
 
     return ERROR_SUCCESS;
 }
@@ -193,7 +193,7 @@ UINT DELETE_CreateView( MSIDATABASE *db, MSIVIEW **view, MSIVIEW *table )
 
     TRACE("%p\n", dv );
 
-    dv = msi_alloc_zero( sizeof *dv );
+    dv = calloc( 1, sizeof *dv );
     if( !dv )
         return ERROR_FUNCTION_FAILED;
 
diff --git a/dlls/msi/dialog.c b/dlls/msi/dialog.c
index d5d0fd3f20dd..e5a2208cb6fc 100644
--- a/dlls/msi/dialog.c
+++ b/dlls/msi/dialog.c
@@ -146,14 +146,14 @@ static LPWSTR msi_get_window_text( HWND hwnd )
     LPWSTR buf;
 
     sz = 0x20;
-    buf = msi_alloc( sz*sizeof(WCHAR) );
+    buf = malloc( sz * sizeof(WCHAR) );
     while ( buf )
     {
         r = GetWindowTextW( hwnd, buf, sz );
         if ( r < (sz - 1) )
             break;
         sz *= 2;
-        buf = msi_realloc( buf, sz*sizeof(WCHAR) );
+        buf = realloc( buf, sz * sizeof(WCHAR) );
     }
 
     return buf;
@@ -265,7 +265,7 @@ static LPWSTR msi_dialog_get_style( LPCWSTR p, LPCWSTR *rest )
     *rest = ++q;
     len = q - p;
 
-    ret = msi_alloc( len*sizeof(WCHAR) );
+    ret = malloc( len * sizeof(WCHAR) );
     if( !ret )
         return ret;
     memcpy( ret, p, len*sizeof(WCHAR) );
@@ -284,7 +284,7 @@ static UINT msi_dialog_add_font( MSIRECORD *rec, LPVOID param )
 
     /* create a font and add it to the list */
     name = MSI_RecordGetString( rec, 1 );
-    font = msi_alloc( FIELD_OFFSET( msi_font, name[lstrlenW( name ) + 1] ));
+    font = malloc( offsetof( msi_font, name[wcslen( name ) + 1] ) );
     lstrcpyW( font->name, name );
     list_add_head( &dialog->fonts, &font->entry );
 
@@ -362,19 +362,19 @@ static void msi_destroy_control( msi_control *t )
 {
     list_remove( &t->entry );
     /* leave dialog->hwnd - destroying parent destroys child windows */
-    msi_free( t->property );
-    msi_free( t->value );
+    free( t->property );
+    free( t->value );
     if( t->hBitmap )
         DeleteObject( t->hBitmap );
     if( t->hIcon )
         DestroyIcon( t->hIcon );
     if ( t->hImageList )
         ImageList_Destroy( t->hImageList );
-    msi_free( t->tabnext );
-    msi_free( t->type );
+    free( t->tabnext );
+    free( t->type );
     if (t->hDll)
         FreeLibrary( t->hDll );
-    msi_free( t );
+    free( t );
 }
 
 static msi_control *dialog_create_window( msi_dialog *dialog, MSIRECORD *rec, DWORD exstyle,
@@ -388,7 +388,7 @@ static msi_control *dialog_create_window( msi_dialog *dialog, MSIRECORD *rec, DW
 
     style |= WS_CHILD;
 
-    control = msi_alloc( FIELD_OFFSET( msi_control, name[lstrlenW( name ) + 1] ));
+    control = malloc( offsetof( msi_control, name[wcslen( name ) + 1] ) );
     if (!control)
         return NULL;
 
@@ -433,8 +433,8 @@ static msi_control *dialog_create_window( msi_dialog *dialog, MSIRECORD *rec, DW
     msi_dialog_set_font( dialog, control->hwnd,
                          font ? font : dialog->default_font );
 
-    msi_free( title_font );
-    msi_free( font );
+    free( title_font );
+    free( font );
 
     return control;
 }
@@ -475,7 +475,7 @@ static HANDLE msi_load_image( MSIDATABASE *db, LPCWSTR name, UINT type,
     }
     DeleteFileW( tmp );
 
-    msi_free( tmp );
+    free( tmp );
     return himage;
 }
 
@@ -578,8 +578,8 @@ static void dialog_handle_event( msi_dialog *dialog, const WCHAR *control,
 
         SetWindowTextW( ctrl->hwnd, text );
 
-        msi_free( font );
-        msi_free( text_fmt );
+        free( font );
+        free( text_fmt );
         msi_dialog_check_messages( NULL );
     }
     else if( !wcscmp( attribute, L"Progress" ) )
@@ -648,7 +648,7 @@ static void dialog_handle_event( msi_dialog *dialog, const WCHAR *control,
         LPWSTR path = msi_dialog_dup_property( dialog, ctrl->property, indirect );
         if (!path) return;
         SetWindowTextW( ctrl->hwnd, path );
-        msi_free(path);
+        free( path );
     }
     else
     {
@@ -675,7 +675,7 @@ static void event_subscribe( msi_dialog *dialog, const WCHAR *event, const WCHAR
             return;
         };
     }
-    if (!(sub = msi_alloc( sizeof(*sub) ))) return;
+    if (!(sub = malloc( sizeof(*sub) ))) return;
     sub->dialog    = dialog;
     sub->event     = wcsdup( event );
     sub->control   = wcsdup( control );
@@ -793,7 +793,7 @@ MSIText_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
         msi_text_on_settext( hWnd );
         break;
     case WM_NCDESTROY:
-        msi_free( info );
+        free( info );
         RemovePropW( hWnd, L"MSIDATA" );
         break;
     }
@@ -814,7 +814,7 @@ static UINT msi_dialog_text_control( msi_dialog *dialog, MSIRECORD *rec )
     if( !control )
         return ERROR_FUNCTION_FAILED;
 
-    info = msi_alloc( sizeof *info );
+    info = malloc( sizeof *info );
     if( !info )
         return ERROR_SUCCESS;
 
@@ -826,7 +826,7 @@ static UINT msi_dialog_text_control( msi_dialog *dialog, MSIRECORD *rec )
     text = MSI_RecordGetString( rec, 10 );
     font_name = msi_dialog_get_style( text, &ptr );
     info->font = ( font_name ) ? msi_dialog_find_font( dialog, font_name ) : NULL;
-    msi_free( font_name );
+    free( font_name );
 
     info->attributes = MSI_RecordGetInteger( rec, 8 );
     if( info->attributes & msidbControlAttributesTransparent )
@@ -857,7 +857,7 @@ static WCHAR *msi_get_binary_name( MSIPACKAGE *package, MSIRECORD *rec )
     if (!*p++) return text;
 
     p = wcsdup( p );
-    msi_free( text );
+    free( text );
     return p;
 }
 
@@ -867,7 +867,7 @@ static UINT msi_dialog_set_property_event( msi_dialog *dialog, LPCWSTR event, LP
     UINT len;
 
     len = lstrlenW( event );
-    prop = msi_alloc( len * sizeof(WCHAR) );
+    prop = malloc( len * sizeof(WCHAR) );
     lstrcpyW( prop, &event[1] );
     p = wcschr( prop, ']' );
     if (p && (p[1] == 0 || p[1] == ' '))
@@ -876,10 +876,10 @@ static UINT msi_dialog_set_property_event( msi_dialog *dialog, LPCWSTR event, LP
         if (wcscmp( L"{}", arg )) deformat_string( dialog->package, arg, &arg_fmt );
         msi_dialog_set_property( dialog->package, prop, arg_fmt );
         msi_dialog_update_controls( dialog, prop );
-        msi_free( arg_fmt );
+        free( arg_fmt );
     }
     else ERR("Badly formatted property string - what happens?\n");
-    msi_free( prop );
+    free( prop );
     return ERROR_SUCCESS;
 }
 
@@ -894,8 +894,8 @@ static UINT msi_dialog_send_event( msi_dialog *dialog, LPCWSTR event, LPCWSTR ar
 
     dialog->event_handler( dialog, event_fmt, arg_fmt );
 
-    msi_free( event_fmt );
-    msi_free( arg_fmt );
+    free( event_fmt );
+    free( arg_fmt );
 
     return ERROR_SUCCESS;
 }
@@ -944,7 +944,7 @@ static UINT msi_dialog_button_handler( msi_dialog *dialog, msi_control *control,
     {
         r = dialog->pending_event( dialog, dialog->pending_argument );
 
-        msi_free( dialog->pending_argument );
+        free( dialog->pending_argument );
         dialog->pending_event = NULL;
         dialog->pending_argument = NULL;
     }
@@ -1064,7 +1064,7 @@ static UINT msi_dialog_button_control( msi_dialog *dialog, MSIRECORD *rec )
         else ERR("Failed to load bitmap %s\n", debugstr_w(name));
     }
 
-    msi_free( name );
+    free( name );
     return ERROR_SUCCESS;
 }
 
@@ -1081,7 +1081,7 @@ static LPWSTR msi_get_checkbox_value( msi_dialog *dialog, LPCWSTR prop )
     ret = msi_get_deformatted_field( dialog->package, rec, 2 );
     if( ret && !ret[0] )
     {
-        msi_free( ret );
+        free( ret );
         ret = NULL;
     }
     msiobj_release( &rec->hdr );
@@ -1091,7 +1091,7 @@ static LPWSTR msi_get_checkbox_value( msi_dialog *dialog, LPCWSTR prop )
     ret = msi_dup_property( dialog->package->db, prop );
     if( ret && !ret[0] )
     {
-        msi_free( ret );
+        free( ret );
         ret = NULL;
     }
 
@@ -1195,7 +1195,7 @@ static UINT msi_dialog_line_control( msi_dialog *dialog, MSIRECORD *rec )
 
     dialog_map_events( dialog, name );
 
-    control = msi_alloc( FIELD_OFFSET(msi_control, name[lstrlenW( name ) + 1] ));
+    control = malloc( offsetof( msi_control, name[wcslen( name ) + 1] ) );
     if (!control)
         return ERROR_OUTOFMEMORY;
 
@@ -1257,7 +1257,7 @@ MSIScrollText_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
     case WM_GETDLGCODE:
         return DLGC_WANTARROWS;
     case WM_NCDESTROY:
-        msi_free( info );
+        free( info );
         RemovePropW( hWnd, L"MSIDATA" );
         break;
     case WM_PAINT:
@@ -1306,7 +1306,7 @@ static void msi_scrolltext_add_text( msi_control *control, LPCWSTR text )
 
     SendMessageW( control->hwnd, EM_STREAMIN, SF_RTF, (LPARAM) &es );
 
-    msi_free( info.string );
+    free( info.string );
 }
 
 static UINT msi_dialog_scrolltext_control( msi_dialog *dialog, MSIRECORD *rec )
@@ -1317,7 +1317,7 @@ static UINT msi_dialog_scrolltext_control( msi_dialog *dialog, MSIRECORD *rec )
     LPCWSTR text;
     DWORD style;
 
-    info = msi_alloc( sizeof *info );
+    info = malloc( sizeof *info );
     if (!info)
         return ERROR_FUNCTION_FAILED;
 
@@ -1329,7 +1329,7 @@ static UINT msi_dialog_scrolltext_control( msi_dialog *dialog, MSIRECORD *rec )
     if (!control)
     {
         FreeLibrary( hRichedit );
-        msi_free( info );
+        free( info );
         return ERROR_FUNCTION_FAILED;
     }
 
@@ -1382,7 +1382,7 @@ static UINT msi_dialog_bitmap_control( msi_dialog *dialog, MSIRECORD *rec )
     else
         ERR("Failed to load bitmap %s\n", debugstr_w(name));
 
-    msi_free( name );
+    free( name );
 
     return ERROR_SUCCESS;
 }
@@ -1405,7 +1405,7 @@ static UINT msi_dialog_icon_control( msi_dialog *dialog, MSIRECORD *rec )
         SendMessageW( control->hwnd, STM_SETICON, (WPARAM) control->hIcon, 0 );
     else
         ERR("Failed to load bitmap %s\n", debugstr_w(name));
-    msi_free( name );
+    free( name );
     return ERROR_SUCCESS;
 }
 
@@ -1439,9 +1439,9 @@ static LRESULT WINAPI MSIComboBox_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LP
     {
     case WM_NCDESTROY:
         for (j = 0; j < info->num_items; j++)
-            msi_free( info->items[j] );
-        msi_free( info->items );
-        msi_free( info );
+            free( info->items[j] );
+        free( info->items );
+        free( info );
         RemovePropW( hWnd, L"MSIDATA" );
         break;
     }
@@ -1487,7 +1487,7 @@ static UINT msi_combobox_add_items( struct msi_combobox_info *info, LPCWSTR prop
         return r;
     }
     info->num_items = count;
-    info->items = msi_alloc( sizeof(*info->items) * count );
+    info->items = malloc( sizeof(*info->items) * count );
 
     r = MSI_IterateRecords( view, NULL, msi_combobox_add_item, info );
     msiobj_release( &view->hdr );
@@ -1565,7 +1565,7 @@ static UINT msi_dialog_combobox_handler( msi_dialog *dialog, msi_control *contro
     msi_dialog_evaluate_control_conditions( info->dialog );
 
     if (index == CB_ERR)
-        msi_free( value );
+        free( value );
 
     return ERROR_SUCCESS;
 }
@@ -1602,7 +1602,7 @@ static void msi_dialog_combobox_update( msi_dialog *dialog, msi_control *control
         SetWindowTextW( control->hwnd, value );
     }
 
-    msi_free(value);
+    free( value );
 }
 
 static UINT msi_dialog_combo_control( msi_dialog *dialog, MSIRECORD *rec )
@@ -1612,7 +1612,7 @@ static UINT msi_dialog_combo_control( msi_dialog *dialog, MSIRECORD *rec )
     DWORD attributes, style;
     LPCWSTR prop;
 
-    info = msi_alloc( sizeof *info );
+    info = malloc( sizeof *info );
     if (!info)
         return ERROR_FUNCTION_FAILED;
 
@@ -1628,7 +1628,7 @@ static UINT msi_dialog_combo_control( msi_dialog *dialog, MSIRECORD *rec )
     control = msi_dialog_add_control( dialog, rec, WC_COMBOBOXW, style );
     if (!control)
     {
-        msi_free( info );
+        free( info );
         return ERROR_FUNCTION_FAILED;
     }
 
@@ -1666,7 +1666,7 @@ static UINT msi_dialog_edit_handler( msi_dialog *dialog, msi_control *control, W
 
     buf = msi_get_window_text( control->hwnd );
     msi_dialog_set_property( dialog->package, control->property, buf );
-    msi_free( buf );
+    free( buf );
 
     return ERROR_SUCCESS;
 }
@@ -1709,7 +1709,7 @@ static UINT msi_dialog_edit_control( msi_dialog *dialog, MSIRECORD *rec )
 
     val = msi_dup_property( dialog->package->db, control->property );
     SetWindowTextW( control->hwnd, val );
-    msi_free( val );
+    free( val );
     return ERROR_SUCCESS;
 }
 
@@ -1756,13 +1756,13 @@ static void msi_mask_control_change( struct msi_maskedit_info *info )
     LPWSTR val;
     UINT i, n, r;
 
-    val = msi_alloc( (info->num_chars+1)*sizeof(WCHAR) );
+    val = malloc( (info->num_chars + 1) * sizeof(WCHAR) );
     for( i=0, n=0; i<info->num_groups; i++ )
     {
         if (info->group[i].len == ~0u)
         {
             UINT len = SendMessageW( info->group[i].hwnd, WM_GETTEXTLENGTH, 0, 0 );
-            val = msi_realloc( val, (len + 1) * sizeof(WCHAR) );
+            val = realloc( val, (len + 1) * sizeof(WCHAR) );
             GetWindowTextW( info->group[i].hwnd, val, len + 1 );
         }
         else
@@ -1796,7 +1796,7 @@ static void msi_mask_control_change( struct msi_maskedit_info *info )
         msi_dialog_set_property( info->dialog->package, info->prop, val );
         msi_dialog_evaluate_control_conditions( info->dialog );
     }
-    msi_free( val );
+    free( val );
 }
 
 /* now move to the next control if necessary */
@@ -1843,8 +1843,8 @@ MSIMaskedEdit_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
         }
         break;
     case WM_NCDESTROY:
-        msi_free( info->prop );
-        msi_free( info );
+        free( info->prop );
+        free( info );
         RemovePropW( hWnd, L"MSIDATA" );
         break;
     }
@@ -1867,7 +1867,7 @@ msi_maskedit_set_text( struct msi_maskedit_info *info, LPCWSTR text )
             WCHAR *chunk = wcsdup( p );
             chunk[ info->group[i].len ] = 0;
             SetWindowTextW( info->group[i].hwnd, chunk );
-            msi_free( chunk );
+            free( chunk );
         }
         else
         {
@@ -1889,7 +1889,7 @@ static struct msi_maskedit_info * msi_dialog_parse_groups( LPCWSTR mask )
     if( !mask )
         return NULL;
 
-    info = msi_alloc_zero( sizeof *info );
+    info = calloc( 1, sizeof *info );
     if( !info )
         return info;
 
@@ -2045,15 +2045,15 @@ static UINT msi_dialog_maskedit_control( msi_dialog *dialog, MSIRECORD *rec )
         if( val )
         {
             msi_maskedit_set_text( info, val );
-            msi_free( val );
+            free( val );
         }
     }
 
 end:
     if( ret != ERROR_SUCCESS )
-        msi_free( info );
-    msi_free( font_mask );
-    msi_free( font );
+        free( info );
+    free( font_mask );
+    free( font );
     return ret;
 }
 
@@ -2092,7 +2092,7 @@ static WCHAR *get_path_property( msi_dialog *dialog, msi_control *control )
     BOOL indirect = control->attributes & msidbControlAttributesIndirect;
     if (!(prop = msi_dialog_dup_property( dialog, control->property, indirect ))) return NULL;
     path = msi_dialog_dup_property( dialog, prop, TRUE );
-    msi_free( prop );
+    free( prop );
     return path;
 }
 
@@ -2106,7 +2106,7 @@ static void msi_dialog_update_pathedit( msi_dialog *dialog, msi_control *control
     if (!(path = get_path_property( dialog, control ))) return;
     SetWindowTextW( control->hwnd, path );
     SendMessageW( control->hwnd, EM_SETSEL, 0, -1 );
-    msi_free( path );
+    free( path );
 }
 
 /* FIXME: test when this should fail */
@@ -2151,8 +2151,8 @@ static BOOL msi_dialog_onkillfocus( msi_dialog *dialog, msi_control *control )
     TRACE("edit %s contents changed, set %s\n", debugstr_w(control->name),
           debugstr_w(prop));
 
-    msi_free( buf );
-    msi_free( prop );
+    free( buf );
+    free( prop );
 
     return valid;
 }
@@ -2175,7 +2175,7 @@ static LRESULT WINAPI MSIPathEdit_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LP
 
     if ( msg == WM_NCDESTROY )
     {
-        msi_free( info );
+        free( info );
         RemovePropW( hWnd, L"MSIDATA" );
     }
 
@@ -2188,7 +2188,7 @@ static UINT msi_dialog_pathedit_control( msi_dialog *dialog, MSIRECORD *rec )
     msi_control *control;
     LPCWSTR prop;
 
-    info = msi_alloc( sizeof *info );
+    info = malloc( sizeof *info );
     if (!info)
         return ERROR_FUNCTION_FAILED;
 
@@ -2328,7 +2328,7 @@ static UINT msi_dialog_radiogroup_control( msi_dialog *dialog, MSIRECORD *rec )
 
     r = MSI_IterateRecords( view, 0, msi_dialog_create_radiobutton, &group );
     msiobj_release( &view->hdr );
-    msi_free( group.propval );
+    free( group.propval );
     return r;
 }
 
@@ -2483,7 +2483,7 @@ MSISelectionTree_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
     switch( msg )
     {
     case WM_NCDESTROY:
-        msi_free( info );
+        free( info );
         RemovePropW( hWnd, L"MSIDATA" );
         break;
     }
@@ -2644,7 +2644,7 @@ static UINT msi_dialog_selection_tree( msi_dialog *dialog, MSIRECORD *rec )
     DWORD style;
     struct msi_selection_tree_info *info;
 
-    info = msi_alloc( sizeof *info );
+    info = malloc( sizeof *info );
     if (!info)
         return ERROR_FUNCTION_FAILED;
 
@@ -2654,7 +2654,7 @@ static UINT msi_dialog_selection_tree( msi_dialog *dialog, MSIRECORD *rec )
     control = msi_dialog_add_control( dialog, rec, WC_TREEVIEWW, style );
     if (!control)
     {
-        msi_free(info);
+        free(info);
         return ERROR_FUNCTION_FAILED;
     }
 
@@ -2725,9 +2725,9 @@ static LRESULT WINAPI MSIListBox_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPA
     {
     case WM_NCDESTROY:
         for (j = 0; j < info->num_items; j++)
-            msi_free( info->items[j] );
-        msi_free( info->items );
-        msi_free( info );
+            free( info->items[j] );
+        free( info->items );
+        free( info );
         RemovePropW( hWnd, L"MSIDATA" );
         break;
     }
@@ -2772,7 +2772,7 @@ static UINT msi_listbox_add_items( struct msi_listbox_info *info, LPCWSTR proper
         return r;
     }
     info->num_items = count;
-    info->items = msi_alloc( sizeof(*info->items) * count );
+    info->items = malloc( sizeof(*info->items) * count );
 
     r = MSI_IterateRecords( view, NULL, msi_listbox_add_item, info );
     msiobj_release( &view->hdr );
@@ -2806,7 +2806,7 @@ static UINT msi_dialog_list_box( msi_dialog *dialog, MSIRECORD *rec )
     DWORD attributes, style;
     LPCWSTR prop;
 
-    info = msi_alloc( sizeof *info );
+    info = malloc( sizeof *info );
     if (!info)
         return ERROR_FUNCTION_FAILED;
 
@@ -2818,7 +2818,7 @@ static UINT msi_dialog_list_box( msi_dialog *dialog, MSIRECORD *rec )
     control = msi_dialog_add_control( dialog, rec, WC_LISTBOXW, style );
     if (!control)
     {
-        msi_free(info);
+        free(info);
         return ERROR_FUNCTION_FAILED;
     }
 
@@ -2858,7 +2858,7 @@ static void msi_dialog_update_directory_combo( msi_dialog *dialog, msi_control *
     SendMessageW( control->hwnd, CB_INSERTSTRING, 0, (LPARAM)path );
     SendMessageW( control->hwnd, CB_SETCURSEL, 0, 0 );
 
-    msi_free( path );
+    free( path );
 }
 
 static UINT msi_dialog_directory_combo( msi_dialog *dialog, MSIRECORD *rec )
@@ -2905,7 +2905,7 @@ static void msi_dialog_update_directory_list( msi_dialog *dialog, msi_control *c
     file = FindFirstFileW( dir_spec, &wfd );
     if (file == INVALID_HANDLE_VALUE)
     {
-        msi_free( path );
+        free( path );
         return;
     }
 
@@ -2926,7 +2926,7 @@ static void msi_dialog_update_directory_list( msi_dialog *dialog, msi_control *c
         SendMessageW( control->hwnd, LVM_INSERTITEMW, 0, (LPARAM)&item );
     } while ( FindNextFileW( file, &wfd ) );
 
-    msi_free( path );
+    free( path );
     FindClose( file );
 }
 
@@ -2952,8 +2952,8 @@ static UINT msi_dialog_directorylist_up( msi_dialog *dialog )
     msi_dialog_update_directory_combo( dialog, NULL );
     msi_dialog_update_pathedit( dialog, NULL );
 
-    msi_free( path );
-    msi_free( prop );
+    free( path );
+    free( prop );
 
     return ERROR_SUCCESS;
 }
@@ -2965,7 +2965,7 @@ static WCHAR *get_unique_folder_name( const WCHAR *root, int *ret_len )
 
     len = LoadStringW( msi_hInstance, IDS_NEWFOLDER, newfolder, ARRAY_SIZE(newfolder) );
     len += lstrlenW(root) + 1;
-    if (!(path = msi_alloc( (len + 4) * sizeof(WCHAR) ))) return NULL;
+    if (!(path = malloc( (len + 4) * sizeof(WCHAR) ))) return NULL;
     lstrcpyW( path, root );
     lstrcatW( path, newfolder );
 
@@ -2974,7 +2974,7 @@ static WCHAR *get_unique_folder_name( const WCHAR *root, int *ret_len )
         if (GetFileAttributesW( path ) == INVALID_FILE_ATTRIBUTES) break;
         if (count > 99)
         {
-            msi_free( path );
+            free( path );
             return NULL;
         }
         swprintf( path, len + 4, L"%s%s %u", root, newfolder, count++ );
@@ -3006,8 +3006,8 @@ static UINT msi_dialog_directorylist_new( msi_dialog *dialog )
     SendMessageW( control->hwnd, LVM_ENSUREVISIBLE, index, 0 );
     SendMessageW( control->hwnd, LVM_EDITLABELW, index, -1 );
 
-    msi_free( path );
-    msi_free( item.pszText );
+    free( path );
+    free( item.pszText );
     return ERROR_SUCCESS;
 }
 
@@ -3052,10 +3052,10 @@ static UINT msi_dialog_dirlist_handler( msi_dialog *dialog, msi_control *control
     prop = msi_dialog_dup_property( dialog, control->property, indirect );
     path = msi_dialog_dup_property( dialog, prop, TRUE );
 
-    if (!(new_path = msi_alloc( (lstrlenW(path) + lstrlenW(text) + 2) * sizeof(WCHAR) )))
+    if (!(new_path = malloc( (wcslen(path) + wcslen(text) + 2) * sizeof(WCHAR) )))
     {
-        msi_free( prop );
-        msi_free( path );
+        free( prop );
+        free( path );
         return ERROR_OUTOFMEMORY;
     }
     lstrcpyW( new_path, path );
@@ -3069,9 +3069,9 @@ static UINT msi_dialog_dirlist_handler( msi_dialog *dialog, msi_control *control
     msi_dialog_update_directory_combo( dialog, NULL );
     msi_dialog_update_pathedit( dialog, NULL );
 
-    msi_free( prop );
-    msi_free( path );
-    msi_free( new_path );
+    free( prop );
+    free( path );
+    free( new_path );
 
     return ERROR_SUCCESS;
 }
@@ -3140,7 +3140,7 @@ static void msi_dialog_vcl_add_columns( msi_dialog *dialog, msi_control *control
         if (!(end = wcschr( begin, '}' )))
             return;
 
-        num = msi_alloc( (end-begin+1)*sizeof(WCHAR) );
+        num = malloc( (end - begin + 1) * sizeof(WCHAR) );
         if (!num)
             return;
 
@@ -3151,7 +3151,7 @@ static void msi_dialog_vcl_add_columns( msi_dialog *dialog, msi_control *control
         if ( !num[0] || !wcscmp( num, L"0" ) )
         {
             count++;
-            msi_free( num );
+            free( num );
             continue;
         }
 
@@ -3159,7 +3159,7 @@ static void msi_dialog_vcl_add_columns( msi_dialog *dialog, msi_control *control
          * if a width is invalid, all remaining columns are hidden
          */
         if ( !wcsncmp( num, L"-", 1 ) || !str_is_number( num ) ) {
-            msi_free( num );
+            free( num );
             return;
         }
 
@@ -3169,8 +3169,8 @@ static void msi_dialog_vcl_add_columns( msi_dialog *dialog, msi_control *control
         lvc.pszText = msi_dialog_get_uitext( dialog, column_keys[count] );
 
         SendMessageW( control->hwnd,  LVM_INSERTCOLUMNW, count++, (LPARAM)&lvc );
-        msi_free( lvc.pszText );
-        msi_free( num );
+        free( lvc.pszText );
+        free( num );
     }
 }
 
@@ -3200,7 +3200,7 @@ static LONGLONG msi_vcl_get_cost( msi_dialog *dialog )
 
 static void msi_dialog_vcl_add_drives( msi_dialog *dialog, msi_control *control )
 {
-    ULARGE_INTEGER total, free;
+    ULARGE_INTEGER total, unused;
     LONGLONG difference, cost;
     WCHAR size_text[MAX_PATH];
     WCHAR cost_text[MAX_PATH];
@@ -3215,7 +3215,7 @@ static void msi_dialog_vcl_add_drives( msi_dialog *dialog, msi_control *control
     size = GetLogicalDriveStringsW( 0, NULL );
     if ( !size ) return;
 
-    drives = msi_alloc( (size + 1) * sizeof(WCHAR) );
+    drives = malloc( (size + 1) * sizeof(WCHAR) );
     if ( !drives ) return;
 
     GetLogicalDriveStringsW( size, drives );
@@ -3237,8 +3237,8 @@ static void msi_dialog_vcl_add_drives( msi_dialog *dialog, msi_control *control
         lvitem.cchTextMax = lstrlenW(ptr) + 1;
         SendMessageW( control->hwnd, LVM_INSERTITEMW, 0, (LPARAM)&lvitem );
 
-        GetDiskFreeSpaceExW(ptr, &free, &total, NULL);
-        difference = free.QuadPart - cost;
+        GetDiskFreeSpaceExW(ptr, &unused, &total, NULL);
+        difference = unused.QuadPart - cost;
 
         StrFormatByteSizeW(total.QuadPart, size_text, MAX_PATH);
         lvitem.iSubItem = 1;
@@ -3246,7 +3246,7 @@ static void msi_dialog_vcl_add_drives( msi_dialog *dialog, msi_control *control
         lvitem.cchTextMax = lstrlenW(size_text) + 1;
         SendMessageW( control->hwnd, LVM_SETITEMW, 0, (LPARAM)&lvitem );
 
-        StrFormatByteSizeW(free.QuadPart, size_text, MAX_PATH);
+        StrFormatByteSizeW(unused.QuadPart, size_text, MAX_PATH);
         lvitem.iSubItem = 2;
         lvitem.pszText = size_text;
         lvitem.cchTextMax = lstrlenW(size_text) + 1;
@@ -3267,7 +3267,7 @@ static void msi_dialog_vcl_add_drives( msi_dialog *dialog, msi_control *control
         i++;
     }
 
-    msi_free( drives );
+    free( drives );
 }
 
 static UINT msi_dialog_volumecost_list( msi_dialog *dialog, MSIRECORD *rec )
@@ -3315,7 +3315,7 @@ static UINT msi_dialog_volsel_handler( msi_dialog *dialog,
 
     msi_dialog_set_property( dialog->package, prop, text );
 
-    msi_free( prop );
+    free( prop );
     return ERROR_SUCCESS;
 }
 
@@ -3327,7 +3327,7 @@ static void msi_dialog_vsc_add_drives( msi_dialog *dialog, msi_control *control
     size = GetLogicalDriveStringsW( 0, NULL );
     if ( !size ) return;
 
-    drives = msi_alloc( (size + 1) * sizeof(WCHAR) );
+    drives = malloc( (size + 1) * sizeof(WCHAR) );
     if ( !drives ) return;
 
     GetLogicalDriveStringsW( size, drives );
@@ -3339,7 +3339,7 @@ static void msi_dialog_vsc_add_drives( msi_dialog *dialog, msi_control *control
         ptr += lstrlenW(ptr) + 1;
     }
 
-    msi_free( drives );
+    free( drives );
 }
 
 static UINT msi_dialog_volumeselect_combo( msi_dialog *dialog, MSIRECORD *rec )
@@ -3772,7 +3772,7 @@ static LRESULT msi_dialog_oncreate( HWND hwnd, LPCREATESTRUCTW cs )
 
     title = msi_get_deformatted_field( dialog->package, rec, 7 );
     SetWindowTextW( hwnd, title );
-    msi_free( title );
+    free( title );
 
     SetWindowPos( hwnd, 0, pos.left, pos.top,
                   pos.right - pos.left, pos.bottom - pos.top,
@@ -4005,7 +4005,7 @@ static msi_dialog *dialog_create( MSIPACKAGE *package, const WCHAR *name, msi_di
     if (!hMsiHiddenWindow) dialog_register_class();
 
     /* allocate the structure for the dialog to use */
-    dialog = msi_alloc_zero( FIELD_OFFSET( msi_dialog, name[lstrlenW( name ) + 1] ));
+    dialog = calloc( 1, offsetof( msi_dialog, name[wcslen( name ) + 1] ) );
     if( !dialog )
         return NULL;
     lstrcpyW( dialog->name, name );
@@ -4020,7 +4020,7 @@ static msi_dialog *dialog_create( MSIPACKAGE *package, const WCHAR *name, msi_di
     rec = msi_get_dialog_record( dialog );
     if( !rec )
     {
-        msi_free( dialog );
+        free( dialog );
         return NULL;
     }
     dialog->attributes = MSI_RecordGetInteger( rec, 6 );
@@ -4097,10 +4097,10 @@ static void dialog_do_preview( msi_dialog *dialog )
 
 static void free_subscriber( struct subscriber *sub )
 {
-    msi_free( sub->event );
-    msi_free( sub->control );
-    msi_free( sub->attribute );
-    msi_free( sub );
+    free( sub->event );
+    free( sub->control );
+    free( sub->attribute );
+    free( sub );
 }
 
 static void event_cleanup_subscriptions( MSIPACKAGE *package, const WCHAR *dialog )
@@ -4151,14 +4151,14 @@ void msi_dialog_destroy( msi_dialog *dialog )
     {
         list_remove( &font->entry );
         DeleteObject( font->hfont );
-        msi_free( font );
+        free( font );
     }
-    msi_free( dialog->default_font );
+    free( dialog->default_font );
 
-    msi_free( dialog->control_default );
-    msi_free( dialog->control_cancel );
+    free( dialog->control_default );
+    free( dialog->control_cancel );
     dialog->package = NULL;
-    msi_free( dialog );
+    free( dialog );
 }
 
 void msi_dialog_unregister_class( void )
@@ -4288,7 +4288,7 @@ UINT WINAPI MsiPreviewDialogA( MSIHANDLE hPreview, LPCSTR szDialogName )
             return ERROR_OUTOFMEMORY;
     }
     r = MsiPreviewDialogW( hPreview, strW );
-    msi_free( strW );
+    free( strW );
     return r;
 }
 
@@ -4371,7 +4371,7 @@ static UINT event_end_dialog( msi_dialog *dialog, const WCHAR *argument )
 static UINT pending_event_end_dialog( msi_dialog *dialog, const WCHAR *argument )
 {
     dialog->pending_event = event_end_dialog;
-    msi_free( dialog->pending_argument );
+    free( dialog->pending_argument );
     dialog->pending_argument = wcsdup( argument );
     return ERROR_SUCCESS;
 }
@@ -4389,7 +4389,7 @@ static UINT event_new_dialog( msi_dialog *dialog, const WCHAR *argument )
 static UINT pending_event_new_dialog( msi_dialog *dialog, const WCHAR *argument )
 {
     dialog->pending_event = event_new_dialog;
-    msi_free( dialog->pending_argument );
+    free( dialog->pending_argument );
     dialog->pending_argument = wcsdup( argument );
     return ERROR_SUCCESS;
 }
@@ -4414,7 +4414,7 @@ static UINT event_spawn_dialog( msi_dialog *dialog, const WCHAR *argument )
 static UINT pending_event_spawn_dialog( msi_dialog *dialog, const WCHAR *argument )
 {
     dialog->pending_event = event_spawn_dialog;
-    msi_free( dialog->pending_argument );
+    free( dialog->pending_argument );
     dialog->pending_argument = wcsdup( argument );
     return ERROR_SUCCESS;
 }
@@ -4505,9 +4505,9 @@ static UINT event_set_target_path( msi_dialog *dialog, const WCHAR *argument )
     {
         /* failure to set the path halts the executing of control events */
         r = MSI_SetTargetPathW( dialog->package, argument, path );
-        msi_free( path );
+        free( path );
     }
-    msi_free( &rec->hdr );
+    free( &rec->hdr );
     return r;
 }
 
@@ -4564,7 +4564,7 @@ INT ACTION_DialogBox( MSIPACKAGE *package, const WCHAR *dialog )
 
         package->next_dialog = NULL;
         r = event_do_dialog( package, name, NULL, TRUE );
-        msi_free( name );
+        free( name );
     }
     return r;
 }
diff --git a/dlls/msi/distinct.c b/dlls/msi/distinct.c
index b97b8c90efc6..23e74e17edca 100644
--- a/dlls/msi/distinct.c
+++ b/dlls/msi/distinct.c
@@ -67,7 +67,7 @@ static DISTINCTSET ** distinct_insert( DISTINCTSET **x, UINT val, UINT row )
     }
 
     /* nothing found, so add one */
-    *x = msi_alloc( sizeof (DISTINCTSET) );
+    *x = malloc( sizeof(DISTINCTSET) );
     if( *x )
     {
         (*x)->val = val;
@@ -85,7 +85,7 @@ static void distinct_free( DISTINCTSET *x )
     {
         DISTINCTSET *next = x->nextrow;
         distinct_free( x->nextcol );
-        msi_free( x );
+        free( x );
         x = next;
     }
 }
@@ -126,7 +126,7 @@ static UINT DISTINCT_execute( struct tagMSIVIEW *view, MSIRECORD *record )
     if( r != ERROR_SUCCESS )
         return r;
 
-    dv->translation = msi_alloc( r_count*sizeof(UINT) );
+    dv->translation = malloc( r_count * sizeof(UINT) );
     if( !dv->translation )
         return ERROR_FUNCTION_FAILED;
 
@@ -178,7 +178,7 @@ static UINT DISTINCT_close( struct tagMSIVIEW *view )
     if( !dv->table )
          return ERROR_FUNCTION_FAILED;
 
-    msi_free( dv->translation );
+    free( dv->translation );
     dv->translation = NULL;
     dv->row_count = 0;
 
@@ -240,9 +240,9 @@ static UINT DISTINCT_delete( struct tagMSIVIEW *view )
     if( dv->table )
         dv->table->ops->delete( dv->table );
 
-    msi_free( dv->translation );
+    free( dv->translation );
     msiobj_release( &dv->db->hdr );
-    msi_free( dv );
+    free( dv );
 
     return ERROR_SUCCESS;
 }
@@ -284,7 +284,7 @@ UINT DISTINCT_CreateView( MSIDATABASE *db, MSIVIEW **view, MSIVIEW *table )
         return r;
     }
 
-    dv = msi_alloc_zero( sizeof *dv );
+    dv = calloc( 1, sizeof *dv );
     if( !dv )
         return ERROR_FUNCTION_FAILED;
 
diff --git a/dlls/msi/drop.c b/dlls/msi/drop.c
index 89fac9dfc7c4..9c3aebba0eb5 100644
--- a/dlls/msi/drop.c
+++ b/dlls/msi/drop.c
@@ -87,7 +87,7 @@ static UINT DROP_delete( struct tagMSIVIEW *view )
     if( dv->table )
         dv->table->ops->delete( dv->table );
 
-    msi_free( dv );
+    free( dv );
 
     return ERROR_SUCCESS;
 }
@@ -122,14 +122,14 @@ UINT DROP_CreateView(MSIDATABASE *db, MSIVIEW **view, LPCWSTR name)
 
     TRACE("%p %s\n", view, debugstr_w(name));
 
-    dv = msi_alloc_zero(sizeof *dv);
+    dv = calloc(1, sizeof *dv);
     if(!dv)
         return ERROR_FUNCTION_FAILED;
 
     r = TABLE_CreateView(db, name, &dv->table);
     if (r != ERROR_SUCCESS)
     {
-        msi_free( dv );
+        free( dv );
         return r;
     }
 
diff --git a/dlls/msi/files.c b/dlls/msi/files.c
index b335a511339d..75075a37b5f2 100644
--- a/dlls/msi/files.c
+++ b/dlls/msi/files.c
@@ -175,24 +175,24 @@ VS_FIXEDFILEINFO *msi_get_disk_file_version( MSIPACKAGE *package, const WCHAR *f
     void *version;
 
     if (!(version_size = msi_get_file_version_info( package, filename, 0, NULL ))) return NULL;
-    if (!(version = msi_alloc( version_size ))) return NULL;
+    if (!(version = malloc( version_size ))) return NULL;
 
     msi_get_file_version_info( package, filename, version_size, version );
 
     if (!VerQueryValueW( version, L"\\", (void **)&ptr, &size ))
     {
-        msi_free( version );
+        free( version );
         return NULL;
     }
 
-    if (!(ret = msi_alloc( size )))
+    if (!(ret = malloc( size )))
     {
-        msi_free( version );
+        free( version );
         return NULL;
     }
 
     memcpy( ret, ptr, size );
-    msi_free( version );
+    free( version );
     return ret;
 }
 
@@ -214,7 +214,7 @@ BOOL msi_create_full_path( MSIPACKAGE *package, const WCHAR *path )
     WCHAR *new_path;
     int len;
 
-    if (!(new_path = msi_alloc( (lstrlenW( path ) + 1) * sizeof(WCHAR) ))) return FALSE;
+    if (!(new_path = malloc( (wcslen( path ) + 1) * sizeof(WCHAR) ))) return FALSE;
     lstrcpyW( new_path, path );
 
     while ((len = lstrlenW( new_path )) && new_path[len - 1] == '\\')
@@ -244,7 +244,7 @@ BOOL msi_create_full_path( MSIPACKAGE *package, const WCHAR *path )
         }
         new_path[len] = '\\';
     }
-    msi_free( new_path );
+    free( new_path );
     return ret;
 }
 
@@ -341,7 +341,7 @@ static msi_file_state calculate_install_state( MSIPACKAGE *package, MSIFILE *fil
                       HIWORD(file_version->dwFileVersionLS), LOWORD(file_version->dwFileVersionLS));
                 state = msifs_present;
             }
-            msi_free( file_version );
+            free( file_version );
             return state;
         }
         else if ((font_version = msi_get_font_file_version( package, file->TargetPath )))
@@ -358,7 +358,7 @@ static msi_file_state calculate_install_state( MSIPACKAGE *package, MSIFILE *fil
                       debugstr_w(file->File), debugstr_w(file->Version), debugstr_w(font_version));
                 state = msifs_present;
             }
-            msi_free( font_version );
+            free( font_version );
             return state;
         }
     }
@@ -446,13 +446,13 @@ static UINT copy_install_file(MSIPACKAGE *package, MSIFILE *file, LPWSTR source)
         if (!(pathW = wcsdup( file->TargetPath ))) return ERROR_OUTOFMEMORY;
         if ((p = wcsrchr(pathW, '\\'))) *p = 0;
         len = lstrlenW( pathW ) + 16;
-        if (!(tmpfileW = msi_alloc(len * sizeof(WCHAR))))
+        if (!(tmpfileW = malloc(len * sizeof(WCHAR))))
         {
-            msi_free( pathW );
+            free( pathW );
             return ERROR_OUTOFMEMORY;
         }
         if (!GetTempFileNameW( pathW, L"msi", 0, tmpfileW )) tmpfileW[0] = 0;
-        msi_free( pathW );
+        free( pathW );
 
         if (msi_copy_file( package, source, tmpfileW, FALSE ) &&
             msi_move_file( package, file->TargetPath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) &&
@@ -467,7 +467,7 @@ static UINT copy_install_file(MSIPACKAGE *package, MSIFILE *file, LPWSTR source)
             WARN("failed to schedule rename operation: %d)\n", gle);
             DeleteFileW( tmpfileW );
         }
-        msi_free(tmpfileW);
+        free(tmpfileW);
     }
 
     return gle;
@@ -547,10 +547,10 @@ WCHAR *msi_resolve_file_source( MSIPACKAGE *package, MSIFILE *file )
 
     if (file->LongName && msi_get_file_attributes( package, path ) == INVALID_FILE_ATTRIBUTES)
     {
-        msi_free( path );
+        free( path );
         path = msi_build_directory_name( 2, p, file->LongName );
     }
-    msi_free( p );
+    free( p );
     TRACE("file %s source resolves to %s\n", debugstr_w(file->File), debugstr_w(path));
     return path;
 }
@@ -574,7 +574,7 @@ UINT ACTION_InstallFiles(MSIPACKAGE *package)
         return msi_schedule_action(package, SCRIPT_INSTALL, L"InstallFiles");
 
     schedule_install_files(package);
-    mi = msi_alloc_zero( sizeof(MSIMEDIAINFO) );
+    mi = calloc(1, sizeof(MSIMEDIAINFO));
 
     LIST_FOR_EACH_ENTRY( file, &package->files, MSIFILE, entry )
     {
@@ -636,11 +636,11 @@ UINT ACTION_InstallFiles(MSIPACKAGE *package)
             {
                 ERR("Failed to copy %s to %s (%u)\n", debugstr_w(source), debugstr_w(file->TargetPath), rc);
                 rc = ERROR_INSTALL_FAILURE;
-                msi_free(source);
+                free(source);
                 goto done;
             }
             if (!is_global_assembly) file->state = msifs_installed;
-            msi_free(source);
+            free(source);
         }
         else if (!is_global_assembly && file->state != msifs_installed &&
                  !(file->Attributes & msidbFileAttributesPatchAdded))
@@ -736,7 +736,7 @@ static UINT patch_file( MSIPACKAGE *package, MSIFILEPATCH *patch )
     }
     DeleteFileW( patch->path );
     DeleteFileW( tmpfile );
-    msi_free( tmpfile );
+    free( tmpfile );
     return r;
 }
 
@@ -756,13 +756,13 @@ static UINT patch_assembly( MSIPACKAGE *package, MSIASSEMBLY *assembly, MSIFILEP
         HRESULT hr;
 
         hr = IAssemblyName_GetDisplayName( name, NULL, &len, 0 );
-        if (hr != E_NOT_SUFFICIENT_BUFFER || !(displayname = msi_alloc( len * sizeof(WCHAR) )))
+        if (hr != E_NOT_SUFFICIENT_BUFFER || !(displayname = malloc( len * sizeof(WCHAR) )))
             break;
 
         hr = IAssemblyName_GetDisplayName( name, displayname, &len, 0 );
         if (FAILED( hr ))
         {
-            msi_free( displayname );
+            free( displayname );
             break;
         }
 
@@ -772,16 +772,16 @@ static UINT patch_assembly( MSIPACKAGE *package, MSIASSEMBLY *assembly, MSIFILEP
             {
                 ERR( "failed to copy file %s -> %s (%lu)\n", debugstr_w(path),
                      debugstr_w(patch->File->TargetPath), GetLastError() );
-                msi_free( path );
-                msi_free( displayname );
+                free( path );
+                free( displayname );
                 IAssemblyName_Release( name );
                 break;
             }
             r = patch_file( package, patch );
-            msi_free( path );
+            free( path );
         }
 
-        msi_free( displayname );
+        free( displayname );
         IAssemblyName_Release( name );
         if (r == ERROR_SUCCESS) break;
     }
@@ -801,7 +801,7 @@ UINT ACTION_PatchFiles( MSIPACKAGE *package )
     if (package->script == SCRIPT_NONE)
         return msi_schedule_action(package, SCRIPT_INSTALL, L"PatchFiles");
 
-    mi = msi_alloc_zero( sizeof(MSIMEDIAINFO) );
+    mi = calloc( 1, sizeof(MSIMEDIAINFO) );
 
     TRACE("extracting files\n");
 
@@ -935,7 +935,7 @@ static WCHAR *wildcard_to_file( const WCHAR *wildcard, const WCHAR *filename )
     dirlen = ptr - wildcard + 1;
 
     pathlen = dirlen + lstrlenW(filename) + 1;
-    if (!(path = msi_alloc(pathlen * sizeof(WCHAR)))) return NULL;
+    if (!(path = malloc(pathlen * sizeof(WCHAR)))) return NULL;
 
     lstrcpynW(path, wildcard, dirlen + 1);
     lstrcatW(path, filename);
@@ -945,9 +945,9 @@ static WCHAR *wildcard_to_file( const WCHAR *wildcard, const WCHAR *filename )
 
 static void free_file_entry(FILE_LIST *file)
 {
-    msi_free(file->source);
-    msi_free(file->dest);
-    msi_free(file);
+    free(file->source);
+    free(file->dest);
+    free(file);
 }
 
 static void free_list(FILE_LIST *list)
@@ -967,7 +967,7 @@ static BOOL add_wildcard( FILE_LIST *files, const WCHAR *source, WCHAR *dest )
     WCHAR *ptr, *filename;
     DWORD size;
 
-    new = msi_alloc_zero(sizeof(FILE_LIST));
+    new = calloc(1, sizeof(FILE_LIST));
     if (!new)
         return FALSE;
 
@@ -983,7 +983,7 @@ static BOOL add_wildcard( FILE_LIST *files, const WCHAR *source, WCHAR *dest )
         new->destname = new->sourcename;
 
     size = (ptr - dest) + lstrlenW(filename) + 1;
-    new->dest = msi_alloc(size * sizeof(WCHAR));
+    new->dest = malloc(size * sizeof(WCHAR));
     if (!new->dest)
     {
         free_file_entry(new);
@@ -1038,7 +1038,7 @@ static BOOL move_files_wildcard( MSIPACKAGE *package, const WCHAR *source, WCHAR
         }
 
         add_wildcard(&files, path, dest);
-        msi_free(path);
+        free(path);
     }
 
     /* no files match the wildcard */
@@ -1048,7 +1048,7 @@ static BOOL move_files_wildcard( MSIPACKAGE *package, const WCHAR *source, WCHAR
     /* only the first wildcard match gets renamed to dest */
     file = LIST_ENTRY(list_head(&files.entry), FILE_LIST, entry);
     size = (wcsrchr(file->dest, '\\') - file->dest) + lstrlenW(file->destname) + 2;
-    file->dest = msi_realloc(file->dest, size * sizeof(WCHAR));
+    file->dest = realloc(file->dest, size * sizeof(WCHAR));
     if (!file->dest)
     {
         res = FALSE;
@@ -1132,7 +1132,7 @@ static UINT ITERATE_MoveFiles( MSIRECORD *rec, LPVOID param )
     else
     {
         size = lstrlenW(sourcedir) + lstrlenW(sourcename) + 2;
-        source = msi_alloc(size * sizeof(WCHAR));
+        source = malloc(size * sizeof(WCHAR));
         if (!source)
             goto done;
 
@@ -1170,7 +1170,7 @@ static UINT ITERATE_MoveFiles( MSIRECORD *rec, LPVOID param )
         size = lstrlenW(destname);
 
     size += lstrlenW(destdir) + 2;
-    dest = msi_alloc(size * sizeof(WCHAR));
+    dest = malloc(size * sizeof(WCHAR));
     if (!dest)
         goto done;
 
@@ -1203,11 +1203,11 @@ static UINT ITERATE_MoveFiles( MSIRECORD *rec, LPVOID param )
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free(sourcedir);
-    msi_free(destdir);
-    msi_free(destname);
-    msi_free(source);
-    msi_free(dest);
+    free(sourcedir);
+    free(destdir);
+    free(destname);
+    free(source);
+    free(dest);
 
     return ERROR_SUCCESS;
 }
@@ -1237,13 +1237,13 @@ static WCHAR *get_duplicate_filename( MSIPACKAGE *package, MSIRECORD *row, const
     if (MSI_RecordIsNull( row, 4 ))
     {
         len = lstrlenW( src ) + 1;
-        if (!(dst_name = msi_alloc( len * sizeof(WCHAR)))) return NULL;
+        if (!(dst_name = malloc( len * sizeof(WCHAR)))) return NULL;
         lstrcpyW( dst_name, wcsrchr( src, '\\' ) + 1 );
     }
     else
     {
         MSI_RecordGetStringW( row, 4, NULL, &len );
-        if (!(dst_name = msi_alloc( ++len * sizeof(WCHAR) ))) return NULL;
+        if (!(dst_name = malloc( ++len * sizeof(WCHAR) ))) return NULL;
         MSI_RecordGetStringW( row, 4, dst_name, &len );
         msi_reduce_to_long_filename( dst_name );
     }
@@ -1267,7 +1267,7 @@ static WCHAR *get_duplicate_filename( MSIPACKAGE *package, MSIRECORD *row, const
             if (!dst_path)
             {
                 FIXME("Unable to get destination folder, try AppSearch properties\n");
-                msi_free( dst_name );
+                free( dst_name );
                 return NULL;
             }
         }
@@ -1276,8 +1276,8 @@ static WCHAR *get_duplicate_filename( MSIPACKAGE *package, MSIRECORD *row, const
     dst = msi_build_directory_name( 2, dst_path, dst_name );
     msi_create_full_path( package, dst_path );
 
-    msi_free( dst_name );
-    msi_free( dst_path );
+    free( dst_name );
+    free( dst_path );
     return dst;
 }
 
@@ -1338,7 +1338,7 @@ static UINT ITERATE_DuplicateFiles(MSIRECORD *row, LPVOID param)
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free(dest);
+    free(dest);
     return ERROR_SUCCESS;
 }
 
@@ -1413,7 +1413,7 @@ static UINT ITERATE_RemoveDuplicateFiles( MSIRECORD *row, LPVOID param )
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free(dest);
+    free(dest);
     return ERROR_SUCCESS;
 }
 
@@ -1506,7 +1506,7 @@ static UINT ITERATE_RemoveFiles(MSIRECORD *row, LPVOID param)
         size = lstrlenW( filename );
     }
     size += lstrlenW(dir) + 2;
-    path = msi_alloc(size * sizeof(WCHAR));
+    path = malloc(size * sizeof(WCHAR));
     if (!path)
     {
         ret = ERROR_OUTOFMEMORY;
@@ -1535,9 +1535,9 @@ static UINT ITERATE_RemoveFiles(MSIRECORD *row, LPVOID param)
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
 
-    msi_free(filename);
-    msi_free(path);
-    msi_free(dir);
+    free(filename);
+    free(path);
+    free(dir);
     return ret;
 }
 
@@ -1601,10 +1601,10 @@ UINT ACTION_RemoveFiles( MSIPACKAGE *package )
             if (ver && msi_compare_file_versions( ver, file->Version ) > 0)
             {
                 TRACE("newer version detected, not removing file\n");
-                msi_free( ver );
+                free( ver );
                 continue;
             }
-            msi_free( ver );
+            free( ver );
         }
 
         if (file->state == msifs_installed)
diff --git a/dlls/msi/font.c b/dlls/msi/font.c
index 4dbddc4d72ac..b4eadbc89680 100644
--- a/dlls/msi/font.c
+++ b/dlls/msi/font.c
@@ -143,17 +143,17 @@ static WCHAR *load_ttf_name_id( MSIPACKAGE *package, const WCHAR *filename, DWOR
             ttRecord.uStringOffset = SWAPWORD(ttRecord.uStringOffset);
             SetFilePointer(handle, tblDir.uOffset + ttRecord.uStringOffset + ttNTHeader.uStorageOffset,
                            NULL, FILE_BEGIN);
-            if (!(buf = msi_alloc_zero( ttRecord.uStringLength + sizeof(WCHAR) ))) goto end;
+            if (!(buf = calloc(ttRecord.uStringLength, sizeof(WCHAR)))) goto end;
             dwRead = 0;
             ReadFile(handle, buf, ttRecord.uStringLength, &dwRead, NULL);
             if (dwRead % sizeof(WCHAR))
             {
-                msi_free(buf);
+                free(buf);
                 goto end;
             }
             for (i = 0; i < dwRead / sizeof(WCHAR); i++) buf[i] = SWAPWORD(buf[i]);
             ret = wcsdup(buf);
-            msi_free(buf);
+            free(buf);
             break;
         }
     }
@@ -172,13 +172,13 @@ static WCHAR *font_name_from_file( MSIPACKAGE *package, const WCHAR *filename )
         if (!name[0])
         {
             WARN("empty font name\n");
-            msi_free( name );
+            free( name );
             return NULL;
         }
-        ret = msi_alloc( (lstrlenW( name ) + lstrlenW( L" (TrueType)" ) + 1 ) * sizeof(WCHAR) );
+        ret = malloc( wcslen( name ) * sizeof(WCHAR) + sizeof( L" (TrueType)" ) );
         lstrcpyW( ret, name );
         lstrcatW( ret, L" (TrueType)" );
-        msi_free( name );
+        free( name );
     }
     return ret;
 }
@@ -202,9 +202,9 @@ WCHAR *msi_get_font_file_version( MSIPACKAGE *package, const WCHAR *filename )
             else major = 0;
         }
         len = lstrlenW( L"%u.%u.0.0" ) + 20;
-        ret = msi_alloc( len * sizeof(WCHAR) );
+        ret = malloc( len * sizeof(WCHAR) );
         swprintf( ret, len, L"%u.%u.0.0", major, minor );
-        msi_free( version );
+        free( version );
     }
     return ret;
 }
@@ -254,7 +254,7 @@ static UINT ITERATE_RegisterFonts(MSIRECORD *row, LPVOID param)
         msi_reg_set_val_str( hkey2, name, file->TargetPath);
     }
 
-    msi_free(name);
+    free(name);
     RegCloseKey(hkey1);
     RegCloseKey(hkey2);
 
@@ -267,7 +267,7 @@ static UINT ITERATE_RegisterFonts(MSIRECORD *row, LPVOID param)
     MSI_RecordSetStringW( uirow, 1, p );
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
-    msi_free( uipath );
+    free( uipath );
     /* FIXME: call msi_ui_progress? */
 
     return ERROR_SUCCESS;
@@ -335,7 +335,7 @@ static UINT ITERATE_UnregisterFonts( MSIRECORD *row, LPVOID param )
         RegDeleteValueW( hkey2, name );
     }
 
-    msi_free( name );
+    free( name );
     RegCloseKey( hkey1 );
     RegCloseKey( hkey2 );
 
@@ -348,7 +348,7 @@ static UINT ITERATE_UnregisterFonts( MSIRECORD *row, LPVOID param )
     MSI_RecordSetStringW( uirow, 1, p );
     MSI_ProcessMessage(package, INSTALLMESSAGE_ACTIONDATA, uirow);
     msiobj_release( &uirow->hdr );
-    msi_free( uipath );
+    free( uipath );
     /* FIXME: call msi_ui_progress? */
 
     return ERROR_SUCCESS;
diff --git a/dlls/msi/format.c b/dlls/msi/format.c
index f2be8db87fc8..8802756d88cd 100644
--- a/dlls/msi/format.c
+++ b/dlls/msi/format.c
@@ -83,7 +83,7 @@ typedef struct _tagSTACK
 
 static STACK *create_stack(void)
 {
-    STACK *stack = msi_alloc(sizeof(STACK));
+    STACK *stack = malloc(sizeof(STACK));
     list_init(&stack->items);
     return stack;
 }
@@ -94,10 +94,10 @@ static void free_stack(STACK *stack)
     {
         FORMSTR *str = LIST_ENTRY(list_head(&stack->items), FORMSTR, entry);
         list_remove(&str->entry);
-        msi_free(str);
+        free(str);
     }
 
-    msi_free(stack);
+    free(stack);
 }
 
 static void stack_push(STACK *stack, FORMSTR *str)
@@ -145,7 +145,7 @@ static WCHAR *dup_formstr( FORMAT *format, FORMSTR *str, int *ret_len )
     WCHAR *val;
 
     if (!str->len) return NULL;
-    if ((val = msi_alloc( (str->len + 1) * sizeof(WCHAR) )))
+    if ((val = malloc( (str->len + 1) * sizeof(WCHAR) )))
     {
         memcpy( val, get_formstr_data(format, str), str->len * sizeof(WCHAR) );
         val[str->len] = 0;
@@ -160,20 +160,20 @@ static WCHAR *deformat_index( FORMAT *format, FORMSTR *str, int *ret_len )
     DWORD len;
     int field;
 
-    if (!(val = msi_alloc( (str->len + 1) * sizeof(WCHAR) ))) return NULL;
+    if (!(val = malloc( (str->len + 1) * sizeof(WCHAR) ))) return NULL;
     lstrcpynW(val, get_formstr_data(format, str), str->len + 1);
     field = wcstol( val, NULL, 10 );
-    msi_free( val );
+    free( val );
 
     if (MSI_RecordIsNull( format->record, field ) ||
         MSI_RecordGetStringW( format->record, field, NULL, &len )) return NULL;
 
     len++;
-    if (!(ret = msi_alloc( len * sizeof(WCHAR) ))) return NULL;
+    if (!(ret = malloc( len * sizeof(WCHAR) ))) return NULL;
     ret[0] = 0;
     if (MSI_RecordGetStringW( format->record, field, ret, &len ))
     {
-        msi_free( ret );
+        free( ret );
         return NULL;
     }
     *ret_len = len;
@@ -186,19 +186,19 @@ static WCHAR *deformat_property( FORMAT *format, FORMSTR *str, int *ret_len )
     DWORD len = 0;
     UINT r;
 
-    if (!(prop = msi_alloc( (str->len + 1) * sizeof(WCHAR) ))) return NULL;
+    if (!(prop = malloc( (str->len + 1) * sizeof(WCHAR) ))) return NULL;
     lstrcpynW( prop, get_formstr_data(format, str), str->len + 1 );
 
     r = msi_get_property( format->package->db, prop, NULL, &len );
     if (r != ERROR_SUCCESS && r != ERROR_MORE_DATA)
     {
-        msi_free( prop );
+        free( prop );
         return NULL;
     }
     len++;
-    if ((ret = msi_alloc( len * sizeof(WCHAR) )))
+    if ((ret = malloc( len * sizeof(WCHAR) )))
         msi_get_property( format->package->db, prop, ret, &len );
-    msi_free( prop );
+    free( prop );
     *ret_len = len;
     return ret;
 }
@@ -208,12 +208,12 @@ static WCHAR *deformat_component( FORMAT *format, FORMSTR *str, int *ret_len )
     WCHAR *key, *ret;
     MSICOMPONENT *comp;
 
-    if (!(key = msi_alloc( (str->len + 1) * sizeof(WCHAR) ))) return NULL;
+    if (!(key = malloc( (str->len + 1) * sizeof(WCHAR) ))) return NULL;
     lstrcpynW(key, get_formstr_data(format, str), str->len + 1);
 
     if (!(comp = msi_get_loaded_component( format->package, key )))
     {
-        msi_free( key );
+        free( key );
         return NULL;
     }
     if (comp->Action == INSTALLSTATE_SOURCE)
@@ -223,7 +223,7 @@ static WCHAR *deformat_component( FORMAT *format, FORMSTR *str, int *ret_len )
 
     if (ret) *ret_len = lstrlenW( ret );
     else *ret_len = 0;
-    msi_free( key );
+    free( key );
     return ret;
 }
 
@@ -233,7 +233,7 @@ static WCHAR *deformat_file( FORMAT *format, FORMSTR *str, BOOL shortname, int *
     const MSIFILE *file;
     DWORD len = 0;
 
-    if (!(key = msi_alloc( (str->len + 1) * sizeof(WCHAR) ))) return NULL;
+    if (!(key = malloc( (str->len + 1) * sizeof(WCHAR) ))) return NULL;
     lstrcpynW(key, get_formstr_data(format, str), str->len + 1);
 
     if (!(file = msi_get_loaded_file( format->package, key ))) goto done;
@@ -248,11 +248,11 @@ static WCHAR *deformat_file( FORMAT *format, FORMSTR *str, BOOL shortname, int *
         goto done;
     }
     len++;
-    if ((ret = msi_alloc( len * sizeof(WCHAR) )))
+    if ((ret = malloc( len * sizeof(WCHAR) )))
         len = GetShortPathNameW( file->TargetPath, ret, len );
 
 done:
-    msi_free( key );
+    free( key );
     *ret_len = len;
     return ret;
 }
@@ -262,16 +262,16 @@ static WCHAR *deformat_environment( FORMAT *format, FORMSTR *str, int *ret_len )
     WCHAR *key, *ret = NULL;
     DWORD len;
 
-    if (!(key = msi_alloc((str->len + 1) * sizeof(WCHAR)))) return NULL;
+    if (!(key = malloc((str->len + 1) * sizeof(WCHAR)))) return NULL;
     lstrcpynW(key, get_formstr_data(format, str), str->len + 1);
 
     if ((len = GetEnvironmentVariableW( key, NULL, 0 )))
     {
         len++;
-        if ((ret = msi_alloc( len * sizeof(WCHAR) )))
+        if ((ret = malloc( len * sizeof(WCHAR) )))
             *ret_len = GetEnvironmentVariableW( key, ret, len );
     }
-    msi_free( key );
+    free( key );
     return ret;
 }
 
@@ -300,7 +300,7 @@ static WCHAR *deformat_literal( FORMAT *format, FORMSTR *str, BOOL *propfound,
     {
         if (str->len != 1)
             replaced = NULL;
-        else if ((replaced = msi_alloc( sizeof(WCHAR) )))
+        else if ((replaced = malloc( sizeof(WCHAR) )))
         {
             *replaced = 0;
             *len = 0;
@@ -345,15 +345,15 @@ static WCHAR *build_default_format( const MSIRECORD *record )
     WCHAR *ret, *tmp, buf[26];
     DWORD size = 1;
 
-    if (!(ret = msi_alloc( sizeof(*ret) ))) return NULL;
+    if (!(ret = malloc( sizeof(*ret) ))) return NULL;
     ret[0] = 0;
 
     for (i = 1; i <= count; i++)
     {
         size += swprintf( buf, ARRAY_SIZE(buf), L"%d: [%d] ", i, i );
-        if (!(tmp = msi_realloc( ret, size * sizeof(*ret) )))
+        if (!(tmp = realloc( ret, size * sizeof(*ret) )))
         {
-            msi_free( ret );
+            free( ret );
             return NULL;
         }
         ret = tmp;
@@ -401,7 +401,7 @@ static int format_lex(FORMAT *format, FORMSTR **out)
     if (!format->deformatted)
         return FORMAT_NULL;
 
-    *out = msi_alloc_zero(sizeof(FORMSTR));
+    *out = calloc(1, sizeof(FORMSTR));
     if (!*out)
         return FORMAT_FAIL;
 
@@ -494,13 +494,13 @@ static FORMSTR *format_replace( FORMAT *format, BOOL propfound, BOOL nonprop,
 
     if (size <= 1)
     {
-        msi_free(format->deformatted);
+        free(format->deformatted);
         format->deformatted = NULL;
         format->len = 0;
         return NULL;
     }
 
-    str = msi_alloc(size * sizeof(WCHAR));
+    str = malloc(size * sizeof(WCHAR));
     if (!str)
         return NULL;
 
@@ -522,7 +522,7 @@ static FORMSTR *format_replace( FORMAT *format, BOOL propfound, BOOL nonprop,
     ptr = &format->deformatted[format->n + oldsize];
     memcpy(&str[n], ptr, (lstrlenW(ptr) + 1) * sizeof(WCHAR));
 
-    msi_free(format->deformatted);
+    free(format->deformatted);
     format->deformatted = str;
     format->len = size - 1;
 
@@ -533,7 +533,7 @@ static FORMSTR *format_replace( FORMAT *format, BOOL propfound, BOOL nonprop,
     if (!replace)
         return NULL;
 
-    ret = msi_alloc_zero(sizeof(FORMSTR));
+    ret = calloc(1, sizeof(FORMSTR));
     if (!ret)
         return NULL;
 
@@ -560,7 +560,7 @@ static WCHAR *replace_stack_group( FORMAT *format, STACK *values,
     node = stack_pop(values);
     n = node->n;
     *oldsize = node->len;
-    msi_free(node);
+    free(node);
 
     while ((node = stack_pop(values)))
     {
@@ -572,10 +572,10 @@ static WCHAR *replace_stack_group( FORMAT *format, STACK *values,
         if (node->propfound)
             *propfound = TRUE;
 
-        msi_free(node);
+        free(node);
     }
 
-    content = msi_alloc_zero(sizeof(FORMSTR));
+    content = calloc(1, sizeof(FORMSTR));
     content->n = n;
     content->len = *oldsize;
     content->type = FORMAT_LITERAL;
@@ -583,7 +583,7 @@ static WCHAR *replace_stack_group( FORMAT *format, STACK *values,
     if (!format->groupfailed && (*oldsize == 2 ||
         (format->propfailed && !*nonprop)))
     {
-        msi_free(content);
+        free(content);
         return NULL;
     }
     else if (format->deformatted[content->n + 1] == '{' &&
@@ -608,7 +608,7 @@ static WCHAR *replace_stack_group( FORMAT *format, STACK *values,
 
     replaced = dup_formstr( format, content, len );
     *type = content->type;
-    msi_free(content);
+    free(content);
 
     if (format->groups == 0)
         format->propfailed = FALSE;
@@ -631,7 +631,7 @@ static WCHAR *replace_stack_prop( FORMAT *format, STACK *values,
     n = node->n;
     *oldsize = node->len;
     *type = stack_peek(values)->type;
-    msi_free(node);
+    free(node);
 
     while ((node = stack_pop(values)))
     {
@@ -641,10 +641,10 @@ static WCHAR *replace_stack_prop( FORMAT *format, STACK *values,
             stack_peek(values) && node->type != *type)
             *type = FORMAT_LITERAL;
 
-        msi_free(node);
+        free(node);
     }
 
-    content = msi_alloc_zero(sizeof(FORMSTR));
+    content = calloc(1, sizeof(FORMSTR));
     content->n = n + 1;
     content->len = *oldsize - 2;
     content->type = *type;
@@ -672,7 +672,7 @@ static WCHAR *replace_stack_prop( FORMAT *format, STACK *values,
         content->len += 2;
         replaced = dup_formstr( format, content, len );
     }
-    msi_free(content);
+    free(content);
     return replaced;
 }
 
@@ -699,7 +699,7 @@ static UINT replace_stack(FORMAT *format, STACK *stack, STACK *values)
 
     format->n = n;
     beg = format_replace( format, propfound, nonprop, oldsize, type, replaced, len );
-    msi_free(replaced);
+    free(replaced);
     if (!beg)
         return ERROR_SUCCESS;
 
@@ -724,7 +724,7 @@ static UINT replace_stack(FORMAT *format, STACK *stack, STACK *values)
             if (beg->propfound)
                 top->propfound = TRUE;
 
-            msi_free(beg);
+            free(beg);
             return ERROR_SUCCESS;
         }
     }
@@ -828,7 +828,7 @@ static DWORD deformat_string_internal(MSIPACKAGE *package, LPCWSTR ptr,
     *data = format.deformatted;
     *len = format.len;
 
-    msi_free(str);
+    free(str);
     free_stack(stack);
     free_stack(temp);
 
@@ -864,7 +864,7 @@ UINT MSI_FormatRecordW( MSIPACKAGE* package, MSIRECORD* record, LPWSTR buffer,
         {
             deformat_string_internal(package, MSI_RecordGetString(record, i), &deformated, &len, NULL);
             MSI_RecordSetStringW(record_deformated, i, deformated);
-            msi_free(deformated);
+            free(deformated);
         }
     }
 
@@ -892,8 +892,8 @@ UINT MSI_FormatRecordW( MSIPACKAGE* package, MSIRECORD* record, LPWSTR buffer,
     *size = len;
     msiobj_release(&record_deformated->hdr);
 end:
-    msi_free( format );
-    msi_free( deformated );
+    free( format );
+    free( deformated );
     return rc;
 }
 
@@ -997,7 +997,7 @@ UINT WINAPI MsiFormatRecordA(MSIHANDLE hinst, MSIHANDLE hrec, char *buf, DWORD *
     if (r != ERROR_SUCCESS)
         return r;
 
-    value = msi_alloc(++len * sizeof(WCHAR));
+    value = malloc(++len * sizeof(WCHAR));
     if (!value)
         goto done;
 
@@ -1005,7 +1005,7 @@ UINT WINAPI MsiFormatRecordA(MSIHANDLE hinst, MSIHANDLE hrec, char *buf, DWORD *
     if (!r)
         r = msi_strncpyWtoA(value, len, buf, sz, FALSE);
 
-    msi_free(value);
+    free(value);
 done:
     msiobj_release(&rec->hdr);
     if (package) msiobj_release(&package->hdr);
@@ -1024,7 +1024,7 @@ DWORD deformat_string( MSIPACKAGE *package, const WCHAR *fmt, WCHAR **data )
 
     MSI_RecordSetStringW( rec, 0, fmt );
     MSI_FormatRecordW( package, rec, NULL, &len );
-    if (!(*data = msi_alloc( ++len * sizeof(WCHAR) )))
+    if (!(*data = malloc( ++len * sizeof(WCHAR) )))
     {
         msiobj_release( &rec->hdr );
         return 0;
diff --git a/dlls/msi/handle.c b/dlls/msi/handle.c
index f0a55956fce6..6ebe1796d3ae 100644
--- a/dlls/msi/handle.c
+++ b/dlls/msi/handle.c
@@ -70,7 +70,7 @@ static unsigned int msihandletable_size = 0;
 
 void msi_free_handle_table(void)
 {
-    msi_free( msihandletable );
+    free( msihandletable );
     msihandletable = NULL;
     msihandletable_size = 0;
     DeleteCriticalSection(&MSI_handle_cs);
@@ -92,12 +92,12 @@ static MSIHANDLE alloc_handle_table_entry(void)
         if (msihandletable_size == 0)
         {
             newsize = 256;
-            p = msi_alloc_zero(newsize * sizeof(*p));
+            p = calloc(newsize, sizeof(*p));
         }
         else
         {
             newsize = msihandletable_size * 2;
-            p = msi_realloc(msihandletable, newsize * sizeof(*p));
+            p = realloc(msihandletable, newsize * sizeof(*p));
             if (p) memset(p + msihandletable_size, 0, (newsize - msihandletable_size) * sizeof(*p));
         }
         if (!p)
@@ -202,7 +202,7 @@ void *alloc_msiobject(UINT type, UINT size, msihandledestructor destroy )
 {
     MSIOBJECTHDR *info;
 
-    info = msi_alloc_zero( size );
+    info = calloc( 1, size );
     if( info )
     {
         info->magic = MSIHANDLE_MAGIC;
@@ -257,7 +257,7 @@ int msiobj_release( MSIOBJECTHDR *info )
         if( info->destructor )
             info->destructor( info );
         TRACE("object %p destroyed\n", info);
-        msi_free( info );
+        free( info );
     }
 
     return ret;
diff --git a/dlls/msi/insert.c b/dlls/msi/insert.c
index 3021fc88de8c..1859b31438fa 100644
--- a/dlls/msi/insert.c
+++ b/dlls/msi/insert.c
@@ -312,7 +312,7 @@ static UINT INSERT_delete( struct tagMSIVIEW *view )
     if( sv )
         sv->ops->delete( sv );
     msiobj_release( &iv->db->hdr );
-    msi_free( iv );
+    free( iv );
 
     return ERROR_SUCCESS;
 }
@@ -373,7 +373,7 @@ UINT INSERT_CreateView( MSIDATABASE *db, MSIVIEW **view, LPCWSTR table,
         return r;
     }
 
-    iv = msi_alloc_zero( sizeof *iv );
+    iv = calloc( 1, sizeof *iv );
     if( !iv )
         return ERROR_FUNCTION_FAILED;
 
diff --git a/dlls/msi/install.c b/dlls/msi/install.c
index b9e646be2476..609a3016eaa4 100644
--- a/dlls/msi/install.c
+++ b/dlls/msi/install.c
@@ -54,7 +54,7 @@ UINT WINAPI MsiDoActionA( MSIHANDLE hInstall, LPCSTR szAction )
         return ERROR_FUNCTION_FAILED;
 
     ret = MsiDoActionW( hInstall, szwAction );
-    msi_free( szwAction );
+    free( szwAction );
     return ret;
 }
 
@@ -113,7 +113,7 @@ UINT WINAPI MsiSequenceA( MSIHANDLE hInstall, LPCSTR szTable, INT iSequenceMode
         return ERROR_FUNCTION_FAILED;
 
     ret = MsiSequenceW( hInstall, szwTable, iSequenceMode );
-    msi_free( szwTable );
+    free( szwTable );
     return ret;
 }
 
@@ -398,7 +398,7 @@ WCHAR *msi_resolve_source_folder( MSIPACKAGE *package, const WCHAR *name, MSIFOL
 
     TRACE("-> %s\n", debugstr_w(path));
     f->ResolvedSource = wcsdup( path );
-    msi_free( p );
+    free( p );
 
     return path;
 }
@@ -533,8 +533,8 @@ UINT WINAPI MsiSetTargetPathA( MSIHANDLE hInstall, LPCSTR szFolder,
     rc = MsiSetTargetPathW( hInstall, szwFolder, szwFolderPath );
 
 end:
-    msi_free(szwFolder);
-    msi_free(szwFolderPath);
+    free(szwFolder);
+    free(szwFolderPath);
 
     return rc;
 }
@@ -548,7 +548,7 @@ static void set_target_path( MSIPACKAGE *package, MSIFOLDER *folder, const WCHAR
     if (!(target_path = msi_normalize_path( path ))) return;
     if (wcscmp( target_path, folder->ResolvedTarget ))
     {
-        msi_free( folder->ResolvedTarget );
+        free( folder->ResolvedTarget );
         folder->ResolvedTarget = target_path;
         msi_set_property( package->db, folder->Directory, folder->ResolvedTarget, -1 );
 
@@ -558,7 +558,7 @@ static void set_target_path( MSIPACKAGE *package, MSIFOLDER *folder, const WCHAR
             msi_resolve_target_folder( package, child->Directory, FALSE );
         }
     }
-    else msi_free( target_path );
+    else free( target_path );
 }
 
 UINT MSI_SetTargetPathW( MSIPACKAGE *package, LPCWSTR szFolder, LPCWSTR szFolderPath )
@@ -588,7 +588,7 @@ UINT MSI_SetTargetPathW( MSIPACKAGE *package, LPCWSTR szFolder, LPCWSTR szFolder
         if (!comp->Enabled || msi_is_global_assembly( comp )) continue;
 
         dir = msi_get_target_folder( package, comp->Directory );
-        msi_free( file->TargetPath );
+        free( file->TargetPath );
         file->TargetPath = msi_build_directory_name( 2, dir, file->FileName );
     }
     return ERROR_SUCCESS;
@@ -824,7 +824,7 @@ UINT WINAPI MsiSetFeatureStateA(MSIHANDLE hInstall, LPCSTR szFeature,
 
     rc = MsiSetFeatureStateW(hInstall,szwFeature, iState);
 
-    msi_free(szwFeature);
+    free(szwFeature);
 
     return rc;
 }
@@ -995,7 +995,7 @@ UINT WINAPI MsiSetFeatureAttributesA( MSIHANDLE handle, LPCSTR feature, DWORD at
     if (feature && !(featureW = strdupAtoW( feature ))) return ERROR_OUTOFMEMORY;
 
     r = MsiSetFeatureAttributesW( handle, featureW, attrs );
-    msi_free( featureW );
+    free( featureW );
     return r;
 }
 
@@ -1031,11 +1031,11 @@ UINT WINAPI MsiSetFeatureAttributesW( MSIHANDLE handle, LPCWSTR name, DWORD attr
     costing = msi_dup_property( package->db, L"CostingComplete" );
     if (!costing || !wcscmp( costing, L"1" ))
     {
-        msi_free( costing );
+        free( costing );
         msiobj_release( &package->hdr );
         return ERROR_FUNCTION_FAILED;
     }
-    msi_free( costing );
+    free( costing );
     if (!(feature = msi_get_loaded_feature( package, name )))
     {
         msiobj_release( &package->hdr );
@@ -1058,7 +1058,7 @@ UINT WINAPI MsiGetFeatureStateA(MSIHANDLE hInstall, LPCSTR szFeature,
     if (szFeature && !(szwFeature = strdupAtoW(szFeature))) return ERROR_OUTOFMEMORY;
 
     rc = MsiGetFeatureStateW(hInstall, szwFeature, piInstalled, piAction);
-    msi_free( szwFeature);
+    free(szwFeature);
     return rc;
 }
 
@@ -1135,7 +1135,7 @@ UINT WINAPI MsiGetFeatureCostA(MSIHANDLE hInstall, LPCSTR szFeature,
 
     rc = MsiGetFeatureCostW(hInstall, szwFeature, iCostTree, iState, piCost);
 
-    msi_free(szwFeature);
+    free(szwFeature);
 
     return rc;
 }
@@ -1268,15 +1268,15 @@ UINT WINAPI MsiGetFeatureInfoA( MSIHANDLE handle, const char *feature, DWORD *at
 
     if (feature && !(featureW = strdupAtoW( feature ))) return ERROR_OUTOFMEMORY;
 
-    if (title && title_len && !(titleW = msi_alloc( *title_len * sizeof(WCHAR) )))
+    if (title && title_len && !(titleW = malloc( *title_len * sizeof(WCHAR) )))
     {
-        msi_free( featureW );
+        free( featureW );
         return ERROR_OUTOFMEMORY;
     }
-    if (help && help_len && !(helpW = msi_alloc( *help_len * sizeof(WCHAR) )))
+    if (help && help_len && !(helpW = malloc( *help_len * sizeof(WCHAR) )))
     {
-        msi_free( featureW );
-        msi_free( titleW );
+        free( featureW );
+        free( titleW );
         return ERROR_OUTOFMEMORY;
     }
     r = MsiGetFeatureInfoW( handle, featureW, attrs, titleW, title_len, helpW, help_len );
@@ -1285,9 +1285,9 @@ UINT WINAPI MsiGetFeatureInfoA( MSIHANDLE handle, const char *feature, DWORD *at
         if (titleW) WideCharToMultiByte( CP_ACP, 0, titleW, -1, title, *title_len + 1, NULL, NULL );
         if (helpW) WideCharToMultiByte( CP_ACP, 0, helpW, -1, help, *help_len + 1, NULL, NULL );
     }
-    msi_free( titleW );
-    msi_free( helpW );
-    msi_free( featureW );
+    free( titleW );
+    free( helpW );
+    free( featureW );
     return r;
 }
 
@@ -1385,7 +1385,7 @@ UINT WINAPI MsiSetComponentStateA(MSIHANDLE hInstall, LPCSTR szComponent,
 
     rc = MsiSetComponentStateW(hInstall, szwComponent, iState);
 
-    msi_free(szwComponent);
+    free(szwComponent);
 
     return rc;
 }
@@ -1403,7 +1403,7 @@ UINT WINAPI MsiGetComponentStateA(MSIHANDLE hInstall, LPCSTR szComponent,
 
     rc = MsiGetComponentStateW(hInstall,szwComponent,piInstalled, piAction);
 
-    msi_free( szwComponent);
+    free(szwComponent);
 
     return rc;
 }
@@ -1648,6 +1648,6 @@ UINT WINAPI MsiGetFeatureValidStatesA( MSIHANDLE hInstall, const char *szFeature
     UINT ret;
     WCHAR *szwFeature = strdupAtoW(szFeature);
     ret = MsiGetFeatureValidStatesW(hInstall, szwFeature, pInstallState);
-    msi_free(szwFeature);
+    free(szwFeature);
     return ret;
 }
diff --git a/dlls/msi/media.c b/dlls/msi/media.c
index bc17e5fcb62f..97c59b4e543d 100644
--- a/dlls/msi/media.c
+++ b/dlls/msi/media.c
@@ -78,7 +78,7 @@ static UINT msi_change_media(MSIPACKAGE *package, MSIMEDIAINFO *mi)
     }
 
     msiobj_release(&record->hdr);
-    msi_free(source_dir);
+    free(source_dir);
 
     return r == IDRETRY ? ERROR_SUCCESS : ERROR_INSTALL_SOURCE_ABSENT;
 }
@@ -96,12 +96,12 @@ static MSICABINETSTREAM *msi_get_cabinet_stream( MSIPACKAGE *package, UINT disk_
 
 static void * CDECL cabinet_alloc(ULONG cb)
 {
-    return msi_alloc(cb);
+    return malloc(cb);
 }
 
 static void CDECL cabinet_free(void *pv)
 {
-    msi_free(pv);
+    free(pv);
 }
 
 static INT_PTR CDECL cabinet_open(char *pszFile, int oflag, int pmode)
@@ -208,7 +208,7 @@ static INT_PTR CDECL cabinet_open_stream( char *pszFile, int oflag, int pmode )
             return -1;
         }
         hr = IStorage_OpenStream( cab->storage, encoded, NULL, STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &stream );
-        msi_free( encoded );
+        free( encoded );
         if (FAILED(hr))
         {
             WARN( "failed to open stream %#lx\n", hr );
@@ -288,7 +288,7 @@ static WCHAR *get_cabinet_filename(MSIMEDIAINFO *mi)
     WCHAR *ret;
 
     len = lstrlenW(mi->sourcedir) + lstrlenW(mi->cabinet) + 1;
-    if (!(ret = msi_alloc(len * sizeof(WCHAR)))) return NULL;
+    if (!(ret = malloc(len * sizeof(WCHAR)))) return NULL;
     lstrcpyW(ret, mi->sourcedir);
     lstrcatW(ret, mi->cabinet);
     return ret;
@@ -303,9 +303,9 @@ static INT_PTR cabinet_next_cabinet(FDINOTIFICATIONTYPE fdint,
     INT_PTR res = -1;
     UINT rc;
 
-    msi_free(mi->disk_prompt);
-    msi_free(mi->cabinet);
-    msi_free(mi->volume_label);
+    free(mi->disk_prompt);
+    free(mi->cabinet);
+    free(mi->volume_label);
     mi->disk_prompt = NULL;
     mi->cabinet = NULL;
     mi->volume_label = NULL;
@@ -334,7 +334,7 @@ static INT_PTR cabinet_next_cabinet(FDINOTIFICATIONTYPE fdint,
         if (length > 256)
         {
             WARN( "cannot update next cabinet filename with a string size %lu > 256\n", length );
-            msi_free(next_cab);
+            free(next_cab);
             goto done;
         }
         else
@@ -344,7 +344,7 @@ static INT_PTR cabinet_next_cabinet(FDINOTIFICATIONTYPE fdint,
         }
         /* Path psz3 and cabinet psz1 are concatenated by FDI so just reset psz1 */
         *pfdin->psz1 = 0;
-        msi_free(next_cab);
+        free(next_cab);
     }
 
     if (!(cabinet_file = get_cabinet_filename(mi)))
@@ -360,8 +360,8 @@ static INT_PTR cabinet_next_cabinet(FDINOTIFICATIONTYPE fdint,
     }
 
 done:
-    msi_free(cab);
-    msi_free(cabinet_file);
+    free(cab);
+    free(cabinet_file);
     return res;
 }
 
@@ -372,9 +372,9 @@ static INT_PTR cabinet_next_cabinet_stream( FDINOTIFICATIONTYPE fdint,
     MSIMEDIAINFO *mi = data->mi;
     UINT rc;
 
-    msi_free( mi->disk_prompt );
-    msi_free( mi->cabinet );
-    msi_free( mi->volume_label );
+    free( mi->disk_prompt );
+    free( mi->cabinet );
+    free( mi->volume_label );
     mi->disk_prompt = NULL;
     mi->cabinet = NULL;
     mi->volume_label = NULL;
@@ -407,7 +407,7 @@ static INT_PTR cabinet_copy_file(FDINOTIFICATIONTYPE fdint,
                   &attrs, data->user))
     {
         /* We're not extracting this file, so free the filename. */
-        msi_free(data->curfile);
+        free(data->curfile);
         data->curfile = NULL;
         goto done;
     }
@@ -447,13 +447,13 @@ static INT_PTR cabinet_copy_file(FDINOTIFICATIONTYPE fdint,
             if (!(tmppathW = wcsdup(path))) return ERROR_OUTOFMEMORY;
             if ((p = wcsrchr(tmppathW, '\\'))) *p = 0;
             len = lstrlenW( tmppathW ) + 16;
-            if (!(tmpfileW = msi_alloc(len * sizeof(WCHAR))))
+            if (!(tmpfileW = malloc(len * sizeof(WCHAR))))
             {
-                msi_free( tmppathW );
+                free( tmppathW );
                 return ERROR_OUTOFMEMORY;
             }
             if (!msi_get_temp_file_name( data->package, tmppathW, L"msi", tmpfileW )) tmpfileW[0] = 0;
-            msi_free( tmppathW );
+            free( tmppathW );
 
             handle = msi_create_file( data->package, tmpfileW, GENERIC_READ | GENERIC_WRITE, 0, CREATE_ALWAYS, attrs );
 
@@ -468,13 +468,13 @@ static INT_PTR cabinet_copy_file(FDINOTIFICATIONTYPE fdint,
                 WARN( "failed to schedule rename operation %s (error %lu)\n", debugstr_w(path), GetLastError() );
                 msi_delete_file( data->package, tmpfileW );
             }
-            msi_free(tmpfileW);
+            free(tmpfileW);
         }
         else WARN( "failed to create %s (error %lu)\n", debugstr_w(path), err );
     }
 
 done:
-    msi_free(path);
+    free(path);
 
     return (INT_PTR)handle;
 }
@@ -508,7 +508,7 @@ static INT_PTR cabinet_close_file_info(FDINOTIFICATIONTYPE fdint,
     CloseHandle(handle);
     data->cb(data->package, data->curfile, MSICABEXTRACT_FILEEXTRACTED, NULL, NULL, data->user);
 
-    msi_free(data->curfile);
+    free(data->curfile);
     data->curfile = NULL;
 
     return 1;
@@ -591,8 +591,8 @@ static BOOL extract_cabinet( MSIPACKAGE* package, MSIMEDIAINFO *mi, LPVOID data
 
 done:
     FDIDestroy( hfdi );
-    msi_free(cabinet );
-    msi_free( cab_path );
+    free( cabinet );
+    free( cab_path );
 
     if (ret)
         mi->is_extracted = TRUE;
@@ -644,11 +644,11 @@ BOOL msi_cabextract(MSIPACKAGE* package, MSIMEDIAINFO *mi, LPVOID data)
 
 void msi_free_media_info(MSIMEDIAINFO *mi)
 {
-    msi_free(mi->disk_prompt);
-    msi_free(mi->cabinet);
-    msi_free(mi->volume_label);
-    msi_free(mi->last_volume);
-    msi_free(mi);
+    free(mi->disk_prompt);
+    free(mi->cabinet);
+    free(mi->volume_label);
+    free(mi->last_volume);
+    free(mi);
 }
 
 static UINT get_drive_type(const WCHAR *path)
@@ -666,7 +666,7 @@ static WCHAR *get_base_url( MSIDATABASE *db )
 {
     WCHAR *p, *ret = NULL, *orig_db = msi_dup_property( db, L"OriginalDatabase" );
     if (UrlIsW( orig_db, URLIS_URL ) && (ret = wcsdup( orig_db )) && (p = wcsrchr( ret, '/' ))) p[1] = 0;
-    msi_free( orig_db );
+    free( orig_db );
     return ret;
 }
 
@@ -689,11 +689,11 @@ UINT msi_load_media_info(MSIPACKAGE *package, UINT Sequence, MSIMEDIAINFO *mi)
     mi->is_extracted = FALSE;
     mi->disk_id = MSI_RecordGetInteger(row, 1);
     mi->last_sequence = MSI_RecordGetInteger(row, 2);
-    msi_free(mi->disk_prompt);
+    free(mi->disk_prompt);
     mi->disk_prompt = wcsdup(MSI_RecordGetString(row, 3));
-    msi_free(mi->cabinet);
+    free(mi->cabinet);
     mi->cabinet = wcsdup(MSI_RecordGetString(row, 4));
-    msi_free(mi->volume_label);
+    free(mi->volume_label);
     mi->volume_label = wcsdup(MSI_RecordGetString(row, 5));
     msiobj_release(&row->hdr);
 
@@ -729,8 +729,8 @@ UINT msi_load_media_info(MSIPACKAGE *package, UINT Sequence, MSIMEDIAINFO *mi)
 
     TRACE("sequence %u -> cabinet %s disk id %u\n", Sequence, debugstr_w(mi->cabinet), mi->disk_id);
 
-    msi_free(base_url);
-    msi_free(source_dir);
+    free(base_url);
+    free(source_dir);
     return ERROR_SUCCESS;
 }
 
@@ -810,12 +810,12 @@ static UINT find_published_source(MSIPACKAGE *package, MSIMEDIAINFO *mi)
                                         volume, &volumesz, prompt, &promptsz) == ERROR_SUCCESS)
     {
         mi->disk_id = id;
-        msi_free( mi->volume_label );
-        if (!(mi->volume_label = msi_alloc( ++volumesz * sizeof(WCHAR) ))) return ERROR_OUTOFMEMORY;
+        free( mi->volume_label );
+        if (!(mi->volume_label = malloc( ++volumesz * sizeof(WCHAR) ))) return ERROR_OUTOFMEMORY;
         lstrcpyW( mi->volume_label, volume );
 
-        msi_free( mi->disk_prompt );
-        if (!(mi->disk_prompt = msi_alloc( ++promptsz * sizeof(WCHAR) ))) return ERROR_OUTOFMEMORY;
+        free( mi->disk_prompt );
+        if (!(mi->disk_prompt = malloc( ++promptsz * sizeof(WCHAR) ))) return ERROR_OUTOFMEMORY;
         lstrcpyW( mi->disk_prompt, prompt );
 
         if (source_matches_volume(mi, source))
@@ -854,8 +854,8 @@ UINT ready_media( MSIPACKAGE *package, BOOL compressed, MSIMEDIAINFO *mi )
         {
             WCHAR temppath[MAX_PATH], *p, *url;
 
-            msi_free( cabinet_file );
-            if (!(url = msi_alloc( (lstrlenW( base_url ) + lstrlenW( mi->cabinet ) + 1) * sizeof(WCHAR) )))
+            free( cabinet_file );
+            if (!(url = malloc( (wcslen( base_url ) + wcslen( mi->cabinet ) + 1) * sizeof(WCHAR) )))
             {
                 return ERROR_OUTOFMEMORY;
             }
@@ -864,16 +864,16 @@ UINT ready_media( MSIPACKAGE *package, BOOL compressed, MSIMEDIAINFO *mi )
             if ((rc = msi_download_file( url, temppath )) != ERROR_SUCCESS)
             {
                 ERR("failed to download %s (%u)\n", debugstr_w(url), rc);
-                msi_free( url );
+                free( url );
                 return rc;
             }
             if ((p = wcsrchr( temppath, '\\' ))) *p = 0;
             lstrcpyW( mi->sourcedir, temppath );
             PathAddBackslashW( mi->sourcedir );
-            msi_free( mi->cabinet );
+            free( mi->cabinet );
             mi->cabinet = wcsdup( p + 1 );
 
-            msi_free( url );
+            free( url );
             return ERROR_SUCCESS;
         }
     }
@@ -885,19 +885,19 @@ UINT ready_media( MSIPACKAGE *package, BOOL compressed, MSIMEDIAINFO *mi )
         {
             WCHAR *source = msi_dup_property( package->db, L"SourceDir" );
             BOOL match = source_matches_volume( mi, source );
-            msi_free( source );
+            free( source );
 
             if (!match && (mi->type == DRIVE_CDROM || mi->type == DRIVE_REMOVABLE))
             {
                 if ((rc = msi_change_media( package, mi )) != ERROR_SUCCESS)
                 {
-                    msi_free( cabinet_file );
+                    free( cabinet_file );
                     return rc;
                 }
             }
         }
 
-        msi_free(mi->last_volume);
+        free(mi->last_volume);
         mi->last_volume = wcsdup(mi->volume_label);
     }
     if (mi->cabinet)
@@ -907,12 +907,12 @@ UINT ready_media( MSIPACKAGE *package, BOOL compressed, MSIMEDIAINFO *mi )
             if ((rc = find_published_source( package, mi )) != ERROR_SUCCESS)
             {
                 ERR("cabinet not found: %s\n", debugstr_w(cabinet_file));
-                msi_free( cabinet_file );
+                free( cabinet_file );
                 return ERROR_INSTALL_FAILURE;
             }
         }
     }
-    msi_free( cabinet_file );
+    free( cabinet_file );
     return ERROR_SUCCESS;
 }
 
@@ -930,10 +930,10 @@ UINT msi_add_cabinet_stream( MSIPACKAGE *package, UINT disk_id, IStorage *storag
             return ERROR_FUNCTION_FAILED;
         }
     }
-    if (!(cab = msi_alloc( sizeof(*cab) ))) return ERROR_OUTOFMEMORY;
-    if (!(cab->stream = msi_alloc( (lstrlenW( name ) + 1) * sizeof(WCHAR ) )))
+    if (!(cab = malloc( sizeof(*cab) ))) return ERROR_OUTOFMEMORY;
+    if (!(cab->stream = malloc( (wcslen( name ) + 1) * sizeof(WCHAR) )))
     {
-        msi_free( cab );
+        free( cab );
         return ERROR_OUTOFMEMORY;
     }
     lstrcpyW( cab->stream, name );
diff --git a/dlls/msi/msi.c b/dlls/msi/msi.c
index 56a4625febf4..db04babb899d 100644
--- a/dlls/msi/msi.c
+++ b/dlls/msi/msi.c
@@ -95,7 +95,7 @@ UINT WINAPI MsiOpenProductA(LPCSTR szProduct, MSIHANDLE *phProduct)
 
     r = MsiOpenProductW( szwProd, phProduct );
 
-    msi_free( szwProd );
+    free( szwProd );
 
     return r;
 }
@@ -137,7 +137,7 @@ static UINT MSI_OpenProductW(LPCWSTR szProduct, MSIPACKAGE **package)
 
 done:
     RegCloseKey(props);
-    msi_free(path);
+    free(path);
     return r;
 }
 
@@ -221,8 +221,8 @@ UINT WINAPI MsiInstallProductA(LPCSTR szPackagePath, LPCSTR szCommandLine)
     r = MsiInstallProductW( szwPath, szwCommand );
 
 end:
-    msi_free( szwPath );
-    msi_free( szwCommand );
+    free( szwPath );
+    free( szwCommand );
 
     return r;
 }
@@ -274,7 +274,7 @@ UINT WINAPI MsiReinstallProductA( const char *szProduct, DWORD dwReinstallMode )
 
     wszProduct = strdupAtoW(szProduct);
     rc = MsiReinstallProductW(wszProduct, dwReinstallMode);
-    msi_free(wszProduct);
+    free(wszProduct);
     return rc;
 }
 
@@ -308,9 +308,9 @@ UINT WINAPI MsiApplyPatchA(LPCSTR szPatchPackage, LPCSTR szInstallPackage,
     r = MsiApplyPatchW(patch_package, install_package, eInstallType, command_line);
 
 done:
-    msi_free(patch_package);
-    msi_free(install_package);
-    msi_free(command_line);
+    free(patch_package);
+    free(install_package);
+    free(command_line);
 
     return r;
 }
@@ -340,7 +340,7 @@ static UINT get_patch_product_codes( LPCWSTR szPatchPackage, WCHAR ***product_co
         goto done;
     }
 
-    codes = msi_alloc( ++size * sizeof(WCHAR) );
+    codes = malloc( ++size * sizeof(WCHAR) );
     if (!codes)
     {
         r = ERROR_OUTOFMEMORY;
@@ -354,7 +354,7 @@ static UINT get_patch_product_codes( LPCWSTR szPatchPackage, WCHAR ***product_co
 done:
     MsiCloseHandle( info );
     MsiCloseHandle( patch );
-    msi_free( codes );
+    free( codes );
     return r;
 }
 
@@ -376,10 +376,10 @@ static UINT MSI_ApplyPatchW(LPCWSTR szPatchPackage, LPCWSTR szProductCode, LPCWS
         cmd_ptr = L"";
 
     size = lstrlenW(cmd_ptr) + lstrlenW(L"%s PATCH=\"%s\"") + lstrlenW(szPatchPackage) + 1;
-    cmd = msi_alloc(size * sizeof(WCHAR));
+    cmd = malloc(size * sizeof(WCHAR));
     if (!cmd)
     {
-        msi_free(codes);
+        free(codes);
         return ERROR_OUTOFMEMORY;
     }
     swprintf(cmd, size, L"%s PATCH=\"%s\"", cmd_ptr, szPatchPackage);
@@ -402,8 +402,8 @@ static UINT MSI_ApplyPatchW(LPCWSTR szPatchPackage, LPCWSTR szProductCode, LPCWS
             r = ERROR_SUCCESS;
     }
 
-    msi_free(cmd);
-    msi_free(codes);
+    free(cmd);
+    free(codes);
     return r;
 }
 
@@ -449,9 +449,9 @@ UINT WINAPI MsiApplyMultiplePatchesA(LPCSTR szPatchPackages,
     r = MsiApplyMultiplePatchesW(patch_packages, product_code, properties_list);
 
 done:
-    msi_free(patch_packages);
-    msi_free(product_code);
-    msi_free(properties_list);
+    free(patch_packages);
+    free(product_code);
+    free(properties_list);
 
     return r;
 }
@@ -482,7 +482,7 @@ UINT WINAPI MsiApplyMultiplePatchesW(LPCWSTR szPatchPackages,
 
         if (!len) return ERROR_INVALID_NAME;
 
-        patch = msi_alloc((len + 1) * sizeof(WCHAR));
+        patch = malloc((len + 1) * sizeof(WCHAR));
         if (!patch)
             return ERROR_OUTOFMEMORY;
 
@@ -490,7 +490,7 @@ UINT WINAPI MsiApplyMultiplePatchesW(LPCWSTR szPatchPackages,
         patch[len] = '\0';
 
         r = MSI_ApplyPatchW(patch, szProductCode, szPropertiesList);
-        msi_free(patch);
+        free(patch);
 
         if (r != ERROR_SUCCESS || !*end)
             break;
@@ -503,8 +503,8 @@ UINT WINAPI MsiApplyMultiplePatchesW(LPCWSTR szPatchPackages,
 static void free_patchinfo( DWORD count, MSIPATCHSEQUENCEINFOW *info )
 {
     DWORD i;
-    for (i = 0; i < count; i++) msi_free( (WCHAR *)info[i].szPatchData );
-    msi_free( info );
+    for (i = 0; i < count; i++) free( (WCHAR *)info[i].szPatchData );
+    free( info );
 }
 
 static MSIPATCHSEQUENCEINFOW *patchinfoAtoW( DWORD count, const MSIPATCHSEQUENCEINFOA *info )
@@ -512,7 +512,7 @@ static MSIPATCHSEQUENCEINFOW *patchinfoAtoW( DWORD count, const MSIPATCHSEQUENCE
     DWORD i;
     MSIPATCHSEQUENCEINFOW *ret;
 
-    if (!(ret = msi_alloc( count * sizeof(MSIPATCHSEQUENCEINFOW) ))) return NULL;
+    if (!(ret = malloc( count * sizeof(MSIPATCHSEQUENCEINFOW) ))) return NULL;
     for (i = 0; i < count; i++)
     {
         if (info[i].szPatchData && !(ret[i].szPatchData = strdupAtoW( info[i].szPatchData )))
@@ -541,7 +541,7 @@ UINT WINAPI MsiDetermineApplicablePatchesA( const char *szProductPackagePath, DW
 
     if (!(psi = patchinfoAtoW( cPatchInfo, pPatchInfo )))
     {
-        msi_free( package_path );
+        free( package_path );
         return ERROR_OUTOFMEMORY;
     }
     r = MsiDetermineApplicablePatchesW( package_path, cPatchInfo, psi );
@@ -553,7 +553,7 @@ UINT WINAPI MsiDetermineApplicablePatchesA( const char *szProductPackagePath, DW
             pPatchInfo[i].uStatus = psi[i].uStatus;
         }
     }
-    msi_free( package_path );
+    free( package_path );
     free_patchinfo( cPatchInfo, psi );
     return r;
 }
@@ -626,7 +626,7 @@ static UINT MSI_ApplicablePatchXML( MSIPACKAGE *package, IXMLDOMDocument *desc )
     if (r != ERROR_SUCCESS)
         TRACE("patch not applicable\n");
 
-    msi_free( product_code );
+    free( product_code );
     return r;
 }
 
@@ -757,13 +757,13 @@ UINT WINAPI MsiDeterminePatchSequenceA( const char *product, const char *usersid
     if (!(productW = strdupAtoW( product ))) return ERROR_OUTOFMEMORY;
     if (usersid && !(usersidW = strdupAtoW( usersid )))
     {
-        msi_free( productW );
+        free( productW );
         return ERROR_OUTOFMEMORY;
     }
     if (!(patchinfoW = patchinfoAtoW( count, patchinfo )))
     {
-        msi_free( productW );
-        msi_free( usersidW );
+        free( productW );
+        free( usersidW );
         return ERROR_OUTOFMEMORY;
     }
     r = MsiDeterminePatchSequenceW( productW, usersidW, context, count, patchinfoW );
@@ -775,8 +775,8 @@ UINT WINAPI MsiDeterminePatchSequenceA( const char *product, const char *usersid
             patchinfo[i].uStatus = patchinfoW[i].uStatus;
         }
     }
-    msi_free( productW );
-    msi_free( usersidW );
+    free( productW );
+    free( usersidW );
     free_patchinfo( count, patchinfoW );
     return r;
 }
@@ -794,7 +794,7 @@ static UINT open_package( const WCHAR *product, const WCHAR *usersid,
     if ((localpath = msi_reg_get_val_str( props, L"LocalPackage" )))
     {
         lstrcpyW( sourcepath, localpath );
-        msi_free( localpath );
+        free( localpath );
     }
     RegCloseKey( props );
     if (!localpath || GetFileAttributesW( sourcepath ) == INVALID_FILE_ATTRIBUTES)
@@ -875,7 +875,7 @@ UINT WINAPI MsiConfigureProductExW(LPCWSTR szProduct, int iInstallLevel,
     if (context == MSIINSTALLCONTEXT_MACHINE)
         sz += lstrlenW(L" ALLUSERS=1");
 
-    commandline = msi_alloc(sz * sizeof(WCHAR));
+    commandline = malloc(sz * sizeof(WCHAR));
     if (!commandline)
     {
         r = ERROR_OUTOFMEMORY;
@@ -907,7 +907,7 @@ UINT WINAPI MsiConfigureProductExW(LPCWSTR szProduct, int iInstallLevel,
 
     r = MSI_InstallPackage( package, sourcepath, commandline );
 
-    msi_free(commandline);
+    free(commandline);
 
 end:
     msiobj_release( &package->hdr );
@@ -939,8 +939,8 @@ UINT WINAPI MsiConfigureProductExA(LPCSTR szProduct, int iInstallLevel,
     r = MsiConfigureProductExW( szwProduct, iInstallLevel, eInstallState,
                                 szwCommandLine );
 end:
-    msi_free( szwProduct );
-    msi_free( szwCommandLine);
+    free( szwProduct );
+    free( szwCommandLine);
 
     return r;
 }
@@ -961,7 +961,7 @@ UINT WINAPI MsiConfigureProductA(LPCSTR szProduct, int iInstallLevel,
     }
 
     r = MsiConfigureProductW( szwProduct, iInstallLevel, eInstallState );
-    msi_free( szwProduct );
+    free( szwProduct );
 
     return r;
 }
@@ -993,7 +993,7 @@ UINT WINAPI MsiGetProductCodeA(LPCSTR szComponent, LPSTR szBuffer)
     if(*szwBuffer)
         WideCharToMultiByte(CP_ACP, 0, szwBuffer, -1, szBuffer, GUID_SIZE, NULL, NULL);
 
-    msi_free( szwComponent );
+    free( szwComponent );
 
     return r;
 }
@@ -1209,7 +1209,7 @@ static UINT MSI_GetProductInfo(LPCWSTR szProduct, LPCWSTR szAttribute,
             else
             {
                 unsquash_guid(val, packagecode);
-                msi_free(val);
+                free(val);
                 val = wcsdup(packagecode);
             }
         }
@@ -1246,7 +1246,7 @@ static UINT MSI_GetProductInfo(LPCWSTR szProduct, LPCWSTR szAttribute,
         r = ERROR_BAD_CONFIGURATION;
 
     if (val != empty)
-        msi_free(val);
+        free(val);
 
 done:
     RegCloseKey(prodkey);
@@ -1278,8 +1278,8 @@ UINT WINAPI MsiGetProductInfoA(LPCSTR szProduct, LPCSTR szAttribute,
                             &buffer, pcchValueBuf );
 
 end:
-    msi_free( szwProduct );
-    msi_free( szwAttribute );
+    free( szwProduct );
+    free( szwAttribute );
 
     return r;
 }
@@ -1326,7 +1326,7 @@ UINT WINAPI MsiGetProductInfoExA(LPCSTR szProductCode, LPCSTR szUserSid,
     if (r != ERROR_SUCCESS)
         goto done;
 
-    value = msi_alloc(++len * sizeof(WCHAR));
+    value = malloc(++len * sizeof(WCHAR));
     if (!value)
     {
         r = ERROR_OUTOFMEMORY;
@@ -1357,10 +1357,10 @@ UINT WINAPI MsiGetProductInfoExA(LPCSTR szProductCode, LPCSTR szUserSid,
     *pcchValue = len - 1;
 
 done:
-    msi_free(product);
-    msi_free(usersid);
-    msi_free(property);
-    msi_free(value);
+    free(product);
+    free(usersid);
+    free(property);
+    free(value);
 
     return r;
 }
@@ -1479,7 +1479,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
             goto done;
         }
 
-        msi_free(val);
+        free(val);
 
         if (!wcscmp( szProperty, INSTALLPROPERTY_INSTALLEDPRODUCTNAMEW ))
             szProperty = L"DisplayName";
@@ -1527,7 +1527,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
                 if (!val)
                     goto done;
 
-                msi_free(val);
+                free(val);
                 val = wcsdup(L"5");
             }
             else
@@ -1538,7 +1538,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
         }
         else if (props && (val = reg_get_value(props, package, &type)))
         {
-            msi_free(val);
+            free(val);
             val = wcsdup(L"5");
             r = msi_copy_outval(val, szValue, pcchValue);
             goto done;
@@ -1568,7 +1568,7 @@ UINT WINAPI MsiGetProductInfoExW(LPCWSTR szProductCode, LPCWSTR szUserSid,
     RegCloseKey(prod);
     RegCloseKey(managed);
     RegCloseKey(classes);
-    msi_free(val);
+    free(val);
 
     return r;
 }
@@ -1616,7 +1616,7 @@ UINT WINAPI MsiGetPatchInfoExA(LPCSTR szPatchCode, LPCSTR szProductCode,
     if (r != ERROR_SUCCESS)
         goto done;
 
-    val = msi_alloc(++len * sizeof(WCHAR));
+    val = malloc(++len * sizeof(WCHAR));
     if (!val)
     {
         r = ERROR_OUTOFMEMORY;
@@ -1647,11 +1647,11 @@ UINT WINAPI MsiGetPatchInfoExA(LPCSTR szPatchCode, LPCSTR szProductCode,
         *pcchValue = len;
 
 done:
-    msi_free(val);
-    msi_free(patch);
-    msi_free(product);
-    msi_free(usersid);
-    msi_free(property);
+    free(val);
+    free(patch);
+    free(product);
+    free(usersid);
+    free(property);
 
     return r;
 }
@@ -1782,7 +1782,7 @@ UINT WINAPI MsiGetPatchInfoExW(LPCWSTR szPatchCode, LPCWSTR szProductCode,
     *pcchValue = len;
 
 done:
-    msi_free(val);
+    free(val);
     RegCloseKey(prodpatches);
     RegCloseKey(prod);
     RegCloseKey(patch);
@@ -1817,7 +1817,7 @@ UINT WINAPI MsiGetPatchInfoA( LPCSTR patch, LPCSTR attr, LPSTR buffer, LPDWORD b
         goto done;
 
     size++;
-    if (!(bufferW = msi_alloc( size * sizeof(WCHAR) )))
+    if (!(bufferW = malloc( size * sizeof(WCHAR) )))
     {
         r = ERROR_OUTOFMEMORY;
         goto done;
@@ -1836,9 +1836,9 @@ UINT WINAPI MsiGetPatchInfoA( LPCSTR patch, LPCSTR attr, LPSTR buffer, LPDWORD b
     }
 
 done:
-    msi_free( patchW );
-    msi_free( attrW );
-    msi_free( bufferW );
+    free( patchW );
+    free( attrW );
+    free( bufferW );
     return r;
 }
 
@@ -1895,7 +1895,7 @@ UINT WINAPI MsiEnableLogA( DWORD dwLogMode, const char *szLogFile, DWORD attribu
             return ERROR_OUTOFMEMORY;
     }
     r = MsiEnableLogW( dwLogMode, szwLogFile, attributes );
-    msi_free( szwLogFile );
+    free( szwLogFile );
     return r;
 }
 
@@ -1903,7 +1903,7 @@ UINT WINAPI MsiEnableLogW( DWORD dwLogMode, const WCHAR *szLogFile, DWORD attrib
 {
     TRACE( "%#lx, %s, %#lx\n", dwLogMode, debugstr_w(szLogFile), attributes );
 
-    msi_free(gszLogFile);
+    free(gszLogFile);
     gszLogFile = NULL;
     if (szLogFile)
     {
@@ -1938,9 +1938,9 @@ UINT WINAPI MsiEnumComponentCostsA( MSIHANDLE handle, const char *component, DWO
     if (component && !(componentW = strdupAtoW( component ))) return ERROR_OUTOFMEMORY;
 
     len = *buflen;
-    if (!(driveW = msi_alloc( len * sizeof(WCHAR) )))
+    if (!(driveW = malloc( len * sizeof(WCHAR) )))
     {
-        msi_free( componentW );
+        free( componentW );
         return ERROR_OUTOFMEMORY;
     }
     r = MsiEnumComponentCostsW( handle, componentW, index, state, driveW, buflen, cost, temp );
@@ -1948,8 +1948,8 @@ UINT WINAPI MsiEnumComponentCostsA( MSIHANDLE handle, const char *component, DWO
     {
         WideCharToMultiByte( CP_ACP, 0, driveW, -1, drive, len, NULL, NULL );
     }
-    msi_free( componentW );
-    msi_free( driveW );
+    free( componentW );
+    free( driveW );
     return r;
 }
 
@@ -2075,9 +2075,9 @@ UINT WINAPI MsiQueryComponentStateA(LPCSTR szProductCode,
 
     r = MsiQueryComponentStateW(prodcode, usersid, dwContext, comp, pdwState);
 
-    msi_free(prodcode);
-    msi_free(usersid);
-    msi_free(comp);
+    free(prodcode);
+    free(usersid);
+    free(comp);
 
     return r;
 }
@@ -2186,10 +2186,10 @@ UINT WINAPI MsiQueryComponentStateW(LPCWSTR szProductCode,
         WCHAR *val;
         UINT r;
 
-        if (!(val = msi_alloc( sz ))) return ERROR_OUTOFMEMORY;
+        if (!(val = malloc( sz ))) return ERROR_OUTOFMEMORY;
         if ((r = msi_comp_find_prodcode( squashed_pc, dwContext, szComponent, val, &sz )))
         {
-            msi_free(val);
+            free(val);
             return r;
         }
 
@@ -2200,7 +2200,7 @@ UINT WINAPI MsiQueryComponentStateW(LPCWSTR szProductCode,
         }
         else
             *pdwState = INSTALLSTATE_LOCAL;
-        msi_free( val );
+        free( val );
     }
 
     TRACE("-> %d\n", *pdwState);
@@ -2219,7 +2219,7 @@ INSTALLSTATE WINAPI MsiQueryProductStateA(LPCSTR szProduct)
              return ERROR_OUTOFMEMORY;
     }
     r = MsiQueryProductStateW( szwProduct );
-    msi_free( szwProduct );
+    free( szwProduct );
     return r;
 }
 
@@ -2404,7 +2404,7 @@ LANGID WINAPI MsiLoadStringA( MSIHANDLE handle, UINT id, LPSTR lpBuffer,
     LANGID r;
     INT len;
 
-    bufW = msi_alloc(nBufferMax*sizeof(WCHAR));
+    bufW = malloc(nBufferMax * sizeof(WCHAR));
     r = MsiLoadStringW(handle, id, bufW, nBufferMax, lang);
     if( r )
     {
@@ -2415,7 +2415,7 @@ LANGID WINAPI MsiLoadStringA( MSIHANDLE handle, UINT id, LPSTR lpBuffer,
         else
             r = 0;
     }
-    msi_free(bufW);
+    free(bufW);
     return r;
 }
 
@@ -2521,7 +2521,7 @@ HRESULT WINAPI MsiGetFileSignatureInformationA( const char *path, DWORD flags, P
 
     if (path && !(pathW = strdupAtoW( path ))) return E_OUTOFMEMORY;
     r = MsiGetFileSignatureInformationW( pathW, flags, cert, hash, hashlen );
-    msi_free( pathW );
+    free( pathW );
     return r;
 }
 
@@ -2618,7 +2618,7 @@ UINT WINAPI MsiGetProductPropertyA( MSIHANDLE hProduct, const char *szProperty,
         goto done;
     }
 
-    val = msi_alloc(++len * sizeof(WCHAR));
+    val = malloc(++len * sizeof(WCHAR));
     if (!val)
     {
         r = ERROR_OUTOFMEMORY;
@@ -2644,8 +2644,8 @@ UINT WINAPI MsiGetProductPropertyA( MSIHANDLE hProduct, const char *szProperty,
     }
 
 done:
-    msi_free(prop);
-    msi_free(val);
+    free(prop);
+    free(val);
 
     return r;
 }
@@ -2737,7 +2737,7 @@ UINT WINAPI MsiVerifyPackageA( LPCSTR szPackage )
 
     r = MsiVerifyPackageW( szPack );
 
-    msi_free( szPack );
+    free( szPack );
 
     return r;
 }
@@ -2822,7 +2822,7 @@ static INSTALLSTATE MSI_GetComponentPath( const WCHAR *szProduct, const WCHAR *s
 
         if (open_userdata_comp_key( szComponent, szUserSid, ctx, &hkey ))
         {
-            msi_free(path);
+            free(path);
             path = msi_reg_get_val_str( hkey, squashed_pc );
             RegCloseKey(hkey);
 
@@ -2842,7 +2842,7 @@ static INSTALLSTATE MSI_GetComponentPath( const WCHAR *szProduct, const WCHAR *s
     if (msi_strcpy_to_awstring(path, -1, lpPathBuf, pcchBuf) == ERROR_MORE_DATA)
         state = INSTALLSTATE_MOREDATA;
 
-    msi_free(path);
+    free(path);
     return state;
 }
 
@@ -2883,9 +2883,9 @@ INSTALLSTATE WINAPI MsiGetComponentPathExA( LPCSTR product, LPCSTR comp, LPCSTR
     r = MSI_GetComponentPath( productW, compW, usersidW, ctx, &path, buflen );
 
 end:
-    msi_free( productW );
-    msi_free( compW );
-    msi_free( usersidW );
+    free( productW );
+    free( compW );
+    free( usersidW );
 
     return r;
 }
@@ -2926,7 +2926,7 @@ static UINT query_feature_state( const WCHAR *product, const WCHAR *squashed, co
     if (!parent) return ERROR_UNKNOWN_FEATURE;
 
     *state = (parent[0] == 6) ? INSTALLSTATE_ABSENT : INSTALLSTATE_LOCAL;
-    msi_free( parent );
+    free( parent );
     if (*state == INSTALLSTATE_ABSENT)
         return ERROR_SUCCESS;
 
@@ -2951,7 +2951,7 @@ static UINT query_feature_state( const WCHAR *product, const WCHAR *squashed, co
         if (!decode_base85_guid( p, &guid ))
         {
             if (p != components) break;
-            msi_free( components );
+            free( components );
             *state = INSTALLSTATE_BADCONFIG;
             return ERROR_BAD_CONFIGURATION;
         }
@@ -2963,7 +2963,7 @@ static UINT query_feature_state( const WCHAR *product, const WCHAR *squashed, co
 
         if (r != ERROR_SUCCESS)
         {
-            msi_free( components );
+            free( components );
             *state = INSTALLSTATE_ADVERTISED;
             return ERROR_SUCCESS;
         }
@@ -2975,9 +2975,9 @@ static UINT query_feature_state( const WCHAR *product, const WCHAR *squashed, co
         {
             source = TRUE;
         }
-        msi_free( path );
+        free( path );
     }
-    msi_free( components );
+    free( components );
 
     if (missing)
         *state = INSTALLSTATE_ADVERTISED;
@@ -2999,19 +2999,19 @@ UINT WINAPI MsiQueryFeatureStateExA( LPCSTR product, LPCSTR usersid, MSIINSTALLC
     if (product && !(productW = strdupAtoW( product ))) return ERROR_OUTOFMEMORY;
     if (usersid && !(usersidW = strdupAtoW( usersid )))
     {
-        msi_free( productW );
+        free( productW );
         return ERROR_OUTOFMEMORY;
     }
     if (feature && !(featureW = strdupAtoW( feature )))
     {
-        msi_free( productW );
-        msi_free( usersidW );
+        free( productW );
+        free( usersidW );
         return ERROR_OUTOFMEMORY;
     }
     r = MsiQueryFeatureStateExW( productW, usersidW, ctx, featureW, state );
-    msi_free( productW );
-    msi_free( usersidW );
-    msi_free( featureW );
+    free( productW );
+    free( usersidW );
+    free( featureW );
     return r;
 }
 
@@ -3042,8 +3042,8 @@ INSTALLSTATE WINAPI MsiQueryFeatureStateA(LPCSTR szProduct, LPCSTR szFeature)
     rc = MsiQueryFeatureStateW(szwProduct, szwFeature);
 
 end:
-    msi_free( szwProduct);
-    msi_free( szwFeature);
+    free(szwProduct);
+    free(szwFeature);
 
     return rc;
 }
@@ -3110,14 +3110,14 @@ UINT WINAPI MsiGetFileVersionA(LPCSTR szFilePath, LPSTR lpVersionBuf,
 
     if( lpVersionBuf && pcchVersionBuf && *pcchVersionBuf )
     {
-        lpwVersionBuff = msi_alloc(*pcchVersionBuf*sizeof(WCHAR));
+        lpwVersionBuff = malloc(*pcchVersionBuf * sizeof(WCHAR));
         if( !lpwVersionBuff )
             goto end;
     }
 
     if( lpLangBuf && pcchLangBuf && *pcchLangBuf )
     {
-        lpwLangBuff = msi_alloc(*pcchLangBuf*sizeof(WCHAR));
+        lpwLangBuff = malloc(*pcchLangBuf * sizeof(WCHAR));
         if( !lpwLangBuff )
             goto end;
     }
@@ -3133,9 +3133,9 @@ UINT WINAPI MsiGetFileVersionA(LPCSTR szFilePath, LPSTR lpVersionBuf,
                             lpLangBuf, *pcchLangBuf + 1, NULL, NULL);
 
 end:
-    msi_free(szwFilePath);
-    msi_free(lpwVersionBuff);
-    msi_free(lpwLangBuff);
+    free(szwFilePath);
+    free(lpwVersionBuff);
+    free(lpwLangBuff);
 
     return ret;
 }
@@ -3158,15 +3158,15 @@ static UINT get_file_version( const WCHAR *path, WCHAR *verbuf, DWORD *verlen,
         if (error == ERROR_RESOURCE_DATA_NOT_FOUND) return ERROR_FILE_INVALID;
         return error;
     }
-    if (!(version = msi_alloc( len ))) return ERROR_OUTOFMEMORY;
+    if (!(version = malloc( len ))) return ERROR_OUTOFMEMORY;
     if (!GetFileVersionInfoW( path, 0, len, version ))
     {
-        msi_free( version );
+        free( version );
         return GetLastError();
     }
     if (!verbuf && !verlen && !langbuf && !langlen)
     {
-        msi_free( version );
+        free( version );
         return ERROR_SUCCESS;
     }
     if (verlen)
@@ -3203,7 +3203,7 @@ static UINT get_file_version( const WCHAR *path, WCHAR *verbuf, DWORD *verlen,
             *langlen = 0;
         }
     }
-    msi_free( version );
+    free( version );
     return ret;
 }
 
@@ -3234,7 +3234,7 @@ UINT WINAPI MsiGetFileVersionW( const WCHAR *path, WCHAR *verbuf, DWORD *verlen,
             ret = ERROR_SUCCESS;
         }
         *verlen = len;
-        msi_free( version );
+        free( version );
     }
     return ret;
 }
@@ -3273,8 +3273,8 @@ UINT WINAPI MsiGetFeatureUsageA( LPCSTR szProduct, LPCSTR szFeature,
     ret = MsiGetFeatureUsageW( prod, feat, pdwUseCount, pwDateUsed );
 
 end:
-    msi_free( prod );
-    msi_free( feat );
+    free( prod );
+    free( feat );
 
     return ret;
 }
@@ -3325,8 +3325,8 @@ INSTALLSTATE WINAPI MsiUseFeatureExA( const char *szProduct, const char *szFeatu
     ret = MsiUseFeatureExW( prod, feat, dwInstallMode, dwReserved );
 
 end:
-    msi_free( prod );
-    msi_free( feat );
+    free( prod );
+    free( feat );
 
     return ret;
 }
@@ -3352,7 +3352,7 @@ static WCHAR *reg_get_multisz( HKEY hkey, const WCHAR *name )
     WCHAR *ret;
     DWORD len, type;
     if (RegQueryValueExW( hkey, name, NULL, &type, NULL, &len ) || type != REG_MULTI_SZ) return NULL;
-    if ((ret = msi_alloc( len ))) RegQueryValueExW( hkey, name, NULL, NULL, (BYTE *)ret, &len );
+    if ((ret = malloc( len ))) RegQueryValueExW( hkey, name, NULL, NULL, (BYTE *)ret, &len );
     return ret;
 }
 
@@ -3361,7 +3361,7 @@ static WCHAR *reg_get_sz( HKEY hkey, const WCHAR *name )
     WCHAR *ret;
     DWORD len, type;
     if (RegQueryValueExW( hkey, name, NULL, &type, NULL, &len ) || type != REG_SZ) return NULL;
-    if ((ret = msi_alloc( len ))) RegQueryValueExW( hkey, name, NULL, NULL, (BYTE *)ret, &len );
+    if ((ret = malloc( len ))) RegQueryValueExW( hkey, name, NULL, NULL, (BYTE *)ret, &len );
     return ret;
 }
 
@@ -3390,7 +3390,7 @@ static UINT MSI_ProvideQualifiedComponentEx(LPCWSTR szComponent,
 
     /* FIXME: handle multiple descriptors */
     ret = MsiDecomposeDescriptorW( desc, product, feature, comp, &size );
-    msi_free( desc );
+    free( desc );
     if (ret != ERROR_SUCCESS) return ret;
 
     if (!szProduct) szProduct = product;
@@ -3412,10 +3412,10 @@ static UINT MSI_ProvideQualifiedComponentEx(LPCWSTR szComponent,
 
         if (lstrlenW( components ) < BASE85_SIZE || !decode_base85_guid( components, &guid ))
         {
-            msi_free( components );
+            free( components );
             return ERROR_FILE_NOT_FOUND;
         }
-        msi_free( components );
+        free( components );
         StringFromGUID2( &guid, comp, ARRAY_SIZE( comp ));
     }
 
@@ -3478,9 +3478,9 @@ UINT WINAPI MsiProvideQualifiedComponentExA( const char *szComponent, const char
                               dwInstallMode, szwProduct, Unused1,
                               Unused2, &path, pcchPathBuf);
 end:
-    msi_free(szwProduct);
-    msi_free(szwComponent);
-    msi_free(szwQualifier);
+    free(szwProduct);
+    free(szwComponent);
+    free(szwQualifier);
 
     return r;
 }
@@ -3601,9 +3601,9 @@ static USERINFOSTATE MSI_GetUserInfo(LPCWSTR szProduct,
     }
 
 done:
-    msi_free(user);
-    msi_free(org);
-    msi_free(serial);
+    free(user);
+    free(org);
+    free(serial);
 
     return state;
 }
@@ -3664,7 +3664,7 @@ USERINFOSTATE WINAPI MsiGetUserInfoA(LPCSTR szProduct,
                          &org, pcchOrgNameBuf,
                          &serial, pcchSerialBuf );
 
-    msi_free( prod );
+    free( prod );
 
     return r;
 }
@@ -3740,8 +3740,8 @@ UINT WINAPI MsiConfigureFeatureA(LPCSTR szProduct, LPCSTR szFeature, INSTALLSTAT
     r = MsiConfigureFeatureW(prod, feat, eInstallState);
 
 end:
-    msi_free(feat);
-    msi_free(prod);
+    free(feat);
+    free(prod);
 
     return r;
 }
@@ -3855,7 +3855,7 @@ UINT WINAPI MsiGetShortcutTargetA( LPCSTR szShortcutTarget,
     feature[0] = 0;
     component[0] = 0;
     r = MsiGetShortcutTargetW( target, product, feature, component );
-    msi_free( target );
+    free( target );
     if (r == ERROR_SUCCESS)
     {
         WideCharToMultiByte( CP_ACP, 0, product, -1, szProductCode, len, NULL, NULL );
@@ -3978,7 +3978,7 @@ UINT WINAPI MsiReinstallFeatureW( const WCHAR *szProduct, const WCHAR *szFeature
 
     sz = (lstrlenW( L"%s=%s %s=%s" ) + lstrlenW( L"REINSTALLMODE" ) + lstrlenW( reinstallmode )) * sizeof(WCHAR);
     sz += (lstrlenW( L"REINSTALL" ) + lstrlenW( szFeature )) * sizeof(WCHAR);
-    if (!(cmdline = msi_alloc( sz )))
+    if (!(cmdline = malloc( sz )))
     {
         msiobj_release( &package->hdr );
         return ERROR_OUTOFMEMORY;
@@ -3987,7 +3987,7 @@ UINT WINAPI MsiReinstallFeatureW( const WCHAR *szProduct, const WCHAR *szFeature
 
     r = MSI_InstallPackage( package, sourcepath, cmdline );
     msiobj_release( &package->hdr );
-    msi_free( cmdline );
+    free( cmdline );
 
     return r;
 }
@@ -4004,8 +4004,8 @@ UINT WINAPI MsiReinstallFeatureA( const char *szProduct, const char *szFeature,
 
     rc = MsiReinstallFeatureW(wszProduct, wszFeature, dwReinstallMode);
 
-    msi_free(wszProduct);
-    msi_free(wszFeature);
+    free(wszProduct);
+    free(wszFeature);
     return rc;
 }
 
@@ -4105,7 +4105,7 @@ UINT WINAPI MsiGetFileHashA( const char *szFilePath, DWORD dwOptions, MSIFILEHAS
         return ERROR_OUTOFMEMORY;
 
     r = MsiGetFileHashW( file, dwOptions, pHash );
-    msi_free( file );
+    free( file );
     return r;
 }
 
@@ -4182,13 +4182,13 @@ UINT WINAPI MsiInstallMissingComponentA( LPCSTR product, LPCSTR component, INSTA
 
     if (component && !(componentW = strdupAtoW( component )))
     {
-        msi_free( productW );
+        free( productW );
         return ERROR_OUTOFMEMORY;
     }
 
     r = MsiInstallMissingComponentW( productW, componentW, state );
-    msi_free( productW );
-    msi_free( componentW );
+    free( productW );
+    free( componentW );
     return r;
 }
 
@@ -4220,7 +4220,7 @@ UINT WINAPI MsiProvideComponentA( const char *product, const char *feature, cons
     if (r != ERROR_SUCCESS)
         goto done;
 
-    if (!(bufW = msi_alloc( ++lenW * sizeof(WCHAR) )))
+    if (!(bufW = malloc( ++lenW * sizeof(WCHAR) )))
     {
         r = ERROR_OUTOFMEMORY;
         goto done;
@@ -4242,10 +4242,10 @@ UINT WINAPI MsiProvideComponentA( const char *product, const char *feature, cons
     *buflen = len - 1;
 
 done:
-    msi_free( productW );
-    msi_free( featureW );
-    msi_free( componentW );
-    msi_free( bufW );
+    free( productW );
+    free( featureW );
+    free( componentW );
+    free( bufW );
     return r;
 }
 
@@ -4306,7 +4306,7 @@ UINT WINAPI MsiBeginTransactionA( const char *name, DWORD attrs, MSIHANDLE *id,
         return ERROR_OUTOFMEMORY;
 
     r = MsiBeginTransactionW( nameW, attrs, id, event );
-    msi_free( nameW );
+    free( nameW );
     return r;
 }
 
diff --git a/dlls/msi/msi_main.c b/dlls/msi/msi_main.c
index 738d9272cd9a..258489c4ef10 100644
--- a/dlls/msi/msi_main.c
+++ b/dlls/msi/msi_main.c
@@ -80,7 +80,7 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
         if (lpvReserved) break;
         msi_dialog_unregister_class();
         msi_free_handle_table();
-        msi_free( gszLogFile );
+        free( gszLogFile );
         release_typelib();
         break;
     }
diff --git a/dlls/msi/msipriv.h b/dlls/msi/msipriv.h
index 20150cf5c466..1db770481efe 100644
--- a/dlls/msi/msipriv.h
+++ b/dlls/msi/msipriv.h
@@ -1138,30 +1138,6 @@ extern DWORD call_script(MSIHANDLE hPackage, INT type, LPCWSTR script, LPCWSTR f
 /* User interface messages from the actions */
 extern void msi_ui_progress(MSIPACKAGE *, int, int, int, int) DECLSPEC_HIDDEN;
 
-/* memory allocation macro functions */
-static void *msi_alloc( size_t len ) __WINE_ALLOC_SIZE(1);
-static inline void *msi_alloc( size_t len )
-{
-    return malloc( len );
-}
-
-static void *msi_alloc_zero( size_t len ) __WINE_ALLOC_SIZE(1);
-static inline void *msi_alloc_zero( size_t len )
-{
-    return calloc( 1, len );
-}
-
-static void *msi_realloc( void *mem, size_t len ) __WINE_ALLOC_SIZE(2);
-static inline void *msi_realloc( void *mem, size_t len )
-{
-    return realloc( mem, len );
-}
-
-static inline void msi_free( void *mem )
-{
-    free( mem );
-}
-
 static inline char *strdupWtoA( LPCWSTR str )
 {
     LPSTR ret = NULL;
@@ -1169,7 +1145,7 @@ static inline char *strdupWtoA( LPCWSTR str )
 
     if (!str) return ret;
     len = WideCharToMultiByte( CP_ACP, 0, str, -1, NULL, 0, NULL, NULL);
-    ret = msi_alloc( len );
+    ret = malloc( len );
     if (ret)
         WideCharToMultiByte( CP_ACP, 0, str, -1, ret, len, NULL, NULL );
     return ret;
@@ -1182,7 +1158,7 @@ static inline LPWSTR strdupAtoW( LPCSTR str )
 
     if (!str) return ret;
     len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
-    ret = msi_alloc( len * sizeof(WCHAR) );
+    ret = malloc( len * sizeof(WCHAR) );
     if (ret)
         MultiByteToWideChar( CP_ACP, 0, str, -1, ret, len );
     return ret;
diff --git a/dlls/msi/msiquery.c b/dlls/msi/msiquery.c
index 00135a0317a0..b4fbf2797009 100644
--- a/dlls/msi/msiquery.c
+++ b/dlls/msi/msiquery.c
@@ -52,7 +52,7 @@ static void MSI_CloseView( MSIOBJECTHDR *arg )
 
     LIST_FOR_EACH_SAFE( ptr, t, &query->mem )
     {
-        msi_free( ptr );
+        free( ptr );
     }
 }
 
@@ -103,7 +103,7 @@ UINT WINAPI MsiDatabaseOpenViewA( MSIHANDLE hdb, const char *szQuery, MSIHANDLE
 
     r = MsiDatabaseOpenViewW( hdb, szwQuery, phView);
 
-    msi_free( szwQuery );
+    free( szwQuery );
     return r;
 }
 
@@ -145,18 +145,18 @@ UINT WINAPIV MSI_OpenQuery( MSIDATABASE *db, MSIQUERY **view, LPCWSTR fmt, ... )
     for (;;)
     {
         va_list va;
-        query = msi_alloc( size*sizeof(WCHAR) );
+        query = malloc(size * sizeof(WCHAR));
         va_start(va, fmt);
         res = vswprintf(query, size, fmt, va);
         va_end(va);
         if (res == -1) size *= 2;
         else if (res >= size) size = res + 1;
         else break;
-        msi_free( query );
+        free(query);
     }
     /* perform the query */
     r = MSI_DatabaseOpenViewW(db, query, view);
-    msi_free(query);
+    free(query);
     return r;
 }
 
@@ -210,18 +210,18 @@ MSIRECORD * WINAPIV MSI_QueryGetRecord( MSIDATABASE *db, LPCWSTR fmt, ... )
     for (;;)
     {
         va_list va;
-        query = msi_alloc( size*sizeof(WCHAR) );
+        query = malloc(size * sizeof(WCHAR));
         va_start(va, fmt);
         res = vswprintf(query, size, fmt, va);
         va_end(va);
         if (res == -1) size *= 2;
         else if (res >= size) size = res + 1;
         else break;
-        msi_free( query );
+        free(query);
     }
     /* perform the query */
     r = MSI_DatabaseOpenViewW(db, query, &view);
-    msi_free(query);
+    free(query);
 
     if( r == ERROR_SUCCESS )
     {
@@ -942,7 +942,7 @@ UINT WINAPI MsiDatabaseApplyTransformA( MSIHANDLE hdb, const char *transform, in
         return ERROR_NOT_ENOUGH_MEMORY;
 
     ret = MsiDatabaseApplyTransformW( hdb, wstr, error_cond );
-    msi_free( wstr );
+    free( wstr );
     return ret;
 }
 
@@ -1002,7 +1002,7 @@ UINT WINAPI MsiDatabaseCommit( MSIHANDLE hdb )
 
     if (r == ERROR_SUCCESS)
     {
-        msi_free( db->deletefile );
+        free( db->deletefile );
         db->deletefile = NULL;
     }
 
@@ -1140,7 +1140,7 @@ UINT WINAPI MsiDatabaseGetPrimaryKeysA( MSIHANDLE hdb, const char *table, MSIHAN
             return ERROR_OUTOFMEMORY;
     }
     r = MsiDatabaseGetPrimaryKeysW( hdb, szwTable, phRec );
-    msi_free( szwTable );
+    free( szwTable );
 
     return r;
 }
@@ -1159,7 +1159,7 @@ MSICONDITION WINAPI MsiDatabaseIsTablePersistentA( MSIHANDLE hDatabase, const ch
             return MSICONDITION_ERROR;
     }
     r = MsiDatabaseIsTablePersistentW( hDatabase, szwTableName );
-    msi_free( szwTableName );
+    free( szwTableName );
 
     return r;
 }
diff --git a/dlls/msi/package.c b/dlls/msi/package.c
index 024449180c70..bfbbaadae1bd 100644
--- a/dlls/msi/package.c
+++ b/dlls/msi/package.c
@@ -60,21 +60,21 @@ static void free_feature( MSIFEATURE *feature )
     {
         FeatureList *fl = LIST_ENTRY( item, FeatureList, entry );
         list_remove( &fl->entry );
-        msi_free( fl );
+        free( fl );
     }
 
     LIST_FOR_EACH_SAFE( item, cursor, &feature->Components )
     {
         ComponentList *cl = LIST_ENTRY( item, ComponentList, entry );
         list_remove( &cl->entry );
-        msi_free( cl );
+        free( cl );
     }
-    msi_free( feature->Feature );
-    msi_free( feature->Feature_Parent );
-    msi_free( feature->Directory );
-    msi_free( feature->Description );
-    msi_free( feature->Title );
-    msi_free( feature );
+    free( feature->Feature );
+    free( feature->Feature_Parent );
+    free( feature->Directory );
+    free( feature->Description );
+    free( feature->Title );
+    free( feature );
 }
 
 static void free_folder( MSIFOLDER *folder )
@@ -85,16 +85,16 @@ static void free_folder( MSIFOLDER *folder )
     {
         FolderList *fl = LIST_ENTRY( item, FolderList, entry );
         list_remove( &fl->entry );
-        msi_free( fl );
+        free( fl );
     }
-    msi_free( folder->Parent );
-    msi_free( folder->Directory );
-    msi_free( folder->TargetDefault );
-    msi_free( folder->SourceLongPath );
-    msi_free( folder->SourceShortPath );
-    msi_free( folder->ResolvedTarget );
-    msi_free( folder->ResolvedSource );
-    msi_free( folder );
+    free( folder->Parent );
+    free( folder->Directory );
+    free( folder->TargetDefault );
+    free( folder->SourceLongPath );
+    free( folder->SourceShortPath );
+    free( folder->ResolvedTarget );
+    free( folder->ResolvedSource );
+    free( folder );
 }
 
 static void free_extension( MSIEXTENSION *ext )
@@ -106,35 +106,35 @@ static void free_extension( MSIEXTENSION *ext )
         MSIVERB *verb = LIST_ENTRY( item, MSIVERB, entry );
 
         list_remove( &verb->entry );
-        msi_free( verb->Verb );
-        msi_free( verb->Command );
-        msi_free( verb->Argument );
-        msi_free( verb );
+        free( verb->Verb );
+        free( verb->Command );
+        free( verb->Argument );
+        free( verb );
     }
 
-    msi_free( ext->Extension );
-    msi_free( ext->ProgIDText );
-    msi_free( ext );
+    free( ext->Extension );
+    free( ext->ProgIDText );
+    free( ext );
 }
 
 static void free_assembly( MSIASSEMBLY *assembly )
 {
-    msi_free( assembly->feature );
-    msi_free( assembly->manifest );
-    msi_free( assembly->application );
-    msi_free( assembly->display_name );
+    free( assembly->feature );
+    free( assembly->manifest );
+    free( assembly->application );
+    free( assembly->display_name );
     if (assembly->tempdir) RemoveDirectoryW( assembly->tempdir );
-    msi_free( assembly->tempdir );
-    msi_free( assembly );
+    free( assembly->tempdir );
+    free( assembly );
 }
 
 void msi_free_action_script( MSIPACKAGE *package, UINT script )
 {
     UINT i;
     for (i = 0; i < package->script_actions_count[script]; i++)
-        msi_free( package->script_actions[script][i] );
+        free( package->script_actions[script][i] );
 
-    msi_free( package->script_actions[script] );
+    free( package->script_actions[script] );
     package->script_actions[script] = NULL;
     package->script_actions_count[script] = 0;
 }
@@ -163,15 +163,15 @@ static void free_package_structures( MSIPACKAGE *package )
         MSIFILE *file = LIST_ENTRY( item, MSIFILE, entry );
 
         list_remove( &file->entry );
-        msi_free( file->File );
-        msi_free( file->FileName );
-        msi_free( file->ShortName );
-        msi_free( file->LongName );
-        msi_free( file->Version );
-        msi_free( file->Language );
+        free( file->File );
+        free( file->FileName );
+        free( file->ShortName );
+        free( file->LongName );
+        free( file->Version );
+        free( file->Language );
         if (msi_is_global_assembly( file->Component )) DeleteFileW( file->TargetPath );
-        msi_free( file->TargetPath );
-        msi_free( file );
+        free( file->TargetPath );
+        free( file );
     }
 
     LIST_FOR_EACH_SAFE( item, cursor, &package->components )
@@ -179,14 +179,14 @@ static void free_package_structures( MSIPACKAGE *package )
         MSICOMPONENT *comp = LIST_ENTRY( item, MSICOMPONENT, entry );
 
         list_remove( &comp->entry );
-        msi_free( comp->Component );
-        msi_free( comp->ComponentId );
-        msi_free( comp->Directory );
-        msi_free( comp->Condition );
-        msi_free( comp->KeyPath );
-        msi_free( comp->FullKeypath );
+        free( comp->Component );
+        free( comp->ComponentId );
+        free( comp->Directory );
+        free( comp->Condition );
+        free( comp->KeyPath );
+        free( comp->FullKeypath );
         if (comp->assembly) free_assembly( comp->assembly );
-        msi_free( comp );
+        free( comp );
     }
 
     LIST_FOR_EACH_SAFE( item, cursor, &package->filepatches )
@@ -194,8 +194,8 @@ static void free_package_structures( MSIPACKAGE *package )
         MSIFILEPATCH *patch = LIST_ENTRY( item, MSIFILEPATCH, entry );
 
         list_remove( &patch->entry );
-        msi_free( patch->path );
-        msi_free( patch );
+        free( patch->path );
+        free( patch );
     }
 
     /* clean up extension, progid, class and verb structures */
@@ -204,16 +204,16 @@ static void free_package_structures( MSIPACKAGE *package )
         MSICLASS *cls = LIST_ENTRY( item, MSICLASS, entry );
 
         list_remove( &cls->entry );
-        msi_free( cls->clsid );
-        msi_free( cls->Context );
-        msi_free( cls->Description );
-        msi_free( cls->FileTypeMask );
-        msi_free( cls->IconPath );
-        msi_free( cls->DefInprocHandler );
-        msi_free( cls->DefInprocHandler32 );
-        msi_free( cls->Argument );
-        msi_free( cls->ProgIDText );
-        msi_free( cls );
+        free( cls->clsid );
+        free( cls->Context );
+        free( cls->Description );
+        free( cls->FileTypeMask );
+        free( cls->IconPath );
+        free( cls->DefInprocHandler );
+        free( cls->DefInprocHandler32 );
+        free( cls->Argument );
+        free( cls->ProgIDText );
+        free( cls );
     }
 
     LIST_FOR_EACH_SAFE( item, cursor, &package->extensions )
@@ -229,10 +229,10 @@ static void free_package_structures( MSIPACKAGE *package )
         MSIPROGID *progid = LIST_ENTRY( item, MSIPROGID, entry );
 
         list_remove( &progid->entry );
-        msi_free( progid->ProgID );
-        msi_free( progid->Description );
-        msi_free( progid->IconPath );
-        msi_free( progid );
+        free( progid->ProgID );
+        free( progid->Description );
+        free( progid->IconPath );
+        free( progid );
     }
 
     LIST_FOR_EACH_SAFE( item, cursor, &package->mimes )
@@ -240,10 +240,10 @@ static void free_package_structures( MSIPACKAGE *package )
         MSIMIME *mt = LIST_ENTRY( item, MSIMIME, entry );
 
         list_remove( &mt->entry );
-        msi_free( mt->suffix );
-        msi_free( mt->clsid );
-        msi_free( mt->ContentType );
-        msi_free( mt );
+        free( mt->suffix );
+        free( mt->clsid );
+        free( mt->ContentType );
+        free( mt );
     }
 
     LIST_FOR_EACH_SAFE( item, cursor, &package->appids )
@@ -251,12 +251,12 @@ static void free_package_structures( MSIPACKAGE *package )
         MSIAPPID *appid = LIST_ENTRY( item, MSIAPPID, entry );
 
         list_remove( &appid->entry );
-        msi_free( appid->AppID );
-        msi_free( appid->RemoteServerName );
-        msi_free( appid->LocalServer );
-        msi_free( appid->ServiceParameters );
-        msi_free( appid->DllSurrogate );
-        msi_free( appid );
+        free( appid->AppID );
+        free( appid->RemoteServerName );
+        free( appid->LocalServer );
+        free( appid->ServiceParameters );
+        free( appid->DllSurrogate );
+        free( appid );
     }
 
     LIST_FOR_EACH_SAFE( item, cursor, &package->sourcelist_info )
@@ -264,8 +264,8 @@ static void free_package_structures( MSIPACKAGE *package )
         MSISOURCELISTINFO *info = LIST_ENTRY( item, MSISOURCELISTINFO, entry );
 
         list_remove( &info->entry );
-        msi_free( info->value );
-        msi_free( info );
+        free( info->value );
+        free( info );
     }
 
     LIST_FOR_EACH_SAFE( item, cursor, &package->sourcelist_media )
@@ -273,17 +273,17 @@ static void free_package_structures( MSIPACKAGE *package )
         MSIMEDIADISK *info = LIST_ENTRY( item, MSIMEDIADISK, entry );
 
         list_remove( &info->entry );
-        msi_free( info->volume_label );
-        msi_free( info->disk_prompt );
-        msi_free( info );
+        free( info->volume_label );
+        free( info->disk_prompt );
+        free( info );
     }
 
     for (i = 0; i < SCRIPT_MAX; i++)
         msi_free_action_script( package, i );
 
     for (i = 0; i < package->unique_actions_count; i++)
-        msi_free( package->unique_actions[i] );
-    msi_free( package->unique_actions);
+        free( package->unique_actions[i] );
+    free( package->unique_actions );
 
     LIST_FOR_EACH_SAFE( item, cursor, &package->binaries )
     {
@@ -292,9 +292,9 @@ static void free_package_structures( MSIPACKAGE *package )
         list_remove( &binary->entry );
         if (!DeleteFileW( binary->tmpfile ))
             ERR( "failed to delete %s (%lu)\n", debugstr_w(binary->tmpfile), GetLastError() );
-        msi_free( binary->source );
-        msi_free( binary->tmpfile );
-        msi_free( binary );
+        free( binary->source );
+        free( binary->tmpfile );
+        free( binary );
     }
 
     LIST_FOR_EACH_SAFE( item, cursor, &package->cabinet_streams )
@@ -303,8 +303,8 @@ static void free_package_structures( MSIPACKAGE *package )
 
         list_remove( &cab->entry );
         IStorage_Release( cab->storage );
-        msi_free( cab->stream );
-        msi_free( cab );
+        free( cab->stream );
+        free( cab );
     }
 
     LIST_FOR_EACH_SAFE( item, cursor, &package->patches )
@@ -319,12 +319,12 @@ static void free_package_structures( MSIPACKAGE *package )
         msi_free_patchinfo( patch );
     }
 
-    msi_free( package->PackagePath );
-    msi_free( package->ProductCode );
-    msi_free( package->ActionFormat );
-    msi_free( package->LastAction );
-    msi_free( package->LastActionTemplate );
-    msi_free( package->langids );
+    free( package->PackagePath );
+    free( package->ProductCode );
+    free( package->ActionFormat );
+    free( package->LastAction );
+    free( package->LastActionTemplate );
+    free( package->langids );
 
     /* cleanup control event subscriptions */
     msi_event_cleanup_all_subscriptions( package );
@@ -352,7 +352,7 @@ static void MSI_FreePackage( MSIOBJECTHDR *arg)
         custom_stop_server(package->custom_server_64_process, package->custom_server_64_pipe);
 
     if (package->delete_on_close) DeleteFileW( package->localfile );
-    msi_free( package->localfile );
+    free( package->localfile );
     MSI_ProcessMessage(NULL, INSTALLMESSAGE_TERMINATE, 0);
 }
 
@@ -476,7 +476,7 @@ static UINT set_user_sid_prop( MSIPACKAGE *package )
     size = 0;
     GetUserNameW( NULL, &size );
 
-    user_name = msi_alloc( (size + 1) * sizeof(WCHAR) );
+    user_name = malloc( (size + 1) * sizeof(WCHAR) );
     if (!user_name)
         return ERROR_OUTOFMEMORY;
 
@@ -487,8 +487,8 @@ static UINT set_user_sid_prop( MSIPACKAGE *package )
     dom_size = 0;
     LookupAccountNameW( NULL, user_name, NULL, &size, NULL, &dom_size, &use );
 
-    psid = msi_alloc( size );
-    dom = msi_alloc( dom_size*sizeof (WCHAR) );
+    psid = malloc( size );
+    dom = malloc( dom_size * sizeof (WCHAR) );
     if (!psid || !dom)
     {
         r = ERROR_OUTOFMEMORY;
@@ -505,9 +505,9 @@ static UINT set_user_sid_prop( MSIPACKAGE *package )
 
 done:
     LocalFree( sid_str );
-    msi_free( dom );
-    msi_free( psid );
-    msi_free( user_name );
+    free( dom );
+    free( psid );
+    free( user_name );
 
     return r;
 }
@@ -530,7 +530,7 @@ static LPWSTR get_fusion_filename(MSIPACKAGE *package)
         if (!RegQueryValueExW(hkey, L"InstallPath", NULL, &type, (BYTE *)path, &size))
         {
             len = lstrlenW(path) + lstrlenW(L"fusion.dll") + 2;
-            if (!(filename = msi_alloc(len * sizeof(WCHAR)))) return NULL;
+            if (!(filename = malloc(len * sizeof(WCHAR)))) return NULL;
 
             lstrcpyW(filename, path);
             lstrcatW(filename, L"\\");
@@ -552,8 +552,8 @@ static LPWSTR get_fusion_filename(MSIPACKAGE *package)
         GetWindowsDirectoryW(windir, MAX_PATH);
         len = lstrlenW(windir) + lstrlenW(L"Microsoft.NET\\Framework\\") + lstrlenW(L"v2.0.50727") +
               lstrlenW(L"fusion.dll") + 3;
-        msi_free(filename);
-        if (!(filename = msi_alloc(len * sizeof(WCHAR)))) return NULL;
+        free(filename);
+        if (!(filename = malloc(len * sizeof(WCHAR)))) return NULL;
 
         lstrcpyW(filename, windir);
         lstrcatW(filename, L"\\");
@@ -596,7 +596,7 @@ static void set_msi_assembly_prop(MSIPACKAGE *package)
     if (!size)
         goto done;
 
-    version = msi_alloc(size);
+    version = malloc(size);
     if (!version)
         goto done;
 
@@ -618,8 +618,8 @@ static void set_msi_assembly_prop(MSIPACKAGE *package)
     msi_set_property( package->db, L"MsiNetAssemblySupport", verstr, -1 );
 
 done:
-    msi_free(fusion);
-    msi_free(version);
+    free(fusion);
+    free(version);
 }
 
 static VOID set_installer_properties(MSIPACKAGE *package)
@@ -866,8 +866,8 @@ static VOID set_installer_properties(MSIPACKAGE *package)
             msi_set_property( package->db, L"COMPANYNAME", companyname, -1 );
         CloseHandle( hkey );
     }
-    msi_free( username );
-    msi_free( companyname );
+    free( username );
+    free( companyname );
 
     if ( set_user_sid_prop( package ) != ERROR_SUCCESS)
         ERR("Failed to set the UserSID property\n");
@@ -889,27 +889,27 @@ static VOID set_installer_properties(MSIPACKAGE *package)
     if (!GetUserNameW( NULL, &len ) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
     {
         WCHAR *username;
-        if ((username = msi_alloc( len * sizeof(WCHAR) )))
+        if ((username = malloc( len * sizeof(WCHAR) )))
         {
             if (GetUserNameW( username, &len ))
                 msi_set_property( package->db, L"LogonUser", username, len - 1 );
-            msi_free( username );
+            free( username );
         }
     }
     len = 0;
     if (!GetComputerNameW( NULL, &len ) && GetLastError() == ERROR_BUFFER_OVERFLOW)
     {
         WCHAR *computername;
-        if ((computername = msi_alloc( len * sizeof(WCHAR) )))
+        if ((computername = malloc( len * sizeof(WCHAR) )))
         {
             if (GetComputerNameW( computername, &len ))
                 msi_set_property( package->db, L"ComputerName", computername, len );
-            msi_free( computername );
+            free( computername );
         }
     }
 }
 
-static MSIPACKAGE *msi_alloc_package( void )
+static MSIPACKAGE *alloc_package( void )
 {
     MSIPACKAGE *package;
 
@@ -951,7 +951,7 @@ static UINT msi_load_admin_properties(MSIPACKAGE *package)
 
     r = msi_parse_command_line(package, (WCHAR *)data, TRUE);
 
-    msi_free(data);
+    free(data);
     return r;
 }
 
@@ -977,7 +977,7 @@ MSIPACKAGE *MSI_CreatePackage( MSIDATABASE *db )
 
     TRACE("%p\n", db);
 
-    package = msi_alloc_package();
+    package = alloc_package();
     if (package)
     {
         msiobj_addref( &db->hdr );
@@ -1030,16 +1030,16 @@ UINT msi_download_file( LPCWSTR szUrl, LPWSTR filename )
     GetUrlCacheEntryInfoW( szUrl, NULL, &size );
     if ( GetLastError() != ERROR_FILE_NOT_FOUND )
     {
-        cache_entry = msi_alloc( size );
+        cache_entry = malloc( size );
         if ( !GetUrlCacheEntryInfoW( szUrl, cache_entry, &size ) )
         {
             UINT error = GetLastError();
-            msi_free( cache_entry );
+            free( cache_entry );
             return error;
         }
 
         lstrcpyW( filename, cache_entry->lpszLocalFileName );
-        msi_free( cache_entry );
+        free( cache_entry );
         return ERROR_SUCCESS;
     }
 
@@ -1111,7 +1111,7 @@ static UINT parse_suminfo( MSISUMMARYINFO *si, MSIPACKAGE *package )
     if (!p)
     {
         WARN("invalid template string %s\n", debugstr_w(template));
-        msi_free( template );
+        free( template );
         return ERROR_PATCH_PACKAGE_INVALID;
     }
     *p = 0;
@@ -1127,22 +1127,22 @@ static UINT parse_suminfo( MSISUMMARYINFO *si, MSIPACKAGE *package )
     if (package->platform == PLATFORM_UNRECOGNIZED)
     {
         WARN("unknown platform %s\n", debugstr_w(template));
-        msi_free( template );
+        free( template );
         return ERROR_INSTALL_PLATFORM_UNSUPPORTED;
     }
     p++;
     if (!*p)
     {
-        msi_free( template );
+        free( template );
         return ERROR_SUCCESS;
     }
     count = 1;
     for (q = p; (q = wcschr( q, ',' )); q++) count++;
 
-    package->langids = msi_alloc( count * sizeof(LANGID) );
+    package->langids = malloc( count * sizeof(LANGID) );
     if (!package->langids)
     {
-        msi_free( template );
+        free( template );
         return ERROR_OUTOFMEMORY;
     }
 
@@ -1158,7 +1158,7 @@ static UINT parse_suminfo( MSISUMMARYINFO *si, MSIPACKAGE *package )
     }
     package->num_langids = i + 1;
 
-    msi_free( template );
+    free( template );
     return ERROR_SUCCESS;
 }
 
@@ -1264,7 +1264,7 @@ static UINT get_registered_local_package( const WCHAR *product, WCHAR *localfile
         return ERROR_FUNCTION_FAILED;
 
     lstrcpyW( localfile, filename );
-    msi_free( filename );
+    free( filename );
     return ERROR_SUCCESS;
 }
 
@@ -1297,7 +1297,7 @@ static UINT get_local_package( MSIDATABASE *db, WCHAR *localfile )
     if (!(product_code = get_product_code( db )))
         return ERROR_INSTALL_PACKAGE_INVALID;
     r = get_registered_local_package( product_code, localfile );
-    msi_free( product_code );
+    free( product_code );
     return r;
 }
 
@@ -1315,10 +1315,10 @@ UINT msi_set_original_database_property( MSIDATABASE *db, const WCHAR *package )
         WCHAR *path;
 
         if (!(len = GetFullPathNameW( package, 0, NULL, NULL ))) return GetLastError();
-        if (!(path = msi_alloc( len * sizeof(WCHAR) ))) return ERROR_OUTOFMEMORY;
+        if (!(path = malloc( len * sizeof(WCHAR) ))) return ERROR_OUTOFMEMORY;
         len = GetFullPathNameW( package, len, path, NULL );
         r = msi_set_property( db, L"OriginalDatabase", path, len );
-        msi_free( path );
+        free( path );
     }
     return r;
 }
@@ -1420,12 +1420,12 @@ UINT MSI_OpenPackageW(LPCWSTR szPackage, DWORD dwOptions, MSIPACKAGE **pPackage)
                     (product_version && wcscmp(product_version, cache_version)))
             {
                 msiobj_release( &db->hdr );
-                msi_free(product_version);
-                msi_free(cache_version);
+                free( product_version );
+                free( cache_version );
                 return ERROR_PRODUCT_VERSION;
             }
-            msi_free(product_version);
-            msi_free(cache_version);
+            free( product_version );
+            free( cache_version );
         }
     }
     package = MSI_CreatePackage( db );
@@ -1469,7 +1469,7 @@ UINT MSI_OpenPackageW(LPCWSTR szPackage, DWORD dwOptions, MSIPACKAGE **pPackage)
         TRACE("product already registered\n");
         msi_set_property( package->db, L"ProductToBeRegistered", L"1", -1 );
     }
-    msi_free(product_code);
+    free( product_code );
 
     while (1)
     {
@@ -1527,7 +1527,7 @@ UINT MSI_OpenPackageW(LPCWSTR szPackage, DWORD dwOptions, MSIPACKAGE **pPackage)
     }
     info_template = msi_get_error_message(package->db, MSIERR_INFO_LOGGINGSTART);
     MSI_RecordSetStringW(info_row, 0, info_template);
-    msi_free(info_template);
+    free(info_template);
     MSI_ProcessMessage(package, INSTALLMESSAGE_INFO|MB_ICONHAND, info_row);
 
     MSI_ProcessMessage(package, INSTALLMESSAGE_COMMONDATA, data_row);
@@ -1538,7 +1538,7 @@ UINT MSI_OpenPackageW(LPCWSTR szPackage, DWORD dwOptions, MSIPACKAGE **pPackage)
     MSI_RecordSetStringW(data_row, 3, NULL);
     MSI_ProcessMessage(package, INSTALLMESSAGE_COMMONDATA, data_row);
 
-    msi_free(productname);
+    free(productname);
     msiobj_release(&info_row->hdr);
     msiobj_release(&data_row->hdr);
 
@@ -1598,7 +1598,7 @@ UINT WINAPI MsiOpenPackageExA(LPCSTR szPackage, DWORD dwOptions, MSIHANDLE *phPa
 
     ret = MsiOpenPackageExW( szwPack, dwOptions, phPackage );
 
-    msi_free( szwPack );
+    free( szwPack );
 
     return ret;
 }
@@ -1675,7 +1675,7 @@ static INT internal_ui_handler(MSIPACKAGE *package, INSTALLMESSAGE eMessageType,
     {
         LPWSTR dialog = msi_dup_record_field(record, 0);
         INT rc = ACTION_DialogBox(package, dialog);
-        msi_free(dialog);
+        free(dialog);
         return rc;
     }
     case INSTALLMESSAGE_ACTIONSTART:
@@ -1687,7 +1687,7 @@ static INT internal_ui_handler(MSIPACKAGE *package, INSTALLMESSAGE eMessageType,
         MSI_RecordSetStringW(uirow, 1, deformatted);
         msi_event_fire(package, L"ActionText", uirow);
 
-        msi_free(deformatted);
+        free(deformatted);
         msiobj_release(&uirow->hdr);
         return 1;
     }
@@ -1772,7 +1772,7 @@ LPWSTR msi_get_error_message(MSIDATABASE *db, int error)
         int len = LoadStringW(msi_hInstance, IDS_ERROR_BASE + error, (LPWSTR) &ret, 0);
         if (len)
         {
-            ret = msi_alloc((len + 1) * sizeof(WCHAR));
+            ret = malloc((len + 1) * sizeof(WCHAR));
             LoadStringW(msi_hInstance, IDS_ERROR_BASE + error, ret, len + 1);
         }
         else
@@ -1801,14 +1801,14 @@ INT MSI_ProcessMessageVerbatim(MSIPACKAGE *package, INSTALLMESSAGE eMessageType,
         if (res != ERROR_SUCCESS && res != ERROR_MORE_DATA)
             return res;
         len++;
-        message = msi_alloc(len * sizeof(WCHAR));
+        message = malloc(len * sizeof(WCHAR));
         if (!message) return ERROR_OUTOFMEMORY;
         MSI_FormatRecordW(package, record, message, &len);
     }
 
     /* convert it to ANSI */
     len = WideCharToMultiByte( CP_ACP, 0, message, -1, NULL, 0, NULL, NULL );
-    msg = msi_alloc( len );
+    msg = malloc( len );
     WideCharToMultiByte( CP_ACP, 0, message, -1, msg, len, NULL, NULL );
 
     if (gUIHandlerRecord && (gUIFilterRecord & log_type))
@@ -1842,8 +1842,8 @@ INT MSI_ProcessMessageVerbatim(MSIPACKAGE *package, INSTALLMESSAGE eMessageType,
         WriteFile( package->log_file, msg, len - 1, &written, NULL );
         WriteFile( package->log_file, "\n", 1, &written, NULL );
     }
-    msi_free( msg );
-    msi_free( message );
+    free( msg );
+    free( message );
 
     return rc;
 }
@@ -1883,7 +1883,7 @@ INT MSI_ProcessMessage( MSIPACKAGE *package, INSTALLMESSAGE eMessageType, MSIREC
                         template_rec = msi_get_error_message(package->db, MSIERR_INSTALLERROR);
                         MSI_RecordSetStringW(record, 0, template_rec);
                         MSI_ProcessMessageVerbatim(package, eMessageType, record);
-                        msi_free(template_rec);
+                        free(template_rec);
                         return 0;
                     }
                 }
@@ -1899,30 +1899,30 @@ INT MSI_ProcessMessage( MSIPACKAGE *package, INSTALLMESSAGE eMessageType, MSIREC
                 /* always returns 0 */
                 MSI_RecordSetStringW(record, 0, template_prefix);
                 MSI_ProcessMessageVerbatim(package, eMessageType, record);
-                msi_free(template_prefix);
+                free(template_prefix);
                 return 0;
             }
 
-            template = msi_alloc((lstrlenW(template_rec) + lstrlenW(template_prefix) + 1) * sizeof(WCHAR));
+            template = malloc((wcslen(template_rec) + wcslen(template_prefix) + 1) * sizeof(WCHAR));
             if (!template) return ERROR_OUTOFMEMORY;
 
             lstrcpyW(template, template_prefix);
             lstrcatW(template, template_rec);
             MSI_RecordSetStringW(record, 0, template);
 
-            msi_free(template_prefix);
-            msi_free(template_rec);
-            msi_free(template);
+            free(template_prefix);
+            free(template_rec);
+            free(template);
         }
         break;
     case INSTALLMESSAGE_ACTIONSTART:
     {
         WCHAR *template = msi_get_error_message(package->db, MSIERR_ACTIONSTART);
         MSI_RecordSetStringW(record, 0, template);
-        msi_free(template);
+        free(template);
 
-        msi_free(package->LastAction);
-        msi_free(package->LastActionTemplate);
+        free(package->LastAction);
+        free(package->LastActionTemplate);
         package->LastAction = msi_dup_record_field(record, 1);
         if (!package->LastAction) package->LastAction = wcsdup(L"");
         package->LastActionTemplate = msi_dup_record_field(record, 3);
@@ -1932,18 +1932,18 @@ INT MSI_ProcessMessage( MSIPACKAGE *package, INSTALLMESSAGE eMessageType, MSIREC
         if (package->LastAction && package->LastActionTemplate)
         {
             size_t len = lstrlenW(package->LastAction) + lstrlenW(package->LastActionTemplate) + 7;
-            WCHAR *template = msi_alloc(len * sizeof(WCHAR));
+            WCHAR *template = malloc(len * sizeof(WCHAR));
             if (!template) return ERROR_OUTOFMEMORY;
             swprintf(template, len, L"{{%s: }}%s", package->LastAction, package->LastActionTemplate);
             MSI_RecordSetStringW(record, 0, template);
-            msi_free(template);
+            free(template);
         }
         break;
     case INSTALLMESSAGE_COMMONDATA:
     {
         WCHAR *template = msi_get_error_message(package->db, MSIERR_COMMONDATA);
         MSI_RecordSetStringW(record, 0, template);
-        msi_free(template);
+        free(template);
     }
     break;
     }
@@ -2017,8 +2017,8 @@ UINT WINAPI MsiSetPropertyA( MSIHANDLE hInstall, LPCSTR szName, LPCSTR szValue )
     r = MsiSetPropertyW( hInstall, szwName, szwValue);
 
 end:
-    msi_free( szwName );
-    msi_free( szwValue );
+    free( szwName );
+    free( szwValue );
 
     return r;
 }
@@ -2029,7 +2029,7 @@ void msi_reset_source_folders( MSIPACKAGE *package )
 
     LIST_FOR_EACH_ENTRY( folder, &package->folders, MSIFOLDER, entry )
     {
-        msi_free( folder->ResolvedSource );
+        free( folder->ResolvedSource );
         folder->ResolvedSource = NULL;
     }
 }
@@ -2133,17 +2133,17 @@ static MSIRECORD *msi_get_property_row( MSIDATABASE *db, LPCWSTR name )
         length = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_SHORTDATE, NULL, NULL, NULL, 0);
         if (!length)
             return NULL;
-        buffer = msi_alloc(length * sizeof(WCHAR));
+        buffer = malloc(length * sizeof(WCHAR));
         GetDateFormatW(LOCALE_USER_DEFAULT, DATE_SHORTDATE, NULL, NULL, buffer, length);
 
         row = MSI_CreateRecord(1);
         if (!row)
         {
-            msi_free(buffer);
+            free(buffer);
             return NULL;
         }
         MSI_RecordSetStringW(row, 1, buffer);
-        msi_free(buffer);
+        free(buffer);
         return row;
     }
     else if (!wcscmp(name, L"Time"))
@@ -2151,17 +2151,17 @@ static MSIRECORD *msi_get_property_row( MSIDATABASE *db, LPCWSTR name )
         length = GetTimeFormatW(LOCALE_USER_DEFAULT, TIME_NOTIMEMARKER, NULL, NULL, NULL, 0);
         if (!length)
             return NULL;
-        buffer = msi_alloc(length * sizeof(WCHAR));
+        buffer = malloc(length * sizeof(WCHAR));
         GetTimeFormatW(LOCALE_USER_DEFAULT, TIME_NOTIMEMARKER, NULL, NULL, buffer, length);
 
         row = MSI_CreateRecord(1);
         if (!row)
         {
-            msi_free(buffer);
+            free(buffer);
             return NULL;
         }
         MSI_RecordSetStringW(row, 1, buffer);
-        msi_free(buffer);
+        free(buffer);
         return row;
     }
 
@@ -2228,11 +2228,11 @@ LPWSTR msi_dup_property(MSIDATABASE *db, LPCWSTR prop)
         return NULL;
 
     sz++;
-    str = msi_alloc(sz * sizeof(WCHAR));
+    str = malloc(sz * sizeof(WCHAR));
     r = msi_get_property(db, prop, str, &sz);
     if (r != ERROR_SUCCESS)
     {
-        msi_free(str);
+        free(str);
         str = NULL;
     }
 
@@ -2243,7 +2243,7 @@ int msi_get_property_int( MSIDATABASE *db, LPCWSTR prop, int def )
 {
     LPWSTR str = msi_dup_property( db, prop );
     int val = str ? wcstol(str, NULL, 10) : def;
-    msi_free(str);
+    free(str);
     return val;
 }
 
@@ -2569,7 +2569,7 @@ UINT msi_package_add_info(MSIPACKAGE *package, DWORD context, DWORD options,
         if (!wcscmp( info->value, value )) return ERROR_SUCCESS;
     }
 
-    info = msi_alloc(sizeof(MSISOURCELISTINFO));
+    info = malloc(sizeof(MSISOURCELISTINFO));
     if (!info)
         return ERROR_OUTOFMEMORY;
 
@@ -2592,7 +2592,7 @@ UINT msi_package_add_media_disk(MSIPACKAGE *package, DWORD context, DWORD option
         if (disk->disk_id == disk_id) return ERROR_SUCCESS;
     }
 
-    disk = msi_alloc(sizeof(MSIMEDIADISK));
+    disk = malloc(sizeof(MSIMEDIADISK));
     if (!disk)
         return ERROR_OUTOFMEMORY;
 
diff --git a/dlls/msi/patch.c b/dlls/msi/patch.c
index 84ba305d23e6..8acc741e0c7b 100644
--- a/dlls/msi/patch.c
+++ b/dlls/msi/patch.c
@@ -54,12 +54,12 @@ struct transform_desc
 
 static void free_transform_desc( struct transform_desc *desc )
 {
-    msi_free( desc->product_code_from );
-    msi_free( desc->product_code_to );
-    msi_free( desc->version_from );
-    msi_free( desc->version_to );
-    msi_free( desc->upgrade_code );
-    msi_free( desc );
+    free( desc->product_code_from );
+    free( desc->product_code_to );
+    free( desc->version_from );
+    free( desc->version_to );
+    free( desc->upgrade_code );
+    free( desc );
 }
 
 static struct transform_desc *parse_transform_desc( const WCHAR *str )
@@ -68,20 +68,20 @@ static struct transform_desc *parse_transform_desc( const WCHAR *str )
     const WCHAR *p = str, *q;
     UINT len;
 
-    if (!(ret = msi_alloc_zero( sizeof(*ret) ))) return NULL;
+    if (!(ret = calloc( 1, sizeof(*ret) ))) return NULL;
 
     q = wcschr( p, '}' );
     if (*p != '{' || !q) goto error;
 
     len = q - p + 1;
-    if (!(ret->product_code_from = msi_alloc( (len + 1) * sizeof(WCHAR) ))) goto error;
+    if (!(ret->product_code_from = malloc( (len + 1) * sizeof(WCHAR) ))) goto error;
     memcpy( ret->product_code_from, p, len * sizeof(WCHAR) );
     ret->product_code_from[len] = 0;
 
     p = q + 1;
     if (!(q = wcschr( p, ';' ))) goto error;
     len = q - p;
-    if (!(ret->version_from = msi_alloc( (len + 1) * sizeof(WCHAR) ))) goto error;
+    if (!(ret->version_from = malloc( (len + 1) * sizeof(WCHAR) ))) goto error;
     memcpy( ret->version_from, p, len * sizeof(WCHAR) );
     ret->version_from[len] = 0;
 
@@ -90,14 +90,14 @@ static struct transform_desc *parse_transform_desc( const WCHAR *str )
     if (*p != '{' || !q) goto error;
 
     len = q - p + 1;
-    if (!(ret->product_code_to = msi_alloc( (len + 1) * sizeof(WCHAR) ))) goto error;
+    if (!(ret->product_code_to = malloc( (len + 1) * sizeof(WCHAR) ))) goto error;
     memcpy( ret->product_code_to, p, len * sizeof(WCHAR) );
     ret->product_code_to[len] = 0;
 
     p = q + 1;
     if (!(q = wcschr( p, ';' ))) goto error;
     len = q - p;
-    if (!(ret->version_to = msi_alloc( (len + 1) * sizeof(WCHAR) ))) goto error;
+    if (!(ret->version_to = malloc( (len + 1) * sizeof(WCHAR) ))) goto error;
     memcpy( ret->version_to, p, len * sizeof(WCHAR) );
     ret->version_to[len] = 0;
 
@@ -106,7 +106,7 @@ static struct transform_desc *parse_transform_desc( const WCHAR *str )
     if (*p != '{' || !q) goto error;
 
     len = q - p + 1;
-    if (!(ret->upgrade_code = msi_alloc( (len + 1) * sizeof(WCHAR) ))) goto error;
+    if (!(ret->upgrade_code = malloc( (len + 1) * sizeof(WCHAR) ))) goto error;
     memcpy( ret->upgrade_code, p, len * sizeof(WCHAR) );
     ret->upgrade_code[len] = 0;
 
@@ -157,18 +157,18 @@ static UINT check_transform_applicable( MSIPACKAGE *package, IStorage *transform
     if (!(product = msi_get_suminfo_product( transform )))
     {
         WARN("no product property!\n");
-        msi_free( template );
+        free( template );
         msiobj_release( &si->hdr );
         return ERROR_FUNCTION_FAILED;
     }
     TRACE("product property: %s\n", debugstr_w(product));
     if (!(desc = parse_transform_desc( product )))
     {
-        msi_free( template );
+        free( template );
         msiobj_release( &si->hdr );
         return ERROR_FUNCTION_FAILED;
     }
-    msi_free( product );
+    free( product );
 
     if (wanted_flags & MSITRANSFORM_VALIDATE_LANGUAGE)
     {
@@ -183,7 +183,7 @@ static UINT check_transform_applicable( MSIPACKAGE *package, IStorage *transform
 
         if (!product_code_installed)
         {
-            msi_free( template );
+            free( template );
             free_transform_desc( desc );
             msiobj_release( &si->hdr );
             return ERROR_INSTALL_PACKAGE_INVALID;
@@ -192,9 +192,9 @@ static UINT check_transform_applicable( MSIPACKAGE *package, IStorage *transform
         {
             valid_flags |= MSITRANSFORM_VALIDATE_PRODUCT;
         }
-        msi_free( product_code_installed );
+        free( product_code_installed );
     }
-    msi_free( template );
+    free( template );
     if (wanted_flags & MSITRANSFORM_VALIDATE_MAJORVERSION)
     {
         WCHAR *product_version_installed = msi_dup_property( package->db, L"ProductVersion" );
@@ -214,7 +214,7 @@ static UINT check_transform_applicable( MSIPACKAGE *package, IStorage *transform
             valid_flags |= MSITRANSFORM_VALIDATE_MAJORVERSION;
             wanted_flags &= ~MSITRANSFORM_VALIDATE_MINORVERSION;
         }
-        msi_free( product_version_installed );
+        free( product_version_installed );
     }
     else if (wanted_flags & MSITRANSFORM_VALIDATE_MINORVERSION)
     {
@@ -232,7 +232,7 @@ static UINT check_transform_applicable( MSIPACKAGE *package, IStorage *transform
 
         if (major_installed == major && minor_installed == minor)
             valid_flags |= MSITRANSFORM_VALIDATE_MINORVERSION;
-        msi_free( product_version_installed );
+        free( product_version_installed );
     }
     if (wanted_flags & MSITRANSFORM_VALIDATE_UPGRADECODE)
     {
@@ -246,7 +246,7 @@ static UINT check_transform_applicable( MSIPACKAGE *package, IStorage *transform
         }
         if (!wcscmp( desc->upgrade_code, upgrade_code_installed ))
             valid_flags |= MSITRANSFORM_VALIDATE_UPGRADECODE;
-        msi_free( upgrade_code_installed );
+        free( upgrade_code_installed );
     }
 
     free_transform_desc( desc );
@@ -309,9 +309,9 @@ UINT msi_check_patch_applicable( MSIPACKAGE *package, MSISUMMARYINFO *si )
     {
         if (!wcscmp( guids[i], product_code )) ret = ERROR_SUCCESS;
     }
-    msi_free( guids );
-    msi_free( guid_list );
-    msi_free( product_code );
+    free( guids );
+    free( guid_list );
+    free( product_code );
     return ret;
 }
 
@@ -321,26 +321,26 @@ static UINT msi_parse_patch_summary( MSISUMMARYINFO *si, MSIPATCHINFO **patch )
     UINT r = ERROR_SUCCESS;
     WCHAR *p;
 
-    if (!(pi = msi_alloc_zero( sizeof(MSIPATCHINFO) )))
+    if (!(pi = calloc( 1, sizeof(MSIPATCHINFO) )))
     {
         return ERROR_OUTOFMEMORY;
     }
     if (!(pi->patchcode = msi_suminfo_dup_string( si, PID_REVNUMBER )))
     {
-        msi_free( pi );
+        free( pi );
         return ERROR_OUTOFMEMORY;
     }
     p = pi->patchcode;
     if (*p != '{')
     {
-        msi_free( pi->patchcode );
-        msi_free( pi );
+        free( pi->patchcode );
+        free( pi );
         return ERROR_PATCH_PACKAGE_INVALID;
     }
     if (!(p = wcschr( p + 1, '}' )))
     {
-        msi_free( pi->patchcode );
-        msi_free( pi );
+        free( pi->patchcode );
+        free( pi );
         return ERROR_PATCH_PACKAGE_INVALID;
     }
     if (p[1])
@@ -351,15 +351,15 @@ static UINT msi_parse_patch_summary( MSISUMMARYINFO *si, MSIPATCHINFO **patch )
     TRACE("patch code %s\n", debugstr_w(pi->patchcode));
     if (!(pi->products = msi_suminfo_dup_string( si, PID_TEMPLATE )))
     {
-        msi_free( pi->patchcode );
-        msi_free( pi );
+        free( pi->patchcode );
+        free( pi );
         return ERROR_OUTOFMEMORY;
     }
     if (!(pi->transforms = msi_suminfo_dup_string( si, PID_LASTAUTHOR )))
     {
-        msi_free( pi->patchcode );
-        msi_free( pi->products );
-        msi_free( pi );
+        free( pi->patchcode );
+        free( pi->products );
+        free( pi );
         return ERROR_OUTOFMEMORY;
     }
     *patch = pi;
@@ -387,7 +387,7 @@ static UINT patch_set_media_source_prop( MSIPACKAGE *package )
         property = MSI_RecordGetString( rec, 1 );
         patch = msi_dup_property( package->db, L"PATCH" );
         msi_set_property( package->db, property, patch, -1 );
-        msi_free( patch );
+        free( patch );
         msiobj_release( &rec->hdr );
     }
 
@@ -413,7 +413,7 @@ struct patch_offset_list
 
 static struct patch_offset_list *patch_offset_list_create( void )
 {
-    struct patch_offset_list *pos = msi_alloc( sizeof(struct patch_offset_list) );
+    struct patch_offset_list *pos = malloc( sizeof(struct patch_offset_list) );
     list_init( &pos->files );
     list_init( &pos->patches );
     pos->count = pos->max = 0;
@@ -427,15 +427,15 @@ static void patch_offset_list_free( struct patch_offset_list *pos )
 
     LIST_FOR_EACH_ENTRY_SAFE( po, po2, &pos->files, struct patch_offset, entry )
     {
-        msi_free( po->name );
-        msi_free( po );
+        free( po->name );
+        free( po );
     }
     LIST_FOR_EACH_ENTRY_SAFE( po, po2, &pos->patches, struct patch_offset, entry )
     {
-        msi_free( po->name );
-        msi_free( po );
+        free( po->name );
+        free( po );
     }
-    msi_free( pos );
+    free( pos );
 }
 
 static void patch_offset_get_filepatches( MSIDATABASE *db, UINT last_sequence, struct patch_offset_list *pos )
@@ -458,7 +458,7 @@ static void patch_offset_get_filepatches( MSIDATABASE *db, UINT last_sequence, s
 
     while (MSI_ViewFetch( view, &rec ) == ERROR_SUCCESS)
     {
-        struct patch_offset *po = msi_alloc( sizeof(struct patch_offset) );
+        struct patch_offset *po = malloc( sizeof(struct patch_offset) );
 
         po->name     = msi_dup_record_field( rec, 1 );
         po->sequence = MSI_RecordGetInteger( rec, 2 );
@@ -495,7 +495,7 @@ static void patch_offset_get_files( MSIDATABASE *db, UINT last_sequence, struct
         UINT attributes = MSI_RecordGetInteger( rec, 7 );
         if (attributes & msidbFileAttributesPatchAdded)
         {
-            struct patch_offset *po = msi_alloc( sizeof(struct patch_offset) );
+            struct patch_offset *po = malloc( sizeof(struct patch_offset) );
 
             po->name     = msi_dup_record_field( rec, 1 );
             po->sequence = MSI_RecordGetInteger( rec, 8 );
@@ -669,7 +669,7 @@ static UINT patch_add_media( MSIPACKAGE *package, IStorage *storage, MSIPATCHINF
             msiobj_release( &rec->hdr );
             continue;
         }
-        if (!(media = msi_alloc( sizeof( *media ))))
+        if (!(media = malloc( sizeof( *media ))))
         {
             msiobj_release( &rec->hdr );
             goto done;
@@ -739,11 +739,11 @@ static UINT patch_add_media( MSIPACKAGE *package, IStorage *storage, MSIPATCHINF
     LIST_FOR_EACH_ENTRY_SAFE( media, next, &media_list, struct patch_media, entry )
     {
         list_remove( &media->entry );
-        msi_free( media->prompt );
-        msi_free( media->cabinet );
-        msi_free( media->volume );
-        msi_free( media->source );
-        msi_free( media );
+        free( media->prompt );
+        free( media->cabinet );
+        free( media->volume );
+        free( media->source );
+        free( media );
     }
     return r;
 }
@@ -848,7 +848,7 @@ static UINT msi_apply_patch_db( MSIPACKAGE *package, MSIDATABASE *patch_db, MSIP
                 r = patch_add_media( package, patch_db->storage, patch );
         }
     }
-    msi_free( substorage );
+    free( substorage );
     if (r != ERROR_SUCCESS)
         return r;
 
@@ -864,12 +864,12 @@ static UINT msi_apply_patch_db( MSIPACKAGE *package, MSIDATABASE *patch_db, MSIP
 
 void msi_free_patchinfo( MSIPATCHINFO *patch )
 {
-    msi_free( patch->patchcode );
-    msi_free( patch->products );
-    msi_free( patch->transforms );
-    msi_free( patch->filename );
-    msi_free( patch->localfile );
-    msi_free( patch );
+    free( patch->patchcode );
+    free( patch->products );
+    free( patch->transforms );
+    free( patch->filename );
+    free( patch->localfile );
+    free( patch );
 }
 
 static UINT msi_apply_patch_package( MSIPACKAGE *package, const WCHAR *file )
@@ -942,8 +942,8 @@ UINT msi_apply_patches( MSIPACKAGE *package )
     for (i = 0; patches && patches[i] && r == ERROR_SUCCESS; i++)
         r = msi_apply_patch_package( package, patches[i] );
 
-    msi_free( patches );
-    msi_free( patch_list );
+    free( patches );
+    free( patch_list );
     return r;
 }
 
@@ -969,21 +969,21 @@ UINT msi_apply_transforms( MSIPACKAGE *package )
                 WCHAR *p = wcsrchr( package->PackagePath, '\\' );
                 DWORD len = p - package->PackagePath + 1;
 
-                if (!(transform = msi_alloc( (len + lstrlenW( xforms[i] ) + 1) * sizeof(WCHAR)) ))
+                if (!(transform = malloc( (len + wcslen( xforms[i] ) + 1) * sizeof(WCHAR)) ))
                 {
-                    msi_free( xforms );
-                    msi_free( xform_list );
+                    free( xforms );
+                    free( xform_list );
                     return ERROR_OUTOFMEMORY;
                 }
                 memcpy( transform, package->PackagePath, len * sizeof(WCHAR) );
                 memcpy( transform + len, xforms[i], (lstrlenW( xforms[i] ) + 1) * sizeof(WCHAR) );
             }
             r = MSI_DatabaseApplyTransformW( package->db, transform, 0 );
-            if (transform != xforms[i]) msi_free( transform );
+            if (transform != xforms[i]) free( transform );
         }
     }
-    msi_free( xforms );
-    msi_free( xform_list );
+    free( xforms );
+    free( xform_list );
     return r;
 }
 
diff --git a/dlls/msi/record.c b/dlls/msi/record.c
index 277e4c374fcc..4e7430774d6b 100644
--- a/dlls/msi/record.c
+++ b/dlls/msi/record.c
@@ -54,7 +54,7 @@ static void MSI_FreeField( MSIFIELD *field )
     case MSIFIELD_INT:
         break;
     case MSIFIELD_WSTR:
-        msi_free( field->u.szwVal);
+        free( field->u.szwVal);
         break;
     case MSIFIELD_STREAM:
         IStream_Release( field->u.stream );
@@ -157,7 +157,7 @@ WCHAR *msi_strdupW( const WCHAR *value, int len )
     WCHAR *ret;
 
     if (!value) return NULL;
-    if (!(ret = msi_alloc( (len + 1) * sizeof(WCHAR) ))) return NULL;
+    if (!(ret = malloc( (len + 1) * sizeof(WCHAR) ))) return NULL;
     memcpy( ret, value, len * sizeof(WCHAR) );
     ret[len] = 0;
     return ret;
@@ -559,14 +559,14 @@ UINT WINAPI MsiRecordSetStringA( MSIHANDLE handle, UINT iField, const char *szVa
     rec = msihandle2msiinfo( handle, MSIHANDLETYPE_RECORD );
     if( !rec )
     {
-        msi_free( valueW );
+        free( valueW );
         return ERROR_INVALID_HANDLE;
     }
     msiobj_lock( &rec->hdr );
     ret = MSI_RecordSetStringW( rec, iField, valueW );
     msiobj_unlock( &rec->hdr );
     msiobj_release( &rec->hdr );
-    msi_free( valueW );
+    free( valueW );
     return ret;
 }
 
@@ -735,7 +735,7 @@ UINT WINAPI MsiRecordSetStreamA( MSIHANDLE hRecord, UINT iField, const char *szF
              return ERROR_OUTOFMEMORY;
     }
     ret = MsiRecordSetStreamW(hRecord, iField, wstr);
-    msi_free(wstr);
+    free(wstr);
 
     return ret;
 }
@@ -1012,14 +1012,14 @@ WCHAR *msi_dup_record_field( MSIRECORD *rec, INT field )
         return NULL;
 
     sz++;
-    str = msi_alloc( sz * sizeof(WCHAR) );
+    str = malloc( sz * sizeof(WCHAR) );
     if (!str) return NULL;
     str[0] = 0;
     r = MSI_RecordGetStringW( rec, field, str, &sz );
     if (r != ERROR_SUCCESS)
     {
         ERR("failed to get string!\n");
-        msi_free( str );
+        free( str );
         return NULL;
     }
     return str;
diff --git a/dlls/msi/registry.c b/dlls/msi/registry.c
index 877b889ef42f..4120800db1e6 100644
--- a/dlls/msi/registry.c
+++ b/dlls/msi/registry.c
@@ -251,7 +251,7 @@ LPWSTR msi_reg_get_val_str( HKEY hkey, LPCWSTR name )
         return NULL;
 
     len += sizeof (WCHAR);
-    val = msi_alloc( len );
+    val = malloc( len );
     if (!val)
         return NULL;
     val[0] = 0;
@@ -274,15 +274,15 @@ static WCHAR *get_user_sid(void)
     WCHAR *ret;
 
     if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &token )) return NULL;
-    if (!(user = msi_alloc( size )))
+    if (!(user = malloc( size )))
     {
         CloseHandle( token );
         return NULL;
     }
     if (!GetTokenInformation( token, TokenUser, user, size, &size ))
     {
-        msi_free( user );
-        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER || !(user = msi_alloc( size )))
+        free( user );
+        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER || !(user = malloc( size )))
         {
             CloseHandle( token );
             return NULL;
@@ -292,10 +292,10 @@ static WCHAR *get_user_sid(void)
     CloseHandle( token );
     if (!ConvertSidToStringSidW( user->User.Sid, &ret ))
     {
-        msi_free( user );
+        free( user );
         return NULL;
     }
-    msi_free( user );
+    free( user );
     return ret;
 }
 
@@ -1016,7 +1016,7 @@ UINT WINAPI MsiDecomposeDescriptorA( LPCSTR szDescriptor, LPSTR szProduct,
                              szComponent, MAX_FEATURE_CHARS+1, NULL, NULL );
     }
 
-    msi_free( str );
+    free( str );
 
     return r;
 }
@@ -1070,7 +1070,7 @@ UINT WINAPI MsiEnumFeaturesA( const char *szProduct, DWORD index, char *szFeatur
         WideCharToMultiByte(CP_ACP, 0, szwParent, -1, szParent, GUID_SIZE, NULL, NULL);
     }
 
-    msi_free( szwProduct);
+    free(szwProduct);
 
     return r;
 }
@@ -1132,9 +1132,9 @@ UINT WINAPI MsiEnumComponentsExA( const char *user_sid, DWORD ctx, DWORD index,
 
     if (sid && !sid_len) return ERROR_INVALID_PARAMETER;
     if (user_sid && !(user_sidW = strdupAtoW( user_sid ))) return ERROR_OUTOFMEMORY;
-    if (sid && !(sidW = msi_alloc( *sid_len * sizeof(WCHAR) )))
+    if (sid && !(sidW = malloc( *sid_len * sizeof(WCHAR) )))
     {
-        msi_free( user_sidW );
+        free( user_sidW );
         return ERROR_OUTOFMEMORY;
     }
     r = MsiEnumComponentsExW( user_sidW, ctx, index, guidW, installed_ctx, sidW, sid_len );
@@ -1143,8 +1143,8 @@ UINT WINAPI MsiEnumComponentsExA( const char *user_sid, DWORD ctx, DWORD index,
         if (guid) WideCharToMultiByte( CP_ACP, 0, guidW, GUID_SIZE, guid, GUID_SIZE, NULL, NULL );
         if (sid) WideCharToMultiByte( CP_ACP, 0, sidW, *sid_len + 1, sid, *sid_len + 1, NULL, NULL );
     }
-    msi_free( user_sidW );
-    msi_free( sidW );
+    free( user_sidW );
+    free( sidW );
     return r;
 }
 
@@ -1347,7 +1347,7 @@ UINT WINAPI MsiEnumClientsA( const char *szComponent, DWORD index, char *szProdu
     if( r == ERROR_SUCCESS )
         WideCharToMultiByte(CP_ACP, 0, szwProduct, -1, szProduct, GUID_SIZE, NULL, NULL);
 
-    msi_free( szwComponent);
+    free(szwComponent);
 
     return r;
 }
@@ -1429,13 +1429,13 @@ static UINT MSI_EnumComponentQualifiers( const WCHAR *szComponent, DWORD iIndex,
     /* figure out how big the name is we want to return */
     name_max = 0x10;
     r = ERROR_OUTOFMEMORY;
-    name = msi_alloc( name_max * sizeof(WCHAR) );
+    name = malloc( name_max * sizeof(WCHAR) );
     if (!name)
         goto end;
 
     val_max = 0x10;
     r = ERROR_OUTOFMEMORY;
-    val = msi_alloc( val_max );
+    val = malloc( val_max );
     if (!val)
         goto end;
 
@@ -1460,8 +1460,8 @@ static UINT MSI_EnumComponentQualifiers( const WCHAR *szComponent, DWORD iIndex,
         if (name_sz + 1 >= name_max)
         {
             name_max *= 2;
-            msi_free( name );
-            name = msi_alloc( name_max * sizeof (WCHAR) );
+            free( name );
+            name = malloc( name_max * sizeof (WCHAR) );
             if (!name)
                 goto end;
             continue;
@@ -1469,8 +1469,8 @@ static UINT MSI_EnumComponentQualifiers( const WCHAR *szComponent, DWORD iIndex,
         if (val_sz > val_max)
         {
             val_max = val_sz + sizeof (WCHAR);
-            msi_free( val );
-            val = msi_alloc( val_max * sizeof (WCHAR) );
+            free( val );
+            val = malloc( val_max * sizeof (WCHAR) );
             if (!val)
                 goto end;
             continue;
@@ -1493,8 +1493,8 @@ static UINT MSI_EnumComponentQualifiers( const WCHAR *szComponent, DWORD iIndex,
         r = r2;
 
 end:
-    msi_free(val);
-    msi_free(name);
+    free(val);
+    free(name);
     RegCloseKey(key);
     return r;
 }
@@ -1525,7 +1525,7 @@ UINT WINAPI MsiEnumComponentQualifiersA( const char *szComponent, DWORD iIndex,
 
     r = MSI_EnumComponentQualifiers( comp, iIndex,
               &qual, pcchQualifierBuf, &appdata, pcchApplicationDataBuf );
-    msi_free( comp );
+    free( comp );
     return r;
 }
 
@@ -1608,7 +1608,7 @@ UINT WINAPI MsiEnumRelatedProductsA( const char *szUpgradeCode, DWORD dwReserved
         WideCharToMultiByte( CP_ACP, 0, productW, GUID_SIZE,
                              lpProductBuf, GUID_SIZE, NULL, NULL );
     }
-    msi_free( szwUpgradeCode);
+    free( szwUpgradeCode );
     return r;
 }
 
@@ -1654,7 +1654,7 @@ UINT WINAPI MsiEnumPatchesExA( const char *szProductCode, const char *szUserSid,
         goto done;
     }
 
-    targsid = msi_alloc(++len * sizeof(WCHAR));
+    targsid = malloc(++len * sizeof(WCHAR));
     if (!targsid)
     {
         r = ERROR_OUTOFMEMORY;
@@ -1680,9 +1680,9 @@ UINT WINAPI MsiEnumPatchesExA( const char *szProductCode, const char *szUserSid,
         *pcchTargetUserSid = len;
 
 done:
-    msi_free(prodcode);
-    msi_free(usersid);
-    msi_free(targsid);
+    free(prodcode);
+    free(usersid);
+    free(targsid);
 
     return r;
 }
@@ -1761,7 +1761,7 @@ static UINT msi_check_product_patches(LPCWSTR prodcode, LPCWSTR usersid,
         goto done;
     }
 
-    patches = msi_alloc(size);
+    patches = malloc(size);
     if (!patches)
     {
         r = ERROR_OUTOFMEMORY;
@@ -1789,7 +1789,7 @@ static UINT msi_check_product_patches(LPCWSTR prodcode, LPCWSTR usersid,
 
         if (transforms)
         {
-            *transforms = msi_alloc(size);
+            *transforms = malloc(size);
             if (!*transforms)
             {
                 r = ERROR_OUTOFMEMORY;
@@ -1896,7 +1896,7 @@ static UINT msi_check_product_patches(LPCWSTR prodcode, LPCWSTR usersid,
 
 done:
     RegCloseKey(prod);
-    msi_free(patches);
+    free(patches);
 
     return r;
 }
@@ -2031,7 +2031,7 @@ UINT WINAPI MsiEnumPatchesA( const char *szProduct, DWORD iPatchIndex, char *lpP
         return ERROR_OUTOFMEMORY;
 
     len = *pcchTransformsBuf;
-    transforms = msi_alloc( len * sizeof(WCHAR) );
+    transforms = malloc(len * sizeof(WCHAR));
     if (!transforms)
     {
         r = ERROR_OUTOFMEMORY;
@@ -2058,8 +2058,8 @@ UINT WINAPI MsiEnumPatchesA( const char *szProduct, DWORD iPatchIndex, char *lpP
         *pcchTransformsBuf = strlen( lpTransformsBuf );
 
 done:
-    msi_free(transforms);
-    msi_free(product);
+    free(transforms);
+    free(product);
 
     return r;
 }
@@ -2110,7 +2110,7 @@ UINT WINAPI MsiEnumPatchesW( const WCHAR *szProduct, DWORD iPatchIndex, WCHAR *l
         *pcchTransformsBuf = lstrlenW(transforms);
 
 done:
-    msi_free(transforms);
+    free(transforms);
     return r;
 }
 
@@ -2128,13 +2128,13 @@ UINT WINAPI MsiEnumProductsExA( const char *product, const char *usersid, DWORD
     if (product && !(productW = strdupAtoW( product ))) return ERROR_OUTOFMEMORY;
     if (usersid && !(usersidW = strdupAtoW( usersid )))
     {
-        msi_free( productW );
+        free( productW );
         return ERROR_OUTOFMEMORY;
     }
-    if (sid && !(sidW = msi_alloc( *sid_len * sizeof(WCHAR) )))
+    if (sid && !(sidW = malloc( *sid_len * sizeof(WCHAR) )))
     {
-        msi_free( usersidW );
-        msi_free( productW );
+        free( usersidW );
+        free( productW );
         return ERROR_OUTOFMEMORY;
     }
     r = MsiEnumProductsExW( productW, usersidW, ctx, index, installed_productW,
@@ -2145,9 +2145,9 @@ UINT WINAPI MsiEnumProductsExA( const char *product, const char *usersid, DWORD
                                                     installed_product, GUID_SIZE, NULL, NULL );
         if (sid) WideCharToMultiByte( CP_ACP, 0, sidW, *sid_len + 1, sid, *sid_len + 1, NULL, NULL );
     }
-    msi_free( productW );
-    msi_free( usersidW );
-    msi_free( sidW );
+    free( productW );
+    free( usersidW );
+    free( sidW );
     return r;
 }
 
diff --git a/dlls/msi/script.c b/dlls/msi/script.c
index 26dcddc041e7..519beb86a63a 100644
--- a/dlls/msi/script.c
+++ b/dlls/msi/script.c
@@ -102,7 +102,7 @@ static ULONG WINAPI MsiActiveScriptSite_Release(IActiveScriptSite* iface)
     TRACE( "(%p)->(%lu)\n", This, ref );
 
     if (!ref)
-        msi_free(This);
+        free(This);
 
     return ref;
 }
@@ -254,7 +254,7 @@ static HRESULT create_activescriptsite(MsiActiveScriptSite **obj)
 
     *obj = NULL;
 
-    object = msi_alloc( sizeof(MsiActiveScriptSite) );
+    object = malloc(sizeof(MsiActiveScriptSite));
     if (!object)
         return E_OUTOFMEMORY;
 
diff --git a/dlls/msi/select.c b/dlls/msi/select.c
index d5a8e1fde23b..1b77d1095d36 100644
--- a/dlls/msi/select.c
+++ b/dlls/msi/select.c
@@ -344,7 +344,7 @@ static UINT SELECT_delete( struct tagMSIVIEW *view )
         sv->table->ops->delete( sv->table );
     sv->table = NULL;
 
-    msi_free( sv );
+    free( sv );
 
     return ERROR_SUCCESS;
 }
@@ -430,7 +430,7 @@ UINT SELECT_CreateView( MSIDATABASE *db, MSIVIEW **view, MSIVIEW *table,
 
     count = select_count_columns( columns );
 
-    sv = msi_alloc_zero( FIELD_OFFSET( MSISELECTVIEW, cols[count] ));
+    sv = calloc( 1, offsetof( MSISELECTVIEW, cols[count] ) );
     if( !sv )
         return ERROR_FUNCTION_FAILED;
 
@@ -452,7 +452,7 @@ UINT SELECT_CreateView( MSIDATABASE *db, MSIVIEW **view, MSIVIEW *table,
     if( r == ERROR_SUCCESS )
         *view = &sv->view;
     else
-        msi_free( sv );
+        free( sv );
 
     return r;
 }
diff --git a/dlls/msi/source.c b/dlls/msi/source.c
index 4f118c32cd52..6545f5dc63cd 100644
--- a/dlls/msi/source.c
+++ b/dlls/msi/source.c
@@ -162,10 +162,10 @@ UINT WINAPI MsiSourceListEnumMediaDisksA( const char *szProductCodeOrPatchCode,
     /* FIXME: add tests for an invalid format */
 
     if (pcchVolumeLabel)
-        volume = msi_alloc(*pcchVolumeLabel * sizeof(WCHAR));
+        volume = malloc(*pcchVolumeLabel * sizeof(WCHAR));
 
     if (pcchDiskPrompt)
-        prompt = msi_alloc(*pcchDiskPrompt * sizeof(WCHAR));
+        prompt = malloc(*pcchDiskPrompt * sizeof(WCHAR));
 
     if (volume) *volume = '\0';
     if (prompt) *prompt = '\0';
@@ -184,10 +184,10 @@ UINT WINAPI MsiSourceListEnumMediaDisksA( const char *szProductCodeOrPatchCode,
                             *pcchDiskPrompt + 1, NULL, NULL);
 
 done:
-    msi_free(product);
-    msi_free(usersid);
-    msi_free(volume);
-    msi_free(prompt);
+    free(product);
+    free(usersid);
+    free(volume);
+    free(prompt);
 
     return r;
 }
@@ -249,8 +249,8 @@ UINT WINAPI MsiSourceListEnumMediaDisksW( const WCHAR *szProductCodeOrPatchCode,
         goto done;
     }
 
-    value = msi_alloc(++valuesz * sizeof(WCHAR));
-    data = msi_alloc(++datasz * sizeof(WCHAR));
+    value = malloc(++valuesz * sizeof(WCHAR));
+    data = malloc(++datasz * sizeof(WCHAR));
     if (!value || !data)
     {
         r = ERROR_OUTOFMEMORY;
@@ -316,8 +316,8 @@ UINT WINAPI MsiSourceListEnumMediaDisksW( const WCHAR *szProductCodeOrPatchCode,
     index++;
 
 done:
-    msi_free(value);
-    msi_free(data);
+    free(value);
+    free(data);
     RegCloseKey(source);
 
     return r;
@@ -355,7 +355,7 @@ UINT WINAPI MsiSourceListEnumSourcesA( const char *szProductCodeOrPatch, const c
     if (r != ERROR_SUCCESS)
         goto done;
 
-    source = msi_alloc(++len * sizeof(WCHAR));
+    source = malloc(++len * sizeof(WCHAR));
     if (!source)
     {
         r = ERROR_OUTOFMEMORY;
@@ -378,9 +378,9 @@ UINT WINAPI MsiSourceListEnumSourcesA( const char *szProductCodeOrPatch, const c
         *pcchSource = len - 1;
 
 done:
-    msi_free(product);
-    msi_free(usersid);
-    msi_free(source);
+    free(product);
+    free(usersid);
+    free(source);
 
     if (r == ERROR_SUCCESS)
     {
@@ -491,7 +491,7 @@ UINT WINAPI MsiSourceListGetInfoA( LPCSTR szProduct, LPCSTR szUserSid,
     if (ret != ERROR_SUCCESS)
         goto done;
 
-    value = msi_alloc(++len * sizeof(WCHAR));
+    value = malloc(++len * sizeof(WCHAR));
     if (!value)
         return ERROR_OUTOFMEMORY;
 
@@ -510,10 +510,10 @@ UINT WINAPI MsiSourceListGetInfoA( LPCSTR szProduct, LPCSTR szUserSid,
     *pcchValue = len - 1;
 
 done:
-    msi_free(product);
-    msi_free(usersid);
-    msi_free(property);
-    msi_free(value);
+    free(product);
+    free(usersid);
+    free(property);
+    free(value);
     return ret;
 }
 
@@ -583,13 +583,13 @@ UINT WINAPI MsiSourceListGetInfoW( LPCWSTR szProduct, LPCWSTR szUserSid,
             goto output_out;
         }
 
-        source = msi_alloc(size);
+        source = malloc(size);
         RegQueryValueExW(sourcekey, INSTALLPROPERTY_LASTUSEDSOURCEW,
                          0, 0, (LPBYTE)source, &size);
 
         if (!*source)
         {
-            msi_free(source);
+            free(source);
             RegCloseKey(sourcekey);
             return ERROR_SUCCESS;
         }
@@ -598,7 +598,7 @@ UINT WINAPI MsiSourceListGetInfoW( LPCWSTR szProduct, LPCWSTR szUserSid,
         {
             if (*source != 'n' && *source != 'u' && *source != 'm')
             {
-                msi_free(source);
+                free(source);
                 RegCloseKey(sourcekey);
                 return ERROR_SUCCESS;
             }
@@ -624,7 +624,7 @@ UINT WINAPI MsiSourceListGetInfoW( LPCWSTR szProduct, LPCWSTR szUserSid,
         }
 
         *pcchValue = lstrlenW(ptr);
-        msi_free(source);
+        free(source);
     }
     else if (!wcscmp( szProperty, INSTALLPROPERTY_PACKAGENAMEW ))
     {
@@ -675,10 +675,10 @@ UINT WINAPI MsiSourceListSetInfoA(LPCSTR szProduct, LPCSTR szUserSid,
     ret = MsiSourceListSetInfoW(product, usersid, dwContext, dwOptions,
                                 property, value);
 
-    msi_free(product);
-    msi_free(usersid);
-    msi_free(property);
-    msi_free(value);
+    free(product);
+    free(usersid);
+    free(property);
+    free(value);
 
     return ret;
 }
@@ -720,14 +720,14 @@ UINT msi_set_last_used_source(LPCWSTR product, LPCWSTR usersid,
     }
 
     size = lstrlenW(L"%c;%d;%s") + lstrlenW(value) + 7;
-    buffer = msi_alloc(size * sizeof(WCHAR));
+    buffer = malloc(size * sizeof(WCHAR));
     if (!buffer)
         return ERROR_OUTOFMEMORY;
 
     r = OpenSourceKey(product, &source, MSICODE_PRODUCT, context, FALSE);
     if (r != ERROR_SUCCESS)
     {
-        msi_free(buffer);
+        free(buffer);
         return r;
     }
 
@@ -736,7 +736,7 @@ UINT msi_set_last_used_source(LPCWSTR product, LPCWSTR usersid,
     size = (lstrlenW(buffer) + 1) * sizeof(WCHAR);
     r = RegSetValueExW(source, INSTALLPROPERTY_LASTUSEDSOURCEW, 0,
                        REG_SZ, (LPBYTE)buffer, size);
-    msi_free(buffer);
+    free(buffer);
 
     RegCloseKey(source);
     return r;
@@ -851,12 +851,12 @@ UINT WINAPI MsiSourceListAddSourceW( LPCWSTR szProduct, LPCWSTR szUserName,
     {
         if (LookupAccountNameW(NULL, szUserName, NULL, &sidsize, NULL, &domsize, NULL))
         {
-            PSID psid = msi_alloc(sidsize);
+            PSID psid = malloc(sidsize);
 
             if (LookupAccountNameW(NULL, szUserName, psid, &sidsize, NULL, &domsize, NULL))
                 ConvertSidToStringSidW(psid, &sidstr);
 
-            msi_free(psid);
+            free(psid);
         }
 
         r = MSIREG_OpenProductKey(szProduct, NULL,
@@ -903,9 +903,9 @@ UINT WINAPI MsiSourceListAddSourceA( LPCSTR szProduct, LPCSTR szUserName,
 
     ret = MsiSourceListAddSourceW(szwproduct, szwusername, dwReserved, szwsource);
 
-    msi_free(szwproduct);
-    msi_free(szwusername);
-    msi_free(szwsource);
+    free(szwproduct);
+    free(szwusername);
+    free(szwsource);
 
     return ret;
 }
@@ -926,9 +926,9 @@ UINT WINAPI MsiSourceListAddSourceExA(LPCSTR szProduct, LPCSTR szUserSid,
     ret = MsiSourceListAddSourceExW(product, usersid, dwContext,
                                     dwOptions, source, dwIndex);
 
-    msi_free(product);
-    msi_free(usersid);
-    msi_free(source);
+    free(product);
+    free(usersid);
+    free(source);
 
     return ret;
 }
@@ -939,8 +939,8 @@ static void free_source_list(struct list *sourcelist)
     {
         media_info *info = LIST_ENTRY(list_head(sourcelist), media_info, entry);
         list_remove(&info->entry);
-        msi_free(info->path);
-        msi_free(info);
+        free(info->path);
+        free(info);
     }
 }
 
@@ -994,14 +994,14 @@ static UINT fill_source_list(struct list *sourcelist, HKEY sourcekey, DWORD *cou
         if (r != ERROR_SUCCESS)
             return r;
 
-        entry = msi_alloc(sizeof(media_info));
+        entry = malloc(sizeof(media_info));
         if (!entry)
             goto error;
 
-        entry->path = msi_alloc(val_size);
+        entry->path = malloc(val_size);
         if (!entry->path)
         {
-            msi_free(entry);
+            free(entry);
             goto error;
         }
 
@@ -1013,8 +1013,8 @@ static UINT fill_source_list(struct list *sourcelist, HKEY sourcekey, DWORD *cou
                           NULL, (LPBYTE)entry->path, &val_size);
         if (r != ERROR_SUCCESS)
         {
-            msi_free(entry->path);
-            msi_free(entry);
+            free(entry->path);
+            free(entry);
             goto error;
         }
 
@@ -1092,7 +1092,7 @@ UINT WINAPI MsiSourceListAddSourceExW( const WCHAR *szProduct, const WCHAR *szUs
     else
     {
         size = lstrlenW(szSource) + 2;
-        source = msi_alloc(size * sizeof(WCHAR));
+        source = malloc(size * sizeof(WCHAR));
         lstrcpyW(source, szSource);
         lstrcatW(source, postfix);
     }
@@ -1118,7 +1118,7 @@ UINT WINAPI MsiSourceListAddSourceExW( const WCHAR *szProduct, const WCHAR *szUs
     else
     {
         swprintf(name, ARRAY_SIZE(name), L"%d", dwIndex);
-        info = msi_alloc(sizeof(media_info));
+        info = malloc(sizeof(media_info));
         if (!info)
         {
             rc = ERROR_OUTOFMEMORY;
@@ -1145,7 +1145,7 @@ UINT WINAPI MsiSourceListAddSourceExW( const WCHAR *szProduct, const WCHAR *szUs
 
 done:
     free_source_list(&sourcelist);
-    msi_free(source);
+    free(source);
     RegCloseKey(typekey);
     RegCloseKey(sourcekey);
     return rc;
@@ -1172,10 +1172,10 @@ UINT WINAPI MsiSourceListAddMediaDiskA(LPCSTR szProduct, LPCSTR szUserSid,
     r = MsiSourceListAddMediaDiskW(product, usersid, dwContext, dwOptions,
                                      dwDiskId, volume, prompt);
 
-    msi_free(product);
-    msi_free(usersid);
-    msi_free(volume);
-    msi_free(prompt);
+    free(product);
+    free(usersid);
+    free(volume);
+    free(prompt);
 
     return r;
 }
@@ -1226,7 +1226,7 @@ UINT WINAPI MsiSourceListAddMediaDiskW( const WCHAR *szProduct, const WCHAR *szU
     if (szDiskPrompt) size += lstrlenW(szDiskPrompt);
 
     size *= sizeof(WCHAR);
-    buffer = msi_alloc(size);
+    buffer = malloc(size);
     *buffer = '\0';
 
     if (szVolumeLabel) lstrcpyW(buffer, szVolumeLabel);
@@ -1234,7 +1234,7 @@ UINT WINAPI MsiSourceListAddMediaDiskW( const WCHAR *szProduct, const WCHAR *szU
     if (szDiskPrompt) lstrcatW(buffer, szDiskPrompt);
 
     RegSetValueExW(mediakey, szIndex, 0, REG_SZ, (LPBYTE)buffer, size);
-    msi_free(buffer);
+    free(buffer);
 
     RegCloseKey(sourcekey);
     RegCloseKey(mediakey);
diff --git a/dlls/msi/sql.y b/dlls/msi/sql.y
index 885593a9d18d..43425fa4afcf 100644
--- a/dlls/msi/sql.y
+++ b/dlls/msi/sql.y
@@ -759,7 +759,7 @@ static void *parser_alloc( void *info, unsigned int sz )
     SQL_input* sql = (SQL_input*) info;
     struct list *mem;
 
-    mem = msi_alloc( sizeof (struct list) + sz );
+    mem = malloc( sizeof (struct list) + sz );
     list_add_tail( sql->mem, mem );
     return &mem[1];
 }
diff --git a/dlls/msi/storages.c b/dlls/msi/storages.c
index 652f5f4988e4..df17aa036a52 100644
--- a/dlls/msi/storages.c
+++ b/dlls/msi/storages.c
@@ -61,7 +61,7 @@ static BOOL storages_set_table_size(MSISTORAGESVIEW *sv, UINT size)
     if (size >= sv->max_storages)
     {
         sv->max_storages *= 2;
-        sv->storages = msi_realloc(sv->storages, sv->max_storages * sizeof(*sv->storages));
+        sv->storages = realloc(sv->storages, sv->max_storages * sizeof(*sv->storages));
         if (!sv->storages)
             return FALSE;
     }
@@ -124,7 +124,7 @@ static HRESULT stream_to_storage(IStream *stm, IStorage **stg)
     }
 
     size = stat.cbSize.QuadPart;
-    data = msi_alloc(size);
+    data = malloc(size);
     if (!data)
         return E_OUTOFMEMORY;
 
@@ -148,7 +148,7 @@ static HRESULT stream_to_storage(IStream *stm, IStorage **stg)
         goto done;
 
 done:
-    msi_free(data);
+    free(data);
     if (lockbytes) ILockBytes_Release(lockbytes);
     return hr;
 }
@@ -248,7 +248,7 @@ static UINT STORAGES_set_row(struct tagMSIVIEW *view, UINT row, MSIRECORD *rec,
     if (prev) IStorage_Release(prev);
 
 done:
-    msi_free(name);
+    free(name);
 
     if (substg) IStorage_Release(substg);
     IStorage_Release(stg);
@@ -431,9 +431,9 @@ static UINT STORAGES_delete(struct tagMSIVIEW *view)
             IStorage_Release(sv->storages[i].storage);
     }
 
-    msi_free(sv->storages);
+    free(sv->storages);
     sv->storages = NULL;
-    msi_free(sv);
+    free(sv);
 
     return ERROR_SUCCESS;
 }
@@ -474,7 +474,7 @@ static INT add_storages_to_table(MSISTORAGESVIEW *sv)
         return -1;
 
     sv->max_storages = 1;
-    sv->storages = msi_alloc(sizeof(*sv->storages));
+    sv->storages = malloc(sizeof(*sv->storages));
     if (!sv->storages)
         return -1;
 
@@ -519,7 +519,7 @@ UINT STORAGES_CreateView(MSIDATABASE *db, MSIVIEW **view)
 
     TRACE("(%p, %p)\n", db, view);
 
-    sv = msi_alloc_zero( sizeof(MSISTORAGESVIEW) );
+    sv = calloc(1, sizeof(MSISTORAGESVIEW));
     if (!sv)
         return ERROR_FUNCTION_FAILED;
 
@@ -529,7 +529,7 @@ UINT STORAGES_CreateView(MSIDATABASE *db, MSIVIEW **view)
     rows = add_storages_to_table(sv);
     if (rows < 0)
     {
-        msi_free( sv );
+        free(sv);
         return ERROR_FUNCTION_FAILED;
     }
     sv->num_rows = rows;
diff --git a/dlls/msi/streams.c b/dlls/msi/streams.c
index faa9fe4333a5..fb83e49db8b0 100644
--- a/dlls/msi/streams.c
+++ b/dlls/msi/streams.c
@@ -49,7 +49,7 @@ static BOOL streams_resize_table( MSIDATABASE *db, UINT size )
 {
     if (!db->num_streams_allocated)
     {
-        if (!(db->streams = msi_alloc_zero( size * sizeof(MSISTREAM) ))) return FALSE;
+        if (!(db->streams = calloc( size, sizeof(MSISTREAM) ))) return FALSE;
         db->num_streams_allocated = size;
         return TRUE;
     }
@@ -57,7 +57,7 @@ static BOOL streams_resize_table( MSIDATABASE *db, UINT size )
     {
         MSISTREAM *tmp;
         UINT new_size = db->num_streams_allocated * 2;
-        if (!(tmp = msi_realloc( db->streams, new_size * sizeof(*tmp) ))) return FALSE;
+        if (!(tmp = realloc( db->streams, new_size * sizeof(*tmp) ))) return FALSE;
         memset( tmp + db->num_streams_allocated, 0, (new_size - db->num_streams_allocated) * sizeof(*tmp) );
         db->streams = tmp;
         db->num_streams_allocated = new_size;
@@ -238,7 +238,7 @@ static UINT STREAMS_delete_row(struct tagMSIVIEW *view, UINT row)
     db->num_streams = num_rows;
 
     hr = IStorage_DestroyElement( db->storage, encname );
-    msi_free( encname );
+    free( encname );
     return FAILED( hr ) ? ERROR_FUNCTION_FAILED : ERROR_SUCCESS;
 }
 
@@ -366,7 +366,7 @@ static UINT STREAMS_delete(struct tagMSIVIEW *view)
 
     TRACE("(%p)\n", view);
 
-    msi_free(sv);
+    free(sv);
     return ERROR_SUCCESS;
 }
 
@@ -521,7 +521,7 @@ UINT msi_get_stream( MSIDATABASE *db, const WCHAR *name, IStream **ret )
         return ERROR_OUTOFMEMORY;
 
     hr = open_stream( db, encname, ret );
-    msi_free( encname );
+    free( encname );
     if (FAILED( hr ))
         return ERROR_FUNCTION_FAILED;
 
@@ -547,7 +547,7 @@ UINT STREAMS_CreateView(MSIDATABASE *db, MSIVIEW **view)
     if (r != ERROR_SUCCESS)
         return r;
 
-    if (!(sv = msi_alloc_zero( sizeof(MSISTREAMSVIEW) )))
+    if (!(sv = calloc( 1, sizeof(MSISTREAMSVIEW) )))
         return ERROR_OUTOFMEMORY;
 
     sv->view.ops = &streams_ops;
@@ -629,7 +629,7 @@ UINT msi_commit_streams( MSIDATABASE *db )
             if (FAILED( hr ))
             {
                 ERR( "failed to write stream %s (hr = %#lx)\n", debugstr_w(encname), hr );
-                msi_free( encname );
+                free( encname );
                 IStream_Release( stream );
                 return ERROR_FUNCTION_FAILED;
             }
@@ -638,17 +638,17 @@ UINT msi_commit_streams( MSIDATABASE *db )
             if (FAILED( hr ))
             {
                 ERR( "failed to commit stream %s (hr = %#lx)\n", debugstr_w(encname), hr );
-                msi_free( encname );
+                free( encname );
                 return ERROR_FUNCTION_FAILED;
             }
         }
         else if (hr != STG_E_FILEALREADYEXISTS)
         {
             ERR( "failed to create stream %s (hr = %#lx)\n", debugstr_w(encname), hr );
-            msi_free( encname );
+            free( encname );
             return ERROR_FUNCTION_FAILED;
         }
-        msi_free( encname );
+        free( encname );
     }
 
     return ERROR_SUCCESS;
diff --git a/dlls/msi/string.c b/dlls/msi/string.c
index 70c6873a331c..38381b8b5216 100644
--- a/dlls/msi/string.c
+++ b/dlls/msi/string.c
@@ -75,24 +75,24 @@ static string_table *init_stringtable( int entries, UINT codepage )
     if (!validate_codepage( codepage ))
         return NULL;
 
-    st = msi_alloc( sizeof (string_table) );
+    st = malloc( sizeof(string_table) );
     if( !st )
         return NULL;
     if( entries < 1 )
         entries = 1;
 
-    st->strings = msi_alloc_zero( sizeof(struct msistring) * entries );
+    st->strings = calloc( entries, sizeof(struct msistring) );
     if( !st->strings )
     {
-        msi_free( st );
+        free( st );
         return NULL;
     }
 
-    st->sorted = msi_alloc( sizeof (UINT) * entries );
+    st->sorted = malloc( sizeof(UINT) * entries );
     if( !st->sorted )
     {
-        msi_free( st->strings );
-        msi_free( st );
+        free( st->strings );
+        free( st );
         return NULL;
     }
 
@@ -112,11 +112,11 @@ VOID msi_destroy_stringtable( string_table *st )
     {
         if( st->strings[i].persistent_refcount ||
             st->strings[i].nonpersistent_refcount )
-            msi_free( st->strings[i].data );
+            free( st->strings[i].data );
     }
-    msi_free( st->strings );
-    msi_free( st->sorted );
-    msi_free( st );
+    free( st->strings );
+    free( st->sorted );
+    free( st );
 }
 
 static int st_find_free_entry( string_table *st )
@@ -140,12 +140,12 @@ static int st_find_free_entry( string_table *st )
 
     /* dynamically resize */
     sz = st->maxcount + 1 + st->maxcount / 2;
-    if (!(p = msi_realloc( st->strings, sz * sizeof(*p) ))) return -1;
+    if (!(p = realloc( st->strings, sz * sizeof(*p) ))) return -1;
     memset( p + st->maxcount, 0, (sz - st->maxcount) * sizeof(*p) );
 
-    if (!(s = msi_realloc( st->sorted, sz * sizeof(*s) )))
+    if (!(s = realloc( st->sorted, sz * sizeof(*s) )))
     {
-        msi_free( p );
+        free( p );
         return -1;
     }
 
@@ -244,13 +244,13 @@ static UINT string2id( const string_table *st, const char *buffer, UINT *id )
 
     if (!(sz = MultiByteToWideChar( st->codepage, 0, buffer, -1, NULL, 0 )))
         return r;
-    str = msi_alloc( sz*sizeof(WCHAR) );
+    str = malloc( sz * sizeof(WCHAR) );
     if( !str )
         return ERROR_NOT_ENOUGH_MEMORY;
     MultiByteToWideChar( st->codepage, 0, buffer, -1, str, sz );
 
     r = msi_string2id( st, str, sz - 1, id );
-    msi_free( str );
+    free( str );
     return r;
 }
 
@@ -290,7 +290,7 @@ static int add_string( string_table *st, UINT n, const char *data, UINT len, USH
 
     /* allocate a new string */
     sz = MultiByteToWideChar( st->codepage, 0, data, len, NULL, 0 );
-    str = msi_alloc( (sz+1)*sizeof(WCHAR) );
+    str = malloc( (sz + 1) * sizeof(WCHAR) );
     if( !str )
         return -1;
     MultiByteToWideChar( st->codepage, 0, data, len, str, sz );
@@ -329,7 +329,7 @@ int msi_add_string( string_table *st, const WCHAR *data, int len, BOOL persisten
     /* allocate a new string */
     TRACE( "%s, n = %d len = %d\n", debugstr_wn(data, len), n, len );
 
-    str = msi_alloc( (len+1)*sizeof(WCHAR) );
+    str = malloc( (len + 1) * sizeof(WCHAR) );
     if( !str )
         return -1;
     memcpy( str, data, len*sizeof(WCHAR) );
@@ -555,8 +555,8 @@ string_table *msi_load_string_table( IStorage *stg, UINT *bytes_per_strref )
     TRACE( "loaded %lu strings\n", count );
 
 end:
-    msi_free( pool );
-    msi_free( data );
+    free( pool );
+    free( data );
 
     return st;
 }
@@ -575,13 +575,13 @@ UINT msi_save_string_table( const string_table *st, IStorage *storage, UINT *byt
 
     TRACE("%u %u %u\n", st->maxcount, datasize, poolsize );
 
-    pool = msi_alloc( poolsize );
+    pool = malloc( poolsize );
     if( ! pool )
     {
         WARN("Failed to alloc pool %d bytes\n", poolsize );
         goto err;
     }
-    data = msi_alloc( datasize );
+    data = malloc( datasize );
     if( ! data )
     {
         WARN("Failed to alloc data %d bytes\n", datasize );
@@ -662,8 +662,8 @@ UINT msi_save_string_table( const string_table *st, IStorage *storage, UINT *byt
     ret = ERROR_SUCCESS;
 
 err:
-    msi_free( data );
-    msi_free( pool );
+    free( data );
+    free( pool );
 
     return ret;
 }
diff --git a/dlls/msi/suminfo.c b/dlls/msi/suminfo.c
index 296d554cfe0a..de2dda8bf2b5 100644
--- a/dlls/msi/suminfo.c
+++ b/dlls/msi/suminfo.c
@@ -91,7 +91,7 @@ static HRESULT (WINAPI *pPropVariantChangeType)
 static void free_prop( PROPVARIANT *prop )
 {
     if (prop->vt == VT_LPSTR )
-        msi_free( prop->pszVal );
+        free( prop->pszVal );
     prop->vt = VT_EMPTY;
 }
 
@@ -210,7 +210,7 @@ static void read_properties_from_data( PROPVARIANT *prop, LPBYTE data, DWORD sz
         property.vt = propdata->type;
         if( propdata->type == VT_LPSTR )
         {
-            LPSTR str = msi_alloc( propdata->u.str.len );
+            char *str = malloc( propdata->u.str.len );
             memcpy( str, propdata->u.str.str, propdata->u.str.len );
             str[ propdata->u.str.len - 1 ] = 0;
             property.pszVal = str;
@@ -286,7 +286,7 @@ static UINT load_summary_info( MSISUMMARYINFO *si, IStream *stm )
         return ERROR_FUNCTION_FAILED;
     }
 
-    data = msi_alloc( section_hdr.cbSection);
+    data = malloc( section_hdr.cbSection );
     if( !data )
         return ERROR_FUNCTION_FAILED;
 
@@ -300,7 +300,7 @@ static UINT load_summary_info( MSISUMMARYINFO *si, IStream *stm )
     else
         ERR( "failed to read properties %lu %lu\n", count, sz );
 
-    msi_free( data );
+    free( data );
     return ERROR_SUCCESS;
 }
 
@@ -406,7 +406,7 @@ static UINT save_summary_info( const MSISUMMARYINFO * si, IStream *stm )
         section_hdr.cbSection += sz;
     }
 
-    data = msi_alloc_zero( section_hdr.cbSection );
+    data = calloc( 1, section_hdr.cbSection );
 
     sz = 0;
     memcpy( &data[sz], &section_hdr, sizeof section_hdr );
@@ -420,7 +420,7 @@ static UINT save_summary_info( const MSISUMMARYINFO * si, IStream *stm )
         sz += write_property_to_data( &si->property[i], &data[sz] );
 
     r = IStream_Write( stm, data, sz, &count );
-    msi_free( data );
+    free( data );
     if( FAILED(r) || count != sz )
         return ret;
 
@@ -585,7 +585,7 @@ UINT WINAPI MsiGetSummaryInformationA( MSIHANDLE hDatabase, const char *szDataba
 
     ret = MsiGetSummaryInformationW(hDatabase, szwDatabase, uiUpdateCount, pHandle);
 
-    msi_free( szwDatabase );
+    free( szwDatabase );
 
     return ret;
 }
@@ -859,14 +859,14 @@ static UINT set_prop( MSISUMMARYINFO *si, UINT uiProperty, UINT type,
         {
             len = WideCharToMultiByte( CP_ACP, 0, str->str.w, -1,
                                        NULL, 0, NULL, NULL );
-            prop->pszVal = msi_alloc( len );
+            prop->pszVal = malloc( len );
             WideCharToMultiByte( CP_ACP, 0, str->str.w, -1,
                                  prop->pszVal, len, NULL, NULL );
         }
         else
         {
             len = lstrlenA( str->str.a ) + 1;
-            prop->pszVal = msi_alloc( len );
+            prop->pszVal = malloc( len );
             lstrcpyA( prop->pszVal, str->str.a );
         }
         break;
@@ -1126,21 +1126,21 @@ static UINT save_prop( MSISUMMARYINFO *si, HANDLE handle, UINT row )
         break;
     case VT_LPSTR:
         len++;
-        if (!(str.str.a = msi_alloc( len )))
+        if (!(str.str.a = malloc( len )))
             return ERROR_OUTOFMEMORY;
         r = get_prop( si, row, NULL, NULL, NULL, &str, &len );
         if (r != ERROR_SUCCESS)
         {
-            msi_free( str.str.a );
+            free( str.str.a );
             return r;
         }
         sz = len;
         if (!WriteFile( handle, str.str.a, sz, &sz, NULL ))
         {
-            msi_free( str.str.a );
+            free( str.str.a );
             return ERROR_WRITE_FAULT;
         }
-        msi_free( str.str.a );
+        free( str.str.a );
         break;
     case VT_FILETIME:
         if (!FileTimeToSystemTime( &file_time, &system_time ))
@@ -1227,7 +1227,7 @@ UINT WINAPI MsiCreateTransformSummaryInfoA( MSIHANDLE db, MSIHANDLE db_ref, cons
         return ERROR_OUTOFMEMORY;
 
     r = MsiCreateTransformSummaryInfoW( db, db_ref, transformW, error, validation );
-    msi_free( transformW );
+    free( transformW );
     return r;
 }
 
@@ -1270,19 +1270,19 @@ UINT msi_load_suminfo_properties( MSIPACKAGE *package )
     }
 
     len++;
-    if (!(package_code = msi_alloc( len * sizeof(WCHAR) ))) return ERROR_OUTOFMEMORY;
+    if (!(package_code = malloc( len * sizeof(WCHAR) ))) return ERROR_OUTOFMEMORY;
     str.str.w = package_code;
 
     r = get_prop( si, PID_REVNUMBER, NULL, NULL, NULL, &str, &len );
     if (r != ERROR_SUCCESS)
     {
-        msi_free( package_code );
+        free( package_code );
         msiobj_release( &si->hdr );
         return r;
     }
 
     r = msi_set_property( package->db, L"PackageCode", package_code, len );
-    msi_free( package_code );
+    free( package_code );
 
     count = 0;
     get_prop( si, PID_WORDCOUNT, NULL, &count, NULL, NULL, NULL );
diff --git a/dlls/msi/table.c b/dlls/msi/table.c
index 36ad40590141..5fe803cee3cb 100644
--- a/dlls/msi/table.c
+++ b/dlls/msi/table.c
@@ -124,7 +124,7 @@ LPWSTR encode_streamname(BOOL bTable, LPCWSTR in)
 
     if( !bTable )
         count = lstrlenW( in )+2;
-    if (!(out = msi_alloc( count*sizeof(WCHAR) ))) return NULL;
+    if (!(out = malloc( count * sizeof(WCHAR) ))) return NULL;
     p = out;
 
     if( bTable )
@@ -158,7 +158,7 @@ LPWSTR encode_streamname(BOOL bTable, LPCWSTR in)
         *p++ = ch;
     }
     ERR("Failed to encode stream name (%s)\n",debugstr_w(in));
-    msi_free( out );
+    free( out );
     return NULL;
 }
 
@@ -246,7 +246,7 @@ UINT read_stream_data( IStorage *stg, LPCWSTR stname, BOOL table,
 
     r = IStorage_OpenStream(stg, encname, NULL,
             STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &stm);
-    msi_free( encname );
+    free(encname);
     if( FAILED( r ) )
     {
         WARN( "open stream failed r = %#lx - empty table?\n", r );
@@ -267,7 +267,7 @@ UINT read_stream_data( IStorage *stg, LPCWSTR stname, BOOL table,
     }
 
     sz = stat.cbSize.QuadPart;
-    data = msi_alloc( sz );
+    data = malloc(sz);
     if( !data )
     {
         WARN( "couldn't allocate memory r = %#lx!\n", r );
@@ -278,7 +278,7 @@ UINT read_stream_data( IStorage *stg, LPCWSTR stname, BOOL table,
     r = IStream_Read(stm, data, sz, &count );
     if( FAILED( r ) || ( count != sz ) )
     {
-        msi_free( data );
+        free(data);
         WARN("read stream failed r = %#lx!\n", r);
         goto end;
     }
@@ -312,7 +312,7 @@ UINT write_stream_data( IStorage *stg, LPCWSTR stname,
         r = IStorage_CreateStream( stg, encname,
                 STGM_WRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &stm);
     }
-    msi_free( encname );
+    free( encname );
     if( FAILED( r ) )
     {
         WARN( "open stream failed r = %#lx\n", r );
@@ -353,22 +353,22 @@ UINT write_stream_data( IStorage *stg, LPCWSTR stname,
     return ret;
 }
 
-static void msi_free_colinfo( MSICOLUMNINFO *colinfo, UINT count )
+static void free_colinfo( MSICOLUMNINFO *colinfo, UINT count )
 {
     UINT i;
-    for (i = 0; i < count; i++) msi_free( colinfo[i].hash_table );
+    for (i = 0; i < count; i++) free( colinfo[i].hash_table );
 }
 
 static void free_table( MSITABLE *table )
 {
     UINT i;
     for( i=0; i<table->row_count; i++ )
-        msi_free( table->data[i] );
-    msi_free( table->data );
-    msi_free( table->data_persistent );
-    msi_free_colinfo( table->colinfo, table->col_count );
-    msi_free( table->colinfo );
-    msi_free( table );
+        free( table->data[i] );
+    free( table->data );
+    free( table->data_persistent );
+    free_colinfo( table->colinfo, table->col_count );
+    free( table->colinfo );
+    free( table );
 }
 
 static UINT msi_table_get_row_size( MSIDATABASE *db, const MSICOLUMNINFO *cols, UINT count, UINT bytes_per_strref )
@@ -414,8 +414,8 @@ static UINT read_table_from_storage( MSIDATABASE *db, MSITABLE *t, IStorage *stg
 
     if ((t->row_count = rawsize / row_size))
     {
-        if (!(t->data = msi_alloc_zero( t->row_count * sizeof(USHORT *) ))) goto err;
-        if (!(t->data_persistent = msi_alloc_zero( t->row_count * sizeof(BOOL) ))) goto err;
+        if (!(t->data = calloc( t->row_count, sizeof(USHORT *) ))) goto err;
+        if (!(t->data_persistent = calloc( t->row_count, sizeof(BOOL) ))) goto err;
     }
 
     /* transpose all the data */
@@ -424,7 +424,7 @@ static UINT read_table_from_storage( MSIDATABASE *db, MSITABLE *t, IStorage *stg
     {
         UINT ofs = 0, ofs_mem = 0;
 
-        t->data[i] = msi_alloc( row_size_mem );
+        t->data[i] = malloc( row_size_mem );
         if( !t->data[i] )
             goto err;
         t->data_persistent[i] = TRUE;
@@ -460,10 +460,10 @@ static UINT read_table_from_storage( MSIDATABASE *db, MSITABLE *t, IStorage *stg
         }
     }
 
-    msi_free( rawdata );
+    free( rawdata );
     return ERROR_SUCCESS;
 err:
-    msi_free( rawdata );
+    free( rawdata );
     return ERROR_FUNCTION_FAILED;
 }
 
@@ -556,14 +556,14 @@ static UINT table_get_column_info( MSIDATABASE *db, LPCWSTR name, MSICOLUMNINFO
 
     TRACE("table %s found\n", debugstr_w(name));
 
-    columns = msi_alloc( column_count * sizeof(MSICOLUMNINFO) );
+    columns = malloc( column_count * sizeof(MSICOLUMNINFO) );
     if (!columns)
         return ERROR_FUNCTION_FAILED;
 
     r = get_tablecolumns( db, name, columns, &column_count );
     if (r != ERROR_SUCCESS)
     {
-        msi_free( columns );
+        free( columns );
         return ERROR_FUNCTION_FAILED;
     }
     *pcols = columns;
@@ -584,7 +584,7 @@ static UINT get_table( MSIDATABASE *db, LPCWSTR name, MSITABLE **table_ret )
     }
 
     /* nonexistent tables should be interpreted as empty tables */
-    table = msi_alloc( sizeof(MSITABLE) + lstrlenW( name ) * sizeof(WCHAR) );
+    table = malloc( sizeof(MSITABLE) + wcslen( name ) * sizeof(WCHAR) );
     if (!table)
         return ERROR_FUNCTION_FAILED;
 
@@ -694,7 +694,7 @@ static UINT get_tablecolumns( MSIDATABASE *db, LPCWSTR szTableName, MSICOLUMNINF
     if (colinfo && n != maxcount)
     {
         ERR("missing column in table %s\n", debugstr_w(szTableName));
-        msi_free_colinfo( colinfo, maxcount );
+        free_colinfo( colinfo, maxcount );
         return ERROR_FUNCTION_FAILED;
     }
     table_calc_column_offsets( db, colinfo, n );
@@ -719,7 +719,7 @@ UINT msi_create_table( MSIDATABASE *db, LPCWSTR name, column_info *col_info,
         return ERROR_BAD_QUERY_SYNTAX;
     }
 
-    table = msi_alloc( sizeof (MSITABLE) + lstrlenW(name)*sizeof (WCHAR) );
+    table = malloc( sizeof(MSITABLE) + wcslen(name) * sizeof(WCHAR) );
     if( !table )
         return ERROR_FUNCTION_FAILED;
 
@@ -738,7 +738,7 @@ UINT msi_create_table( MSIDATABASE *db, LPCWSTR name, column_info *col_info,
     for( col = col_info; col; col = col->next )
         table->col_count++;
 
-    table->colinfo = msi_alloc( table->col_count * sizeof(MSICOLUMNINFO) );
+    table->colinfo = malloc( table->col_count * sizeof(MSICOLUMNINFO) );
     if (!table->colinfo)
     {
         free_table( table );
@@ -878,7 +878,7 @@ static UINT save_table( MSIDATABASE *db, const MSITABLE *t, UINT bytes_per_strre
         }
     }
     rawsize = row_count * row_size;
-    rawdata = msi_alloc_zero( rawsize );
+    rawdata = calloc( 1, rawsize );
     if( !rawdata )
     {
         r = ERROR_NOT_ENOUGH_MEMORY;
@@ -926,7 +926,7 @@ static UINT save_table( MSIDATABASE *db, const MSITABLE *t, UINT bytes_per_strre
     r = write_stream_data( db->storage, t->name, rawdata, rawsize, TRUE );
 
 err:
-    msi_free( rawdata );
+    free( rawdata );
     return r;
 }
 
@@ -938,8 +938,8 @@ static void msi_update_table_columns( MSIDATABASE *db, LPCWSTR name )
 
     if (!(table = find_cached_table( db, name ))) return;
     old_count = table->col_count;
-    msi_free_colinfo( table->colinfo, table->col_count );
-    msi_free( table->colinfo );
+    free_colinfo( table->colinfo, table->col_count );
+    free( table->colinfo );
     table->colinfo = NULL;
 
     table_get_column_info( db, name, &table->colinfo, &table->col_count );
@@ -950,7 +950,7 @@ static void msi_update_table_columns( MSIDATABASE *db, LPCWSTR name )
 
     for ( n = 0; n < table->row_count; n++ )
     {
-        table->data[n] = msi_realloc( table->data[n], size );
+        table->data[n] = realloc( table->data[n], size );
         if (old_count < table->col_count)
             memset( &table->data[n][offset], 0, size - offset );
     }
@@ -1050,7 +1050,7 @@ static UINT get_stream_name( const MSITABLEVIEW *tv, UINT row, WCHAR **pstname )
     TRACE("%p %d\n", tv, row);
 
     len = lstrlenW( tv->name ) + 1;
-    stname = msi_alloc( len*sizeof(WCHAR) );
+    stname = malloc( len * sizeof(WCHAR) );
     if ( !stname )
     {
        r = ERROR_OUTOFMEMORY;
@@ -1100,7 +1100,7 @@ static UINT get_stream_name( const MSITABLEVIEW *tv, UINT row, WCHAR **pstname )
             }
 
             len += lstrlenW( L"." ) + lstrlenW( sval );
-            p = msi_realloc ( stname, len*sizeof(WCHAR) );
+            p = realloc( stname, len * sizeof(WCHAR) );
             if ( !p )
             {
                 r = ERROR_OUTOFMEMORY;
@@ -1119,7 +1119,7 @@ static UINT get_stream_name( const MSITABLEVIEW *tv, UINT row, WCHAR **pstname )
     return ERROR_SUCCESS;
 
 err:
-    msi_free( stname );
+    free( stname );
     *pstname = NULL;
     return r;
 }
@@ -1149,7 +1149,7 @@ static UINT TABLE_fetch_stream( struct tagMSIVIEW *view, UINT row, UINT col, ISt
     if (r != ERROR_SUCCESS)
         ERR("fetching stream %s, error = %u\n", debugstr_w(name), r);
 
-    msi_free( name );
+    free( name );
     return r;
 }
 
@@ -1174,7 +1174,7 @@ static UINT table_set_bytes( MSITABLEVIEW *tv, UINT row, UINT col, UINT val )
         return ERROR_FUNCTION_FAILED;
     }
 
-    msi_free( tv->columns[col-1].hash_table );
+    free( tv->columns[col-1].hash_table );
     tv->columns[col-1].hash_table = NULL;
 
     n = bytes_per_column( tv->db, &tv->columns[col - 1], LONG_STR_BYTES );
@@ -1349,7 +1349,7 @@ static UINT TABLE_set_stream( MSIVIEW *view, UINT row, UINT col, IStream *stream
         return r;
 
     r = add_stream( tv->db, name, stream );
-    msi_free( name );
+    free( name );
     return r;
 }
 
@@ -1434,7 +1434,7 @@ static UINT TABLE_set_row( struct tagMSIVIEW *view, UINT row, MSIRECORD *rec, UI
 
                 r = add_stream( tv->db, stname, stm );
                 IStream_Release( stm );
-                msi_free ( stname );
+                free( stname );
 
                 if ( r != ERROR_SUCCESS )
                     return r;
@@ -1485,7 +1485,7 @@ static UINT table_create_new_row( struct tagMSIVIEW *view, UINT *num, BOOL tempo
     if( !tv->table )
         return ERROR_INVALID_PARAMETER;
 
-    row = msi_alloc_zero( tv->row_size );
+    row = calloc( 1, tv->row_size );
     if( !row )
         return ERROR_NOT_ENOUGH_MEMORY;
 
@@ -1497,24 +1497,24 @@ static UINT table_create_new_row( struct tagMSIVIEW *view, UINT *num, BOOL tempo
 
     sz = (*row_count + 1) * sizeof (BYTE*);
     if( *data_ptr )
-        p = msi_realloc( *data_ptr, sz );
+        p = realloc( *data_ptr, sz );
     else
-        p = msi_alloc( sz );
+        p = malloc( sz );
     if( !p )
     {
-        msi_free( row );
+        free( row );
         return ERROR_NOT_ENOUGH_MEMORY;
     }
 
     sz = (*row_count + 1) * sizeof (BOOL);
     if( *data_persist_ptr )
-        b = msi_realloc( *data_persist_ptr, sz );
+        b = realloc( *data_persist_ptr, sz );
     else
-        b = msi_alloc( sz );
+        b = malloc( sz );
     if( !b )
     {
-        msi_free( row );
-        msi_free( p );
+        free( row );
+        free( p );
         return ERROR_NOT_ENOUGH_MEMORY;
     }
 
@@ -1759,7 +1759,7 @@ static UINT TABLE_delete_row( struct tagMSIVIEW *view, UINT row )
     /* reset the hash tables */
     for (i = 0; i < tv->num_cols; i++)
     {
-        msi_free( tv->columns[i].hash_table );
+        free(tv->columns[i].hash_table);
         tv->columns[i].hash_table = NULL;
     }
 
@@ -1769,7 +1769,7 @@ static UINT TABLE_delete_row( struct tagMSIVIEW *view, UINT row )
         tv->table->data_persistent[i - 1] = tv->table->data_persistent[i];
     }
 
-    msi_free(tv->table->data[num_rows - 1]);
+    free(tv->table->data[num_rows - 1]);
 
     return ERROR_SUCCESS;
 }
@@ -1919,7 +1919,7 @@ static UINT TABLE_delete( struct tagMSIVIEW *view )
     tv->table = NULL;
     tv->columns = NULL;
 
-    msi_free( tv );
+    free( tv );
 
     return ERROR_SUCCESS;
 }
@@ -1946,10 +1946,10 @@ static UINT TABLE_remove_column(struct tagMSIVIEW *view, UINT number)
     {
         UINT size = tv->table->colinfo[number-1].offset;
         tv->table->col_count--;
-        tv->table->colinfo = msi_realloc( tv->table->colinfo, sizeof(*tv->table->colinfo) * tv->table->col_count );
+        tv->table->colinfo = realloc(tv->table->colinfo, sizeof(*tv->table->colinfo) * tv->table->col_count);
 
         for (row = 0; row < tv->table->row_count; row++)
-            tv->table->data[row] = msi_realloc( tv->table->data[row], size );
+            tv->table->data[row] = realloc(tv->table->data[row], size);
         return ERROR_SUCCESS;
     }
 
@@ -2041,7 +2041,7 @@ static UINT TABLE_add_column(struct tagMSIVIEW *view, LPCWSTR column,
             return ERROR_BAD_QUERY_SYNTAX;
     }
 
-    colinfo = msi_realloc(tv->table->colinfo, sizeof(*tv->table->colinfo) * (tv->table->col_count + 1));
+    colinfo = realloc(tv->table->colinfo, sizeof(*tv->table->colinfo) * (tv->table->col_count + 1));
     if (!colinfo)
         return ERROR_OUTOFMEMORY;
     tv->table->colinfo = colinfo;
@@ -2065,7 +2065,7 @@ static UINT TABLE_add_column(struct tagMSIVIEW *view, LPCWSTR column,
     offset = tv->table->colinfo[tv->table->col_count - 1].offset;
     for (i = 0; i < tv->table->row_count; i++)
     {
-        BYTE *data = msi_realloc( tv->table->data[i], size );
+        BYTE *data = realloc(tv->table->data[i], size);
         if (!data)
         {
             tv->table->col_count--;
@@ -2199,14 +2199,14 @@ UINT TABLE_CreateView( MSIDATABASE *db, LPCWSTR name, MSIVIEW **view )
         return STORAGES_CreateView( db, view );
 
     sz = FIELD_OFFSET( MSITABLEVIEW, name[lstrlenW( name ) + 1] );
-    tv = msi_alloc_zero( sz );
+    tv = calloc( 1, sz );
     if( !tv )
         return ERROR_FUNCTION_FAILED;
 
     r = get_table( db, name, &tv->table );
     if( r != ERROR_SUCCESS )
     {
-        msi_free( tv );
+        free( tv );
         WARN("table not found\n");
         return r;
     }
@@ -2242,7 +2242,7 @@ static WCHAR* create_key_string(MSITABLEVIEW *tv, MSIRECORD *rec)
         key_len++;
     }
 
-    key = msi_alloc( key_len * sizeof(WCHAR) );
+    key = malloc( key_len * sizeof(WCHAR) );
     if(!key)
         return NULL;
 
@@ -2369,26 +2369,26 @@ static UINT TransformView_set_row( MSIVIEW *view, UINT row, MSIRECORD *rec, UINT
         {
             if (old_rec)
                 msiobj_release( &old_rec->hdr );
-            msi_free( key );
+            free( key );
             return r;
         }
         qlen += len + 3;
         if (old_rec && (r = MSI_RecordGetStringW( old_rec, i+1, NULL, &len )))
         {
             msiobj_release( &old_rec->hdr );
-            msi_free( key );
+            free( key );
             return r;
         }
         qlen += len + 3; /* strlen("')") + 1 */
 
         if (qlen > ARRAY_SIZE(buf))
         {
-            query = msi_alloc( qlen * sizeof(WCHAR) );
+            query = malloc( qlen * sizeof(WCHAR) );
             if (!query)
             {
                 if (old_rec)
                     msiobj_release( &old_rec->hdr );
-                msi_free( key );
+                free( key );
                 return ERROR_OUTOFMEMORY;
             }
         }
@@ -2437,12 +2437,12 @@ static UINT TransformView_set_row( MSIVIEW *view, UINT row, MSIRECORD *rec, UINT
 
         r = MSI_DatabaseOpenViewW( tv->db, query, &q );
         if (query != buf)
-            msi_free( query );
+            free( query );
         if (r != ERROR_SUCCESS)
         {
             if (old_rec)
                 msiobj_release( &old_rec->hdr );
-            msi_free( key );
+            free( key );
             return r;
         }
 
@@ -2452,14 +2452,14 @@ static UINT TransformView_set_row( MSIVIEW *view, UINT row, MSIRECORD *rec, UINT
         {
             if (old_rec)
                 msiobj_release( &old_rec->hdr );
-            msi_free( key );
+            free( key );
             return r;
         }
     }
 
     if (old_rec)
         msiobj_release( &old_rec->hdr );
-    msi_free( key );
+    free( key );
     return ERROR_SUCCESS;
 }
 
@@ -2481,7 +2481,7 @@ static UINT TransformView_create_table( MSITABLEVIEW *tv, MSIRECORD *rec )
     len = _snwprintf( NULL, 0, query_fmt, name ) + 1;
     if (len > ARRAY_SIZE(buf))
     {
-        query = msi_alloc( len * sizeof(WCHAR) );
+        query = malloc( len * sizeof(WCHAR) );
         if (!query)
             return ERROR_OUTOFMEMORY;
     }
@@ -2489,7 +2489,7 @@ static UINT TransformView_create_table( MSITABLEVIEW *tv, MSIRECORD *rec )
 
     r = MSI_DatabaseOpenViewW( tv->db, query, &q );
     if (query != buf)
-        msi_free( query );
+        free( query );
     if (r != ERROR_SUCCESS)
         return r;
 
@@ -2519,7 +2519,7 @@ static UINT TransformView_add_column( MSITABLEVIEW *tv, MSIRECORD *rec )
 
     if (qlen > ARRAY_SIZE(buf))
     {
-        query = msi_alloc( len * sizeof(WCHAR) );
+        query = malloc( len * sizeof(WCHAR) );
         qlen = len;
         if (!query)
             return ERROR_OUTOFMEMORY;
@@ -2543,7 +2543,7 @@ static UINT TransformView_add_column( MSITABLEVIEW *tv, MSIRECORD *rec )
 
     r = MSI_DatabaseOpenViewW( tv->db, query, &q );
     if (query != buf)
-        msi_free( query );
+        free( query );
     if (r != ERROR_SUCCESS)
         return r;
 
@@ -2577,19 +2577,19 @@ static UINT TransformView_insert_row( MSIVIEW *view, MSIRECORD *rec, UINT row, B
     len = _snwprintf( NULL, 0, query_fmt, tv->name, key ) + 1;
     if (len > ARRAY_SIZE(buf))
     {
-        query = msi_alloc( len * sizeof(WCHAR) );
+        query = malloc( len * sizeof(WCHAR) );
         if (!query)
         {
-            msi_free( key );
+            free( key );
             return ERROR_OUTOFMEMORY;
         }
     }
     swprintf( query, len, query_fmt, tv->name, key );
-    msi_free( key );
+    free( key );
 
     r = MSI_DatabaseOpenViewW( tv->db, query, &q );
     if (query != buf)
-        msi_free( query );
+        free( query );
     if (r != ERROR_SUCCESS)
         return r;
 
@@ -2623,7 +2623,7 @@ static UINT TransformView_drop_table( MSITABLEVIEW *tv, UINT row )
     len = ARRAY_SIZE(query_pfx) - 1 + table_len + ARRAY_SIZE(query_sfx);
     if (len > ARRAY_SIZE(buf))
     {
-        query = msi_alloc( len * sizeof(WCHAR) );
+        query = malloc( len * sizeof(WCHAR) );
         if (!query)
             return ERROR_OUTOFMEMORY;
     }
@@ -2636,7 +2636,7 @@ static UINT TransformView_drop_table( MSITABLEVIEW *tv, UINT row )
 
     r = MSI_DatabaseOpenViewW( tv->db, query, &q );
     if (query != buf)
-        msi_free( query );
+        free( query );
     if (r != ERROR_SUCCESS)
         return r;
 
@@ -2680,11 +2680,11 @@ static UINT TransformView_delete_row( MSIVIEW *view, UINT row )
     len = ARRAY_SIZE(query_pfx) + name_len + ARRAY_SIZE(query_column) + key_len + ARRAY_SIZE(query_sfx) - 2;
     if (len > ARRAY_SIZE(buf))
     {
-        query = msi_alloc( len * sizeof(WCHAR) );
+        query = malloc( len * sizeof(WCHAR) );
         if (!query)
         {
-            msi_free( tv );
-            msi_free( key );
+            free( tv );
+            free( key );
             return ERROR_OUTOFMEMORY;
         }
     }
@@ -2698,11 +2698,11 @@ static UINT TransformView_delete_row( MSIVIEW *view, UINT row )
     memcpy( query + len, key, key_len * sizeof(WCHAR) );
     len += key_len;
     memcpy( query + len, query_sfx, ARRAY_SIZE(query_sfx) * sizeof(WCHAR) );
-    msi_free( key );
+    free( key );
 
     r = MSI_DatabaseOpenViewW( tv->db, query, &q );
     if (query != buf)
-        msi_free( query );
+        free( query );
     if (r != ERROR_SUCCESS)
         return r;
 
@@ -2736,7 +2736,7 @@ static UINT TransformView_delete( MSIVIEW *view )
 {
     MSITABLEVIEW *tv = (MSITABLEVIEW*)view;
     if (!tv->table || tv->columns != tv->table->colinfo)
-        msi_free( tv->columns );
+        free( tv->columns );
     return TABLE_delete( view );
 }
 
@@ -2782,7 +2782,7 @@ UINT TransformView_Create( MSIDATABASE *db, string_table *st, LPCWSTR name, MSIV
     {
         /* table does not exist */
         size = FIELD_OFFSET( MSITABLEVIEW, name[name_len + 1] );
-        tv = msi_alloc_zero( size );
+        tv = calloc( 1, size );
         if (!tv)
             return ERROR_OUTOFMEMORY;
 
@@ -2804,10 +2804,10 @@ UINT TransformView_Create( MSIDATABASE *db, string_table *st, LPCWSTR name, MSIV
     len = ARRAY_SIZE(query_pfx) + name_len + ARRAY_SIZE(query_sfx) - 1;
     if (len > ARRAY_SIZE(buf))
     {
-        query = msi_alloc( len * sizeof(WCHAR) );
+        query = malloc( len * sizeof(WCHAR) );
         if (!query)
         {
-            msi_free( tv );
+            free( tv );
             return ERROR_OUTOFMEMORY;
         }
     }
@@ -2819,17 +2819,17 @@ UINT TransformView_Create( MSIDATABASE *db, string_table *st, LPCWSTR name, MSIV
 
     r = MSI_DatabaseOpenViewW( tv->db, query, &q );
     if (query != buf)
-        msi_free( query );
+        free( query );
     if (r != ERROR_SUCCESS)
     {
-        msi_free( tv );
+        free( tv );
         return r;
     }
 
     r = MSI_ViewExecute( q, NULL );
     if (r != ERROR_SUCCESS)
     {
-        msi_free( tv );
+        free( tv );
         return r;
     }
 
@@ -2838,7 +2838,7 @@ UINT TransformView_Create( MSIDATABASE *db, string_table *st, LPCWSTR name, MSIV
     {
         MSI_ViewClose( q );
         msiobj_release( &q->hdr );
-        msi_free( tv );
+        free( tv );
         return r;
     }
     if (!add_col)
@@ -2848,12 +2848,12 @@ UINT TransformView_Create( MSIDATABASE *db, string_table *st, LPCWSTR name, MSIV
         return ERROR_SUCCESS;
     }
 
-    colinfo = msi_alloc_zero( (add_col + tv->num_cols) * sizeof(*colinfo) );
+    colinfo = calloc( add_col + tv->num_cols, sizeof(*colinfo) );
     if (!colinfo)
     {
         MSI_ViewClose( q );
         msiobj_release( &q->hdr );
-        msi_free( tv );
+        free( tv );
         return r;
     }
 
@@ -2959,19 +2959,19 @@ static UINT msi_record_encoded_stream_name( const MSITABLEVIEW *tv, MSIRECORD *r
         return r;
     len++;
 
-    name = msi_alloc( len * sizeof(WCHAR) );
+    name = malloc( len * sizeof(WCHAR) );
     if (!name)
         return ERROR_OUTOFMEMORY;
 
     r = msi_record_stream_name( tv, rec, name, &len );
     if (r != ERROR_SUCCESS)
     {
-        msi_free( name );
+        free( name );
         return r;
     }
 
     *pstname = encode_streamname( FALSE, name );
-    msi_free( name );
+    free( name );
     return ERROR_SUCCESS;
 }
 
@@ -3017,13 +3017,13 @@ static MSIRECORD *msi_get_transform_record( const MSITABLEVIEW *tv, const string
             if ( r != ERROR_SUCCESS )
             {
                 msiobj_release( &rec->hdr );
-                msi_free( encname );
+                free( encname );
                 return NULL;
             }
 
             MSI_RecordSetStream( rec, i+1, stm );
             TRACE(" field %d [%s]\n", i+1, debugstr_w(encname));
-            msi_free( encname );
+            free( encname );
         }
         else if( columns[i].type & MSITYPE_STRING )
         {
@@ -3078,7 +3078,7 @@ static UINT* msi_record_to_row( const MSITABLEVIEW *tv, MSIRECORD *rec )
 {
     UINT i, r, *data;
 
-    data = msi_alloc( tv->num_cols *sizeof (UINT) );
+    data = malloc( tv->num_cols * sizeof (UINT) );
     for( i=0; i<tv->num_cols; i++ )
     {
         data[i] = 0;
@@ -3100,7 +3100,7 @@ static UINT* msi_record_to_row( const MSITABLEVIEW *tv, MSIRECORD *rec )
                    these keys can't match any record, so fail now. */
                 if (r != ERROR_SUCCESS)
                 {
-                    msi_free( data );
+                    free( data );
                     return NULL;
                 }
             }
@@ -3110,7 +3110,7 @@ static UINT* msi_record_to_row( const MSITABLEVIEW *tv, MSIRECORD *rec )
         {
             if (int_to_table_storage( tv, i + 1, MSI_RecordGetInteger( rec, i + 1 ), &data[i] ))
             {
-                msi_free( data );
+                free( data );
                 return NULL;
             }
         }
@@ -3163,7 +3163,7 @@ static UINT msi_table_find_row( MSITABLEVIEW *tv, MSIRECORD *rec, UINT *row, UIN
             break;
         }
     }
-    msi_free( data );
+    free( data );
     return r;
 }
 
@@ -3356,7 +3356,7 @@ static UINT msi_table_load_transform( MSIDATABASE *db, IStorage *stg,
 
 err:
     /* no need to free the table, it's associated with the database */
-    msi_free( rawdata );
+    free( rawdata );
     if( tv )
         tv->view.ops->delete( &tv->view );
 
@@ -3413,7 +3413,7 @@ UINT msi_table_apply_transform( MSIDATABASE *db, IStorage *stg, int err_cond )
              !wcscmp( name+1, L"_StringData" ) )
             continue;
 
-        transform = msi_alloc_zero( sizeof(TRANSFORMDATA) );
+        transform = calloc( 1, sizeof(TRANSFORMDATA) );
         if ( !transform )
             break;
 
@@ -3502,8 +3502,8 @@ UINT msi_table_apply_transform( MSIDATABASE *db, IStorage *stg, int err_cond )
         }
 
         list_remove( &transform->entry );
-        msi_free( transform->name );
-        msi_free( transform );
+        free( transform->name );
+        free( transform );
     }
 
     if ( ret == ERROR_SUCCESS )
diff --git a/dlls/msi/update.c b/dlls/msi/update.c
index 4aa03443f0ca..3fc5b2583bb0 100644
--- a/dlls/msi/update.c
+++ b/dlls/msi/update.c
@@ -190,7 +190,7 @@ static UINT UPDATE_delete( struct tagMSIVIEW *view )
     if( wv )
         wv->ops->delete( wv );
     msiobj_release( &uv->db->hdr );
-    msi_free( uv );
+    free( uv );
 
     return ERROR_SUCCESS;
 }
@@ -242,7 +242,7 @@ UINT UPDATE_CreateView( MSIDATABASE *db, MSIVIEW **view, LPWSTR table,
         return r;
     }
 
-    uv = msi_alloc_zero( sizeof *uv );
+    uv = calloc( 1, sizeof *uv );
     if( !uv )
     {
         wv->ops->delete( wv );
diff --git a/dlls/msi/upgrade.c b/dlls/msi/upgrade.c
index c9744e518598..a3b90a21b763 100644
--- a/dlls/msi/upgrade.c
+++ b/dlls/msi/upgrade.c
@@ -87,13 +87,13 @@ static void append_productcode( MSIPACKAGE *package, const WCHAR *action_prop, c
     if (find_product( prop, product ))
     {
         TRACE( "related product property %s already contains %s\n", debugstr_w(action_prop), debugstr_w(product) );
-        msi_free( prop );
+        free( prop );
         return;
     }
 
     if (prop) len += lstrlenW( prop );
     len += lstrlenW( product ) + 2;
-    if (!(newprop = msi_alloc( len * sizeof(WCHAR) ))) return;
+    if (!(newprop = malloc( len * sizeof(WCHAR) ))) return;
     if (prop)
     {
         lstrcpyW( newprop, prop );
@@ -108,8 +108,8 @@ static void append_productcode( MSIPACKAGE *package, const WCHAR *action_prop, c
 
     TRACE( "related product property %s now %s\n", debugstr_w(action_prop), debugstr_w(newprop) );
 
-    msi_free( prop );
-    msi_free( newprop );
+    free( prop );
+    free( newprop );
 }
 
 static UINT ITERATE_FindRelatedProducts(MSIRECORD *rec, LPVOID param)
diff --git a/dlls/msi/where.c b/dlls/msi/where.c
index 684d9d5fb983..05be5338ac67 100644
--- a/dlls/msi/where.c
+++ b/dlls/msi/where.c
@@ -90,9 +90,9 @@ static void free_reorder(MSIWHEREVIEW *wv)
         return;
 
     for (i = 0; i < wv->row_count; i++)
-        msi_free(wv->reorder[i]);
+        free(wv->reorder[i]);
 
-    msi_free( wv->reorder );
+    free(wv->reorder);
     wv->reorder = NULL;
     wv->reorder_size = 0;
     wv->row_count = 0;
@@ -100,7 +100,7 @@ static void free_reorder(MSIWHEREVIEW *wv)
 
 static UINT init_reorder(MSIWHEREVIEW *wv)
 {
-    MSIROWENTRY **new = msi_alloc_zero(sizeof(MSIROWENTRY *) * INITIAL_REORDER_SIZE);
+    MSIROWENTRY **new = calloc(INITIAL_REORDER_SIZE, sizeof(MSIROWENTRY *));
     if (!new)
         return ERROR_OUTOFMEMORY;
 
@@ -131,7 +131,7 @@ static UINT add_row(MSIWHEREVIEW *wv, UINT vals[])
         MSIROWENTRY **new_reorder;
         UINT newsize = wv->reorder_size * 2;
 
-        new_reorder = msi_realloc(wv->reorder, newsize * sizeof(*new_reorder));
+        new_reorder = realloc(wv->reorder, newsize * sizeof(*new_reorder));
         if (!new_reorder)
             return ERROR_OUTOFMEMORY;
         memset(new_reorder + wv->reorder_size, 0, (newsize - wv->reorder_size) * sizeof(*new_reorder));
@@ -140,7 +140,7 @@ static UINT add_row(MSIWHEREVIEW *wv, UINT vals[])
         wv->reorder_size = newsize;
     }
 
-    new = msi_alloc(FIELD_OFFSET( MSIROWENTRY, values[wv->table_count] ));
+    new = malloc(offsetof(MSIROWENTRY, values[wv->table_count]));
 
     if (!new)
         return ERROR_OUTOFMEMORY;
@@ -792,7 +792,7 @@ static JOINTABLE **ordertables( MSIWHEREVIEW *wv )
     JOINTABLE *table;
     JOINTABLE **tables;
 
-    tables = msi_alloc_zero( (wv->table_count + 1) * sizeof(*tables) );
+    tables = calloc(wv->table_count + 1, sizeof(*tables));
 
     if (wv->cond)
     {
@@ -848,7 +848,7 @@ static UINT WHERE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
 
     ordered_tables = ordertables( wv );
 
-    rows = msi_alloc( wv->table_count * sizeof(*rows) );
+    rows = malloc(wv->table_count * sizeof(*rows));
     for (i = 0; i < wv->table_count; i++)
         rows[i] = INVALID_ROW_INDEX;
 
@@ -862,8 +862,8 @@ static UINT WHERE_execute( struct tagMSIVIEW *view, MSIRECORD *record )
     if (wv->order_info)
         r = wv->order_info->error;
 
-    msi_free( rows );
-    msi_free( ordered_tables );
+    free(rows);
+    free(ordered_tables);
     return r;
 }
 
@@ -1046,7 +1046,7 @@ static UINT WHERE_delete( struct tagMSIVIEW *view )
         table->view->ops->delete(table->view);
         table->view = NULL;
         next = table->next;
-        msi_free(table);
+        free(table);
         table = next;
     }
     wv->tables = NULL;
@@ -1054,11 +1054,11 @@ static UINT WHERE_delete( struct tagMSIVIEW *view )
 
     free_reorder(wv);
 
-    msi_free(wv->order_info);
+    free(wv->order_info);
     wv->order_info = NULL;
 
     msiobj_release( &wv->db->hdr );
-    msi_free( wv );
+    free(wv);
 
     return ERROR_SUCCESS;
 }
@@ -1086,7 +1086,7 @@ static UINT WHERE_sort(struct tagMSIVIEW *view, column_info *columns)
     if (count == 0)
         return ERROR_SUCCESS;
 
-    orderinfo = msi_alloc(FIELD_OFFSET(MSIORDERINFO, columns[count]));
+    orderinfo = malloc(offsetof(MSIORDERINFO, columns[count]));
     if (!orderinfo)
         return ERROR_OUTOFMEMORY;
 
@@ -1108,7 +1108,7 @@ static UINT WHERE_sort(struct tagMSIVIEW *view, column_info *columns)
 
     return ERROR_SUCCESS;
 error:
-    msi_free(orderinfo);
+    free(orderinfo);
     return r;
 }
 
@@ -1233,7 +1233,7 @@ UINT WHERE_CreateView( MSIDATABASE *db, MSIVIEW **view, LPWSTR tables,
 
     TRACE("(%s)\n", debugstr_w(tables) );
 
-    wv = msi_alloc_zero( sizeof *wv );
+    wv = calloc(1, sizeof *wv);
     if( !wv )
         return ERROR_FUNCTION_FAILED;
 
@@ -1250,7 +1250,7 @@ UINT WHERE_CreateView( MSIDATABASE *db, MSIVIEW **view, LPWSTR tables,
         if ((ptr = wcschr(tables, ' ')))
             *ptr = '\0';
 
-        table = msi_alloc(sizeof(JOINTABLE));
+        table = malloc(sizeof(JOINTABLE));
         if (!table)
         {
             r = ERROR_OUTOFMEMORY;
@@ -1261,7 +1261,7 @@ UINT WHERE_CreateView( MSIDATABASE *db, MSIVIEW **view, LPWSTR tables,
         if (r != ERROR_SUCCESS)
         {
             WARN("can't create table: %s\n", debugstr_w(tables));
-            msi_free(table);
+            free(table);
             r = ERROR_BAD_QUERY_SYNTAX;
             goto end;
         }
@@ -1272,7 +1272,7 @@ UINT WHERE_CreateView( MSIDATABASE *db, MSIVIEW **view, LPWSTR tables,
         {
             ERR("can't get table dimensions\n");
             table->view->ops->delete(table->view);
-            msi_free(table);
+            free(table);
             goto end;
         }
 
From 904bedb3e96bc68101652e151db102532399abe8 Mon Sep 17 00:00:00 2001
From: "Philip K. Gisslow" <ripxorip@gmail.com>
Date: Thu, 5 Jan 2023 08:08:05 +0100
Subject: [PATCH] msi: Initialize all members of WINTRUST_DATA.

The pSignatureSettings field was not unitilized so it got a random value from
the stack causing a later crash when it was dereferenced in Wintrust
(SoftPubloadSignature).
---
 dlls/msi/msi.c | 7 ++-----
 1 file changed, 2 insertions(+), 5 deletions(-)

diff --git a/dlls/msi/msi.c b/dlls/msi/msi.c
index db04babb899d..3ebfd94a9f0b 100644
--- a/dlls/msi/msi.c
+++ b/dlls/msi/msi.c
@@ -2544,18 +2544,15 @@ HRESULT WINAPI MsiGetFileSignatureInformationW( const WCHAR *path, DWORD flags,
     info.hFile          = NULL;
     info.pgKnownSubject = NULL;
 
+    memset( &data, 0, sizeof(data) );
     data.cbStruct            = sizeof(data);
-    data.pPolicyCallbackData = NULL;
-    data.pSIPClientData      = NULL;
     data.dwUIChoice          = WTD_UI_NONE;
     data.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
     data.dwUnionChoice       = WTD_CHOICE_FILE;
     data.u.pFile             = &info;
     data.dwStateAction       = WTD_STATEACTION_VERIFY;
-    data.hWVTStateData       = NULL;
-    data.pwszURLReference    = NULL;
-    data.dwProvFlags         = 0;
     data.dwUIContext         = WTD_UICONTEXT_INSTALL;
+
     hr = WinVerifyTrustEx( INVALID_HANDLE_VALUE, &generic_verify_v2, &data );
     *cert = NULL;
     if (FAILED(hr)) goto done;

