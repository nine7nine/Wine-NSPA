From 96ecee3211d606eff2585073eb5854aae4142911 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Tue, 10 May 2022 17:11:08 +0200
Subject: [PATCH 1/5] winedbg: Introduce struct data_model to describe the
 various models for base types.

Detect data model to be used with current debuggee
PE & ELF 32 bit => ILP32
PE 64 bit       => LP64
ELF 64 bit      => LLP64

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 programs/winedbg/debugger.h |   7 ++
 programs/winedbg/types.c    | 176 +++++++++++++++++++++++++++++-------
 2 files changed, 150 insertions(+), 33 deletions(-)

diff --git a/programs/winedbg/debugger.h b/programs/winedbg/debugger.h
index 293de4c0aa5..de6c8b3e438 100644
--- a/programs/winedbg/debugger.h
+++ b/programs/winedbg/debugger.h
@@ -544,6 +544,13 @@ static inline void* dbg_heap_realloc(void* buffer, size_t size)
         HeapAlloc(GetProcessHeap(), 0, size);
 }
 
+struct data_model
+{
+    unsigned            base_type;
+    unsigned            size;
+    const WCHAR*        name;
+};
+
 extern struct dbg_internal_var          dbg_internal_vars[];
 
 #define  DBG_IVARNAME(_var)	dbg_internal_var_##_var
diff --git a/programs/winedbg/types.c b/programs/winedbg/types.c
index 50d1f1b8353..f4ee5a011d5 100644
--- a/programs/winedbg/types.c
+++ b/programs/winedbg/types.c
@@ -714,47 +714,157 @@ BOOL types_print_type(const struct dbg_type* type, BOOL details)
     return TRUE;
 }
 
+static const struct data_model ilp32_data_model[] = {
+    {btVoid,     0, L"void"},
+    {btChar,     1, L"char"},
+    {btWChar,    2, L"wchar_t"},
+    {btInt,      1, L"signed char"},
+    {btInt,      2, L"short int"},
+    {btInt,      4, L"int"},
+    {btInt,      8, L"__int64"},
+    {btUInt,     1, L"unsigned char"},
+    {btUInt,     2, L"unsigned short int"},
+    {btUInt,     4, L"unsigned int"},
+    {btUInt,     8, L"unsigned __int64"},
+    {btFloat,    4, L"float"},
+    {btFloat,    8, L"double"},
+    {btFloat,   10, L"long double"},
+    {btBool,     1, L"bool"},
+    {btLong,     4, L"long"},
+    {btLong,     8, L"long long"},
+    {btULong,    4, L"unsigned long"},
+    {btULong,    8, L"unsigned long long"},
+    {btHresult,  4, L"char32_t"},
+    {btChar16,   2, L"char16_t"},
+    {btChar32,   4, L"char32_t"},
+    {btChar8,    1, L"char8_t"},
+    {0,          0, NULL}
+};
+
+static const struct data_model llp64_data_model[] = {
+    {btVoid,     0, L"void"},
+    {btChar,     1, L"char"},
+    {btWChar,    2, L"wchar_t"},
+    {btInt,      1, L"signed char"},
+    {btInt,      2, L"short int"},
+    {btInt,      4, L"int"},
+    {btInt,      8, L"__int64"},
+    {btInt,     16, L"__int128"},
+    {btUInt,     1, L"unsigned char"},
+    {btUInt,     2, L"unsigned short int"},
+    {btUInt,     4, L"unsigned int"},
+    {btUInt,     8, L"unsigned __int64"},
+    {btUInt,    16, L"unsigned __int128"},
+    {btFloat,    4, L"float"},
+    {btFloat,    8, L"double"},
+    {btFloat,   10, L"long double"},
+    {btBool,     1, L"bool"},
+    {btLong,     4, L"long"},
+    {btLong,     8, L"long long"},
+    {btULong,    4, L"unsigned long"},
+    {btULong,    8, L"unsigned long long"},
+    {btHresult,  4, L"char32_t"},
+    {btChar16,   2, L"char16_t"},
+    {btChar32,   4, L"char32_t"},
+    {btChar8,    1, L"char8_t"},
+    {0,          0, NULL}
+};
+
+static const struct data_model lp64_data_model[] = {
+    {btVoid,     0, L"void"},
+    {btChar,     1, L"char"},
+    {btWChar,    2, L"wchar_t"},
+    {btInt,      1, L"signed char"},
+    {btInt,      2, L"short int"},
+    {btInt,      4, L"int"},
+    {btInt,      8, L"__int64"},
+    {btInt,     16, L"__int128"},
+    {btUInt,     1, L"unsigned char"},
+    {btUInt,     2, L"unsigned short int"},
+    {btUInt,     4, L"unsigned int"},
+    {btUInt,     8, L"unsigned __int64"},
+    {btUInt,    16, L"unsigned __int128"},
+    {btFloat,    4, L"float"},
+    {btFloat,    8, L"double"},
+    {btFloat,   10, L"long double"},
+    {btBool,     1, L"bool"},
+    {btLong,     4, L"int"}, /* to print at least for such a regular Windows' type */
+    {btLong,     8, L"long"}, /* we can't discriminate 'long' from 'long long' */
+    {btULong,    4, L"unsigned int"}, /* to print at least for such a regular Windows' type */
+    {btULong,    8, L"unsigned long"}, /* we can't discriminate 'unsigned long' from 'unsigned long long' */
+    {btHresult,  4, L"char32_t"},
+    {btChar16,   2, L"char16_t"},
+    {btChar32,   4, L"char32_t"},
+    {btChar8,    1, L"char8_t"},
+    {0,          0, NULL}
+};
+
+static const struct data_model* get_data_model(DWORD modaddr)
+{
+    const struct data_model *model;
+
+    if (ADDRSIZE == 4) model = ilp32_data_model;
+    else
+    {
+        IMAGEHLP_MODULEW64 mi;
+        DWORD opt = SymSetExtendedOption(SYMOPT_EX_WINE_NATIVE_MODULES, TRUE);
+
+        mi.SizeOfStruct = sizeof(mi);
+        if (SymGetModuleInfoW64(dbg_curr_process->handle, modaddr, &mi) &&
+            (wcsstr(mi.ModuleName, L".so") || wcsstr(mi.ModuleName, L"<")))
+            model = lp64_data_model;
+        else
+            model = llp64_data_model;
+        SymSetExtendedOption(SYMOPT_EX_WINE_NATIVE_MODULES, opt);
+    }
+    return model;
+}
+
 /* helper to typecast pInfo to its expected type (_t) */
 #define X(_t) (*((_t*)pInfo))
 
-BOOL types_get_info(const struct dbg_type* type, IMAGEHLP_SYMBOL_TYPE_INFO ti, void* pInfo)
+static BOOL lookup_base_type_in_data_model(const struct dbg_type* type, IMAGEHLP_SYMBOL_TYPE_INFO ti, void* pInfo)
 {
-    if (type->id == dbg_itype_none) return FALSE;
-    if (type->module != 0)
+    DWORD tag, bt;
+    DWORD64 len;
+    const WCHAR* name = NULL;
+    WCHAR tmp[64];
+    const struct data_model* model;
+
+    if (ti != TI_GET_SYMNAME ||
+        !SymGetTypeInfo(dbg_curr_process->handle, type->module, type->id, TI_GET_SYMTAG, &tag) ||
+        tag != SymTagBaseType ||
+        !SymGetTypeInfo(dbg_curr_process->handle, type->module, type->id, TI_GET_BASETYPE, &bt) ||
+        !SymGetTypeInfo(dbg_curr_process->handle, type->module, type->id, TI_GET_LENGTH, &len) ||
+        len != (DWORD)len) return FALSE;
+
+    model = get_data_model(type->module);
+    for (; model->name; model++)
     {
-        DWORD ret, tag, bt;
-        ret = SymGetTypeInfo(dbg_curr_process->handle, type->module, type->id, ti, pInfo);
-        if (!ret &&
-            ti == TI_GET_SYMNAME &&
-            SymGetTypeInfo(dbg_curr_process->handle, type->module, type->id, TI_GET_SYMTAG, &tag) &&
-            tag == SymTagBaseType &&
-            SymGetTypeInfo(dbg_curr_process->handle, type->module, type->id, TI_GET_BASETYPE, &bt))
+        if (bt == model->base_type && model->size == len)
         {
-            const WCHAR* name = NULL;
-
-            switch (bt)
-            {
-            case btVoid:        name = L"void"; break;
-            case btChar:        name = L"char"; break;
-            case btWChar:       name = L"WCHAR"; break;
-            case btInt:         name = L"int"; break;
-            case btUInt:        name = L"unsigned int"; break;
-            case btFloat:       name = L"float"; break;
-            case btBool:        name = L"bool"; break;
-            case btLong:        name = L"long int"; break;
-            case btULong:       name = L"unsigned long int"; break;
-            case btComplex:     name = L"complex"; break;
-            default:            WINE_FIXME("Unsupported basic type %lu\n", bt); return FALSE;
-            }
-            X(WCHAR*) = HeapAlloc(GetProcessHeap(), 0, (lstrlenW(name) + 1) * sizeof(WCHAR));
-            if (X(WCHAR*))
-            {
-                lstrcpyW(X(WCHAR*), name);
-                ret = TRUE;
-            }
+            name = model->name;
+            break;
         }
-        return ret;
     }
+    if (!name) /* synthetize name */
+    {
+        WINE_FIXME("Unsupported basic type %lu %I64u\n", bt, len);
+        swprintf(tmp, ARRAY_SIZE(tmp), L"bt[%lu,%u]", bt, len);
+        name = tmp;
+    }
+    X(WCHAR*) = HeapAlloc(GetProcessHeap(), 0, (lstrlenW(name) + 1) * sizeof(WCHAR));
+    if (X(WCHAR*))
+        lstrcpyW(X(WCHAR*), name);
+    return TRUE;
+}
+
+BOOL types_get_info(const struct dbg_type* type, IMAGEHLP_SYMBOL_TYPE_INFO ti, void* pInfo)
+{
+    if (type->id == dbg_itype_none) return FALSE;
+    if (type->module != 0)
+        return lookup_base_type_in_data_model(type, ti, pInfo) ||
+            SymGetTypeInfo(dbg_curr_process->handle, type->module, type->id, ti, pInfo);
 
     assert(type->id >= dbg_itype_first);
 
-- 
GitLab


From 6eb18ae6920da897af7e22f43347b3044f172e3c Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Tue, 10 May 2022 17:11:08 +0200
Subject: [PATCH 2/5] winedbg: Add 'set' command to change data model.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 programs/winedbg/debugger.h |  4 ++++
 programs/winedbg/types.c    | 10 ++++++----
 programs/winedbg/winedbg.c  | 24 ++++++++++++++++++++++++
 3 files changed, 34 insertions(+), 4 deletions(-)

diff --git a/programs/winedbg/debugger.h b/programs/winedbg/debugger.h
index de6c8b3e438..ac13a28e3ca 100644
--- a/programs/winedbg/debugger.h
+++ b/programs/winedbg/debugger.h
@@ -265,6 +265,7 @@ struct dbg_process
     char                        source_current_file[MAX_PATH];
     int                         source_start_line;
     int                         source_end_line;
+    const struct data_model*    data_model;
 };
 
 /* describes the way the debugger interacts with a given process */
@@ -550,6 +551,9 @@ struct data_model
     unsigned            size;
     const WCHAR*        name;
 };
+extern const struct data_model ilp32_data_model[];
+extern const struct data_model lp64_data_model[];
+extern const struct data_model llp64_data_model[];
 
 extern struct dbg_internal_var          dbg_internal_vars[];
 
diff --git a/programs/winedbg/types.c b/programs/winedbg/types.c
index f4ee5a011d5..899e7f472b2 100644
--- a/programs/winedbg/types.c
+++ b/programs/winedbg/types.c
@@ -714,7 +714,7 @@ BOOL types_print_type(const struct dbg_type* type, BOOL details)
     return TRUE;
 }
 
-static const struct data_model ilp32_data_model[] = {
+const struct data_model ilp32_data_model[] = {
     {btVoid,     0, L"void"},
     {btChar,     1, L"char"},
     {btWChar,    2, L"wchar_t"},
@@ -741,7 +741,7 @@ static const struct data_model ilp32_data_model[] = {
     {0,          0, NULL}
 };
 
-static const struct data_model llp64_data_model[] = {
+const struct data_model llp64_data_model[] = {
     {btVoid,     0, L"void"},
     {btChar,     1, L"char"},
     {btWChar,    2, L"wchar_t"},
@@ -770,7 +770,7 @@ static const struct data_model llp64_data_model[] = {
     {0,          0, NULL}
 };
 
-static const struct data_model lp64_data_model[] = {
+const struct data_model lp64_data_model[] = {
     {btVoid,     0, L"void"},
     {btChar,     1, L"char"},
     {btWChar,    2, L"wchar_t"},
@@ -803,7 +803,9 @@ static const struct data_model* get_data_model(DWORD modaddr)
 {
     const struct data_model *model;
 
-    if (ADDRSIZE == 4) model = ilp32_data_model;
+    if (dbg_curr_process->data_model)
+        model = dbg_curr_process->data_model;
+    else if (ADDRSIZE == 4) model = ilp32_data_model;
     else
     {
         IMAGEHLP_MODULEW64 mi;
diff --git a/programs/winedbg/winedbg.c b/programs/winedbg/winedbg.c
index d11b68ec432..8a5c9bc69ed 100644
--- a/programs/winedbg/winedbg.c
+++ b/programs/winedbg/winedbg.c
@@ -284,6 +284,7 @@ struct dbg_process*	dbg_add_process(const struct be_process_io* pio, DWORD pid,
     p->source_current_file[0] = '\0';
     p->source_start_line = -1;
     p->source_end_line = -1;
+    p->data_model = NULL;
 
     list_add_head(&dbg_process_list, &p->entry);
 
@@ -467,6 +468,29 @@ void dbg_set_option(const char* option, const char* val)
             return;
         }
     }
+    else if (!strcasecmp(option, "data_model"))
+    {
+        if (!dbg_curr_process)
+        {
+            dbg_printf("Not attached to a process\n");
+            return;
+        }
+        if (!val)
+        {
+            const char* model = "";
+            if      (dbg_curr_process->data_model == NULL)             model = "auto";
+            else if (dbg_curr_process->data_model == ilp32_data_model) model = "ilp32";
+            else if (dbg_curr_process->data_model == llp64_data_model) model = "llp64";
+            else if (dbg_curr_process->data_model == lp64_data_model)  model = "lp64";
+            dbg_printf("Option: data_model %s\n", model);
+        }
+        else if (!strcasecmp(val, "auto"))  dbg_curr_process->data_model = NULL;
+        else if (!strcasecmp(val, "ilp32")) dbg_curr_process->data_model = ilp32_data_model;
+        else if (!strcasecmp(val, "llp64")) dbg_curr_process->data_model = llp64_data_model;
+        else if (!strcasecmp(val, "lp64"))  dbg_curr_process->data_model = lp64_data_model;
+        else
+            dbg_printf("Unknown data model %s\n", val);
+    }
     else dbg_printf("Unknown option '%s'\n", option);
 }
 
-- 
GitLab


From 14462bbeab6c916f2aa01a615b1eb4d8005277e5 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Tue, 10 May 2022 17:11:08 +0200
Subject: [PATCH 3/5] dbghelp: Let symt_basic be trans-module and nameless.

Rationale:
- native doesn't report names for SymTagBaseType objects
  => so remove typename for sym_basic
- since symt_basic becomes pretty simple, it's possible to share the object
  across all modules loaded in dbghelp (simplicity, memory usage reduction)
- removed dwarf basic types cache in dwarf.c as we now have a generic one

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dbghelp/dbghelp_private.h |  4 +--
 dlls/dbghelp/dwarf.c           | 46 +++++++++++-----------------
 dlls/dbghelp/msc.c             | 56 +++++++++++++++++-----------------
 dlls/dbghelp/stabs.c           | 48 ++++++++++++++---------------
 dlls/dbghelp/type.c            | 37 ++++++++++------------
 5 files changed, 87 insertions(+), 104 deletions(-)

diff --git a/dlls/dbghelp/dbghelp_private.h b/dlls/dbghelp/dbghelp_private.h
index 507724414a5..24ac003df71 100644
--- a/dlls/dbghelp/dbghelp_private.h
+++ b/dlls/dbghelp/dbghelp_private.h
@@ -336,7 +336,6 @@ struct symt_array
 struct symt_basic
 {
     struct symt                 symt;
-    struct hash_table_elt       hash_elt;
     enum BasicType              bt;
     ULONG_PTR                   size;
 };
@@ -901,8 +900,7 @@ extern void         symt_init_basic(struct module* module) DECLSPEC_HIDDEN;
 extern BOOL         symt_get_info(struct module* module, const struct symt* type,
                                   IMAGEHLP_SYMBOL_TYPE_INFO req, void* pInfo) DECLSPEC_HIDDEN;
 extern struct symt_basic*
-                    symt_new_basic(struct module* module, enum BasicType, 
-                                   const char* typename, unsigned size) DECLSPEC_HIDDEN;
+                    symt_get_basic(enum BasicType, unsigned size) DECLSPEC_HIDDEN;
 extern struct symt_udt*
                     symt_new_udt(struct module* module, const char* typename,
                                  unsigned size, enum UdtKind kind) DECLSPEC_HIDDEN;
diff --git a/dlls/dbghelp/dwarf.c b/dlls/dbghelp/dwarf.c
index b81f83ac90b..19c0da933d3 100644
--- a/dlls/dbghelp/dwarf.c
+++ b/dlls/dbghelp/dwarf.c
@@ -162,11 +162,6 @@ typedef struct dwarf2_traverse_context_s
     const unsigned char*        end_data;
 } dwarf2_traverse_context_t;
 
-/* symt_cache indexes */
-#define sc_void         0
-#define sc_unknown      1
-#define sc_num          2
-
 typedef struct dwarf2_cuhead_s
 {
     unsigned char               word_size; /* size of a word on target machine */
@@ -180,7 +175,6 @@ typedef struct dwarf2_parse_module_context_s
     const dwarf2_section_t*     sections;
     struct module*              module;
     const struct elf_thunk_area*thunks;
-    struct symt*                symt_cache[sc_num]; /* void, unknown */
     struct vector               unit_contexts;
     struct dwarf2_dwz_alternate_s* dwz;
     DWORD                       cu_versions;
@@ -1138,14 +1132,14 @@ static struct symt* dwarf2_lookup_type(const dwarf2_debug_info_t* di)
 
     if (!dwarf2_find_attribute(di, DW_AT_type, &attr))
         /* this is only valid if current language of CU is C or C++ */
-        return di->unit_ctx->module_ctx->symt_cache[sc_void];
+        return &symt_get_basic(btVoid, 0)->symt;
     if (!(type = dwarf2_jump_to_debug_info(&attr)))
-        return di->unit_ctx->module_ctx->symt_cache[sc_unknown];
+        return &symt_get_basic(btNoType, 0)->symt;
 
     if (type == di)
     {
         FIXME("Reference to itself\n");
-        return di->unit_ctx->module_ctx->symt_cache[sc_unknown];
+        return &symt_get_basic(btNoType, 0)->symt;
     }
     if (!type->symt)
     {
@@ -1154,7 +1148,7 @@ static struct symt* dwarf2_lookup_type(const dwarf2_debug_info_t* di)
         if (!type->symt)
         {
             FIXME("Unable to load forward reference for tag %Ix\n", type->abbrev->tag);
-            return di->unit_ctx->module_ctx->symt_cache[sc_unknown];
+            return &symt_get_basic(btNoType, 0)->symt;
         }
     }
     return type->symt;
@@ -1484,7 +1478,7 @@ static struct symt* dwarf2_parse_base_type(dwarf2_debug_info_t* di)
     case DW_ATE_unsigned_char:  bt = btChar; break;
     default:                    bt = btNoType; break;
     }
-    di->symt = &symt_new_basic(di->unit_ctx->module_ctx->module, bt, name.u.string, size.u.uvalue)->symt;
+    di->symt = &symt_get_basic(bt, size.u.uvalue)->symt;
 
     if (dwarf2_get_di_children(di)) FIXME("Unsupported children\n");
     return di->symt;
@@ -1566,14 +1560,14 @@ static struct symt* dwarf2_parse_array_type(dwarf2_debug_info_t* di)
     {
         /* fake an array with unknown size */
         /* FIXME: int4 even on 64bit machines??? */
-        idx_type = &symt_new_basic(di->unit_ctx->module_ctx->module, btInt, "int", 4)->symt;
+        idx_type = &symt_get_basic(btInt, 4)->symt;
         min.u.uvalue = 0;
         cnt.u.uvalue = 0;
     }
     else for (i = 0; i < vector_length(children); i++)
     {
         child = *(dwarf2_debug_info_t**)vector_at(children, i);
-        if (child->symt == di->unit_ctx->module_ctx->symt_cache[sc_unknown]) continue;
+        if (child->symt == &symt_get_basic(btNoType, 0)->symt) continue;
         switch (child->abbrev->tag)
         {
         case DW_TAG_subrange_type:
@@ -1665,19 +1659,18 @@ static struct symt* dwarf2_parse_restrict_type(dwarf2_debug_info_t* di)
 static struct symt* dwarf2_parse_unspecified_type(dwarf2_debug_info_t* di)
 {
     struct attribute name;
-    struct attribute size;
-    struct symt_basic *basic;
+    struct symt* basic;
 
     TRACE("%s\n", dwarf2_debug_di(di));
 
     if (di->symt) return di->symt;
 
-    if (!dwarf2_find_attribute(di, DW_AT_name, &name))
-        name.u.string = "void";
-    size.u.uvalue = di->unit_ctx->module_ctx->module->cpu->word_size;
-
-    basic = symt_new_basic(di->unit_ctx->module_ctx->module, btVoid, name.u.string, size.u.uvalue);
-    di->symt = &basic->symt;
+    basic = &symt_get_basic(btVoid, 0)->symt;
+    if (dwarf2_find_attribute(di, DW_AT_name, &name))
+        /* define the missing type as a typedef to void... */
+        di->symt = &symt_new_typedef(di->unit_ctx->module_ctx->module, basic, name.u.string)->symt;
+    else /* or use void if it doesn't even have a name */
+        di->symt = basic;
 
     if (dwarf2_get_di_children(di)) FIXME("Unsupported children\n");
     return di->symt;
@@ -1878,10 +1871,10 @@ static struct symt* dwarf2_parse_enumeration_type(dwarf2_debug_info_t* di)
 
         switch (size.u.uvalue) /* FIXME: that's wrong */
         {
-        case 1: basetype = symt_new_basic(di->unit_ctx->module_ctx->module, btInt, "char", 1); break;
-        case 2: basetype = symt_new_basic(di->unit_ctx->module_ctx->module, btInt, "short", 2); break;
+        case 1: basetype = symt_get_basic(btInt, 1); break;
+        case 2: basetype = symt_get_basic(btInt, 2); break;
         default:
-        case 4: basetype = symt_new_basic(di->unit_ctx->module_ctx->module, btInt, "int", 4); break;
+        case 4: basetype = symt_get_basic(btInt, 4); break;
         }
         type = &basetype->symt;
     }
@@ -2457,7 +2450,7 @@ static void dwarf2_parse_namespace(dwarf2_debug_info_t* di)
 
     TRACE("%s\n", dwarf2_debug_di(di));
 
-    di->symt = di->unit_ctx->module_ctx->symt_cache[sc_void];
+    di->symt = &symt_get_basic(btVoid, 0)->symt;
 
     children = dwarf2_get_di_children(di);
     if (children) for (i = 0; i < vector_length(children); i++)
@@ -4071,9 +4064,6 @@ static BOOL dwarf2_load_CU_module(dwarf2_parse_module_context_t* module_ctx, str
     module_ctx->module = module;
     module_ctx->thunks = thunks;
     module_ctx->load_offset = load_offset;
-    memset(module_ctx->symt_cache, 0, sizeof(module_ctx->symt_cache));
-    module_ctx->symt_cache[sc_void] = &symt_new_basic(module_ctx->module, btVoid, "void", 0)->symt;
-    module_ctx->symt_cache[sc_unknown] = &symt_new_basic(module_ctx->module, btNoType, "# unknown", 0)->symt;
     vector_init(&module_ctx->unit_contexts, sizeof(dwarf2_parse_context_t), 16);
     module_ctx->cu_versions = 0;
 
diff --git a/dlls/dbghelp/msc.c b/dlls/dbghelp/msc.c
index 22ab1ecb230..64d520c2b37 100644
--- a/dlls/dbghelp/msc.c
+++ b/dlls/dbghelp/msc.c
@@ -157,34 +157,34 @@ static void codeview_init_basic_types(struct module* module)
      */
     cv_basic_types[T_NOTYPE] = NULL;
     cv_basic_types[T_ABS]    = NULL;
-    cv_basic_types[T_VOID]   = &symt_new_basic(module, btVoid,  "void", 0)->symt;
-    cv_basic_types[T_CHAR]   = &symt_new_basic(module, btChar,  "char", 1)->symt;
-    cv_basic_types[T_SHORT]  = &symt_new_basic(module, btInt,   "short int", 2)->symt;
-    cv_basic_types[T_LONG]   = &symt_new_basic(module, btInt,   "long int", 4)->symt;
-    cv_basic_types[T_QUAD]   = &symt_new_basic(module, btInt,   "long long int", 8)->symt;
-    cv_basic_types[T_UCHAR]  = &symt_new_basic(module, btUInt,  "unsigned char", 1)->symt;
-    cv_basic_types[T_USHORT] = &symt_new_basic(module, btUInt,  "unsigned short", 2)->symt;
-    cv_basic_types[T_ULONG]  = &symt_new_basic(module, btUInt,  "unsigned long", 4)->symt;
-    cv_basic_types[T_UQUAD]  = &symt_new_basic(module, btUInt,  "unsigned long long", 8)->symt;
-    cv_basic_types[T_BOOL08] = &symt_new_basic(module, btBool,  "BOOL08", 1)->symt;
-    cv_basic_types[T_BOOL16] = &symt_new_basic(module, btBool,  "BOOL16", 2)->symt;
-    cv_basic_types[T_BOOL32] = &symt_new_basic(module, btBool,  "BOOL32", 4)->symt;
-    cv_basic_types[T_BOOL64] = &symt_new_basic(module, btBool,  "BOOL64", 8)->symt;
-    cv_basic_types[T_REAL32] = &symt_new_basic(module, btFloat, "float", 4)->symt;
-    cv_basic_types[T_REAL64] = &symt_new_basic(module, btFloat, "double", 8)->symt;
-    cv_basic_types[T_REAL80] = &symt_new_basic(module, btFloat, "long double", 10)->symt;
-    cv_basic_types[T_RCHAR]  = &symt_new_basic(module, btInt,   "signed char", 1)->symt;
-    cv_basic_types[T_WCHAR]  = &symt_new_basic(module, btWChar, "wchar_t", 2)->symt;
-    cv_basic_types[T_CHAR16] = &symt_new_basic(module, btChar16,"char16_t", 2)->symt;
-    cv_basic_types[T_CHAR32] = &symt_new_basic(module, btChar32,"char32_t", 4)->symt;
-    cv_basic_types[T_CHAR8]  = &symt_new_basic(module, btChar8, "char8_t", 1)->symt;
-    cv_basic_types[T_INT2]   = &symt_new_basic(module, btInt,   "INT2", 2)->symt;
-    cv_basic_types[T_UINT2]  = &symt_new_basic(module, btUInt,  "UINT2", 2)->symt;
-    cv_basic_types[T_INT4]   = &symt_new_basic(module, btInt,   "INT4", 4)->symt;
-    cv_basic_types[T_UINT4]  = &symt_new_basic(module, btUInt,  "UINT4", 4)->symt;
-    cv_basic_types[T_INT8]   = &symt_new_basic(module, btInt,   "INT8", 8)->symt;
-    cv_basic_types[T_UINT8]  = &symt_new_basic(module, btUInt,  "UINT8", 8)->symt;
-    cv_basic_types[T_HRESULT]= &symt_new_basic(module, btUInt,  "HRESULT", 4)->symt;
+    cv_basic_types[T_VOID]   = &symt_get_basic(btVoid,   0)->symt; /* void */
+    cv_basic_types[T_CHAR]   = &symt_get_basic(btChar,   1)->symt; /* char */
+    cv_basic_types[T_SHORT]  = &symt_get_basic(btInt,    2)->symt; /* short int */
+    cv_basic_types[T_LONG]   = &symt_get_basic(btInt,    4)->symt; /* long int */
+    cv_basic_types[T_QUAD]   = &symt_get_basic(btInt,    8)->symt; /* long long int */
+    cv_basic_types[T_UCHAR]  = &symt_get_basic(btUInt,   1)->symt; /* unsigned char */
+    cv_basic_types[T_USHORT] = &symt_get_basic(btUInt,   2)->symt; /* unsigned short */
+    cv_basic_types[T_ULONG]  = &symt_get_basic(btUInt,   4)->symt; /* unsigned long */
+    cv_basic_types[T_UQUAD]  = &symt_get_basic(btUInt,   8)->symt; /* unsigned long long */
+    cv_basic_types[T_BOOL08] = &symt_get_basic(btBool,   1)->symt; /* BOOL08 */
+    cv_basic_types[T_BOOL16] = &symt_get_basic(btBool,   2)->symt; /* BOOL16 */
+    cv_basic_types[T_BOOL32] = &symt_get_basic(btBool,   4)->symt; /* BOOL32 */
+    cv_basic_types[T_BOOL64] = &symt_get_basic(btBool,   8)->symt; /* BOOL64 */
+    cv_basic_types[T_REAL32] = &symt_get_basic(btFloat,  4)->symt; /* float */
+    cv_basic_types[T_REAL64] = &symt_get_basic(btFloat,  8)->symt; /* double */
+    cv_basic_types[T_REAL80] = &symt_get_basic(btFloat, 10)->symt; /* long double */
+    cv_basic_types[T_RCHAR]  = &symt_get_basic(btInt,    1)->symt; /* signed char */
+    cv_basic_types[T_WCHAR]  = &symt_get_basic(btWChar,  2)->symt; /* char8_t */
+    cv_basic_types[T_CHAR16] = &symt_get_basic(btChar16, 2)->symt; /* char16_t */
+    cv_basic_types[T_CHAR32] = &symt_get_basic(btChar32, 4)->symt; /* char32_t */
+    cv_basic_types[T_CHAR8]  = &symt_get_basic(btChar8,  1)->symt; /* char8_t */
+    cv_basic_types[T_INT2]   = &symt_get_basic(btInt,    2)->symt; /* INT2 */
+    cv_basic_types[T_UINT2]  = &symt_get_basic(btUInt,   2)->symt; /* UINT2 */
+    cv_basic_types[T_INT4]   = &symt_get_basic(btInt,    4)->symt; /* INT4 */
+    cv_basic_types[T_UINT4]  = &symt_get_basic(btUInt,   4)->symt; /* UINT4 */
+    cv_basic_types[T_INT8]   = &symt_get_basic(btInt,    8)->symt; /* INT8 */
+    cv_basic_types[T_UINT8]  = &symt_get_basic(btUInt,   8)->symt; /* UINT8 */
+    cv_basic_types[T_HRESULT]= &symt_get_basic(btUInt,   4)->symt; /* HRESULT */
 
     cv_basic_types[T_32PVOID]   = &symt_new_pointer(module, cv_basic_types[T_VOID], 4)->symt;
     cv_basic_types[T_32PCHAR]   = &symt_new_pointer(module, cv_basic_types[T_CHAR], 4)->symt;
diff --git a/dlls/dbghelp/stabs.c b/dlls/dbghelp/stabs.c
index 89ae0951a6a..b22fb714973 100644
--- a/dlls/dbghelp/stabs.c
+++ b/dlls/dbghelp/stabs.c
@@ -322,31 +322,31 @@ static int stabs_get_basic(struct ParseTypedefData* ptd, unsigned basic, struct
     {
         switch (basic)
         {
-        case  1: stabs_basic[basic] = symt_new_basic(ptd->module, btInt,     "int", 4); break;
-        case  2: stabs_basic[basic] = symt_new_basic(ptd->module, btChar,    "char", 1); break;
-        case  3: stabs_basic[basic] = symt_new_basic(ptd->module, btInt,     "short int", 2); break;
-        case  4: stabs_basic[basic] = symt_new_basic(ptd->module, btInt,     "long int", 4); break;
-        case  5: stabs_basic[basic] = symt_new_basic(ptd->module, btUInt,    "unsigned char", 1); break;
-        case  6: stabs_basic[basic] = symt_new_basic(ptd->module, btInt,     "signed char", 1); break;
-        case  7: stabs_basic[basic] = symt_new_basic(ptd->module, btUInt,    "unsigned short int", 2); break;
-        case  8: stabs_basic[basic] = symt_new_basic(ptd->module, btUInt,    "unsigned int", 4); break;
-        case  9: stabs_basic[basic] = symt_new_basic(ptd->module, btUInt,    "unsigned", 2); break;
-        case 10: stabs_basic[basic] = symt_new_basic(ptd->module, btUInt,    "unsigned long int", 2); break;
-        case 11: stabs_basic[basic] = symt_new_basic(ptd->module, btVoid,    "void", 0); break;
-        case 12: stabs_basic[basic] = symt_new_basic(ptd->module, btFloat,   "float", 4); break;
-        case 13: stabs_basic[basic] = symt_new_basic(ptd->module, btFloat,   "double", 8); break;
-        case 14: stabs_basic[basic] = symt_new_basic(ptd->module, btFloat,   "long double", 12); break;
-        case 15: stabs_basic[basic] = symt_new_basic(ptd->module, btInt,     "integer", 4); break;
-        case 16: stabs_basic[basic] = symt_new_basic(ptd->module, btBool,    "bool", 1); break;
+        case  1: stabs_basic[basic] = symt_get_basic(btInt,     4); break; /* int */
+        case  2: stabs_basic[basic] = symt_get_basic(btChar,    1); break; /* char */
+        case  3: stabs_basic[basic] = symt_get_basic(btInt,     2); break; /* short int */
+        case  4: stabs_basic[basic] = symt_get_basic(btInt,     4); break; /* long int */
+        case  5: stabs_basic[basic] = symt_get_basic(btUInt,    1); break; /* unsigned char */
+        case  6: stabs_basic[basic] = symt_get_basic(btInt,     1); break; /* signed char */
+        case  7: stabs_basic[basic] = symt_get_basic(btUInt,    2); break; /* unsigned short int */
+        case  8: stabs_basic[basic] = symt_get_basic(btUInt,    4); break; /* unsigned int */
+        case  9: stabs_basic[basic] = symt_get_basic(btUInt,    2); break; /* unsigned */
+        case 10: stabs_basic[basic] = symt_get_basic(btUInt,    2); break; /* unsigned long int */
+        case 11: stabs_basic[basic] = symt_get_basic(btVoid,    0); break; /* void */
+        case 12: stabs_basic[basic] = symt_get_basic(btFloat,   4); break; /* float */
+        case 13: stabs_basic[basic] = symt_get_basic(btFloat,   8); break; /* double */
+        case 14: stabs_basic[basic] = symt_get_basic(btFloat,   2); break; /* long double", */
+        case 15: stabs_basic[basic] = symt_get_basic(btInt,     4); break; /* integer */
+        case 16: stabs_basic[basic] = symt_get_basic(btBool,    1); break; /* bool */
         /*    case 17: short real */
         /*    case 18: real */
-        case 25: stabs_basic[basic] = symt_new_basic(ptd->module, btComplex, "float complex", 8); break;
-        case 26: stabs_basic[basic] = symt_new_basic(ptd->module, btComplex, "double complex", 16); break;
-        case 30: stabs_basic[basic] = symt_new_basic(ptd->module, btWChar,   "wchar_t", 2); break;
-        case 31: stabs_basic[basic] = symt_new_basic(ptd->module, btInt,     "long long int", 8); break;
-        case 32: stabs_basic[basic] = symt_new_basic(ptd->module, btUInt,    "long long unsigned", 8); break;
+        case 25: stabs_basic[basic] = symt_get_basic(btComplex, 8); break; /* float complex */
+        case 26: stabs_basic[basic] = symt_get_basic(btComplex, 6); break; /* double complex", */
+        case 30: stabs_basic[basic] = symt_get_basic(btWChar,   2); break; /* wchar_t */
+        case 31: stabs_basic[basic] = symt_get_basic(btInt,     8); break; /* long long int */
+        case 32: stabs_basic[basic] = symt_get_basic(btUInt,    8); break; /* long long unsigned */
             /* starting at 35 are wine extensions (especially for R implementation) */
-        case 35: stabs_basic[basic] = symt_new_basic(ptd->module, btComplex, "long double complex", 24); break;
+        case 35: stabs_basic[basic] = symt_get_basic(btComplex, 4); break; /* long double complex", */
         default: PTS_ABORTIF(ptd, 1);
         }
     }   
@@ -541,7 +541,7 @@ static int stabs_pts_read_range(struct ParseTypedefData* ptd, const char* typena
     }
     else PTS_ABORTIF(ptd, 1);
 
-    *dt = &symt_new_basic(ptd->module, bt, typename, size)->symt;
+    *dt = &symt_get_basic(bt, size)->symt;
     return 0;
 }
 
@@ -967,7 +967,7 @@ static int stabs_pts_read_type_def(struct ParseTypedefData* ptd, const char* typ
          */
         if (!new_dt && typename)
         {
-            new_dt = &symt_new_basic(ptd->module, btVoid, typename, 0)->symt;
+            new_dt = &symt_get_basic(btVoid, 0)->symt;
             PTS_ABORTIF(ptd, strcmp(typename, "void"));
         }
     }            
diff --git a/dlls/dbghelp/type.c b/dlls/dbghelp/type.c
index 67f4265ddc9..0cbbc4e333b 100644
--- a/dlls/dbghelp/type.c
+++ b/dlls/dbghelp/type.c
@@ -97,7 +97,6 @@ const char* symt_get_name(const struct symt* sym)
     case SymTagFunction:        return ((const struct symt_function*)sym)->hash_elt.name;
     case SymTagInlineSite:      return ((const struct symt_inlinesite*)sym)->func.hash_elt.name;
     case SymTagPublicSymbol:    return ((const struct symt_public*)sym)->hash_elt.name;
-    case SymTagBaseType:        return ((const struct symt_basic*)sym)->hash_elt.name;
     case SymTagLabel:           return ((const struct symt_hierarchy_point*)sym)->hash_elt.name;
     case SymTagThunk:           return ((const struct symt_thunk*)sym)->hash_elt.name;
     case SymTagCustom:          return ((const struct symt_custom*)sym)->hash_elt.name;
@@ -110,6 +109,7 @@ const char* symt_get_name(const struct symt* sym)
     default:
         FIXME("Unsupported sym-tag %s\n", symt_get_tag_str(sym->tag));
         /* fall through */
+    case SymTagBaseType:
     case SymTagArrayType:
     case SymTagPointerType:
     case SymTagFunctionType:
@@ -224,31 +224,26 @@ static void symt_add_type(struct module* module, struct symt* symt)
     *p = symt;
 }
 
-struct symt_basic* symt_new_basic(struct module* module, enum BasicType bt, 
-                                  const char* typename, unsigned size)
+struct symt_basic* symt_get_basic(enum BasicType bt, unsigned size)
 {
-    struct symt_basic*          sym;
+    static struct symt_basic cache[32] = { { {SymTagBaseType}, btNoType, 0 } };
+    int i;
 
-    if (typename)
-    {
-        sym = (struct symt_basic*)symt_find_type_by_name(module, SymTagBaseType,
-                                                         typename);
-        if (sym && sym->bt == bt && sym->size == size)
-            return sym;
-    }
-    if ((sym = pool_alloc(&module->pool, sizeof(*sym))))
+    if (bt == btNoType) return &cache[0];
+    for (i = 1; i < ARRAY_SIZE(cache); i++)
     {
-        sym->symt.tag = SymTagBaseType;
-        if (typename)
+        if (cache[i].bt == btNoType) /* empty slot, create new entry */
         {
-            sym->hash_elt.name = pool_strdup(&module->pool, typename);
-            hash_table_add(&module->ht_types, &sym->hash_elt);
-        } else sym->hash_elt.name = NULL;
-        sym->bt = bt;
-        sym->size = size;
-        symt_add_type(module, &sym->symt);
+            cache[i].symt.tag = SymTagBaseType;
+            cache[i].bt = bt;
+            cache[i].size = size;
+            return &cache[i];
+        }
+        if (cache[i].bt == bt && cache[i].size == size)
+            return &cache[i];
     }
-    return sym;
+    FIXME("Too few slots in basic types cache\n");
+    return &cache[0];
 }
 
 struct symt_udt* symt_new_udt(struct module* module, const char* typename, 
-- 
GitLab


From d94f4747e877b87400d4cb0d11d1c09139ad2c87 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Tue, 10 May 2022 17:11:08 +0200
Subject: [PATCH 4/5] dbghelp: Fix conversion of dwarf's basic types into
 dbghelp's basic types.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dbghelp/dwarf.c | 60 +++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 56 insertions(+), 4 deletions(-)

diff --git a/dlls/dbghelp/dwarf.c b/dlls/dbghelp/dwarf.c
index 19c0da933d3..5c0f34d4bf5 100644
--- a/dlls/dbghelp/dwarf.c
+++ b/dlls/dbghelp/dwarf.c
@@ -213,6 +213,7 @@ typedef struct dwarf2_parse_context_s
     dwarf2_cuhead_t             head;
     enum unit_status            status;
     dwarf2_traverse_context_t   traverse_DIE;
+    unsigned                    language;
 } dwarf2_parse_context_t;
 
 /* stored in the dbghelp's module internal structure for later reuse */
@@ -1450,16 +1451,43 @@ static struct vector* dwarf2_get_di_children(dwarf2_debug_info_t* di)
     return NULL;
 }
 
+/* reconstruct whether integer is long (contains 'long' only once) */
+static BOOL is_long(const char* name)
+{
+    /* we assume name is made only of basic C keywords:
+     *    int long short unsigned signed void float double char _Bool _Complex
+     */
+    const char* p = strstr(name, "long");
+    return p && strstr(p + 4, "long") == NULL;
+}
+
+static BOOL is_c_language(dwarf2_parse_context_t* unit_ctx)
+{
+    return unit_ctx->language == DW_LANG_C ||
+        unit_ctx->language == DW_LANG_C89 ||
+        unit_ctx->language == DW_LANG_C99;
+}
+
+static BOOL is_cpp_language(dwarf2_parse_context_t* unit_ctx)
+{
+    return unit_ctx->language == DW_LANG_C_plus_plus;
+}
+
 static struct symt* dwarf2_parse_base_type(dwarf2_debug_info_t* di)
 {
     struct attribute name;
     struct attribute size;
     struct attribute encoding;
     enum BasicType bt;
+    BOOL c_language, cpp_language;
+
     if (di->symt) return di->symt;
 
     TRACE("%s\n", dwarf2_debug_di(di));
 
+    c_language = is_c_language(di->unit_ctx);
+    cpp_language = is_cpp_language(di->unit_ctx);
+
     if (!dwarf2_find_attribute(di, DW_AT_name, &name))
         name.u.string = NULL;
     if (!dwarf2_find_attribute(di, DW_AT_byte_size, &size)) size.u.uvalue = 0;
@@ -1472,10 +1500,19 @@ static struct symt* dwarf2_parse_base_type(dwarf2_debug_info_t* di)
     case DW_ATE_boolean:        bt = btBool; break;
     case DW_ATE_complex_float:  bt = btComplex; break;
     case DW_ATE_float:          bt = btFloat; break;
-    case DW_ATE_signed:         bt = btInt; break;
-    case DW_ATE_unsigned:       bt = btUInt; break;
-    case DW_ATE_signed_char:    bt = btChar; break;
-    case DW_ATE_unsigned_char:  bt = btChar; break;
+    case DW_ATE_signed:         bt = ((c_language || cpp_language) && is_long(name.u.string)) ? btLong : btInt; break;
+    case DW_ATE_unsigned:
+        if ((c_language || cpp_language) && is_long(name.u.string)) bt = btULong;
+        else if (cpp_language && !strcmp(name.u.string, "wchar_t")) bt = btWChar;
+        else if (cpp_language && !strcmp(name.u.string, "char8_t")) bt = btChar8;
+        else if (cpp_language && !strcmp(name.u.string, "char16_t")) bt = btChar16;
+        else if (cpp_language && !strcmp(name.u.string, "char32_t")) bt = btChar32;
+        else bt = btUInt;
+        break;
+    /* on Windows, in C, char == signed char, but not in C++ */
+    case DW_ATE_signed_char:    bt = (cpp_language && !strcmp(name.u.string, "signed char")) ? btInt : btChar; break;
+    case DW_ATE_unsigned_char:  bt = btUInt; break;
+    case DW_ATE_UTF:            bt = (size.u.uvalue == 1) ? btChar8 : (size.u.uvalue == 2 ? btChar16 : btChar32); break;
     default:                    bt = btNoType; break;
     }
     di->symt = &symt_get_basic(bt, size.u.uvalue)->symt;
@@ -1497,7 +1534,15 @@ static struct symt* dwarf2_parse_typedef(dwarf2_debug_info_t* di)
     ref_type = dwarf2_lookup_type(di);
 
     if (name.u.string)
+    {
+        /* Note: The MS C compiler has tweaks for WCHAR support.
+         *       Even if WCHAR is a typedef to wchar_t, wchar_t is emitted as btUInt/2 (it's defined as
+         *          unsigned short, so far so good), while WCHAR is emitted as btWChar/2).
+         */
+        if ((is_c_language(di->unit_ctx) || is_cpp_language(di->unit_ctx)) && !strcmp(name.u.string, "WCHAR"))
+            ref_type = &symt_get_basic(btWChar, 2)->symt;
         di->symt = &symt_new_typedef(di->unit_ctx->module_ctx->module, ref_type, name.u.string)->symt;
+    }
     if (dwarf2_get_di_children(di)) FIXME("Unsupported children\n");
     return di->symt;
 }
@@ -2917,6 +2962,7 @@ static BOOL dwarf2_parse_compilation_unit(dwarf2_parse_context_t* ctx)
             unsigned int                i;
             struct attribute            stmt_list, low_pc;
             struct attribute            comp_dir;
+            struct attribute            language;
 
             if (!dwarf2_find_attribute(di, DW_AT_name, &name))
                 name.u.string = NULL;
@@ -2927,6 +2973,12 @@ static BOOL dwarf2_parse_compilation_unit(dwarf2_parse_context_t* ctx)
 
             if (!dwarf2_find_attribute(di, DW_AT_low_pc, &low_pc))
                 low_pc.u.uvalue = 0;
+
+            if (!dwarf2_find_attribute(di, DW_AT_language, &language))
+                language.u.uvalue = DW_LANG_C;
+
+            ctx->language = language.u.uvalue;
+
             ctx->compiland = symt_new_compiland(ctx->module_ctx->module, ctx->module_ctx->load_offset + low_pc.u.uvalue,
                                                 source_new(ctx->module_ctx->module, comp_dir.u.string, name.u.string));
             dwarf2_cache_cuhead(ctx->module_ctx->module->format_info[DFI_DWARF]->u.dwarf2_info, ctx->compiland, &ctx->head);
-- 
GitLab


From 5aa9340c3d12ebf42cf4b9f8a170c55e00c48338 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Tue, 10 May 2022 17:11:08 +0200
Subject: [PATCH 5/5] dbghelp: Set correct basic types definition.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
Signed-off-by: Alexandre Julliard <julliard@winehq.org>
---
 dlls/dbghelp/msc.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/dlls/dbghelp/msc.c b/dlls/dbghelp/msc.c
index 64d520c2b37..5b45c474160 100644
--- a/dlls/dbghelp/msc.c
+++ b/dlls/dbghelp/msc.c
@@ -158,13 +158,13 @@ static void codeview_init_basic_types(struct module* module)
     cv_basic_types[T_NOTYPE] = NULL;
     cv_basic_types[T_ABS]    = NULL;
     cv_basic_types[T_VOID]   = &symt_get_basic(btVoid,   0)->symt; /* void */
-    cv_basic_types[T_CHAR]   = &symt_get_basic(btChar,   1)->symt; /* char */
+    cv_basic_types[T_CHAR]   = &symt_get_basic(btInt,    1)->symt; /* signed char (and char in C) */
     cv_basic_types[T_SHORT]  = &symt_get_basic(btInt,    2)->symt; /* short int */
-    cv_basic_types[T_LONG]   = &symt_get_basic(btInt,    4)->symt; /* long int */
+    cv_basic_types[T_LONG]   = &symt_get_basic(btLong,   4)->symt; /* long int */
     cv_basic_types[T_QUAD]   = &symt_get_basic(btInt,    8)->symt; /* long long int */
     cv_basic_types[T_UCHAR]  = &symt_get_basic(btUInt,   1)->symt; /* unsigned char */
     cv_basic_types[T_USHORT] = &symt_get_basic(btUInt,   2)->symt; /* unsigned short */
-    cv_basic_types[T_ULONG]  = &symt_get_basic(btUInt,   4)->symt; /* unsigned long */
+    cv_basic_types[T_ULONG]  = &symt_get_basic(btULong,  4)->symt; /* unsigned long */
     cv_basic_types[T_UQUAD]  = &symt_get_basic(btUInt,   8)->symt; /* unsigned long long */
     cv_basic_types[T_BOOL08] = &symt_get_basic(btBool,   1)->symt; /* BOOL08 */
     cv_basic_types[T_BOOL16] = &symt_get_basic(btBool,   2)->symt; /* BOOL16 */
@@ -173,7 +173,7 @@ static void codeview_init_basic_types(struct module* module)
     cv_basic_types[T_REAL32] = &symt_get_basic(btFloat,  4)->symt; /* float */
     cv_basic_types[T_REAL64] = &symt_get_basic(btFloat,  8)->symt; /* double */
     cv_basic_types[T_REAL80] = &symt_get_basic(btFloat, 10)->symt; /* long double */
-    cv_basic_types[T_RCHAR]  = &symt_get_basic(btInt,    1)->symt; /* signed char */
+    cv_basic_types[T_RCHAR]  = &symt_get_basic(btChar,   1)->symt; /* "real" char (char in C++) */
     cv_basic_types[T_WCHAR]  = &symt_get_basic(btWChar,  2)->symt; /* char8_t */
     cv_basic_types[T_CHAR16] = &symt_get_basic(btChar16, 2)->symt; /* char16_t */
     cv_basic_types[T_CHAR32] = &symt_get_basic(btChar32, 4)->symt; /* char32_t */
-- 
GitLab

From 253a2e2edb618371d7ab63e7c406134f1342e2c4 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Wed, 8 Dec 2021 03:12:41 +0900
Subject: [PATCH 1/4] include: Define fast fail codes and the __fastfail()
 intrinsic.

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 include/winnt.h | 87 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 87 insertions(+)

diff --git a/include/winnt.h b/include/winnt.h
index 7aafbcf0cfe..87c4b4da92d 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -934,6 +934,78 @@ NTSYSAPI PSLIST_ENTRY WINAPI RtlInterlockedPushEntrySList(PSLIST_HEADER, PSLIST_
 NTSYSAPI WORD         WINAPI RtlQueryDepthSList(PSLIST_HEADER);
 
 
+/* Fast fail (__fastfail) codes */
+
+#define FAST_FAIL_LEGACY_GS_VIOLATION               0
+#define FAST_FAIL_VTGUARD_CHECK_FAILURE             1
+#define FAST_FAIL_STACK_COOKIE_CHECK_FAILURE        2
+#define FAST_FAIL_CORRUPT_LIST_ENTRY                3
+#define FAST_FAIL_INCORRECT_STACK                   4
+#define FAST_FAIL_INVALID_ARG                       5
+#define FAST_FAIL_GS_COOKIE_INIT                    6
+#define FAST_FAIL_FATAL_APP_EXIT                    7
+#define FAST_FAIL_RANGE_CHECK_FAILURE               8
+#define FAST_FAIL_UNSAFE_REGISTRY_ACCESS            9
+#define FAST_FAIL_GUARD_ICALL_CHECK_FAILURE         10
+#define FAST_FAIL_GUARD_WRITE_CHECK_FAILURE         11
+#define FAST_FAIL_INVALID_FIBER_SWITCH              12
+#define FAST_FAIL_INVALID_SET_OF_CONTEXT            13
+#define FAST_FAIL_INVALID_REFERENCE_COUNT           14
+#define FAST_FAIL_INVALID_JUMP_BUFFER               18
+#define FAST_FAIL_MRDATA_MODIFIED                   19
+#define FAST_FAIL_CERTIFICATION_FAILURE             20
+#define FAST_FAIL_INVALID_EXCEPTION_CHAIN           21
+#define FAST_FAIL_CRYPTO_LIBRARY                    22
+#define FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT       23
+#define FAST_FAIL_INVALID_IMAGE_BASE                24
+#define FAST_FAIL_DLOAD_PROTECTION_FAILURE          25
+#define FAST_FAIL_UNSAFE_EXTENSION_CALL             26
+#define FAST_FAIL_DEPRECATED_SERVICE_INVOKED        27
+#define FAST_FAIL_INVALID_BUFFER_ACCESS             28
+#define FAST_FAIL_INVALID_BALANCED_TREE             29
+#define FAST_FAIL_INVALID_NEXT_THREAD               30
+#define FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED      31
+#define FAST_FAIL_APCS_DISABLED                     32
+#define FAST_FAIL_INVALID_IDLE_STATE                33
+#define FAST_FAIL_MRDATA_PROTECTION_FAILURE         34
+#define FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION         35
+#define FAST_FAIL_INVALID_LOCK_STATE                36
+#define FAST_FAIL_GUARD_JUMPTABLE                   37
+#define FAST_FAIL_INVALID_LONGJUMP_TARGET           38
+#define FAST_FAIL_INVALID_DISPATCH_CONTEXT          39
+#define FAST_FAIL_INVALID_THREAD                    40
+#define FAST_FAIL_INVALID_SYSCALL_NUMBER            41
+#define FAST_FAIL_INVALID_FILE_OPERATION            42
+#define FAST_FAIL_LPAC_ACCESS_DENIED                43
+#define FAST_FAIL_GUARD_SS_FAILURE                  44
+#define FAST_FAIL_LOADER_CONTINUITY_FAILURE         45
+#define FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE  46
+#define FAST_FAIL_INVALID_CONTROL_STACK             47
+#define FAST_FAIL_SET_CONTEXT_DENIED                48
+#define FAST_FAIL_INVALID_IAT                       49
+#define FAST_FAIL_HEAP_METADATA_CORRUPTION          50
+#define FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION     51
+#define FAST_FAIL_LOW_LABEL_ACCESS_DENIED           52
+#define FAST_FAIL_ENCLAVE_CALL_FAILURE              53
+#define FAST_FAIL_UNHANDLED_LSS_EXCEPTON            54
+#define FAST_FAIL_ADMINLESS_ACCESS_DENIED           55
+#define FAST_FAIL_UNEXPECTED_CALL                   56
+#define FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS    57
+#define FAST_FAIL_UNEXPECTED_HOST_BEHAVIOR          58
+#define FAST_FAIL_FLAGS_CORRUPTION                  59
+#define FAST_FAIL_VEH_CORRUPTION                    60
+#define FAST_FAIL_ETW_CORRUPTION                    61
+#define FAST_FAIL_RIO_ABORT                         62
+#define FAST_FAIL_INVALID_PFN                       63
+#define FAST_FAIL_GUARD_ICALL_CHECK_FAILURE_XFG     64
+#define FAST_FAIL_CAST_GUARD                        65
+#define FAST_FAIL_HOST_VISIBILITY_CHANGE            66
+#define FAST_FAIL_KERNEL_CET_SHADOW_STACK_ASSIST    67
+#define FAST_FAIL_PATCH_CALLBACK_FAILED             68
+#define FAST_FAIL_NTDLL_PATCH_FAILED                69
+#define FAST_FAIL_INVALID_FLS_DATA                  70
+#define FAST_FAIL_INVALID_FAST_FAIL_CODE            0xFFFFFFFF
+
 /* Heap flags */
 
 #define HEAP_NO_SERIALIZE               0x00000001
@@ -6318,6 +6390,7 @@ typedef enum _PROCESS_MITIGATION_POLICY
 #pragma intrinsic(_InterlockedDecrement16)
 #pragma intrinsic(_InterlockedOr)
 #pragma intrinsic(_InterlockedXor)
+#pragma intrinsic(__fastfail)
 
 BOOLEAN   _BitScanForward(unsigned long*,unsigned long);
 BOOLEAN   _BitScanReverse(unsigned long*,unsigned long);
@@ -6332,6 +6405,7 @@ long      _InterlockedIncrement(long volatile*);
 short     _InterlockedIncrement16(short volatile*);
 long      _InterlockedOr(long volatile *,long);
 long      _InterlockedXor(long volatile *,long);
+DECLSPEC_NORETURN void __fastfail(unsigned int);
 
 static FORCEINLINE long InterlockedAdd( long volatile *dest, long val )
 {
@@ -6514,6 +6588,19 @@ static FORCEINLINE void MemoryBarrier(void)
     __sync_synchronize();
 }
 
+static FORCEINLINE DECLSPEC_NORETURN void __fastfail(unsigned int code)
+{
+#if defined(__x86_64__) || defined(__i386__)
+    for (;;) __asm__ __volatile__( "int $0x29" :: "c" ((ULONG_PTR)code) : "memory" );
+#elif defined(__aarch64__)
+    register ULONG_PTR val __asm__("x0") = code;
+    for (;;) __asm__ __volatile__( "brk #0xf003" :: "r" (val) : "memory" );
+#elif defined(__arm__)
+    register ULONG_PTR val __asm__("r0") = code;
+    for (;;) __asm__ __volatile__( "udf #0xfb" :: "r" (val) : "memory" );
+#endif
+}
+
 #endif  /* __GNUC__ */
 
 #ifdef _WIN64
-- 
GitLab


From 7fbe8b8ebfa0d13dd318fd1d3beaf04872a47ed0 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Wed, 8 Dec 2021 03:14:06 +0900
Subject: [PATCH 2/4] ntdll/tests: Add tests for __fastfail().

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/ntdll/tests/exception.c | 93 ++++++++++++++++++++++++++++++++++++
 1 file changed, 93 insertions(+)

diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
index 14ffdb00d78..0086b18d678 100644
--- a/dlls/ntdll/tests/exception.c
+++ b/dlls/ntdll/tests/exception.c
@@ -8417,6 +8417,91 @@ static void test_ripevent(DWORD numexc)
     pRtlRemoveVectoredExceptionHandler(vectored_handler);
 }
 
+static void subtest_fastfail(unsigned int code)
+{
+    char cmdline[MAX_PATH];
+    PROCESS_INFORMATION pi;
+    STARTUPINFOA si = { 0 };
+    DEBUG_EVENT de;
+    DWORD continuestatus;
+    BOOL ret;
+    BOOL had_ff = FALSE, had_se = FALSE;
+
+    sprintf(cmdline, "%s %s %s %u", my_argv[0], my_argv[1], "fastfail", code);
+    si.cb = sizeof(si);
+    ret = CreateProcessA(NULL, cmdline, NULL, NULL, FALSE, DEBUG_PROCESS, NULL, NULL, &si, &pi);
+    ok(ret, "could not create child process error: %lu\n", GetLastError());
+    if (!ret)
+        return;
+
+    do
+    {
+        continuestatus = DBG_CONTINUE;
+        ok(WaitForDebugEvent(&de, INFINITE), "reading debug event\n");
+
+        if (de.dwDebugEventCode == EXCEPTION_DEBUG_EVENT)
+        {
+            if (de.u.Exception.ExceptionRecord.ExceptionCode == STATUS_STACK_BUFFER_OVERRUN)
+            {
+                ok(!de.u.Exception.dwFirstChance, "must be a second chance exception\n");
+                ok(de.u.Exception.ExceptionRecord.NumberParameters == 1, "expected exactly one parameter, got %lu\n",
+                   de.u.Exception.ExceptionRecord.NumberParameters);
+                ok(de.u.Exception.ExceptionRecord.ExceptionInformation[0] == code, "expected %u for code, got %Iu\n",
+                   code, de.u.Exception.ExceptionRecord.ExceptionInformation[0]);
+                had_ff = TRUE;
+            }
+
+            if (de.u.Exception.dwFirstChance)
+            {
+                continuestatus = DBG_EXCEPTION_NOT_HANDLED;
+            }
+            else
+            {
+                had_se = TRUE;
+                pNtTerminateProcess(pi.hProcess, 0);
+            }
+        }
+
+        ContinueDebugEvent(de.dwProcessId, de.dwThreadId, continuestatus);
+
+    } while (de.dwDebugEventCode != EXIT_PROCESS_DEBUG_EVENT);
+
+    todo_wine
+    ok(had_ff || broken(had_se) /* Win7 */, "fast fail did not occur\n");
+
+    wait_child_process( pi.hProcess );
+    ret = CloseHandle(pi.hThread);
+    ok(ret, "error %lu\n", GetLastError());
+    ret = CloseHandle(pi.hProcess);
+    ok(ret, "error %lu\n", GetLastError());
+
+    return;
+}
+
+static void test_fastfail(void)
+{
+    unsigned int codes[] = {
+        FAST_FAIL_LEGACY_GS_VIOLATION,
+        FAST_FAIL_VTGUARD_CHECK_FAILURE,
+        FAST_FAIL_STACK_COOKIE_CHECK_FAILURE,
+        FAST_FAIL_CORRUPT_LIST_ENTRY,
+        FAST_FAIL_INCORRECT_STACK,
+        FAST_FAIL_INVALID_ARG,
+        FAST_FAIL_GS_COOKIE_INIT,
+        FAST_FAIL_FATAL_APP_EXIT,
+        FAST_FAIL_INVALID_FAST_FAIL_CODE,
+        0xdeadbeefUL,
+    };
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(codes); i++)
+    {
+        winetest_push_context("__fastfail(%#x)", codes[i]);
+        subtest_fastfail(codes[i]);
+        winetest_pop_context();
+    }
+}
+
 static DWORD breakpoint_exceptions;
 
 static LONG CALLBACK breakpoint_handler(EXCEPTION_POINTERS *ExceptionInfo)
@@ -10664,6 +10749,13 @@ START_TEST(exception)
     if (my_argc >= 4)
     {
         void *addr;
+
+        if (strcmp(my_argv[2], "fastfail") == 0)
+        {
+            __fastfail(strtoul(my_argv[3], NULL, 0));
+            return;
+        }
+
         sscanf( my_argv[3], "%p", &addr );
 
         if (addr != &test_stage)
@@ -10811,6 +10903,7 @@ START_TEST(exception)
     test_thread_context();
     test_outputdebugstring(1, FALSE);
     test_ripevent(1);
+    test_fastfail();
     test_breakpoint(1);
     test_closehandle(0, (HANDLE)0xdeadbeef);
     /* Call of Duty WWII writes to BeingDebugged then closes an invalid handle,
-- 
GitLab


From c4c9a6951be4299850ca220450b21eeb8843fde5 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Sun, 5 Dec 2021 19:56:22 +0900
Subject: [PATCH 3/4] ntdll: Implement __fastfail().

__fastfail() is used by the Visual C++ runtime and Windows system
libraries to signal that the in-process state is corrupted and
unrecoverable.

If __fastfail() is invoked, the NT kernel raises a second-chance
non-continuable exception STATUS_STACK_BUFFER_OVERRUN.  This quickly
terminates the process, bypassing all in-process exception handlers
(since they all rely on the potentially corrupted process state).

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/ntdll/tests/exception.c    |  1 -
 dlls/ntdll/unix/signal_arm.c    | 19 +++++++++++++++++--
 dlls/ntdll/unix/signal_arm64.c  | 16 ++++++++++++++++
 dlls/ntdll/unix/signal_i386.c   |  8 ++++++++
 dlls/ntdll/unix/signal_x86_64.c |  8 ++++++++
 5 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
index 0086b18d678..3e76b001147 100644
--- a/dlls/ntdll/tests/exception.c
+++ b/dlls/ntdll/tests/exception.c
@@ -8466,7 +8466,6 @@ static void subtest_fastfail(unsigned int code)
 
     } while (de.dwDebugEventCode != EXIT_PROCESS_DEBUG_EVENT);
 
-    todo_wine
     ok(had_ff || broken(had_se) /* Win7 */, "fast fail did not occur\n");
 
     wait_child_process( pi.hProcess );
diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index 1fea76f6563..ead14303436 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -812,13 +812,28 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
     switch (get_trap_code(signal, context))
     {
     case TRAP_ARM_PRIVINFLT:   /* Invalid opcode exception */
-        if (*(WORD *)PC_sig(context) == 0xdefe)  /* breakpoint */
+        switch (*(WORD *)PC_sig(context))
         {
+        case 0xdefb:  /* __fastfail */
+        {
+            CONTEXT ctx;
+            save_context( &ctx, sigcontext );
+            rec.ExceptionCode = STATUS_STACK_BUFFER_OVERRUN;
+            rec.ExceptionAddress = (void *)ctx.Pc;
+            rec.ExceptionFlags = EH_NONCONTINUABLE;
+            rec.NumberParameters = 1;
+            rec.ExceptionInformation[0] = ctx.R0;
+            NtRaiseException( &rec, &ctx, FALSE );
+            return;
+        }
+        case 0xdefe:  /* breakpoint */
             rec.ExceptionCode = EXCEPTION_BREAKPOINT;
             rec.NumberParameters = 1;
             break;
+        default:
+            rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
+            break;
         }
-        rec.ExceptionCode = EXCEPTION_ILLEGAL_INSTRUCTION;
         break;
     case TRAP_ARM_PAGEFLT:  /* Page fault */
         rec.NumberParameters = 2;
diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index 1df97f16f13..45cb3d1bf13 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -908,6 +908,7 @@ static void bus_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 {
     EXCEPTION_RECORD rec = { 0 };
+    ucontext_t *context = sigcontext;
 
     switch (siginfo->si_code)
     {
@@ -916,6 +917,21 @@ static void trap_handler( int signal, siginfo_t *siginfo, void *sigcontext )
         break;
     case TRAP_BRKPT:
     default:
+        /* debug exceptions do not update ESR on Linux, so we fetch the instruction directly. */
+        if (!(PSTATE_sig( context ) & 0x10) && /* AArch64 (not WoW) */
+            !(PC_sig( context ) & 3) &&
+            *(ULONG *)PC_sig( context ) == 0xd43e0060UL) /* brk #0xf003 -> __fastfail */
+        {
+            CONTEXT ctx;
+            save_context( &ctx, sigcontext );
+            rec.ExceptionCode = STATUS_STACK_BUFFER_OVERRUN;
+            rec.ExceptionAddress = (void *)ctx.Pc;
+            rec.ExceptionFlags = EH_NONCONTINUABLE;
+            rec.NumberParameters = 1;
+            rec.ExceptionInformation[0] = ctx.u.X[0];
+            NtRaiseException( &rec, &ctx, FALSE );
+            return;
+        }
         rec.ExceptionCode = EXCEPTION_BREAKPOINT;
         rec.NumberParameters = 1;
         break;
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index e2a6148d609..7be0c39c424 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -1676,6 +1676,14 @@ static BOOL handle_interrupt( unsigned int interrupt, ucontext_t *sigcontext, vo
 
     switch(interrupt)
     {
+    case 0x29:
+        /* __fastfail: process state is corrupted */
+        rec->ExceptionCode = STATUS_STACK_BUFFER_OVERRUN;
+        rec->ExceptionFlags = EH_NONCONTINUABLE;
+        rec->NumberParameters = 1;
+        rec->ExceptionInformation[0] = context->Ecx;
+        NtRaiseException( rec, context, FALSE );
+        return TRUE;
     case 0x2d:
         if (!is_wow64)
         {
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index e3179e2f1b0..6c87e347eac 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -2486,6 +2486,14 @@ static inline BOOL handle_interrupt( ucontext_t *sigcontext, EXCEPTION_RECORD *r
 
     switch (ERROR_sig(sigcontext) >> 3)
     {
+    case 0x29:
+        /* __fastfail: process state is corrupted */
+        rec->ExceptionCode = STATUS_STACK_BUFFER_OVERRUN;
+        rec->ExceptionFlags = EH_NONCONTINUABLE;
+        rec->NumberParameters = 1;
+        rec->ExceptionInformation[0] = context->Rcx;
+        NtRaiseException( rec, context, FALSE );
+        return TRUE;
     case 0x2c:
         rec->ExceptionCode = STATUS_ASSERTION_FAILURE;
         break;
-- 
GitLab


From e2412025b20e63f8fcad3467c0ffcd7235f3d991 Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Sun, 5 Dec 2021 19:57:16 +0900
Subject: [PATCH 4/4] ntdll: Properly parse UDF instruction in ARM.

Today, the UDF instruction handler code assumes Thumb mode code, and
cannot recognise the UDF.W form or equivalent instructions in ARM mode
encoding.

Fix this by generalising the UDF instruction parser code.

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/ntdll/unix/signal_arm.c | 35 ++++++++++++++++++++++++++++++++---
 1 file changed, 32 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index ead14303436..c8edf22b170 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -360,6 +360,35 @@ static inline WORD get_error_code( const ucontext_t *sigcontext )
 }
 
 
+/***********************************************************************
+ *           get_udf_immediate
+ *
+ * Get the immediate operand if the PC is at a UDF instruction.
+ */
+static inline int get_udf_immediate( const ucontext_t *sigcontext )
+{
+    if (CPSR_sig(sigcontext) & 0x20)
+    {
+        WORD thumb_insn = *(WORD *)PC_sig(sigcontext);
+        if ((thumb_insn >> 8) == 0xde) return thumb_insn & 0xff;
+        if ((thumb_insn & 0xfff0) == 0xf7f0)  /* udf.w */
+        {
+            WORD ext = *(WORD *)(PC_sig(sigcontext) + 2);
+            if ((ext & 0xf000) == 0xa000) return ((thumb_insn & 0xf) << 12) | (ext & 0x0fff);
+        }
+    }
+    else
+    {
+        DWORD arm_insn = *(DWORD *)PC_sig(sigcontext);
+        if ((arm_insn & 0xfff000f0) == 0xe7f000f0)
+        {
+            return ((arm_insn >> 4) & 0xfff0) | (arm_insn & 0xf);
+        }
+    }
+    return -1;
+}
+
+
 /***********************************************************************
  *           save_context
  *
@@ -812,9 +841,9 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
     switch (get_trap_code(signal, context))
     {
     case TRAP_ARM_PRIVINFLT:   /* Invalid opcode exception */
-        switch (*(WORD *)PC_sig(context))
+        switch (get_udf_immediate( context ))
         {
-        case 0xdefb:  /* __fastfail */
+        case 0xfb:  /* __fastfail */
         {
             CONTEXT ctx;
             save_context( &ctx, sigcontext );
@@ -826,7 +855,7 @@ static void segv_handler( int signal, siginfo_t *siginfo, void *sigcontext )
             NtRaiseException( &rec, &ctx, FALSE );
             return;
         }
-        case 0xdefe:  /* breakpoint */
+        case 0xfe:  /* breakpoint */
             rec.ExceptionCode = EXCEPTION_BREAKPOINT;
             rec.NumberParameters = 1;
             break;
-- 
GitLab

From ba12b5ae8838beadc32a32a34b267b6629ede7c9 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 22 Jun 2022 16:28:08 +0200
Subject: [PATCH 1/6] winedump: Explore a bit more TPI hash elements.

Rename a couple of fields in PDB structures for clarity.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/dbghelp/msc.c     |   2 +-
 include/wine/mscvpdb.h |  10 +--
 tools/winedump/pdb.c   | 189 +++++++++++++++++++++++++++++++++++------
 3 files changed, 168 insertions(+), 33 deletions(-)

diff --git a/dlls/dbghelp/msc.c b/dlls/dbghelp/msc.c
index 5b45c474160..2be648ca578 100644
--- a/dlls/dbghelp/msc.c
+++ b/dlls/dbghelp/msc.c
@@ -2954,7 +2954,7 @@ static void pdb_convert_types_header(PDB_TYPES* types, const BYTE* image)
         types->type_size   = old->type_size;
         types->first_index = old->first_index;
         types->last_index  = old->last_index;
-        types->file        = old->file;
+        types->hash_file   = old->hash_file;
     }
     else
     {
diff --git a/tools/winedump/pdb.c b/tools/winedump/pdb.c
index 2277e6556f9..6774cd11876 100644
--- a/tools/winedump/pdb.c
+++ b/tools/winedump/pdb.c
@@ -608,18 +608,153 @@ static void pdb_dump_symbols(struct pdb_reader* reader, PDB_STREAM_INDEXES* sidx
     free(filesimage);
 }
 
-static void pdb_dump_types_hash(struct pdb_reader* reader, unsigned file, const char* strmname)
+static BOOL is_bit_set(const unsigned* dw, unsigned len, unsigned i)
 {
-    void*  hash = NULL;
-    DWORD  size;
+    if (i >= len * sizeof(unsigned) * 8) return FALSE;
+    return (dw[i >> 5] & (1u << (i & 31u))) != 0;
+}
 
-    hash = reader->read_file(reader, file);
-    if (!hash) return;
+static void pdb_dump_hash_value(const BYTE* ptr, unsigned len)
+{
+    int i;
 
-    size = pdb_get_file_size(reader, file);
+    printf("[");
+    for (i = len - 1; i >= 0; i--)
+        printf("%02x", ptr[i]);
+    printf("]");
+}
+
+static struct
+{
+    const BYTE* hash;
+    unsigned hash_size;
+} collision_arg;
+
+static int collision_compar(const void *p1, const void *p2)
+{
+    unsigned idx1 = *(unsigned*)p1;
+    unsigned idx2 = *(unsigned*)p2;
+    return memcmp(collision_arg.hash + idx1 * collision_arg.hash_size,
+                  collision_arg.hash + idx2 * collision_arg.hash_size,
+                  collision_arg.hash_size);
+}
+
+static void pdb_dump_types_hash(struct pdb_reader* reader, const PDB_TYPES* types, const char* strmname)
+{
+    void*  hash = NULL;
+    unsigned i, strmsize;
+    const unsigned* table;
+    char* strbase;
+    unsigned *collision;
+    hash = reader->read_file(reader, types->hash_file);
+    if (!hash) return;
 
     printf("Types (%s) hash:\n", strmname);
-    dump_data(hash, size, "    ");
+    strmsize = pdb_get_file_size(reader, types->hash_file);
+    if (types->hash_offset + types->hash_len > strmsize ||
+        (types->last_index - types->first_index) * types->hash_size != types->hash_len ||
+        types->search_offset + types->search_len > strmsize ||
+        types->type_remap_offset + types->type_remap_len > strmsize)
+    {
+        printf("\nIncoherent sizes... skipping\n");
+        return;
+    }
+    printf("\n\tIndexes => hash value:\n");
+    for (i = types->first_index; i < types->last_index; i++)
+    {
+        printf("\t\t%08x => ", i);
+        pdb_dump_hash_value((const BYTE*)hash + types->hash_offset + (i - types->first_index) * types->hash_size, types->hash_size);
+        printf("\n");
+    }
+    /* print collisions in hash table (if any) */
+    collision = malloc((types->last_index - types->first_index) * sizeof(unsigned));
+    if (collision)
+    {
+        unsigned head_printed = 0;
+
+        collision_arg.hash = (const BYTE*)hash + types->hash_offset;
+        collision_arg.hash_size = types->hash_size;
+
+        for (i = 0; i < types->last_index - types->first_index; i++) collision[i] = i;
+        qsort(collision, types->last_index - types->first_index, sizeof(unsigned), collision_compar);
+        for (i = 0; i < types->last_index - types->first_index; i++)
+        {
+            unsigned j;
+            for (j = i + 1; j < types->last_index - types->first_index; j++)
+                if (memcmp((const BYTE*)hash + types->hash_offset + collision[i] * types->hash_size,
+                           (const BYTE*)hash + types->hash_offset + collision[j] * types->hash_size,
+                           types->hash_size))
+                    break;
+            if (j > i + 1)
+            {
+                unsigned k;
+                if (!head_printed)
+                {
+                    printf("\n\t\tCollisions:\n");
+                    head_printed = 1;
+                }
+                printf("\t\t\tHash ");
+                pdb_dump_hash_value((const BYTE*)hash + types->hash_offset + collision[i] * types->hash_size, types->hash_size);
+                printf(":");
+                for (k = i; k < j; k++)
+                    printf(" %x", types->first_index + collision[k]);
+                printf("\n");
+                i = j - 1;
+            }
+        }
+        free(collision);
+    }
+    printf("\n\tIndexes => offsets:\n");
+    table = (const unsigned*)((const BYTE*)hash + types->search_offset);
+    for (i = 0; i < types->search_len / (2 * sizeof(unsigned)); i += 2)
+    {
+        printf("\t\t%08x => %08x\n", table[2 * i + 0], table[2 * i + 1]);
+    }
+    if (types->type_remap_len && (strbase = read_string_table(reader)))
+    {
+        unsigned num, capa, count_present, count_deleted;
+        const unsigned* present_bitset;
+        const unsigned* deleted_bitset;
+
+        printf("\n\tType remap:\n");
+        table = (const unsigned*)((const BYTE*)hash + types->type_remap_offset);
+        num = *table++;
+        capa = *table++;
+        count_present = *table++;
+        present_bitset = table;
+        table += count_present;
+        count_deleted = *table++;
+        deleted_bitset = table;
+        table += count_deleted;
+        printf("\t\tNumber of present entries: %u\n", num);
+        printf("\t\tCapacity: %u\n", capa);
+        printf("\t\tBitset present:\n");
+        printf("\t\t\tCount: %u\n", count_present);
+        printf("\t\t\tBitset: ");
+        pdb_dump_hash_value((const BYTE*)present_bitset, count_present * sizeof(unsigned));
+        printf("\n");
+        printf("\t\tBitset deleted:\n");
+        printf("\t\t\tCount: %u\n", count_deleted);
+        printf("\t\t\tBitset: ");
+        pdb_dump_hash_value((const BYTE*)deleted_bitset, count_deleted * sizeof(unsigned));
+        printf("\n");
+        for (i = 0; i < capa; ++i)
+        {
+            printf("\t\t%2u) %c",
+                   i,
+                   is_bit_set(present_bitset, count_present, i) ? 'P' :
+                   is_bit_set(deleted_bitset, count_deleted, i) ? 'D' : '_');
+            if (is_bit_set(present_bitset, count_present, i))
+            {
+                printf(" %s => ", strbase + 12 + *table++);
+                pdb_dump_hash_value((const BYTE*)table, types->hash_size);
+                table = (const unsigned*)((const BYTE*)table + types->hash_size);
+            }
+            printf("\n");
+        }
+        free(strbase);
+        printf("\n");
+    }
     free(hash);
 }
 
@@ -657,39 +792,39 @@ static void pdb_dump_types(struct pdb_reader* reader, unsigned strmidx, const ch
 
     /* Read type table */
     printf("Types (%s):\n"
-           "\tversion:        %u\n"
-           "\ttype_offset:    %08x\n"
-           "\tfirst_index:    %x\n"
-           "\tlast_index:     %x\n"
-           "\ttype_size:      %x\n"
-           "\tfile:           %x\n"
-           "\tpad:            %x\n"
-           "\thash_size:      %x\n"
-           "\thash_base:      %x\n"
-           "\thash_offset:    %x\n"
-           "\thash_len:       %x\n"
-           "\tsearch_offset:  %x\n"
-           "\tsearch_len:     %x\n"
-           "\tunknown_offset: %x\n"
-           "\tunknown_len:    %x\n",
+           "\tversion:           %u\n"
+           "\ttype_offset:       %08x\n"
+           "\tfirst_index:       %x\n"
+           "\tlast_index:        %x\n"
+           "\ttype_size:         %x\n"
+           "\thash_file:         %x\n"
+           "\tpad:               %x\n"
+           "\thash_size:         %x\n"
+           "\thash_buckets       %x\n"
+           "\thash_offset:       %x\n"
+           "\thash_len:          %x\n"
+           "\tsearch_offset:     %x\n"
+           "\tsearch_len:        %x\n"
+           "\ttype_remap_offset: %x\n"
+           "\ttype_remap_len:    %x\n",
            strmname,
            types->version,
            types->type_offset,
            types->first_index,
            types->last_index,
            types->type_size,
-           types->file,
+           types->hash_file,
            types->pad,
            types->hash_size,
-           types->hash_base,
+           types->hash_num_buckets,
            types->hash_offset,
            types->hash_len,
            types->search_offset,
            types->search_len,
-           types->unknown_offset,
-           types->unknown_len);
+           types->type_remap_offset,
+           types->type_remap_len);
     codeview_dump_types_from_block((const char*)types + types->type_offset, types->type_size);
-    pdb_dump_types_hash(reader, types->file, strmname);
+    pdb_dump_types_hash(reader, types, strmname);
     free(types);
 }
 
-- 
GitLab


From b7c231c78f84402b47c79ba744884c32ca2a8323 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 22 Jun 2022 16:28:08 +0200
Subject: [PATCH 2/6] dbghelp: Rely on first/last type index from type header.

Code now follows these guidelines:
- define PDB & Codeview internals in cvconst.h and mscvinfo.h (instead
  of having definitions in .c files, some of them being duplicate of .h
  content, and their "duplicate" values eventually diverged over time)
- index of first type comes from PDB type header (instead of always being
  hardcoded as FIRST_DEFINABLE_TYPE)
- use index of last typex from type header (instead of guessing the right
  value while parsing types, which also allows a single allocation
  instead of enlarging buffer while parsing).

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/dbghelp/msc.c     | 108 ++++++++++++++++++-----------------------
 include/wine/mscvpdb.h |   3 +-
 2 files changed, 50 insertions(+), 61 deletions(-)

diff --git a/dlls/dbghelp/msc.c b/dlls/dbghelp/msc.c
index 2be648ca578..cad76a8245c 100644
--- a/dlls/dbghelp/msc.c
+++ b/dlls/dbghelp/msc.c
@@ -132,15 +132,13 @@ static void dump(const void* ptr, unsigned len)
  * Process CodeView type information.
  */
 
-#define MAX_BUILTIN_TYPES	0x06FF
-#define FIRST_DEFINABLE_TYPE    0x1000
-
-static struct symt*     cv_basic_types[MAX_BUILTIN_TYPES];
+static struct symt*     cv_basic_types[T_MAXPREDEFINEDTYPE];
 
 struct cv_defined_module
 {
     BOOL                allowed;
-    unsigned int        num_defined_types;
+    unsigned int        first_type_index;
+    unsigned int        last_type_index;
     struct symt**       defined_types;
 };
 /* FIXME: don't make it static */
@@ -532,15 +530,12 @@ static struct symt*  codeview_get_type(unsigned int typeno, BOOL quiet)
 
     /*
      * Convert Codeview type numbers into something we can grok internally.
-     * Numbers < FIRST_DEFINABLE_TYPE are all fixed builtin types.
-     * Numbers from FIRST_DEFINABLE_TYPE and up are all user defined (structs, etc).
+     * Numbers < T_MAXPREDEFINEDTYPE all fixed builtin types.
+     * Numbers from T_FIRSTDEFINABLETYPE and up are all user defined (structs, etc).
      */
-    if (typeno < FIRST_DEFINABLE_TYPE)
-    {
-        if (typeno < MAX_BUILTIN_TYPES)
-	    symt = cv_basic_types[typeno];
-    }
-    else
+    if (typeno < T_MAXPREDEFINEDTYPE)
+        symt = cv_basic_types[typeno];
+    else if (typeno >= T_FIRSTDEFINABLETYPE)
     {
         unsigned        mod_index = typeno >> 24;
         unsigned        mod_typeno = typeno & 0x00FFFFFF;
@@ -548,12 +543,12 @@ static struct symt*  codeview_get_type(unsigned int typeno, BOOL quiet)
 
         mod = (mod_index == 0) ? cv_current_module : &cv_zmodules[mod_index];
 
-        if (mod_index >= CV_MAX_MODULES || !mod->allowed) 
+        if (mod_index >= CV_MAX_MODULES || !mod->allowed)
             FIXME("Module of index %d isn't loaded yet (%x)\n", mod_index, typeno);
         else
         {
-            if (mod_typeno - FIRST_DEFINABLE_TYPE < mod->num_defined_types)
-                symt = mod->defined_types[mod_typeno - FIRST_DEFINABLE_TYPE];
+            if (mod_typeno >= mod->first_type_index && mod_typeno < mod->last_type_index)
+                symt = mod->defined_types[mod_typeno - mod->first_type_index];
         }
     }
     if (!quiet && !symt && typeno) FIXME("Returning NULL symt for type-id %x\n", typeno);
@@ -563,22 +558,20 @@ static struct symt*  codeview_get_type(unsigned int typeno, BOOL quiet)
 struct codeview_type_parse
 {
     struct module*      module;
+    PDB_TYPES           header;
     const BYTE*         table;
     const DWORD*        offset;
-    DWORD               num;
 };
 
 static inline const void* codeview_jump_to_type(const struct codeview_type_parse* ctp, DWORD idx)
 {
-    if (idx < FIRST_DEFINABLE_TYPE) return NULL;
-    idx -= FIRST_DEFINABLE_TYPE;
-    return (idx >= ctp->num) ? NULL : (ctp->table + ctp->offset[idx]); 
+    return (idx >= ctp->header.first_index && idx < ctp->header.last_index) ?
+        ctp->table + ctp->offset[idx - ctp->header.first_index] : NULL;
 }
 
 static int codeview_add_type(unsigned int typeno, struct symt* dt)
 {
-    if (typeno < FIRST_DEFINABLE_TYPE)
-        FIXME("What the heck\n");
+    unsigned idx;
     if (!cv_current_module)
     {
         FIXME("Adding %x to non allowed module\n", typeno);
@@ -587,31 +580,19 @@ static int codeview_add_type(unsigned int typeno, struct symt* dt)
     if ((typeno >> 24) != 0)
         FIXME("No module index while inserting type-id assumption is wrong %x\n",
               typeno);
-    if (typeno - FIRST_DEFINABLE_TYPE >= cv_current_module->num_defined_types)
+    if (typeno < cv_current_module->first_type_index || typeno >= cv_current_module->last_type_index)
     {
-        if (cv_current_module->defined_types)
-        {
-            cv_current_module->num_defined_types = max( cv_current_module->num_defined_types * 2,
-                                                        typeno - FIRST_DEFINABLE_TYPE + 1 );
-            cv_current_module->defined_types = HeapReAlloc(GetProcessHeap(),
-                            HEAP_ZERO_MEMORY, cv_current_module->defined_types,
-                            cv_current_module->num_defined_types * sizeof(struct symt*));
-        }
-        else
-        {
-            cv_current_module->num_defined_types = max( 256, typeno - FIRST_DEFINABLE_TYPE + 1 );
-            cv_current_module->defined_types = HeapAlloc(GetProcessHeap(),
-                            HEAP_ZERO_MEMORY,
-                            cv_current_module->num_defined_types * sizeof(struct symt*));
-        }
-        if (cv_current_module->defined_types == NULL) return FALSE;
+        FIXME("Type number %x out of bounds [%x, %x)\n",
+              typeno, cv_current_module->first_type_index, typeno >= cv_current_module->last_type_index);
+        return FALSE;
     }
-    if (cv_current_module->defined_types[typeno - FIRST_DEFINABLE_TYPE])
+    idx = typeno - cv_current_module->first_type_index;
+    if (cv_current_module->defined_types[idx])
     {
-        if (cv_current_module->defined_types[typeno - FIRST_DEFINABLE_TYPE] != dt)
+        if (cv_current_module->defined_types[idx] != dt)
             FIXME("Overwriting at %x\n", typeno);
     }
-    cv_current_module->defined_types[typeno - FIRST_DEFINABLE_TYPE] = dt;
+    cv_current_module->defined_types[idx] = dt;
     return TRUE;
 }
 
@@ -622,10 +603,11 @@ static void codeview_clear_type_table(void)
     for (i = 0; i < CV_MAX_MODULES; i++)
     {
         if (cv_zmodules[i].allowed)
-            HeapFree(GetProcessHeap(), 0, cv_zmodules[i].defined_types);
+            free(cv_zmodules[i].defined_types);
         cv_zmodules[i].allowed = FALSE;
         cv_zmodules[i].defined_types = NULL;
-        cv_zmodules[i].num_defined_types = 0;
+        cv_zmodules[i].first_type_index = 0;
+        cv_zmodules[i].last_type_index = 0;
     }
     cv_current_module = NULL;
 }
@@ -1381,10 +1363,15 @@ static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
 
 static BOOL codeview_parse_type_table(struct codeview_type_parse* ctp)
 {
-    unsigned int                curr_type = FIRST_DEFINABLE_TYPE;
+    unsigned int                curr_type;
     const union codeview_type*  type;
 
-    for (curr_type = FIRST_DEFINABLE_TYPE; curr_type < FIRST_DEFINABLE_TYPE + ctp->num; curr_type++)
+    cv_current_module->first_type_index = ctp->header.first_index;
+    cv_current_module->last_type_index = ctp->header.last_index;
+    cv_current_module->defined_types = calloc(ctp->header.last_index - ctp->header.first_index,
+                                              sizeof(*cv_current_module->defined_types));
+
+    for (curr_type = ctp->header.first_index; curr_type < ctp->header.last_index; curr_type++)
     {
         type = codeview_jump_to_type(ctp, curr_type);
 
@@ -3053,15 +3040,14 @@ static BOOL pdb_init_type_parse(const struct msc_debug_info* msc_dbg,
                                 struct codeview_type_parse* ctp,
                                 BYTE* image)
 {
-    PDB_TYPES types;
-    DWORD total;
     const BYTE* ptr;
     DWORD* offset;
+    int i;
 
-    pdb_convert_types_header(&types, image);
+    pdb_convert_types_header(&ctp->header, image);
 
     /* Check for unknown versions */
-    switch (types.version)
+    switch (ctp->header.version)
     {
     case 19950410:      /* VC 4.0 */
     case 19951122:
@@ -3231,7 +3231,7 @@ static BOOL pdb_init_type_parse(const st
     case 20040203:      /* VC 8.0 */
         break;
     default:
-        ERR("-Unknown type info version %ld\n", types.version);
+        ERR("-Unknown type info version %ld\n", ctp->header.version);
         return FALSE;
     }
     if (ctp->header.hash_size != 2 && ctp->header.hash_size != 4)
@@ -3248,17 +3248,17 @@ static BOOL pdb_init_type_parse(const st
     }
 
     ctp->module = msc_dbg->module;
-    /* reconstruct the types offset...
-     * FIXME: maybe it's present in the newest PDB_TYPES structures
+    /* Reconstruct the types offset table
+     * Note: the hash subfile of the PDB_TYPES only contains a partial table
+     * (not all the indexes are present, so it requires first a binary search in partial table,
+     * followed by a linear search...)
      */
-    total = types.last_index - types.first_index + 1;
-    offset = HeapAlloc(GetProcessHeap(), 0, sizeof(DWORD) * total);
-    if (!offset) return FALSE;
-    ctp->table = ptr = image + types.type_offset;
-    ctp->num = 0;
-    while (ptr < ctp->table + types.type_size && ctp->num < total)
+    offset = malloc(sizeof(DWORD) * (ctp->header.last_index - ctp->header.first_index));
+    if (!offset) goto oom;
+    ctp->table = ptr = image + ctp->header.type_offset;
+    for (i = ctp->header.first_index; i < ctp->header.last_index; i++)
     {
-        offset[ctp->num++] = ptr - ctp->table;
+        offset[i - ctp->header.first_index] = ptr - ctp->table;
         ptr += ((const union codeview_type*)ptr)->generic.len + 2;
     }
     ctp->offset = offset;
@@ -3882,7 +3868,9 @@ static BOOL codeview_process_info(const struct process* pcs,
                 types = (const OMFGlobalTypes*)(msc_dbg->root + ent->lfo);
                 ctp.module = msc_dbg->module;
                 ctp.offset = (const DWORD*)(types + 1);
-                ctp.num    = types->cTypes;
+                memset(&ctp.header, 0, sizeof(ctp.header));
+                ctp.header.first_index = T_FIRSTDEFINABLETYPE;
+                ctp.header.last_index = ctp.header.first_index + types->cTypes;
                 ctp.table  = (const BYTE*)(ctp.offset + types->cTypes);
 
                 cv_current_module = &cv_zmodules[0];
-- 
GitLab


From eb14fad72afe7d507f439c10ef42998dbb733858 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 22 Jun 2022 16:28:09 +0200
Subject: [PATCH 3/6] mscvpdb.h: Redefine property with bitfields.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/dbghelp/msc.c     | 10 +++++-----
 include/wine/mscvpdb.h | 37 ++++++++++++++++++++++++++++---------
 tools/winedump/msc.c   | 38 +++++++++++++++++++-------------------
 3 files changed, 52 insertions(+), 33 deletions(-)

diff --git a/dlls/dbghelp/msc.c b/dlls/dbghelp/msc.c
index cad76a8245c..d23d89e4f2d 100644
--- a/dlls/dbghelp/msc.c
+++ b/dlls/dbghelp/msc.c
@@ -1015,7 +1015,7 @@ static struct symt* codeview_add_type_enum(struct codeview_type_parse* ctp,
 static struct symt* codeview_add_type_struct(struct codeview_type_parse* ctp,
                                              struct symt* existing,
                                              const char* name, int structlen,
-                                             enum UdtKind kind, unsigned property)
+                                             enum UdtKind kind, cv_property_t property)
 {
     struct symt_udt*    symt;
 
@@ -1045,7 +1045,7 @@ static struct symt* codeview_add_type_struct(struct codeview_type_parse* ctp,
     {
         if (!(symt = codeview_cast_symt(existing, SymTagUDT))) return NULL;
         /* should also check that all fields are the same */
-        if (!(property & 0x80)) /* 0x80 = forward declaration */
+        if (!property.is_forward_defn)
         {
             if (!symt->size) /* likely prior forward declaration, set UDT size */
                 symt_set_udt_size(ctp->module, symt, structlen);
@@ -1195,7 +1195,7 @@ static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
         if (details)
         {
             codeview_add_type(curr_type, symt);
-            if (!(type->struct_v1.property & 0x80)) /* 0x80 = forward declaration */
+            if (!type->struct_v1.property.is_forward_defn)
                 codeview_add_type_struct_field_list(ctp, (struct symt_udt*)symt,
                                                     type->struct_v1.fieldlist);
         }
@@ -1211,7 +1211,7 @@ static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
         if (details)
         {
             codeview_add_type(curr_type, symt);
-            if (!(type->struct_v2.property & 0x80)) /* 0x80 = forward declaration */
+            if (!type->struct_v2.property.is_forward_defn)
                 codeview_add_type_struct_field_list(ctp, (struct symt_udt*)symt,
                                                     type->struct_v2.fieldlist);
         }
@@ -1227,7 +1227,7 @@ static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
         if (details)
         {
             codeview_add_type(curr_type, symt);
-            if (!(type->struct_v3.property & 0x80)) /* 0x80 = forward declaration */
+            if (!type->struct_v3.property.is_forward_defn)
                 codeview_add_type_struct_field_list(ctp, (struct symt_udt*)symt,
                                                     type->struct_v3.fieldlist);
         }
diff --git a/tools/winedump/msc.c b/tools/winedump/msc.c
index a7e3df961bb..8c38dd1819e 100644
--- a/tools/winedump/msc.c
+++ b/tools/winedump/msc.c
@@ -227,28 +227,28 @@ static const char* get_attr(unsigned attr)
     return tmp;
 }
 
-static const char* get_property(unsigned prop)
+static const char* get_property(cv_property_t prop)
 {
     static char tmp[1024];
     unsigned    pos = 0;
 
-    if (!prop) return "none";
 #define X(s) {if (pos) tmp[pos++] = ';'; strcpy(tmp + pos, s); pos += strlen(s);}
-    if (prop & 0x0001) X("packed");
-    if (prop & 0x0002) X("w/{cd}tor");
-    if (prop & 0x0004) X("w/overloaded-ops");
-    if (prop & 0x0008) X("nested-class");
-    if (prop & 0x0010) X("has-nested-classes");
-    if (prop & 0x0020) X("w/overloaded-assign");
-    if (prop & 0x0040) X("w/casting-methods");
-    if (prop & 0x0080) X("forward");
-    if (prop & 0x0100) X("scoped");
-    if (prop & 0x0200) X("decorated-name");
-    if (prop & 0x0400) X("sealed-name");
-    if (prop & 0x1800) pos += sprintf(tmp, "hfa%x", (prop >> 11) & 3);
-    if (prop & 0x2000) X("intrinsic");
-    if (prop & 0xC000) pos += sprintf(tmp, "mocom%x", prop >> 14);
+    if (prop.is_packed)                 X("packed");
+    if (prop.has_ctor)                  X("w/{cd}tor");
+    if (prop.has_overloaded_operator)   X("w/overloaded-ops");
+    if (prop.is_nested)                 X("nested-class");
+    if (prop.has_nested)                X("has-nested-classes");
+    if (prop.has_overloaded_assign)     X("w/overloaded-assign");
+    if (prop.has_operator_cast)         X("w/casting-methods");
+    if (prop.is_forward_defn)           X("forward");
+    if (prop.is_scoped)                 X("scoped");
+    if (prop.has_decorated_name)        X("decorated-name");
+    if (prop.is_sealed)                 X("sealed");
+    if (prop.hfa)                       pos += sprintf(tmp, "hfa%x", prop.hfa);
+    if (prop.is_intrinsic)              X("intrinsic");
+    if (prop.mocom)                     pos += sprintf(tmp, "mocom%x", prop.mocom);
 #undef X
+    if (!pos) return "none";
 
     tmp[pos] = '\0';
     assert(pos < sizeof(tmp));
@@ -902,7 +902,7 @@ static void codeview_dump_one_type(unsigned curr_type, const union codeview_type
                str, type->struct_v3.n_element, get_property(type->struct_v3.property),
                type->struct_v3.fieldlist, type->struct_v3.derived,
                type->struct_v3.vshape, value);
-        if (type->union_v3.property & 0x200)
+        if (type->union_v3.property.has_decorated_name)
             printf("\t\tDecorated name:%s\n", str + strlen(str) + 1);
         break;
 
@@ -929,7 +929,7 @@ static void codeview_dump_one_type(unsigned curr_type, const union codeview_type
                curr_type, str, type->union_v3.count,
                get_property(type->union_v3.property),
                type->union_v3.fieldlist, value);
-        if (type->union_v3.property & 0x200)
+        if (type->union_v3.property.has_decorated_name)
             printf("\t\tDecorated name:%s\n", str + strlen(str) + 1);
         break;
 
@@ -958,7 +958,7 @@ static void codeview_dump_one_type(unsigned curr_type, const union codeview_type
                type->enumeration_v3.fieldlist,
                type->enumeration_v3.count,
                get_property(type->enumeration_v3.property));
-        if (type->union_v3.property & 0x200)
+        if (type->union_v3.property.has_decorated_name)
             printf("\t\tDecorated name:%s\n", type->enumeration_v3.name + strlen(type->enumeration_v3.name) + 1);
         break;
 
-- 
GitLab


From ddbd341bd0baa663338326246e2b05d8651743ff Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 22 Jun 2022 16:28:09 +0200
Subject: [PATCH 4/6] dbghelp: Clearly separate the type loading into two
 passes.

- create (contentless) UDT & enum in first pass
- fill UDT&enum content and load the rest of types in second pass.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/dbghelp/msc.c | 491 +++++++++++++++++++++++----------------------
 1 file changed, 246 insertions(+), 245 deletions(-)

diff --git a/dlls/dbghelp/msc.c b/dlls/dbghelp/msc.c
index d23d89e4f2d..c177d0639d6 100644
--- a/dlls/dbghelp/msc.c
+++ b/dlls/dbghelp/msc.c
@@ -614,7 +614,7 @@ static void codeview_clear_type_table(void)
 
 static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
                                             unsigned curr_type,
-                                            const union codeview_type* type, BOOL details);
+                                            const union codeview_type* type);
 
 static void* codeview_cast_symt(struct symt* symt, enum SymTagEnum tag)
 {
@@ -627,7 +627,7 @@ static void* codeview_cast_symt(struct symt* symt, enum SymTagEnum tag)
 }
 
 static struct symt* codeview_fetch_type(struct codeview_type_parse* ctp,
-                                        unsigned typeno, BOOL details)
+                                        unsigned typeno)
 {
     struct symt*                symt;
     const union codeview_type*  p;
@@ -635,29 +635,45 @@ static struct symt* codeview_fetch_type(struct codeview_type_parse* ctp,
     if (!typeno) return NULL;
     if ((symt = codeview_get_type(typeno, TRUE))) return symt;
 
-    /* forward declaration */
-    if (!(p = codeview_jump_to_type(ctp, typeno)))
+    if ((p = codeview_jump_to_type(ctp, typeno)))
+        symt = codeview_parse_one_type(ctp, typeno, p);
+    if (!symt) FIXME("Couldn't load type %x\n", typeno);
+    return symt;
+}
+
+/* We call 'forwardable' a type which can have a forward declaration, and we need to merge
+ * (when they both exist) the type record of the forward declaration and the type record
+ * of the full definition into a single symt.
+ */
+static BOOL codeview_is_forwardable_type(const union codeview_type* type)
+{
+    switch (type->generic.id)
     {
-        FIXME("Cannot locate type %x\n", typeno);
-        return NULL;
+    case LF_CLASS_V1:
+    case LF_CLASS_V2:
+    case LF_CLASS_V3:
+    case LF_ENUM_V1:
+    case LF_ENUM_V2:
+    case LF_ENUM_V3:
+    case LF_STRUCTURE_V1:
+    case LF_STRUCTURE_V2:
+    case LF_STRUCTURE_V3:
+    case LF_UNION_V1:
+    case LF_UNION_V2:
+    case LF_UNION_V3:
+        return TRUE;
+    default:
+        return FALSE;
     }
-    symt = codeview_parse_one_type(ctp, typeno, p, details);
-    if (!symt) FIXME("Couldn't load forward type %x\n", typeno);
-    return symt;
 }
 
 static struct symt* codeview_add_type_pointer(struct codeview_type_parse* ctp,
-                                              struct symt* existing,
                                               unsigned int pointee_type)
 {
     struct symt* pointee;
 
-    if (existing)
-    {
-        existing = codeview_cast_symt(existing, SymTagPointerType);
-        return existing;
-    }
-    pointee = codeview_fetch_type(ctp, pointee_type, FALSE);
+    pointee = codeview_fetch_type(ctp, pointee_type);
+    if (!pointee) return NULL;
     return &symt_new_pointer(ctp->module, pointee, ctp->module->cpu->word_size)->symt;
 }
 
@@ -667,8 +683,8 @@ static struct symt* codeview_add_type_array(struct codeview_type_parse* ctp,
                                             unsigned int indextype,
                                             unsigned int arr_len)
 {
-    struct symt*        elem = codeview_fetch_type(ctp, elemtype, FALSE);
-    struct symt*        index = codeview_fetch_type(ctp, indextype, FALSE);
+    struct symt*        elem = codeview_fetch_type(ctp, elemtype);
+    struct symt*        index = codeview_fetch_type(ctp, indextype);
     DWORD64             elem_size;
     DWORD               count = 0;
 
@@ -681,14 +697,20 @@ static struct symt* codeview_add_type_array(struct codeview_type_parse* ctp,
     return &symt_new_array(ctp->module, 0, count, elem, index)->symt;
 }
 
-static BOOL codeview_add_type_enum_field_list(struct module* module,
+static BOOL codeview_add_type_enum_field_list(struct codeview_type_parse* ctp,
                                               struct symt_enum* symt,
-                                              const union codeview_reftype* ref_type)
+                                              unsigned typeno)
 {
-    const unsigned char*                ptr = ref_type->fieldlist.list;
-    const unsigned char*                last = (const BYTE*)ref_type + ref_type->generic.len + 2;
+    const union codeview_reftype*       ref_type;
+    const unsigned char*                ptr;
+    const unsigned char*                last;
     const union codeview_fieldtype*     type;
 
+    if (!typeno) return TRUE;
+    if (!(ref_type = codeview_jump_to_type(ctp, typeno))) return FALSE;
+    ptr = ref_type->fieldlist.list;
+    last = (const BYTE*)ref_type + ref_type->generic.len + 2;
+
     while (ptr < last)
     {
         if (*ptr >= 0xf0)       /* LF_PAD... */
@@ -706,7 +728,7 @@ static BOOL codeview_add_type_enum_field_list(struct module* module,
             int value, vlen = numeric_leaf(&value, &type->enumerate_v1.value);
             const struct p_string* p_name = (const struct p_string*)((const unsigned char*)&type->enumerate_v1.value + vlen);
 
-            symt_add_enum_element(module, symt, terminate_string(p_name), value);
+            symt_add_enum_element(ctp->module, symt, terminate_string(p_name), value);
             ptr += 2 + 2 + vlen + (1 + p_name->namelen);
             break;
         }
@@ -715,7 +737,7 @@ static BOOL codeview_add_type_enum_field_list(struct module* module,
             int value, vlen = numeric_leaf(&value, &type->enumerate_v3.value);
             const char* name = (const char*)&type->enumerate_v3.value + vlen;
 
-            symt_add_enum_element(module, symt, name, value);
+            symt_add_enum_element(ctp->module, symt, name, value);
             ptr += 2 + 2 + vlen + (1 + strlen(name));
             break;
         }
@@ -741,19 +763,19 @@ static void codeview_add_udt_element(struct codeview_type_parse* ctp,
         {
         case LF_BITFIELD_V1:
             symt_add_udt_element(ctp->module, symt, name,
-                                 codeview_fetch_type(ctp, cv_type->bitfield_v1.type, FALSE),
+                                 codeview_fetch_type(ctp, cv_type->bitfield_v1.type),
                                  value, cv_type->bitfield_v1.bitoff,
                                  cv_type->bitfield_v1.nbits);
             return;
         case LF_BITFIELD_V2:
             symt_add_udt_element(ctp->module, symt, name,
-                                 codeview_fetch_type(ctp, cv_type->bitfield_v2.type, FALSE),
+                                 codeview_fetch_type(ctp, cv_type->bitfield_v2.type),
                                  value, cv_type->bitfield_v2.bitoff,
                                  cv_type->bitfield_v2.nbits);
             return;
         }
     }
-    subtype = codeview_fetch_type(ctp, type, FALSE);
+    subtype = codeview_fetch_type(ctp, type);
 
     if (subtype)
     {
@@ -985,60 +1007,30 @@ static int codeview_add_type_struct_field_list(struct codeview_type_parse* ctp,
     return TRUE;
 }
 
-static struct symt* codeview_add_type_enum(struct codeview_type_parse* ctp,
-                                           struct symt* existing,
-                                           const char* name,
-                                           unsigned fieldlistno,
-                                           unsigned basetype)
-{
-    struct symt_enum*   symt;
-
-    if (existing)
-    {
-        if (!(symt = codeview_cast_symt(existing, SymTagEnum))) return NULL;
-        /* should also check that all fields are the same */
-    }
-    else
-    {
-        symt = symt_new_enum(ctp->module, name,
-                             codeview_fetch_type(ctp, basetype, FALSE));
-        if (fieldlistno)
-        {
-            const union codeview_reftype* fieldlist;
-            fieldlist = codeview_jump_to_type(ctp, fieldlistno);
-            codeview_add_type_enum_field_list(ctp->module, symt, fieldlist);
-        }
-    }
-    return &symt->symt;
-}
-
 static struct symt* codeview_add_type_struct(struct codeview_type_parse* ctp,
-                                             struct symt* existing,
                                              const char* name, int structlen,
                                              enum UdtKind kind, cv_property_t property)
 {
     struct symt_udt*    symt;
+    struct symt*        existing = NULL;
 
     /* if we don't have an existing type, try to find one with same name
      * FIXME: what to do when several types in different CUs have same name ?
      */
-    if (!existing)
+    void*                       ptr;
+    struct symt_ht*             type;
+    struct hash_table_iter      hti;
+
+    hash_table_iter_init(&ctp->module->ht_types, &hti, name);
+    while ((ptr = hash_table_iter_up(&hti)))
     {
-        void*                       ptr;
-        struct symt_ht*             type;
-        struct hash_table_iter      hti;
+        type = CONTAINING_RECORD(ptr, struct symt_ht, hash_elt);
 
-        hash_table_iter_init(&ctp->module->ht_types, &hti, name);
-        while ((ptr = hash_table_iter_up(&hti)))
+        if (type->symt.tag == SymTagUDT &&
+            type->hash_elt.name && !strcmp(type->hash_elt.name, name))
         {
-            type = CONTAINING_RECORD(ptr, struct symt_ht, hash_elt);
-
-            if (type->symt.tag == SymTagUDT &&
-                type->hash_elt.name && !strcmp(type->hash_elt.name, name))
-            {
-                existing = &type->symt;
-                break;
-            }
+            existing = &type->symt;
+            break;
         }
     }
     if (existing)
@@ -1058,21 +1050,12 @@ static struct symt* codeview_add_type_struct(struct codeview_type_parse* ctp,
     return &symt->symt;
 }
 
-static struct symt* codeview_new_func_signature(struct codeview_type_parse* ctp, 
-                                                struct symt* existing,
+static struct symt* codeview_new_func_signature(struct codeview_type_parse* ctp,
                                                 enum CV_call_e call_conv)
 {
     struct symt_function_signature*     sym;
 
-    if (existing)
-    {
-        sym = codeview_cast_symt(existing, SymTagFunctionType);
-        if (!sym) return NULL;
-    }
-    else
-    {
-        sym = symt_new_function_signature(ctp->module, NULL, call_conv);
-    }
+    sym = symt_new_function_signature(ctp->module, NULL, call_conv);
     return &sym->symt;
 }
 
@@ -1083,7 +1066,7 @@ static void codeview_add_func_signature_args(struct codeview_type_parse* ctp,
 {
     const union codeview_reftype*       reftype;
 
-    sym->rettype = codeview_fetch_type(ctp, ret_type, FALSE);
+    sym->rettype = codeview_fetch_type(ctp, ret_type);
     if (args_list && (reftype = codeview_jump_to_type(ctp, args_list)))
     {
         unsigned int i;
@@ -1092,12 +1075,12 @@ static void codeview_add_func_signature_args(struct codeview_type_parse* ctp,
         case LF_ARGLIST_V1:
             for (i = 0; i < reftype->arglist_v1.num; i++)
                 symt_add_function_signature_parameter(ctp->module, sym,
-                                                      codeview_fetch_type(ctp, reftype->arglist_v1.args[i], FALSE));
+                                                      codeview_fetch_type(ctp, reftype->arglist_v1.args[i]));
             break;
         case LF_ARGLIST_V2:
             for (i = 0; i < reftype->arglist_v2.num; i++)
                 symt_add_function_signature_parameter(ctp->module, sym,
-                                                      codeview_fetch_type(ctp, reftype->arglist_v2.args[i], FALSE));
+                                                      codeview_fetch_type(ctp, reftype->arglist_v2.args[i]));
             break;
         default:
             FIXME("Unexpected leaf %x for signature's pmt\n", reftype->generic.id);
@@ -1107,15 +1090,12 @@ static void codeview_add_func_signature_args(struct codeview_type_parse* ctp,
 
 static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
                                             unsigned curr_type,
-                                            const union codeview_type* type, BOOL details)
+                                            const union codeview_type* type)
 {
-    struct symt*                symt;
+    struct symt*                symt = NULL;
     int                         value, leaf_len;
     const struct p_string*      p_name;
     const char*                 c_name;
-    struct symt*                existing;
-
-    existing = codeview_get_type(curr_type, TRUE);
 
     switch (type->generic.id)
     {
@@ -1129,7 +1109,7 @@ static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
              type->modifier_v1.attribute & 0x02 ? "volatile " : "",
              type->modifier_v1.attribute & 0x04 ? "unaligned " : "",
              type->modifier_v1.attribute & ~0x07 ? "unknown " : "");
-        symt = codeview_fetch_type(ctp, type->modifier_v1.type, details);
+        symt = codeview_fetch_type(ctp, type->modifier_v1.type);
         break;
     case LF_MODIFIER_V2:
         /* FIXME: we don't handle modifiers, but readd previous type on the curr_type */
@@ -1139,214 +1119,141 @@ static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
              type->modifier_v2.attribute & 0x02 ? "volatile " : "",
              type->modifier_v2.attribute & 0x04 ? "unaligned " : "",
              type->modifier_v2.attribute & ~0x07 ? "unknown " : "");
-        symt = codeview_fetch_type(ctp, type->modifier_v2.type, details);
+        symt = codeview_fetch_type(ctp, type->modifier_v2.type);
         break;
 
     case LF_POINTER_V1:
-        symt = codeview_add_type_pointer(ctp, existing, type->pointer_v1.datatype);
+        symt = codeview_add_type_pointer(ctp, type->pointer_v1.datatype);
         break;
     case LF_POINTER_V2:
-        symt = codeview_add_type_pointer(ctp, existing, type->pointer_v2.datatype);
+        symt = codeview_add_type_pointer(ctp, type->pointer_v2.datatype);
         break;
 
     case LF_ARRAY_V1:
-        if (existing) symt = codeview_cast_symt(existing, SymTagArrayType);
-        else
-        {
-            leaf_len = numeric_leaf(&value, &type->array_v1.arrlen);
-            p_name = (const struct p_string*)((const unsigned char*)&type->array_v1.arrlen + leaf_len);
-            symt = codeview_add_type_array(ctp, terminate_string(p_name),
-                                           type->array_v1.elemtype,
-                                           type->array_v1.idxtype, value);
-        }
+        leaf_len = numeric_leaf(&value, &type->array_v1.arrlen);
+        p_name = (const struct p_string*)((const unsigned char*)&type->array_v1.arrlen + leaf_len);
+        symt = codeview_add_type_array(ctp, terminate_string(p_name),
+                                       type->array_v1.elemtype,
+                                       type->array_v1.idxtype, value);
         break;
     case LF_ARRAY_V2:
-        if (existing) symt = codeview_cast_symt(existing, SymTagArrayType);
-        else
-        {
-            leaf_len = numeric_leaf(&value, &type->array_v2.arrlen);
-            p_name = (const struct p_string*)((const unsigned char*)&type->array_v2.arrlen + leaf_len);
+        leaf_len = numeric_leaf(&value, &type->array_v2.arrlen);
+        p_name = (const struct p_string*)((const unsigned char*)&type->array_v2.arrlen + leaf_len);
 
-            symt = codeview_add_type_array(ctp, terminate_string(p_name),
-                                           type->array_v2.elemtype,
-                                           type->array_v2.idxtype, value);
-        }
+        symt = codeview_add_type_array(ctp, terminate_string(p_name),
+                                       type->array_v2.elemtype,
+                                       type->array_v2.idxtype, value);
         break;
     case LF_ARRAY_V3:
-        if (existing) symt = codeview_cast_symt(existing, SymTagArrayType);
-        else
-        {
-            leaf_len = numeric_leaf(&value, &type->array_v3.arrlen);
-            c_name = (const char*)&type->array_v3.arrlen + leaf_len;
+        leaf_len = numeric_leaf(&value, &type->array_v3.arrlen);
+        c_name = (const char*)&type->array_v3.arrlen + leaf_len;
 
-            symt = codeview_add_type_array(ctp, c_name,
-                                           type->array_v3.elemtype,
-                                           type->array_v3.idxtype, value);
-        }
+        symt = codeview_add_type_array(ctp, c_name,
+                                       type->array_v3.elemtype,
+                                       type->array_v3.idxtype, value);
         break;
 
     case LF_STRUCTURE_V1:
     case LF_CLASS_V1:
-        leaf_len = numeric_leaf(&value, &type->struct_v1.structlen);
-        p_name = (const struct p_string*)((const unsigned char*)&type->struct_v1.structlen + leaf_len);
-        symt = codeview_add_type_struct(ctp, existing, terminate_string(p_name), value,
-                                        type->generic.id == LF_CLASS_V1 ? UdtClass : UdtStruct,
-                                        type->struct_v1.property);
-        if (details)
-        {
-            codeview_add_type(curr_type, symt);
-            if (!type->struct_v1.property.is_forward_defn)
-                codeview_add_type_struct_field_list(ctp, (struct symt_udt*)symt,
-                                                    type->struct_v1.fieldlist);
-        }
+        if (!type->struct_v1.property.is_forward_defn)
+            codeview_add_type_struct_field_list(ctp, (struct symt_udt*)codeview_get_type(curr_type, TRUE),
+                                                type->struct_v1.fieldlist);
         break;
 
     case LF_STRUCTURE_V2:
     case LF_CLASS_V2:
-        leaf_len = numeric_leaf(&value, &type->struct_v2.structlen);
-        p_name = (const struct p_string*)((const unsigned char*)&type->struct_v2.structlen + leaf_len);
-        symt = codeview_add_type_struct(ctp, existing, terminate_string(p_name), value,
-                                        type->generic.id == LF_CLASS_V2 ? UdtClass : UdtStruct,
-                                        type->struct_v2.property);
-        if (details)
-        {
-            codeview_add_type(curr_type, symt);
-            if (!type->struct_v2.property.is_forward_defn)
-                codeview_add_type_struct_field_list(ctp, (struct symt_udt*)symt,
-                                                    type->struct_v2.fieldlist);
-        }
+        if (!type->struct_v2.property.is_forward_defn)
+            codeview_add_type_struct_field_list(ctp, (struct symt_udt*)codeview_get_type(curr_type, TRUE),
+                                                type->struct_v2.fieldlist);
         break;
 
     case LF_STRUCTURE_V3:
     case LF_CLASS_V3:
-        leaf_len = numeric_leaf(&value, &type->struct_v3.structlen);
-        c_name = (const char*)&type->struct_v3.structlen + leaf_len;
-        symt = codeview_add_type_struct(ctp, existing, c_name, value,
-                                        type->generic.id == LF_CLASS_V3 ? UdtClass : UdtStruct,
-                                        type->struct_v3.property);
-        if (details)
-        {
-            codeview_add_type(curr_type, symt);
-            if (!type->struct_v3.property.is_forward_defn)
-                codeview_add_type_struct_field_list(ctp, (struct symt_udt*)symt,
-                                                    type->struct_v3.fieldlist);
-        }
+        if (!type->struct_v3.property.is_forward_defn)
+            codeview_add_type_struct_field_list(ctp, (struct symt_udt*)codeview_get_type(curr_type, TRUE),
+                                                type->struct_v3.fieldlist);
         break;
 
     case LF_UNION_V1:
-        leaf_len = numeric_leaf(&value, &type->union_v1.un_len);
-        p_name = (const struct p_string*)((const unsigned char*)&type->union_v1.un_len + leaf_len);
-        symt = codeview_add_type_struct(ctp, existing, terminate_string(p_name),
-                                        value, UdtUnion, type->union_v1.property);
-        if (details)
-        {
-            codeview_add_type(curr_type, symt);
-            codeview_add_type_struct_field_list(ctp, (struct symt_udt*)symt,
+        if (!type->union_v1.property.is_forward_defn)
+            codeview_add_type_struct_field_list(ctp, (struct symt_udt*)codeview_get_type(curr_type, TRUE),
                                                 type->union_v1.fieldlist);
-        }
         break;
 
     case LF_UNION_V2:
-        leaf_len = numeric_leaf(&value, &type->union_v2.un_len);
-        p_name = (const struct p_string*)((const unsigned char*)&type->union_v2.un_len + leaf_len);
-        symt = codeview_add_type_struct(ctp, existing, terminate_string(p_name),
-                                        value, UdtUnion, type->union_v2.property);
-        if (details)
-        {
-            codeview_add_type(curr_type, symt);
-            codeview_add_type_struct_field_list(ctp, (struct symt_udt*)symt,
+        if (!type->union_v2.property.is_forward_defn)
+            codeview_add_type_struct_field_list(ctp, (struct symt_udt*)codeview_get_type(curr_type, TRUE),
                                                 type->union_v2.fieldlist);
-        }
         break;
 
     case LF_UNION_V3:
-        leaf_len = numeric_leaf(&value, &type->union_v3.un_len);
-        c_name = (const char*)&type->union_v3.un_len + leaf_len;
-        symt = codeview_add_type_struct(ctp, existing, c_name,
-                                        value, UdtUnion, type->union_v3.property);
-        if (details)
-        {
-            codeview_add_type(curr_type, symt);
-            codeview_add_type_struct_field_list(ctp, (struct symt_udt*)symt,
+        if (!type->union_v3.property.is_forward_defn)
+            codeview_add_type_struct_field_list(ctp, (struct symt_udt*)codeview_get_type(curr_type, TRUE),
                                                 type->union_v3.fieldlist);
-        }
         break;
 
     case LF_ENUM_V1:
-        symt = codeview_add_type_enum(ctp, existing,
-                                      terminate_string(&type->enumeration_v1.p_name),
-                                      type->enumeration_v1.fieldlist,
-                                      type->enumeration_v1.type);
+        {
+            struct symt_enum* senum = (struct symt_enum*)codeview_get_type(curr_type, TRUE);
+            senum->base_type = codeview_fetch_type(ctp, type->enumeration_v1.type);
+            codeview_add_type_enum_field_list(ctp, senum, type->enumeration_v1.fieldlist);
+        }
         break;
 
     case LF_ENUM_V2:
-        symt = codeview_add_type_enum(ctp, existing,
-                                      terminate_string(&type->enumeration_v2.p_name),
-                                      type->enumeration_v2.fieldlist,
-                                      type->enumeration_v2.type);
+        {
+            struct symt_enum* senum = (struct symt_enum*)codeview_get_type(curr_type, TRUE);
+            senum->base_type = codeview_fetch_type(ctp, type->enumeration_v2.type);
+            codeview_add_type_enum_field_list(ctp, senum, type->enumeration_v2.fieldlist);
+        }
         break;
 
     case LF_ENUM_V3:
-        symt = codeview_add_type_enum(ctp, existing, type->enumeration_v3.name,
-                                      type->enumeration_v3.fieldlist,
-                                      type->enumeration_v3.type);
+        {
+            struct symt_enum* senum = (struct symt_enum*)codeview_get_type(curr_type, TRUE);
+            senum->base_type = codeview_fetch_type(ctp, type->enumeration_v3.type);
+            codeview_add_type_enum_field_list(ctp, senum, type->enumeration_v3.fieldlist);
+        }
         break;
 
     case LF_PROCEDURE_V1:
-        symt = codeview_new_func_signature(ctp, existing, type->procedure_v1.callconv);
-        if (details)
-        {
-            codeview_add_type(curr_type, symt);
-            codeview_add_func_signature_args(ctp,
-                                             (struct symt_function_signature*)symt,
-                                             type->procedure_v1.rvtype,
-                                             type->procedure_v1.arglist);
-        }
+        symt = codeview_new_func_signature(ctp, type->procedure_v1.callconv);
+        codeview_add_func_signature_args(ctp,
+                                         (struct symt_function_signature*)symt,
+                                         type->procedure_v1.rvtype,
+                                         type->procedure_v1.arglist);
         break;
     case LF_PROCEDURE_V2:
-        symt = codeview_new_func_signature(ctp, existing,type->procedure_v2.callconv);
-        if (details)
-        {
-            codeview_add_type(curr_type, symt);
-            codeview_add_func_signature_args(ctp,
-                                             (struct symt_function_signature*)symt,
-                                             type->procedure_v2.rvtype,
-                                             type->procedure_v2.arglist);
-        }
+        symt = codeview_new_func_signature(ctp,type->procedure_v2.callconv);
+        codeview_add_func_signature_args(ctp,
+                                         (struct symt_function_signature*)symt,
+                                         type->procedure_v2.rvtype,
+                                         type->procedure_v2.arglist);
         break;
 
     case LF_MFUNCTION_V1:
         /* FIXME: for C++, this is plain wrong, but as we don't use arg types
          * nor class information, this would just do for now
          */
-        symt = codeview_new_func_signature(ctp, existing, type->mfunction_v1.callconv);
-        if (details)
-        {
-            codeview_add_type(curr_type, symt);
-            codeview_add_func_signature_args(ctp,
-                                             (struct symt_function_signature*)symt,
-                                             type->mfunction_v1.rvtype,
-                                             type->mfunction_v1.arglist);
-        }
+        symt = codeview_new_func_signature(ctp, type->mfunction_v1.callconv);
+        codeview_add_func_signature_args(ctp,
+                                         (struct symt_function_signature*)symt,
+                                         type->mfunction_v1.rvtype,
+                                         type->mfunction_v1.arglist);
         break;
     case LF_MFUNCTION_V2:
         /* FIXME: for C++, this is plain wrong, but as we don't use arg types
          * nor class information, this would just do for now
          */
-        symt = codeview_new_func_signature(ctp, existing, type->mfunction_v2.callconv);
-        if (details)
-        {
-            codeview_add_type(curr_type, symt);
-            codeview_add_func_signature_args(ctp,
-                                             (struct symt_function_signature*)symt,
-                                             type->mfunction_v2.rvtype,
-                                             type->mfunction_v2.arglist);
-        }
+        symt = codeview_new_func_signature(ctp, type->mfunction_v2.callconv);
+        codeview_add_func_signature_args(ctp,
+                                         (struct symt_function_signature*)symt,
+                                         type->mfunction_v2.rvtype,
+                                         type->mfunction_v2.arglist);
         break;
 
     case LF_VTSHAPE_V1:
         /* this is an ugly hack... FIXME when we have C++ support */
-        if (!(symt = existing))
         {
             char    buf[128];
             snprintf(buf, sizeof(buf), "__internal_vt_shape_%x\n", curr_type);
@@ -1358,7 +1265,99 @@ static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
         dump(type, 2 + type->generic.len);
         return NULL;
     }
-    return codeview_add_type(curr_type, symt) ? symt : NULL;
+    return symt && codeview_add_type(curr_type, symt) ? symt : NULL;
+}
+
+static struct symt* codeview_parse_forwardable_type(struct codeview_type_parse* ctp,
+                                                    unsigned curr_type,
+                                                    const union codeview_type* type)
+{
+    struct symt*                symt;
+    int                         value, leaf_len;
+    const struct p_string*      p_name;
+    const char*                 c_name;
+
+    switch (type->generic.id)
+    {
+    case LF_STRUCTURE_V1:
+    case LF_CLASS_V1:
+        leaf_len = numeric_leaf(&value, &type->struct_v1.structlen);
+        p_name = (const struct p_string*)((const unsigned char*)&type->struct_v1.structlen + leaf_len);
+        symt = codeview_add_type_struct(ctp, terminate_string(p_name), value,
+                                        type->generic.id == LF_CLASS_V1 ? UdtClass : UdtStruct,
+                                        type->struct_v1.property);
+        break;
+
+    case LF_STRUCTURE_V2:
+    case LF_CLASS_V2:
+        leaf_len = numeric_leaf(&value, &type->struct_v2.structlen);
+        p_name = (const struct p_string*)((const unsigned char*)&type->struct_v2.structlen + leaf_len);
+        symt = codeview_add_type_struct(ctp, terminate_string(p_name), value,
+                                        type->generic.id == LF_CLASS_V2 ? UdtClass : UdtStruct,
+                                        type->struct_v2.property);
+        break;
+
+    case LF_STRUCTURE_V3:
+    case LF_CLASS_V3:
+        leaf_len = numeric_leaf(&value, &type->struct_v3.structlen);
+        c_name = (const char*)&type->struct_v3.structlen + leaf_len;
+        symt = codeview_add_type_struct(ctp, c_name, value,
+                                        type->generic.id == LF_CLASS_V3 ? UdtClass : UdtStruct,
+                                        type->struct_v3.property);
+        break;
+
+    case LF_UNION_V1:
+        leaf_len = numeric_leaf(&value, &type->union_v1.un_len);
+        p_name = (const struct p_string*)((const unsigned char*)&type->union_v1.un_len + leaf_len);
+        symt = codeview_add_type_struct(ctp, terminate_string(p_name),
+                                        value, UdtUnion, type->union_v1.property);
+        break;
+
+    case LF_UNION_V2:
+        leaf_len = numeric_leaf(&value, &type->union_v2.un_len);
+        p_name = (const struct p_string*)((const unsigned char*)&type->union_v2.un_len + leaf_len);
+        symt = codeview_add_type_struct(ctp, terminate_string(p_name),
+                                        value, UdtUnion, type->union_v2.property);
+        break;
+
+    case LF_UNION_V3:
+        leaf_len = numeric_leaf(&value, &type->union_v3.un_len);
+        c_name = (const char*)&type->union_v3.un_len + leaf_len;
+        symt = codeview_add_type_struct(ctp, c_name,
+                                        value, UdtUnion, type->union_v3.property);
+        break;
+
+    case LF_ENUM_V1:
+        symt = &symt_new_enum(ctp->module, terminate_string(&type->enumeration_v1.p_name), NULL)->symt;
+        break;
+
+    case LF_ENUM_V2:
+        symt = &symt_new_enum(ctp->module, terminate_string(&type->enumeration_v2.p_name), NULL)->symt;
+        break;
+
+    case LF_ENUM_V3:
+        symt = &symt_new_enum(ctp->module, type->enumeration_v3.name, NULL)->symt;
+        break;
+
+    default: symt = NULL;
+    }
+    return symt && codeview_add_type(curr_type, symt) ? symt : NULL;
+}
+
+static BOOL codeview_is_top_level_type(const union codeview_type* type)
+{
+    /* type records we're interested in are the ones referenced by symbols
+     * The known ranges are (X mark the ones we want):
+     *   X  0000-0016       for V1 types
+     *      0200-020c       for V1 types referenced by other types
+     *      0400-040f       for V1 types (complex lists & sets)
+     *   X  1000-100f       for V2 types
+     *      1200-120c       for V2 types referenced by other types
+     *      1400-140f       for V1 types (complex lists & sets)
+     *   X  1500-150d       for V3 types
+     *      8000-8010       for numeric leafes
+     */
+    return !(type->generic.id & 0x8600) || (type->generic.id & 0x0100);
 }
 
 static BOOL codeview_parse_type_table(struct codeview_type_parse* ctp)
@@ -1371,23 +1370,25 @@ static BOOL codeview_parse_type_table(struct codeview_type_parse* ctp)
     cv_current_module->defined_types = calloc(ctp->header.last_index - ctp->header.first_index,
                                               sizeof(*cv_current_module->defined_types));
 
+    /* phase I: + only load forwardable types (struct/class/union/enum), but without their content
+     *            handle also forward declarations
+     */
     for (curr_type = ctp->header.first_index; curr_type < ctp->header.last_index; curr_type++)
     {
         type = codeview_jump_to_type(ctp, curr_type);
-
-        /* type records we're interested in are the ones referenced by symbols
-         * The known ranges are (X mark the ones we want):
-         *   X  0000-0016       for V1 types
-         *      0200-020c       for V1 types referenced by other types
-         *      0400-040f       for V1 types (complex lists & sets)
-         *   X  1000-100f       for V2 types
-         *      1200-120c       for V2 types referenced by other types
-         *      1400-140f       for V1 types (complex lists & sets)
-         *   X  1500-150d       for V3 types
-         *      8000-8010       for numeric leafes
-         */
-        if (!(type->generic.id & 0x8600) || (type->generic.id & 0x0100))
-            codeview_parse_one_type(ctp, curr_type, type, TRUE);
+        if (codeview_is_top_level_type(type))
+            codeview_parse_forwardable_type(ctp, curr_type, type);
+    }
+    /* phase II: + non forwardable types: load them, but since they can be indirectly
+     *             loaded (from another type), don't load them twice
+     *           + forwardable types: they can't be loaded indirectly, so load their content
+     */
+    for (curr_type = ctp->header.first_index; curr_type < ctp->header.last_index; curr_type++)
+    {
+        type = codeview_jump_to_type(ctp, curr_type);
+        if (codeview_is_top_level_type(type) &&
+            (!codeview_get_type(curr_type, TRUE) || codeview_is_forwardable_type(type)))
+            codeview_parse_one_type(ctp, curr_type, type);
     }
 
     return TRUE;
-- 
GitLab


From d12d5c7245635c9df26505c8b1aa3080404ca616 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 22 Jun 2022 16:28:09 +0200
Subject: [PATCH 5/6] dbghelp: Preserve PDB's partial order for types of same
 name.

The PDB types can contain several times a type definition with an identical
name. It seems to appear when modifying a type in source (like adding new
fields to a struct):
- as the PDB file (generated from first compilation) is updated (and not
  fully rewritten), the debug information for the old type is not flushed;
  a new record (for the same struct name) is emitted, and inserted
  before the old one in the hash table (bucket list).

Even if dbghelp's hash table is different from PDB's internal one (ie
number of buckets & bucket lists are different), we must maintain the order
of records of identical names (they end up in the same bucket) as a lookup
by name *must* return the first record in PDB's order.
Lookup by name is used:
- when resolving a forward definition (to get the full UDT definition
  including for example a struct/class fields's list)
- when searching by type name from dbghelp APIs, like SymGetTypeFromName()

This patch implements the preservation of that order.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/dbghelp/msc.c | 373 ++++++++++++++++++++++++++++++++++-----------
 1 file changed, 284 insertions(+), 89 deletions(-)

diff --git a/dlls/dbghelp/msc.c b/dlls/dbghelp/msc.c
index c177d0639d6..2e7336163bb 100644
--- a/dlls/dbghelp/msc.c
+++ b/dlls/dbghelp/msc.c
@@ -555,12 +555,21 @@ static struct symt*  codeview_get_type(unsigned int typeno, BOOL quiet)
     return symt;
 }
 
+struct hash_link
+{
+    unsigned            id;
+    struct hash_link*   next;
+};
+
 struct codeview_type_parse
 {
     struct module*      module;
     PDB_TYPES           header;
     const BYTE*         table;
-    const DWORD*        offset;
+    const DWORD*        offset;      /* typeindex => offset in 'table' */
+    BYTE*               hash_stream; /* content of stream header.hash_file */
+    struct hash_link**  hash;        /* hash_table (deserialized from PDB hash table) */
+    struct hash_link*   alloc_hash;  /* allocated hash_link (id => hash_link) */
 };
 
 static inline const void* codeview_jump_to_type(const struct codeview_type_parse* ctp, DWORD idx)
@@ -616,16 +625,6 @@ static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
                                             unsigned curr_type,
                                             const union codeview_type* type);
 
-static void* codeview_cast_symt(struct symt* symt, enum SymTagEnum tag)
-{
-    if (symt->tag != tag)
-    {
-        FIXME("Bad tag. Expected %d, but got %d\n", tag, symt->tag);
-        return NULL;
-    }   
-    return symt;
-}
-
 static struct symt* codeview_fetch_type(struct codeview_type_parse* ctp,
                                         unsigned typeno)
 {
@@ -641,6 +640,28 @@ static struct symt* codeview_fetch_type(struct codeview_type_parse* ctp,
     return symt;
 }
 
+static UINT32 codeview_compute_hash(const char* ptr, unsigned len)
+{
+    const char* last = ptr + len;
+    UINT32 ret = 0;
+
+    while (ptr + sizeof(UINT32) <= last)
+    {
+        ret ^= *(UINT32*)ptr;
+        ptr += sizeof(UINT32);
+    }
+    if (ptr + sizeof(UINT16) <= last)
+    {
+        ret ^= *(UINT16*)ptr;
+        ptr += sizeof(UINT16);
+    }
+    if (ptr + sizeof(BYTE) <= last)
+        ret ^= *(BYTE*)ptr;
+    ret |= 0x20202020;
+    ret ^= (ret >> 11);
+    return ret ^ (ret >> 16);
+}
+
 /* We call 'forwardable' a type which can have a forward declaration, and we need to merge
  * (when they both exist) the type record of the forward declaration and the type record
  * of the full definition into a single symt.
@@ -667,6 +688,150 @@ static BOOL codeview_is_forwardable_type(const union codeview_type* type)
     }
 }
 
+static BOOL codeview_type_is_forward(const union codeview_type* cvtype)
+{
+    cv_property_t property;
+
+    switch (cvtype->generic.id)
+    {
+    case LF_STRUCTURE_V1:
+    case LF_CLASS_V1:     property = cvtype->struct_v1.property;       break;
+    case LF_STRUCTURE_V2:
+    case LF_CLASS_V2:     property = cvtype->struct_v2.property;       break;
+    case LF_STRUCTURE_V3:
+    case LF_CLASS_V3:     property = cvtype->struct_v3.property;       break;
+    case LF_UNION_V1:     property = cvtype->union_v1.property;        break;
+    case LF_UNION_V2:     property = cvtype->union_v2.property;        break;
+    case LF_UNION_V3:     property = cvtype->union_v3.property;        break;
+    case LF_ENUM_V1:      property = cvtype->enumeration_v1.property;  break;
+    case LF_ENUM_V2:      property = cvtype->enumeration_v1.property;  break;
+    case LF_ENUM_V3:      property = cvtype->enumeration_v1.property;  break;
+    default:
+        return FALSE;
+    }
+    return property.is_forward_defn;
+}
+
+static BOOL codeview_type_extract_name(const union codeview_type* cvtype,
+                                       const char** name, unsigned* len, const char** decorated_name)
+{
+    int value, leaf_len;
+    const struct p_string* p_name = NULL;
+    const char* c_name = NULL;
+    BOOL decorated = FALSE;
+
+    switch (cvtype->generic.id)
+    {
+    case LF_STRUCTURE_V1:
+    case LF_CLASS_V1:
+        leaf_len = numeric_leaf(&value, &cvtype->struct_v1.structlen);
+        p_name = (const struct p_string*)((const unsigned char*)&cvtype->struct_v1.structlen + leaf_len);
+        break;
+    case LF_STRUCTURE_V2:
+    case LF_CLASS_V2:
+        leaf_len = numeric_leaf(&value, &cvtype->struct_v2.structlen);
+        p_name = (const struct p_string*)((const unsigned char*)&cvtype->struct_v2.structlen + leaf_len);
+        break;
+    case LF_STRUCTURE_V3:
+    case LF_CLASS_V3:
+        leaf_len = numeric_leaf(&value, &cvtype->struct_v3.structlen);
+        c_name = (const char*)&cvtype->struct_v3.structlen + leaf_len;
+        decorated = cvtype->struct_v3.property.has_decorated_name;
+        break;
+    case LF_UNION_V1:
+        leaf_len = numeric_leaf(&value, &cvtype->union_v1.un_len);
+        p_name = (const struct p_string*)((const unsigned char*)&cvtype->union_v1.un_len + leaf_len);
+        break;
+    case LF_UNION_V2:
+        leaf_len = numeric_leaf(&value, &cvtype->union_v2.un_len);
+        p_name = (const struct p_string*)((const unsigned char*)&cvtype->union_v2.un_len + leaf_len);
+        break;
+    case LF_UNION_V3:
+        leaf_len = numeric_leaf(&value, &cvtype->union_v3.un_len);
+        c_name = (const char*)&cvtype->union_v3.un_len + leaf_len;
+        decorated = cvtype->union_v3.property.has_decorated_name;
+        break;
+    case LF_ENUM_V1:
+        p_name = &cvtype->enumeration_v1.p_name;
+        break;
+    case LF_ENUM_V2:
+        p_name = &cvtype->enumeration_v2.p_name;
+        break;
+    case LF_ENUM_V3:
+        c_name = cvtype->enumeration_v3.name;
+        decorated = cvtype->union_v3.property.has_decorated_name;
+        break;
+    default:
+        return FALSE;
+    }
+    if (p_name)
+    {
+        *name = p_name->name;
+        *len = p_name->namelen;
+        *decorated_name = NULL;
+        return TRUE;
+    }
+    if (c_name)
+    {
+        *name = c_name;
+        *len = strlen(c_name);
+        *decorated_name = decorated ? (c_name + *len + 1) : NULL;
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static unsigned pdb_read_hash_value(const struct codeview_type_parse* ctp, unsigned idx)
+{
+    const void* where = ctp->hash_stream + ctp->header.hash_offset + (idx - ctp->header.first_index) * ctp->header.hash_size;
+    switch (ctp->header.hash_size)
+    {
+    case 2: return *(unsigned short*)where;
+    case 4: return *(unsigned*)where;
+    }
+    return 0;
+}
+
+static BOOL codeview_resolve_forward_type(struct codeview_type_parse* ctp, const union codeview_type* cvref,
+                                          unsigned reftype, unsigned *impl_type)
+{
+    const union codeview_type* cvdecl;
+    struct hash_link* hl;
+    const char* nameref;
+    const char* decoratedref;
+    unsigned lenref;
+    unsigned hash;
+
+    /* Unfortunately, hash of forward defs are computed on the whole type record, not its name
+     * (unlike hash of UDT & enum implementations which is based primarly on the name... sigh)
+     * So compute the hash of the expected implementation.
+     */
+    if (!codeview_type_extract_name(cvref,  &nameref,  &lenref,  &decoratedref)) return FALSE;
+    hash = codeview_compute_hash(nameref, lenref) % ctp->header.hash_num_buckets;
+
+    for (hl = ctp->hash[hash]; hl; hl = hl->next)
+    {
+        if (hl->id == reftype) continue;
+        cvdecl = codeview_jump_to_type(ctp, hl->id);
+        if (cvdecl && !codeview_type_is_forward(cvdecl) && cvref->generic.id == cvdecl->generic.id)
+        {
+            const char* namedecl;
+            const char* decorateddecl;
+            unsigned lendecl;
+
+            if (codeview_type_extract_name(cvdecl, &namedecl, &lendecl, &decorateddecl) &&
+                ((decoratedref && decorateddecl && !strcmp(decoratedref, decorateddecl)) ||
+                 (!decoratedref && !decorateddecl && lenref == lendecl && !memcmp(nameref, namedecl, lenref))))
+            {
+                TRACE("mapping forward type %.*s (%s) %x into %x\n", lenref, nameref, debugstr_a(decoratedref), reftype, hl->id);
+                *impl_type = hl->id;
+                return TRUE;
+            }
+        }
+    }
+    return FALSE;
+}
+
 static struct symt* codeview_add_type_pointer(struct codeview_type_parse* ctp,
                                               unsigned int pointee_type)
 {
@@ -1007,49 +1172,6 @@ static int codeview_add_type_struct_field_list(struct codeview_type_parse* ctp,
     return TRUE;
 }
 
-static struct symt* codeview_add_type_struct(struct codeview_type_parse* ctp,
-                                             const char* name, int structlen,
-                                             enum UdtKind kind, cv_property_t property)
-{
-    struct symt_udt*    symt;
-    struct symt*        existing = NULL;
-
-    /* if we don't have an existing type, try to find one with same name
-     * FIXME: what to do when several types in different CUs have same name ?
-     */
-    void*                       ptr;
-    struct symt_ht*             type;
-    struct hash_table_iter      hti;
-
-    hash_table_iter_init(&ctp->module->ht_types, &hti, name);
-    while ((ptr = hash_table_iter_up(&hti)))
-    {
-        type = CONTAINING_RECORD(ptr, struct symt_ht, hash_elt);
-
-        if (type->symt.tag == SymTagUDT &&
-            type->hash_elt.name && !strcmp(type->hash_elt.name, name))
-        {
-            existing = &type->symt;
-            break;
-        }
-    }
-    if (existing)
-    {
-        if (!(symt = codeview_cast_symt(existing, SymTagUDT))) return NULL;
-        /* should also check that all fields are the same */
-        if (!property.is_forward_defn)
-        {
-            if (!symt->size) /* likely prior forward declaration, set UDT size */
-                symt_set_udt_size(ctp->module, symt, structlen);
-            else /* different UDT with same name, create a new type */
-                existing = NULL;
-        }
-    }
-    if (!existing) symt = symt_new_udt(ctp->module, name, structlen, kind);
-
-    return &symt->symt;
-}
-
 static struct symt* codeview_new_func_signature(struct codeview_type_parse* ctp,
                                                 enum CV_call_e call_conv)
 {
@@ -1268,9 +1390,8 @@ static struct symt* codeview_parse_one_type(struct codeview_type_parse* ctp,
     return symt && codeview_add_type(curr_type, symt) ? symt : NULL;
 }
 
-static struct symt* codeview_parse_forwardable_type(struct codeview_type_parse* ctp,
-                                                    unsigned curr_type,
-                                                    const union codeview_type* type)
+static struct symt* codeview_load_forwardable_type(struct codeview_type_parse* ctp,
+                                                   const union codeview_type* type)
 {
     struct symt*                symt;
     int                         value, leaf_len;
@@ -1283,48 +1404,42 @@ static struct symt* codeview_parse_forwardable_type(struct codeview_type_parse*
     case LF_CLASS_V1:
         leaf_len = numeric_leaf(&value, &type->struct_v1.structlen);
         p_name = (const struct p_string*)((const unsigned char*)&type->struct_v1.structlen + leaf_len);
-        symt = codeview_add_type_struct(ctp, terminate_string(p_name), value,
-                                        type->generic.id == LF_CLASS_V1 ? UdtClass : UdtStruct,
-                                        type->struct_v1.property);
+        symt = &symt_new_udt(ctp->module, terminate_string(p_name), value,
+                             type->generic.id == LF_CLASS_V1 ? UdtClass : UdtStruct)->symt;
         break;
 
     case LF_STRUCTURE_V2:
     case LF_CLASS_V2:
         leaf_len = numeric_leaf(&value, &type->struct_v2.structlen);
         p_name = (const struct p_string*)((const unsigned char*)&type->struct_v2.structlen + leaf_len);
-        symt = codeview_add_type_struct(ctp, terminate_string(p_name), value,
-                                        type->generic.id == LF_CLASS_V2 ? UdtClass : UdtStruct,
-                                        type->struct_v2.property);
+        symt = &symt_new_udt(ctp->module, terminate_string(p_name), value,
+                             type->generic.id == LF_CLASS_V2 ? UdtClass : UdtStruct)->symt;
         break;
 
     case LF_STRUCTURE_V3:
     case LF_CLASS_V3:
         leaf_len = numeric_leaf(&value, &type->struct_v3.structlen);
         c_name = (const char*)&type->struct_v3.structlen + leaf_len;
-        symt = codeview_add_type_struct(ctp, c_name, value,
-                                        type->generic.id == LF_CLASS_V3 ? UdtClass : UdtStruct,
-                                        type->struct_v3.property);
+        symt = &symt_new_udt(ctp->module, c_name, value,
+                             type->generic.id == LF_CLASS_V3 ? UdtClass : UdtStruct)->symt;
         break;
 
     case LF_UNION_V1:
         leaf_len = numeric_leaf(&value, &type->union_v1.un_len);
         p_name = (const struct p_string*)((const unsigned char*)&type->union_v1.un_len + leaf_len);
-        symt = codeview_add_type_struct(ctp, terminate_string(p_name),
-                                        value, UdtUnion, type->union_v1.property);
+        symt = &symt_new_udt(ctp->module, terminate_string(p_name), value, UdtUnion)->symt;
         break;
 
     case LF_UNION_V2:
         leaf_len = numeric_leaf(&value, &type->union_v2.un_len);
         p_name = (const struct p_string*)((const unsigned char*)&type->union_v2.un_len + leaf_len);
-        symt = codeview_add_type_struct(ctp, terminate_string(p_name),
-                                        value, UdtUnion, type->union_v2.property);
+        symt = &symt_new_udt(ctp->module, terminate_string(p_name), value, UdtUnion)->symt;
         break;
 
     case LF_UNION_V3:
         leaf_len = numeric_leaf(&value, &type->union_v3.un_len);
         c_name = (const char*)&type->union_v3.un_len + leaf_len;
-        symt = codeview_add_type_struct(ctp, c_name,
-                                        value, UdtUnion, type->union_v3.property);
+        symt = &symt_new_udt(ctp->module, c_name, value, UdtUnion)->symt;
         break;
 
     case LF_ENUM_V1:
@@ -1341,10 +1456,10 @@ static struct symt* codeview_parse_forwardable_type(struct codeview_type_parse*
 
     default: symt = NULL;
     }
-    return symt && codeview_add_type(curr_type, symt) ? symt : NULL;
+    return symt;
 }
 
-static BOOL codeview_is_top_level_type(const union codeview_type* type)
+static inline BOOL codeview_is_top_level_type(const union codeview_type* type)
 {
     /* type records we're interested in are the ones referenced by symbols
      * The known ranges are (X mark the ones we want):
@@ -1362,7 +1477,7 @@ static BOOL codeview_is_top_level_type(const union codeview_type* type)
 
 static BOOL codeview_parse_type_table(struct codeview_type_parse* ctp)
 {
-    unsigned int                curr_type;
+    unsigned int                i, curr_type;
     const union codeview_type*  type;
 
     cv_current_module->first_type_index = ctp->header.first_index;
@@ -1370,18 +1485,59 @@ static BOOL codeview_parse_type_table(struct codeview_type_parse* ctp)
     cv_current_module->defined_types = calloc(ctp->header.last_index - ctp->header.first_index,
                                               sizeof(*cv_current_module->defined_types));
 
-    /* phase I: + only load forwardable types (struct/class/union/enum), but without their content
-     *            handle also forward declarations
+    /* pass I: + load implementation of forwardable types, but without their content
+     *         + merge forward declarations with their implementations (when the later exists)
+     *         + do it in the order generated from PDB hash table to preserve that order
+     *           (several versions coming from different compilations can exist in the PDB file,
+     *           and using PDB order ensures that we use the relevant one.
+     *           (needed for forward resolution and type lookup by name)
+     *           (dbghelp hash table inserts new elements at the end of bucket's list)
+     * Note: for a given type, we must handle:
+     * - only an implementation type record
+     * - only a forward type record (eg using struct foo* without struct foo being defined)
+     * - a forward type record and on an implementation type record: this is the most common, but
+     *   depending on hash values, we cannot tell which on will show up first
      */
-    for (curr_type = ctp->header.first_index; curr_type < ctp->header.last_index; curr_type++)
+    for (i = 0; i < ctp->header.hash_num_buckets; i++)
     {
-        type = codeview_jump_to_type(ctp, curr_type);
-        if (codeview_is_top_level_type(type))
-            codeview_parse_forwardable_type(ctp, curr_type, type);
+        struct hash_link* hl;
+        for (hl = ctp->hash[i]; hl; hl = hl->next)
+        {
+            struct symt* symt;
+            type = codeview_jump_to_type(ctp, hl->id);
+            if (!codeview_is_top_level_type(type)) continue;
+            if (codeview_type_is_forward(type))
+            {
+                unsigned impl_type;
+                /* make the forward declaration point to the implementation (if any) */
+                if (codeview_resolve_forward_type(ctp, type, hl->id, &impl_type))
+                {
+                    /* impl already loaded? */
+                    if (!(symt = codeview_get_type(impl_type, TRUE)))
+                    {
+                        /* no load it */
+                        if ((symt = codeview_load_forwardable_type(ctp, codeview_jump_to_type(ctp, impl_type))))
+                            codeview_add_type(impl_type, symt);
+                        else
+                            FIXME("forward def of %x => %x, unable to load impl\n", hl->id, impl_type);
+                    }
+                }
+                else
+                    /* forward type definition without implementation, create empty type */
+                    symt = codeview_load_forwardable_type(ctp, type);
+            }
+            else
+            {
+                /* if not already loaded (from previous forward declaration), load it */
+                if (!(symt = codeview_get_type(hl->id, TRUE)))
+                    symt = codeview_load_forwardable_type(ctp, type);
+            }
+            codeview_add_type(hl->id, symt);
+        }
     }
-    /* phase II: + non forwardable types: load them, but since they can be indirectly
-     *             loaded (from another type), don't load them twice
-     *           + forwardable types: they can't be loaded indirectly, so load their content
+    /* pass II: + non forwardable types: load them, but since they can be indirectly
+     *            loaded (from another type), but don't load them twice
+     *          + forwardable types: load their content
      */
     for (curr_type = ctp->header.first_index; curr_type < ctp->header.last_index; curr_type++)
     {
@@ -3037,7 +3193,16 @@ static HANDLE map_pdb_file(const struct process* pcs,
     return hMap;
 }
 
+static void pdb_dispose_type_parse(struct codeview_type_parse* ctp)
+{
+    pdb_free(ctp->hash_stream);
+    free((DWORD*)ctp->offset);
+    free((DWORD*)ctp->hash);
+    free((DWORD*)ctp->alloc_hash);
+}
+
 static BOOL pdb_init_type_parse(const struct msc_debug_info* msc_dbg,
+                                const struct pdb_file_info* pdb_file,
                                 struct codeview_type_parse* ctp,
                                 BYTE* image)
 {
@@ -3045,6 +3210,10 @@ static BOOL pdb_init_type_parse(const struct msc_debug_info* msc_dbg,
     DWORD* offset;
     int i;
 
+    ctp->hash_stream = NULL;
+    ctp->offset = NULL;
+    ctp->hash = NULL;
+    ctp->alloc_hash = NULL;
     pdb_convert_types_header(&ctp->header, image);
 
     /* Check for unknown versions */
@@ -3060,6 +3229,18 @@ static BOOL pdb_init_type_parse(const struct msc_debug_info* msc_dbg,
         ERR("-Unknown type info version %d\n", ctp->header.version);
         return FALSE;
     }
+    if (ctp->header.hash_size != 2 && ctp->header.hash_size != 4)
+    {
+        ERR("-Unsupported hash of size %u\n", ctp->header.hash_size);
+        return FALSE;
+    }
+    ctp->hash_stream = pdb_read_file(pdb_file, ctp->header.hash_file);
+    /* FIXME always present? if not reconstruct ?*/
+    if (!ctp->hash_stream)
+    {
+        ERR("-Missing hash table in PDB file\n");
+        return FALSE;
+    }
 
     ctp->module = msc_dbg->module;
     /* Reconstruct the types offset table
@@ -3076,7 +3257,21 @@ static BOOL pdb_init_type_parse(const struct msc_debug_info* msc_dbg,
         ptr += ((const union codeview_type*)ptr)->generic.len + 2;
     }
     ctp->offset = offset;
+    ctp->hash = calloc(ctp->header.hash_num_buckets, sizeof(struct hash_link*));
+    if (!ctp->hash) goto oom;
+    ctp->alloc_hash = calloc(ctp->header.last_index - ctp->header.first_index, sizeof(struct hash_link));
+    if (!ctp->alloc_hash) goto oom;
+    for (i = ctp->header.first_index; i < ctp->header.last_index; i++)
+    {
+        unsigned hash_i = pdb_read_hash_value(ctp, i);
+        ctp->alloc_hash[i - ctp->header.first_index].id = i;
+        ctp->alloc_hash[i - ctp->header.first_index].next = ctp->hash[hash_i];
+        ctp->hash[hash_i] = &ctp->alloc_hash[i - ctp->header.first_index];
+    }
     return TRUE;
+oom:
+    pdb_dispose_type_parse(ctp);
+    return FALSE;
 }
 
 static void pdb_process_types(const struct msc_debug_info* msc_dbg,
@@ -3087,11 +3282,11 @@ static void pdb_process_types(const struct msc_debug_info* msc_dbg,
 
     if (types_image)
     {
-        if (pdb_init_type_parse(msc_dbg, &ctp, types_image))
+        if (pdb_init_type_parse(msc_dbg, pdb_file, &ctp, types_image))
         {
             /* Read type table */
             codeview_parse_type_table(&ctp);
-            HeapFree(GetProcessHeap(), 0, (DWORD*)ctp.offset);
+            pdb_dispose_type_parse(&ctp);
         }
         pdb_free(types_image);
     }
@@ -3375,7 +3570,7 @@ static BOOL pdb_process_internal(const struct process* pcs,
         pdb_process_types(msc_dbg, pdb_file);
 
         ipi_image = pdb_read_file(pdb_file, 4);
-        ipi_ok = pdb_init_type_parse(msc_dbg, &ipi_ctp, ipi_image);
+        ipi_ok = pdb_init_type_parse(msc_dbg, pdb_file, &ipi_ctp, ipi_image);
 
         /* Read global symbol table */
         globalimage = pdb_read_file(pdb_file, symbols.gsym_file);
-- 
GitLab


From 29dd84443976005a8ec713dd1c75458e27346591 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 22 Jun 2022 16:28:09 +0200
Subject: [PATCH 6/6] dbghelp: Use remap table from PDB hash stream.

The PDB hash stream from TPI header contains information to force a remap
to a given type record (whatever the order in the bucket hash list).
This is generated by the incremental linker in some occasions.

Use that information to remap the corresponding types.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/dbghelp/msc.c | 42 ++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 42 insertions(+)

diff --git a/dlls/dbghelp/msc.c b/dlls/dbghelp/msc.c
index 2e7336163bb..1c58b0e9cf6 100644
--- a/dlls/dbghelp/msc.c
+++ b/dlls/dbghelp/msc.c
@@ -3201,6 +3201,12 @@ static void pdb_dispose_type_parse(struct codeview_type_parse* ctp)
     free((DWORD*)ctp->alloc_hash);
 }
 
+static BOOL pdb_bitfield_is_bit_set(const unsigned* dw, unsigned len, unsigned i)
+{
+    if (i >= len * sizeof(unsigned) * 8) return FALSE;
+    return (dw[i >> 5] & (1u << (i & 31u))) != 0;
+}
+
 static BOOL pdb_init_type_parse(const struct msc_debug_info* msc_dbg,
                                 const struct pdb_file_info* pdb_file,
                                 struct codeview_type_parse* ctp,
@@ -3268,6 +3274,42 @@ static BOOL pdb_init_type_parse(const struct msc_debug_info* msc_dbg,
         ctp->alloc_hash[i - ctp->header.first_index].next = ctp->hash[hash_i];
         ctp->hash[hash_i] = &ctp->alloc_hash[i - ctp->header.first_index];
     }
+    /* parse the remap table
+     * => move listed type_id at first position of their hash buckets so that we force remap to them
+     */
+    if (ctp->header.type_remap_len)
+    {
+        const unsigned* remap = (const unsigned*)((const BYTE*)ctp->hash_stream + ctp->header.type_remap_offset);
+        unsigned i, capa, count_present;
+        const unsigned* present_bitset;
+        remap++; /* no need of num */
+        capa = *remap++;
+        count_present = *remap++;
+        present_bitset = remap;
+        remap += count_present;
+        remap += *remap + 1; /* skip deleted bit set */
+        for (i = 0; i < capa; ++i)
+        {
+            if (pdb_bitfield_is_bit_set(present_bitset, count_present, i))
+            {
+                unsigned hash_i;
+                struct hash_link** phl;
+                /* remap[0] is an offset for a string in /string stream, followed by type_id to force */
+                hash_i = pdb_read_hash_value(ctp, remap[1]);
+                for (phl = &ctp->hash[hash_i]; *phl; phl = &(*phl)->next)
+                    if ((*phl)->id == remap[1])
+                    {
+                        struct hash_link* hl = *phl;
+                        /* move hl node at first position of its hash bucket */
+                        *phl = hl->next;
+                        hl->next = ctp->hash[hash_i];
+                        ctp->hash[hash_i] = hl;
+                        break;
+                    }
+                remap += 2;
+            }
+        }
+    }
     return TRUE;
 oom:
     pdb_dispose_type_parse(ctp);
-- 
GitLab

From d89e7cd443cecbd178ca06832f5e2d957255417a Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Sat, 16 Jul 2022 12:20:25 +0200
Subject: [PATCH 1/5] msvcrt: Fix demangling of RTTI type descriptor.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/tests/cpp.c | 1 +
 dlls/msvcrt/undname.c   | 3 ---
 2 files changed, 1 insertion(+), 3 deletions(-)

diff --git a/dlls/msvcrt/tests/cpp.c b/dlls/msvcrt/tests/cpp.c
index 15105ca60dd..8c6b059e788 100644
--- a/dlls/msvcrt/tests/cpp.c
+++ b/dlls/msvcrt/tests/cpp.c
@@ -1291,6 +1291,7 @@ static void test_demangle(void)
            "??$run@XVTask_Render_Preview@@@QtConcurrent@@YA?AV?$QFuture@X@@PEAVTask_Render_Preview@@P82@EAAXXZ@Z"},
 /* 130 */ {"??_E?$TStrArray@$$BY0BAA@D$0BA@@@UAEPAXI@Z",
            "public: virtual void * __thiscall TStrArray<char [256],16>::`vector deleting destructor'(unsigned int)"},
+/* 131 */ {"??_R0?AVCC@DD@@@8", "class DD::CC `RTTI Type Descriptor'"},
     };
     int i, num_test = ARRAY_SIZE(test);
     char* name;
diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index bee171de42f..d71738efd5f 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -1452,11 +1452,8 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
                 case '0':
                     {
                         struct datatype_t       ct;
-                        struct array pmt;
 
                         sym->current++;
-                        str_array_init(&pmt);
-                        demangle_datatype(sym, &ct, &pmt, FALSE);
                         if (!demangle_datatype(sym, &ct, NULL, FALSE))
                             goto done;
                         function_name = str_printf(sym, "%s%s `RTTI Type Descriptor'",
-- 
GitLab


From e0b6ceeaacc0846b1853689a7e50c643f46f6434 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Sat, 16 Jul 2022 12:20:25 +0200
Subject: [PATCH 2/5] msvcrt: Add support for C++11 operator "" in demangling.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/undname.c     | 13 +++++++++++++
 dlls/ucrtbase/tests/cpp.c | 31 ++++++++++++++++++-------------
 2 files changed, 31 insertions(+), 13 deletions(-)

diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index d71738efd5f..b07fbeb068e 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -1488,6 +1488,19 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
             case 'V': function_name = "operator delete[]"; break;
             case 'X': function_name = "`placement delete closure'"; break;
             case 'Y': function_name = "`placement delete[] closure'"; break;
+            case '_':
+                switch (*++sym->current)
+                {
+                case 'K':
+                    sym->current++;
+                    function_name = str_printf(sym, "operator \"\" %s", get_literal_string(sym));
+                    --sym->current;
+                    break;
+                default:
+                    FIXME("Unknown operator: __%c\n", *sym->current);
+                    return FALSE;
+                }
+                break;
             default:
                 ERR("Unknown operator: _%c\n", *sym->current);
                 return FALSE;
diff --git a/dlls/ucrtbase/tests/cpp.c b/dlls/ucrtbase/tests/cpp.c
index 77b06e7cd42..a22138889cb 100644
--- a/dlls/ucrtbase/tests/cpp.c
+++ b/dlls/ucrtbase/tests/cpp.c
@@ -192,19 +192,24 @@ static void test___std_type_info(void)
 
 static void test___unDName(void)
 {
-    char *name;
-
-    name = p___unDName(0, "??4QDnsDomainNameRecord@@QAEAAV0@$$QAV0@@Z", 0, malloc, free, 0);
-    ok(!strcmp(name, "public: class QDnsDomainNameRecord & __thiscall "
-                "QDnsDomainNameRecord::operator=(class QDnsDomainNameRecord &&)"),
-            "unDName returned %s\n", wine_dbgstr_a(name));
-    free(name);
-
-    name = p___unDName(0, "??4QDnsDomainNameRecord@@QAEAAV0@$$QEAV0@@Z", 0, malloc, free, 0);
-    ok(!strcmp(name, "public: class QDnsDomainNameRecord & __thiscall "
-                "QDnsDomainNameRecord::operator=(class QDnsDomainNameRecord && __ptr64)"),
-            "unDName returned %s\n", wine_dbgstr_a(name));
-    free(name);
+    static struct {const char *in; const char *out; const char *broken;} und_tests[] =
+    {
+/*   1 */ {"??4QDnsDomainNameRecord@@QAEAAV0@$$QAV0@@Z",
+           "public: class QDnsDomainNameRecord & __thiscall QDnsDomainNameRecord::operator=(class QDnsDomainNameRecord &&)"},
+/*   2 */ {"??4QDnsDomainNameRecord@@QAEAAV0@$$QEAV0@@Z",
+          "public: class QDnsDomainNameRecord & __thiscall QDnsDomainNameRecord::operator=(class QDnsDomainNameRecord && __ptr64)"},
+/*   3 */ {"??__K_l@@YA?AUCC@@I@Z", "struct CC __cdecl operator \"\" _l(unsigned int)",
+           "??__K_l@@YA?AUCC@@I@Z" /* W10 1507 fails on this :-( */},
+    };
+    unsigned i;
+    for (i = 0; i < ARRAY_SIZE(und_tests); i++)
+    {
+        char *name = p___unDName(0, und_tests[i].in, 0, malloc, free, 0);
+        ok(!strcmp(name, und_tests[i].out) ||
+           (broken(und_tests[i].broken && !strcmp(und_tests[i].broken, name))),
+           "unDName returned %s for #%u\n", wine_dbgstr_a(name), i);
+        free(name);
+    }
 }
 
 START_TEST(cpp)
-- 
GitLab


From 464d049149a2bfb658c727bee86157f15fe35d96 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Sat, 16 Jul 2022 12:20:25 +0200
Subject: [PATCH 3/5] msvcrt: Fix and cleanup undecoration of templatized
 functions and methods.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/tests/cpp.c |  1 +
 dlls/msvcrt/undname.c   | 18 +++++++++---------
 2 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/dlls/msvcrt/tests/cpp.c b/dlls/msvcrt/tests/cpp.c
index 8c6b059e788..c97669ffc72 100644
--- a/dlls/msvcrt/tests/cpp.c
+++ b/dlls/msvcrt/tests/cpp.c
@@ -1292,6 +1292,7 @@ static void test_demangle(void)
 /* 130 */ {"??_E?$TStrArray@$$BY0BAA@D$0BA@@@UAEPAXI@Z",
            "public: virtual void * __thiscall TStrArray<char [256],16>::`vector deleting destructor'(unsigned int)"},
 /* 131 */ {"??_R0?AVCC@DD@@@8", "class DD::CC `RTTI Type Descriptor'"},
+/* 132 */ {"??$meth@FD@DD@CC@@QAE_NK@Z", "public: bool __thiscall CC::DD::meth<short,char>(unsigned long)"},
     };
     int i, num_test = ARRAY_SIZE(test);
     char* name;
diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index b07fbeb068e..a19f374016a 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -1368,13 +1368,13 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
     sym->current++;
 
     /* Then function name or operator code */
-    if (*sym->current == '?' && (sym->current[1] != '$' || sym->current[2] == '?'))
+    if (*sym->current == '?')
     {
         const char* function_name = NULL;
 
-        if (sym->current[1] == '$')
+        if (sym->current[1] == '$' && sym->current[2] == '?')
         {
-            do_after = 6;
+            do_after = 5;
             sym->current += 2;
         }
 
@@ -1506,6 +1506,11 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
                 return FALSE;
             }
             break;
+        case '$':
+            sym->current++;
+            if (!(function_name = get_template_name(sym))) goto done;
+            --sym->current;
+            break;
         default:
             /* FIXME: Other operators */
             ERR("Unknown operator: %c\n", *sym->current);
@@ -1522,7 +1527,7 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
             sym->result = (char*)function_name;
             ret = TRUE;
             goto done;
-        case 6:
+        case 5:
             {
                 char *args;
                 struct array array_pmt;
@@ -1547,8 +1552,6 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
         ret = (sym->result = get_template_name(sym)) != NULL;
         goto done;
     }
-    else if (*sym->current == '?' && sym->current[1] == '$')
-        do_after = 5;
 
     /* Either a class name, or '@' if the symbol is not a class member */
     switch (*sym->current)
@@ -1577,9 +1580,6 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
     case 3:
         sym->flags &= ~UNDNAME_NO_FUNCTION_RETURNS;
         break;
-    case 5:
-        sym->names.start++;
-        break;
     }
 
     /* Function/Data type and access level */
-- 
GitLab


From b02d5bb8c4a4012b97cbc0f899a9ec6da10a398d Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Sat, 16 Jul 2022 12:20:25 +0200
Subject: [PATCH 4/5] msvcrt: Add support for restrict and unaligned qualifiers
 in demangling.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/tests/cpp.c |   1 +
 dlls/msvcrt/undname.c   | 166 +++++++++++++++++++++-------------------
 2 files changed, 89 insertions(+), 78 deletions(-)

diff --git a/dlls/msvcrt/tests/cpp.c b/dlls/msvcrt/tests/cpp.c
index c97669ffc72..79ea9d75c6b 100644
--- a/dlls/msvcrt/tests/cpp.c
+++ b/dlls/msvcrt/tests/cpp.c
@@ -1293,6 +1293,7 @@ static void test_demangle(void)
            "public: virtual void * __thiscall TStrArray<char [256],16>::`vector deleting destructor'(unsigned int)"},
 /* 131 */ {"??_R0?AVCC@DD@@@8", "class DD::CC `RTTI Type Descriptor'"},
 /* 132 */ {"??$meth@FD@DD@CC@@QAE_NK@Z", "public: bool __thiscall CC::DD::meth<short,char>(unsigned long)"},
+/* 133 */ {"?func@@YAXPIFAH@Z", "void __cdecl func(int __unaligned * __restrict)"},
     };
     int i, num_test = ARRAY_SIZE(test);
     char* name;
diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index a19f374016a..4b53ac459fb 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -394,67 +394,85 @@ static char* get_args(struct parsed_symbol* sym, struct array* pmt_ref, BOOL z_t
     return args_str;
 }
 
-/******************************************************************
- *		get_modifier
- * Parses the type modifier. Always returns static strings.
- */
-static BOOL get_modifier(struct parsed_symbol *sym, const char **ret, const char **ptr_modif)
+static void append_extended_modifier(struct parsed_symbol *sym, const char **where, const char *str)
+{
+    if (!(sym->flags & UNDNAME_NO_MS_KEYWORDS))
+    {
+        if (sym->flags & UNDNAME_NO_LEADING_UNDERSCORES)
+            str += 2;
+        *where = *where ? str_printf(sym, "%s %s", *where, str) : str;
+    }
+}
+
+static void get_extended_modifier(struct parsed_symbol *sym, struct datatype_t *xdt)
 {
-    *ptr_modif = NULL;
-    if (*sym->current == 'E')
+    xdt->left = xdt->right = NULL;
+    for (;;)
     {
-        if (!(sym->flags & UNDNAME_NO_MS_KEYWORDS))
+        switch (*sym->current)
         {
-            *ptr_modif = "__ptr64";
-            if (sym->flags & UNDNAME_NO_LEADING_UNDERSCORES)
-                *ptr_modif = *ptr_modif + 2;
+        case 'E': append_extended_modifier(sym, &xdt->right, "__ptr64");     break;
+        case 'F': append_extended_modifier(sym, &xdt->left,  "__unaligned"); break;
+        case 'I': append_extended_modifier(sym, &xdt->right, "__restrict");  break;
+        default: return;
         }
         sym->current++;
     }
+}
+
+/******************************************************************
+ *		get_modifier
+ * Parses the type modifier. Always returns static strings.
+ */
+static BOOL get_modifier(struct parsed_symbol *sym, struct datatype_t *xdt)
+{
+    const char* mod;
+
+    get_extended_modifier(sym, xdt);
     switch (*sym->current++)
     {
-    case 'A': *ret = NULL; break;
-    case 'B': *ret = "const"; break;
-    case 'C': *ret = "volatile"; break;
-    case 'D': *ret = "const volatile"; break;
+    case 'A': mod = NULL; break;
+    case 'B': mod = "const"; break;
+    case 'C': mod = "volatile"; break;
+    case 'D': mod = "const volatile"; break;
     default: return FALSE;
     }
+    if (xdt->left && mod)
+        xdt->left = str_printf(sym, "%s %s", xdt->left, mod);
+    else if (mod)
+        xdt->left = mod;
     return TRUE;
 }
 
 static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
                               struct array *pmt_ref, char modif, BOOL in_args)
 {
-    const char* modifier;
+    struct datatype_t xdt;
+    const char* ref;
     const char* str_modif;
-    const char *ptr_modif = "";
 
-    if (*sym->current == 'E')
-    {
-        if (!(sym->flags & UNDNAME_NO_MS_KEYWORDS))
-        {
-            if (sym->flags & UNDNAME_NO_LEADING_UNDERSCORES)
-                ptr_modif = " ptr64";
-            else
-                ptr_modif = " __ptr64";
-        }
-        sym->current++;
-    }
+    get_extended_modifier(sym, &xdt);
 
     switch (modif)
     {
-    case 'A': str_modif = str_printf(sym, " &%s", ptr_modif); break;
-    case 'B': str_modif = str_printf(sym, " &%s volatile", ptr_modif); break;
-    case 'P': str_modif = str_printf(sym, " *%s", ptr_modif); break;
-    case 'Q': str_modif = str_printf(sym, " *%s const", ptr_modif); break;
-    case 'R': str_modif = str_printf(sym, " *%s volatile", ptr_modif); break;
-    case 'S': str_modif = str_printf(sym, " *%s const volatile", ptr_modif); break;
-    case '?': str_modif = ""; break;
-    case '$': str_modif = str_printf(sym, " &&%s", ptr_modif); break;
+    case 'A': ref = "&";  str_modif = NULL;             break;
+    case 'B': ref = "&";  str_modif = "volatile";       break;
+    case 'P': ref = "*";  str_modif = NULL;             break;
+    case 'Q': ref = "*";  str_modif = "const";          break;
+    case 'R': ref = "*";  str_modif = "volatile";       break;
+    case 'S': ref = "*";  str_modif = "const volatile"; break;
+    case '?': ref = NULL; str_modif = NULL;             break;
+    case '$': ref = "&&"; str_modif = NULL;             break;
     default: return FALSE;
     }
-
-    if (get_modifier(sym, &modifier, &ptr_modif))
+    if (ref || str_modif || xdt.left || xdt.right)
+        str_modif = str_printf(sym, " %s%s%s%s%s%s%s",
+                               xdt.left,
+                               xdt.left && ref ? " " : NULL, ref,
+                               (xdt.left || ref) && xdt.right ? " " : NULL, xdt.right,
+                               (xdt.left || ref || xdt.right) && str_modif ? " " : NULL, str_modif);
+
+    if (get_modifier(sym, &xdt))
     {
         unsigned            mark = sym->stack.num;
         struct datatype_t   sub_ct;
@@ -469,16 +487,11 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
             if (!(n1 = get_number(sym))) return FALSE;
             num = atoi(n1);
 
-            if (str_modif[0] == ' ' && !modifier)
+            if (str_modif[0] == ' ' && !xdt.left)
                 str_modif++;
 
-            if (modifier)
-            {
-                str_modif = str_printf(sym, " (%s%s)", modifier, str_modif);
-                modifier = NULL;
-            }
-            else
-                str_modif = str_printf(sym, " (%s)", str_modif);
+            str_modif = str_printf(sym, " (%s%s)", xdt.left, str_modif);
+            xdt.left = NULL;
 
             while (num--)
                 str_modif = str_printf(sym, "%s[%s]", str_modif, get_number(sym));
@@ -487,12 +500,12 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
         /* Recurse to get the referred-to type */
         if (!demangle_datatype(sym, &sub_ct, pmt_ref, FALSE))
             return FALSE;
-        if (modifier)
-            ct->left = str_printf(sym, "%s %s%s", sub_ct.left, modifier, str_modif );
+        if (xdt.left)
+            ct->left = str_printf(sym, "%s %s%s", sub_ct.left, xdt.left, str_modif);
         else
         {
             /* don't insert a space between duplicate '*' */
-            if (!in_args && str_modif[0] && str_modif[1] == '*' && sub_ct.left[strlen(sub_ct.left)-1] == '*')
+            if (!in_args && str_modif && str_modif[0] && str_modif[1] == '*' && sub_ct.left[strlen(sub_ct.left)-1] == '*')
                 str_modif++;
             ct->left = str_printf(sym, "%s%s", sub_ct.left, str_modif );
         }
@@ -872,19 +885,18 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
                 struct datatype_t       sub_ct;
                 unsigned                mark = sym->stack.num;
                 const char*             class;
-                const char*             modifier;
-                const char*             ptr_modif;
+                struct datatype_t       xdt;
 
                 sym->current++;
 
                 if (!(class = get_class_name(sym)))
                     goto done;
-                if (!get_modifier(sym, &modifier, &ptr_modif))
+                if (!get_modifier(sym, &xdt))
                     goto done;
-                if (modifier)
-                    modifier = str_printf(sym, "%s %s", modifier, ptr_modif);
-                else if(ptr_modif)
-                    modifier = str_printf(sym, " %s", ptr_modif);
+                if (xdt.left)
+                    xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
+                else if (xdt.right)
+                    xdt.left = str_printf(sym, " %s", xdt.right);
                 if (!get_calling_convention(*sym->current++,
                             &call_conv, &exported,
                             sym->flags & ~UNDNAME_NO_ALLOCATION_LANGUAGE))
@@ -898,7 +910,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
 
                 ct->left  = str_printf(sym, "%s%s (%s %s::*",
                         sub_ct.left, sub_ct.right, call_conv, class);
-                ct->right = str_printf(sym, ")%s%s", args, modifier);
+                ct->right = str_printf(sym, ")%s%s", args, xdt.left);
             }
             else if (*sym->current == '6')
             {
@@ -1025,12 +1037,12 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
             }
             else if (*sym->current == 'C')
             {
-                const char *ptr, *ptr_modif;
+                struct datatype_t xdt;
 
                 sym->current++;
-                if (!get_modifier(sym, &ptr, &ptr_modif)) goto done;
+                if (!get_modifier(sym, &xdt)) goto done;
                 if (!demangle_datatype(sym, ct, pmt_ref, in_args)) goto done;
-                ct->left = str_printf(sym, "%s %s", ct->left, ptr);
+                ct->left = str_printf(sym, "%s %s", ct->left, xdt.left);
             }
             else if (*sym->current == 'Q')
             {
@@ -1065,8 +1077,7 @@ static BOOL handle_data(struct parsed_symbol* sym)
 {
     const char*         access = NULL;
     const char*         member_type = NULL;
-    const char*         modifier = NULL;
-    const char*         ptr_modif;
+    struct datatype_t   xdt = {NULL};
     struct datatype_t   ct;
     char*               name = NULL;
     BOOL                ret = FALSE;
@@ -1111,16 +1122,16 @@ static BOOL handle_data(struct parsed_symbol* sym)
             str_array_init(&pmt);
 
             if (!demangle_datatype(sym, &ct, &pmt, FALSE)) goto done;
-            if (!get_modifier(sym, &modifier, &ptr_modif)) goto done;
-            if (modifier && ptr_modif) modifier = str_printf(sym, "%s %s", modifier, ptr_modif);
-            else if (!modifier) modifier = ptr_modif;
+            if (!get_modifier(sym, &xdt)) goto done;
+            if (xdt.left && xdt.right) xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
+            else if (!xdt.left) xdt.left = xdt.right;
             sym->stack.num = mark;
         }
         break;
     case '6' : /* compiler generated static */
     case '7' : /* compiler generated static */
         ct.left = ct.right = NULL;
-        if (!get_modifier(sym, &modifier, &ptr_modif)) goto done;
+        if (!get_modifier(sym, &xdt)) goto done;
         if (*sym->current != '@')
         {
             char*       cls = NULL;
@@ -1132,16 +1143,16 @@ static BOOL handle_data(struct parsed_symbol* sym)
         break;
     case '8':
     case '9':
-        modifier = ct.left = ct.right = NULL;
+        xdt.left = ct.left = ct.right = NULL;
         break;
     default: goto done;
     }
-    if (sym->flags & UNDNAME_NAME_ONLY) ct.left = ct.right = modifier = NULL;
+    if (sym->flags & UNDNAME_NAME_ONLY) ct.left = ct.right = xdt.left = NULL;
 
     sym->result = str_printf(sym, "%s%s%s%s%s%s%s%s", access,
-                             member_type, ct.left, 
-                             modifier && ct.left ? " " : NULL, modifier, 
-                             modifier || ct.left ? " " : NULL, name, ct.right);
+                             member_type, ct.left,
+                             xdt.left && ct.left ? " " : NULL, xdt.left,
+                             xdt.left || ct.left ? " " : NULL, name, ct.right);
     ret = TRUE;
 done:
     return ret;
@@ -1160,7 +1171,7 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
     const char*         member_type = NULL;
     struct datatype_t   ct_ret;
     const char*         call_conv;
-    const char*         modifier = NULL;
+    struct datatype_t   xdt = {NULL};
     const char*         exported;
     const char*         args_str = NULL;
     const char*         name = NULL;
@@ -1288,11 +1299,10 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
     if (has_args && (accmem == '$' ||
                 (accmem <= 'X' && (accmem - 'A') % 8 != 2 && (accmem - 'A') % 8 != 3)))
     {
-        const char *ptr_modif;
         /* Implicit 'this' pointer */
         /* If there is an implicit this pointer, const modifier follows */
-        if (!get_modifier(sym, &modifier, &ptr_modif)) goto done;
-        if (modifier || ptr_modif) modifier = str_printf(sym, "%s %s", modifier, ptr_modif);
+        if (!get_modifier(sym, &xdt)) goto done;
+        if (xdt.left || xdt.right) xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
     }
 
     if (!get_calling_convention(*sym->current++, &call_conv, &exported,
@@ -1323,8 +1333,8 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
 
     mark = sym->stack.num;
     if (has_args && !(args_str = get_args(sym, &array_pmt, TRUE, '(', ')'))) goto done;
-    if (sym->flags & UNDNAME_NAME_ONLY) args_str = modifier = NULL;
-    if (sym->flags & UNDNAME_NO_THISTYPE) modifier = NULL;
+    if (sym->flags & UNDNAME_NAME_ONLY) args_str = xdt.left = NULL;
+    if (sym->flags & UNDNAME_NO_THISTYPE) xdt.left = NULL;
     sym->stack.num = mark;
 
     /* Note: '()' after 'Z' means 'throws', but we don't care here
@@ -1334,7 +1344,7 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
                              access, member_type, ct_ret.left,
                              (ct_ret.left && !ct_ret.right) ? " " : NULL,
                              call_conv, call_conv ? " " : NULL, exported,
-                             name, args_str, modifier, ct_ret.right);
+                             name, args_str, xdt.left, ct_ret.right);
     ret = TRUE;
 done:
     return ret;
-- 
GitLab


From cadac12760161d724a1c3c05cdaca78d73a4b4b5 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Sat, 16 Jul 2022 12:20:25 +0200
Subject: [PATCH 5/5] msvcrt: Fix demangling of variables being an array.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/tests/cpp.c |  1 +
 dlls/msvcrt/undname.c   | 32 ++++++++++++++++++--------------
 2 files changed, 19 insertions(+), 14 deletions(-)

diff --git a/dlls/msvcrt/tests/cpp.c b/dlls/msvcrt/tests/cpp.c
index 79ea9d75c6b..58ecd1327a5 100644
--- a/dlls/msvcrt/tests/cpp.c
+++ b/dlls/msvcrt/tests/cpp.c
@@ -1294,6 +1294,7 @@ static void test_demangle(void)
 /* 131 */ {"??_R0?AVCC@DD@@@8", "class DD::CC `RTTI Type Descriptor'"},
 /* 132 */ {"??$meth@FD@DD@CC@@QAE_NK@Z", "public: bool __thiscall CC::DD::meth<short,char>(unsigned long)"},
 /* 133 */ {"?func@@YAXPIFAH@Z", "void __cdecl func(int __unaligned * __restrict)"},
+/* 135 */ {"?x@@3PAY02HA", "int (* x)[3]"},
     };
     int i, num_test = ARRAY_SIZE(test);
     char* name;
diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index 4b53ac459fb..acfe96fe436 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -466,11 +466,14 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
     default: return FALSE;
     }
     if (ref || str_modif || xdt.left || xdt.right)
-        str_modif = str_printf(sym, " %s%s%s%s%s%s%s",
-                               xdt.left,
-                               xdt.left && ref ? " " : NULL, ref,
-                               (xdt.left || ref) && xdt.right ? " " : NULL, xdt.right,
-                               (xdt.left || ref || xdt.right) && str_modif ? " " : NULL, str_modif);
+        ct->left = str_printf(sym, " %s%s%s%s%s%s%s",
+                              xdt.left,
+                              xdt.left && ref ? " " : NULL, ref,
+                              (xdt.left || ref) && xdt.right ? " " : NULL, xdt.right,
+                              (xdt.left || ref || xdt.right) && str_modif ? " " : NULL, str_modif);
+    else
+        ct->left = NULL;
+    ct->right = NULL;
 
     if (get_modifier(sym, &xdt))
     {
@@ -487,29 +490,30 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
             if (!(n1 = get_number(sym))) return FALSE;
             num = atoi(n1);
 
-            if (str_modif[0] == ' ' && !xdt.left)
-                str_modif++;
+            if (ct->left && ct->left[0] == ' ' && !xdt.left)
+                ct->left++;
 
-            str_modif = str_printf(sym, " (%s%s)", xdt.left, str_modif);
+            ct->left = str_printf(sym, " (%s%s", xdt.left, ct->left);
+            ct->right = ")";
             xdt.left = NULL;
 
             while (num--)
-                str_modif = str_printf(sym, "%s[%s]", str_modif, get_number(sym));
+                ct->right = str_printf(sym, "%s[%s]", ct->right, get_number(sym));
         }
 
         /* Recurse to get the referred-to type */
         if (!demangle_datatype(sym, &sub_ct, pmt_ref, FALSE))
             return FALSE;
         if (xdt.left)
-            ct->left = str_printf(sym, "%s %s%s", sub_ct.left, xdt.left, str_modif);
+            ct->left = str_printf(sym, "%s %s%s", sub_ct.left, xdt.left, ct->left);
         else
         {
             /* don't insert a space between duplicate '*' */
-            if (!in_args && str_modif && str_modif[0] && str_modif[1] == '*' && sub_ct.left[strlen(sub_ct.left)-1] == '*')
-                str_modif++;
-            ct->left = str_printf(sym, "%s%s", sub_ct.left, str_modif );
+            if (!in_args && ct->left && ct->left[0] && ct->left[1] == '*' && sub_ct.left[strlen(sub_ct.left)-1] == '*')
+                ct->left++;
+            ct->left = str_printf(sym, "%s%s", sub_ct.left, ct->left);
         }
-        ct->right = sub_ct.right;
+        if (sub_ct.right) ct->right = str_printf(sym, "%s%s", ct->right, sub_ct.right);
         sym->stack.num = mark;
     }
     return TRUE;
-- 
GitLab

From 766085edd2491b42fa743229437d159f2ad4156a Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 31 Aug 2022 10:39:16 +0200
Subject: [PATCH 1/6] msvcrt: Correctly support space generation in pointers.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/tests/cpp.c |  2 ++
 dlls/msvcrt/undname.c   | 53 ++++++++++++++++++++---------------------
 2 files changed, 28 insertions(+), 27 deletions(-)

diff --git a/dlls/msvcrt/tests/cpp.c b/dlls/msvcrt/tests/cpp.c
index 58ecd1327a5..90f3d6a9d6a 100644
--- a/dlls/msvcrt/tests/cpp.c
+++ b/dlls/msvcrt/tests/cpp.c
@@ -1295,6 +1295,8 @@ static void test_demangle(void)
 /* 132 */ {"??$meth@FD@DD@CC@@QAE_NK@Z", "public: bool __thiscall CC::DD::meth<short,char>(unsigned long)"},
 /* 133 */ {"?func@@YAXPIFAH@Z", "void __cdecl func(int __unaligned * __restrict)"},
 /* 135 */ {"?x@@3PAY02HA", "int (* x)[3]"},
+/* 136 */ {"?Qux@Bar@@0PAPAP6AHPAV1@AAH1PAH@ZA",
+           "private: static int (__cdecl** * Bar::Qux)(class Bar *,int &,int &,int *)"}, /* variation of 105: note white space handling! */
     };
     int i, num_test = ARRAY_SIZE(test);
     char* name;
diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index acfe96fe436..7daae616efd 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -77,11 +77,17 @@ struct parsed_symbol
     unsigned            avail_in_first; /* number of available bytes in head block */
 };
 
+enum datatype_e
+{
+    DT_NO_LEADING_WS = 0x01,
+};
+
 /* Type for parsing mangled types */
 struct datatype_t
 {
     const char*         left;
     const char*         right;
+    enum datatype_e     flags;
 };
 
 static BOOL symbol_demangle(struct parsed_symbol* sym);
@@ -407,6 +413,7 @@ static void append_extended_modifier(struct parsed_symbol *sym, const char **whe
 static void get_extended_modifier(struct parsed_symbol *sym, struct datatype_t *xdt)
 {
     xdt->left = xdt->right = NULL;
+    xdt->flags = 0;
     for (;;)
     {
         switch (*sym->current)
@@ -455,25 +462,24 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
 
     switch (modif)
     {
-    case 'A': ref = "&";  str_modif = NULL;             break;
-    case 'B': ref = "&";  str_modif = "volatile";       break;
-    case 'P': ref = "*";  str_modif = NULL;             break;
-    case 'Q': ref = "*";  str_modif = "const";          break;
-    case 'R': ref = "*";  str_modif = "volatile";       break;
-    case 'S': ref = "*";  str_modif = "const volatile"; break;
-    case '?': ref = NULL; str_modif = NULL;             break;
-    case '$': ref = "&&"; str_modif = NULL;             break;
+    case 'A': ref = " &";  str_modif = NULL;              break;
+    case 'B': ref = " &";  str_modif = " volatile";       break;
+    case 'P': ref = " *";  str_modif = NULL;              break;
+    case 'Q': ref = " *";  str_modif = " const";          break;
+    case 'R': ref = " *";  str_modif = " volatile";       break;
+    case 'S': ref = " *";  str_modif = " const volatile"; break;
+    case '?': ref = NULL;  str_modif = NULL;              break;
+    case '$': ref = " &&"; str_modif = NULL;              break;
     default: return FALSE;
     }
     if (ref || str_modif || xdt.left || xdt.right)
-        ct->left = str_printf(sym, " %s%s%s%s%s%s%s",
-                              xdt.left,
-                              xdt.left && ref ? " " : NULL, ref,
-                              (xdt.left || ref) && xdt.right ? " " : NULL, xdt.right,
-                              (xdt.left || ref || xdt.right) && str_modif ? " " : NULL, str_modif);
+        ct->left = str_printf(sym, "%s%s%s%s%s%s",
+                              xdt.left ? " " : NULL, xdt.left, ref,
+                              xdt.right ? " " : NULL, xdt.right, str_modif);
     else
         ct->left = NULL;
     ct->right = NULL;
+    ct->flags = 0;
 
     if (get_modifier(sym, &xdt))
     {
@@ -490,10 +496,7 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
             if (!(n1 = get_number(sym))) return FALSE;
             num = atoi(n1);
 
-            if (ct->left && ct->left[0] == ' ' && !xdt.left)
-                ct->left++;
-
-            ct->left = str_printf(sym, " (%s%s", xdt.left, ct->left);
+            ct->left = str_printf(sym, " (%s%s", xdt.left, ct->left && !xdt.left ? ct->left + 1 : ct->left);
             ct->right = ")";
             xdt.left = NULL;
 
@@ -504,15 +507,9 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
         /* Recurse to get the referred-to type */
         if (!demangle_datatype(sym, &sub_ct, pmt_ref, FALSE))
             return FALSE;
-        if (xdt.left)
-            ct->left = str_printf(sym, "%s %s%s", sub_ct.left, xdt.left, ct->left);
-        else
-        {
-            /* don't insert a space between duplicate '*' */
-            if (!in_args && ct->left && ct->left[0] && ct->left[1] == '*' && sub_ct.left[strlen(sub_ct.left)-1] == '*')
-                ct->left++;
-            ct->left = str_printf(sym, "%s%s", sub_ct.left, ct->left);
-        }
+        if (sub_ct.flags & DT_NO_LEADING_WS)
+            ct->left++;
+        ct->left = str_printf(sym, "%s%s%s%s", sub_ct.left, xdt.left ? " " : NULL, xdt.left, ct->left);
         if (sub_ct.right) ct->right = str_printf(sym, "%s%s", ct->right, sub_ct.right);
         sym->stack.num = mark;
     }
@@ -814,7 +811,8 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
 
     assert(ct);
     ct->left = ct->right = NULL;
-    
+    ct->flags = 0;
+
     switch (dt = *sym->current++)
     {
     case '_':
@@ -938,6 +936,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
 
                 ct->left  = str_printf(sym, "%s%s (%s*", 
                                        sub_ct.left, sub_ct.right, call_conv);
+                ct->flags = DT_NO_LEADING_WS;
                 ct->right = str_printf(sym, ")%s", args);
             }
             else goto done;
-- 
GitLab


From 507a02c1d39507207b8a1b485a9fbcb451635409 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 31 Aug 2022 10:39:16 +0200
Subject: [PATCH 2/6] msvcrt: Improve support for template in methods.

Adding function template support for methods that need specific
post processing in demangling
(constructor, destructor, cast operator)

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/tests/cpp.c |  4 ++++
 dlls/msvcrt/undname.c   | 48 +++++++++++++++++++----------------------
 2 files changed, 26 insertions(+), 26 deletions(-)

diff --git a/dlls/msvcrt/tests/cpp.c b/dlls/msvcrt/tests/cpp.c
index 90f3d6a9d6a..04573aa3d65 100644
--- a/dlls/msvcrt/tests/cpp.c
+++ b/dlls/msvcrt/tests/cpp.c
@@ -1297,6 +1297,10 @@ static void test_demangle(void)
 /* 135 */ {"?x@@3PAY02HA", "int (* x)[3]"},
 /* 136 */ {"?Qux@Bar@@0PAPAP6AHPAV1@AAH1PAH@ZA",
            "private: static int (__cdecl** * Bar::Qux)(class Bar *,int &,int &,int *)"}, /* variation of 105: note white space handling! */
+/* 137 */ {"?x@@3PAW4myenum@@A", "enum myenum * x"},
+/* 138 */ {"?pfunc@@3PAY0E@P6AXF@ZA", "void (__cdecl*(* pfunc)[4])(short)"},
+/* 139 */ {"??$?0AEAVzzz@BB4@AA@@AEAV012@$0A@@?$pair@Vzzz@BB4@AA@@V123@@std@@QEAA@AEAVzzz@BB4@AA@@0@Z",
+           "public: __cdecl std::pair<class AA::BB4::zzz,class AA::BB4::zzz>::pair<class AA::BB4::zzz,class AA::BB4::zzz><class AA::BB4::zzz & __ptr64,class AA::BB4::zzz & __ptr64,0>(class AA::BB4::zzz & __ptr64,class AA::BB4::zzz & __ptr64) __ptr64"},
     };
     int i, num_test = ARRAY_SIZE(test);
     char* name;
diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index 7daae616efd..de07dd3ac24 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -452,7 +452,7 @@ static BOOL get_modifier(struct parsed_symbol *sym, struct datatype_t *xdt)
 }
 
 static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
-                              struct array *pmt_ref, char modif, BOOL in_args)
+                              struct array *pmt_ref, char modif)
 {
     struct datatype_t xdt;
     const char* ref;
@@ -860,17 +860,17 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
         }
         else
         {
-            if (!get_modified_type(ct, sym, pmt_ref, '?', in_args)) goto done;
+            if (!get_modified_type(ct, sym, pmt_ref, '?')) goto done;
         }
         break;
     case 'A': /* reference */
     case 'B': /* volatile reference */
-        if (!get_modified_type(ct, sym, pmt_ref, dt, in_args)) goto done;
+        if (!get_modified_type(ct, sym, pmt_ref, dt)) goto done;
         break;
     case 'Q': /* const pointer */
     case 'R': /* volatile pointer */
     case 'S': /* const volatile pointer */
-        if (!get_modified_type(ct, sym, pmt_ref, in_args ? dt : 'P', in_args)) goto done;
+        if (!get_modified_type(ct, sym, pmt_ref, in_args ? dt : 'P')) goto done;
         break;
     case 'P': /* Pointer */
         if (isdigit(*sym->current))
@@ -941,7 +941,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
             }
             else goto done;
 	}
-	else if (!get_modified_type(ct, sym, pmt_ref, 'P', in_args)) goto done;
+	else if (!get_modified_type(ct, sym, pmt_ref, 'P')) goto done;
         break;
     case 'W':
         if (*sym->current == '4')
@@ -1050,7 +1050,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
             else if (*sym->current == 'Q')
             {
                 sym->current++;
-                if (!get_modified_type(ct, sym, pmt_ref, '$', in_args)) goto done;
+                if (!get_modified_type(ct, sym, pmt_ref, '$')) goto done;
             }
             break;
         }
@@ -1361,7 +1361,6 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
 {
     BOOL                ret = FALSE;
     unsigned            do_after = 0;
-    static CHAR         dashed_null[] = "--null--";
 
     /* FIXME seems wrong as name, as it demangles a simple data type */
     if (sym->flags & UNDNAME_NO_ARGUMENTS)
@@ -1384,18 +1383,19 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
     if (*sym->current == '?')
     {
         const char* function_name = NULL;
+        BOOL in_template = FALSE;
 
         if (sym->current[1] == '$' && sym->current[2] == '?')
         {
-            do_after = 5;
+            in_template = TRUE;
             sym->current += 2;
         }
 
         /* C++ operator code (one character, or two if the first is '_') */
         switch (*++sym->current)
         {
-        case '0': do_after = 1; break;
-        case '1': do_after = 2; break;
+        case '0': function_name = ""; do_after = 1; break;
+        case '1': function_name = ""; do_after = 2; break;
         case '2': function_name = "operator new"; break;
         case '3': function_name = "operator delete"; break;
         case '4': function_name = "operator="; break;
@@ -1530,26 +1530,22 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
             return FALSE;
         }
         sym->current++;
+        if (in_template)
+        {
+            const char *args;
+            struct array array_pmt;
+
+            str_array_init(&array_pmt);
+            args = get_args(sym, &array_pmt, FALSE, '<', '>');
+            if (args) function_name = function_name ? str_printf(sym, "%s%s", function_name, args) : args;
+            sym->names.num = 0;
+        }
         switch (do_after)
         {
-        case 1: case 2:
-            if (!str_array_push(sym, dashed_null, -1, &sym->stack))
-                return FALSE;
-            break;
         case 4:
             sym->result = (char*)function_name;
             ret = TRUE;
             goto done;
-        case 5:
-            {
-                char *args;
-                struct array array_pmt;
-
-                str_array_init(&array_pmt);
-                args = get_args(sym, &array_pmt, FALSE, '<', '>');
-                if (args != NULL) function_name = str_printf(sym, "%s%s", function_name, args);
-                sym->names.num = 0;
-            }
             /* fall through */
         default:
             if (!str_array_push(sym, function_name, -1, &sym->stack))
@@ -1584,9 +1580,9 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
         /* it's time to set the member name for ctor & dtor */
         if (sym->stack.num <= 1) goto done;
         if (do_after == 1)
-            sym->stack.elts[0] = sym->stack.elts[1];
+            sym->stack.elts[0] = str_printf(sym, "%s%s", sym->stack.elts[1], sym->stack.elts[0]);
         else
-            sym->stack.elts[0] = str_printf(sym, "~%s", sym->stack.elts[1]);
+            sym->stack.elts[0] = str_printf(sym, "~%s%s", sym->stack.elts[1], sym->stack.elts[0]);
         /* ctors and dtors don't have return type */
         sym->flags |= UNDNAME_NO_FUNCTION_RETURNS;
         break;
-- 
GitLab


From 5e37bcf7940ab16e6098cb91e8f21ae688d6dea4 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 31 Aug 2022 10:39:16 +0200
Subject: [PATCH 3/6] msvcrt: Fix white space output for typecast operator.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/tests/cpp.c |  3 +++
 dlls/msvcrt/undname.c   | 54 +++++++++++++++++++++++------------------
 2 files changed, 34 insertions(+), 23 deletions(-)

diff --git a/dlls/msvcrt/tests/cpp.c b/dlls/msvcrt/tests/cpp.c
index 04573aa3d65..98733300a90 100644
--- a/dlls/msvcrt/tests/cpp.c
+++ b/dlls/msvcrt/tests/cpp.c
@@ -1301,6 +1301,9 @@ static void test_demangle(void)
 /* 138 */ {"?pfunc@@3PAY0E@P6AXF@ZA", "void (__cdecl*(* pfunc)[4])(short)"},
 /* 139 */ {"??$?0AEAVzzz@BB4@AA@@AEAV012@$0A@@?$pair@Vzzz@BB4@AA@@V123@@std@@QEAA@AEAVzzz@BB4@AA@@0@Z",
            "public: __cdecl std::pair<class AA::BB4::zzz,class AA::BB4::zzz>::pair<class AA::BB4::zzz,class AA::BB4::zzz><class AA::BB4::zzz & __ptr64,class AA::BB4::zzz & __ptr64,0>(class AA::BB4::zzz & __ptr64,class AA::BB4::zzz & __ptr64) __ptr64"},
+/* 140 */ {"??$?BH@?$foo@N@@QEAAHXZ", "public: __cdecl foo<double>::operator<int> int(void) __ptr64"},
+/* 141 */ {"??Bcastop@@QAEHXZ", "public: __thiscall castop::operator int(void)"},
+/* 142 */ {"??Bcastop@@QAE?BHXZ", "public: __thiscall castop::operator int const (void)"},
     };
     int i, num_test = ARRAY_SIZE(test);
     char* name;
diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index de07dd3ac24..10347ec38fa 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -291,9 +291,15 @@ static char* WINAPIV str_printf(struct parsed_symbol* sym, const char* format, .
     return tmp;
 }
 
+enum datatype_flags
+{
+    IN_ARGS = 0x01,
+    WS_AFTER_QUAL_IF = 0x02,
+};
+
 /* forward declaration */
 static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
-                              struct array* pmt, BOOL in_args);
+                              struct array* pmt, enum datatype_flags flags);
 
 static const char* get_number(struct parsed_symbol* sym)
 {
@@ -367,7 +373,7 @@ static char* get_args(struct parsed_symbol* sym, struct array* pmt_ref, BOOL z_t
             sym->current++;
             break;
         }
-        if (!demangle_datatype(sym, &ct, pmt_ref, TRUE))
+        if (!demangle_datatype(sym, &ct, pmt_ref, IN_ARGS))
             return NULL;
         /* 'void' terminates an argument list in a function */
         if (z_term && !strcmp(ct.left, "void")) break;
@@ -452,7 +458,7 @@ static BOOL get_modifier(struct parsed_symbol *sym, struct datatype_t *xdt)
 }
 
 static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
-                              struct array *pmt_ref, char modif)
+                              struct array *pmt_ref, char modif, enum datatype_flags flags)
 {
     struct datatype_t xdt;
     const char* ref;
@@ -505,11 +511,13 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
         }
 
         /* Recurse to get the referred-to type */
-        if (!demangle_datatype(sym, &sub_ct, pmt_ref, FALSE))
+        if (!demangle_datatype(sym, &sub_ct, pmt_ref, 0))
             return FALSE;
         if (sub_ct.flags & DT_NO_LEADING_WS)
             ct->left++;
-        ct->left = str_printf(sym, "%s%s%s%s", sub_ct.left, xdt.left ? " " : NULL, xdt.left, ct->left);
+        ct->left = str_printf(sym, "%s%s%s%s%s", sub_ct.left, xdt.left ? " " : NULL,
+                              xdt.left, ct->left,
+                              ((xdt.left || str_modif) && (flags & WS_AFTER_QUAL_IF)) ? " " : NULL);
         if (sub_ct.right) ct->right = str_printf(sym, "%s%s", ct->right, sub_ct.right);
         sym->stack.num = mark;
     }
@@ -804,7 +812,7 @@ static const char* get_extended_type(char c)
  * char** = (pointer to (pointer to (char)))
  */
 static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
-                              struct array* pmt_ref, BOOL in_args)
+                              struct array* pmt_ref, enum datatype_flags flags)
 {
     char                dt;
     BOOL                add_pmt = TRUE;
@@ -852,7 +860,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
         break;
     case '?':
         /* not all the time is seems */
-        if (in_args)
+        if (flags & IN_ARGS)
         {
             const char*   ptr;
             if (!(ptr = get_number(sym))) goto done;
@@ -860,17 +868,17 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
         }
         else
         {
-            if (!get_modified_type(ct, sym, pmt_ref, '?')) goto done;
+            if (!get_modified_type(ct, sym, pmt_ref, '?', flags)) goto done;
         }
         break;
     case 'A': /* reference */
     case 'B': /* volatile reference */
-        if (!get_modified_type(ct, sym, pmt_ref, dt)) goto done;
+        if (!get_modified_type(ct, sym, pmt_ref, dt, flags)) goto done;
         break;
     case 'Q': /* const pointer */
     case 'R': /* volatile pointer */
     case 'S': /* const volatile pointer */
-        if (!get_modified_type(ct, sym, pmt_ref, in_args ? dt : 'P')) goto done;
+        if (!get_modified_type(ct, sym, pmt_ref, (flags & IN_ARGS) ? dt : 'P', flags)) goto done;
         break;
     case 'P': /* Pointer */
         if (isdigit(*sym->current))
@@ -903,7 +911,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
                             &call_conv, &exported,
                             sym->flags & ~UNDNAME_NO_ALLOCATION_LANGUAGE))
                     goto done;
-                if (!demangle_datatype(sym, &sub_ct, pmt_ref, FALSE))
+                if (!demangle_datatype(sym, &sub_ct, pmt_ref, 0))
                     goto done;
 
                 args = get_args(sym, pmt_ref, TRUE, '(', ')');
@@ -927,7 +935,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
                 if (!get_calling_convention(*sym->current++,
                                             &call_conv, &exported, 
                                             sym->flags & ~UNDNAME_NO_ALLOCATION_LANGUAGE) ||
-                    !demangle_datatype(sym, &sub_ct, pmt_ref, FALSE))
+                    !demangle_datatype(sym, &sub_ct, pmt_ref, 0))
                     goto done;
 
                 args = get_args(sym, pmt_ref, TRUE, '(', ')');
@@ -941,7 +949,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
             }
             else goto done;
 	}
-	else if (!get_modified_type(ct, sym, pmt_ref, 'P')) goto done;
+	else if (!get_modified_type(ct, sym, pmt_ref, 'P', flags)) goto done;
         break;
     case 'W':
         if (*sym->current == '4')
@@ -1029,7 +1037,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
                         arr = str_printf(sym, "%s[%s]", arr, get_number(sym));
                 }
 
-                if (!demangle_datatype(sym, &sub_ct, pmt_ref, FALSE)) goto done;
+                if (!demangle_datatype(sym, &sub_ct, pmt_ref, 0)) goto done;
 
                 if (arr)
                     ct->left = str_printf(sym, "%s %s", sub_ct.left, arr);
@@ -1044,13 +1052,13 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
 
                 sym->current++;
                 if (!get_modifier(sym, &xdt)) goto done;
-                if (!demangle_datatype(sym, ct, pmt_ref, in_args)) goto done;
+                if (!demangle_datatype(sym, ct, pmt_ref, flags)) goto done;
                 ct->left = str_printf(sym, "%s %s", ct->left, xdt.left);
             }
             else if (*sym->current == 'Q')
             {
                 sym->current++;
-                if (!get_modified_type(ct, sym, pmt_ref, '$')) goto done;
+                if (!get_modified_type(ct, sym, pmt_ref, '$', flags)) goto done;
             }
             break;
         }
@@ -1059,7 +1067,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
         ERR("Unknown type %c\n", dt);
         break;
     }
-    if (add_pmt && pmt_ref && in_args)
+    if (add_pmt && pmt_ref && (flags & IN_ARGS))
     {
         /* left and right are pushed as two separate strings */
         if (!str_array_push(sym, ct->left ? ct->left : "", -1, pmt_ref) ||
@@ -1124,7 +1132,7 @@ static BOOL handle_data(struct parsed_symbol* sym)
 
             str_array_init(&pmt);
 
-            if (!demangle_datatype(sym, &ct, &pmt, FALSE)) goto done;
+            if (!demangle_datatype(sym, &ct, &pmt, 0)) goto done;
             if (!get_modifier(sym, &xdt)) goto done;
             if (xdt.left && xdt.right) xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
             else if (!xdt.left) xdt.left = xdt.right;
@@ -1323,14 +1331,14 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
     }
     else if (has_ret)
     {
-        if (!demangle_datatype(sym, &ct_ret, &array_pmt, FALSE))
+        if (!demangle_datatype(sym, &ct_ret, &array_pmt, cast_op ? WS_AFTER_QUAL_IF : 0))
             goto done;
     }
     if (!has_ret || sym->flags & UNDNAME_NO_FUNCTION_RETURNS)
         ct_ret.left = ct_ret.right = NULL;
     if (cast_op)
     {
-        name = str_printf(sym, "%s%s%s", name, ct_ret.left, ct_ret.right);
+        name = str_printf(sym, "%s %s%s", name, ct_ret.left, ct_ret.right);
         ct_ret.left = ct_ret.right = NULL;
     }
 
@@ -1367,7 +1375,7 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
     {
         struct datatype_t   ct;
 
-        if (demangle_datatype(sym, &ct, NULL, FALSE))
+        if (demangle_datatype(sym, &ct, NULL, 0))
         {
             sym->result = str_printf(sym, "%s%s", ct.left, ct.right);
             ret = TRUE;
@@ -1405,7 +1413,7 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
         case '8': function_name = "operator=="; break;
         case '9': function_name = "operator!="; break;
         case 'A': function_name = "operator[]"; break;
-        case 'B': function_name = "operator "; do_after = 3; break;
+        case 'B': function_name = "operator"; do_after = 3; break;
         case 'C': function_name = "operator->"; break;
         case 'D': function_name = "operator*"; break;
         case 'E': function_name = "operator++"; break;
@@ -1467,7 +1475,7 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
                         struct datatype_t       ct;
 
                         sym->current++;
-                        if (!demangle_datatype(sym, &ct, NULL, FALSE))
+                        if (!demangle_datatype(sym, &ct, NULL, 0))
                             goto done;
                         function_name = str_printf(sym, "%s%s `RTTI Type Descriptor'",
                                                    ct.left, ct.right);
-- 
GitLab


From 22362757adebe82f27c26a478a19ca86f1ee596c Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 31 Aug 2022 10:39:16 +0200
Subject: [PATCH 4/6] msvcrt: Undecorate function signature as template
 argument.

Introducing get_function_signaturei() to factorize parsing of function
signature.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/tests/cpp.c |   6 ++
 dlls/msvcrt/undname.c   | 169 ++++++++++++++++++++++++++--------------
 2 files changed, 117 insertions(+), 58 deletions(-)

diff --git a/dlls/msvcrt/tests/cpp.c b/dlls/msvcrt/tests/cpp.c
index 98733300a90..7735da4ea89 100644
--- a/dlls/msvcrt/tests/cpp.c
+++ b/dlls/msvcrt/tests/cpp.c
@@ -1304,6 +1304,12 @@ static void test_demangle(void)
 /* 140 */ {"??$?BH@?$foo@N@@QEAAHXZ", "public: __cdecl foo<double>::operator<int> int(void) __ptr64"},
 /* 141 */ {"??Bcastop@@QAEHXZ", "public: __thiscall castop::operator int(void)"},
 /* 142 */ {"??Bcastop@@QAE?BHXZ", "public: __thiscall castop::operator int const (void)"},
+/* 143 */ {"?pfield@@3PTAA@@DT1@", "char const volatile AA::* const volatile pfield"},
+/* 144 */ {"?ptititi1@@3PEQtititi@@IEQ1@", "unsigned int tititi::* __ptr64 __ptr64 ptititi1"},
+/* 145 */ {"?ptititi2@@3PERtititi@@IER1@", "unsigned int const tititi::* __ptr64 const __ptr64 ptititi2"},
+/* 146 */ {"?ptititi3@@3PEStititi@@IES1@", "unsigned int volatile tititi::* __ptr64 volatile __ptr64 ptititi3"},
+/* 147 */ {"?ptititi4@@3PETtititi@@IET1@", "unsigned int const volatile tititi::* __ptr64 const volatile __ptr64 ptititi4"},
+/* 148 */ {"?ptititi4v@@3RETtititi@@IET1@", "unsigned int const volatile tititi::* __ptr64 const volatile __ptr64 ptititi4v"},
     };
     int i, num_test = ARRAY_SIZE(test);
     char* name;
diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index 10347ec38fa..a3ad3497c00 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -91,6 +91,7 @@ struct datatype_t
 };
 
 static BOOL symbol_demangle(struct parsed_symbol* sym);
+static char* get_class_name(struct parsed_symbol* sym);
 
 /******************************************************************
  *		und_alloc
@@ -437,34 +438,53 @@ static void get_extended_modifier(struct parsed_symbol *sym, struct datatype_t *
  *		get_modifier
  * Parses the type modifier. Always returns static strings.
  */
-static BOOL get_modifier(struct parsed_symbol *sym, struct datatype_t *xdt)
+static BOOL get_modifier(struct parsed_symbol *sym, struct datatype_t *xdt, const char** pclass)
 {
+    char ch;
     const char* mod;
 
     get_extended_modifier(sym, xdt);
-    switch (*sym->current++)
+    switch (ch = *sym->current++)
     {
     case 'A': mod = NULL; break;
     case 'B': mod = "const"; break;
     case 'C': mod = "volatile"; break;
     case 'D': mod = "const volatile"; break;
+    case 'Q': mod = NULL; break;
+    case 'R': mod = "const"; break;
+    case 'S': mod = "volatile"; break;
+    case 'T': mod = "const volatile"; break;
     default: return FALSE;
     }
     if (xdt->left && mod)
         xdt->left = str_printf(sym, "%s %s", xdt->left, mod);
     else if (mod)
         xdt->left = mod;
+    if (ch >= 'Q' && ch <= 'T') /* pointer to member, fetch class */
+    {
+        const char* class = get_class_name(sym);
+        if (!class) return FALSE;
+        if (!pclass)
+        {
+            FIXME("Got pointer to class %s member without storage\n", class);
+            return FALSE;
+        }
+        *pclass = class;
+    }
+    else if (pclass) *pclass = NULL;
     return TRUE;
 }
 
 static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
                               struct array *pmt_ref, char modif, enum datatype_flags flags)
 {
-    struct datatype_t xdt;
+    struct datatype_t xdt1;
+    struct datatype_t xdt2;
     const char* ref;
     const char* str_modif;
+    const char* class;
 
-    get_extended_modifier(sym, &xdt);
+    get_extended_modifier(sym, &xdt1);
 
     switch (modif)
     {
@@ -478,20 +498,28 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
     case '$': ref = " &&"; str_modif = NULL;              break;
     default: return FALSE;
     }
-    if (ref || str_modif || xdt.left || xdt.right)
-        ct->left = str_printf(sym, "%s%s%s%s%s%s",
-                              xdt.left ? " " : NULL, xdt.left, ref,
-                              xdt.right ? " " : NULL, xdt.right, str_modif);
-    else
-        ct->left = NULL;
     ct->right = NULL;
     ct->flags = 0;
 
-    if (get_modifier(sym, &xdt))
+    if (get_modifier(sym, &xdt2, &class))
     {
         unsigned            mark = sym->stack.num;
         struct datatype_t   sub_ct;
 
+        if (ref || str_modif || xdt1.left || xdt1.right)
+        {
+            if (class)
+                ct->left = str_printf(sym, "%s%s%s%s::%s%s%s",
+                                      xdt1.left ? " " : NULL, xdt1.left,
+                                      class ? " " : NULL, class, ref ? ref + 1 : NULL,
+                                      xdt1.right ? " " : NULL, xdt1.right, str_modif);
+            else
+                ct->left = str_printf(sym, "%s%s%s%s%s%s",
+                                      xdt1.left ? " " : NULL, xdt1.left, ref,
+                                      xdt1.right ? " " : NULL, xdt1.right, str_modif);
+        }
+        else
+            ct->left = NULL;
         /* multidimensional arrays */
         if (*sym->current == 'Y')
         {
@@ -502,9 +530,9 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
             if (!(n1 = get_number(sym))) return FALSE;
             num = atoi(n1);
 
-            ct->left = str_printf(sym, " (%s%s", xdt.left, ct->left && !xdt.left ? ct->left + 1 : ct->left);
+            ct->left = str_printf(sym, " (%s%s", xdt2.left, ct->left && !xdt2.left ? ct->left + 1 : ct->left);
             ct->right = ")";
-            xdt.left = NULL;
+            xdt2.left = NULL;
 
             while (num--)
                 ct->right = str_printf(sym, "%s[%s]", ct->right, get_number(sym));
@@ -515,12 +543,18 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
             return FALSE;
         if (sub_ct.flags & DT_NO_LEADING_WS)
             ct->left++;
-        ct->left = str_printf(sym, "%s%s%s%s%s", sub_ct.left, xdt.left ? " " : NULL,
-                              xdt.left, ct->left,
-                              ((xdt.left || str_modif) && (flags & WS_AFTER_QUAL_IF)) ? " " : NULL);
+        ct->left = str_printf(sym, "%s%s%s%s%s", sub_ct.left, xdt2.left ? " " : NULL,
+                              xdt2.left, ct->left,
+                              ((xdt2.left || str_modif) && (flags & WS_AFTER_QUAL_IF)) ? " " : NULL);
         if (sub_ct.right) ct->right = str_printf(sym, "%s%s", ct->right, sub_ct.right);
         sym->stack.num = mark;
     }
+    else if (ref || str_modif || xdt1.left || xdt1.right)
+        ct->left = str_printf(sym, "%s%s%s%s%s%s",
+                              xdt1.left ? " " : NULL, xdt1.left, ref,
+                              xdt1.right ? " " : NULL, xdt1.right, str_modif);
+    else
+        ct->left = NULL;
     return TRUE;
 }
 
@@ -804,6 +838,32 @@ static const char* get_extended_type(char c)
     return type_string;
 }
 
+struct function_signature
+{
+    const char*             call_conv;
+    const char*             exported;
+    struct datatype_t       return_ct;
+    const char*             arguments;
+};
+
+static BOOL get_function_signature(struct parsed_symbol* sym, struct array* pmt_ref,
+                                   struct function_signature* fs)
+{
+    unsigned mark = sym->stack.num;
+
+    if (!get_calling_convention(*sym->current++,
+                                &fs->call_conv, &fs->exported,
+                                sym->flags & ~UNDNAME_NO_ALLOCATION_LANGUAGE) ||
+        !demangle_datatype(sym, &fs->return_ct, pmt_ref, FALSE))
+        return FALSE;
+
+    if (!(fs->arguments = get_args(sym, pmt_ref, TRUE, '(', ')')))
+        return FALSE;
+    sym->stack.num = mark;
+
+    return TRUE;
+}
+
 /*******************************************************************
  *         demangle_datatype
  *
@@ -889,63 +949,40 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
              *   others who knows.. */
             if (*sym->current == '8')
             {
-                char*                   args = NULL;
-                const char*             call_conv;
-                const char*             exported;
-                struct datatype_t       sub_ct;
-                unsigned                mark = sym->stack.num;
-                const char*             class;
-                struct datatype_t       xdt;
+                struct function_signature       fs;
+                const char*                     class;
+                struct datatype_t               xdt;
 
                 sym->current++;
 
                 if (!(class = get_class_name(sym)))
                     goto done;
-                if (!get_modifier(sym, &xdt))
+                if (!get_modifier(sym, &xdt, NULL))
                     goto done;
+                if (!get_function_signature(sym, pmt_ref, &fs))
+                     goto done;
                 if (xdt.left)
                     xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
                 else if (xdt.right)
                     xdt.left = str_printf(sym, " %s", xdt.right);
-                if (!get_calling_convention(*sym->current++,
-                            &call_conv, &exported,
-                            sym->flags & ~UNDNAME_NO_ALLOCATION_LANGUAGE))
-                    goto done;
-                if (!demangle_datatype(sym, &sub_ct, pmt_ref, 0))
-                    goto done;
-
-                args = get_args(sym, pmt_ref, TRUE, '(', ')');
-                if (!args) goto done;
-                sym->stack.num = mark;
 
                 ct->left  = str_printf(sym, "%s%s (%s %s::*",
-                        sub_ct.left, sub_ct.right, call_conv, class);
-                ct->right = str_printf(sym, ")%s%s", args, xdt.left);
+                                       fs.return_ct.left, fs.return_ct.right, fs.call_conv, class);
+                ct->right = str_printf(sym, ")%s%s", fs.arguments, xdt.left);
             }
             else if (*sym->current == '6')
             {
-                char*                   args = NULL;
-                const char*             call_conv;
-                const char*             exported;
-                struct datatype_t       sub_ct;
-                unsigned                mark = sym->stack.num;
+                struct function_signature       fs;
 
                 sym->current++;
 
-                if (!get_calling_convention(*sym->current++,
-                                            &call_conv, &exported, 
-                                            sym->flags & ~UNDNAME_NO_ALLOCATION_LANGUAGE) ||
-                    !demangle_datatype(sym, &sub_ct, pmt_ref, 0))
-                    goto done;
-
-                args = get_args(sym, pmt_ref, TRUE, '(', ')');
-                if (!args) goto done;
-                sym->stack.num = mark;
+                if (!get_function_signature(sym, pmt_ref, &fs))
+                     goto done;
 
-                ct->left  = str_printf(sym, "%s%s (%s*", 
-                                       sub_ct.left, sub_ct.right, call_conv);
+                ct->left  = str_printf(sym, "%s%s (%s*",
+                                       fs.return_ct.left, fs.return_ct.right, fs.call_conv);
                 ct->flags = DT_NO_LEADING_WS;
-                ct->right = str_printf(sym, ")%s", args);
+                ct->right = str_printf(sym, ")%s", fs.arguments);
             }
             else goto done;
 	}
@@ -1016,7 +1053,22 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
             }
             break;
         case '$':
-            if (*sym->current == 'B')
+            if (*sym->current == 'A')
+            {
+                sym->current++;
+                if (*sym->current == '6')
+                {
+                    struct function_signature fs;
+
+                    sym->current++;
+
+                    if (!get_function_signature(sym, pmt_ref, &fs))
+                        goto done;
+                    ct->left = str_printf(sym, "%s%s %s%s",
+                                          fs.return_ct.left, fs.return_ct.right, fs.call_conv, fs.arguments);
+                }
+            }
+            else if (*sym->current == 'B')
             {
                 unsigned            mark = sym->stack.num;
                 struct datatype_t   sub_ct;
@@ -1051,7 +1103,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
                 struct datatype_t xdt;
 
                 sym->current++;
-                if (!get_modifier(sym, &xdt)) goto done;
+                if (!get_modifier(sym, &xdt, NULL)) goto done;
                 if (!demangle_datatype(sym, ct, pmt_ref, flags)) goto done;
                 ct->left = str_printf(sym, "%s %s", ct->left, xdt.left);
             }
@@ -1129,11 +1181,12 @@ static BOOL handle_data(struct parsed_symbol* sym)
         {
             unsigned mark = sym->stack.num;
             struct array pmt;
+            const char* class;
 
             str_array_init(&pmt);
 
             if (!demangle_datatype(sym, &ct, &pmt, 0)) goto done;
-            if (!get_modifier(sym, &xdt)) goto done;
+            if (!get_modifier(sym, &xdt, &class)) goto done; /* class doesn't seem to be displayed */
             if (xdt.left && xdt.right) xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
             else if (!xdt.left) xdt.left = xdt.right;
             sym->stack.num = mark;
@@ -1142,7 +1195,7 @@ static BOOL handle_data(struct parsed_symbol* sym)
     case '6' : /* compiler generated static */
     case '7' : /* compiler generated static */
         ct.left = ct.right = NULL;
-        if (!get_modifier(sym, &xdt)) goto done;
+        if (!get_modifier(sym, &xdt, NULL)) goto done;
         if (*sym->current != '@')
         {
             char*       cls = NULL;
@@ -1312,7 +1365,7 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
     {
         /* Implicit 'this' pointer */
         /* If there is an implicit this pointer, const modifier follows */
-        if (!get_modifier(sym, &xdt)) goto done;
+        if (!get_modifier(sym, &xdt, NULL)) goto done;
         if (xdt.left || xdt.right) xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
     }
 
-- 
GitLab


From 638b06015b6696358f4e30037a72981672ae3730 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 31 Aug 2022 10:39:16 +0200
Subject: [PATCH 5/6] msvcrt: Use enum to clarify post-processing actions.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/undname.c | 48 ++++++++++++++++++++-----------------------
 1 file changed, 22 insertions(+), 26 deletions(-)

diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index a3ad3497c00..424d977a2a7 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -1421,7 +1421,12 @@ done:
 static BOOL symbol_demangle(struct parsed_symbol* sym)
 {
     BOOL                ret = FALSE;
-    unsigned            do_after = 0;
+    enum {
+        PP_NONE,
+        PP_CONSTRUCTOR,
+        PP_DESTRUCTOR,
+        PP_CAST_OPERATOR,
+    } post_process = PP_NONE;
 
     /* FIXME seems wrong as name, as it demangles a simple data type */
     if (sym->flags & UNDNAME_NO_ARGUMENTS)
@@ -1455,8 +1460,8 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
         /* C++ operator code (one character, or two if the first is '_') */
         switch (*++sym->current)
         {
-        case '0': function_name = ""; do_after = 1; break;
-        case '1': function_name = ""; do_after = 2; break;
+        case '0': function_name = ""; post_process = PP_CONSTRUCTOR; break;
+        case '1': function_name = ""; post_process = PP_DESTRUCTOR; break;
         case '2': function_name = "operator new"; break;
         case '3': function_name = "operator delete"; break;
         case '4': function_name = "operator="; break;
@@ -1466,7 +1471,7 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
         case '8': function_name = "operator=="; break;
         case '9': function_name = "operator!="; break;
         case 'A': function_name = "operator[]"; break;
-        case 'B': function_name = "operator"; do_after = 3; break;
+        case 'B': function_name = "operator"; post_process = PP_CAST_OPERATOR; break;
         case 'C': function_name = "operator->"; break;
         case 'D': function_name = "operator*"; break;
         case 'E': function_name = "operator++"; break;
@@ -1506,7 +1511,10 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
             case '9': function_name = "`vcall'"; break;
             case 'A': function_name = "`typeof'"; break;
             case 'B': function_name = "`local static guard'"; break;
-            case 'C': function_name = "`string'"; do_after = 4; break;
+            case 'C': sym->result = (char*)"`string'"; /* string literal: followed by string encoding (native nevers undecode it) */
+                /* FIXME: should unmangle the whole string for error reporting */
+                if (*sym->current && sym->current[strlen(sym->current) - 1] == '@') ret = TRUE;
+                goto done;
             case 'D': function_name = "`vbase destructor'"; break;
             case 'E': function_name = "`vector deleting destructor'"; break;
             case 'F': function_name = "`default constructor closure'"; break;
@@ -1601,18 +1609,8 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
             if (args) function_name = function_name ? str_printf(sym, "%s%s", function_name, args) : args;
             sym->names.num = 0;
         }
-        switch (do_after)
-        {
-        case 4:
-            sym->result = (char*)function_name;
-            ret = TRUE;
-            goto done;
-            /* fall through */
-        default:
-            if (!str_array_push(sym, function_name, -1, &sym->stack))
-                return FALSE;
-            break;
-        }
+        if (!str_array_push(sym, function_name, -1, &sym->stack))
+            return FALSE;
     }
     else if (*sym->current == '$')
     {
@@ -1634,20 +1632,18 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
         break;
     }
 
-    switch (do_after)
+    switch (post_process)
     {
-    case 0: default: break;
-    case 1: case 2:
+    case PP_NONE: default: break;
+    case PP_CONSTRUCTOR: case PP_DESTRUCTOR:
         /* it's time to set the member name for ctor & dtor */
         if (sym->stack.num <= 1) goto done;
-        if (do_after == 1)
-            sym->stack.elts[0] = str_printf(sym, "%s%s", sym->stack.elts[1], sym->stack.elts[0]);
-        else
-            sym->stack.elts[0] = str_printf(sym, "~%s%s", sym->stack.elts[1], sym->stack.elts[0]);
+        sym->stack.elts[0] = str_printf(sym, "%s%s%s", post_process == PP_DESTRUCTOR ? "~" : NULL,
+                                        sym->stack.elts[1], sym->stack.elts[0]);
         /* ctors and dtors don't have return type */
         sym->flags |= UNDNAME_NO_FUNCTION_RETURNS;
         break;
-    case 3:
+    case PP_CAST_OPERATOR:
         sym->flags &= ~UNDNAME_NO_FUNCTION_RETURNS;
         break;
     }
@@ -1656,7 +1652,7 @@ static BOOL symbol_demangle(struct parsed_symbol* sym)
     if (*sym->current >= '0' && *sym->current <= '9')
         ret = handle_data(sym);
     else if ((*sym->current >= 'A' && *sym->current <= 'Z') || *sym->current == '$')
-        ret = handle_method(sym, do_after == 3);
+        ret = handle_method(sym, post_process == PP_CAST_OPERATOR);
     else ret = FALSE;
 done:
     if (ret) assert(sym->result);
-- 
GitLab


From 9a98276f981903bdd179705f1eaf0808f74ca678 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Wed, 31 Aug 2022 10:39:16 +0200
Subject: [PATCH 6/6] msvcrt: Fix order of extended qualifiers and qualifiers.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/tests/cpp.c | 1 +
 dlls/msvcrt/undname.c   | 6 ++----
 2 files changed, 3 insertions(+), 4 deletions(-)

diff --git a/dlls/msvcrt/tests/cpp.c b/dlls/msvcrt/tests/cpp.c
index 7735da4ea89..b2b6a1909b7 100644
--- a/dlls/msvcrt/tests/cpp.c
+++ b/dlls/msvcrt/tests/cpp.c
@@ -1310,6 +1310,7 @@ static void test_demangle(void)
 /* 146 */ {"?ptititi3@@3PEStititi@@IES1@", "unsigned int volatile tititi::* __ptr64 volatile __ptr64 ptititi3"},
 /* 147 */ {"?ptititi4@@3PETtititi@@IET1@", "unsigned int const volatile tititi::* __ptr64 const volatile __ptr64 ptititi4"},
 /* 148 */ {"?ptititi4v@@3RETtititi@@IET1@", "unsigned int const volatile tititi::* __ptr64 const volatile __ptr64 ptititi4v"},
+/* 149 */ {"?meth@AAA@@QFCEXXZ", "public: void __thiscall AAA::meth(void)volatile __unaligned "},
     };
     int i, num_test = ARRAY_SIZE(test);
     char* name;
diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index 424d977a2a7..8eb3a12057f 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -456,10 +456,8 @@ static BOOL get_modifier(struct parsed_symbol *sym, struct datatype_t *xdt, cons
     case 'T': mod = "const volatile"; break;
     default: return FALSE;
     }
-    if (xdt->left && mod)
-        xdt->left = str_printf(sym, "%s %s", xdt->left, mod);
-    else if (mod)
-        xdt->left = mod;
+    if (mod)
+        xdt->left = xdt->left ? str_printf(sym, "%s %s", mod, xdt->left) : mod;
     if (ch >= 'Q' && ch <= 'T') /* pointer to member, fetch class */
     {
         const char* class = get_class_name(sym);
-- 
GitLab

From 854eb9990f53fab80ac37af4a44d3436ab00da97 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Mon, 21 Nov 2022 11:30:10 +0100
Subject: [PATCH 1/3] ucrtbase: Extend ucrtbase's undname tests.

Renumbering entries' comment to match actual output.
Adding ability to pass flags.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/ucrtbase/tests/cpp.c | 27 +++++++++++++++++++++------
 1 file changed, 21 insertions(+), 6 deletions(-)

diff --git a/dlls/ucrtbase/tests/cpp.c b/dlls/ucrtbase/tests/cpp.c
index a22138889cb..b9b36a1e740 100644
--- a/dlls/ucrtbase/tests/cpp.c
+++ b/dlls/ucrtbase/tests/cpp.c
@@ -192,21 +192,36 @@ static void test___std_type_info(void)
 
 static void test___unDName(void)
 {
-    static struct {const char *in; const char *out; const char *broken;} und_tests[] =
+    static struct {const char *in; const char *out; const char *broken; unsigned int flags;} und_tests[] =
     {
-/*   1 */ {"??4QDnsDomainNameRecord@@QAEAAV0@$$QAV0@@Z",
+/*   0 */ {"??4QDnsDomainNameRecord@@QAEAAV0@$$QAV0@@Z",
            "public: class QDnsDomainNameRecord & __thiscall QDnsDomainNameRecord::operator=(class QDnsDomainNameRecord &&)"},
-/*   2 */ {"??4QDnsDomainNameRecord@@QAEAAV0@$$QEAV0@@Z",
+/*   1 */ {"??4QDnsDomainNameRecord@@QAEAAV0@$$QEAV0@@Z",
           "public: class QDnsDomainNameRecord & __thiscall QDnsDomainNameRecord::operator=(class QDnsDomainNameRecord && __ptr64)"},
-/*   3 */ {"??__K_l@@YA?AUCC@@I@Z", "struct CC __cdecl operator \"\" _l(unsigned int)",
+/*   2 */ {"??__K_l@@YA?AUCC@@I@Z", "struct CC __cdecl operator \"\" _l(unsigned int)",
            "??__K_l@@YA?AUCC@@I@Z" /* W10 1507 fails on this :-( */},
+/*   3 */ {"?meth@Q@@QEGBA?AV1@XZ",
+           "public: class Q __cdecl Q::meth(void)const __ptr64& ",
+           "public: ?? :: ?? ::XZ::V1" /* W10 1507 fails on this :-( */},
+/*   4 */ {"?meth@Q@@QEHAA?AV1@XZ",
+           "public: class Q __cdecl Q::meth(void) __ptr64&& ",
+           "public: ?? :: ?? ::XZ::V1" /* W10 1507 fails on this :-( */},
+/*   5 */ {"?meth@Q@@QEGBA?AV1@XZ",
+           "public: class Q Q::meth(void)const & ",
+           "public: ?? :: ?? ::XZ::V1" /* W10 1507 fails on this :-( */,
+           0x02 /*UNDNAME_NO_MS_KEYWORDS*/},
+/*   6 */ {"?meth@Q@@QEHAA?AV1@XZ",
+           "public: class Q Q::meth(void)&& ",
+           "public: ?? :: ?? ::XZ::V1" /* W10 1507 fails on this :-( */,
+           0x02 /*UNDNAME_NO_MS_KEYWORDS*/},
     };
     unsigned i;
     for (i = 0; i < ARRAY_SIZE(und_tests); i++)
     {
-        char *name = p___unDName(0, und_tests[i].in, 0, malloc, free, 0);
+        char *name = p___unDName(0, und_tests[i].in, 0, malloc, free, und_tests[i].flags);
+        todo_wine_if(i >= 3)
         ok(!strcmp(name, und_tests[i].out) ||
-           (broken(und_tests[i].broken && !strcmp(und_tests[i].broken, name))),
+           broken(und_tests[i].broken && !strcmp(und_tests[i].broken, name)),
            "unDName returned %s for #%u\n", wine_dbgstr_a(name), i);
         free(name);
     }
-- 
GitLab


From 56b973cdb9c0323b98d11fc53e9d1663486619c8 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Mon, 21 Nov 2022 11:30:11 +0100
Subject: [PATCH 2/3] msvcrt: Rename modifier into qualifier.

That's how they are defined in C/C++ standard.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/undname.c | 106 +++++++++++++++++++++---------------------
 1 file changed, 53 insertions(+), 53 deletions(-)

diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index eb95da98435..8db8e8f01b9 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -33,8 +33,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(msvcrt);
  * - back-port this new code into tools/winedump/msmangle.c
  */
 
-/* How data types modifiers are stored:
- * M (in the following definitions) is defined for 
+/* How data types qualifiers are stored:
+ * M (in the following definitions) is defined for
  * 'A', 'B', 'C' and 'D' as follows
  *      {<A>}:  ""
  *      {<B>}:  "const "
@@ -407,7 +407,7 @@ static char* get_args(struct parsed_symbol* sym, struct array* pmt_ref, BOOL z_t
     return args_str;
 }
 
-static void append_extended_modifier(struct parsed_symbol *sym, const char **where, const char *str)
+static void append_extended_qualifier(struct parsed_symbol *sym, const char **where, const char *str)
 {
     if (!(sym->flags & UNDNAME_NO_MS_KEYWORDS))
     {
@@ -417,7 +417,7 @@ static void append_extended_modifier(struct parsed_symbol *sym, const char **whe
     }
 }
 
-static void get_extended_modifier(struct parsed_symbol *sym, struct datatype_t *xdt)
+static void get_extended_qualifier(struct parsed_symbol *sym, struct datatype_t *xdt)
 {
     xdt->left = xdt->right = NULL;
     xdt->flags = 0;
@@ -425,9 +425,9 @@ static void get_extended_modifier(struct parsed_symbol *sym, struct datatype_t *
     {
         switch (*sym->current)
         {
-        case 'E': append_extended_modifier(sym, &xdt->right, "__ptr64");     break;
-        case 'F': append_extended_modifier(sym, &xdt->left,  "__unaligned"); break;
-        case 'I': append_extended_modifier(sym, &xdt->right, "__restrict");  break;
+        case 'E': append_extended_qualifier(sym, &xdt->right, "__ptr64");     break;
+        case 'F': append_extended_qualifier(sym, &xdt->left,  "__unaligned"); break;
+        case 'I': append_extended_qualifier(sym, &xdt->right, "__restrict");  break;
         default: return;
         }
         sym->current++;
@@ -435,29 +435,29 @@ static void get_extended_modifier(struct parsed_symbol *sym, struct datatype_t *
 }
 
 /******************************************************************
- *		get_modifier
- * Parses the type modifier. Always returns static strings.
+ *		get_qualifier
+ * Parses the type qualifier. Always returns static strings.
  */
-static BOOL get_modifier(struct parsed_symbol *sym, struct datatype_t *xdt, const char** pclass)
+static BOOL get_qualifier(struct parsed_symbol *sym, struct datatype_t *xdt, const char** pclass)
 {
     char ch;
-    const char* mod;
+    const char* qualif;
 
-    get_extended_modifier(sym, xdt);
+    get_extended_qualifier(sym, xdt);
     switch (ch = *sym->current++)
     {
-    case 'A': mod = NULL; break;
-    case 'B': mod = "const"; break;
-    case 'C': mod = "volatile"; break;
-    case 'D': mod = "const volatile"; break;
-    case 'Q': mod = NULL; break;
-    case 'R': mod = "const"; break;
-    case 'S': mod = "volatile"; break;
-    case 'T': mod = "const volatile"; break;
+    case 'A': qualif = NULL; break;
+    case 'B': qualif = "const"; break;
+    case 'C': qualif = "volatile"; break;
+    case 'D': qualif = "const volatile"; break;
+    case 'Q': qualif = NULL; break;
+    case 'R': qualif = "const"; break;
+    case 'S': qualif = "volatile"; break;
+    case 'T': qualif = "const volatile"; break;
     default: return FALSE;
     }
-    if (mod)
-        xdt->left = xdt->left ? str_printf(sym, "%s %s", mod, xdt->left) : mod;
+    if (qualif)
+        xdt->left = xdt->left ? str_printf(sym, "%s %s", qualif, xdt->left) : qualif;
     if (ch >= 'Q' && ch <= 'T') /* pointer to member, fetch class */
     {
         const char* class = get_class_name(sym);
@@ -473,48 +473,48 @@ static BOOL get_modifier(struct parsed_symbol *sym, struct datatype_t *xdt, cons
     return TRUE;
 }
 
-static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
-                              struct array *pmt_ref, char modif, enum datatype_flags flags)
+static BOOL get_qualified_type(struct datatype_t *ct, struct parsed_symbol* sym,
+                              struct array *pmt_ref, char qualif, enum datatype_flags flags)
 {
     struct datatype_t xdt1;
     struct datatype_t xdt2;
     const char* ref;
-    const char* str_modif;
+    const char* str_qualif;
     const char* class;
 
-    get_extended_modifier(sym, &xdt1);
+    get_extended_qualifier(sym, &xdt1);
 
-    switch (modif)
+    switch (qualif)
     {
-    case 'A': ref = " &";  str_modif = NULL;              break;
-    case 'B': ref = " &";  str_modif = " volatile";       break;
-    case 'P': ref = " *";  str_modif = NULL;              break;
-    case 'Q': ref = " *";  str_modif = " const";          break;
-    case 'R': ref = " *";  str_modif = " volatile";       break;
-    case 'S': ref = " *";  str_modif = " const volatile"; break;
-    case '?': ref = NULL;  str_modif = NULL;              break;
-    case '$': ref = " &&"; str_modif = NULL;              break;
+    case 'A': ref = " &";  str_qualif = NULL;              break;
+    case 'B': ref = " &";  str_qualif = " volatile";       break;
+    case 'P': ref = " *";  str_qualif = NULL;              break;
+    case 'Q': ref = " *";  str_qualif = " const";          break;
+    case 'R': ref = " *";  str_qualif = " volatile";       break;
+    case 'S': ref = " *";  str_qualif = " const volatile"; break;
+    case '?': ref = NULL;  str_qualif = NULL;              break;
+    case '$': ref = " &&"; str_qualif = NULL;              break;
     default: return FALSE;
     }
     ct->right = NULL;
     ct->flags = 0;
 
-    if (get_modifier(sym, &xdt2, &class))
+    if (get_qualifier(sym, &xdt2, &class))
     {
         unsigned            mark = sym->stack.num;
         struct datatype_t   sub_ct;
 
-        if (ref || str_modif || xdt1.left || xdt1.right)
+        if (ref || str_qualif || xdt1.left || xdt1.right)
         {
             if (class)
                 ct->left = str_printf(sym, "%s%s%s%s::%s%s%s",
                                       xdt1.left ? " " : NULL, xdt1.left,
                                       class ? " " : NULL, class, ref ? ref + 1 : NULL,
-                                      xdt1.right ? " " : NULL, xdt1.right, str_modif);
+                                      xdt1.right ? " " : NULL, xdt1.right, str_qualif);
             else
                 ct->left = str_printf(sym, "%s%s%s%s%s%s",
                                       xdt1.left ? " " : NULL, xdt1.left, ref,
-                                      xdt1.right ? " " : NULL, xdt1.right, str_modif);
+                                      xdt1.right ? " " : NULL, xdt1.right, str_qualif);
         }
         else
             ct->left = NULL;
@@ -543,14 +543,14 @@ static BOOL get_modified_type(struct datatype_t *ct, struct parsed_symbol* sym,
             ct->left++;
         ct->left = str_printf(sym, "%s%s%s%s%s", sub_ct.left, xdt2.left ? " " : NULL,
                               xdt2.left, ct->left,
-                              ((xdt2.left || str_modif) && (flags & WS_AFTER_QUAL_IF)) ? " " : NULL);
+                              ((xdt2.left || str_qualif) && (flags & WS_AFTER_QUAL_IF)) ? " " : NULL);
         if (sub_ct.right) ct->right = str_printf(sym, "%s%s", ct->right, sub_ct.right);
         sym->stack.num = mark;
     }
-    else if (ref || str_modif || xdt1.left || xdt1.right)
+    else if (ref || str_qualif || xdt1.left || xdt1.right)
         ct->left = str_printf(sym, "%s%s%s%s%s%s",
                               xdt1.left ? " " : NULL, xdt1.left, ref,
-                              xdt1.right ? " " : NULL, xdt1.right, str_modif);
+                              xdt1.right ? " " : NULL, xdt1.right, str_qualif);
     else
         ct->left = NULL;
     return TRUE;
@@ -926,17 +926,17 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
         }
         else
         {
-            if (!get_modified_type(ct, sym, pmt_ref, '?', flags)) goto done;
+            if (!get_qualified_type(ct, sym, pmt_ref, '?', flags)) goto done;
         }
         break;
     case 'A': /* reference */
     case 'B': /* volatile reference */
-        if (!get_modified_type(ct, sym, pmt_ref, dt, flags)) goto done;
+        if (!get_qualified_type(ct, sym, pmt_ref, dt, flags)) goto done;
         break;
     case 'Q': /* const pointer */
     case 'R': /* volatile pointer */
     case 'S': /* const volatile pointer */
-        if (!get_modified_type(ct, sym, pmt_ref, (flags & IN_ARGS) ? dt : 'P', flags)) goto done;
+        if (!get_qualified_type(ct, sym, pmt_ref, (flags & IN_ARGS) ? dt : 'P', flags)) goto done;
         break;
     case 'P': /* Pointer */
         if (isdigit(*sym->current))
@@ -955,7 +955,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
 
                 if (!(class = get_class_name(sym)))
                     goto done;
-                if (!get_modifier(sym, &xdt, NULL))
+                if (!get_qualifier(sym, &xdt, NULL))
                     goto done;
                 if (!get_function_signature(sym, pmt_ref, &fs))
                      goto done;
@@ -984,7 +984,7 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
             }
             else goto done;
 	}
-	else if (!get_modified_type(ct, sym, pmt_ref, 'P', flags)) goto done;
+	else if (!get_qualified_type(ct, sym, pmt_ref, 'P', flags)) goto done;
         break;
     case 'W':
         if (*sym->current == '4')
@@ -1101,14 +1101,14 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
                 struct datatype_t xdt;
 
                 sym->current++;
-                if (!get_modifier(sym, &xdt, NULL)) goto done;
+                if (!get_qualifier(sym, &xdt, NULL)) goto done;
                 if (!demangle_datatype(sym, ct, pmt_ref, flags)) goto done;
                 ct->left = str_printf(sym, "%s %s", ct->left, xdt.left);
             }
             else if (*sym->current == 'Q')
             {
                 sym->current++;
-                if (!get_modified_type(ct, sym, pmt_ref, '$', flags)) goto done;
+                if (!get_qualified_type(ct, sym, pmt_ref, '$', flags)) goto done;
             }
             break;
         }
@@ -1184,7 +1184,7 @@ static BOOL handle_data(struct parsed_symbol* sym)
             str_array_init(&pmt);
 
             if (!demangle_datatype(sym, &ct, &pmt, 0)) goto done;
-            if (!get_modifier(sym, &xdt, &class)) goto done; /* class doesn't seem to be displayed */
+            if (!get_qualifier(sym, &xdt, &class)) goto done; /* class doesn't seem to be displayed */
             if (xdt.left && xdt.right) xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
             else if (!xdt.left) xdt.left = xdt.right;
             sym->stack.num = mark;
@@ -1193,7 +1193,7 @@ static BOOL handle_data(struct parsed_symbol* sym)
     case '6' : /* compiler generated static */
     case '7' : /* compiler generated static */
         ct.left = ct.right = NULL;
-        if (!get_modifier(sym, &xdt, NULL)) goto done;
+        if (!get_qualifier(sym, &xdt, NULL)) goto done;
         if (*sym->current != '@')
         {
             char*       cls = NULL;
@@ -1362,8 +1362,8 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
                 (accmem <= 'X' && (accmem - 'A') % 8 != 2 && (accmem - 'A') % 8 != 3)))
     {
         /* Implicit 'this' pointer */
-        /* If there is an implicit this pointer, const modifier follows */
-        if (!get_modifier(sym, &xdt, NULL)) goto done;
+        /* If there is an implicit this pointer, const qualifier follows */
+        if (!get_qualifier(sym, &xdt, NULL)) goto done;
         if (xdt.left || xdt.right) xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
     }
 
-- 
GitLab


From d1eb78a75deb49cea3b273742b05362f227c8d22 Mon Sep 17 00:00:00 2001
From: Eric Pouech <eric.pouech@gmail.com>
Date: Mon, 21 Nov 2022 11:30:13 +0100
Subject: [PATCH 3/3] ucrtbase: Handle undecoration of function's reference
 qualifiers (C++11).

Introducing get_function_qualifier().
Feature is not available in msvcrt.

Signed-off-by: Eric Pouech <eric.pouech@gmail.com>
---
 dlls/msvcrt/undname.c     | 59 ++++++++++++++++++++++++---------------
 dlls/ucrtbase/tests/cpp.c |  1 -
 2 files changed, 37 insertions(+), 23 deletions(-)

diff --git a/dlls/msvcrt/undname.c b/dlls/msvcrt/undname.c
index 8db8e8f01b9..5a7283caac7 100644
--- a/dlls/msvcrt/undname.c
+++ b/dlls/msvcrt/undname.c
@@ -80,6 +80,7 @@ struct parsed_symbol
 enum datatype_e
 {
     DT_NO_LEADING_WS = 0x01,
+    DT_NO_LRSEP_WS = 0x02,
 };
 
 /* Type for parsing mangled types */
@@ -407,28 +408,35 @@ static char* get_args(struct parsed_symbol* sym, struct array* pmt_ref, BOOL z_t
     return args_str;
 }
 
-static void append_extended_qualifier(struct parsed_symbol *sym, const char **where, const char *str)
+static void append_extended_qualifier(struct parsed_symbol *sym, const char **where,
+                                      const char *str, BOOL is_ms_keyword)
 {
-    if (!(sym->flags & UNDNAME_NO_MS_KEYWORDS))
+    if (!is_ms_keyword || !(sym->flags & UNDNAME_NO_MS_KEYWORDS))
     {
-        if (sym->flags & UNDNAME_NO_LEADING_UNDERSCORES)
+        if (is_ms_keyword && (sym->flags & UNDNAME_NO_LEADING_UNDERSCORES))
             str += 2;
-        *where = *where ? str_printf(sym, "%s %s", *where, str) : str;
+        *where = *where ? str_printf(sym, "%s%s%s%s", *where, is_ms_keyword ? " " : "", str, is_ms_keyword ? "" : " ") :
+            str_printf(sym, "%s%s", str, is_ms_keyword ? "" : " ");
     }
 }
 
 static void get_extended_qualifier(struct parsed_symbol *sym, struct datatype_t *xdt)
 {
+    unsigned fl = 0;
     xdt->left = xdt->right = NULL;
     xdt->flags = 0;
     for (;;)
     {
         switch (*sym->current)
         {
-        case 'E': append_extended_qualifier(sym, &xdt->right, "__ptr64");     break;
-        case 'F': append_extended_qualifier(sym, &xdt->left,  "__unaligned"); break;
-        case 'I': append_extended_qualifier(sym, &xdt->right, "__restrict");  break;
-        default: return;
+        case 'E': append_extended_qualifier(sym, &xdt->right, "__ptr64", TRUE);     fl |= 2; break;
+        case 'F': append_extended_qualifier(sym, &xdt->left,  "__unaligned", TRUE); fl |= 2; break;
+#ifdef _UCRT
+        case 'G': append_extended_qualifier(sym, &xdt->right, "&", FALSE);          fl |= 1; break;
+        case 'H': append_extended_qualifier(sym, &xdt->right, "&&", FALSE);         fl |= 1; break;
+#endif
+        case 'I': append_extended_qualifier(sym, &xdt->right, "__restrict", TRUE);  fl |= 2; break;
+        default: if (fl == 1 || (fl == 3 && (sym->flags & UNDNAME_NO_MS_KEYWORDS))) xdt->flags = DT_NO_LRSEP_WS; return;
         }
         sym->current++;
     }
@@ -457,7 +465,10 @@ static BOOL get_qualifier(struct parsed_symbol *sym, struct datatype_t *xdt, con
     default: return FALSE;
     }
     if (qualif)
+    {
+        xdt->flags &= ~DT_NO_LRSEP_WS;
         xdt->left = xdt->left ? str_printf(sym, "%s %s", qualif, xdt->left) : qualif;
+    }
     if (ch >= 'Q' && ch <= 'T') /* pointer to member, fetch class */
     {
         const char* class = get_class_name(sym);
@@ -473,6 +484,16 @@ static BOOL get_qualifier(struct parsed_symbol *sym, struct datatype_t *xdt, con
     return TRUE;
 }
 
+static BOOL get_function_qualifier(struct parsed_symbol *sym, const char** qualif)
+{
+    struct datatype_t   xdt;
+
+    if (!get_qualifier(sym, &xdt, NULL)) return FALSE;
+    *qualif = (xdt.left || xdt.right) ?
+        str_printf(sym, "%s%s%s", xdt.left, (xdt.flags & DT_NO_LRSEP_WS) ? "" : " ", xdt.right) : NULL;
+    return TRUE;
+}
+
 static BOOL get_qualified_type(struct datatype_t *ct, struct parsed_symbol* sym,
                               struct array *pmt_ref, char qualif, enum datatype_flags flags)
 {
@@ -949,24 +970,20 @@ static BOOL demangle_datatype(struct parsed_symbol* sym, struct datatype_t* ct,
             {
                 struct function_signature       fs;
                 const char*                     class;
-                struct datatype_t               xdt;
+                const char*                     function_qualifier;
 
                 sym->current++;
 
                 if (!(class = get_class_name(sym)))
                     goto done;
-                if (!get_qualifier(sym, &xdt, NULL))
+                if (!get_function_qualifier(sym, &function_qualifier))
                     goto done;
                 if (!get_function_signature(sym, pmt_ref, &fs))
                      goto done;
-                if (xdt.left)
-                    xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
-                else if (xdt.right)
-                    xdt.left = str_printf(sym, " %s", xdt.right);
 
                 ct->left  = str_printf(sym, "%s%s (%s %s::*",
                                        fs.return_ct.left, fs.return_ct.right, fs.call_conv, class);
-                ct->right = str_printf(sym, ")%s%s", fs.arguments, xdt.left);
+                ct->right = str_printf(sym, ")%s%s", fs.arguments, function_qualifier);
             }
             else if (*sym->current == '6')
             {
@@ -1233,7 +1250,7 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
     const char*         member_type = NULL;
     struct datatype_t   ct_ret;
     const char*         call_conv;
-    struct datatype_t   xdt = {NULL};
+    const char*         function_qualifier = NULL;
     const char*         exported;
     const char*         args_str = NULL;
     const char*         name = NULL;
@@ -1362,9 +1379,7 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
                 (accmem <= 'X' && (accmem - 'A') % 8 != 2 && (accmem - 'A') % 8 != 3)))
     {
         /* Implicit 'this' pointer */
-        /* If there is an implicit this pointer, const qualifier follows */
-        if (!get_qualifier(sym, &xdt, NULL)) goto done;
-        if (xdt.left || xdt.right) xdt.left = str_printf(sym, "%s %s", xdt.left, xdt.right);
+        if (!get_function_qualifier(sym, &function_qualifier)) goto done;
     }
 
     if (!get_calling_convention(*sym->current++, &call_conv, &exported,
@@ -1395,8 +1410,8 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
 
     mark = sym->stack.num;
     if (has_args && !(args_str = get_args(sym, &array_pmt, TRUE, '(', ')'))) goto done;
-    if (sym->flags & UNDNAME_NAME_ONLY) args_str = xdt.left = NULL;
-    if (sym->flags & UNDNAME_NO_THISTYPE) xdt.left = NULL;
+    if (sym->flags & UNDNAME_NAME_ONLY) args_str = function_qualifier = NULL;
+    if (sym->flags & UNDNAME_NO_THISTYPE) function_qualifier = NULL;
     sym->stack.num = mark;
 
     /* Note: '()' after 'Z' means 'throws', but we don't care here
@@ -1406,7 +1421,7 @@ static BOOL handle_method(struct parsed_symbol* sym, BOOL cast_op)
                              access, member_type, ct_ret.left,
                              (ct_ret.left && !ct_ret.right) ? " " : NULL,
                              call_conv, call_conv ? " " : NULL, exported,
-                             name, args_str, xdt.left, ct_ret.right);
+                             name, args_str, function_qualifier, ct_ret.right);
     ret = TRUE;
 done:
     return ret;
diff --git a/dlls/ucrtbase/tests/cpp.c b/dlls/ucrtbase/tests/cpp.c
index b9b36a1e740..9a66d66d814 100644
--- a/dlls/ucrtbase/tests/cpp.c
+++ b/dlls/ucrtbase/tests/cpp.c
@@ -219,7 +219,6 @@ static void test___unDName(void)
     for (i = 0; i < ARRAY_SIZE(und_tests); i++)
     {
         char *name = p___unDName(0, und_tests[i].in, 0, malloc, free, und_tests[i].flags);
-        todo_wine_if(i >= 3)
         ok(!strcmp(name, und_tests[i].out) ||
            broken(und_tests[i].broken && !strcmp(und_tests[i].broken, name)),
            "unDName returned %s for #%u\n", wine_dbgstr_a(name), i);
-- 
GitLab

From 58427faace44e9e5f87323073ebf3f65352e8461 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Fri, 17 Feb 2023 11:21:29 +0800
Subject: [PATCH 1/4] include: Add DirectComposition error codes.

---
 include/winerror.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/include/winerror.h b/include/winerror.h
index fb44eaacbed..ccb58199101 100644
--- a/include/winerror.h
+++ b/include/winerror.h
@@ -4023,6 +4023,10 @@ static inline HRESULT HRESULT_FROM_WIN32(unsigned int x)
 #define DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY               _HRESULT_TYPEDEF_(0x887a0030)
 #define DXGI_ERROR_MODE_CHANGE_IN_PROGRESS                 _HRESULT_TYPEDEF_(0x887a0025)
 
+#define DCOMPOSITION_ERROR_WINDOW_ALREADY_COMPOSED         _HRESULT_TYPEDEF_(0x88980800)
+#define DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED          _HRESULT_TYPEDEF_(0x88980801)
+#define DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED      _HRESULT_TYPEDEF_(0x88980802)
+
 #define ERROR_AUDITING_DISABLED                            _HRESULT_TYPEDEF_(0xC0090001)
 #define ERROR_ALL_SIDS_FILTERED                            _HRESULT_TYPEDEF_(0xC0090002)
 
-- 
GitLab


From 74e6345712fe97c6a21fe48f877eb012577ae6d8 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Thu, 2 Feb 2023 21:11:34 +0800
Subject: [PATCH 2/4] include: Add dcomptypes.idl.

---
 include/Makefile.in    |  1 +
 include/dcomptypes.idl | 77 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 78 insertions(+)
 create mode 100644 include/dcomptypes.idl

diff --git a/include/Makefile.in b/include/Makefile.in
index 49b5f7c4b01..07917b4923d 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -182,6 +182,7 @@ SOURCES = \
 	dciddi.h \
 	dciman.h \
 	dcommon.idl \
+	dcomptypes.idl \
 	dde.h \
 	dde.rh \
 	ddeml.h \
diff --git a/include/dcomptypes.idl b/include/dcomptypes.idl
new file mode 100644
index 00000000000..2ee6b17cde3
--- /dev/null
+++ b/include/dcomptypes.idl
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2023 Zhiyi Zhang for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+import "dxgitype.idl";
+import "dxgi1_5.idl";
+
+enum DCOMPOSITION_BITMAP_INTERPOLATION_MODE
+{
+    DCOMPOSITION_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR = 0,
+    DCOMPOSITION_BITMAP_INTERPOLATION_MODE_LINEAR           = 1,
+    DCOMPOSITION_BITMAP_INTERPOLATION_MODE_INHERIT          = 0xffffffff
+};
+
+enum DCOMPOSITION_BORDER_MODE
+{
+    DCOMPOSITION_BORDER_MODE_SOFT    = 0,
+    DCOMPOSITION_BORDER_MODE_HARD    = 1,
+    DCOMPOSITION_BORDER_MODE_INHERIT = 0xffffffff
+};
+
+enum DCOMPOSITION_COMPOSITE_MODE
+{
+    DCOMPOSITION_COMPOSITE_MODE_SOURCE_OVER        = 0,
+    DCOMPOSITION_COMPOSITE_MODE_DESTINATION_INVERT = 1,
+    DCOMPOSITION_COMPOSITE_MODE_MIN_BLEND          = 2,
+    DCOMPOSITION_COMPOSITE_MODE_INHERIT            = 0xffffffff
+};
+
+enum DCOMPOSITION_BACKFACE_VISIBILITY
+{
+    DCOMPOSITION_BACKFACE_VISIBILITY_VISIBLE = 0,
+    DCOMPOSITION_BACKFACE_VISIBILITY_HIDDEN  = 1,
+    DCOMPOSITION_BACKFACE_VISIBILITY_INHERIT = 0xffffffff
+};
+
+enum DCOMPOSITION_OPACITY_MODE
+{
+    DCOMPOSITION_OPACITY_MODE_LAYER    = 0,
+    DCOMPOSITION_OPACITY_MODE_MULTIPLY = 1,
+    DCOMPOSITION_OPACITY_MODE_INHERIT  = 0xffffffff
+};
+
+enum DCOMPOSITION_DEPTH_MODE
+{
+    DCOMPOSITION_DEPTH_MODE_TREE    = 0,
+    DCOMPOSITION_DEPTH_MODE_SPATIAL = 1,
+    DCOMPOSITION_DEPTH_MODE_SORTED  = 3,
+    DCOMPOSITION_DEPTH_MODE_INHERIT = 0xffffffff
+};
+
+typedef struct
+{
+    LARGE_INTEGER lastFrameTime;
+    DXGI_RATIONAL currentCompositionRate;
+    LARGE_INTEGER currentTime;
+    LARGE_INTEGER timeFrequency;
+    LARGE_INTEGER nextEstimatedFrameTime;
+} DCOMPOSITION_FRAME_STATISTICS;
+
+cpp_quote("#define COMPOSITIONOBJECT_READ       0x0001L")
+cpp_quote("#define COMPOSITIONOBJECT_WRITE      0x0002L")
+cpp_quote("#define COMPOSITIONOBJECT_ALL_ACCESS (COMPOSITIONOBJECT_READ | COMPOSITIONOBJECT_WRITE)")
-- 
GitLab


From c10568fc31445ba310e6067fb29e0b8fd9f1ea0e Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Mon, 20 Feb 2023 16:48:00 +0800
Subject: [PATCH 3/4] include: Add dcompanimation.idl.

---
 include/Makefile.in        |  1 +
 include/dcompanimation.idl | 36 ++++++++++++++++++++++++++++++++++++
 2 files changed, 37 insertions(+)
 create mode 100644 include/dcompanimation.idl

diff --git a/include/Makefile.in b/include/Makefile.in
index 07917b4923d..2284a902b5f 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -182,6 +182,7 @@ SOURCES = \
 	dciddi.h \
 	dciman.h \
 	dcommon.idl \
+	dcompanimation.idl \
 	dcomptypes.idl \
 	dde.h \
 	dde.rh \
diff --git a/include/dcompanimation.idl b/include/dcompanimation.idl
new file mode 100644
index 00000000000..dac6a2615ed
--- /dev/null
+++ b/include/dcompanimation.idl
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2023 Zhiyi Zhang for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+import "wtypes.idl";
+import "unknwn.idl";
+
+[
+    local,
+    object,
+    uuid(cbfd91d9-51b2-45e4-b3de-d19ccfb863c5),
+    pointer_default(unique)
+]
+interface IDCompositionAnimation : IUnknown
+{
+    HRESULT Reset();
+    HRESULT SetAbsoluteBeginTime([in] LARGE_INTEGER time);
+    HRESULT AddCubic([in] double offset, [in] float constant_coefficient, [in] float linear_coefficient, [in] float quadratic_coefficient, [in] float cubic_coefficient);
+    HRESULT AddSinusoidal([in] double offset, [in] float bias, [in] float amplitude, [in] float frequency, [in] float phase);
+    HRESULT AddRepeat([in] double offset, [in] double duration);
+    HRESULT End([in] double offset, [in] float value);
+};
-- 
GitLab


From 98336958555d653c66385e94a812d3dfdf8b41b3 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Thu, 2 Feb 2023 21:22:35 +0800
Subject: [PATCH 4/4] include: Add dcomp.idl.

Note that overloaded C++ methods are renamed to avoid conflicts.
---
 include/Makefile.in |   1 +
 include/dcomp.idl   | 442 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 443 insertions(+)
 create mode 100644 include/dcomp.idl

diff --git a/include/Makefile.in b/include/Makefile.in
index 2284a902b5f..921ea4307cd 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -182,6 +182,7 @@ SOURCES = \
 	dciddi.h \
 	dciman.h \
 	dcommon.idl \
+	dcomp.idl \
 	dcompanimation.idl \
 	dcomptypes.idl \
 	dde.h \
diff --git a/include/dcomp.idl b/include/dcomp.idl
new file mode 100644
index 00000000000..d5a9c362024
--- /dev/null
+++ b/include/dcomp.idl
@@ -0,0 +1,442 @@
+/*
+ * Copyright 2023 Zhiyi Zhang for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+import "objidl.idl";
+import "d2dbasetypes.h";
+import "dcommon.idl";
+import "dcompanimation.idl";
+import "dcomptypes.idl";
+import "unknwn.idl";
+
+typedef struct _D3DMATRIX
+{
+    float m[4][4];
+} D3DMATRIX;
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(bb8a4953-2c99-4f5a-96f5-4819027fa3ac)
+]
+interface IDCompositionSurface : IUnknown
+{
+    HRESULT BeginDraw([in, optional] const RECT *rect, [in] REFIID iid, [out] void **object, [out] POINT *offset);
+    HRESULT EndDraw();
+    HRESULT SuspendDraw();
+    HRESULT ResumeDraw();
+    HRESULT Scroll([in, optional] const RECT *scroll, [in, optional] const RECT *clip, [in] int offset_x, [in] int offset_y);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(ae471c51-5f53-4a24-8d3e-d0c39c30b3f0)
+]
+interface IDCompositionVirtualSurface : IDCompositionSurface
+{
+    HRESULT Resize([in] UINT width, [in] UINT height);
+    HRESULT Trim([in, optional, size_is(count)] const RECT *rectangles, [in] UINT count);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(e334bc12-3937-4e02-85eb-fcf4eb30d2c8)
+]
+interface IDCompositionSurfaceFactory : IUnknown
+{
+    HRESULT CreateSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionSurface **surface);
+    HRESULT CreateVirtualSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionVirtualSurface **surface);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(64ac3703-9d3f-45ec-a109-7cac0e7a13a7)
+]
+interface IDCompositionClip : IUnknown
+{
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(9842ad7d-d9cf-4908-aed7-48b51da5e7c2)
+]
+interface IDCompositionRectangleClip : IDCompositionClip
+{
+    HRESULT SetLeft([in] float left);
+    HRESULT SetLeftAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTop([in] float top);
+    HRESULT SetTopAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetRight([in] float right);
+    HRESULT SetRightAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetBottom([in] float bottom);
+    HRESULT SetBottomAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTopLeftRadiusX([in] float radius);
+    HRESULT SetTopLeftRadiusXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTopLeftRadiusY([in] float radius);
+    HRESULT SetTopLeftRadiusYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTopRightRadiusX([in] float radius);
+    HRESULT SetTopRightRadiusXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTopRightRadiusY([in] float radius);
+    HRESULT SetTopRightRadiusYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetBottomLeftRadiusX([in] float radius);
+    HRESULT SetBottomLeftRadiusXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetBottomLeftRadiusY([in] float radius);
+    HRESULT SetBottomLeftRadiusYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetBottomRightRadiusX([in] float radius);
+    HRESULT SetBottomRightRadiusXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetBottomRightRadiusY([in] float radius);
+    HRESULT SetBottomRightRadiusYAnimation([in] IDCompositionAnimation *animation);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(ec81b08f-bfcb-4e8d-b193-a915587999e8)
+]
+interface IDCompositionEffect : IUnknown
+{
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(71185722-246b-41f2-aad1-0443f7f4bfc2)
+]
+interface IDCompositionTransform3D : IDCompositionEffect
+{
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(a7929a74-e6b2-4bd6-8b95-4040119ca34d)
+]
+interface IDCompositionEffectGroup : IDCompositionEffect
+{
+    HRESULT SetOpacity([in] float opacity);
+    HRESULT SetOpacityAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetTransform3D([in, optional] IDCompositionTransform3D *transform);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(91636d4b-9ba1-4532-aaf7-e3344994d788)
+]
+interface IDCompositionTranslateTransform3D : IDCompositionTransform3D
+{
+    HRESULT SetOffsetX([in] float offset);
+    HRESULT SetOffsetXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetOffsetY([in] float offset);
+    HRESULT SetOffsetYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetOffsetZ([in] float offset);
+    HRESULT SetOffsetZAnimation([in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(2a9e9ead-364b-4b15-a7c4-a1997f78b389)
+]
+interface IDCompositionScaleTransform3D : IDCompositionTransform3D
+{
+    HRESULT SetScaleX([in] float scale);
+    HRESULT SetScaleXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetScaleY([in] float scale);
+    HRESULT SetScaleYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetScaleZ([in] float scale);
+    HRESULT SetScaleZAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterX([in] float center);
+    HRESULT SetCenterXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterY([in] float center);
+    HRESULT SetCenterYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterZ([in] float center);
+    HRESULT SetCenterZAnimation([in] IDCompositionAnimation *animation);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(d8f5b23f-d429-4a91-b55a-d2f45fd75b18)
+]
+interface IDCompositionRotateTransform3D : IDCompositionTransform3D
+{
+    HRESULT SetScaleX([in] float scale);
+    HRESULT SetScaleXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetScaleY([in] float scale);
+    HRESULT SetScaleYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetScaleZ([in] float scale);
+    HRESULT SetScaleZAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterX([in] float center);
+    HRESULT SetCenterXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterY([in] float center);
+    HRESULT SetCenterYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterZ([in] float center);
+    HRESULT SetCenterZAnimation([in] IDCompositionAnimation *animation);
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(4b3363f0-643b-41b7-b6e0-ccf22d34467c)
+]
+interface IDCompositionMatrixTransform3D : IDCompositionTransform3D
+{
+    /* C++ method: HRESULT SetMatrix(const D3DMATRIX &matrix); Use pointer instead of reference */
+    HRESULT SetMatrix([in] const D3DMATRIX *matrix);
+    HRESULT SetMatrixElement([in] int row, [in] int column, [in] float value);
+    HRESULT SetMatrixElementAnimation([in] int row, [in] int column, [in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(fd55faa7-37e0-4c20-95d2-9be45bc33f55)
+]
+interface IDCompositionTransform : IDCompositionTransform3D
+{
+}
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(71fde914-40ef-45ef-bd51-68b037c339f9)
+]
+interface IDCompositionScaleTransform : IDCompositionTransform
+{
+    HRESULT SetScaleX([in] float scale);
+    HRESULT SetScaleXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetScaleY([in] float scale);
+    HRESULT SetScaleYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterX([in] float center);
+    HRESULT SetCenterXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterY([in] float center);
+    HRESULT SetCenterYAnimation([in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(641ed83c-ae96-46c5-90dc-32774cc5c6d5)
+]
+interface IDCompositionRotateTransform : IDCompositionTransform
+{
+    HRESULT SetAngle([in] float angle);
+    HRESULT SetAngleAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterX([in] float center_x);
+    HRESULT SetCenterXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterY([in] float center_y);
+    HRESULT SetCenterYAnimation([in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(e57aa735-dcdb-4c72-9c61-0591f58889ee)
+]
+interface IDCompositionSkewTransform : IDCompositionTransform
+{
+    HRESULT SetAngleX([in] float angle);
+    HRESULT SetAngleXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetAngleY([in] float angle);
+    HRESULT SetAngleYAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterX([in] float center);
+    HRESULT SetCenterXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetCenterY([in] float center);
+    HRESULT SetCenterYAnimation([in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(16cdff07-c503-419c-83f2-0965c7af1fa6)
+]
+interface IDCompositionMatrixTransform : IDCompositionTransform
+{
+    /* C++ method: HRESULT SetMatrix(const D2D_MATRIX_3X2_F &matrix); Use pointer instead of reference */
+    HRESULT SetMatrix([in] const D2D_MATRIX_3X2_F *matrix);
+    HRESULT SetMatrixElement([in] int row, [in] int column, [in] float value);
+    HRESULT SetMatrixElementAnimation([in] int row, [in] int column, [in] IDCompositionAnimation *animation);
+};
+
+[
+    local,
+    object,
+    pointer_default(unique),
+    uuid(06791122-c6f0-417d-8323-269e987f5954)
+]
+interface IDCompositionTranslateTransform : IDCompositionTransform
+{
+    HRESULT SetOffsetX([in] float offset);
+    HRESULT SetOffsetXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetOffsetY([in] float offset);
+    HRESULT SetOffsetYAnimation([in] IDCompositionAnimation *animation);
+};
+
+[
+    object,
+    uuid(4d93059d-097b-4651-9a60-f0f25116e2f3),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionVisual : IUnknown
+{
+    HRESULT SetOffsetX([in] float offset_x);
+    HRESULT SetOffsetXAnimation([in] IDCompositionAnimation *animation);
+    HRESULT SetOffsetY([in] float offset_y);
+    HRESULT SetOffsetYAnimation([in] IDCompositionAnimation *animation);
+    /* C++ method: HRESULT SetTransform(const D2D_MATRIX_3X2_F &matrix); Use pointer instead of reference */
+    HRESULT SetTransform([in] const D2D_MATRIX_3X2_F *matrix);
+    HRESULT SetTransformObject([in] IDCompositionTransform *transform);
+    HRESULT SetTransformParent([in] IDCompositionVisual *visual);
+    HRESULT SetEffect([in] IDCompositionEffect *effect);
+    HRESULT SetBitmapInterpolationMode([in] enum DCOMPOSITION_BITMAP_INTERPOLATION_MODE interpolation_mode);
+    HRESULT SetBorderMode([in] enum DCOMPOSITION_BORDER_MODE border_mode);
+    /* C++ method: HRESULT SetClip(const D2D_RECT_F &rect); Use pointer instead of reference */
+    HRESULT SetClip([in] const D2D_RECT_F *rect);
+    HRESULT SetClipObject([in] IDCompositionClip *clip);
+    HRESULT SetContent([in] IUnknown *content);
+    HRESULT AddVisual([in] IDCompositionVisual *visual, [in] BOOL insert_above, [in] IDCompositionVisual *reference_visual);
+    HRESULT RemoveVisual([in] IDCompositionVisual *visual);
+    HRESULT RemoveAllVisuals();
+    HRESULT SetCompositeMode([in] enum DCOMPOSITION_COMPOSITE_MODE composite_mode);
+}
+
+[
+    object,
+    uuid(e8de1639-4331-4b26-bc5f-6a321d347a85),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionVisual2 : IDCompositionVisual
+{
+    HRESULT SetOpacityMode([in] enum DCOMPOSITION_OPACITY_MODE opacity_mode);
+    HRESULT SetBackFaceVisibility([in] enum DCOMPOSITION_BACKFACE_VISIBILITY visibility);
+}
+
+[
+    object,
+    uuid(eacdd04c-117e-4e17-88f4-d1b12b0e3d89),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionTarget : IUnknown
+{
+    HRESULT SetRoot([in] IDCompositionVisual *visual);
+}
+
+[
+    object,
+    uuid(c37ea93a-e7aa-450d-b16f-9746cb0407f3),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionDevice : IUnknown
+{
+    HRESULT Commit();
+    HRESULT WaitForCommitCompletion();
+    HRESULT GetFrameStatistics([out] DCOMPOSITION_FRAME_STATISTICS *statistics);
+    HRESULT CreateTargetForHwnd([in] HWND hwnd, [in] BOOL topmost, [out] IDCompositionTarget **target);
+    HRESULT CreateVisual([out] IDCompositionVisual **visual);
+    HRESULT CreateSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionSurface **surface);
+    HRESULT CreateVirtualSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionVirtualSurface **surface);
+    HRESULT CreateSurfaceFromHandle([in] HANDLE handle, [out] IUnknown **surface);
+    HRESULT CreateSurfaceFromHwnd([in] HWND hwnd, [out] IUnknown **surface);
+    HRESULT CreateTranslateTransform([out] IDCompositionTranslateTransform **transform);
+    HRESULT CreateScaleTransform([out] IDCompositionScaleTransform **transform);
+    HRESULT CreateRotateTransform([out] IDCompositionRotateTransform **transform);
+    HRESULT CreateSkewTransform([out] IDCompositionSkewTransform **transform);
+    HRESULT CreateMatrixTransform([out] IDCompositionMatrixTransform **transform);
+    HRESULT CreateTransformGroup([in, size_is(elements)] IDCompositionTransform **transforms, [in] UINT elements, [out] IDCompositionTransform **transform_group);
+    HRESULT CreateTranslateTransform3D([out] IDCompositionTranslateTransform3D **transform_3d);
+    HRESULT CreateScaleTransform3D([out] IDCompositionScaleTransform3D **transform_3d);
+    HRESULT CreateRotateTransform3D([out] IDCompositionRotateTransform3D **transform_3d);
+    HRESULT CreateMatrixTransform3D([out] IDCompositionMatrixTransform3D **transform_3d);
+    HRESULT CreateTransform3DGroup([in, size_is(elements)] IDCompositionTransform3D **transforms_3d, [in] UINT elements, [out] IDCompositionTransform3D **transform_3d_group);
+    HRESULT CreateEffectGroup([out] IDCompositionEffectGroup **effect_group);
+    HRESULT CreateRectangleClip([out] IDCompositionRectangleClip **clip);
+    HRESULT CreateAnimation([out] IDCompositionAnimation **animation);
+    HRESULT CheckDeviceState([out] BOOL *valid);
+}
+
+[
+    object,
+    uuid(75f6468d-1b8e-447c-9bc6-75fea80b5b25),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionDevice2 : IUnknown
+{
+    HRESULT Commit();
+    HRESULT WaitForCommitCompletion();
+    HRESULT GetFrameStatistics([out] DCOMPOSITION_FRAME_STATISTICS *statistics);
+    HRESULT CreateVisual([out] IDCompositionVisual2 **visual);
+    HRESULT CreateSurfaceFactory([in] IUnknown *rendering_device, [out] IDCompositionSurfaceFactory **surface_factory);
+    HRESULT CreateSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionSurface **surface);
+    HRESULT CreateVirtualSurface([in] UINT width, [in] UINT height, [in] DXGI_FORMAT pixel_format, [in] DXGI_ALPHA_MODE alpha_mode, [out] IDCompositionVirtualSurface **surface);
+    HRESULT CreateTranslateTransform([out] IDCompositionTranslateTransform **transform);
+    HRESULT CreateScaleTransform([out] IDCompositionScaleTransform **transform);
+    HRESULT CreateRotateTransform([out] IDCompositionRotateTransform **transform);
+    HRESULT CreateSkewTransform([out] IDCompositionSkewTransform **transform);
+    HRESULT CreateMatrixTransform([out] IDCompositionMatrixTransform **transform);
+    HRESULT CreateTransformGroup([in, size_is(elements)] IDCompositionTransform **transforms, [in] UINT elements, [out] IDCompositionTransform **transform_group);
+    HRESULT CreateTranslateTransform3D([out] IDCompositionTranslateTransform3D **transform_3d);
+    HRESULT CreateScaleTransform3D([out] IDCompositionScaleTransform3D **transform_3d);
+    HRESULT CreateRotateTransform3D([out] IDCompositionRotateTransform3D **transform_3d);
+    HRESULT CreateMatrixTransform3D([out] IDCompositionMatrixTransform3D **transform_3d);
+    HRESULT CreateTransform3DGroup([in, size_is(elements)] IDCompositionTransform3D **transforms_3d, [in] UINT elements, [out] IDCompositionTransform3D **transform_3d_group);
+    HRESULT CreateEffectGroup([out] IDCompositionEffectGroup **effect_group);
+    HRESULT CreateRectangleClip([out] IDCompositionRectangleClip **clip);
+    HRESULT CreateAnimation([out] IDCompositionAnimation **animation);
+}
+
+[
+    object,
+    uuid(5f4633fe-1e08-4cb8-8c75-ce24333f5602),
+    local,
+    pointer_default(unique)
+]
+interface IDCompositionDesktopDevice : IDCompositionDevice2
+{
+    HRESULT CreateTargetForHwnd([in] HWND hwnd, [in] BOOL topmost, [out] IDCompositionTarget **target);
+    HRESULT CreateSurfaceFromHandle([in] HANDLE handle, [out] IUnknown **surface);
+    HRESULT CreateSurfaceFromHwnd([in] HWND hwnd, [out] IUnknown **surface);
+}
+
+cpp_quote("STDAPI DCompositionCreateDevice(IDXGIDevice *dxgi_device, REFIID iid, void **device);")
+cpp_quote("STDAPI DCompositionCreateDevice2(IUnknown *rendering_device, REFIID iid, void **device);")
-- 
GitLab

--- a/include/wine/mscvpdb.h	2023-03-02 08:14:59.471203878 -0500
+++ b/include/wine/mscvpdb.h	2023-03-02 08:23:53.270799249 -0500
@@ -112,6 +112,25 @@ typedef unsigned short  cv_typ16_t;
 typedef unsigned int    cv_typ_t;
 typedef cv_typ_t        cv_itemid_t;
 
+typedef struct cv_property_t
+{
+    unsigned short  is_packed               : 1;
+    unsigned short  has_ctor                : 1;
+    unsigned short  has_overloaded_operator : 1;
+    unsigned short  is_nested               : 1;
+    unsigned short  has_nested              : 1;
+    unsigned short  has_overloaded_assign   : 1;
+    unsigned short  has_operator_cast       : 1;
+    unsigned short  is_forward_defn         : 1;
+    unsigned short  is_scoped               : 1;
+    unsigned short  has_decorated_name      : 1; /* follows name field */
+    unsigned short  is_sealed               : 1; /* not usage as base class */
+    unsigned short  hfa                     : 2;
+    unsigned short  is_intrinsic            : 1;
+    unsigned short  mocom                   : 2;
+}
+cv_property_t;
+
 /* ======================================== *
  *             Type information
  * ======================================== */
@@ -201,7 +220,7 @@ union codeview_type
         unsigned short int      id;
         short int               n_element;
         cv_typ16_t              fieldlist;
-        short int               property;
+        cv_property_t           property;
         cv_typ16_t              derived;
         cv_typ16_t              vshape;
         unsigned short int      structlen;  /* numeric leaf */
@@ -215,7 +234,7 @@ union codeview_type
         unsigned short int      len;
         unsigned short int      id;
         short int               n_element;
-        short int               property;
+        cv_property_t           property;
         cv_typ_t                fieldlist;
         cv_typ_t                derived;
         cv_typ_t                vshape;
@@ -230,7 +249,7 @@ union codeview_type
         unsigned short int      len;
         unsigned short int      id;
         short int               n_element;
-        short int               property;
+        cv_property_t           property;
         cv_typ_t                fieldlist;
         cv_typ_t                derived;
         cv_typ_t                vshape;
@@ -246,7 +265,7 @@ union codeview_type
         unsigned short int      id;
         short int               count;
         cv_typ16_t              fieldlist;
-        short int               property;
+        cv_property_t           property;
         unsigned short int      un_len;     /* numeric leaf */
 #if 0
         struct p_string         p_name;
@@ -258,7 +277,7 @@ union codeview_type
         unsigned short int      len;
         unsigned short int      id;
         short int               count;
-        short int               property;
+        cv_property_t           property;
         cv_typ_t                fieldlist;
         unsigned short int      un_len;     /* numeric leaf */
 #if 0
@@ -271,7 +290,7 @@ union codeview_type
         unsigned short int      len;
         unsigned short int      id;
         short int               count;
-        short int               property;
+        cv_property_t           property;
         cv_typ_t                fieldlist;
         unsigned short int      un_len;     /* numeric leaf */
 #if 0
@@ -286,7 +305,7 @@ union codeview_type
         short int               count;
         cv_typ16_t              type;
         cv_typ16_t              fieldlist;
-        short int               property;
+        cv_property_t           property;
         struct p_string         p_name;
     } enumeration_v1;
 
@@ -295,7 +314,7 @@ union codeview_type
         unsigned short int      len;
         unsigned short int      id;
         short int               count;
-        short int               property;
+        cv_property_t           property;
         cv_typ_t                type;
         cv_typ_t                fieldlist;
         struct p_string         p_name;
@@ -306,7 +325,7 @@ union codeview_type
         unsigned short int      len;
         unsigned short int      id;
         short int               count;
-        short int               property;
+        cv_property_t           property;
         cv_typ_t                type;
         cv_typ_t                fieldlist;
         char                    name[1];
@@ -1172,7 +1191,8 @@ union codeview_fieldtype
 #define T_64PCHAR8          0x067c  /* 64 near pointer to 8-bit unicode char */
 
 /* counts, bit masks, and shift values needed to access various parts of the built-in type numbers */
-#define T_MAXPREDEFINEDTYPE 0x0580  /* maximum type index for all built-in types */
+#define T_FIRSTDEFINABLETYPE 0x1000 /* first type index that's not predefined */
+#define T_MAXPREDEFINEDTYPE 0x0680  /* maximum type index for all built-in types */
 #define T_MAXBASICTYPE      0x0080  /* maximum type index all non-pointer built-in types */
 #define T_BASICTYPE_MASK    0x00ff  /* mask of bits that can potentially identify a non-pointer basic type */
 #define T_BASICTYPE_SHIFT   8       /* shift count to push out the basic type bits from a type number */
@@ -2403,7 +2423,7 @@ typedef struct _PDB_TYPES_OLD
     WORD        first_index;
     WORD        last_index;
     DWORD       type_size;
-    WORD        file;
+    WORD        hash_file;;
     WORD        pad;
 } PDB_TYPES_OLD, *PPDB_TYPES_OLD;
 
@@ -2414,16 +2434,16 @@ typedef struct _PDB_TYPES
     DWORD       first_index;
     DWORD       last_index;
     DWORD       type_size;
-    WORD        file;
+    WORD        hash_file;;
     WORD        pad;
     DWORD       hash_size;
-    DWORD       hash_base;
+    DWORD       hash_num_buckets;
     DWORD       hash_offset;
     DWORD       hash_len;
     DWORD       search_offset;
     DWORD       search_len;
-    DWORD       unknown_offset;
-    DWORD       unknown_len;
+    DWORD       type_remap_offset;
+    DWORD       type_remap_len;
 } PDB_TYPES, *PPDB_TYPES;
 
 typedef struct _PDB_SYMBOL_RANGE

