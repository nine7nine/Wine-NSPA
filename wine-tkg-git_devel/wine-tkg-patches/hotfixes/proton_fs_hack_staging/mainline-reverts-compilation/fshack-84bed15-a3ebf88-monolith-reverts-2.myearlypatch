From c18275444a76f4ff5a6e998ccb821f48797f522f Mon Sep 17 00:00:00 2001
From: Tk-Glitch <ti3nou@gmail.com>
Date: Wed, 8 Jun 2022 16:04:47 +0200
Subject: [PATCH 1/1] 01-reverts

---
 dlls/comctl32/listbox.c           |    2 +-
 dlls/dxgi/adapter.c               |   62 +-
 dlls/dxgi/tests/dxgi.c            |    4 +
 dlls/gdi.exe16/gdi.c              |  141 +-
 dlls/gdi32/dc.c                   |    2 +-
 dlls/gdi32/gdi32.spec             |    1 -
 dlls/gdi32/objects.c              |    2 +-
 dlls/gdi32/tests/bitmap.c         |    1 +
 dlls/gdi32/tests/driver.c         |  106 -
 dlls/gdi32/uniscribe/usp10.c      |   18 +-
 dlls/hidclass.sys/Makefile.in     |    2 +-
 dlls/ntdll/unix/thread.c          |    6 -
 dlls/opengl32/make_opengl         |    3 +-
 dlls/user.exe16/message.c         |   31 +-
 dlls/user.exe16/user.c            |    6 +-
 dlls/user.exe16/user_private.h    |    2 +
 dlls/user.exe16/window.c          |    2 +-
 dlls/user32/Makefile.in           |    3 +
 dlls/user32/caret.c               |  406 ++++
 dlls/user32/class.c               |   36 +-
 dlls/user32/clipboard.c           |  385 ++-
 dlls/user32/controls.h            |    6 +-
 dlls/user32/cursoricon.c          |    4 +-
 dlls/user32/defdlg.c              |    2 +-
 dlls/user32/defwnd.c              |  284 ++-
 dlls/user32/desktop.c             |   27 +-
 dlls/user32/dialog.c              |    4 +-
 dlls/user32/driver.c              |  234 ++
 dlls/user32/edit.c                |   47 +-
 dlls/user32/focus.c               |    4 +-
 dlls/user32/hook.c                |   32 +-
 dlls/user32/input.c               |  412 +++-
 dlls/user32/listbox.c             |    2 +-
 dlls/user32/mdi.c                 |   28 +-
 dlls/user32/menu.c                | 1175 ++++++++-
 dlls/user32/message.c             | 3722 ++++++++++++++++++++++++++---
 dlls/user32/nonclient.c           |   38 +-
 dlls/user32/painting.c            |  179 +-
 dlls/user32/scroll.c              |   38 +-
 dlls/{win32u => user32}/spy.c     |  109 +-
 dlls/user32/sysparams.c           |   38 +-
 dlls/user32/tests/clipboard.c     |    6 +-
 dlls/user32/tests/monitor.c       |    1 +
 dlls/user32/tests/msg.c           |    3 +-
 dlls/user32/user32.spec           |   76 +-
 dlls/user32/user_main.c           |   86 +-
 dlls/user32/user_private.h        |   42 +-
 dlls/user32/win.c                 |  901 ++++++-
 dlls/user32/win.h                 |   12 +
 dlls/user32/winpos.c              | 1103 ++++++++-
 dlls/user32/winproc.c             |  605 +----
 dlls/win32u/Makefile.in           |    2 -
 dlls/win32u/bitblt.c              |   28 +-
 dlls/win32u/bitmap.c              |    2 +-
 dlls/win32u/class.c               |  100 +-
 dlls/win32u/clipboard.c           |  437 +---
 dlls/win32u/clipping.c            |   14 +-
 dlls/win32u/cursoricon.c          |   15 -
 dlls/win32u/dc.c                  |   42 +-
 dlls/win32u/dce.c                 |  399 +---
 dlls/win32u/defwnd.c              |  427 ----
 dlls/win32u/dib.c                 |   14 +-
 dlls/win32u/dibdrv/bitblt.c       |   10 +-
 dlls/win32u/dibdrv/dc.c           |   18 +-
 dlls/win32u/dibdrv/objects.c      |   18 +-
 dlls/win32u/dibdrv/primitives.c   |   14 +-
 dlls/win32u/driver.c              |  411 ++--
 dlls/win32u/emfdrv.c              |    3 -
 dlls/win32u/font.c                |  227 +-
 dlls/win32u/freetype.c            |   32 +-
 dlls/win32u/gdiobj.c              |   87 +-
 dlls/win32u/hook.c                |   25 +-
 dlls/win32u/input.c               |  719 +-----
 dlls/win32u/menu.c                | 1212 +---------
 dlls/win32u/message.c             | 2893 +---------------------
 dlls/win32u/ntgdi_private.h       |   39 +-
 dlls/win32u/ntuser_private.h      |  153 +-
 dlls/win32u/painting.c            |    4 +-
 dlls/win32u/palette.c             |   15 +-
 dlls/win32u/path.c                |    3 -
 dlls/win32u/pen.c                 |    2 +-
 dlls/win32u/syscall.c             |   16 +-
 dlls/win32u/sysparams.c           |  215 +-
 dlls/win32u/tests/win32u.c        |  246 --
 dlls/win32u/win32u.spec           |  106 +-
 dlls/win32u/win32u_private.h      |  221 +-
 dlls/win32u/window.c              | 1329 +---------
 dlls/win32u/winstation.c          |   18 +-
 dlls/win32u/wrappers.c            |  243 +-
 dlls/wined3d/directx.c            |  222 +-
 dlls/wined3d/wined3d.spec         |    3 -
 dlls/wined3d/wined3d_private.h    |    2 +-
 dlls/winemac.drv/Makefile.in      |    6 +-
 dlls/winemac.drv/clipboard.c      |  554 +++--
 dlls/winemac.drv/cocoa_app.m      |    4 +-
 dlls/winemac.drv/cocoa_event.m    |    6 +-
 dlls/winemac.drv/display.c        |   51 +-
 dlls/winemac.drv/dllmain.c        |  440 ----
 dlls/winemac.drv/dragdrop.c       |  206 +-
 dlls/winemac.drv/event.c          |  199 +-
 dlls/winemac.drv/gdi.c            |    7 +-
 dlls/winemac.drv/image.c          |  212 +-
 dlls/winemac.drv/ime.c            |  125 +-
 dlls/winemac.drv/keyboard.c       |  140 +-
 dlls/winemac.drv/macdrv.h         |  203 +-
 dlls/winemac.drv/macdrv_cocoa.h   |    2 +-
 dlls/winemac.drv/macdrv_dll.h     |   39 -
 dlls/winemac.drv/macdrv_main.c    |  168 +-
 dlls/winemac.drv/mouse.c          |   96 +-
 dlls/winemac.drv/opengl.c         |   10 +-
 dlls/winemac.drv/surface.c        |   22 +-
 dlls/winemac.drv/systray.c        |   27 +-
 dlls/winemac.drv/unixlib.h        |  199 --
 dlls/winemac.drv/vulkan.c         |    8 +-
 dlls/winemac.drv/window.c         |  625 +++--
 dlls/wineps.drv/init.c            |    3 -
 dlls/winex11.drv/Makefile.in      |    8 +-
 dlls/winex11.drv/bitblt.c         |  105 +-
 dlls/winex11.drv/brush.c          |   13 +-
 dlls/winex11.drv/clipboard.c      | 1052 ++++----
 dlls/winex11.drv/desktop.c        |   77 +-
 dlls/winex11.drv/display.c        |  105 +-
 dlls/winex11.drv/dllmain.c        |  143 --
 dlls/winex11.drv/event.c          |  567 ++---
 dlls/winex11.drv/graphics.c       |  279 +--
 dlls/winex11.drv/ime.c            |   78 +-
 dlls/winex11.drv/init.c           |   56 +-
 dlls/winex11.drv/keyboard.c       |  123 +-
 dlls/winex11.drv/mouse.c          |  271 +--
 dlls/winex11.drv/opengl.c         |  184 +-
 dlls/winex11.drv/palette.c        |  115 +-
 dlls/winex11.drv/pen.c            |   18 +-
 dlls/winex11.drv/settings.c       |  248 +-
 dlls/winex11.drv/systray.c        |  204 +-
 dlls/winex11.drv/unixlib.h        |  138 --
 dlls/winex11.drv/vulkan.c         |   62 +-
 dlls/winex11.drv/window.c         |  791 +++---
 dlls/winex11.drv/winex11.drv.spec |    2 +-
 dlls/winex11.drv/wintab.c         |   92 +-
 dlls/winex11.drv/x11drv.h         |  267 +--
 dlls/winex11.drv/x11drv_dll.h     |   51 -
 dlls/winex11.drv/x11drv_main.c    |  608 +----
 dlls/winex11.drv/xdnd.c           |  350 ++-
 dlls/winex11.drv/xim.c            |  118 +-
 dlls/winex11.drv/xinerama.c       |   21 +-
 dlls/winex11.drv/xrandr.c         |  112 +-
 dlls/winex11.drv/xrender.c        |  204 +-
 dlls/winex11.drv/xvidmode.c       |   19 +-
 dlls/wow64/process.c              |    1 -
 dlls/wow64win/gdi.c               |   34 +
 dlls/wow64win/syscall.h           |   16 +-
 dlls/wow64win/user.c              |  226 +-
 include/ddk/d3dkmthk.h            |   20 -
 include/ntgdi.h                   |    4 -
 include/ntuser.h                  |  903 +------
 include/processthreadsapi.h       |    7 -
 include/wine/gdi_driver.h         |  121 +-
 include/wine/unixlib.h            |  101 -
 include/wine/wgl_driver.h         |    1 +
 include/wine/wined3d.h            |   20 -
 include/winuser.h                 |    4 +-
 programs/explorer/Makefile.in     |    2 +-
 programs/explorer/desktop.c       |   90 -
 tools/winewrapper                 |    4 +-
 170 files changed, 14341 insertions(+), 17609 deletions(-)
 create mode 100644 dlls/user32/caret.c
 create mode 100644 dlls/user32/driver.c
 rename dlls/{win32u => user32}/spy.c (96%)
 delete mode 100644 dlls/win32u/defwnd.c
 delete mode 100644 dlls/winemac.drv/dllmain.c
 delete mode 100644 dlls/winemac.drv/macdrv_dll.h
 delete mode 100644 dlls/winemac.drv/unixlib.h
 delete mode 100644 dlls/winex11.drv/dllmain.c
 delete mode 100644 dlls/winex11.drv/unixlib.h
 delete mode 100644 dlls/winex11.drv/x11drv_dll.h

diff --git a/dlls/comctl32/listbox.c b/dlls/comctl32/listbox.c
index 6724dee1487..08bc4db4362 100644
--- a/dlls/comctl32/listbox.c
+++ b/dlls/comctl32/listbox.c
@@ -2404,7 +2404,7 @@ static void LISTBOX_HandleMouseMove( LB_DESCR *descr,
     /* Start/stop the system timer */
 
     if (dir != LB_TIMER_NONE)
-        SetSystemTimer( descr->self, LB_TIMER_ID, LB_SCROLL_TIMEOUT, 0 );
+        SetSystemTimer( descr->self, LB_TIMER_ID, LB_SCROLL_TIMEOUT, NULL);
     else if (LISTBOX_Timer != LB_TIMER_NONE)
         KillSystemTimer( descr->self, LB_TIMER_ID );
     LISTBOX_Timer = dir;
diff --git a/dlls/dxgi/adapter.c b/dlls/dxgi/adapter.c
index b178376341b..8962c082c17 100644
--- a/dlls/dxgi/adapter.c
+++ b/dlls/dxgi/adapter.c
@@ -21,15 +21,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dxgi);
 
-static void dxgi_video_memory_info_from_wined3d(DXGI_QUERY_VIDEO_MEMORY_INFO *info,
-        const struct wined3d_video_memory_info *wined3d_info)
-{
-    info->Budget = wined3d_info->budget;
-    info->CurrentUsage = wined3d_info->current_usage;
-    info->CurrentReservation = wined3d_info->current_reservation;
-    info->AvailableForReservation = wined3d_info->available_reservation;
-}
-
 static inline struct dxgi_adapter *impl_from_IWineDXGIAdapter(IWineDXGIAdapter *iface)
 {
     return CONTAINING_RECORD(iface, struct dxgi_adapter, IWineDXGIAdapter_iface);
@@ -301,23 +292,45 @@ static HRESULT STDMETHODCALLTYPE dxgi_adapter_QueryVideoMemoryInfo(IWineDXGIAdap
         UINT node_index, DXGI_MEMORY_SEGMENT_GROUP segment_group, DXGI_QUERY_VIDEO_MEMORY_INFO *info)
 {
     struct dxgi_adapter *adapter = impl_from_IWineDXGIAdapter(iface);
-    struct wined3d_video_memory_info wined3d_info;
+    struct wined3d_adapter_identifier adapter_id;
+    static unsigned int once;
     HRESULT hr;
 
     TRACE("iface %p, node_index %u, segment_group %#x, info %p.\n",
             iface, node_index, segment_group, info);
 
-    if (SUCCEEDED(hr = wined3d_adapter_get_video_memory_info(adapter->wined3d_adapter, node_index,
-            (enum wined3d_memory_segment_group)segment_group, &wined3d_info)))
-    {
-        dxgi_video_memory_info_from_wined3d(info, &wined3d_info);
+    if (!once++)
+        FIXME("Returning fake video memory info.\n");
+
+    if (node_index)
+        FIXME("Ignoring node index %u.\n", node_index);
 
-        TRACE("Budget 0x%s, usage 0x%s, available for reservation 0x%s, reservation 0x%s.\n",
-                wine_dbgstr_longlong(info->Budget), wine_dbgstr_longlong(info->CurrentUsage),
-                wine_dbgstr_longlong(info->AvailableForReservation),
-                wine_dbgstr_longlong(info->CurrentReservation));
+    adapter_id.driver_size = 0;
+    adapter_id.description_size = 0;
+
+    if (FAILED(hr = wined3d_adapter_get_identifier(adapter->wined3d_adapter, 0, &adapter_id)))
+        return hr;
+
+    switch (segment_group)
+    {
+        case DXGI_MEMORY_SEGMENT_GROUP_LOCAL:
+            info->Budget = adapter_id.video_memory;
+            info->CurrentUsage = 0;
+            info->AvailableForReservation = adapter_id.video_memory / 2;
+            info->CurrentReservation = 0;
+            break;
+        case DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL:
+            memset(info, 0, sizeof(*info));
+            break;
+        default:
+            WARN("Invalid memory segment group %#x.\n", segment_group);
+            return E_INVALIDARG;
     }
 
+    TRACE("Budget 0x%s, usage 0x%s, available for reservation 0x%s, reservation 0x%s.\n",
+            wine_dbgstr_longlong(info->Budget), wine_dbgstr_longlong(info->CurrentUsage),
+            wine_dbgstr_longlong(info->AvailableForReservation), wine_dbgstr_longlong(info->CurrentReservation));
+
     return hr;
 }
 
@@ -333,22 +346,15 @@ static HRESULT STDMETHODCALLTYPE dxgi_adapter_SetVideoMemoryReservation(IWineDXG
 static HRESULT STDMETHODCALLTYPE dxgi_adapter_RegisterVideoMemoryBudgetChangeNotificationEvent(
         IWineDXGIAdapter *iface, HANDLE event, DWORD *cookie)
 {
-    struct dxgi_adapter *adapter = impl_from_IWineDXGIAdapter(iface);
-
-    TRACE("iface %p, event %p, cookie %p.\n", iface, event, cookie);
-
-    if (!event || !cookie)
-        return DXGI_ERROR_INVALID_CALL;
+    FIXME("iface %p, event %p, cookie %p stub!\n", iface, event, cookie);
 
-    return wined3d_adapter_register_budget_change_notification(adapter->wined3d_adapter, event, cookie);
+    return E_NOTIMPL;
 }
 
 static void STDMETHODCALLTYPE dxgi_adapter_UnregisterVideoMemoryBudgetChangeNotification(
         IWineDXGIAdapter *iface, DWORD cookie)
 {
-    TRACE("iface %p, cookie %#lx.\n", iface, cookie);
-
-    wined3d_adapter_unregister_budget_change_notification(cookie);
+    FIXME("iface %p, cookie %#lx stub!\n", iface, cookie);
 }
 
 static HRESULT STDMETHODCALLTYPE dxgi_adapter_GetDesc3(IWineDXGIAdapter *iface, DXGI_ADAPTER_DESC3 *desc)
diff --git a/dlls/dxgi/tests/dxgi.c b/dlls/dxgi/tests/dxgi.c
index 33e9ead31ad..04bba29e8e5 100644
--- a/dlls/dxgi/tests/dxgi.c
+++ b/dlls/dxgi/tests/dxgi.c
@@ -7539,13 +7539,16 @@ static void test_video_memory_budget_notification(void)
         goto done;
 
     hr = IDXGIAdapter3_RegisterVideoMemoryBudgetChangeNotificationEvent(adapter3, NULL, &cookie);
+    todo_wine
     ok(hr == DXGI_ERROR_INVALID_CALL, "Got unexpected hr %#lx.\n", hr);
 
     event = CreateEventW(NULL, FALSE, FALSE, NULL);
     hr = IDXGIAdapter3_RegisterVideoMemoryBudgetChangeNotificationEvent(adapter3, event, NULL);
+    todo_wine
     ok(hr == DXGI_ERROR_INVALID_CALL, "Got unexpected hr %#lx.\n", hr);
 
     hr = IDXGIAdapter3_RegisterVideoMemoryBudgetChangeNotificationEvent(adapter3, event, &cookie);
+    todo_wine
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
     hr = IDXGIAdapter3_QueryVideoMemoryInfo(adapter3, 0, DXGI_MEMORY_SEGMENT_GROUP_LOCAL, &memory_info);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
@@ -7557,6 +7560,7 @@ static void test_video_memory_budget_notification(void)
     if (memory_info.Budget)
     {
         ret = WaitForSingleObject(event, 1000);
+        todo_wine
         ok(ret == WAIT_OBJECT_0, "Expected event fired.\n");
     }
 
diff --git a/dlls/gdi.exe16/gdi.c b/dlls/gdi.exe16/gdi.c
index 3f363ef2401..b4bcd1c2228 100644
--- a/dlls/gdi.exe16/gdi.c
+++ b/dlls/gdi.exe16/gdi.c
@@ -23,10 +23,11 @@
 
 #include "windef.h"
 #include "winbase.h"
-#include "ntgdi.h"
+#include "wingdi.h"
 #include "wownt32.h"
 #include "wine/wingdi16.h"
 #include "wine/list.h"
+#include "wine/gdi_driver.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(gdi);
@@ -429,6 +430,129 @@ static void free_segptr_bits( HBITMAP16 bmp )
     }
 }
 
+/* window surface used to implement the DIB.DRV driver */
+
+struct dib_window_surface
+{
+    struct window_surface header;
+    RECT                  bounds;
+    void                 *bits;
+    UINT                  info_size;
+    BITMAPINFO            info;   /* variable size, must be last */
+};
+
+static struct dib_window_surface *get_dib_surface( struct window_surface *surface )
+{
+    return (struct dib_window_surface *)surface;
+}
+
+/***********************************************************************
+ *           dib_surface_lock
+ */
+static void CDECL dib_surface_lock( struct window_surface *window_surface )
+{
+    /* nothing to do */
+}
+
+/***********************************************************************
+ *           dib_surface_unlock
+ */
+static void CDECL dib_surface_unlock( struct window_surface *window_surface )
+{
+    /* nothing to do */
+}
+
+/***********************************************************************
+ *           dib_surface_get_bitmap_info
+ */
+static void *CDECL dib_surface_get_bitmap_info( struct window_surface *window_surface, BITMAPINFO *info )
+{
+    struct dib_window_surface *surface = get_dib_surface( window_surface );
+
+    memcpy( info, &surface->info, surface->info_size );
+    return surface->bits;
+}
+
+/***********************************************************************
+ *           dib_surface_get_bounds
+ */
+static RECT *CDECL dib_surface_get_bounds( struct window_surface *window_surface )
+{
+    struct dib_window_surface *surface = get_dib_surface( window_surface );
+
+    return &surface->bounds;
+}
+
+/***********************************************************************
+ *           dib_surface_set_region
+ */
+static void CDECL dib_surface_set_region( struct window_surface *window_surface, HRGN region )
+{
+    /* nothing to do */
+}
+
+/***********************************************************************
+ *           dib_surface_flush
+ */
+static void CDECL dib_surface_flush( struct window_surface *window_surface )
+{
+    /* nothing to do */
+}
+
+/***********************************************************************
+ *           dib_surface_destroy
+ */
+static void CDECL dib_surface_destroy( struct window_surface *window_surface )
+{
+    struct dib_window_surface *surface = get_dib_surface( window_surface );
+
+    TRACE( "freeing %p\n", surface );
+    HeapFree( GetProcessHeap(), 0, surface );
+}
+
+static const struct window_surface_funcs dib_surface_funcs =
+{
+    dib_surface_lock,
+    dib_surface_unlock,
+    dib_surface_get_bitmap_info,
+    dib_surface_get_bounds,
+    dib_surface_set_region,
+    dib_surface_flush,
+    dib_surface_destroy
+};
+
+/***********************************************************************
+ *           create_surface
+ */
+static struct window_surface *create_surface( const BITMAPINFO *info )
+{
+    struct dib_window_surface *surface;
+    int color = 0;
+
+    if (info->bmiHeader.biBitCount <= 8)
+        color = info->bmiHeader.biClrUsed ? info->bmiHeader.biClrUsed : (1 << info->bmiHeader.biBitCount);
+    else if (info->bmiHeader.biCompression == BI_BITFIELDS)
+        color = 3;
+
+    surface = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY,
+                         offsetof( struct dib_window_surface, info.bmiColors[color] ));
+    if (!surface) return NULL;
+
+    surface->header.funcs       = &dib_surface_funcs;
+    surface->header.rect.left   = 0;
+    surface->header.rect.top    = 0;
+    surface->header.rect.right  = info->bmiHeader.biWidth;
+    surface->header.rect.bottom = abs(info->bmiHeader.biHeight);
+    surface->header.ref         = 1;
+    surface->info_size          = offsetof( BITMAPINFO, bmiColors[color] );
+    surface->bits               = (char *)info + surface->info_size;
+    memcpy( &surface->info, info, surface->info_size );
+
+    TRACE( "created %p %lux%lu for info %p bits %p\n",
+           surface, surface->header.rect.right, surface->header.rect.bottom, info, surface->bits );
+    return &surface->header;
+}
+
 
 /***********************************************************************
  *           SetBkColor    (GDI.1)
@@ -1175,8 +1299,19 @@ HDC16 WINAPI CreateDC16( LPCSTR driver, LPCSTR device, LPCSTR output,
 {
     if (!lstrcmpiA( driver, "dib" ) || !lstrcmpiA( driver, "dirdib" ))
     {
-        DRIVER_INFO_2W driver_info = { .cVersion = NTGDI_WIN16_DIB };
-        return HDC_16( NtGdiOpenDCW( NULL, NULL, NULL, 0, TRUE, 0, &driver_info, (void *)initData ));
+        struct window_surface *surface;
+        HDC hdc;
+
+        if (!(surface = create_surface( (const BITMAPINFO *)initData ))) return 0;
+
+        if ((hdc = CreateDCA( "DISPLAY", NULL, NULL, NULL )))
+        {
+            __wine_set_visible_region( hdc, CreateRectRgnIndirect( &surface->rect ),
+                                       &surface->rect, &surface->rect, surface );
+            TRACE( "returning hdc %p surface %p\n", hdc, surface );
+        }
+        window_surface_release( surface );
+        return HDC_16( hdc );
     }
     return HDC_16( CreateDCA( driver, device, output, initData ) );
 }
diff --git a/dlls/gdi32/dc.c b/dlls/gdi32/dc.c
index c193a62aed8..b00fff167cb 100644
--- a/dlls/gdi32/dc.c
+++ b/dlls/gdi32/dc.c
@@ -2092,7 +2092,7 @@ BOOL WINAPI ScaleWindowExtEx( HDC hdc, INT x_num, INT x_denom,
 
 static UINT WINAPI realize_palette( HDC hdc )
 {
-    return NtUserRealizePalette( hdc );
+    return NtUserCallOneParam( HandleToUlong(hdc), NtUserRealizePalette );
 }
 
 /* Pointers to USER implementation of SelectPalette/RealizePalette */
diff --git a/dlls/gdi32/gdi32.spec b/dlls/gdi32/gdi32.spec
index d6a0ad90e1e..d0ffe827539 100644
--- a/dlls/gdi32/gdi32.spec
+++ b/dlls/gdi32/gdi32.spec
@@ -85,7 +85,6 @@
 @ stdcall D3DKMTOpenAdapterFromHdc(ptr) win32u.NtGdiDdDDIOpenAdapterFromHdc
 @ stdcall D3DKMTOpenAdapterFromLuid(ptr) win32u.NtGdiDdDDIOpenAdapterFromLuid
 @ stdcall D3DKMTQueryStatistics(ptr) win32u.NtGdiDdDDIQueryStatistics
-@ stdcall D3DKMTQueryVideoMemoryInfo(ptr) win32u.NtGdiDdDDIQueryVideoMemoryInfo
 @ stdcall D3DKMTSetQueuedLimit(ptr) win32u.NtGdiDdDDISetQueuedLimit
 @ stdcall D3DKMTSetVidPnSourceOwner(ptr) win32u.NtGdiDdDDISetVidPnSourceOwner
 @ stdcall DPtoLP(long ptr long)
diff --git a/dlls/gdi32/objects.c b/dlls/gdi32/objects.c
index 42bf6fcf111..0260027a484 100644
--- a/dlls/gdi32/objects.c
+++ b/dlls/gdi32/objects.c
@@ -695,7 +695,7 @@ HRGN WINAPI CreatePolygonRgn( const POINT *points, INT count, INT mode )
  */
 BOOL WINAPI MirrorRgn( HWND hwnd, HRGN hrgn )
 {
-    return NtUserMirrorRgn( hwnd, hrgn );
+    return NtUserCallTwoParam( HandleToUlong(hwnd), HandleToUlong(hrgn), NtUserMirrorRgn );
 }
 
 /***********************************************************************
diff --git a/dlls/gdi32/tests/bitmap.c b/dlls/gdi32/tests/bitmap.c
index d3074286ee6..18d1e8f6c28 100644
--- a/dlls/gdi32/tests/bitmap.c
+++ b/dlls/gdi32/tests/bitmap.c
@@ -2789,6 +2789,7 @@ static void test_CreateBitmap(void)
        "0: %p, 1: %p, 4: %p, 5: %p, curObj1 %p, old1 %p\n",
        bm, bm1, bm4, bm5, curObj1, old1);
     ok(bm != bm2 && bm != bm3, "0: %p, 2: %p, 3: %p\n", bm, bm2, bm3);
+    todo_wine
     ok(bm != curObj2, "0: %p, curObj2 %p\n", bm, curObj2);
     ok(old2 == 0, "old2 %p\n", old2);
 
diff --git a/dlls/gdi32/tests/driver.c b/dlls/gdi32/tests/driver.c
index 79eedda1241..3d25eacacd9 100644
--- a/dlls/gdi32/tests/driver.c
+++ b/dlls/gdi32/tests/driver.c
@@ -48,27 +48,8 @@ static NTSTATUS (WINAPI *pD3DKMTOpenAdapterFromDeviceName)(D3DKMT_OPENADAPTERFRO
 static NTSTATUS (WINAPI *pD3DKMTOpenAdapterFromGdiDisplayName)(D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME *);
 static NTSTATUS (WINAPI *pD3DKMTOpenAdapterFromHdc)(D3DKMT_OPENADAPTERFROMHDC *);
 static NTSTATUS (WINAPI *pD3DKMTSetVidPnSourceOwner)(const D3DKMT_SETVIDPNSOURCEOWNER *);
-static NTSTATUS (WINAPI *pD3DKMTQueryVideoMemoryInfo)(D3DKMT_QUERYVIDEOMEMORYINFO *);
 static HRESULT  (WINAPI *pDwmEnableComposition)(UINT);
 
-static BOOL get_primary_adapter_name(WCHAR *name)
-{
-    DISPLAY_DEVICEW dd;
-    DWORD adapter_idx;
-
-    dd.cb = sizeof(dd);
-    for (adapter_idx = 0; EnumDisplayDevicesW(NULL, adapter_idx, &dd, 0); ++adapter_idx)
-    {
-        if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
-        {
-            lstrcpyW(name, dd.DeviceName);
-            return TRUE;
-        }
-    }
-
-    return FALSE;
-}
-
 static void test_D3DKMTOpenAdapterFromGdiDisplayName(void)
 {
     D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME open_adapter_gdi_desc;
@@ -905,91 +886,6 @@ static void test_D3DKMTOpenAdapterFromDeviceName(void)
     winetest_pop_context();
 }
 
-static void test_D3DKMTQueryVideoMemoryInfo(void)
-{
-    static const D3DKMT_MEMORY_SEGMENT_GROUP groups[] = {D3DKMT_MEMORY_SEGMENT_GROUP_LOCAL,
-                                                         D3DKMT_MEMORY_SEGMENT_GROUP_NON_LOCAL};
-    D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME open_adapter_desc;
-    D3DKMT_QUERYVIDEOMEMORYINFO query_memory_info;
-    D3DKMT_CLOSEADAPTER close_adapter_desc;
-    NTSTATUS status;
-    unsigned int i;
-    BOOL ret;
-
-    if (!pD3DKMTQueryVideoMemoryInfo)
-    {
-        win_skip("D3DKMTQueryVideoMemoryInfo() is unavailable.\n");
-        return;
-    }
-
-    ret = get_primary_adapter_name(open_adapter_desc.DeviceName);
-    ok(ret, "Failed to get primary adapter name.\n");
-    status = pD3DKMTOpenAdapterFromGdiDisplayName(&open_adapter_desc);
-    ok(status == STATUS_SUCCESS, "Got unexpected return code %#lx.\n", status);
-
-    /* Normal query */
-    for (i = 0; i < ARRAY_SIZE(groups); ++i)
-    {
-        winetest_push_context("group %d", groups[i]);
-
-        query_memory_info.hProcess = NULL;
-        query_memory_info.hAdapter = open_adapter_desc.hAdapter;
-        query_memory_info.PhysicalAdapterIndex = 0;
-        query_memory_info.MemorySegmentGroup = groups[i];
-        status = pD3DKMTQueryVideoMemoryInfo(&query_memory_info);
-        ok(status == STATUS_SUCCESS, "Got unexpected return code %#lx.\n", status);
-        ok(query_memory_info.Budget >= query_memory_info.AvailableForReservation,
-           "Unexpected budget %I64u and reservation %I64u.\n", query_memory_info.Budget,
-           query_memory_info.AvailableForReservation);
-        ok(query_memory_info.CurrentUsage <= query_memory_info.Budget,
-           "Unexpected current usage %I64u.\n", query_memory_info.CurrentUsage);
-        ok(query_memory_info.CurrentReservation == 0,
-           "Unexpected current reservation %I64u.\n", query_memory_info.CurrentReservation);
-
-        winetest_pop_context();
-    }
-
-    /* Query using the current process handle */
-    query_memory_info.hProcess = GetCurrentProcess();
-    status = pD3DKMTQueryVideoMemoryInfo(&query_memory_info);
-    ok(status == STATUS_SUCCESS, "Got unexpected return code %#lx.\n", status);
-
-    /* Query using a process handle without PROCESS_QUERY_INFORMATION privilege */
-    query_memory_info.hProcess = OpenProcess(PROCESS_SET_INFORMATION, FALSE, GetCurrentProcessId());
-    ok(!!query_memory_info.hProcess, "OpenProcess failed, error %ld.\n", GetLastError());
-    status = pD3DKMTQueryVideoMemoryInfo(&query_memory_info);
-    ok(status == STATUS_ACCESS_DENIED, "Got unexpected return code %#lx.\n", status);
-    CloseHandle(query_memory_info.hProcess);
-    query_memory_info.hProcess = NULL;
-
-    /* Query using an invalid process handle */
-    query_memory_info.hProcess = (HANDLE)0xdeadbeef;
-    status = pD3DKMTQueryVideoMemoryInfo(&query_memory_info);
-    ok(status == STATUS_INVALID_HANDLE, "Got unexpected return code %#lx.\n", status);
-    query_memory_info.hProcess = NULL;
-
-    /* Query using an invalid adapter handle */
-    query_memory_info.hAdapter = (D3DKMT_HANDLE)0xdeadbeef;
-    status = pD3DKMTQueryVideoMemoryInfo(&query_memory_info);
-    ok(status == STATUS_INVALID_PARAMETER, "Got unexpected return code %#lx.\n", status);
-    query_memory_info.hAdapter = open_adapter_desc.hAdapter;
-
-    /* Query using an invalid adapter index */
-    query_memory_info.PhysicalAdapterIndex = 99;
-    status = pD3DKMTQueryVideoMemoryInfo(&query_memory_info);
-    ok(status == STATUS_INVALID_PARAMETER, "Got unexpected return code %#lx.\n", status);
-    query_memory_info.PhysicalAdapterIndex = 0;
-
-    /* Query using an invalid memory segment group */
-    query_memory_info.MemorySegmentGroup = D3DKMT_MEMORY_SEGMENT_GROUP_NON_LOCAL + 1;
-    status = pD3DKMTQueryVideoMemoryInfo(&query_memory_info);
-    ok(status == STATUS_INVALID_PARAMETER, "Got unexpected return code %#lx.\n", status);
-
-    close_adapter_desc.hAdapter = open_adapter_desc.hAdapter;
-    status = pD3DKMTCloseAdapter(&close_adapter_desc);
-    ok(status == STATUS_SUCCESS, "Got unexpected return code %#lx.\n", status);
-}
-
 START_TEST(driver)
 {
     HMODULE gdi32 = GetModuleHandleA("gdi32.dll");
@@ -1004,7 +900,6 @@ START_TEST(driver)
     pD3DKMTOpenAdapterFromGdiDisplayName = (void *)GetProcAddress(gdi32, "D3DKMTOpenAdapterFromGdiDisplayName");
     pD3DKMTOpenAdapterFromHdc = (void *)GetProcAddress(gdi32, "D3DKMTOpenAdapterFromHdc");
     pD3DKMTSetVidPnSourceOwner = (void *)GetProcAddress(gdi32, "D3DKMTSetVidPnSourceOwner");
-    pD3DKMTQueryVideoMemoryInfo = (void *)GetProcAddress(gdi32, "D3DKMTQueryVideoMemoryInfo");
 
     if (dwmapi)
         pDwmEnableComposition = (void *)GetProcAddress(dwmapi, "DwmEnableComposition");
@@ -1018,7 +913,6 @@ START_TEST(driver)
     test_D3DKMTSetVidPnSourceOwner();
     test_D3DKMTCheckOcclusion();
     test_D3DKMTOpenAdapterFromDeviceName();
-    test_D3DKMTQueryVideoMemoryInfo();
 
     FreeLibrary(dwmapi);
 }
diff --git a/dlls/gdi32/uniscribe/usp10.c b/dlls/gdi32/uniscribe/usp10.c
index 3e27fcc2a03..a5637dbf645 100644
--- a/dlls/gdi32/uniscribe/usp10.c
+++ b/dlls/gdi32/uniscribe/usp10.c
@@ -31,7 +31,6 @@
 #include "windef.h"
 #include "winbase.h"
 #include "ntgdi.h"
-#include "ntuser.h"
 #include "winuser.h"
 #include "winnls.h"
 #include "winreg.h"
@@ -2108,6 +2107,19 @@ static inline BOOL does_glyph_start_cluster(const SCRIPT_VISATTR *pva, const WOR
     return FALSE;
 }
 
+static DWORD get_sys_color(INT index)
+{
+    static DWORD (WINAPI *pGetSysColor)(INT index);
+
+    if (!pGetSysColor)
+    {
+        HMODULE user = GetModuleHandleW( L"user32.dll" );
+        if (user) pGetSysColor = (void *)GetProcAddress( user, "GetSysColor" );
+    }
+
+    return pGetSysColor(index);
+}
+
 static HRESULT SS_ItemOut( SCRIPT_STRING_ANALYSIS ssa,
                            int iX,
                            int iY,
@@ -2147,11 +2159,11 @@ static HRESULT SS_ItemOut( SCRIPT_STRING_ANALYSIS ssa,
         BkMode = GetBkMode(analysis->hdc);
         SetBkMode( analysis->hdc, OPAQUE);
         BkColor = GetBkColor(analysis->hdc);
-        SetBkColor(analysis->hdc, NtUserGetSysColor(COLOR_HIGHLIGHT));
+        SetBkColor(analysis->hdc, get_sys_color(COLOR_HIGHLIGHT));
         if (!fDisabled)
         {
             TextColor = GetTextColor(analysis->hdc);
-            SetTextColor(analysis->hdc, NtUserGetSysColor(COLOR_HIGHLIGHTTEXT));
+            SetTextColor(analysis->hdc, get_sys_color(COLOR_HIGHLIGHTTEXT));
         }
     }
     if (analysis->glyphs[iItem].fallbackFont)
diff --git a/dlls/hidclass.sys/Makefile.in b/dlls/hidclass.sys/Makefile.in
index 0e55bb9a232..788828ad66a 100644
--- a/dlls/hidclass.sys/Makefile.in
+++ b/dlls/hidclass.sys/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = hidclass.sys
 IMPORTLIB = hidclass
-IMPORTS   = hal ntoskrnl user32 hidparse win32u
+IMPORTS   = hal ntoskrnl user32 hidparse
 
 C_SRCS = \
 	device.c \
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 15bb3be34b2..6d937675bcb 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -2255,12 +2255,6 @@ NTSTATUS WINAPI NtSetInformationThread( HANDLE handle, THREADINFOCLASS class,
         FIXME( "ThreadEnableAlignmentFaultFixup stub!\n" );
         return STATUS_SUCCESS;
 
-    case ThreadPowerThrottlingState:
-        if (length != sizeof(THREAD_POWER_THROTTLING_STATE)) return STATUS_INFO_LENGTH_MISMATCH;
-        if (!data) return STATUS_ACCESS_VIOLATION;
-        FIXME( "ThreadPowerThrottling stub!\n" );
-        return STATUS_SUCCESS;
-
     case ThreadBasicInformation:
     case ThreadTimes:
     case ThreadPriority:
diff --git a/dlls/opengl32/make_opengl b/dlls/opengl32/make_opengl
index 09531731f8d..ebfd3c9161e 100755
--- a/dlls/opengl32/make_opengl
+++ b/dlls/opengl32/make_opengl
@@ -645,7 +645,8 @@ foreach (sort keys %norm_functions)
 }
 print HEADER "\n\n";
 
-print HEADER "extern struct opengl_funcs * CDECL __wine_get_wgl_driver( HDC hdc, UINT version );\n\n";
+print HEADER "extern struct opengl_funcs * CDECL __wine_get_wgl_driver( HDC hdc, UINT version );\n";
+print HEADER "extern BOOL CDECL __wine_set_pixel_format( HWND hwnd, int format );\n\n";
 print HEADER "#endif /* __WINE_WGL_DRIVER_H */\n";
 close HEADER;
 
diff --git a/dlls/user.exe16/message.c b/dlls/user.exe16/message.c
index 46561d722ed..5940adcfcb0 100644
--- a/dlls/user.exe16/message.c
+++ b/dlls/user.exe16/message.c
@@ -2568,6 +2568,20 @@ static LRESULT static_proc16( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam,
 }
 
 
+/***********************************************************************
+ *           wait_message16
+ */
+static DWORD wait_message16( DWORD count, const HANDLE *handles, DWORD timeout, DWORD mask, DWORD flags )
+{
+    DWORD lock, ret;
+
+    ReleaseThunkLock( &lock );
+    ret = wow_handlers32.wait_message( count, handles, timeout, mask, flags );
+    RestoreThunkLock( lock );
+    return ret;
+}
+
+
 /***********************************************************************
  *           create_window16
  */
@@ -2587,19 +2601,6 @@ static void WINAPI User16CallFreeIcon( ULONG *param, ULONG size )
 }
 
 
-static DWORD WINAPI User16ThunkLock( DWORD *param, ULONG size )
-{
-    if (size != sizeof(DWORD))
-    {
-        DWORD lock;
-        ReleaseThunkLock( &lock );
-        return lock;
-    }
-    RestoreThunkLock( *param );
-    return 0;
-}
-
-
 void register_wow_handlers(void)
 {
     void **callback_table = NtCurrentTeb()->Peb->KernelCallbackTable;
@@ -2612,15 +2613,13 @@ void register_wow_handlers(void)
         mdiclient_proc16,
         scrollbar_proc16,
         static_proc16,
+        wait_message16,
         create_window16,
         call_window_proc_Ato16,
         call_dialog_proc_Ato16,
     };
 
     callback_table[NtUserCallFreeIcon] = User16CallFreeIcon;
-    callback_table[NtUserThunkLock]    = User16ThunkLock;
-
-    NtUserEnableThunkLock( TRUE );
 
     UserRegisterWowHandlers( &handlers16, &wow_handlers32 );
 }
diff --git a/dlls/user.exe16/user.c b/dlls/user.exe16/user.c
index 75b81b0ea05..39adb874125 100644
--- a/dlls/user.exe16/user.c
+++ b/dlls/user.exe16/user.c
@@ -300,7 +300,7 @@ static HICON store_icon_32( HICON16 icon16, HICON icon )
         {
             memcpy( &ret, (char *)(ptr + 1) + and_size + xor_size, sizeof(ret) );
             memcpy( (char *)(ptr + 1) + and_size + xor_size, &icon, sizeof(icon) );
-            NtUserSetIconParam( icon, icon16 );
+            NtUserCallTwoParam( HandleToUlong(icon), icon16, NtUserSetIconParam );
         }
         release_icon_ptr( icon16, ptr );
     }
@@ -342,7 +342,7 @@ HICON get_icon_32( HICON16 icon16 )
                 DeleteObject( iinfo.hbmMask );
                 DeleteObject( iinfo.hbmColor );
                 memcpy( (char *)(ptr + 1) + xor_size + and_size, &ret, sizeof(ret) );
-                NtUserSetIconParam( ret, icon16 );
+                NtUserCallTwoParam( HandleToUlong(ret), icon16, NtUserSetIconParam );
             }
         }
         release_icon_ptr( icon16, ptr );
@@ -353,7 +353,7 @@ HICON get_icon_32( HICON16 icon16 )
 /* retrieve the 16-bit counterpart of a 32-bit icon, creating it if needed */
 HICON16 get_icon_16( HICON icon )
 {
-    HICON16 ret = NtUserGetIconParam( icon );
+    HICON16 ret = NtUserCallOneParam( HandleToUlong(icon), NtUserGetIconParam );
 
     if (!ret)
     {
diff --git a/dlls/user.exe16/user_private.h b/dlls/user.exe16/user_private.h
index 0805997246b..f1ca817a080 100644
--- a/dlls/user.exe16/user_private.h
+++ b/dlls/user.exe16/user_private.h
@@ -41,6 +41,7 @@ struct wow_handlers16
     LRESULT (*mdiclient_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
     LRESULT (*scrollbar_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
     LRESULT (*static_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
+    DWORD   (*wait_message)(DWORD,const HANDLE*,DWORD,DWORD,DWORD);
     HWND    (*create_window)(CREATESTRUCTW*,LPCWSTR,HINSTANCE,BOOL);
     LRESULT (*call_window_proc)(HWND,UINT,WPARAM,LPARAM,LRESULT*,void*);
     LRESULT (*call_dialog_proc)(HWND,UINT,WPARAM,LPARAM,LRESULT*,void*);
@@ -55,6 +56,7 @@ struct wow_handlers32
     LRESULT (*mdiclient_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
     LRESULT (*scrollbar_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
     LRESULT (*static_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
+    DWORD   (*wait_message)(DWORD,const HANDLE*,DWORD,DWORD,DWORD);
     HWND    (*create_window)(CREATESTRUCTW*,LPCWSTR,HINSTANCE,BOOL);
     HWND    (*get_win_handle)(HWND);
     WNDPROC (*alloc_winproc)(WNDPROC,BOOL);
diff --git a/dlls/user.exe16/window.c b/dlls/user.exe16/window.c
index e54dd6a803e..5dd9801db18 100644
--- a/dlls/user.exe16/window.c
+++ b/dlls/user.exe16/window.c
@@ -675,7 +675,7 @@ HDC16 WINAPI GetWindowDC16( HWND16 hwnd )
 INT16 WINAPI ReleaseDC16( HWND16 hwnd, HDC16 hdc )
 {
     INT16 ret = (INT16)ReleaseDC( WIN_Handle32(hwnd), HDC_32(hdc) );
-    NtUserEnableDC( HDC_32(hdc) );
+    NtUserCallOneParam( HandleToUlong( HDC_32(hdc) ), NtUserEnableDC );
     return ret;
 }
 
diff --git a/dlls/user32/Makefile.in b/dlls/user32/Makefile.in
index 79821929390..d6e88ddb73e 100644
--- a/dlls/user32/Makefile.in
+++ b/dlls/user32/Makefile.in
@@ -7,6 +7,7 @@ DELAYIMPORTS = setupapi imm32
 
 C_SRCS = \
 	button.c \
+	caret.c \
 	class.c \
 	clipboard.c \
 	combo.c \
@@ -18,6 +19,7 @@ C_SRCS = \
 	defwnd.c \
 	desktop.c \
 	dialog.c \
+	driver.c \
 	edit.c \
 	exticon.c \
 	focus.c \
@@ -37,6 +39,7 @@ C_SRCS = \
 	rawinput.c \
 	resource.c \
 	scroll.c \
+	spy.c \
 	static.c \
 	sysparams.c \
 	text.c \
diff --git a/dlls/user32/caret.c b/dlls/user32/caret.c
new file mode 100644
index 00000000000..8bf4962b708
--- /dev/null
+++ b/dlls/user32/caret.c
@@ -0,0 +1,406 @@
+/*
+ * Caret functions
+ *
+ * Copyright 1993 David Metcalfe
+ * Copyright 1996 Frans van Dorsselaer
+ * Copyright 2001 Eric Pouech
+ * Copyright 2002 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "ntuser.h"
+#include "wine/server.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(caret);
+
+typedef struct
+{
+    HBITMAP  hBmp;
+    UINT     timeout;
+} CARET;
+
+static CARET Caret = { 0, 500 };
+
+#define TIMERID 0xffff  /* system timer id for the caret */
+
+
+/*****************************************************************
+ *               CARET_DisplayCaret
+ */
+static void CARET_DisplayCaret( HWND hwnd, const RECT *r )
+{
+    HDC hdc;
+    HDC hCompDC;
+
+    /* do not use DCX_CACHE here, for x,y,width,height are in logical units */
+    if (!(hdc = NtUserGetDCEx( hwnd, 0, DCX_USESTYLE /*| DCX_CACHE*/ ))) return;
+    hCompDC = CreateCompatibleDC(hdc);
+    if (hCompDC)
+    {
+	HBITMAP	hPrevBmp;
+
+	hPrevBmp = SelectObject(hCompDC, Caret.hBmp);
+	BitBlt(hdc, r->left, r->top, r->right-r->left, r->bottom-r->top, hCompDC, 0, 0, SRCINVERT);
+	SelectObject(hCompDC, hPrevBmp);
+	DeleteDC(hCompDC);
+    }
+    NtUserReleaseDC( hwnd, hdc );
+}
+
+
+/*****************************************************************
+ *               CARET_Callback
+ */
+static void CALLBACK CARET_Callback( HWND hwnd, UINT msg, UINT_PTR id, DWORD ctime)
+{
+    BOOL ret;
+    RECT r;
+    int hidden = 0;
+
+    SERVER_START_REQ( set_caret_info )
+    {
+        req->flags  = SET_CARET_STATE;
+        req->handle = wine_server_user_handle( hwnd );
+        req->x      = 0;
+        req->y      = 0;
+        req->hide   = 0;
+        req->state  = CARET_STATE_TOGGLE;
+        if ((ret = !wine_server_call( req )))
+        {
+            hwnd      = wine_server_ptr_handle( reply->full_handle );
+            r.left    = reply->old_rect.left;
+            r.top     = reply->old_rect.top;
+            r.right   = reply->old_rect.right;
+            r.bottom  = reply->old_rect.bottom;
+            hidden    = reply->old_hide;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (ret && !hidden) CARET_DisplayCaret( hwnd, &r );
+}
+
+
+/*****************************************************************
+ *		CreateCaret (USER32.@)
+ */
+BOOL WINAPI CreateCaret( HWND hwnd, HBITMAP bitmap, INT width, INT height )
+{
+    BOOL ret;
+    RECT r;
+    int old_state = 0;
+    int hidden = 0;
+    HBITMAP hBmp = 0;
+    HWND prev = 0;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    if (!hwnd) return FALSE;
+
+    if (bitmap && (bitmap != (HBITMAP)1))
+    {
+        BITMAP bmp;
+        if (!GetObjectA( bitmap, sizeof(bmp), &bmp )) return FALSE;
+        width = bmp.bmWidth;
+        height = bmp.bmHeight;
+	bmp.bmBits = NULL;
+	hBmp = CreateBitmapIndirect(&bmp);
+	if (hBmp)
+	{
+	    /* copy the bitmap */
+	    LPBYTE buf = HeapAlloc(GetProcessHeap(), 0, bmp.bmWidthBytes * bmp.bmHeight);
+	    GetBitmapBits(bitmap, bmp.bmWidthBytes * bmp.bmHeight, buf);
+	    SetBitmapBits(hBmp, bmp.bmWidthBytes * bmp.bmHeight, buf);
+	    HeapFree(GetProcessHeap(), 0, buf);
+	}
+    }
+    else
+    {
+	HDC hdc;
+
+        if (!width) width = GetSystemMetrics(SM_CXBORDER);
+        if (!height) height = GetSystemMetrics(SM_CYBORDER);
+
+	/* create the uniform bitmap on the fly */
+	hdc = GetDC(hwnd);
+	if (hdc)
+	{
+	    HDC hMemDC = CreateCompatibleDC(hdc);
+	    if (hMemDC)
+	    {
+		if ((hBmp = CreateCompatibleBitmap(hMemDC, width, height )))
+		{
+		    HBITMAP hPrevBmp = SelectObject(hMemDC, hBmp);
+                    SetRect( &r, 0, 0, width, height );
+		    FillRect(hMemDC, &r, bitmap ? GetStockObject(GRAY_BRUSH) : GetStockObject(WHITE_BRUSH));
+		    SelectObject(hMemDC, hPrevBmp);
+		}
+		DeleteDC(hMemDC);
+	    }
+	    NtUserReleaseDC(hwnd, hdc);
+	}
+    }
+    if (!hBmp) return FALSE;
+
+    SERVER_START_REQ( set_caret_window )
+    {
+        req->handle = wine_server_user_handle( hwnd );
+        req->width  = width;
+        req->height = height;
+        if ((ret = !wine_server_call_err( req )))
+        {
+            prev      = wine_server_ptr_handle( reply->previous );
+            r.left    = reply->old_rect.left;
+            r.top     = reply->old_rect.top;
+            r.right   = reply->old_rect.right;
+            r.bottom  = reply->old_rect.bottom;
+            old_state = reply->old_state;
+            hidden    = reply->old_hide;
+        }
+    }
+    SERVER_END_REQ;
+    if (!ret) return FALSE;
+
+    if (prev && !hidden)  /* hide the previous one */
+    {
+        /* FIXME: won't work if prev belongs to a different process */
+        KillSystemTimer( prev, TIMERID );
+        if (old_state) CARET_DisplayCaret( prev, &r );
+    }
+
+    if (Caret.hBmp) DeleteObject( Caret.hBmp );
+    Caret.hBmp = hBmp;
+    Caret.timeout = GetProfileIntA( "windows", "CursorBlinkRate", 500 );
+    return TRUE;
+}
+
+
+/*****************************************************************
+ *		DestroyCaret (USER32.@)
+ */
+BOOL WINAPI DestroyCaret(void)
+{
+    BOOL ret;
+    HWND prev = 0;
+    RECT r;
+    int old_state = 0;
+    int hidden = 0;
+
+    SERVER_START_REQ( set_caret_window )
+    {
+        req->handle = 0;
+        req->width  = 0;
+        req->height = 0;
+        if ((ret = !wine_server_call_err( req )))
+        {
+            prev      = wine_server_ptr_handle( reply->previous );
+            r.left    = reply->old_rect.left;
+            r.top     = reply->old_rect.top;
+            r.right   = reply->old_rect.right;
+            r.bottom  = reply->old_rect.bottom;
+            old_state = reply->old_state;
+            hidden    = reply->old_hide;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (ret && prev && !hidden)
+    {
+        /* FIXME: won't work if prev belongs to a different process */
+        KillSystemTimer( prev, TIMERID );
+        if (old_state) CARET_DisplayCaret( prev, &r );
+    }
+    if (Caret.hBmp) DeleteObject( Caret.hBmp );
+    Caret.hBmp = 0;
+    return ret;
+}
+
+
+/*****************************************************************
+ *		SetCaretPos (USER32.@)
+ */
+BOOL WINAPI SetCaretPos( INT x, INT y )
+{
+    BOOL ret;
+    HWND hwnd = 0;
+    RECT r;
+    int old_state = 0;
+    int hidden = 0;
+
+    SERVER_START_REQ( set_caret_info )
+    {
+        req->flags  = SET_CARET_POS|SET_CARET_STATE;
+        req->handle = 0;
+        req->x      = x;
+        req->y      = y;
+        req->hide   = 0;
+        req->state  = CARET_STATE_ON_IF_MOVED;
+        if ((ret = !wine_server_call_err( req )))
+        {
+            hwnd      = wine_server_ptr_handle( reply->full_handle );
+            r.left    = reply->old_rect.left;
+            r.top     = reply->old_rect.top;
+            r.right   = reply->old_rect.right;
+            r.bottom  = reply->old_rect.bottom;
+            old_state = reply->old_state;
+            hidden    = reply->old_hide;
+        }
+    }
+    SERVER_END_REQ;
+    if (ret && !hidden && (x != r.left || y != r.top))
+    {
+        if (old_state) CARET_DisplayCaret( hwnd, &r );
+        r.right += x - r.left;
+        r.bottom += y - r.top;
+        r.left = x;
+        r.top = y;
+        CARET_DisplayCaret( hwnd, &r );
+        NtUserSetSystemTimer( hwnd, TIMERID, Caret.timeout, CARET_Callback );
+    }
+    return ret;
+}
+
+
+/*****************************************************************
+ *		HideCaret (USER32.@)
+ */
+BOOL WINAPI HideCaret( HWND hwnd )
+{
+    BOOL ret;
+    RECT r;
+    int old_state = 0;
+    int hidden = 0;
+
+    SERVER_START_REQ( set_caret_info )
+    {
+        req->flags  = SET_CARET_HIDE|SET_CARET_STATE;
+        req->handle = wine_server_user_handle( hwnd );
+        req->x      = 0;
+        req->y      = 0;
+        req->hide   = 1;
+        req->state  = CARET_STATE_OFF;
+        if ((ret = !wine_server_call_err( req )))
+        {
+            hwnd      = wine_server_ptr_handle( reply->full_handle );
+            r.left    = reply->old_rect.left;
+            r.top     = reply->old_rect.top;
+            r.right   = reply->old_rect.right;
+            r.bottom  = reply->old_rect.bottom;
+            old_state = reply->old_state;
+            hidden    = reply->old_hide;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (ret && !hidden)
+    {
+        if (old_state) CARET_DisplayCaret( hwnd, &r );
+        KillSystemTimer( hwnd, TIMERID );
+    }
+    return ret;
+}
+
+
+/*****************************************************************
+ *		ShowCaret (USER32.@)
+ */
+BOOL WINAPI ShowCaret( HWND hwnd )
+{
+    BOOL ret;
+    RECT r;
+    int hidden = 0;
+
+    SERVER_START_REQ( set_caret_info )
+    {
+        req->flags  = SET_CARET_HIDE|SET_CARET_STATE;
+        req->handle = wine_server_user_handle( hwnd );
+        req->x      = 0;
+        req->y      = 0;
+        req->hide   = -1;
+        req->state  = CARET_STATE_ON;
+        if ((ret = !wine_server_call_err( req )))
+        {
+            hwnd      = wine_server_ptr_handle( reply->full_handle );
+            r.left    = reply->old_rect.left;
+            r.top     = reply->old_rect.top;
+            r.right   = reply->old_rect.right;
+            r.bottom  = reply->old_rect.bottom;
+            hidden    = reply->old_hide;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (ret && (hidden == 1))  /* hidden was 1 so it's now 0 */
+    {
+        CARET_DisplayCaret( hwnd, &r );
+        NtUserSetSystemTimer( hwnd, TIMERID, Caret.timeout, CARET_Callback );
+    }
+    return ret;
+}
+
+
+/*****************************************************************
+ *		GetCaretPos (USER32.@)
+ */
+BOOL WINAPI GetCaretPos( LPPOINT pt )
+{
+    BOOL ret;
+
+    SERVER_START_REQ( set_caret_info )
+    {
+        req->flags  = 0;  /* don't set anything */
+        req->handle = 0;
+        req->x      = 0;
+        req->y      = 0;
+        req->hide   = 0;
+        req->state  = 0;
+        if ((ret = !wine_server_call_err( req )))
+        {
+            pt->x = reply->old_rect.left;
+            pt->y = reply->old_rect.top;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
+}
+
+
+/*****************************************************************
+ *		SetCaretBlinkTime (USER32.@)
+ */
+BOOL WINAPI SetCaretBlinkTime( UINT msecs )
+{
+    TRACE("msecs=%d\n", msecs);
+
+    Caret.timeout = msecs;
+/*    if (Caret.hwnd) CARET_SetTimer(); FIXME */
+    return TRUE;
+}
+
+
+/*****************************************************************
+ *		GetCaretBlinkTime (USER32.@)
+ */
+UINT WINAPI GetCaretBlinkTime(void)
+{
+    return Caret.timeout;
+}
diff --git a/dlls/user32/class.c b/dlls/user32/class.c
index 620477f1b14..9c625e832d1 100644
--- a/dlls/user32/class.c
+++ b/dlls/user32/class.c
@@ -40,6 +40,10 @@ WINE_DEFAULT_DEBUG_CHANNEL(class);
 
 #define MAX_ATOM_LEN 255 /* from dlls/kernel32/atom.c */
 
+static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+
+#define CLASS_OTHER_PROCESS ((CLASS *)1)
+
 static inline const char *debugstr_us( const UNICODE_STRING *us )
 {
     if (!us) return "<null>";
@@ -305,9 +309,9 @@ static void load_uxtheme(void)
 }
 
 /***********************************************************************
- *           User32RegisterBuiltinClasses
+ *           register_builtins
  */
-BOOL WINAPI User32RegisterBuiltinClasses( const struct win_hook_params *params, ULONG size )
+static BOOL WINAPI register_builtins( INIT_ONCE *once, void *param, void **context )
 {
     register_builtin( &BUTTON_builtin_class );
     register_builtin( &COMBO_builtin_class );
@@ -328,6 +332,15 @@ BOOL WINAPI User32RegisterBuiltinClasses( const struct win_hook_params *params,
 }
 
 
+/***********************************************************************
+ *           register_builtin_classes
+ */
+void register_builtin_classes(void)
+{
+    InitOnceExecuteOnce( &init_once, register_builtins, NULL, NULL );
+}
+
+
 /***********************************************************************
  *           register_desktop_class
  */
@@ -338,6 +351,15 @@ void register_desktop_class(void)
 }
 
 
+/***********************************************************************
+ *           get_class_winproc
+ */
+WNDPROC get_class_winproc( CLASS *class )
+{
+    return class->winproc;
+}
+
+
 /***********************************************************************
  *		RegisterClassA (USER32.@)
  *
@@ -482,7 +504,7 @@ BOOL WINAPI UnregisterClassW( LPCWSTR className, HINSTANCE hInstance )
  */
 WORD WINAPI GetClassWord( HWND hwnd, INT offset )
 {
-    return NtUserGetClassWord( hwnd, offset );
+    return NtUserCallHwndParam( hwnd, offset, NtUserGetClassWord );
 }
 
 
@@ -491,7 +513,7 @@ WORD WINAPI GetClassWord( HWND hwnd, INT offset )
  */
 DWORD WINAPI GetClassLongW( HWND hwnd, INT offset )
 {
-    return NtUserGetClassLongW( hwnd, offset );
+    return NtUserCallHwndParam( hwnd, offset, NtUserGetClassLongW );
 }
 
 
@@ -501,7 +523,7 @@ DWORD WINAPI GetClassLongW( HWND hwnd, INT offset )
  */
 DWORD WINAPI GetClassLongA( HWND hwnd, INT offset )
 {
-    return NtUserGetClassLongA( hwnd, offset );
+    return NtUserCallHwndParam( hwnd, offset, NtUserGetClassLongA );
 }
 
 
@@ -766,7 +788,7 @@ BOOL16 WINAPI ClassNext16( CLASSENTRY *pClassEntry )
  */
 ULONG_PTR WINAPI GetClassLongPtrA( HWND hwnd, INT offset )
 {
-    return NtUserGetClassLongPtrA( hwnd, offset );
+    return NtUserCallHwndParam( hwnd, offset, NtUserGetClassLongPtrA );
 }
 
 /***********************************************************************
@@ -774,7 +796,7 @@ ULONG_PTR WINAPI GetClassLongPtrA( HWND hwnd, INT offset )
  */
 ULONG_PTR WINAPI GetClassLongPtrW( HWND hwnd, INT offset )
 {
-    return NtUserGetClassLongPtrW( hwnd, offset );
+    return NtUserCallHwndParam( hwnd, offset, NtUserGetClassLongPtrW );
 }
 
 /***********************************************************************
diff --git a/dlls/user32/clipboard.c b/dlls/user32/clipboard.c
index 7e5a3e0b022..b45ddf9c7c0 100644
--- a/dlls/user32/clipboard.c
+++ b/dlls/user32/clipboard.c
@@ -48,6 +48,17 @@
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
 
+struct cached_format
+{
+    struct list entry;       /* entry in cache list */
+    UINT        format;      /* format id */
+    UINT        seqno;       /* sequence number when the data was set */
+    HANDLE      handle;      /* original data handle */
+};
+
+static struct list cached_formats = LIST_INIT( cached_formats );
+static struct list formats_to_free = LIST_INIT( formats_to_free );
+
 static CRITICAL_SECTION clipboard_cs;
 static CRITICAL_SECTION_DEBUG critsect_debug =
 {
@@ -108,7 +119,7 @@ static const char *debugstr_format( UINT id )
 }
 
 /* build the data to send to the server in SetClipboardData */
-static HANDLE marshal_data( UINT format, HANDLE handle, size_t *ret_size )
+static HANDLE marshal_data( UINT format, HANDLE handle, data_size_t *ret_size )
 {
     SIZE_T size;
 
@@ -247,35 +258,110 @@ static HANDLE unmarshal_data( UINT format, void *data, data_size_t size )
     return handle;
 }
 
+/* retrieve a data format from the cache */
+static struct cached_format *get_cached_format( UINT format )
+{
+    struct cached_format *cache;
+
+    LIST_FOR_EACH_ENTRY( cache, &cached_formats, struct cached_format, entry )
+        if (cache->format == format) return cache;
+    return NULL;
+}
+
+/* store data in the cache, or reuse the existing one if available */
+static HANDLE cache_data( UINT format, HANDLE data, data_size_t size, UINT seqno,
+                          struct cached_format *cache )
+{
+    if (cache)
+    {
+        if (seqno == cache->seqno)  /* we can reuse the cached data */
+        {
+            GlobalFree( data );
+            return cache->handle;
+        }
+        /* cache entry is stale, remove it */
+        list_remove( &cache->entry );
+        list_add_tail( &formats_to_free, &cache->entry );
+    }
+
+    /* allocate new cache entry */
+    if (!(cache = HeapAlloc( GetProcessHeap(), 0, sizeof(*cache) )))
+    {
+        GlobalFree( data );
+        return 0;
+    }
+    cache->format = format;
+    cache->seqno  = seqno;
+    cache->handle = unmarshal_data( format, data, size );
+    list_add_tail( &cached_formats, &cache->entry );
+    return cache->handle;
+}
+
 /* free a single cached format */
-void free_cached_data( UINT format, HANDLE handle )
+static void free_cached_data( struct cached_format *cache )
 {
     void *ptr;
 
-    switch (format)
+    switch (cache->format)
     {
     case CF_BITMAP:
     case CF_DSPBITMAP:
     case CF_PALETTE:
-        DeleteObject( handle );
+        DeleteObject( cache->handle );
         break;
     case CF_ENHMETAFILE:
     case CF_DSPENHMETAFILE:
-        DeleteEnhMetaFile( handle );
+        DeleteEnhMetaFile( cache->handle );
         break;
     case CF_METAFILEPICT:
     case CF_DSPMETAFILEPICT:
-        if ((ptr = GlobalLock( handle )))
+        if ((ptr = GlobalLock( cache->handle )))
         {
             DeleteMetaFile( ((METAFILEPICT *)ptr)->hMF );
-            GlobalUnlock( handle );
+            GlobalUnlock( cache->handle );
         }
-        GlobalFree( handle );
+        GlobalFree( cache->handle );
         break;
     default:
-        GlobalFree( handle );
+        GlobalFree( cache->handle );
         break;
     }
+    list_remove( &cache->entry );
+    HeapFree( GetProcessHeap(), 0, cache );
+}
+
+/* clear global memory formats; special types are freed on EmptyClipboard */
+static void invalidate_memory_formats(void)
+{
+    struct cached_format *cache, *next;
+
+    LIST_FOR_EACH_ENTRY_SAFE( cache, next, &cached_formats, struct cached_format, entry )
+    {
+        switch (cache->format)
+        {
+        case CF_BITMAP:
+        case CF_DSPBITMAP:
+        case CF_PALETTE:
+        case CF_ENHMETAFILE:
+        case CF_DSPENHMETAFILE:
+        case CF_METAFILEPICT:
+        case CF_DSPMETAFILEPICT:
+            continue;
+        default:
+            free_cached_data( cache );
+            break;
+        }
+    }
+}
+
+/* free all the data in the cache */
+static void free_cached_formats(void)
+{
+    struct list *ptr;
+
+    list_move_tail( &formats_to_free, &cached_formats );
+    while ((ptr = list_head( &formats_to_free )))
+        free_cached_data( LIST_ENTRY( ptr, struct cached_format, entry ));
 }
 
 /* get the clipboard locale stored in the CF_LOCALE format */
@@ -490,7 +576,7 @@ static HANDLE render_synthesized_enhmetafile( HANDLE data )
 }
 
 /* render a synthesized format */
-HANDLE render_synthesized_format( UINT format, UINT from )
+static HANDLE render_synthesized_format( UINT format, UINT from )
 {
     HANDLE data = GetClipboardData( from );
 
@@ -564,7 +650,132 @@ INT WINAPI GetClipboardFormatNameA( UINT format, LPSTR buffer, INT maxlen )
  */
 BOOL WINAPI OpenClipboard( HWND hwnd )
 {
-    return NtUserOpenClipboard( hwnd, 0 );
+    BOOL ret;
+    HWND owner;
+
+    TRACE( "%p\n", hwnd );
+
+    USER_Driver->pUpdateClipboard();
+
+    EnterCriticalSection( &clipboard_cs );
+
+    SERVER_START_REQ( open_clipboard )
+    {
+        req->window = wine_server_user_handle( hwnd );
+        ret = !wine_server_call_err( req );
+        owner = wine_server_ptr_handle( reply->owner );
+    }
+    SERVER_END_REQ;
+
+    if (ret && !WIN_IsCurrentProcess( owner )) invalidate_memory_formats();
+
+    LeaveCriticalSection( &clipboard_cs );
+    return ret;
+}
+
+
+/**************************************************************************
+ *		CloseClipboard (USER32.@)
+ */
+BOOL WINAPI CloseClipboard(void)
+{
+    HWND viewer = 0, owner = 0;
+    BOOL ret;
+
+    TRACE( "\n" );
+
+    SERVER_START_REQ( close_clipboard )
+    {
+        if ((ret = !wine_server_call_err( req )))
+        {
+            viewer = wine_server_ptr_handle( reply->viewer );
+            owner = wine_server_ptr_handle( reply->owner );
+        }
+    }
+    SERVER_END_REQ;
+
+    if (viewer) SendNotifyMessageW( viewer, WM_DRAWCLIPBOARD, (WPARAM)owner, 0 );
+    return ret;
+}
+
+
+/**************************************************************************
+ *		EmptyClipboard (USER32.@)
+ * Empties and acquires ownership of the clipboard
+ */
+BOOL WINAPI EmptyClipboard(void)
+{
+    BOOL ret;
+    HWND owner = NtUserGetClipboardOwner();
+
+    TRACE( "owner %p\n", owner );
+
+    if (owner) SendMessageTimeoutW( owner, WM_DESTROYCLIPBOARD, 0, 0, SMTO_ABORTIFHUNG, 5000, NULL );
+
+    EnterCriticalSection( &clipboard_cs );
+
+    SERVER_START_REQ( empty_clipboard )
+    {
+        ret = !wine_server_call_err( req );
+    }
+    SERVER_END_REQ;
+
+    if (ret) free_cached_formats();
+
+    LeaveCriticalSection( &clipboard_cs );
+    return ret;
+}
+
+
+/**************************************************************************
+ *		SetClipboardViewer (USER32.@)
+ */
+HWND WINAPI SetClipboardViewer( HWND hwnd )
+{
+    HWND prev = 0, owner = 0;
+
+    SERVER_START_REQ( set_clipboard_viewer )
+    {
+        req->viewer = wine_server_user_handle( hwnd );
+        if (!wine_server_call_err( req ))
+        {
+            prev = wine_server_ptr_handle( reply->old_viewer );
+            owner = wine_server_ptr_handle( reply->owner );
+        }
+    }
+    SERVER_END_REQ;
+
+    if (hwnd) SendNotifyMessageW( hwnd, WM_DRAWCLIPBOARD, (WPARAM)owner, 0 );
+
+    TRACE( "%p returning %p\n", hwnd, prev );
+    return prev;
+}
+
+
+/**************************************************************************
+ *              ChangeClipboardChain (USER32.@)
+ */
+BOOL WINAPI ChangeClipboardChain( HWND hwnd, HWND next )
+{
+    NTSTATUS status;
+    HWND viewer;
+
+    if (!hwnd) return FALSE;
+
+    SERVER_START_REQ( set_clipboard_viewer )
+    {
+        req->viewer = wine_server_user_handle( next );
+        req->previous = wine_server_user_handle( hwnd );
+        status = wine_server_call( req );
+        viewer = wine_server_ptr_handle( reply->old_viewer );
+    }
+    SERVER_END_REQ;
+
+    if (status == STATUS_PENDING)
+        return !SendMessageW( viewer, WM_CHANGECBCHAIN, (WPARAM)hwnd, (LPARAM)next );
+
+    if (status) SetLastError( RtlNtStatusToDosError( status ));
+    return !status;
 }
 
 
@@ -573,28 +784,55 @@ BOOL WINAPI OpenClipboard( HWND hwnd )
  */
 HANDLE WINAPI SetClipboardData( UINT format, HANDLE data )
 {
-    struct set_clipboard_params params = { .size = 0 };
-    HANDLE handle = data;
-    NTSTATUS status;
+    struct cached_format *cache = NULL;
+    void *ptr = NULL;
+    data_size_t size = 0;
+    HANDLE handle = data, retval = 0;
+    NTSTATUS status = STATUS_SUCCESS;
 
     TRACE( "%s %p\n", debugstr_format( format ), data );
 
     if (data)
     {
-        if (!(handle = marshal_data( format, data, &params.size ))) return 0;
-        if (!(params.data = GlobalLock( handle ))) return 0;
+        if (!(handle = marshal_data( format, data, &size ))) return 0;
+        if (!(ptr = GlobalLock( handle ))) goto done;
+        if (!(cache = HeapAlloc( GetProcessHeap(), 0, sizeof(*cache) ))) goto done;
+        cache->format = format;
+        cache->handle = data;
     }
 
-    status = NtUserSetClipboardData( format, data, &params );
+    EnterCriticalSection( &clipboard_cs );
 
-    if (params.data) GlobalUnlock( handle );
-    if (handle != data) GlobalFree( handle );
-    if (status)
+    SERVER_START_REQ( set_clipboard_data )
     {
-        SetLastError( RtlNtStatusToDosError( status ));
-        return 0;
+        req->format = format;
+        req->lcid = GetUserDefaultLCID();
+        wine_server_add_data( req, ptr, size );
+        if (!(status = wine_server_call( req )))
+        {
+            if (cache) cache->seqno = reply->seqno;
+        }
     }
-    return data;
+    SERVER_END_REQ;
+
+    if (!status)
+    {
+        /* free the previous entry if any */
+        struct cached_format *prev;
+
+        if ((prev = get_cached_format( format ))) free_cached_data( prev );
+        if (cache) list_add_tail( &cached_formats, &cache->entry );
+        retval = data;
+    }
+    else HeapFree( GetProcessHeap(), 0, cache );
+
+    LeaveCriticalSection( &clipboard_cs );
+
+done:
+    if (ptr) GlobalUnlock( handle );
+    if (handle != data) GlobalFree( handle );
+    if (status) SetLastError( RtlNtStatusToDosError( status ));
+    return retval;
 }
 
 
@@ -603,7 +841,21 @@ HANDLE WINAPI SetClipboardData( UINT format, HANDLE data )
  */
 UINT WINAPI EnumClipboardFormats( UINT format )
 {
-    return NtUserEnumClipboardFormats( format );
+    UINT ret = 0;
+
+    SERVER_START_REQ( enum_clipboard_formats )
+    {
+        req->previous = format;
+        if (!wine_server_call_err( req ))
+        {
+            ret = reply->format;
+            SetLastError( ERROR_SUCCESS );
+        }
+    }
+    SERVER_END_REQ;
+
+    TRACE( "%s -> %s\n", debugstr_format( format ), debugstr_format( ret ));
+    return ret;
 }
 
 
@@ -612,34 +864,73 @@ UINT WINAPI EnumClipboardFormats( UINT format )
  */
 HANDLE WINAPI GetClipboardData( UINT format )
 {
-    struct get_clipboard_params params = { .data_size = 1024 };
-    HANDLE ret = 0;
-
-    EnterCriticalSection( &clipboard_cs );
+    struct cached_format *cache;
+    NTSTATUS status;
+    UINT from, data_seqno;
+    HWND owner;
+    HANDLE data;
+    UINT size = 1024;
+    BOOL render = TRUE;
 
-    while (params.data_size)
+    for (;;)
     {
-        params.size = params.data_size;
-        params.data_size = 0;
-        if (!(params.data = GlobalAlloc( GMEM_FIXED, params.size ))) break;
-        ret = NtUserGetClipboardData( format, &params );
-        if (ret) break;
-        if (params.data_size == ~0) /* needs unmarshaling */
+        if (!(data = GlobalAlloc( GMEM_FIXED, size ))) return 0;
+
+        EnterCriticalSection( &clipboard_cs );
+        cache = get_cached_format( format );
+
+        SERVER_START_REQ( get_clipboard_data )
         {
-            struct set_clipboard_params set_params = { .cache_only = TRUE, .seqno = params.seqno };
+            req->format = format;
+            req->render = render;
+            if (cache)
+            {
+                req->cached = 1;
+                req->seqno = cache->seqno;
+            }
+            wine_server_set_reply( req, data, size );
+            status = wine_server_call( req );
+            from = reply->from;
+            size = reply->total;
+            data_seqno = reply->seqno;
+            owner = wine_server_ptr_handle( reply->owner );
+        }
+        SERVER_END_REQ;
 
-            ret = unmarshal_data( format, params.data, params.size );
-            if (!NtUserSetClipboardData( format, ret, &set_params )) break;
+        if (!status && size)
+        {
+            data = cache_data( format, data, size, data_seqno, cache );
+            LeaveCriticalSection( &clipboard_cs );
+            TRACE( "%s returning %p\n", debugstr_format( format ), data );
+            return data;
+        }
+        LeaveCriticalSection( &clipboard_cs );
+        GlobalFree( data );
 
-            /* data changed, retry */
-            free_cached_data( format, ret );
-            ret = 0;
-            params.data_size = 1024;
-            continue;
+        if (status == STATUS_BUFFER_OVERFLOW) continue;  /* retry with the new size */
+        if (status == STATUS_OBJECT_NAME_NOT_FOUND) return 0; /* no such format */
+        if (status)
+        {
+            SetLastError( RtlNtStatusToDosError( status ));
+            TRACE( "%s error %08x\n", debugstr_format( format ), status );
+            return 0;
+        }
+        if (render)  /* try rendering it */
+        {
+            render = FALSE;
+            if (from)
+            {
+                render_synthesized_format( format, from );
+                continue;
+            }
+            else if (owner)
+            {
+                TRACE( "%s sending WM_RENDERFORMAT to %p\n", debugstr_format( format ), owner );
+                SendMessageW( owner, WM_RENDERFORMAT, format, 0 );
+                continue;
+            }
         }
-        GlobalFree( params.data );
+        TRACE( "%s returning 0\n", debugstr_format( format ));
+        return 0;
     }
-
-    LeaveCriticalSection( &clipboard_cs );
-    return ret;
 }
diff --git a/dlls/user32/controls.h b/dlls/user32/controls.h
index 1e5b1082d50..8438a7bd56b 100644
--- a/dlls/user32/controls.h
+++ b/dlls/user32/controls.h
@@ -69,6 +69,7 @@ struct wow_handlers16
     LRESULT (*mdiclient_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
     LRESULT (*scrollbar_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
     LRESULT (*static_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
+    DWORD   (*wait_message)(DWORD,const HANDLE*,DWORD,DWORD,DWORD);
     HWND    (*create_window)(CREATESTRUCTW*,LPCWSTR,HINSTANCE,BOOL);
     LRESULT (*call_window_proc)(HWND,UINT,WPARAM,LPARAM,LRESULT*,void*);
     LRESULT (*call_dialog_proc)(HWND,UINT,WPARAM,LPARAM,LRESULT*,void*);
@@ -83,6 +84,7 @@ struct wow_handlers32
     LRESULT (*mdiclient_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
     LRESULT (*scrollbar_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
     LRESULT (*static_proc)(HWND,UINT,WPARAM,LPARAM,BOOL);
+    DWORD   (*wait_message)(DWORD,const HANDLE*,DWORD,DWORD,DWORD);
     HWND    (*create_window)(CREATESTRUCTW*,LPCWSTR,HINSTANCE,BOOL);
     HWND    (*get_win_handle)(HWND);
     WNDPROC (*alloc_winproc)(WNDPROC,BOOL);
@@ -104,7 +106,9 @@ extern LRESULT StaticWndProc_common(HWND,UINT,WPARAM,LPARAM,BOOL) DECLSPEC_HIDDE
 struct tagCLASS;  /* opaque structure */
 struct tagWND;
 extern ATOM get_int_atom_value( UNICODE_STRING *name ) DECLSPEC_HIDDEN;
+extern void register_builtin_classes(void) DECLSPEC_HIDDEN;
 extern void register_desktop_class(void) DECLSPEC_HIDDEN;
+extern WNDPROC get_class_winproc( struct tagCLASS *class ) DECLSPEC_HIDDEN;
 
 /* defwnd proc */
 extern HBRUSH DEFWND_ControlColor( HDC hDC, UINT ctlType ) DECLSPEC_HIDDEN;
@@ -116,11 +120,11 @@ extern BOOL update_wallpaper( const WCHAR *wallpaper, const WCHAR *pattern ) DEC
 extern HWND MENU_IsMenuActive(void) DECLSPEC_HIDDEN;
 extern UINT MENU_GetMenuBarHeight( HWND hwnd, UINT menubarWidth,
                                      INT orgX, INT orgY ) DECLSPEC_HIDDEN;
+extern BOOL MENU_SetMenu(HWND, HMENU) DECLSPEC_HIDDEN;
 extern void MENU_TrackMouseMenuBar( HWND hwnd, INT ht, POINT pt ) DECLSPEC_HIDDEN;
 extern void MENU_TrackKbdMenuBar( HWND hwnd, UINT wParam, WCHAR wChar ) DECLSPEC_HIDDEN;
 extern UINT MENU_DrawMenuBar( HDC hDC, LPRECT lprect, HWND hwnd ) DECLSPEC_HIDDEN;
 extern void MENU_EndMenu(HWND) DECLSPEC_HIDDEN;
-extern HMENU MENU_GetSysMenu( HWND hWnd, HMENU hPopupMenu ) DECLSPEC_HIDDEN;
 
 /* nonclient area */
 extern LRESULT NC_HandleNCPaint( HWND hwnd , HRGN clip) DECLSPEC_HIDDEN;
diff --git a/dlls/user32/cursoricon.c b/dlls/user32/cursoricon.c
index 3e83ada3ee5..3c7ed7503d9 100644
--- a/dlls/user32/cursoricon.c
+++ b/dlls/user32/cursoricon.c
@@ -964,7 +964,7 @@ static HICON create_cursoricon_object( struct cursoricon_desc *desc, BOOL is_ico
     UNICODE_STRING res_str = { 0 };
     HICON handle;
 
-    if (!(handle = NtUserCreateCursorIcon( is_icon ))) return 0;
+    if (!(handle = UlongToHandle( NtUserCallOneParam( is_icon, NtUserCreateCursorIcon )))) return 0;
 
     if (module) LdrGetDllFullName( module, &module_name );
 
@@ -1610,7 +1610,7 @@ BOOL WINAPI DrawIcon( HDC hdc, INT x, INT y, HICON hIcon )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH GetClipCursor( RECT *rect )
 {
-    return NtUserGetClipCursor( rect );
+    return NtUserCallOneParam( (UINT_PTR)rect, NtUserGetClipCursor );
 }
 
 
diff --git a/dlls/user32/defdlg.c b/dlls/user32/defdlg.c
index e330cf6603d..3c7a8a78855 100644
--- a/dlls/user32/defdlg.c
+++ b/dlls/user32/defdlg.c
@@ -240,7 +240,7 @@ static LRESULT DEFDLG_Proc( HWND hwnd, UINT msg, WPARAM wParam,
                 WND *wndPtr;
 
                 if (dlgInfo->hUserFont) DeleteObject( dlgInfo->hUserFont );
-                if (dlgInfo->hMenu) NtUserDestroyMenu( dlgInfo->hMenu );
+                if (dlgInfo->hMenu) DestroyMenu( dlgInfo->hMenu );
                 HeapFree( GetProcessHeap(), 0, dlgInfo );
 
                 wndPtr = WIN_GetPtr( hwnd );
diff --git a/dlls/user32/defwnd.c b/dlls/user32/defwnd.c
index c4263edac93..bd1928412e0 100644
--- a/dlls/user32/defwnd.c
+++ b/dlls/user32/defwnd.c
@@ -74,6 +74,89 @@ static void DEFWND_HandleWindowPosChanged( HWND hwnd, const WINDOWPOS *winpos )
 }
 
 
+/***********************************************************************
+ *           DEFWND_SetTextA
+ *
+ * Set the window text.
+ */
+static LRESULT DEFWND_SetTextA( HWND hwnd, LPCSTR text )
+{
+    int count;
+    WCHAR *textW;
+    WND *wndPtr;
+
+    /* check for string, as static icons, bitmaps (SS_ICON, SS_BITMAP)
+     * may have child window IDs instead of window name */
+    if (text && IS_INTRESOURCE(text))
+        return 0;
+
+    if (!text) text = "";
+    count = MultiByteToWideChar( CP_ACP, 0, text, -1, NULL, 0 );
+
+    if (!(wndPtr = WIN_GetPtr( hwnd ))) return 0;
+    if ((textW = HeapAlloc(GetProcessHeap(), 0, count * sizeof(WCHAR))))
+    {
+        HeapFree(GetProcessHeap(), 0, wndPtr->text);
+        wndPtr->text = textW;
+        MultiByteToWideChar( CP_ACP, 0, text, -1, textW, count );
+        SERVER_START_REQ( set_window_text )
+        {
+            req->handle = wine_server_user_handle( hwnd );
+            wine_server_add_data( req, textW, (count-1) * sizeof(WCHAR) );
+            wine_server_call( req );
+        }
+        SERVER_END_REQ;
+    }
+    else
+        ERR("Not enough memory for window text\n");
+    WIN_ReleasePtr( wndPtr );
+
+    USER_Driver->pSetWindowText( hwnd, textW );
+
+    return 1;
+}
+
+/***********************************************************************
+ *           DEFWND_SetTextW
+ *
+ * Set the window text.
+ */
+static LRESULT DEFWND_SetTextW( HWND hwnd, LPCWSTR text )
+{
+    WND *wndPtr;
+    int count;
+
+    /* check for string, as static icons, bitmaps (SS_ICON, SS_BITMAP)
+     * may have child window IDs instead of window name */
+    if (text && IS_INTRESOURCE(text))
+        return 0;
+
+    if (!text) text = L"";
+    count = lstrlenW(text) + 1;
+
+    if (!(wndPtr = WIN_GetPtr( hwnd ))) return 0;
+    HeapFree(GetProcessHeap(), 0, wndPtr->text);
+    if ((wndPtr->text = HeapAlloc(GetProcessHeap(), 0, count * sizeof(WCHAR))))
+    {
+        lstrcpyW( wndPtr->text, text );
+        SERVER_START_REQ( set_window_text )
+        {
+            req->handle = wine_server_user_handle( hwnd );
+            wine_server_add_data( req, wndPtr->text, (count-1) * sizeof(WCHAR) );
+            wine_server_call( req );
+        }
+        SERVER_END_REQ;
+    }
+    else
+        ERR("Not enough memory for window text\n");
+    text = wndPtr->text;
+    WIN_ReleasePtr( wndPtr );
+
+    USER_Driver->pSetWindowText( hwnd, text );
+
+    return 1;
+}
+
 /***********************************************************************
  *           DEFWND_ControlColor
  *
@@ -180,6 +263,9 @@ static LRESULT DEFWND_DefWinProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lPa
         NC_HandleNCCalcSize( hwnd, wParam, (RECT *)lParam );
         break;
 
+    case WM_WINDOWPOSCHANGING:
+        return WINPOS_HandleWindowPosChanging( hwnd, (WINDOWPOS *)lParam );
+
     case WM_WINDOWPOSCHANGED:
         DEFWND_HandleWindowPosChanged( hwnd, (const WINDOWPOS *)lParam );
         break;
@@ -243,26 +329,125 @@ static LRESULT DEFWND_DefWinProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lPa
 
             /* Track system popup if click was in the caption area. */
             if (hitcode==HTCAPTION || hitcode==HTSYSMENU)
-               TrackPopupMenu( NtUserGetSystemMenu(hwnd, FALSE),
+               TrackPopupMenu(GetSystemMenu(hwnd, FALSE),
                                TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
-                               pt.x, pt.y, 0, hwnd, NULL );
+                               pt.x, pt.y, 0, hwnd, NULL);
         }
         break;
 
     case WM_POPUPSYSTEMMENU:
         /* This is an undocumented message used by the windows taskbar to
            display the system menu of windows that belong to other processes. */
-        TrackPopupMenu( NtUserGetSystemMenu(hwnd, FALSE), TPM_LEFTBUTTON|TPM_RIGHTBUTTON,
+        TrackPopupMenu( GetSystemMenu(hwnd, FALSE), TPM_LEFTBUTTON|TPM_RIGHTBUTTON,
                         (short)LOWORD(lParam), (short)HIWORD(lParam), 0, hwnd, NULL );
         return 0;
 
     case WM_NCACTIVATE:
         return NC_HandleNCActivate( hwnd, wParam, lParam );
 
+    case WM_NCDESTROY:
+        {
+            WND *wndPtr = WIN_GetPtr( hwnd );
+            if (!wndPtr) return 0;
+            HeapFree( GetProcessHeap(), 0, wndPtr->text );
+            wndPtr->text = NULL;
+            HeapFree( GetProcessHeap(), 0, wndPtr->pScroll );
+            wndPtr->pScroll = NULL;
+            WIN_ReleasePtr( wndPtr );
+            return 0;
+        }
+
     case WM_PRINT:
         DEFWND_Print(hwnd, (HDC)wParam, lParam);
         return 0;
 
+    case WM_PAINTICON:
+    case WM_PAINT:
+        {
+            PAINTSTRUCT ps;
+            HDC hdc = NtUserBeginPaint( hwnd, &ps );
+            if( hdc )
+            {
+              HICON hIcon;
+              if (IsIconic(hwnd) && ((hIcon = (HICON)GetClassLongPtrW( hwnd, GCLP_HICON))) )
+              {
+                  RECT rc;
+                  int x, y;
+
+                  GetClientRect( hwnd, &rc );
+                  x = (rc.right - rc.left - GetSystemMetrics(SM_CXICON))/2;
+                  y = (rc.bottom - rc.top - GetSystemMetrics(SM_CYICON))/2;
+                  TRACE("Painting class icon: vis rect=(%s)\n",
+                        wine_dbgstr_rect(&ps.rcPaint));
+                  DrawIcon( hdc, x, y, hIcon );
+              }
+              NtUserEndPaint( hwnd, &ps );
+            }
+            return 0;
+        }
+
+    case WM_SYNCPAINT:
+        NtUserRedrawWindow ( hwnd, NULL, 0, RDW_ERASENOW | RDW_ERASE | RDW_ALLCHILDREN );
+        return 0;
+
+    case WM_SETREDRAW:
+        if (wParam) WIN_SetStyle( hwnd, WS_VISIBLE, 0 );
+        else
+        {
+            NtUserRedrawWindow( hwnd, NULL, 0, RDW_ALLCHILDREN | RDW_VALIDATE );
+            WIN_SetStyle( hwnd, 0, WS_VISIBLE );
+        }
+        return 0;
+
+    case WM_CLOSE:
+        NtUserDestroyWindow( hwnd );
+        return 0;
+
+    case WM_MOUSEACTIVATE:
+        if (GetWindowLongW( hwnd, GWL_STYLE ) & WS_CHILD)
+        {
+            LONG ret = SendMessageW( GetParent(hwnd), WM_MOUSEACTIVATE, wParam, lParam );
+            if (ret) return ret;
+        }
+
+        /* Caption clicks are handled by NC_HandleNCLButtonDown() */
+        return ( HIWORD(lParam) == WM_LBUTTONDOWN && LOWORD(lParam) == HTCAPTION ? MA_NOACTIVATE : MA_ACTIVATE );
+
+    case WM_ACTIVATE:
+        /* The default action in Windows is to set the keyboard focus to
+         * the window, if it's being activated and not minimized */
+        if (LOWORD(wParam) != WA_INACTIVE) {
+            if (!IsIconic(hwnd)) NtUserSetFocus( hwnd );
+        }
+        break;
+
+    case WM_MOUSEWHEEL:
+        if (GetWindowLongW( hwnd, GWL_STYLE ) & WS_CHILD)
+            return SendMessageW( GetParent(hwnd), WM_MOUSEWHEEL, wParam, lParam );
+        break;
+
+    case WM_ERASEBKGND:
+    case WM_ICONERASEBKGND:
+        {
+            RECT rect;
+            HDC hdc = (HDC)wParam;
+            HBRUSH hbr = (HBRUSH)GetClassLongPtrW( hwnd, GCLP_HBRBACKGROUND );
+            if (!hbr) return 0;
+
+            if (GetClassLongW( hwnd, GCL_STYLE ) & CS_PARENTDC)
+            {
+                /* can't use GetClipBox with a parent DC or we fill the whole parent */
+                GetClientRect( hwnd, &rect );
+                DPtoLP( hdc, (LPPOINT)&rect, 2 );
+            }
+            else GetClipBox( hdc, &rect );
+            FillRect( hdc, &rect, hbr );
+            return 1;
+        }
+
+    case WM_GETDLGCODE:
+        return 0;
+
     case WM_CTLCOLORMSGBOX:
     case WM_CTLCOLOREDIT:
     case WM_CTLCOLORLISTBOX:
@@ -424,11 +609,77 @@ static LRESULT DEFWND_DefWinProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lPa
 
     case WM_SETICON:
         {
-            LRESULT res =  NtUserMessageCall( hwnd, msg, wParam, lParam,
-                                              0, NtUserDefWindowProc, FALSE );
+            HICON ret;
+            WND *wndPtr = WIN_GetPtr( hwnd );
+
+            switch(wParam)
+            {
+            case ICON_SMALL:
+                ret = wndPtr->hIconSmall;
+                if (ret && !lParam && wndPtr->hIcon)
+                {
+                    wndPtr->hIconSmall2 = CopyImage( wndPtr->hIcon, IMAGE_ICON,
+                                                     GetSystemMetrics( SM_CXSMICON ),
+                                                     GetSystemMetrics( SM_CYSMICON ), 0 );
+                }
+                else if (lParam && wndPtr->hIconSmall2)
+                {
+                    DestroyIcon( wndPtr->hIconSmall2 );
+                    wndPtr->hIconSmall2 = NULL;
+                }
+                wndPtr->hIconSmall = (HICON)lParam;
+                break;
+            case ICON_BIG:
+                ret = wndPtr->hIcon;
+                if (wndPtr->hIconSmall2)
+                {
+                    DestroyIcon( wndPtr->hIconSmall2 );
+                    wndPtr->hIconSmall2 = NULL;
+                }
+                if (lParam && !wndPtr->hIconSmall)
+                {
+                    wndPtr->hIconSmall2 = CopyImage( (HICON)lParam, IMAGE_ICON,
+                                                     GetSystemMetrics( SM_CXSMICON ),
+                                                     GetSystemMetrics( SM_CYSMICON ), 0 );
+                }
+                wndPtr->hIcon = (HICON)lParam;
+                break;
+            default:
+                ret = 0;
+                break;
+            }
+            WIN_ReleasePtr( wndPtr );
+
+            USER_Driver->pSetWindowIcon( hwnd, wParam, (HICON)lParam );
+
             if( (GetWindowLongW( hwnd, GWL_STYLE ) & WS_CAPTION) == WS_CAPTION )
                 NC_HandleNCPaint( hwnd , (HRGN)1 );  /* Repaint caption */
-            return res;
+
+            return (LRESULT)ret;
+        }
+
+    case WM_GETICON:
+        {
+            HICON ret;
+            WND *wndPtr = WIN_GetPtr( hwnd );
+
+            switch(wParam)
+            {
+            case ICON_SMALL:
+                ret = wndPtr->hIconSmall;
+                break;
+            case ICON_BIG:
+                ret = wndPtr->hIcon;
+                break;
+            case ICON_SMALL2:
+                ret = wndPtr->hIconSmall ? wndPtr->hIconSmall : wndPtr->hIconSmall2;
+                break;
+            default:
+                ret = 0;
+                break;
+            }
+            WIN_ReleasePtr( wndPtr );
+            return (LRESULT)ret;
         }
 
     case WM_HELP:
@@ -497,9 +748,6 @@ static LRESULT DEFWND_DefWinProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lPa
             break;
         }
 
-    default:
-        return NtUserMessageCall( hwnd, msg, wParam, lParam, 0, NtUserDefWindowProc, FALSE );
-
     }
 
     return 0;
@@ -554,7 +802,8 @@ LRESULT WINAPI DefWindowProcA( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam
         {
             CREATESTRUCTA *cs = (CREATESTRUCTA *)lParam;
 
-            result = NtUserMessageCall( hwnd, msg, wParam, lParam, 0, NtUserDefWindowProc, TRUE );
+            DEFWND_SetTextA( hwnd, cs->lpszName );
+            result = 1;
 
             if(cs->style & (WS_HSCROLL | WS_VSCROLL))
             {
@@ -589,9 +838,11 @@ LRESULT WINAPI DefWindowProcA( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam
         break;
 
     case WM_SETTEXT:
-        result = NtUserMessageCall( hwnd, msg, wParam, lParam, 0, NtUserDefWindowProc, TRUE );
-        if (result && (GetWindowLongW( hwnd, GWL_STYLE ) & WS_CAPTION) == WS_CAPTION)
+        if (!DEFWND_SetTextA( hwnd, (LPCSTR)lParam ))
+            break;
+        if( (GetWindowLongW( hwnd, GWL_STYLE ) & WS_CAPTION) == WS_CAPTION )
             NC_HandleNCPaint( hwnd , (HRGN)1 );  /* Repaint caption */
+        result = 1; /* success. FIXME: check text length */
         break;
 
     case WM_IME_CHAR:
@@ -736,7 +987,8 @@ LRESULT WINAPI DefWindowProcW(
         {
             CREATESTRUCTW *cs = (CREATESTRUCTW *)lParam;
 
-            result = NtUserMessageCall( hwnd, msg, wParam, lParam, 0, NtUserDefWindowProc, FALSE );
+            DEFWND_SetTextW( hwnd, cs->lpszName );
+            result = 1;
 
             if(cs->style & (WS_HSCROLL | WS_VSCROLL))
             {
@@ -768,9 +1020,11 @@ LRESULT WINAPI DefWindowProcW(
         break;
 
     case WM_SETTEXT:
-        result = NtUserMessageCall( hwnd, msg, wParam, lParam, 0, NtUserDefWindowProc, FALSE );
-        if (result && (GetWindowLongW( hwnd, GWL_STYLE ) & WS_CAPTION) == WS_CAPTION)
+        if (!DEFWND_SetTextW( hwnd, (LPCWSTR)lParam ))
+            break;
+        if( (GetWindowLongW( hwnd, GWL_STYLE ) & WS_CAPTION) == WS_CAPTION )
             NC_HandleNCPaint( hwnd , (HRGN)1 );  /* Repaint caption */
+        result = 1; /* success. FIXME: check text length */
         break;
 
     case WM_IME_CHAR:
diff --git a/dlls/user32/desktop.c b/dlls/user32/desktop.c
index f2905b0efac..9d1484fdcbb 100644
--- a/dlls/user32/desktop.c
+++ b/dlls/user32/desktop.c
@@ -95,14 +95,30 @@ LRESULT WINAPI DesktopWndProc( HWND hwnd, UINT message, WPARAM wParam, LPARAM lP
     switch (message)
     {
     case WM_NCCREATE:
-    case WM_NCCALCSIZE:
-    case WM_PARENTNOTIFY:
-        return NtUserMessageCall( hwnd, message, wParam, lParam, 0, NtUserDesktopWindowProc, FALSE );
+    {
+        CREATESTRUCTW *cs = (CREATESTRUCTW *)lParam;
+        const GUID *guid = cs->lpCreateParams;
+
+        if (guid)
+        {
+            ATOM atom;
+            WCHAR buffer[37];
 
+            if (NtUserGetAncestor( hwnd, GA_PARENT )) return FALSE;  /* refuse to create non-desktop window */
+
+            swprintf( buffer, ARRAY_SIZE(buffer), L"%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
+                      guid->Data1, guid->Data2, guid->Data3,
+                      guid->Data4[0], guid->Data4[1], guid->Data4[2], guid->Data4[3],
+                      guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7] );
+            atom = GlobalAddAtomW( buffer );
+            SetPropW( hwnd, L"__wine_display_device_guid", ULongToHandle( atom ) );
+        }
+        return TRUE;
+    }
+    case WM_NCCALCSIZE:
+        return 0;
     default:
-        if (message < WM_USER)
-            return DefWindowProcW( hwnd, message, wParam, lParam );
-        return NtUserMessageCall( hwnd, message, wParam, lParam, 0, NtUserDesktopWindowProc, FALSE );
+        return DefWindowProcW( hwnd, message, wParam, lParam );
     }
 }
 
diff --git a/dlls/user32/dialog.c b/dlls/user32/dialog.c
index 66000995861..167c9b41df6 100644
--- a/dlls/user32/dialog.c
+++ b/dlls/user32/dialog.c
@@ -639,7 +639,7 @@ static HWND DIALOG_CreateIndirect( HINSTANCE hInst, LPCVOID dlgTemplate,
     if (!hwnd)
     {
         if (hUserFont) DeleteObject( hUserFont );
-        if (hMenu) NtUserDestroyMenu( hMenu );
+        if (hMenu) DestroyMenu( hMenu );
         if (disabled_owner) EnableWindow( disabled_owner, TRUE );
         return 0;
     }
@@ -1164,7 +1164,7 @@ BOOL WINAPI IsDialogMessageW( HWND hwndDlg, LPMSG msg )
     if (!IsWindow( hwndDlg ))
         return FALSE;
 
-    if (NtUserCallMsgFilter( msg, MSGF_DIALOGBOX )) return TRUE;
+    if (CallMsgFilterW( msg, MSGF_DIALOGBOX )) return TRUE;
 
     hwndDlg = WIN_GetFullHandle( hwndDlg );
     if (is_desktop_window(hwndDlg)) return FALSE;
diff --git a/dlls/user32/driver.c b/dlls/user32/driver.c
new file mode 100644
index 00000000000..25ed33ff073
--- /dev/null
+++ b/dlls/user32/driver.c
@@ -0,0 +1,234 @@
+/*
+ * USER driver support
+ *
+ * Copyright 2000, 2005 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <wchar.h>
+
+#include "user_private.h"
+#include "winnls.h"
+#include "wine/debug.h"
+#include "controls.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(user);
+
+static struct user_driver_funcs null_driver, lazy_load_driver;
+
+const struct user_driver_funcs *USER_Driver = &lazy_load_driver;
+
+/* load the graphics driver */
+static const struct user_driver_funcs *load_driver(void)
+{
+    wait_graphics_driver_ready();
+    if (USER_Driver == &lazy_load_driver)
+    {
+        static struct user_driver_funcs empty_funcs;
+        WARN( "failed to load the display driver, falling back to null driver\n" );
+        __wine_set_user_driver( &empty_funcs, WINE_GDI_DRIVER_VERSION );
+    }
+
+    return USER_Driver;
+}
+
+/* unload the graphics driver on process exit */
+void USER_unload_driver(void)
+{
+    struct user_driver_funcs *prev;
+    __wine_set_display_driver( &null_driver, WINE_GDI_DRIVER_VERSION );
+    /* make sure we don't try to call the driver after it has been detached */
+    prev = InterlockedExchangePointer( (void **)&USER_Driver, &null_driver );
+    if (prev != &lazy_load_driver && prev != &null_driver)
+        HeapFree( GetProcessHeap(), 0, prev );
+}
+
+
+/**********************************************************************
+ * Null user driver
+ *
+ * These are fallbacks for entry points that are not implemented in the real driver.
+ */
+
+static BOOL CDECL nulldrv_SetCursorPos( INT x, INT y )
+{
+    return TRUE;
+}
+
+static void CDECL nulldrv_UpdateClipboard(void)
+{
+}
+
+static BOOL CDECL nulldrv_CreateWindow( HWND hwnd )
+{
+    return TRUE;
+}
+
+static DWORD CDECL nulldrv_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles, DWORD timeout,
+                                                        DWORD mask, DWORD flags )
+{
+    if (!count && !timeout) return WAIT_TIMEOUT;
+    return WaitForMultipleObjectsEx( count, handles, flags & MWMO_WAITALL,
+                                     timeout, flags & MWMO_ALERTABLE );
+}
+
+static void CDECL nulldrv_SetWindowIcon( HWND hwnd, UINT type, HICON icon )
+{
+}
+
+static void CDECL nulldrv_SetWindowText( HWND hwnd, LPCWSTR text )
+{
+}
+
+static LRESULT CDECL nulldrv_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam )
+{
+    return -1;
+}
+
+static BOOL CDECL nulldrv_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                             const RECT *window_rect, const RECT *client_rect,
+                                             RECT *visible_rect, struct window_surface **surface )
+{
+    return FALSE;
+}
+
+static void CDECL nulldrv_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                            const RECT *window_rect, const RECT *client_rect,
+                                            const RECT *visible_rect, const RECT *valid_rects,
+                                            struct window_surface *surface )
+{
+}
+
+
+/**********************************************************************
+ * Lazy loading user driver
+ *
+ * Initial driver used before another driver is loaded.
+ * Each entry point simply loads the real driver and chains to it.
+ */
+
+static BOOL CDECL loaderdrv_SetCursorPos( INT x, INT y )
+{
+    return load_driver()->pSetCursorPos( x, y );
+}
+
+static void CDECL loaderdrv_UpdateClipboard(void)
+{
+    load_driver()->pUpdateClipboard();
+}
+
+static BOOL CDECL loaderdrv_CreateWindow( HWND hwnd )
+{
+    return load_driver()->pCreateWindow( hwnd );
+}
+
+static struct user_driver_funcs lazy_load_driver =
+{
+    { NULL },
+    /* keyboard functions */
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    /* cursor/icon functions */
+    NULL,
+    NULL,
+    NULL,
+    loaderdrv_SetCursorPos,
+    NULL,
+    /* clipboard functions */
+    loaderdrv_UpdateClipboard,
+    /* display modes */
+    NULL,
+    NULL,
+    NULL,
+    /* windowing functions */
+    NULL,
+    loaderdrv_CreateWindow,
+    NULL,
+    NULL,
+    NULL,
+    nulldrv_MsgWaitForMultipleObjectsEx,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    nulldrv_SetWindowIcon,
+    NULL,
+    nulldrv_SetWindowText,
+    NULL,
+    nulldrv_SysCommand,
+    NULL,
+    NULL,
+    nulldrv_WindowPosChanging,
+    nulldrv_WindowPosChanged,
+    /* system parameters */
+    NULL,
+    /* vulkan support */
+    NULL,
+    /* opengl support */
+    NULL,
+    /* thread management */
+    NULL,
+};
+
+void CDECL __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT version )
+{
+    struct user_driver_funcs *driver, *prev;
+
+    if (version != WINE_GDI_DRIVER_VERSION)
+    {
+        ERR( "version mismatch, driver wants %u but user32 has %u\n", version, WINE_GDI_DRIVER_VERSION );
+        return;
+    }
+
+    driver = HeapAlloc( GetProcessHeap(), 0, sizeof(*driver) );
+    *driver = *funcs;
+
+#define SET_USER_FUNC(name) \
+    do { if (!driver->p##name) driver->p##name = nulldrv_##name; } while(0)
+
+    SET_USER_FUNC(SetCursorPos);
+    SET_USER_FUNC(UpdateClipboard);
+    SET_USER_FUNC(CreateWindow);
+    SET_USER_FUNC(MsgWaitForMultipleObjectsEx);
+    SET_USER_FUNC(SetWindowIcon);
+    SET_USER_FUNC(SetWindowText);
+    SET_USER_FUNC(SysCommand);
+    SET_USER_FUNC(WindowPosChanging);
+    SET_USER_FUNC(WindowPosChanged);
+#undef SET_USER_FUNC
+
+    prev = InterlockedCompareExchangePointer( (void **)&USER_Driver, driver, &lazy_load_driver );
+    if (prev != &lazy_load_driver)
+    {
+        /* another thread beat us to it */
+        HeapFree( GetProcessHeap(), 0, driver );
+        driver = prev;
+    }
+
+    __wine_set_display_driver( driver, version );
+}
diff --git a/dlls/user32/edit.c b/dlls/user32/edit.c
index b7eaf2b9ddf..c1a916c341e 100644
--- a/dlls/user32/edit.c
+++ b/dlls/user32/edit.c
@@ -3107,7 +3107,7 @@ static void EDIT_WM_Paste(EDITSTATE *es)
             /* clear selected text in password edit box even with empty clipboard */
             EDIT_EM_ReplaceSel(es, TRUE, NULL, 0, TRUE, TRUE);
         }
-	NtUserCloseClipboard();
+	CloseClipboard();
 }
 
 
@@ -3134,9 +3134,9 @@ static void EDIT_WM_Copy(EDITSTATE *es)
 	TRACE("%s\n", debugstr_w(dst));
 	GlobalUnlock(hdst);
 	OpenClipboard(es->hwndSelf);
-	NtUserEmptyClipboard();
+	EmptyClipboard();
 	SetClipboardData(CF_UNICODETEXT, hdst);
-	NtUserCloseClipboard();
+	CloseClipboard();
 }
 
 
@@ -3302,29 +3302,22 @@ static void EDIT_WM_ContextMenu(EDITSTATE *es, INT x, INT y)
 	HMENU popup = GetSubMenu(menu, 0);
 	UINT start = es->selection_start;
 	UINT end = es->selection_end;
-        BOOL enabled;
 	UINT cmd;
 
 	ORDER_UINT(start, end);
 
-        /* undo */
-        enabled = EDIT_EM_CanUndo(es) && !(es->style & ES_READONLY);
-        NtUserEnableMenuItem( popup, 0, MF_BYPOSITION | (enabled ? MF_ENABLED : MF_GRAYED) );
-        /* cut */
-        enabled = (end - start) && !(es->style & ES_PASSWORD) && !(es->style & ES_READONLY);
-        NtUserEnableMenuItem( popup, 2, MF_BYPOSITION | (enabled ? MF_ENABLED : MF_GRAYED) );
-        /* copy */
-        enabled = (end - start) && !(es->style & ES_PASSWORD);
-        NtUserEnableMenuItem( popup, 3, MF_BYPOSITION | (enabled ? MF_ENABLED : MF_GRAYED) );
-        /* paste */
-        enabled = NtUserIsClipboardFormatAvailable(CF_UNICODETEXT) && !(es->style & ES_READONLY);
-        NtUserEnableMenuItem( popup, 4, MF_BYPOSITION | (enabled ? MF_ENABLED : MF_GRAYED) );
-        /* delete */
-        enabled = (end - start) && !(es->style & ES_READONLY);
-        NtUserEnableMenuItem( popup, 5, MF_BYPOSITION | (enabled ? MF_ENABLED : MF_GRAYED) );
-        /* select all */
-        enabled = start || end != get_text_length(es);
-        NtUserEnableMenuItem( popup, 7, MF_BYPOSITION | (enabled ? MF_ENABLED : MF_GRAYED) );
+	/* undo */
+	EnableMenuItem(popup, 0, MF_BYPOSITION | (EDIT_EM_CanUndo(es) && !(es->style & ES_READONLY) ? MF_ENABLED : MF_GRAYED));
+	/* cut */
+	EnableMenuItem(popup, 2, MF_BYPOSITION | ((end - start) && !(es->style & ES_PASSWORD) && !(es->style & ES_READONLY) ? MF_ENABLED : MF_GRAYED));
+	/* copy */
+	EnableMenuItem(popup, 3, MF_BYPOSITION | ((end - start) && !(es->style & ES_PASSWORD) ? MF_ENABLED : MF_GRAYED));
+	/* paste */
+	EnableMenuItem(popup, 4, MF_BYPOSITION | (NtUserIsClipboardFormatAvailable(CF_UNICODETEXT) && !(es->style & ES_READONLY) ? MF_ENABLED : MF_GRAYED));
+	/* delete */
+	EnableMenuItem(popup, 5, MF_BYPOSITION | ((end - start) && !(es->style & ES_READONLY) ? MF_ENABLED : MF_GRAYED));
+	/* select all */
+	EnableMenuItem(popup, 7, MF_BYPOSITION | (start || (end != get_text_length(es)) ? MF_ENABLED : MF_GRAYED));
 
         if (x == -1 && y == -1) /* passed via VK_APPS press/release */
         {
@@ -3344,7 +3337,7 @@ static void EDIT_WM_ContextMenu(EDITSTATE *es, INT x, INT y)
 	if (cmd)
 	    EDIT_ContextMenuCommand(es, cmd);
 
-        NtUserDestroyMenu(menu);
+	DestroyMenu(menu);
 }
 
 
@@ -3807,10 +3800,10 @@ static void EDIT_WM_SetFocus(EDITSTATE *es)
             NtUserReleaseDC( es->hwndSelf, hdc );
         }
 
-        NtUserCreateCaret( es->hwndSelf, 0, 1, es->line_height );
+	CreateCaret(es->hwndSelf, 0, 1, es->line_height);
 	EDIT_SetCaretPos(es, es->selection_end,
 			 es->flags & EF_AFTER_WRAP);
-        NtUserShowCaret( es->hwndSelf );
+	ShowCaret(es->hwndSelf);
 	EDIT_NOTIFY_PARENT(es, EN_SETFOCUS);
 }
 
@@ -3890,10 +3883,10 @@ static void EDIT_WM_SetFont(EDITSTATE *es, HFONT font, BOOL redraw)
 		EDIT_UpdateText(es, NULL, TRUE);
 	if (es->flags & EF_FOCUSED) {
 		DestroyCaret();
-		NtUserCreateCaret( es->hwndSelf, 0, 1, es->line_height );
+		CreateCaret(es->hwndSelf, 0, 1, es->line_height);
 		EDIT_SetCaretPos(es, es->selection_end,
 				 es->flags & EF_AFTER_WRAP);
-		NtUserShowCaret( es->hwndSelf );
+		ShowCaret(es->hwndSelf);
 	}
 }
 
diff --git a/dlls/user32/focus.c b/dlls/user32/focus.c
index c494adce5a6..ff41cf716a1 100644
--- a/dlls/user32/focus.c
+++ b/dlls/user32/focus.c
@@ -39,7 +39,7 @@
  */
 BOOL FOCUS_MouseActivate( HWND hwnd )
 {
-    return NtUserSetForegroundWindow( hwnd, TRUE );
+    return NtUserCallHwndParam( hwnd, TRUE, NtUserSetForegroundWindow );
 }
 
 
@@ -48,7 +48,7 @@ BOOL FOCUS_MouseActivate( HWND hwnd )
  */
 BOOL WINAPI SetForegroundWindow( HWND hwnd )
 {
-    return NtUserSetForegroundWindow( hwnd, FALSE );
+    return NtUserCallHwndParam( hwnd, FALSE, NtUserSetForegroundWindow );
 }
 
 
diff --git a/dlls/user32/hook.c b/dlls/user32/hook.c
index 357a7fdb25a..12ac612e68d 100644
--- a/dlls/user32/hook.c
+++ b/dlls/user32/hook.c
@@ -379,7 +379,27 @@ HHOOK WINAPI SetWindowsHookExW( INT id, HOOKPROC proc, HINSTANCE inst, DWORD tid
  */
 BOOL WINAPI UnhookWindowsHook( INT id, HOOKPROC proc )
 {
-    return NtUserUnhookWindowsHook( id, proc );
+    return NtUserCallTwoParam( id, (UINT_PTR)proc, NtUserUnhookWindowsHook );
+}
+
+
+/***********************************************************************
+ *		CallMsgFilterA (USER32.@)
+ */
+BOOL WINAPI CallMsgFilterA( LPMSG msg, INT code )
+{
+    if (HOOK_CallHooks( WH_SYSMSGFILTER, code, 0, (LPARAM)msg, FALSE )) return TRUE;
+    return HOOK_CallHooks( WH_MSGFILTER, code, 0, (LPARAM)msg, FALSE );
+}
+
+
+/***********************************************************************
+ *		CallMsgFilterW (USER32.@)
+ */
+BOOL WINAPI CallMsgFilterW( LPMSG msg, INT code )
+{
+    if (HOOK_CallHooks( WH_SYSMSGFILTER, code, 0, (LPARAM)msg, TRUE )) return TRUE;
+    return HOOK_CallHooks( WH_MSGFILTER, code, 0, (LPARAM)msg, TRUE );
 }
 
 
@@ -482,16 +502,16 @@ BOOL WINAPI IsWinEventHookInstalled(DWORD dwEvent)
 }
 
 /* Undocumented RegisterUserApiHook() */
-BOOL WINAPI RegisterUserApiHook(const struct user_api_hook *new_hook, struct user_api_hook *old_hook)
+BOOL WINAPI RegisterUserApiHook(const struct user_api_hook *new, struct user_api_hook *old)
 {
-    if (!new_hook)
+    if (!new)
         return FALSE;
 
     USER_Lock();
-    hooked_user_api = *new_hook;
+    hooked_user_api = *new;
     user_api = &hooked_user_api;
-    if (old_hook)
-        *old_hook = original_user_api;
+    if (old)
+        *old = original_user_api;
     USER_Unlock();
     return TRUE;
 }
diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index 5fd5fe6d044..ed99d227f1c 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -49,6 +49,32 @@
 WINE_DEFAULT_DEBUG_CHANNEL(win);
 WINE_DECLARE_DEBUG_CHANNEL(keyboard);
 
+/***********************************************************************
+ *           get_key_state
+ */
+static WORD get_key_state(void)
+{
+    WORD ret = 0;
+
+    if (GetSystemMetrics( SM_SWAPBUTTON ))
+    {
+        if (NtUserGetAsyncKeyState(VK_RBUTTON) & 0x80) ret |= MK_LBUTTON;
+        if (NtUserGetAsyncKeyState(VK_LBUTTON) & 0x80) ret |= MK_RBUTTON;
+    }
+    else
+    {
+        if (NtUserGetAsyncKeyState(VK_LBUTTON) & 0x80) ret |= MK_LBUTTON;
+        if (NtUserGetAsyncKeyState(VK_RBUTTON) & 0x80) ret |= MK_RBUTTON;
+    }
+    if (NtUserGetAsyncKeyState(VK_MBUTTON) & 0x80)  ret |= MK_MBUTTON;
+    if (NtUserGetAsyncKeyState(VK_SHIFT) & 0x80)    ret |= MK_SHIFT;
+    if (NtUserGetAsyncKeyState(VK_CONTROL) & 0x80)  ret |= MK_CONTROL;
+    if (NtUserGetAsyncKeyState(VK_XBUTTON1) & 0x80) ret |= MK_XBUTTON1;
+    if (NtUserGetAsyncKeyState(VK_XBUTTON2) & 0x80) ret |= MK_XBUTTON2;
+    return ret;
+}
+
+
 /***********************************************************************
  *           get_locale_kbd_layout
  */
@@ -96,6 +122,118 @@ BOOL set_capture_window( HWND hwnd, UINT gui_flags, HWND *prev_ret )
 }
 
 
+/***********************************************************************
+ *		__wine_send_input  (USER32.@)
+ *
+ * Internal SendInput function to allow the graphics driver to inject real events.
+ */
+BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput )
+{
+    NTSTATUS status = send_hardware_message( hwnd, input, rawinput, 0 );
+    if (status) SetLastError( RtlNtStatusToDosError(status) );
+    return !status;
+}
+
+
+/***********************************************************************
+ *		update_mouse_coords
+ *
+ * Helper for SendInput.
+ */
+static void update_mouse_coords( INPUT *input )
+{
+    if (!(input->u.mi.dwFlags & MOUSEEVENTF_MOVE)) return;
+
+    if (input->u.mi.dwFlags & MOUSEEVENTF_ABSOLUTE)
+    {
+        DPI_AWARENESS_CONTEXT context = SetThreadDpiAwarenessContext( DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE );
+        RECT rc;
+
+        if (input->u.mi.dwFlags & MOUSEEVENTF_VIRTUALDESK)
+            rc = get_virtual_screen_rect();
+        else
+            rc = get_primary_monitor_rect();
+
+        input->u.mi.dx = rc.left + ((input->u.mi.dx * (rc.right - rc.left)) >> 16);
+        input->u.mi.dy = rc.top  + ((input->u.mi.dy * (rc.bottom - rc.top)) >> 16);
+        SetThreadDpiAwarenessContext( context );
+    }
+    else
+    {
+        int accel[3];
+
+        /* dx and dy can be negative numbers for relative movements */
+        SystemParametersInfoW(SPI_GETMOUSE, 0, accel, 0);
+
+        if (!accel[2]) return;
+
+        if (abs(input->u.mi.dx) > accel[0])
+        {
+            input->u.mi.dx *= 2;
+            if ((abs(input->u.mi.dx) > accel[1]) && (accel[2] == 2)) input->u.mi.dx *= 2;
+        }
+        if (abs(input->u.mi.dy) > accel[0])
+        {
+            input->u.mi.dy *= 2;
+            if ((abs(input->u.mi.dy) > accel[1]) && (accel[2] == 2)) input->u.mi.dy *= 2;
+        }
+    }
+}
+
+/***********************************************************************
+ *		SendInput  (USER32.@)
+ */
+UINT WINAPI SendInput( UINT count, LPINPUT inputs, int size )
+{
+    UINT i;
+    NTSTATUS status = STATUS_SUCCESS;
+
+    if (size != sizeof(INPUT))
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return 0;
+    }
+
+    if (!count)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return 0;
+    }
+
+    if (!inputs)
+    {
+        SetLastError( ERROR_NOACCESS );
+        return 0;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+        INPUT input = inputs[i];
+        switch (input.type)
+        {
+        case INPUT_MOUSE:
+            /* we need to update the coordinates to what the server expects */
+            update_mouse_coords( &input );
+            /* fallthrough */
+        case INPUT_KEYBOARD:
+            status = send_hardware_message( 0, &input, NULL, SEND_HWMSG_INJECTED );
+            break;
+        case INPUT_HARDWARE:
+            SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
+            return 0;
+        }
+
+        if (status)
+        {
+            SetLastError( RtlNtStatusToDosError(status) );
+            break;
+        }
+    }
+
+    return i;
+}
+
+
 /***********************************************************************
  *		keybd_event (USER32.@)
  */
@@ -110,7 +248,7 @@ void WINAPI keybd_event( BYTE bVk, BYTE bScan,
     input.u.ki.dwFlags = dwFlags;
     input.u.ki.time = 0;
     input.u.ki.dwExtraInfo = dwExtraInfo;
-    NtUserSendInput( 1, &input, sizeof(input) );
+    SendInput( 1, &input, sizeof(input) );
 }
 
 
@@ -129,7 +267,7 @@ void WINAPI mouse_event( DWORD dwFlags, DWORD dx, DWORD dy,
     input.u.mi.dwFlags = dwFlags;
     input.u.mi.time = 0;
     input.u.mi.dwExtraInfo = dwExtraInfo;
-    NtUserSendInput( 1, &input, sizeof(input) );
+    SendInput( 1, &input, sizeof(input) );
 }
 
 
@@ -138,7 +276,7 @@ void WINAPI mouse_event( DWORD dwFlags, DWORD dx, DWORD dy,
  */
 BOOL WINAPI DECLSPEC_HOTPATCH GetCursorPos( POINT *pt )
 {
-    return NtUserGetCursorPos( pt );
+    return NtUserCallOneParam( (UINT_PTR)pt, NtUserGetCursorPos );
 }
 
 
@@ -147,7 +285,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetCursorPos( POINT *pt )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH ReleaseCapture(void)
 {
-    return NtUserReleaseCapture();
+    return NtUserCallNoParam( NtUserReleaseCapture );
 }
 
 
@@ -162,39 +300,12 @@ HWND WINAPI GetCapture(void)
 }
 
 
-/*****************************************************************
- *		DestroyCaret (USER32.@)
- */
-BOOL WINAPI DestroyCaret(void)
-{
-    return NtUserDestroyCaret();
-}
-
-
-/*****************************************************************
- *		SetCaretPos (USER32.@)
- */
-BOOL WINAPI SetCaretPos( int x, int y )
-{
-    return NtUserSetCaretPos( x, y );
-}
-
-
-/*****************************************************************
- *		SetCaretBlinkTime (USER32.@)
- */
-BOOL WINAPI SetCaretBlinkTime( unsigned int time )
-{
-    return NtUserSetCaretBlinkTime( time );
-}
-
-
 /***********************************************************************
  *		GetInputState   (USER32.@)
  */
 BOOL WINAPI GetInputState(void)
 {
-    return NtUserGetInputState();
+    return NtUserCallNoParam( NtUserGetInputState );
 }
 
 
@@ -521,6 +632,243 @@ BOOL WINAPI UnloadKeyboardLayout( HKL layout )
     return FALSE;
 }
 
+typedef struct __TRACKINGLIST {
+    TRACKMOUSEEVENT tme;
+    POINT pos; /* center of hover rectangle */
+} _TRACKINGLIST;
+
+/* FIXME: move tracking stuff into a per thread data */
+static _TRACKINGLIST tracking_info;
+static UINT_PTR timer;
+
+static void check_mouse_leave(HWND hwnd, int hittest)
+{
+    if (tracking_info.tme.hwndTrack != hwnd)
+    {
+        if (tracking_info.tme.dwFlags & TME_NONCLIENT)
+            PostMessageW(tracking_info.tme.hwndTrack, WM_NCMOUSELEAVE, 0, 0);
+        else
+            PostMessageW(tracking_info.tme.hwndTrack, WM_MOUSELEAVE, 0, 0);
+
+        /* remove the TME_LEAVE flag */
+        tracking_info.tme.dwFlags &= ~TME_LEAVE;
+    }
+    else
+    {
+        if (hittest == HTCLIENT)
+        {
+            if (tracking_info.tme.dwFlags & TME_NONCLIENT)
+            {
+                PostMessageW(tracking_info.tme.hwndTrack, WM_NCMOUSELEAVE, 0, 0);
+                /* remove the TME_LEAVE flag */
+                tracking_info.tme.dwFlags &= ~TME_LEAVE;
+            }
+        }
+        else
+        {
+            if (!(tracking_info.tme.dwFlags & TME_NONCLIENT))
+            {
+                PostMessageW(tracking_info.tme.hwndTrack, WM_MOUSELEAVE, 0, 0);
+                /* remove the TME_LEAVE flag */
+                tracking_info.tme.dwFlags &= ~TME_LEAVE;
+            }
+        }
+    }
+}
+
+static void CALLBACK TrackMouseEventProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent,
+                                         DWORD dwTime)
+{
+    POINT pos;
+    INT hoverwidth = 0, hoverheight = 0, hittest;
+
+    TRACE("hwnd %p, msg %04x, id %04lx, time %u\n", hwnd, uMsg, idEvent, dwTime);
+
+    GetCursorPos(&pos);
+    hwnd = WINPOS_WindowFromPoint(hwnd, pos, &hittest);
+
+    TRACE("point %s hwnd %p hittest %d\n", wine_dbgstr_point(&pos), hwnd, hittest);
+
+    SystemParametersInfoW(SPI_GETMOUSEHOVERWIDTH, 0, &hoverwidth, 0);
+    SystemParametersInfoW(SPI_GETMOUSEHOVERHEIGHT, 0, &hoverheight, 0);
+
+    TRACE("tracked pos %s, current pos %s, hover width %d, hover height %d\n",
+           wine_dbgstr_point(&tracking_info.pos), wine_dbgstr_point(&pos),
+           hoverwidth, hoverheight);
+
+    /* see if this tracking event is looking for TME_LEAVE and that the */
+    /* mouse has left the window */
+    if (tracking_info.tme.dwFlags & TME_LEAVE)
+    {
+        check_mouse_leave(hwnd, hittest);
+    }
+
+    if (tracking_info.tme.hwndTrack != hwnd)
+    {
+        /* mouse is gone, stop tracking mouse hover */
+        tracking_info.tme.dwFlags &= ~TME_HOVER;
+    }
+
+    /* see if we are tracking hovering for this hwnd */
+    if (tracking_info.tme.dwFlags & TME_HOVER)
+    {
+        /* has the cursor moved outside the rectangle centered around pos? */
+        if ((abs(pos.x - tracking_info.pos.x) > (hoverwidth / 2)) ||
+            (abs(pos.y - tracking_info.pos.y) > (hoverheight / 2)))
+        {
+            /* record this new position as the current position */
+            tracking_info.pos = pos;
+        }
+        else
+        {
+            if (hittest == HTCLIENT)
+            {
+                ScreenToClient(hwnd, &pos);
+                TRACE("client cursor pos %s\n", wine_dbgstr_point(&pos));
+
+                PostMessageW(tracking_info.tme.hwndTrack, WM_MOUSEHOVER,
+                             get_key_state(), MAKELPARAM( pos.x, pos.y ));
+            }
+            else
+            {
+                if (tracking_info.tme.dwFlags & TME_NONCLIENT)
+                    PostMessageW(tracking_info.tme.hwndTrack, WM_NCMOUSEHOVER,
+                                 hittest, MAKELPARAM( pos.x, pos.y ));
+            }
+
+            /* stop tracking mouse hover */
+            tracking_info.tme.dwFlags &= ~TME_HOVER;
+        }
+    }
+
+    /* stop the timer if the tracking list is empty */
+    if (!(tracking_info.tme.dwFlags & (TME_HOVER | TME_LEAVE)))
+    {
+        KillSystemTimer(tracking_info.tme.hwndTrack, timer);
+        timer = 0;
+        tracking_info.tme.hwndTrack = 0;
+        tracking_info.tme.dwFlags = 0;
+        tracking_info.tme.dwHoverTime = 0;
+    }
+}
+
+
+/***********************************************************************
+ * TrackMouseEvent [USER32]
+ *
+ * Requests notification of mouse events
+ *
+ * During mouse tracking WM_MOUSEHOVER or WM_MOUSELEAVE events are posted
+ * to the hwnd specified in the ptme structure.  After the event message
+ * is posted to the hwnd, the entry in the queue is removed.
+ *
+ * If the current hwnd isn't ptme->hwndTrack the TME_HOVER flag is completely
+ * ignored. The TME_LEAVE flag results in a WM_MOUSELEAVE message being posted
+ * immediately and the TME_LEAVE flag being ignored.
+ *
+ * PARAMS
+ *     ptme [I,O] pointer to TRACKMOUSEEVENT information structure.
+ *
+ * RETURNS
+ *     Success: non-zero
+ *     Failure: zero
+ *
+ */
+
+BOOL WINAPI
+TrackMouseEvent (TRACKMOUSEEVENT *ptme)
+{
+    HWND hwnd;
+    POINT pos;
+    DWORD hover_time;
+    INT hittest;
+
+    TRACE("%x, %x, %p, %u\n", ptme->cbSize, ptme->dwFlags, ptme->hwndTrack, ptme->dwHoverTime);
+
+    if (ptme->cbSize != sizeof(TRACKMOUSEEVENT)) {
+        WARN("wrong TRACKMOUSEEVENT size from app\n");
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    /* fill the TRACKMOUSEEVENT struct with the current tracking for the given hwnd */
+    if (ptme->dwFlags & TME_QUERY )
+    {
+        *ptme = tracking_info.tme;
+        /* set cbSize in the case it's not initialized yet */
+        ptme->cbSize = sizeof(TRACKMOUSEEVENT);
+
+        return TRUE; /* return here, TME_QUERY is retrieving information */
+    }
+
+    if (!IsWindow(ptme->hwndTrack))
+    {
+        SetLastError(ERROR_INVALID_WINDOW_HANDLE);
+        return FALSE;
+    }
+
+    hover_time = (ptme->dwFlags & TME_HOVER) ? ptme->dwHoverTime : HOVER_DEFAULT;
+
+    /* if HOVER_DEFAULT was specified replace this with the system's current value.
+     * TME_LEAVE doesn't need to specify hover time so use default */
+    if (hover_time == HOVER_DEFAULT || hover_time == 0)
+        SystemParametersInfoW(SPI_GETMOUSEHOVERTIME, 0, &hover_time, 0);
+
+    GetCursorPos(&pos);
+    hwnd = WINPOS_WindowFromPoint(ptme->hwndTrack, pos, &hittest);
+    TRACE("point %s hwnd %p hittest %d\n", wine_dbgstr_point(&pos), hwnd, hittest);
+
+    if (ptme->dwFlags & ~(TME_CANCEL | TME_HOVER | TME_LEAVE | TME_NONCLIENT))
+        FIXME("Unknown flag(s) %08x\n", ptme->dwFlags & ~(TME_CANCEL | TME_HOVER | TME_LEAVE | TME_NONCLIENT));
+
+    if (ptme->dwFlags & TME_CANCEL)
+    {
+        if (tracking_info.tme.hwndTrack == ptme->hwndTrack)
+        {
+            tracking_info.tme.dwFlags &= ~(ptme->dwFlags & ~TME_CANCEL);
+
+            /* if we aren't tracking on hover or leave remove this entry */
+            if (!(tracking_info.tme.dwFlags & (TME_HOVER | TME_LEAVE)))
+            {
+                KillSystemTimer(tracking_info.tme.hwndTrack, timer);
+                timer = 0;
+                tracking_info.tme.hwndTrack = 0;
+                tracking_info.tme.dwFlags = 0;
+                tracking_info.tme.dwHoverTime = 0;
+            }
+        }
+    } else {
+        /* In our implementation it's possible that another window will receive a
+         * WM_MOUSEMOVE and call TrackMouseEvent before TrackMouseEventProc is
+         * called. In such a situation post the WM_MOUSELEAVE now */
+        if (tracking_info.tme.dwFlags & TME_LEAVE && tracking_info.tme.hwndTrack != NULL)
+            check_mouse_leave(hwnd, hittest);
+
+        if (timer)
+        {
+            KillSystemTimer(tracking_info.tme.hwndTrack, timer);
+            timer = 0;
+            tracking_info.tme.hwndTrack = 0;
+            tracking_info.tme.dwFlags = 0;
+            tracking_info.tme.dwHoverTime = 0;
+        }
+
+        if (ptme->hwndTrack == hwnd)
+        {
+            /* Adding new mouse event to the tracking list */
+            tracking_info.tme = *ptme;
+            tracking_info.tme.dwHoverTime = hover_time;
+
+            /* Initialize HoverInfo variables even if not hover tracking */
+            tracking_info.pos = pos;
+
+            timer = NtUserSetSystemTimer( tracking_info.tme.hwndTrack, (UINT_PTR)&tracking_info.tme,
+                                          hover_time, TrackMouseEventProc );
+        }
+    }
+
+    return TRUE;
+}
 
 /***********************************************************************
  *		EnableMouseInPointer (USER32.@)
diff --git a/dlls/user32/listbox.c b/dlls/user32/listbox.c
index 0eed2fdfe65..ead10edf739 100644
--- a/dlls/user32/listbox.c
+++ b/dlls/user32/listbox.c
@@ -2413,7 +2413,7 @@ static void LISTBOX_HandleMouseMove( LB_DESCR *descr,
     /* Start/stop the system timer */
 
     if (dir != LB_TIMER_NONE)
-        NtUserSetSystemTimer( descr->self, LB_TIMER_ID, LB_SCROLL_TIMEOUT );
+        NtUserSetSystemTimer( descr->self, LB_TIMER_ID, LB_SCROLL_TIMEOUT, NULL);
     else if (LISTBOX_Timer != LB_TIMER_NONE)
         KillSystemTimer( descr->self, LB_TIMER_ID );
     LISTBOX_Timer = dir;
diff --git a/dlls/user32/mdi.c b/dlls/user32/mdi.c
index e5a52012413..0726a28cd4b 100644
--- a/dlls/user32/mdi.c
+++ b/dlls/user32/mdi.c
@@ -217,7 +217,7 @@ static BOOL is_close_enabled(HWND hwnd, HMENU hSysMenu)
 {
     if (GetClassLongW(hwnd, GCL_STYLE) & CS_NOCLOSE) return FALSE;
 
-    if (!hSysMenu) hSysMenu = NtUserGetSystemMenu( hwnd, FALSE );
+    if (!hSysMenu) hSysMenu = GetSystemMenu(hwnd, FALSE);
     if (hSysMenu)
     {
         UINT state = GetMenuState(hSysMenu, SC_CLOSE, MF_BYCOMMAND);
@@ -357,7 +357,7 @@ static LRESULT MDISetMenu( HWND hwnd, HMENU hmenuFrame,
 
     if (hmenuFrame)
     {
-        NtUserSetMenu(hwndFrame, hmenuFrame);
+        SetMenu(hwndFrame, hmenuFrame);
         if( hmenuFrame != ci->hFrameMenu )
         {
             HMENU oldFrameMenu = ci->hFrameMenu;
@@ -417,7 +417,7 @@ static LRESULT MDI_RefreshMenu(MDICLIENTINFO *ci)
                     if (mii.wID == ci->idFirstChild)
                     {
                         TRACE("removing %u items including separator\n", count - i);
-                        while (NtUserRemoveMenu( ci->hWindowMenu, i, MF_BYPOSITION ))
+                        while (RemoveMenu(ci->hWindowMenu, i, MF_BYPOSITION))
                             /* nothing */;
 
                         break;
@@ -457,7 +457,7 @@ static LRESULT MDI_RefreshMenu(MDICLIENTINFO *ci)
             AppendMenuW(ci->hWindowMenu, MF_STRING, id, buf);
 
             if (ci->child[i] == ci->hwndActiveChild)
-                NtUserCheckMenuItem(ci->hWindowMenu, id, MF_CHECKED);
+                CheckMenuItem(ci->hWindowMenu, id, MF_CHECKED);
         }
         else
             TRACE("MDI child %p is not visible, skipping\n", ci->child[i]);
@@ -835,7 +835,7 @@ static BOOL MDI_AugmentFrameMenu( HWND frame, HWND hChild )
     if (!menu) return FALSE;
 
     /* create a copy of sysmenu popup and insert it into frame menu bar */
-    if (!(hSysPopup = NtUserGetSystemMenu( hChild, FALSE )))
+    if (!(hSysPopup = GetSystemMenu(hChild, FALSE)))
     {
         TRACE("child %p doesn't have a system menu\n", hChild);
         return FALSE;
@@ -887,14 +887,14 @@ static BOOL MDI_AugmentFrameMenu( HWND frame, HWND hChild )
                      (UINT_PTR)hSysPopup, (LPSTR)hSysMenuBitmap))
     {
         TRACE("not inserted\n");
-        NtUserDestroyMenu( hSysPopup );
+	DestroyMenu(hSysPopup);
         return FALSE;
     }
 
-    NtUserEnableMenuItem(hSysPopup, SC_SIZE, MF_BYCOMMAND | MF_GRAYED);
-    NtUserEnableMenuItem(hSysPopup, SC_MOVE, MF_BYCOMMAND | MF_GRAYED);
-    NtUserEnableMenuItem(hSysPopup, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
-    NtUserSetMenuDefaultItem(hSysPopup, SC_CLOSE, FALSE);
+    EnableMenuItem(hSysPopup, SC_SIZE, MF_BYCOMMAND | MF_GRAYED);
+    EnableMenuItem(hSysPopup, SC_MOVE, MF_BYCOMMAND | MF_GRAYED);
+    EnableMenuItem(hSysPopup, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
+    SetMenuDefaultItem(hSysPopup, SC_CLOSE, FALSE);
 
     /* redraw menu */
     DrawMenuBar(frame);
@@ -935,7 +935,7 @@ static BOOL MDI_RestoreFrameMenu( HWND frame, HWND hChild )
 		     TRUE,
 		     &menuInfo);
 
-    NtUserRemoveMenu( menu, 0, MF_BYPOSITION );
+    RemoveMenu(menu,0,MF_BYPOSITION);
 
     if ( (menuInfo.fType & MFT_BITMAP)           &&
 	 (LOWORD(menuInfo.dwTypeData)!=0)        &&
@@ -945,11 +945,11 @@ static BOOL MDI_RestoreFrameMenu( HWND frame, HWND hChild )
     }
 
     /* close */
-    NtUserDeleteMenu( menu, SC_CLOSE, MF_BYCOMMAND );
+    DeleteMenu(menu, SC_CLOSE, MF_BYCOMMAND);
     /* restore */
-    NtUserDeleteMenu( menu, SC_RESTORE, MF_BYCOMMAND );
+    DeleteMenu(menu, SC_RESTORE, MF_BYCOMMAND);
     /* minimize */
-    NtUserDeleteMenu( menu, SC_MINIMIZE, MF_BYCOMMAND );
+    DeleteMenu(menu, SC_MINIMIZE, MF_BYCOMMAND);
 
     DrawMenuBar(frame);
 
diff --git a/dlls/user32/menu.c b/dlls/user32/menu.c
index 1ae722b7662..d34634de3ff 100644
--- a/dlls/user32/menu.c
+++ b/dlls/user32/menu.c
@@ -56,6 +56,54 @@
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(menu);
+WINE_DECLARE_DEBUG_CHANNEL(accel);
+
+/* Menu item structure */
+typedef struct {
+    /* ----------- MENUITEMINFO Stuff ----------- */
+    UINT fType;			/* Item type. */
+    UINT fState;		/* Item state.  */
+    UINT_PTR wID;		/* Item id.  */
+    HMENU hSubMenu;		/* Pop-up menu.  */
+    HBITMAP hCheckBit;		/* Bitmap when checked.  */
+    HBITMAP hUnCheckBit;	/* Bitmap when unchecked.  */
+    LPWSTR text;		/* Item text. */
+    ULONG_PTR dwItemData;	/* Application defined.  */
+    LPWSTR dwTypeData;		/* depends on fMask */
+    HBITMAP hbmpItem;		/* bitmap */
+    /* ----------- Wine stuff ----------- */
+    RECT      rect;             /* Item area (relative to the items_rect).
+                                 * See MENU_AdjustMenuItemRect(). */
+    UINT      xTab;		/* X position of text after Tab */
+    SIZE   bmpsize;             /* size needed for the HBMMENU_CALLBACK
+                                 * bitmap */ 
+} MENUITEM;
+
+/* Popup menu structure */
+typedef struct {
+    struct user_object obj;
+    WORD        wFlags;       /* Menu flags (MF_POPUP, MF_SYSMENU) */
+    WORD	Width;        /* Width of the whole menu */
+    WORD	Height;       /* Height of the whole menu */
+    UINT        nItems;       /* Number of items in the menu */
+    HWND        hWnd;         /* Window containing the menu */
+    MENUITEM    *items;       /* Array of menu items */
+    UINT        FocusedItem;  /* Currently focused item */
+    HWND	hwndOwner;    /* window receiving the messages for ownerdraw */
+    BOOL        bScrolling;   /* Scroll arrows are active */
+    UINT        nScrollPos;   /* Current scroll position */
+    UINT        nTotalHeight; /* Total height of menu items inside menu */
+    RECT        items_rect;   /* Rectangle within which the items lie.  Excludes margins and scroll arrows */
+    LONG        refcount;
+    /* ------------ MENUINFO members ------ */
+    DWORD	dwStyle;	/* Extended menu style */
+    UINT	cyMax;		/* max height of the whole menu, 0 is screen height */
+    HBRUSH	hbrBack;	/* brush for menu background */
+    DWORD	dwContextHelpID;
+    ULONG_PTR	dwMenuData;	/* application defined value */
+    HMENU       hSysMenuOwner;  /* Handle to the dummy sys menu holder */
+    WORD        textOffset;     /* Offset of text when items have both bitmaps and text */
+} POPUPMENU, *LPPOPUPMENU;
 
 /* internal flags for menu tracking */
 
@@ -87,6 +135,11 @@ typedef struct
   /* Margins for popup menus */
 #define MENU_MARGIN 3
 
+/* maximum allowed depth of any branch in the menu tree.
+ * This value is slightly larger than in windows (25) to
+ * stay on the safe side. */
+#define MAXMENUDEPTH 30
+
   /* (other menu->FocusedItem values give the position of the focused item) */
 #define NO_SELECTED_ITEM  0xffff
 
@@ -121,6 +174,8 @@ static BOOL fEndMenu = FALSE;
 
 DWORD WINAPI DrawMenuBarTemp(HWND hwnd, HDC hDC, LPRECT lprect, HMENU hMenu, HFONT hFont);
 
+static BOOL SetMenuItemInfo_common( MENUITEM *, const MENUITEMINFOW *, BOOL);
+
 static BOOL is_win_menu_disallowed(HWND hwnd)
 {
     return (GetWindowLongW(hwnd, GWL_STYLE) & (WS_CHILD | WS_POPUP)) == WS_CHILD;
@@ -367,7 +422,7 @@ static HMENU MENU_CopySysPopup(BOOL mdi)
         SetMenuItemInfoW( hMenu, SC_MAXIMIZE, FALSE, &miteminfo);
         miteminfo.hbmpItem = HBMMENU_POPUP_MINIMIZE;
         SetMenuItemInfoW( hMenu, SC_MINIMIZE, FALSE, &miteminfo);
-        NtUserSetMenuDefaultItem( hMenu, SC_CLOSE, FALSE );
+	SetMenuDefaultItem(hMenu, SC_CLOSE, FALSE);
     }
     else
 	ERR("Unable to load default system menu\n" );
@@ -387,7 +442,7 @@ static HMENU MENU_CopySysPopup(BOOL mdi)
  * However, the real system menu handle is sometimes seen in the
  * WM_MENUSELECT parameters (and Word 6 likes it this way).
  */
-HMENU MENU_GetSysMenu( HWND hWnd, HMENU hPopupMenu )
+static HMENU MENU_GetSysMenu( HWND hWnd, HMENU hPopupMenu )
 {
     HMENU hMenu;
 
@@ -410,7 +465,7 @@ HMENU MENU_GetSysMenu( HWND hWnd, HMENU hPopupMenu )
 	if (hPopupMenu)
 	{
             if (GetClassLongW(hWnd, GCL_STYLE) & CS_NOCLOSE)
-                NtUserDeleteMenu( hPopupMenu, SC_CLOSE, MF_BYCOMMAND );
+                DeleteMenu(hPopupMenu, SC_CLOSE, MF_BYCOMMAND);
 
 	    InsertMenuW( hMenu, -1, MF_SYSMENU | MF_POPUP | MF_BYPOSITION,
                          (UINT_PTR)hPopupMenu, NULL );
@@ -422,7 +477,7 @@ HMENU MENU_GetSysMenu( HWND hWnd, HMENU hPopupMenu )
 	    TRACE("hMenu=%p (hPopup %p)\n", hMenu, hPopupMenu );
 	    return hMenu;
 	}
-	NtUserDestroyMenu( hMenu );
+	DestroyMenu( hMenu );
     }
     ERR("failed to load system menu!\n");
     return 0;
@@ -439,20 +494,20 @@ static void MENU_InitSysMenuPopup( HMENU hmenu, DWORD style, DWORD clsStyle )
     BOOL gray;
 
     gray = !(style & WS_THICKFRAME) || (style & (WS_MAXIMIZE | WS_MINIMIZE));
-    NtUserEnableMenuItem( hmenu, SC_SIZE, (gray ? MF_GRAYED : MF_ENABLED) );
+    EnableMenuItem( hmenu, SC_SIZE, (gray ? MF_GRAYED : MF_ENABLED) );
     gray = ((style & WS_MAXIMIZE) != 0);
-    NtUserEnableMenuItem( hmenu, SC_MOVE, (gray ? MF_GRAYED : MF_ENABLED) );
+    EnableMenuItem( hmenu, SC_MOVE, (gray ? MF_GRAYED : MF_ENABLED) );
     gray = !(style & WS_MINIMIZEBOX) || (style & WS_MINIMIZE);
-    NtUserEnableMenuItem( hmenu, SC_MINIMIZE, (gray ? MF_GRAYED : MF_ENABLED) );
+    EnableMenuItem( hmenu, SC_MINIMIZE, (gray ? MF_GRAYED : MF_ENABLED) );
     gray = !(style & WS_MAXIMIZEBOX) || (style & WS_MAXIMIZE);
-    NtUserEnableMenuItem( hmenu, SC_MAXIMIZE, (gray ? MF_GRAYED : MF_ENABLED) );
+    EnableMenuItem( hmenu, SC_MAXIMIZE, (gray ? MF_GRAYED : MF_ENABLED) );
     gray = !(style & (WS_MAXIMIZE | WS_MINIMIZE));
-    NtUserEnableMenuItem( hmenu, SC_RESTORE, (gray ? MF_GRAYED : MF_ENABLED) );
+    EnableMenuItem( hmenu, SC_RESTORE, (gray ? MF_GRAYED : MF_ENABLED) );
     gray = (clsStyle & CS_NOCLOSE) != 0;
 
     /* The menu item must keep its state if it's disabled */
     if(gray)
-	NtUserEnableMenuItem( hmenu, SC_CLOSE, MF_GRAYED);
+	EnableMenuItem( hmenu, SC_CLOSE, MF_GRAYED);
 }
 
 
@@ -615,6 +670,15 @@ static UINT MENU_FindSubMenu( HMENU *hmenu, HMENU hSubTarget )
     return NO_SELECTED_ITEM;
 }
 
+/***********************************************************************
+ *           MENU_FreeItemData
+ */
+static void MENU_FreeItemData( MENUITEM* item )
+{
+    /* delete text */
+    HeapFree( GetProcessHeap(), 0, item->text );
+}
+
 /***********************************************************************
  *           MENU_AdjustMenuItemRect
  *
@@ -2061,6 +2125,62 @@ static void MENU_MoveSelection( HWND hwndOwner, HMENU hmenu, INT offset )
 }
 
 
+/**********************************************************************
+ *         insert_menu_item
+ *
+ * Insert (allocate) a new item into a menu.
+ */
+static POPUPMENU *insert_menu_item(HMENU hMenu, UINT id, UINT flags, UINT *ret_pos)
+{
+    MENUITEM *newItems;
+    POPUPMENU *menu;
+    UINT pos = id;
+
+    /* Find where to insert new item */
+    if (!(menu = find_menu_item(hMenu, id, flags, &pos)))
+    {
+        if (!(menu = grab_menu_ptr(hMenu)))
+            return NULL;
+        pos = menu->nItems;
+    }
+
+    /* Make sure that MDI system buttons stay on the right side.
+     * Note: XP treats only bitmap handles 1 - 6 as "magic" ones
+     * regardless of their id.
+     */
+    while (pos > 0 && (INT_PTR)menu->items[pos - 1].hbmpItem >= (INT_PTR)HBMMENU_SYSTEM &&
+           (INT_PTR)menu->items[pos - 1].hbmpItem <= (INT_PTR)HBMMENU_MBAR_CLOSE_D)
+        pos--;
+
+    TRACE("inserting at %u flags %x\n", pos, flags);
+
+    /* Create new items array */
+
+    newItems = HeapAlloc( GetProcessHeap(), 0, sizeof(MENUITEM) * (menu->nItems+1) );
+    if (!newItems)
+    {
+        release_menu_ptr(menu);
+        WARN("allocation failed\n" );
+        return NULL;
+    }
+    if (menu->nItems > 0)
+    {
+	  /* Copy the old array into the new one */
+	if (pos > 0) memcpy( newItems, menu->items, pos * sizeof(MENUITEM) );
+	if (pos < menu->nItems) memcpy( &newItems[pos+1], &menu->items[pos],
+					(menu->nItems-pos)*sizeof(MENUITEM) );
+        HeapFree( GetProcessHeap(), 0, menu->items );
+    }
+    menu->items = newItems;
+    menu->nItems++;
+    memset( &newItems[pos], 0, sizeof(*newItems) );
+    menu->Height = 0; /* force size recalculate */
+
+    *ret_pos = pos;
+    return menu;
+}
+
+
 /**********************************************************************
  *         MENU_ParseResource
  *
@@ -2144,7 +2264,7 @@ static LPCSTR MENUEX_ParseResource( LPCSTR res, HMENU hMenu)
 	    if (!mii.hSubMenu)
 		return NULL;
 	    if (!(res = MENUEX_ParseResource(res, mii.hSubMenu))) {
-		NtUserDestroyMenu( mii.hSubMenu );
+		DestroyMenu(mii.hSubMenu);
                 return NULL;
 	    }
 	    mii.fMask |= MIIM_SUBMENU;
@@ -2974,7 +3094,7 @@ static BOOL MENU_TrackMenu( HMENU hmenu, UINT wFlags, INT x, INT y,
         {
             if (PeekMessageW( &msg, 0, 0, 0, PM_NOREMOVE ))
             {
-                if (!NtUserCallMsgFilter( &msg, MSGF_MENU )) break;
+                if (!CallMsgFilterW( &msg, MSGF_MENU )) break;
                 /* remove the message from the queue */
                 PeekMessageW( &msg, 0, msg.message, msg.message, PM_REMOVE );
             }
@@ -3227,7 +3347,7 @@ static BOOL MENU_InitTracking(HWND hWnd, HMENU hMenu, BOOL bPopup, UINT wFlags)
     
     TRACE("hwnd=%p hmenu=%p\n", hWnd, hMenu);
 
-    NtUserHideCaret( 0 );
+    HideCaret(0);
 
     if (!(menu = MENU_GetMenu( hMenu ))) return FALSE;
 
@@ -3269,7 +3389,7 @@ static BOOL MENU_ExitTracking(HWND hWnd, BOOL bPopup)
     TRACE("hwnd=%p\n", hWnd);
 
     SendMessageW( hWnd, WM_EXITMENULOOP, bPopup, 0 );
-    NtUserShowCaret( 0 );
+    ShowCaret(0);
     top_popup = 0;
     top_popup_hmenu = NULL;
     return TRUE;
@@ -3540,12 +3660,12 @@ BOOL WINAPI ChangeMenuA( HMENU hMenu, UINT pos, LPCSTR data,
     TRACE("menu=%p pos=%d data=%p id=%08x flags=%08x\n", hMenu, pos, data, id, flags );
     if (flags & MF_APPEND) return AppendMenuA( hMenu, flags & ~MF_APPEND,
                                                  id, data );
-    if (flags & MF_DELETE) return NtUserDeleteMenu( hMenu, pos, flags & ~MF_DELETE );
+    if (flags & MF_DELETE) return DeleteMenu(hMenu, pos, flags & ~MF_DELETE);
     if (flags & MF_CHANGE) return ModifyMenuA(hMenu, pos, flags & ~MF_CHANGE,
                                                 id, data );
-    if (flags & MF_REMOVE) return NtUserRemoveMenu( hMenu,
-                                                    flags & MF_BYPOSITION ? pos : id,
-                                                    flags & ~MF_REMOVE );
+    if (flags & MF_REMOVE) return RemoveMenu( hMenu,
+                                              flags & MF_BYPOSITION ? pos : id,
+                                              flags & ~MF_REMOVE );
     /* Default: MF_INSERT */
     return InsertMenuA( hMenu, pos, flags, id, data );
 }
@@ -3560,17 +3680,86 @@ BOOL WINAPI ChangeMenuW( HMENU hMenu, UINT pos, LPCWSTR data,
     TRACE("menu=%p pos=%d data=%p id=%08x flags=%08x\n", hMenu, pos, data, id, flags );
     if (flags & MF_APPEND) return AppendMenuW( hMenu, flags & ~MF_APPEND,
                                                  id, data );
-    if (flags & MF_DELETE) return NtUserDeleteMenu( hMenu, pos, flags & ~MF_DELETE );
+    if (flags & MF_DELETE) return DeleteMenu(hMenu, pos, flags & ~MF_DELETE);
     if (flags & MF_CHANGE) return ModifyMenuW(hMenu, pos, flags & ~MF_CHANGE,
                                                 id, data );
-    if (flags & MF_REMOVE) return NtUserRemoveMenu( hMenu,
-                                                    flags & MF_BYPOSITION ? pos : id,
-                                                    flags & ~MF_REMOVE );
+    if (flags & MF_REMOVE) return RemoveMenu( hMenu,
+                                              flags & MF_BYPOSITION ? pos : id,
+                                              flags & ~MF_REMOVE );
     /* Default: MF_INSERT */
     return InsertMenuW( hMenu, pos, flags, id, data );
 }
 
 
+/*******************************************************************
+ *         CheckMenuItem    (USER32.@)
+ */
+DWORD WINAPI CheckMenuItem( HMENU hMenu, UINT id, UINT flags )
+{
+    POPUPMENU *menu;
+    MENUITEM *item;
+    DWORD ret;
+    UINT pos;
+
+    if (!(menu = find_menu_item(hMenu, id, flags, &pos)))
+        return -1;
+    item = &menu->items[pos];
+
+    ret = item->fState & MF_CHECKED;
+    if (flags & MF_CHECKED) item->fState |= MF_CHECKED;
+    else item->fState &= ~MF_CHECKED;
+    release_menu_ptr(menu);
+    return ret;
+}
+
+
+/**********************************************************************
+ *         EnableMenuItem    (USER32.@)
+ */
+BOOL WINAPI EnableMenuItem( HMENU hMenu, UINT id, UINT wFlags )
+{
+    UINT oldflags, pos;
+    POPUPMENU *menu;
+    MENUITEM *item;
+
+    TRACE("(%p, %04x, %04x)\n", hMenu, id, wFlags);
+
+    /* Get the Popupmenu to access the owner menu */
+    if (!(menu = find_menu_item(hMenu, id, wFlags, &pos)))
+	return (UINT)-1;
+
+    item = &menu->items[pos];
+    oldflags = item->fState & (MF_GRAYED | MF_DISABLED);
+    item->fState ^= (oldflags ^ wFlags) & (MF_GRAYED | MF_DISABLED);
+
+    /* If the close item in the system menu change update the close button */
+    if ((item->wID == SC_CLOSE) && (oldflags != wFlags) && menu->hSysMenuOwner)
+    {
+        RECT rc;
+        POPUPMENU* parentMenu;
+        HWND hwnd;
+
+        /* Get the parent menu to access */
+        parentMenu = grab_menu_ptr(menu->hSysMenuOwner);
+        release_menu_ptr(menu);
+        if (!parentMenu)
+            return (UINT)-1;
+
+        hwnd = parentMenu->hWnd;
+        release_menu_ptr(parentMenu);
+
+        /* Refresh the frame to reflect the change */
+        WIN_GetRectangles(hwnd, COORDS_CLIENT, &rc, NULL);
+        rc.bottom = 0;
+        NtUserRedrawWindow( hwnd, &rc, 0, RDW_FRAME | RDW_INVALIDATE | RDW_NOCHILDREN );
+    }
+    else
+        release_menu_ptr(menu);
+
+    return oldflags;
+}
+
+
 /*******************************************************************
  *         GetMenuStringA    (USER32.@)
  */
@@ -3686,18 +3875,54 @@ BOOL WINAPI HiliteMenuItem( HWND hWnd, HMENU hMenu, UINT wItemID,
 /**********************************************************************
  *         GetMenuState    (USER32.@)
  */
-UINT WINAPI GetMenuState( HMENU menu, UINT item, UINT flags )
+UINT WINAPI GetMenuState( HMENU hMenu, UINT wItemID, UINT wFlags )
 {
-    return NtUserThunkedMenuItemInfo( menu, item, flags, NtUserGetMenuState, NULL, NULL );
+    POPUPMENU *menu;
+    UINT state, pos;
+    MENUITEM *item;
+
+    TRACE("(menu=%p, id=%04x, flags=%04x);\n", hMenu, wItemID, wFlags);
+
+    if (!(menu = find_menu_item(hMenu, wItemID, wFlags, &pos)))
+        return -1;
+
+    item = &menu->items[pos];
+    debug_print_menuitem ("  item: ", item, "");
+    if (item->fType & MF_POPUP)
+    {
+        POPUPMENU *submenu = grab_menu_ptr(item->hSubMenu);
+        if (submenu)
+            state = (submenu->nItems << 8) | ((item->fState | item->fType) & 0xff);
+        else
+            state = -1;
+        release_menu_ptr(submenu);
+    }
+    else
+    {
+	/* We used to (from way back then) mask the result to 0xff.  */
+	/* I don't know why and it seems wrong as the documented */
+	/* return flag MF_SEPARATOR is outside that mask.  */
+        state = (item->fType | item->fState);
+    }
+    release_menu_ptr(menu);
+    return state;
 }
 
 
 /**********************************************************************
  *         GetMenuItemCount    (USER32.@)
  */
-INT WINAPI GetMenuItemCount( HMENU menu )
+INT WINAPI GetMenuItemCount( HMENU hMenu )
 {
-    return NtUserGetMenuItemCount( menu );
+    POPUPMENU *menu = grab_menu_ptr(hMenu);
+    INT count;
+
+    if (!menu) return -1;
+    count = menu->nItems;
+    release_menu_ptr(menu);
+
+    TRACE("(%p) returning %d\n", hMenu, count);
+    return count;
 }
 
 
@@ -3768,6 +3993,10 @@ BOOL WINAPI InsertMenuW( HMENU hMenu, UINT pos, UINT flags,
                          UINT_PTR id, LPCWSTR str )
 {
     MENUITEMINFOW mii;
+    POPUPMENU *menu;
+    MENUITEM *item;
+    UINT newpos;
+    BOOL ret;
 
     if (IS_STRING_ITEM(flags) && str)
         TRACE("hMenu %p, pos %d, flags %08x, id %04Ix, str %s\n",
@@ -3775,9 +4004,20 @@ BOOL WINAPI InsertMenuW( HMENU hMenu, UINT pos, UINT flags,
     else TRACE("hMenu %p, pos %d, flags %08x, id %04Ix, str %p (not a string)\n",
                hMenu, pos, flags, id, str );
 
+    if (!(menu = insert_menu_item(hMenu, pos, flags, &newpos)))
+        return FALSE;
+
     MENU_mnu2mnuii( flags, id, str, &mii);
-    mii.fMask |= MIIM_CHECKMARKS;
-    return NtUserThunkedMenuItemInfo( hMenu, pos, flags, NtUserInsertMenuItem, &mii, NULL );
+
+    item = &menu->items[newpos];
+    ret = SetMenuItemInfo_common( item, &mii, TRUE);
+    if (ret)
+        item->hCheckBit = item->hUnCheckBit = 0;
+    else
+        RemoveMenu( hMenu, pos, flags );
+    release_menu_ptr(menu);
+
+    return ret;
 }
 
 
@@ -3825,6 +4065,66 @@ BOOL WINAPI AppendMenuW( HMENU hMenu, UINT flags,
 }
 
 
+/**********************************************************************
+ *         RemoveMenu    (USER32.@)
+ */
+BOOL WINAPI RemoveMenu( HMENU hMenu, UINT id, UINT flags )
+{
+    POPUPMENU *menu;
+    UINT pos;
+
+    TRACE("(menu=%p id=%#x flags=%04x)\n", hMenu, id, flags);
+
+    if (!(menu = find_menu_item(hMenu, id, flags, &pos)))
+        return FALSE;
+
+    /* Remove item */
+    MENU_FreeItemData( &menu->items[pos] );
+
+    if (--menu->nItems == 0)
+    {
+        HeapFree( GetProcessHeap(), 0, menu->items );
+        menu->items = NULL;
+    }
+    else
+    {
+        MENUITEM *new_items, *item = &menu->items[pos];
+
+	while (pos < menu->nItems)
+	{
+	    *item = *(item+1);
+	    item++;
+	    pos++;
+	}
+        new_items = HeapReAlloc( GetProcessHeap(), 0, menu->items, menu->nItems * sizeof(MENUITEM) );
+        if (new_items) menu->items = new_items;
+    }
+    release_menu_ptr(menu);
+
+    return TRUE;
+}
+
+
+/**********************************************************************
+ *         DeleteMenu    (USER32.@)
+ */
+BOOL WINAPI DeleteMenu( HMENU hMenu, UINT id, UINT flags )
+{
+    POPUPMENU *menu;
+    UINT pos;
+
+    if (!(menu = find_menu_item(hMenu, id, flags, &pos)))
+        return FALSE;
+
+    if (menu->items[pos].fType & MF_POPUP)
+        DestroyMenu(menu->items[pos].hSubMenu);
+
+    RemoveMenu(menu->obj.handle, pos, flags | MF_BYPOSITION);
+    release_menu_ptr(menu);
+    return TRUE;
+}
+
+
 /*******************************************************************
  *         ModifyMenuW    (USER32.@)
  */
@@ -3832,14 +4132,26 @@ BOOL WINAPI ModifyMenuW( HMENU hMenu, UINT pos, UINT flags,
                          UINT_PTR id, LPCWSTR str )
 {
     MENUITEMINFOW mii;
+    POPUPMENU *menu;
+    UINT item_pos;
+    BOOL ret;
 
     if (IS_STRING_ITEM(flags))
         TRACE("%p %d %04x %04Ix %s\n", hMenu, pos, flags, id, debugstr_w(str) );
     else
         TRACE("%p %d %04x %04Ix %p\n", hMenu, pos, flags, id, str );
 
+    if (!(menu = find_menu_item(hMenu, pos, flags, &item_pos)))
+    {
+        /* workaround for Word 95: pretend that SC_TASKLIST item exists */
+        if (pos == SC_TASKLIST && !(flags & MF_BYPOSITION)) return TRUE;
+        return FALSE;
+    }
+    menu->Height = 0; /* force size recalculate */
     MENU_mnu2mnuii( flags, id, str, &mii);
-    return NtUserThunkedMenuItemInfo( hMenu, pos, flags, NtUserSetMenuItemInfo, &mii, NULL );
+    ret = SetMenuItemInfo_common(&menu->items[item_pos], &mii, TRUE);
+    release_menu_ptr(menu);
+    return ret;
 }
 
 
@@ -3872,7 +4184,13 @@ BOOL WINAPI ModifyMenuA( HMENU hMenu, UINT pos, UINT flags,
  */
 HMENU WINAPI CreatePopupMenu(void)
 {
-    return NtUserCreateMenu( TRUE );
+    HMENU hmenu;
+    POPUPMENU *menu;
+
+    if (!(hmenu = CreateMenu())) return 0;
+    menu = MENU_GetMenu( hmenu );
+    menu->wFlags |= MF_POPUP;
+    return hmenu;
 }
 
 
@@ -3921,7 +4239,112 @@ BOOL WINAPI SetMenuItemBitmaps( HMENU hMenu, UINT nPos, UINT wFlags,
  */
 HMENU WINAPI CreateMenu(void)
 {
-    return NtUserCreateMenu( FALSE );
+    HMENU hMenu;
+    LPPOPUPMENU menu;
+
+    if (!(menu = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*menu) ))) return 0;
+    menu->FocusedItem = NO_SELECTED_ITEM;
+    menu->refcount = 1;
+
+    if (!(hMenu = alloc_user_handle( &menu->obj, NTUSER_OBJ_MENU ))) HeapFree( GetProcessHeap(), 0, menu );
+
+    TRACE("return %p\n", hMenu );
+
+    return hMenu;
+}
+
+
+/**********************************************************************
+ *         DestroyMenu    (USER32.@)
+ */
+BOOL WINAPI DestroyMenu( HMENU hMenu )
+{
+    LPPOPUPMENU lppop;
+
+    TRACE("(%p)\n", hMenu);
+
+    if (!(lppop = free_user_handle( hMenu, NTUSER_OBJ_MENU ))) return FALSE;
+    if (lppop == OBJ_OTHER_PROCESS) return FALSE;
+
+    /* DestroyMenu should not destroy system menu popup owner */
+    if ((lppop->wFlags & (MF_POPUP | MF_SYSMENU)) == MF_POPUP && lppop->hWnd)
+    {
+        NtUserDestroyWindow( lppop->hWnd );
+        lppop->hWnd = 0;
+    }
+
+    if (lppop->items) /* recursively destroy submenus */
+    {
+        int i;
+        MENUITEM *item = lppop->items;
+        for (i = lppop->nItems; i > 0; i--, item++)
+        {
+            if (item->fType & MF_POPUP) DestroyMenu(item->hSubMenu);
+            MENU_FreeItemData( item );
+        }
+        HeapFree( GetProcessHeap(), 0, lppop->items );
+    }
+    HeapFree( GetProcessHeap(), 0, lppop );
+    return TRUE;
+}
+
+
+/**********************************************************************
+ *         GetSystemMenu    (USER32.@)
+ */
+HMENU WINAPI GetSystemMenu( HWND hWnd, BOOL bRevert )
+{
+    WND *wndPtr = WIN_GetPtr( hWnd );
+    HMENU retvalue = 0;
+
+    if (wndPtr == WND_DESKTOP) return 0;
+    if (wndPtr == WND_OTHER_PROCESS)
+    {
+        if (IsWindow( hWnd )) FIXME( "not supported on other process window %p\n", hWnd );
+    }
+    else if (wndPtr)
+    {
+	if (wndPtr->hSysMenu && bRevert)
+	{
+            DestroyMenu(wndPtr->hSysMenu);
+            wndPtr->hSysMenu = 0;
+	}
+
+	if(!wndPtr->hSysMenu && (wndPtr->dwStyle & WS_SYSMENU) )
+	    wndPtr->hSysMenu = MENU_GetSysMenu( hWnd, 0 );
+
+	if( wndPtr->hSysMenu )
+        {
+	    POPUPMENU *menu;
+	    retvalue = GetSubMenu(wndPtr->hSysMenu, 0);
+
+	    /* Store the dummy sysmenu handle to facilitate the refresh */
+	    /* of the close button if the SC_CLOSE item change */
+	    menu = MENU_GetMenu(retvalue);
+	    if ( menu )
+	       menu->hSysMenuOwner = wndPtr->hSysMenu;
+        }
+        WIN_ReleasePtr( wndPtr );
+    }
+    return bRevert ? 0 : retvalue;
+}
+
+
+/*******************************************************************
+ *         SetSystemMenu    (USER32.@)
+ */
+BOOL WINAPI SetSystemMenu( HWND hwnd, HMENU hMenu )
+{
+    WND *wndPtr = WIN_GetPtr( hwnd );
+
+    if (wndPtr && wndPtr != WND_OTHER_PROCESS && wndPtr != WND_DESKTOP)
+    {
+	if (wndPtr->hSysMenu) DestroyMenu( wndPtr->hSysMenu );
+	wndPtr->hSysMenu = MENU_GetSysMenu( hwnd, hMenu );
+        WIN_ReleasePtr( wndPtr );
+	return TRUE;
+    }
+    return FALSE;
 }
 
 
@@ -3965,7 +4388,7 @@ BOOL WINAPI GetMenuBarInfo( HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO
         hmenu = GetMenu(hwnd);
         break;
     case OBJID_SYSMENU:
-        hmenu = NtUserGetSystemMenu( hwnd, FALSE );
+        hmenu = GetSystemMenu(hwnd, FALSE);
         break;
     default:
         return FALSE;
@@ -3992,13 +4415,13 @@ BOOL WINAPI GetMenuBarInfo( HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO
     }
     else if (idItem == 0)
     {
-        NtUserGetMenuItemRect( hwnd, hmenu, 0, &pmbi->rcBar );
+        GetMenuItemRect(hwnd, hmenu, 0, &pmbi->rcBar);
         pmbi->rcBar.right = pmbi->rcBar.left + menu->Width;
         pmbi->rcBar.bottom = pmbi->rcBar.top + menu->Height;
     }
     else
     {
-        NtUserGetMenuItemRect( hwnd, hmenu, idItem - 1, &pmbi->rcBar );
+        GetMenuItemRect(hwnd, hmenu, idItem - 1, &pmbi->rcBar);
     }
 
     pmbi->hMenu = hmenu;
@@ -4022,6 +4445,55 @@ BOOL WINAPI GetMenuBarInfo( HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO
     return TRUE;
 }
 
+/**********************************************************************
+ *         MENU_SetMenu
+ *
+ * Helper for SetMenu. Also called by WIN_CreateWindowEx to avoid the
+ * SetWindowPos call that would result if SetMenu were called directly.
+ */
+BOOL MENU_SetMenu( HWND hWnd, HMENU hMenu )
+{
+    TRACE("(%p, %p);\n", hWnd, hMenu);
+
+    if (hMenu && !IsMenu(hMenu))
+    {
+        WARN("hMenu %p is not a menu handle\n", hMenu);
+        return FALSE;
+    }
+    if (is_win_menu_disallowed(hWnd))
+        return FALSE;
+
+    hWnd = WIN_GetFullHandle( hWnd );
+    if (GetCapture() == hWnd)
+        set_capture_window( 0, GUI_INMENUMODE, NULL );  /* release the capture */
+
+    if (hMenu)
+    {
+        POPUPMENU *menu;
+
+        if (!(menu = grab_menu_ptr(hMenu))) return FALSE;
+        menu->hWnd = hWnd;
+        menu->Height = 0;  /* Make sure we recalculate the size */
+        release_menu_ptr(menu);
+    }
+    SetWindowLongPtrW( hWnd, GWLP_ID, (LONG_PTR)hMenu );
+    return TRUE;
+}
+
+
+/**********************************************************************
+ *         SetMenu    (USER32.@)
+ */
+BOOL WINAPI SetMenu( HWND hWnd, HMENU hMenu )
+{   
+    if(!MENU_SetMenu(hWnd, hMenu))
+        return FALSE;
+ 
+    NtUserSetWindowPos( hWnd, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE |
+                        SWP_NOACTIVATE | SWP_NOZORDER | SWP_FRAMECHANGED );
+    return TRUE;
+}
+
 
 /**********************************************************************
  *         GetSubMenu    (USER32.@)
@@ -4048,9 +4520,28 @@ HMENU WINAPI GetSubMenu( HMENU hMenu, INT nPos )
 /**********************************************************************
  *         DrawMenuBar    (USER32.@)
  */
-BOOL WINAPI DrawMenuBar( HWND hwnd )
+BOOL WINAPI DrawMenuBar( HWND hWnd )
 {
-    return NtUserDrawMenuBar( hwnd );
+    HMENU hMenu;
+
+    if (!IsWindow( hWnd ))
+        return FALSE;
+    if (is_win_menu_disallowed(hWnd))
+        return TRUE;
+
+    if ((hMenu = GetMenu( hWnd )))
+    {
+        POPUPMENU *menu = grab_menu_ptr(hMenu);
+        if (menu)
+        {
+            menu->Height = 0; /* Make sure we call MENU_MenuBarCalcSize */
+            menu->hwndOwner = hWnd;
+            release_menu_ptr(menu);
+        }
+    }
+
+    return NtUserSetWindowPos( hWnd, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE |
+                               SWP_NOACTIVATE | SWP_NOZORDER | SWP_FRAMECHANGED );
 }
 
 /***********************************************************************
@@ -4179,7 +4670,7 @@ HMENU WINAPI LoadMenuIndirectW( LPCVOID template )
 	if (!(hMenu = CreateMenu())) return 0;
 	if (!MENU_ParseResource( p, hMenu ))
 	  {
-            NtUserDestroyMenu( hMenu );
+	    DestroyMenu( hMenu );
 	    return 0;
 	  }
 	return hMenu;
@@ -4189,7 +4680,7 @@ HMENU WINAPI LoadMenuIndirectW( LPCVOID template )
 	if (!(hMenu = CreateMenu())) return 0;
 	if (!MENUEX_ParseResource( p, hMenu))
 	  {
-	    NtUserDestroyMenu( hMenu );
+	    DestroyMenu( hMenu );
 	    return 0;
 	  }
 	return hMenu;
@@ -4212,16 +4703,19 @@ HMENU WINAPI LoadMenuIndirectA( LPCVOID template )
 /**********************************************************************
  *		IsMenu    (USER32.@)
  */
-BOOL WINAPI IsMenu( HMENU menu )
+BOOL WINAPI IsMenu(HMENU hmenu)
 {
-    MENUINFO info;
+    POPUPMENU *menu;
+    BOOL is_menu;
 
-    info.cbSize = sizeof(info);
-    info.fMask = 0;
-    if (GetMenuInfo( menu, &info )) return TRUE;
+    menu = grab_menu_ptr(hmenu);
+    is_menu = menu != NULL;
+    release_menu_ptr(menu);
 
-    SetLastError(ERROR_INVALID_MENU_HANDLE);
-    return FALSE;
+    if (!is_menu)
+        SetLastError(ERROR_INVALID_MENU_HANDLE);
+
+    return is_menu;
 }
 
 /**********************************************************************
@@ -4385,6 +4879,126 @@ BOOL WINAPI GetMenuItemInfoW( HMENU hmenu, UINT item, BOOL bypos,
 }
 
 
+/* set a menu item text from an ANSI or Unicode string */
+static inline void set_menu_item_text( MENUITEM *menu, LPCWSTR text, BOOL unicode )
+{
+    if (!text)
+        menu->text = NULL;
+    else if (unicode)
+    {
+        if ((menu->text = HeapAlloc( GetProcessHeap(), 0, (lstrlenW(text)+1) * sizeof(WCHAR) )))
+            lstrcpyW( menu->text, text );
+    }
+    else
+    {
+        LPCSTR str = (LPCSTR)text;
+        int len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
+        if ((menu->text = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) )))
+            MultiByteToWideChar( CP_ACP, 0, str, -1, menu->text, len );
+    }
+}
+
+
+/**********************************************************************
+ *		MENU_depth
+ *
+ * detect if there are loops in the menu tree (or the depth is too large)
+ */
+static int MENU_depth( POPUPMENU *pmenu, int depth)
+{
+    UINT i;
+    MENUITEM *item;
+    int subdepth;
+
+    depth++;
+    if( depth > MAXMENUDEPTH) return depth;
+    item = pmenu->items;
+    subdepth = depth;
+    for( i = 0; i < pmenu->nItems && subdepth <= MAXMENUDEPTH; i++, item++){
+        POPUPMENU *psubmenu =  item->hSubMenu ? MENU_GetMenu( item->hSubMenu) : NULL;
+        if( psubmenu){
+            int bdepth = MENU_depth( psubmenu, depth);
+            if( bdepth > subdepth) subdepth = bdepth;
+        }
+        if( subdepth > MAXMENUDEPTH)
+            TRACE("<- hmenu %p\n", item->hSubMenu);
+    }
+    return subdepth;
+}
+
+
+/**********************************************************************
+ *		SetMenuItemInfo_common
+ *
+ * Note: does not support the MIIM_TYPE flag. Use the MIIM_FTYPE,
+ * MIIM_BITMAP and MIIM_STRING flags instead.
+ */
+
+static BOOL SetMenuItemInfo_common(MENUITEM * menu,
+				       const MENUITEMINFOW *lpmii,
+				       BOOL unicode)
+{
+    if (!menu) return FALSE;
+
+    debug_print_menuitem("SetMenuItemInfo_common from: ", menu, "");
+
+    if (lpmii->fMask & MIIM_FTYPE ) {
+        menu->fType &= ~MENUITEMINFO_TYPE_MASK;
+        menu->fType |= lpmii->fType & MENUITEMINFO_TYPE_MASK;
+    }
+    if (lpmii->fMask & MIIM_STRING ) {
+        /* free the string when used */
+        HeapFree(GetProcessHeap(), 0, menu->text);
+        set_menu_item_text( menu, lpmii->dwTypeData, unicode );
+    }
+
+    if (lpmii->fMask & MIIM_STATE)
+         /* Other menu items having MFS_DEFAULT are not converted
+           to normal items */
+         menu->fState = lpmii->fState & MENUITEMINFO_STATE_MASK;
+
+    if (lpmii->fMask & MIIM_ID)
+	menu->wID = lpmii->wID;
+
+    if (lpmii->fMask & MIIM_SUBMENU) {
+	menu->hSubMenu = lpmii->hSubMenu;
+	if (menu->hSubMenu) {
+	    POPUPMENU *subMenu = MENU_GetMenu(menu->hSubMenu);
+	    if (subMenu) {
+                if( MENU_depth( subMenu, 0) > MAXMENUDEPTH) {
+                    ERR( "Loop detected in menu hierarchy or maximum menu depth exceeded!\n");
+                    menu->hSubMenu = 0;
+                    return FALSE;
+                }
+		subMenu->wFlags |= MF_POPUP;
+		menu->fType |= MF_POPUP;
+	    } else {
+                SetLastError( ERROR_INVALID_PARAMETER);
+                return FALSE;
+            }
+	}
+	else
+	    menu->fType &= ~MF_POPUP;
+    }
+
+    if (lpmii->fMask & MIIM_CHECKMARKS)
+    {
+	menu->hCheckBit = lpmii->hbmpChecked;
+	menu->hUnCheckBit = lpmii->hbmpUnchecked;
+    }
+    if (lpmii->fMask & MIIM_DATA)
+	menu->dwItemData = lpmii->dwItemData;
+
+    if (lpmii->fMask & MIIM_BITMAP)
+	menu->hbmpItem = lpmii->hbmpItem;
+
+    if( !menu->text && !(menu->fType & MFT_OWNERDRAW) && !menu->hbmpItem)
+        menu->fType |= MFT_SEPARATOR;
+
+    debug_print_menuitem("SetMenuItemInfo_common to : ", menu, "");
+    return TRUE;
+}
+
 /**********************************************************************
  *		MENU_NormalizeMenuItemInfoStruct
  *
@@ -4435,27 +5049,23 @@ static BOOL MENU_NormalizeMenuItemInfoStruct( const MENUITEMINFOW *pmii_in,
 BOOL WINAPI SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL bypos,
                                  const MENUITEMINFOA *lpmii)
 {
-    WCHAR *strW = NULL;
     MENUITEMINFOW mii;
+    POPUPMENU *menu;
+    UINT pos;
     BOOL ret;
 
     TRACE("hmenu %p, item %u, by pos %d, info %p\n", hmenu, item, bypos, lpmii);
 
     if (!MENU_NormalizeMenuItemInfoStruct( (const MENUITEMINFOW *)lpmii, &mii )) return FALSE;
 
-    if ((mii.fMask & MIIM_STRING) && mii.dwTypeData)
+    if (!(menu = find_menu_item(hmenu, item, bypos ? MF_BYPOSITION : 0, &pos)))
     {
-        const char *str = (const char *)mii.dwTypeData;
-        UINT len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
-        if (!(strW = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) ))) return FALSE;
-        MultiByteToWideChar( CP_ACP, 0, str, -1, strW, len );
-        mii.dwTypeData = strW;
+        /* workaround for Word 95: pretend that SC_TASKLIST item exists */
+        if (item == SC_TASKLIST && !bypos) return TRUE;
+        return FALSE;
     }
-
-    ret = NtUserThunkedMenuItemInfo( hmenu, item, bypos ? MF_BYPOSITION : 0,
-                                     NtUserSetMenuItemInfo, &mii, NULL );
-
-    HeapFree( GetProcessHeap(), 0, strW );
+    ret = SetMenuItemInfo_common(&menu->items[pos], &mii, FALSE);
+    release_menu_ptr(menu);
     return ret;
 }
 
@@ -4466,13 +5076,80 @@ BOOL WINAPI SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL bypos,
                                  const MENUITEMINFOW *lpmii)
 {
     MENUITEMINFOW mii;
+    POPUPMENU *menu;
+    BOOL ret;
+    UINT pos;
 
     TRACE("hmenu %p, item %u, by pos %d, info %p\n", hmenu, item, bypos, lpmii);
 
     if (!MENU_NormalizeMenuItemInfoStruct( lpmii, &mii )) return FALSE;
 
-    return NtUserThunkedMenuItemInfo( hmenu, item, bypos ? MF_BYPOSITION : 0,
-                                      NtUserSetMenuItemInfo, &mii, NULL );
+    if (!(menu = find_menu_item(hmenu, item, bypos ? MF_BYPOSITION : 0, &pos)))
+    {
+        /* workaround for Word 95: pretend that SC_TASKLIST item exists */
+        if (item == SC_TASKLIST && !bypos) return TRUE;
+        return FALSE;
+    }
+
+    ret = SetMenuItemInfo_common(&menu->items[pos], &mii, TRUE);
+    release_menu_ptr(menu);
+    return ret;
+}
+
+static BOOL set_menu_default_item(POPUPMENU *menu, UINT uItem, UINT bypos)
+{
+    unsigned int i;
+    MENUITEM *item;
+
+    /* reset all default-item flags */
+    item = menu->items;
+    for (i = 0; i < menu->nItems; i++, item++)
+    {
+        item->fState &= ~MFS_DEFAULT;
+    }
+
+    /* no default item */
+    if (-1 == uItem)
+        return TRUE;
+
+    item = menu->items;
+    if ( bypos )
+    {
+        if ( uItem >= menu->nItems ) return FALSE;
+        item[uItem].fState |= MFS_DEFAULT;
+        return TRUE;
+    }
+    else
+    {
+        for (i = 0; i < menu->nItems; i++, item++)
+        {
+            if (item->wID == uItem)
+            {
+                item->fState |= MFS_DEFAULT;
+                return TRUE;
+            }
+        }
+    }
+
+    return FALSE;
+}
+
+/**********************************************************************
+ *		SetMenuDefaultItem    (USER32.@)
+ *
+ */
+BOOL WINAPI SetMenuDefaultItem(HMENU hmenu, UINT uItem, UINT bypos)
+{
+    POPUPMENU *menu;
+    BOOL ret;
+
+    TRACE("(%p,%d,%d)\n", hmenu, uItem, bypos);
+
+    if (!(menu = grab_menu_ptr(hmenu))) return FALSE;
+    ret = set_menu_default_item(menu, uItem, bypos);
+    release_menu_ptr(menu);
+
+    return ret;
 }
 
 /**********************************************************************
@@ -4523,27 +5200,20 @@ UINT WINAPI GetMenuDefaultItem(HMENU hmenu, UINT bypos, UINT flags)
 BOOL WINAPI InsertMenuItemA(HMENU hMenu, UINT uItem, BOOL bypos,
                                 const MENUITEMINFOA *lpmii)
 {
-    WCHAR *strW = NULL;
     MENUITEMINFOW mii;
+    POPUPMENU *menu;
+    UINT pos;
     BOOL ret;
 
     TRACE("hmenu %p, item %04x, by pos %d, info %p\n", hMenu, uItem, bypos, lpmii);
 
     if (!MENU_NormalizeMenuItemInfoStruct( (const MENUITEMINFOW *)lpmii, &mii )) return FALSE;
 
-    if ((mii.fMask & MIIM_STRING) && mii.dwTypeData)
-    {
-        const char *str = (const char *)mii.dwTypeData;
-        UINT len = MultiByteToWideChar( CP_ACP, 0, str, -1, NULL, 0 );
-        if (!(strW = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) ))) return FALSE;
-        MultiByteToWideChar( CP_ACP, 0, str, -1, strW, len );
-        mii.dwTypeData = strW;
-    }
-
-    ret = NtUserThunkedMenuItemInfo( hMenu, uItem, bypos ? MF_BYPOSITION : 0,
-                                     NtUserInsertMenuItem, &mii, NULL );
+    if (!(menu = insert_menu_item(hMenu, uItem, bypos ? MF_BYPOSITION : 0, &pos)))
+        return FALSE;
 
-    HeapFree( GetProcessHeap(), 0, strW );
+    ret = SetMenuItemInfo_common(&menu->items[pos], &mii, FALSE);
+    release_menu_ptr(menu);
     return ret;
 }
 
@@ -4555,13 +5225,20 @@ BOOL WINAPI InsertMenuItemW(HMENU hMenu, UINT uItem, BOOL bypos,
                                 const MENUITEMINFOW *lpmii)
 {
     MENUITEMINFOW mii;
+    POPUPMENU *menu;
+    UINT pos;
+    BOOL ret;
 
     TRACE("hmenu %p, item %04x, by pos %d, info %p\n", hMenu, uItem, bypos, lpmii);
 
     if (!MENU_NormalizeMenuItemInfoStruct( lpmii, &mii )) return FALSE;
 
-    return NtUserThunkedMenuItemInfo( hMenu, uItem, bypos ? MF_BYPOSITION : 0,
-                                      NtUserInsertMenuItem, &mii, NULL );
+    if (!(menu = insert_menu_item(hMenu, uItem, bypos ? MF_BYPOSITION : 0, &pos)))
+        return FALSE;
+
+    ret = SetMenuItemInfo_common(&menu->items[pos], &mii, TRUE);
+    release_menu_ptr(menu);
+    return ret;
 }
 
 /**********************************************************************
@@ -4616,27 +5293,156 @@ BOOL WINAPI CheckMenuRadioItem(HMENU hMenu, UINT first, UINT last,
 
 
 /**********************************************************************
- *		SetMenuInfo    (USER32.@)
+ *		GetMenuItemRect    (USER32.@)
+ *
+ *      ATTENTION: Here, the returned values in rect are the screen
+ *                 coordinates of the item just like if the menu was
+ *                 always on the upper left side of the application.
+ *
  */
-BOOL WINAPI SetMenuInfo( HMENU menu, const MENUINFO *info )
+BOOL WINAPI GetMenuItemRect(HWND hwnd, HMENU hMenu, UINT uItem, RECT *rect)
 {
-    TRACE( "(%p %p)\n", menu, info );
+    POPUPMENU *menu;
+    UINT pos;
+    RECT window_rect;
 
-    if (!info || info->cbSize != sizeof(*info))
+    TRACE("(%p,%p,%d,%p)\n", hwnd, hMenu, uItem, rect);
+
+    if (!rect)
+        return FALSE;
+
+    if (!(menu = find_menu_item(hMenu, uItem, MF_BYPOSITION, &pos)))
+        return FALSE;
+
+    if (!hwnd) hwnd = menu->hWnd;
+    if (!hwnd)
     {
-        SetLastError( ERROR_INVALID_PARAMETER);
+        release_menu_ptr(menu);
         return FALSE;
     }
 
-    return NtUserThunkedMenuInfo( menu, info );
+    *rect = menu->items[pos].rect;
+    OffsetRect(rect, menu->items_rect.left, menu->items_rect.top);
+
+    /* Popup menu item draws in the client area */
+    if (menu->wFlags & MF_POPUP) MapWindowPoints(hwnd, 0, (POINT *)rect, 2);
+    else
+    {
+        /* Sysmenu draws in the non-client area */
+        GetWindowRect(hwnd, &window_rect);
+        OffsetRect(rect, window_rect.left, window_rect.top);
+    }
+
+    release_menu_ptr(menu);
+    return TRUE;
+}
+
+/**********************************************************************
+ *		SetMenuInfo    (USER32.@)
+ *
+ * FIXME
+ *	actually use the items to draw the menu
+ *      (recalculate and/or redraw)
+ */
+static BOOL menu_SetMenuInfo( HMENU hMenu, LPCMENUINFO lpmi)
+{
+    POPUPMENU *menu;
+    if( !(menu = MENU_GetMenu(hMenu))) return FALSE;
+
+    if (lpmi->fMask & MIM_BACKGROUND)
+        menu->hbrBack = lpmi->hbrBack;
+
+    if (lpmi->fMask & MIM_HELPID)
+        menu->dwContextHelpID = lpmi->dwContextHelpID;
+
+    if (lpmi->fMask & MIM_MAXHEIGHT)
+        menu->cyMax = lpmi->cyMax;
+
+    if (lpmi->fMask & MIM_MENUDATA)
+        menu->dwMenuData = lpmi->dwMenuData;
+
+    if (lpmi->fMask & MIM_STYLE)
+        menu->dwStyle = lpmi->dwStyle;
+
+    if( lpmi->fMask & MIM_APPLYTOSUBMENUS) {
+        int i;
+        MENUITEM *item = menu->items;
+        for( i = menu->nItems; i; i--, item++)
+            if( item->fType & MF_POPUP)
+                menu_SetMenuInfo( item->hSubMenu, lpmi);
+    }
+    return TRUE;
+}
+
+BOOL WINAPI SetMenuInfo (HMENU hMenu, LPCMENUINFO lpmi)
+{
+    TRACE("(%p %p)\n", hMenu, lpmi);
+    if( lpmi && (lpmi->cbSize == sizeof( MENUINFO)) && (menu_SetMenuInfo( hMenu, lpmi))) {
+	if( lpmi->fMask & MIM_STYLE) {
+	    if (lpmi->dwStyle & MNS_AUTODISMISS) FIXME("MNS_AUTODISMISS unimplemented\n");
+	    if (lpmi->dwStyle & MNS_DRAGDROP) FIXME("MNS_DRAGDROP unimplemented\n");
+	    if (lpmi->dwStyle & MNS_MODELESS) FIXME("MNS_MODELESS unimplemented\n");
+	}
+        return TRUE;
+    }
+    SetLastError( ERROR_INVALID_PARAMETER);
+    return FALSE;
+}
+
+/**********************************************************************
+ *		GetMenuInfo    (USER32.@)
+ *
+ *  NOTES
+ *	win98/NT5.0
+ *
+ */
+BOOL WINAPI GetMenuInfo (HMENU hMenu, LPMENUINFO lpmi)
+{
+    POPUPMENU *menu;
+
+    TRACE("(%p %p)\n", hMenu, lpmi);
+
+    if (lpmi && (lpmi->cbSize == sizeof(MENUINFO)) && (menu = grab_menu_ptr(hMenu)))
+    {
+	if (lpmi->fMask & MIM_BACKGROUND)
+	    lpmi->hbrBack = menu->hbrBack;
+
+	if (lpmi->fMask & MIM_HELPID)
+	    lpmi->dwContextHelpID = menu->dwContextHelpID;
+
+	if (lpmi->fMask & MIM_MAXHEIGHT)
+	    lpmi->cyMax = menu->cyMax;
+
+	if (lpmi->fMask & MIM_MENUDATA)
+	    lpmi->dwMenuData = menu->dwMenuData;
+
+	if (lpmi->fMask & MIM_STYLE)
+	    lpmi->dwStyle = menu->dwStyle;
+
+        release_menu_ptr(menu);
+	return TRUE;
+    }
+    SetLastError( ERROR_INVALID_PARAMETER);
+    return FALSE;
 }
 
+
 /**********************************************************************
- *           GetMenuInfo    (USER32.@)
+ *         SetMenuContextHelpId    (USER32.@)
  */
-BOOL WINAPI GetMenuInfo( HMENU menu, MENUINFO *info )
+BOOL WINAPI SetMenuContextHelpId( HMENU hMenu, DWORD dwContextHelpID)
 {
-    return NtUserGetMenuInfo( menu, info );
+    POPUPMENU *menu;
+
+    TRACE("(%p 0x%08x)\n", hMenu, dwContextHelpID);
+
+    if ((menu = grab_menu_ptr(hMenu)))
+    {
+        menu->dwContextHelpID = dwContextHelpID;
+        release_menu_ptr(menu);
+        return TRUE;
+    }
+    return FALSE;
 }
 
 
@@ -4688,6 +5494,170 @@ DWORD WINAPI CalcMenuBar(HWND hwnd, DWORD left, DWORD right, DWORD top, RECT *re
 }
 
 
+/**********************************************************************
+ *           translate_accelerator
+ */
+static BOOL translate_accelerator( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam,
+                                   BYTE fVirt, WORD key, WORD cmd )
+{
+    INT mask = 0;
+    UINT mesg = 0;
+
+    if (wParam != key) return FALSE;
+
+    if (NtUserGetKeyState(VK_CONTROL) & 0x8000) mask |= FCONTROL;
+    if (NtUserGetKeyState(VK_MENU) & 0x8000) mask |= FALT;
+    if (NtUserGetKeyState(VK_SHIFT) & 0x8000) mask |= FSHIFT;
+
+    if (message == WM_CHAR || message == WM_SYSCHAR)
+    {
+        if ( !(fVirt & FVIRTKEY) && (mask & FALT) == (fVirt & FALT) )
+        {
+            TRACE_(accel)("found accel for WM_CHAR: ('%c')\n", LOWORD(wParam) & 0xff);
+            goto found;
+        }
+    }
+    else
+    {
+        if(fVirt & FVIRTKEY)
+        {
+            TRACE_(accel)("found accel for virt_key %04lx (scan %04x)\n",
+                          wParam, 0xff & HIWORD(lParam));
+
+            if(mask == (fVirt & (FSHIFT | FCONTROL | FALT))) goto found;
+            TRACE_(accel)(", but incorrect SHIFT/CTRL/ALT-state\n");
+        }
+        else
+        {
+            if (!(lParam & 0x01000000))  /* no special_key */
+            {
+                if ((fVirt & FALT) && (lParam & 0x20000000))
+                {                              /* ^^ ALT pressed */
+                    TRACE_(accel)("found accel for Alt-%c\n", LOWORD(wParam) & 0xff);
+                    goto found;
+                }
+            }
+        }
+    }
+    return FALSE;
+
+ found:
+    if (message == WM_KEYUP || message == WM_SYSKEYUP)
+        mesg = 1;
+    else
+    {
+        HMENU hMenu, hSubMenu, hSysMenu;
+        UINT uSysStat = (UINT)-1, uStat = (UINT)-1, nPos;
+        POPUPMENU *menu;
+
+        hMenu = (GetWindowLongW( hWnd, GWL_STYLE ) & WS_CHILD) ? 0 : GetMenu(hWnd);
+        hSysMenu = get_win_sys_menu( hWnd );
+
+        /* find menu item and ask application to initialize it */
+        /* 1. in the system menu */
+        if ((menu = find_menu_item(hSysMenu, cmd, MF_BYCOMMAND, NULL)))
+        {
+            hSubMenu = menu->obj.handle;
+            release_menu_ptr(menu);
+
+            if (GetCapture())
+                mesg = 2;
+            if (!IsWindowEnabled(hWnd))
+                mesg = 3;
+            else
+            {
+                SendMessageW(hWnd, WM_INITMENU, (WPARAM)hSysMenu, 0L);
+                if(hSubMenu != hSysMenu)
+                {
+                    nPos = MENU_FindSubMenu(&hSysMenu, hSubMenu);
+                    TRACE_(accel)("hSysMenu = %p, hSubMenu = %p, nPos = %d\n", hSysMenu, hSubMenu, nPos);
+                    SendMessageW(hWnd, WM_INITMENUPOPUP, (WPARAM)hSubMenu, MAKELPARAM(nPos, TRUE));
+                }
+                uSysStat = GetMenuState(GetSubMenu(hSysMenu, 0), cmd, MF_BYCOMMAND);
+            }
+        }
+        else /* 2. in the window's menu */
+        {
+            if ((menu = find_menu_item(hMenu, cmd, MF_BYCOMMAND, NULL)))
+            {
+                hSubMenu = menu->obj.handle;
+                release_menu_ptr(menu);
+
+                if (GetCapture())
+                    mesg = 2;
+                if (!IsWindowEnabled(hWnd))
+                    mesg = 3;
+                else
+                {
+                    SendMessageW(hWnd, WM_INITMENU, (WPARAM)hMenu, 0L);
+                    if(hSubMenu != hMenu)
+                    {
+                        nPos = MENU_FindSubMenu(&hMenu, hSubMenu);
+                        TRACE_(accel)("hMenu = %p, hSubMenu = %p, nPos = %d\n", hMenu, hSubMenu, nPos);
+                        SendMessageW(hWnd, WM_INITMENUPOPUP, (WPARAM)hSubMenu, MAKELPARAM(nPos, FALSE));
+                    }
+                    uStat = GetMenuState(hMenu, cmd, MF_BYCOMMAND);
+                }
+            }
+        }
+
+        if (mesg == 0)
+        {
+            if (uSysStat != (UINT)-1)
+            {
+                if (uSysStat & (MF_DISABLED|MF_GRAYED))
+                    mesg=4;
+                else
+                    mesg=WM_SYSCOMMAND;
+            }
+            else
+            {
+                if (uStat != (UINT)-1)
+                {
+                    if (IsIconic(hWnd))
+                        mesg=5;
+                    else
+                    {
+                        if (uStat & (MF_DISABLED|MF_GRAYED))
+                            mesg=6;
+                        else
+                            mesg=WM_COMMAND;
+                    }
+                }
+                else
+                    mesg=WM_COMMAND;
+            }
+        }
+    }
+
+    if( mesg==WM_COMMAND )
+    {
+        TRACE_(accel)(", sending WM_COMMAND, wParam=%0x\n", 0x10000 | cmd);
+        SendMessageW(hWnd, mesg, 0x10000 | cmd, 0L);
+    }
+    else if( mesg==WM_SYSCOMMAND )
+    {
+        TRACE_(accel)(", sending WM_SYSCOMMAND, wParam=%0x\n", cmd);
+        SendMessageW(hWnd, mesg, cmd, 0x00010000L);
+    }
+    else
+    {
+        /*  some reasons for NOT sending the WM_{SYS}COMMAND message:
+         *   #0: unknown (please report!)
+         *   #1: for WM_KEYUP,WM_SYSKEYUP
+         *   #2: mouse is captured
+         *   #3: window is disabled
+         *   #4: it's a disabled system menu option
+         *   #5: it's a menu option, but window is iconic
+         *   #6: it's a menu option, but disabled
+         */
+        TRACE_(accel)(", but won't send WM_{SYS}COMMAND, reason is #%d\n",mesg);
+        if(mesg==0)
+            ERR_(accel)(" unknown reason - please report!\n");
+    }
+    return TRUE;
+}
+
 /**********************************************************************
  *      TranslateAcceleratorA     (USER32.@)
  *      TranslateAccelerator      (USER32.@)
@@ -4698,7 +5668,7 @@ INT WINAPI TranslateAcceleratorA( HWND hWnd, HACCEL hAccel, LPMSG msg )
     {
     case WM_KEYDOWN:
     case WM_SYSKEYDOWN:
-        return NtUserTranslateAccelerator( hWnd, hAccel, msg );
+        return TranslateAcceleratorW( hWnd, hAccel, msg );
 
     case WM_CHAR:
     case WM_SYSCHAR:
@@ -4708,10 +5678,45 @@ INT WINAPI TranslateAcceleratorA( HWND hWnd, HACCEL hAccel, LPMSG msg )
             WCHAR wch;
             MultiByteToWideChar(CP_ACP, 0, &ch, 1, &wch, 1);
             msgW.wParam = MAKEWPARAM(wch, HIWORD(msg->wParam));
-            return NtUserTranslateAccelerator( hWnd, hAccel, &msgW );
+            return TranslateAcceleratorW( hWnd, hAccel, &msgW );
         }
 
     default:
         return 0;
     }
 }
+
+/**********************************************************************
+ *      TranslateAcceleratorW     (USER32.@)
+ */
+INT WINAPI TranslateAcceleratorW( HWND hWnd, HACCEL hAccel, LPMSG msg )
+{
+    ACCEL data[32], *ptr = data;
+    int i, count;
+
+    if (!hWnd) return 0;
+
+    if (msg->message != WM_KEYDOWN &&
+        msg->message != WM_SYSKEYDOWN &&
+        msg->message != WM_CHAR &&
+        msg->message != WM_SYSCHAR)
+        return 0;
+
+    TRACE_(accel)("hAccel %p, hWnd %p, msg->hwnd %p, msg->message %04x, wParam %08lx, lParam %08lx\n",
+                  hAccel,hWnd,msg->hwnd,msg->message,msg->wParam,msg->lParam);
+
+    if (!(count = NtUserCopyAcceleratorTable( hAccel, NULL, 0 ))) return 0;
+    if (count > ARRAY_SIZE( data ))
+    {
+        if (!(ptr = HeapAlloc( GetProcessHeap(), 0, count * sizeof(*ptr) ))) return 0;
+    }
+    count = NtUserCopyAcceleratorTable( hAccel, ptr, count );
+    for (i = 0; i < count; i++)
+    {
+        if (translate_accelerator( hWnd, msg->message, msg->wParam, msg->lParam,
+                                   ptr[i].fVirt, ptr[i].key, ptr[i].cmd))
+            break;
+    }
+    if (ptr != data) HeapFree( GetProcessHeap(), 0, ptr );
+    return (i < count);
+}
diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 02c40f2ca4f..b2190eb53da 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -45,6 +45,239 @@
 #include "wine/exception.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(msg);
+WINE_DECLARE_DEBUG_CHANNEL(relay);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+#define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
+#define WM_NCMOUSELAST  (WM_NCMOUSEFIRST+(WM_MOUSELAST-WM_MOUSEFIRST))
+
+#define MAX_PACK_COUNT 4
+
+/* the various structures that can be sent in messages, in platform-independent layout */
+struct packed_CREATESTRUCTW
+{
+    ULONGLONG     lpCreateParams;
+    ULONGLONG     hInstance;
+    user_handle_t hMenu;
+    DWORD         __pad1;
+    user_handle_t hwndParent;
+    DWORD         __pad2;
+    INT           cy;
+    INT           cx;
+    INT           y;
+    INT           x;
+    LONG          style;
+    ULONGLONG     lpszName;
+    ULONGLONG     lpszClass;
+    DWORD         dwExStyle;
+    DWORD         __pad3;
+};
+
+struct packed_DRAWITEMSTRUCT
+{
+    UINT          CtlType;
+    UINT          CtlID;
+    UINT          itemID;
+    UINT          itemAction;
+    UINT          itemState;
+    user_handle_t hwndItem;
+    DWORD         __pad1;
+    user_handle_t hDC;
+    DWORD         __pad2;
+    RECT          rcItem;
+    ULONGLONG     itemData;
+};
+
+struct packed_MEASUREITEMSTRUCT
+{
+    UINT          CtlType;
+    UINT          CtlID;
+    UINT          itemID;
+    UINT          itemWidth;
+    UINT          itemHeight;
+    ULONGLONG     itemData;
+};
+
+struct packed_DELETEITEMSTRUCT
+{
+    UINT          CtlType;
+    UINT          CtlID;
+    UINT          itemID;
+    user_handle_t hwndItem;
+    DWORD         __pad;
+    ULONGLONG     itemData;
+};
+
+struct packed_COMPAREITEMSTRUCT
+{
+    UINT          CtlType;
+    UINT          CtlID;
+    user_handle_t hwndItem;
+    DWORD         __pad1;
+    UINT          itemID1;
+    ULONGLONG     itemData1;
+    UINT          itemID2;
+    ULONGLONG     itemData2;
+    DWORD         dwLocaleId;
+    DWORD         __pad2;
+};
+
+struct packed_WINDOWPOS
+{
+    user_handle_t hwnd;
+    DWORD         __pad1;
+    user_handle_t hwndInsertAfter;
+    DWORD         __pad2;
+    INT           x;
+    INT           y;
+    INT           cx;
+    INT           cy;
+    UINT          flags;
+    DWORD         __pad3;
+};
+
+struct packed_COPYDATASTRUCT
+{
+    ULONGLONG dwData;
+    DWORD     cbData;
+    ULONGLONG lpData;
+};
+
+struct packed_HELPINFO
+{
+    UINT          cbSize;
+    INT           iContextType;
+    INT           iCtrlId;
+    user_handle_t hItemHandle;
+    DWORD         __pad;
+    ULONGLONG     dwContextId;
+    POINT         MousePos;
+};
+
+struct packed_NCCALCSIZE_PARAMS
+{
+    RECT          rgrc[3];
+    ULONGLONG     __pad1;
+    user_handle_t hwnd;
+    DWORD         __pad2;
+    user_handle_t hwndInsertAfter;
+    DWORD         __pad3;
+    INT           x;
+    INT           y;
+    INT           cx;
+    INT           cy;
+    UINT          flags;
+    DWORD         __pad4;
+};
+
+struct packed_MSG
+{
+    user_handle_t hwnd;
+    DWORD         __pad1;
+    UINT          message;
+    ULONGLONG     wParam;
+    ULONGLONG     lParam;
+    DWORD         time;
+    POINT         pt;
+    DWORD         __pad2;
+};
+
+struct packed_MDINEXTMENU
+{
+    user_handle_t hmenuIn;
+    DWORD         __pad1;
+    user_handle_t hmenuNext;
+    DWORD         __pad2;
+    user_handle_t hwndNext;
+    DWORD         __pad3;
+};
+
+struct packed_MDICREATESTRUCTW
+{
+    ULONGLONG szClass;
+    ULONGLONG szTitle;
+    ULONGLONG hOwner;
+    INT       x;
+    INT       y;
+    INT       cx;
+    INT       cy;
+    DWORD     style;
+    ULONGLONG lParam;
+};
+
+struct packed_hook_extra_info
+{
+    user_handle_t handle;
+    DWORD         __pad;
+    ULONGLONG     lparam;
+};
+
+/* the structures are unpacked on top of the packed ones, so make sure they fit */
+C_ASSERT( sizeof(struct packed_CREATESTRUCTW) >= sizeof(CREATESTRUCTW) );
+C_ASSERT( sizeof(struct packed_DRAWITEMSTRUCT) >= sizeof(DRAWITEMSTRUCT) );
+C_ASSERT( sizeof(struct packed_MEASUREITEMSTRUCT) >= sizeof(MEASUREITEMSTRUCT) );
+C_ASSERT( sizeof(struct packed_DELETEITEMSTRUCT) >= sizeof(DELETEITEMSTRUCT) );
+C_ASSERT( sizeof(struct packed_COMPAREITEMSTRUCT) >= sizeof(COMPAREITEMSTRUCT) );
+C_ASSERT( sizeof(struct packed_WINDOWPOS) >= sizeof(WINDOWPOS) );
+C_ASSERT( sizeof(struct packed_COPYDATASTRUCT) >= sizeof(COPYDATASTRUCT) );
+C_ASSERT( sizeof(struct packed_HELPINFO) >= sizeof(HELPINFO) );
+C_ASSERT( sizeof(struct packed_NCCALCSIZE_PARAMS) >= sizeof(NCCALCSIZE_PARAMS) + sizeof(WINDOWPOS) );
+C_ASSERT( sizeof(struct packed_MSG) >= sizeof(MSG) );
+C_ASSERT( sizeof(struct packed_MDINEXTMENU) >= sizeof(MDINEXTMENU) );
+C_ASSERT( sizeof(struct packed_MDICREATESTRUCTW) >= sizeof(MDICREATESTRUCTW) );
+C_ASSERT( sizeof(struct packed_hook_extra_info) >= sizeof(struct hook_extra_info) );
+
+union packed_structs
+{
+    struct packed_CREATESTRUCTW cs;
+    struct packed_DRAWITEMSTRUCT dis;
+    struct packed_MEASUREITEMSTRUCT mis;
+    struct packed_DELETEITEMSTRUCT dls;
+    struct packed_COMPAREITEMSTRUCT cis;
+    struct packed_WINDOWPOS wp;
+    struct packed_COPYDATASTRUCT cds;
+    struct packed_HELPINFO hi;
+    struct packed_NCCALCSIZE_PARAMS ncp;
+    struct packed_MSG msg;
+    struct packed_MDINEXTMENU mnm;
+    struct packed_MDICREATESTRUCTW mcs;
+    struct packed_hook_extra_info hook;
+};
+
+/* description of the data fields that need to be packed along with a sent message */
+struct packed_message
+{
+    union packed_structs ps;
+    int                  count;
+    const void          *data[MAX_PACK_COUNT];
+    size_t               size[MAX_PACK_COUNT];
+};
+
+/* info about the message currently being received by the current thread */
+struct received_message_info
+{
+    enum message_type type;
+    MSG               msg;
+    UINT              flags;  /* InSendMessageEx return flags */
+};
+
+/* structure to group all parameters for sent messages of the various kinds */
+struct send_message_info
+{
+    enum message_type type;
+    DWORD             dest_tid;
+    HWND              hwnd;
+    UINT              msg;
+    WPARAM            wparam;
+    LPARAM            lparam;
+    UINT              flags;      /* flags for SendMessageTimeout */
+    UINT              timeout;    /* timeout for SendMessageTimeout */
+    SENDASYNCPROC     callback;   /* callback function for SendMessageCallback */
+    ULONG_PTR         data;       /* callback data */
+    enum wm_char_mapping wm_char;
+};
+
+static const INPUT_MESSAGE_SOURCE msg_source_unavailable = { IMDT_UNAVAILABLE, IMO_UNAVAILABLE };
 
 
 /* Message class descriptor */
@@ -59,6 +292,170 @@ const struct builtin_class_descr MESSAGE_builtin_class =
 };
 
 
+
+/* flag for messages that contain pointers */
+/* 32 messages per entry, messages 0..31 map to bits 0..31 */
+
+#define SET(msg) (1 << ((msg) & 31))
+
+static const unsigned int message_pointer_flags[] =
+{
+    /* 0x00 - 0x1f */
+    SET(WM_CREATE) | SET(WM_SETTEXT) | SET(WM_GETTEXT) |
+    SET(WM_WININICHANGE) | SET(WM_DEVMODECHANGE),
+    /* 0x20 - 0x3f */
+    SET(WM_GETMINMAXINFO) | SET(WM_DRAWITEM) | SET(WM_MEASUREITEM) | SET(WM_DELETEITEM) |
+    SET(WM_COMPAREITEM),
+    /* 0x40 - 0x5f */
+    SET(WM_WINDOWPOSCHANGING) | SET(WM_WINDOWPOSCHANGED) | SET(WM_COPYDATA) | SET(WM_HELP),
+    /* 0x60 - 0x7f */
+    SET(WM_STYLECHANGING) | SET(WM_STYLECHANGED),
+    /* 0x80 - 0x9f */
+    SET(WM_NCCREATE) | SET(WM_NCCALCSIZE) | SET(WM_GETDLGCODE),
+    /* 0xa0 - 0xbf */
+    SET(EM_GETSEL) | SET(EM_GETRECT) | SET(EM_SETRECT) | SET(EM_SETRECTNP),
+    /* 0xc0 - 0xdf */
+    SET(EM_REPLACESEL) | SET(EM_GETLINE) | SET(EM_SETTABSTOPS),
+    /* 0xe0 - 0xff */
+    SET(SBM_GETRANGE) | SET(SBM_SETSCROLLINFO) | SET(SBM_GETSCROLLINFO) | SET(SBM_GETSCROLLBARINFO),
+    /* 0x100 - 0x11f */
+    0,
+    /* 0x120 - 0x13f */
+    0,
+    /* 0x140 - 0x15f */
+    SET(CB_GETEDITSEL) | SET(CB_ADDSTRING) | SET(CB_DIR) | SET(CB_GETLBTEXT) |
+    SET(CB_INSERTSTRING) | SET(CB_FINDSTRING) | SET(CB_SELECTSTRING) |
+    SET(CB_GETDROPPEDCONTROLRECT) | SET(CB_FINDSTRINGEXACT),
+    /* 0x160 - 0x17f */
+    0,
+    /* 0x180 - 0x19f */
+    SET(LB_ADDSTRING) | SET(LB_INSERTSTRING) | SET(LB_GETTEXT) | SET(LB_SELECTSTRING) |
+    SET(LB_DIR) | SET(LB_FINDSTRING) |
+    SET(LB_GETSELITEMS) | SET(LB_SETTABSTOPS) | SET(LB_ADDFILE) | SET(LB_GETITEMRECT),
+    /* 0x1a0 - 0x1bf */
+    SET(LB_FINDSTRINGEXACT),
+    /* 0x1c0 - 0x1df */
+    0,
+    /* 0x1e0 - 0x1ff */
+    0,
+    /* 0x200 - 0x21f */
+    SET(WM_NEXTMENU) | SET(WM_SIZING) | SET(WM_MOVING) | SET(WM_DEVICECHANGE),
+    /* 0x220 - 0x23f */
+    SET(WM_MDICREATE) | SET(WM_MDIGETACTIVE) | SET(WM_DROPOBJECT) |
+    SET(WM_QUERYDROPOBJECT) | SET(WM_DRAGLOOP) | SET(WM_DRAGSELECT) | SET(WM_DRAGMOVE),
+    /* 0x240 - 0x25f */
+    0,
+    /* 0x260 - 0x27f */
+    0,
+    /* 0x280 - 0x29f */
+    0,
+    /* 0x2a0 - 0x2bf */
+    0,
+    /* 0x2c0 - 0x2df */
+    0,
+    /* 0x2e0 - 0x2ff */
+    0,
+    /* 0x300 - 0x31f */
+    SET(WM_ASKCBFORMATNAME)
+};
+
+/* flags for messages that contain Unicode strings */
+static const unsigned int message_unicode_flags[] =
+{
+    /* 0x00 - 0x1f */
+    SET(WM_CREATE) | SET(WM_SETTEXT) | SET(WM_GETTEXT) | SET(WM_GETTEXTLENGTH) |
+    SET(WM_WININICHANGE) | SET(WM_DEVMODECHANGE),
+    /* 0x20 - 0x3f */
+    SET(WM_CHARTOITEM),
+    /* 0x40 - 0x5f */
+    0,
+    /* 0x60 - 0x7f */
+    0,
+    /* 0x80 - 0x9f */
+    SET(WM_NCCREATE),
+    /* 0xa0 - 0xbf */
+    0,
+    /* 0xc0 - 0xdf */
+    SET(EM_REPLACESEL) | SET(EM_GETLINE) | SET(EM_SETPASSWORDCHAR),
+    /* 0xe0 - 0xff */
+    0,
+    /* 0x100 - 0x11f */
+    SET(WM_CHAR) | SET(WM_DEADCHAR) | SET(WM_SYSCHAR) | SET(WM_SYSDEADCHAR),
+    /* 0x120 - 0x13f */
+    SET(WM_MENUCHAR),
+    /* 0x140 - 0x15f */
+    SET(CB_ADDSTRING) | SET(CB_DIR) | SET(CB_GETLBTEXT) | SET(CB_GETLBTEXTLEN) |
+    SET(CB_INSERTSTRING) | SET(CB_FINDSTRING) | SET(CB_SELECTSTRING) | SET(CB_FINDSTRINGEXACT),
+    /* 0x160 - 0x17f */
+    0,
+    /* 0x180 - 0x19f */
+    SET(LB_ADDSTRING) | SET(LB_INSERTSTRING) | SET(LB_GETTEXT) | SET(LB_GETTEXTLEN) |
+    SET(LB_SELECTSTRING) | SET(LB_DIR) | SET(LB_FINDSTRING) | SET(LB_ADDFILE),
+    /* 0x1a0 - 0x1bf */
+    SET(LB_FINDSTRINGEXACT),
+    /* 0x1c0 - 0x1df */
+    0,
+    /* 0x1e0 - 0x1ff */
+    0,
+    /* 0x200 - 0x21f */
+    0,
+    /* 0x220 - 0x23f */
+    SET(WM_MDICREATE),
+    /* 0x240 - 0x25f */
+    0,
+    /* 0x260 - 0x27f */
+    0,
+    /* 0x280 - 0x29f */
+    SET(WM_IME_CHAR),
+    /* 0x2a0 - 0x2bf */
+    0,
+    /* 0x2c0 - 0x2df */
+    0,
+    /* 0x2e0 - 0x2ff */
+    0,
+    /* 0x300 - 0x31f */
+    SET(WM_PAINTCLIPBOARD) | SET(WM_SIZECLIPBOARD) | SET(WM_ASKCBFORMATNAME)
+};
+
+/* check whether a given message type includes pointers */
+static inline BOOL is_pointer_message( UINT message, WPARAM wparam )
+{
+    if (message >= 8*sizeof(message_pointer_flags)) return FALSE;
+    if (message == WM_DEVICECHANGE && !(wparam & 0x8000)) return FALSE;
+    return (message_pointer_flags[message / 32] & SET(message)) != 0;
+}
+
+/* check whether a given message type contains Unicode (or ASCII) chars */
+static inline BOOL is_unicode_message( UINT message )
+{
+    if (message >= 8*sizeof(message_unicode_flags)) return FALSE;
+    return (message_unicode_flags[message / 32] & SET(message)) != 0;
+}
+
+#undef SET
+
+/* add a data field to a packed message */
+static inline void push_data( struct packed_message *data, const void *ptr, size_t size )
+{
+    data->data[data->count] = ptr;
+    data->size[data->count] = size;
+    data->count++;
+}
+
+/* add a string to a packed message */
+static inline void push_string( struct packed_message *data, LPCWSTR str )
+{
+    push_data( data, str, (lstrlenW(str) + 1) * sizeof(WCHAR) );
+}
+
+/* make sure that the buffer contains a valid null-terminated Unicode string */
+static inline BOOL check_string( LPCWSTR str, size_t size )
+{
+    for (size /= sizeof(WCHAR); size; size--, str++)
+        if (!*str) return TRUE;
+    return FALSE;
+}
+
 /* pack a pointer into a 32/64 portable format */
 static inline ULONGLONG pack_ptr( const void *ptr )
 {
@@ -72,6 +469,56 @@ static inline void *unpack_ptr( ULONGLONG ptr64 )
     return (void *)(ULONG_PTR)ptr64;
 }
 
+/* make sure that there is space for 'size' bytes in buffer, growing it if needed */
+static inline void *get_buffer_space( void **buffer, size_t size )
+{
+    void *ret;
+
+    if (*buffer)
+    {
+        if (!(ret = HeapReAlloc( GetProcessHeap(), 0, *buffer, size )))
+            HeapFree( GetProcessHeap(), 0, *buffer );
+    }
+    else ret = HeapAlloc( GetProcessHeap(), 0, size );
+
+    *buffer = ret;
+    return ret;
+}
+
+/* check whether a combobox expects strings or ids in CB_ADDSTRING/CB_INSERTSTRING */
+static inline BOOL combobox_has_strings( HWND hwnd )
+{
+    DWORD style = GetWindowLongA( hwnd, GWL_STYLE );
+    return (!(style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)) || (style & CBS_HASSTRINGS));
+}
+
+/* check whether a listbox expects strings or ids in LB_ADDSTRING/LB_INSERTSTRING */
+static inline BOOL listbox_has_strings( HWND hwnd )
+{
+    DWORD style = GetWindowLongA( hwnd, GWL_STYLE );
+    return (!(style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)) || (style & LBS_HASSTRINGS));
+}
+
+/* check whether message is in the range of keyboard messages */
+static inline BOOL is_keyboard_message( UINT message )
+{
+    return (message >= WM_KEYFIRST && message <= WM_KEYLAST);
+}
+
+/* check whether message is in the range of mouse messages */
+static inline BOOL is_mouse_message( UINT message )
+{
+    return ((message >= WM_NCMOUSEFIRST && message <= WM_NCMOUSELAST) ||
+            (message >= WM_MOUSEFIRST && message <= WM_MOUSELAST));
+}
+
+/* check whether message matches the specified hwnd filter */
+static inline BOOL check_hwnd_filter( const MSG *msg, HWND hwnd_filter )
+{
+    if (!hwnd_filter || hwnd_filter == GetDesktopWindow()) return TRUE;
+    return (msg->hwnd == hwnd_filter || IsChild( hwnd_filter, msg->hwnd ));
+}
+
 /* check for pending WM_CHAR message with DBCS trailing byte */
 static inline BOOL get_pending_wmchar( MSG *msg, UINT first, UINT last, BOOL remove )
 {
@@ -98,6 +545,43 @@ LRESULT WINAPI MessageWndProc( HWND hwnd, UINT message, WPARAM wParam, LPARAM lP
 }
 
 
+/***********************************************************************
+ *		broadcast_message_callback
+ *
+ * Helper callback for broadcasting messages.
+ */
+static BOOL CALLBACK broadcast_message_callback( HWND hwnd, LPARAM lparam )
+{
+    struct send_message_info *info = (struct send_message_info *)lparam;
+    if ((GetWindowLongW( hwnd, GWL_STYLE ) & (WS_POPUP|WS_CHILD)) == WS_CHILD)
+        return TRUE;
+    switch(info->type)
+    {
+    case MSG_UNICODE:
+        SendMessageTimeoutW( hwnd, info->msg, info->wparam, info->lparam,
+                             info->flags, info->timeout, NULL );
+        break;
+    case MSG_ASCII:
+        SendMessageTimeoutA( hwnd, info->msg, info->wparam, info->lparam,
+                             info->flags, info->timeout, NULL );
+        break;
+    case MSG_NOTIFY:
+        SendNotifyMessageW( hwnd, info->msg, info->wparam, info->lparam );
+        break;
+    case MSG_CALLBACK:
+        SendMessageCallbackW( hwnd, info->msg, info->wparam, info->lparam,
+                              info->callback, info->data );
+        break;
+    case MSG_POSTED:
+        PostMessageW( hwnd, info->msg, info->wparam, info->lparam );
+        break;
+    default:
+        ERR( "bad type %d\n", info->type );
+        break;
+    }
+    return TRUE;
+}
+
 DWORD get_input_codepage( void )
 {
     DWORD cp;
@@ -265,195 +749,2284 @@ static void map_wparam_WtoA( MSG *msg, BOOL remove )
 }
 
 
-/* since the WM_DDE_ACK response to a WM_DDE_EXECUTE message should contain the handle
- * to the memory handle, we keep track (in the server side) of all pairs of handle
- * used (the client passes its value and the content of the memory handle), and
- * the server stored both values (the client, and the local one, created after the
- * content). When a ACK message is generated, the list of pair is searched for a
- * matching pair, so that the client memory handle can be returned.
+/***********************************************************************
+ *		pack_message
+ *
+ * Pack a message for sending to another process.
+ * Return the size of the data we expect in the message reply.
+ * Set data->count to -1 if there is an error.
  */
-struct DDE_pair {
-    HGLOBAL     client_hMem;
-    HGLOBAL     server_hMem;
-};
-
-static      struct DDE_pair*    dde_pairs;
-static      int                 dde_num_alloc;
-static      int                 dde_num_used;
-
-static CRITICAL_SECTION dde_crst;
-static CRITICAL_SECTION_DEBUG critsect_debug =
-{
-    0, 0, &dde_crst,
-    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
-      0, 0, { (DWORD_PTR)(__FILE__ ": dde_crst") }
-};
-static CRITICAL_SECTION dde_crst = { &critsect_debug, -1, 0, 0, 0, 0 };
-
-static BOOL dde_add_pair(HGLOBAL chm, HGLOBAL shm)
+static size_t pack_message( HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam,
+                            struct packed_message *data )
 {
-    int  i;
-#define GROWBY  4
-
-    EnterCriticalSection(&dde_crst);
-
-    /* now remember the pair of hMem on both sides */
-    if (dde_num_used == dde_num_alloc)
+    data->count = 0;
+    switch(message)
     {
-        struct DDE_pair* tmp;
-	if (dde_pairs)
-	    tmp  = HeapReAlloc( GetProcessHeap(), 0, dde_pairs,
-                                            (dde_num_alloc + GROWBY) * sizeof(struct DDE_pair));
-	else
-	    tmp  = HeapAlloc( GetProcessHeap(), 0, 
-                                            (dde_num_alloc + GROWBY) * sizeof(struct DDE_pair));
-
-        if (!tmp)
-        {
-            LeaveCriticalSection(&dde_crst);
-            return FALSE;
-        }
-        dde_pairs = tmp;
-        /* zero out newly allocated part */
-        memset(&dde_pairs[dde_num_alloc], 0, GROWBY * sizeof(struct DDE_pair));
-        dde_num_alloc += GROWBY;
+    case WM_NCCREATE:
+    case WM_CREATE:
+    {
+        CREATESTRUCTW *cs = (CREATESTRUCTW *)lparam;
+        data->ps.cs.lpCreateParams = pack_ptr( cs->lpCreateParams );
+        data->ps.cs.hInstance      = pack_ptr( cs->hInstance );
+        data->ps.cs.hMenu          = wine_server_user_handle( cs->hMenu );
+        data->ps.cs.hwndParent     = wine_server_user_handle( cs->hwndParent );
+        data->ps.cs.cy             = cs->cy;
+        data->ps.cs.cx             = cs->cx;
+        data->ps.cs.y              = cs->y;
+        data->ps.cs.x              = cs->x;
+        data->ps.cs.style          = cs->style;
+        data->ps.cs.dwExStyle      = cs->dwExStyle;
+        data->ps.cs.lpszName       = pack_ptr( cs->lpszName );
+        data->ps.cs.lpszClass      = pack_ptr( cs->lpszClass );
+        push_data( data, &data->ps.cs, sizeof(data->ps.cs) );
+        if (!IS_INTRESOURCE(cs->lpszName)) push_string( data, cs->lpszName );
+        if (!IS_INTRESOURCE(cs->lpszClass)) push_string( data, cs->lpszClass );
+        return sizeof(data->ps.cs);
     }
-#undef GROWBY
-    for (i = 0; i < dde_num_alloc; i++)
+    case WM_GETTEXT:
+    case WM_ASKCBFORMATNAME:
+        return wparam * sizeof(WCHAR);
+    case WM_WININICHANGE:
+        if (lparam) push_string(data, (LPWSTR)lparam );
+        return 0;
+    case WM_SETTEXT:
+    case WM_DEVMODECHANGE:
+    case CB_DIR:
+    case LB_DIR:
+    case LB_ADDFILE:
+    case EM_REPLACESEL:
+        push_string( data, (LPWSTR)lparam );
+        return 0;
+    case WM_GETMINMAXINFO:
+        push_data( data, (MINMAXINFO *)lparam, sizeof(MINMAXINFO) );
+        return sizeof(MINMAXINFO);
+    case WM_DRAWITEM:
     {
-        if (dde_pairs[i].server_hMem == 0)
-        {
-            dde_pairs[i].client_hMem = chm;
-            dde_pairs[i].server_hMem = shm;
-            dde_num_used++;
-            break;
-        }
+        DRAWITEMSTRUCT *dis = (DRAWITEMSTRUCT *)lparam;
+        data->ps.dis.CtlType    = dis->CtlType;
+        data->ps.dis.CtlID      = dis->CtlID;
+        data->ps.dis.itemID     = dis->itemID;
+        data->ps.dis.itemAction = dis->itemAction;
+        data->ps.dis.itemState  = dis->itemState;
+        data->ps.dis.hwndItem   = wine_server_user_handle( dis->hwndItem );
+        data->ps.dis.hDC        = wine_server_user_handle( dis->hDC );  /* FIXME */
+        data->ps.dis.rcItem     = dis->rcItem;
+        data->ps.dis.itemData   = dis->itemData;
+        push_data( data, &data->ps.dis, sizeof(data->ps.dis) );
+        return 0;
     }
-    LeaveCriticalSection(&dde_crst);
-    return TRUE;
-}
-
-static HGLOBAL dde_get_pair(HGLOBAL shm)
-{
-    int  i;
-    HGLOBAL     ret = 0;
-
-    EnterCriticalSection(&dde_crst);
-    for (i = 0; i < dde_num_alloc; i++)
+    case WM_MEASUREITEM:
     {
-        if (dde_pairs[i].server_hMem == shm)
+        MEASUREITEMSTRUCT *mis = (MEASUREITEMSTRUCT *)lparam;
+        data->ps.mis.CtlType    = mis->CtlType;
+        data->ps.mis.CtlID      = mis->CtlID;
+        data->ps.mis.itemID     = mis->itemID;
+        data->ps.mis.itemWidth  = mis->itemWidth;
+        data->ps.mis.itemHeight = mis->itemHeight;
+        data->ps.mis.itemData   = mis->itemData;
+        push_data( data, &data->ps.mis, sizeof(data->ps.mis) );
+        return sizeof(data->ps.mis);
+    }
+    case WM_DELETEITEM:
+    {
+        DELETEITEMSTRUCT *dls = (DELETEITEMSTRUCT *)lparam;
+        data->ps.dls.CtlType    = dls->CtlType;
+        data->ps.dls.CtlID      = dls->CtlID;
+        data->ps.dls.itemID     = dls->itemID;
+        data->ps.dls.hwndItem   = wine_server_user_handle( dls->hwndItem );
+        data->ps.dls.itemData   = dls->itemData;
+        push_data( data, &data->ps.dls, sizeof(data->ps.dls) );
+        return 0;
+    }
+    case WM_COMPAREITEM:
+    {
+        COMPAREITEMSTRUCT *cis = (COMPAREITEMSTRUCT *)lparam;
+        data->ps.cis.CtlType    = cis->CtlType;
+        data->ps.cis.CtlID      = cis->CtlID;
+        data->ps.cis.hwndItem   = wine_server_user_handle( cis->hwndItem );
+        data->ps.cis.itemID1    = cis->itemID1;
+        data->ps.cis.itemData1  = cis->itemData1;
+        data->ps.cis.itemID2    = cis->itemID2;
+        data->ps.cis.itemData2  = cis->itemData2;
+        data->ps.cis.dwLocaleId = cis->dwLocaleId;
+        push_data( data, &data->ps.cis, sizeof(data->ps.cis) );
+        return 0;
+    }
+    case WM_WINE_SETWINDOWPOS:
+    case WM_WINDOWPOSCHANGING:
+    case WM_WINDOWPOSCHANGED:
+    {
+        WINDOWPOS *wp = (WINDOWPOS *)lparam;
+        data->ps.wp.hwnd            = wine_server_user_handle( wp->hwnd );
+        data->ps.wp.hwndInsertAfter = wine_server_user_handle( wp->hwndInsertAfter );
+        data->ps.wp.x               = wp->x;
+        data->ps.wp.y               = wp->y;
+        data->ps.wp.cx              = wp->cx;
+        data->ps.wp.cy              = wp->cy;
+        data->ps.wp.flags           = wp->flags;
+        push_data( data, &data->ps.wp, sizeof(data->ps.wp) );
+        return sizeof(data->ps.wp);
+    }
+    case WM_COPYDATA:
+    {
+        COPYDATASTRUCT *cds = (COPYDATASTRUCT *)lparam;
+        data->ps.cds.cbData = cds->cbData;
+        data->ps.cds.dwData = cds->dwData;
+        data->ps.cds.lpData = pack_ptr( cds->lpData );
+        push_data( data, &data->ps.cds, sizeof(data->ps.cds) );
+        if (cds->lpData) push_data( data, cds->lpData, cds->cbData );
+        return 0;
+    }
+    case WM_NOTIFY:
+        /* WM_NOTIFY cannot be sent across processes (MSDN) */
+        data->count = -1;
+        return 0;
+    case WM_HELP:
+    {
+        HELPINFO *hi = (HELPINFO *)lparam;
+        data->ps.hi.iContextType = hi->iContextType;
+        data->ps.hi.iCtrlId      = hi->iCtrlId;
+        data->ps.hi.hItemHandle  = wine_server_user_handle( hi->hItemHandle );
+        data->ps.hi.dwContextId  = hi->dwContextId;
+        data->ps.hi.MousePos     = hi->MousePos;
+        push_data( data, &data->ps.hi, sizeof(data->ps.hi) );
+        return 0;
+    }
+    case WM_STYLECHANGING:
+    case WM_STYLECHANGED:
+        push_data( data, (STYLESTRUCT *)lparam, sizeof(STYLESTRUCT) );
+        return 0;
+    case WM_NCCALCSIZE:
+        if (!wparam)
         {
-            /* free this pair */
-            dde_pairs[i].server_hMem = 0;
-            dde_num_used--;
-            ret = dde_pairs[i].client_hMem;
-            break;
+            push_data( data, (RECT *)lparam, sizeof(RECT) );
+            return sizeof(RECT);
+        }
+        else
+        {
+            NCCALCSIZE_PARAMS *ncp = (NCCALCSIZE_PARAMS *)lparam;
+            data->ps.ncp.rgrc[0]         = ncp->rgrc[0];
+            data->ps.ncp.rgrc[1]         = ncp->rgrc[1];
+            data->ps.ncp.rgrc[2]         = ncp->rgrc[2];
+            data->ps.ncp.hwnd            = wine_server_user_handle( ncp->lppos->hwnd );
+            data->ps.ncp.hwndInsertAfter = wine_server_user_handle( ncp->lppos->hwndInsertAfter );
+            data->ps.ncp.x               = ncp->lppos->x;
+            data->ps.ncp.y               = ncp->lppos->y;
+            data->ps.ncp.cx              = ncp->lppos->cx;
+            data->ps.ncp.cy              = ncp->lppos->cy;
+            data->ps.ncp.flags           = ncp->lppos->flags;
+            push_data( data, &data->ps.ncp, sizeof(data->ps.ncp) );
+            return sizeof(data->ps.ncp);
         }
+    case WM_GETDLGCODE:
+        if (lparam)
+        {
+            MSG *msg = (MSG *)lparam;
+            data->ps.msg.hwnd    = wine_server_user_handle( msg->hwnd );
+            data->ps.msg.message = msg->message;
+            data->ps.msg.wParam  = msg->wParam;
+            data->ps.msg.lParam  = msg->lParam;
+            data->ps.msg.time    = msg->time;
+            data->ps.msg.pt      = msg->pt;
+            push_data( data, &data->ps.msg, sizeof(data->ps.msg) );
+            return sizeof(data->ps.msg);
+        }
+        return 0;
+    case SBM_SETSCROLLINFO:
+        push_data( data, (SCROLLINFO *)lparam, sizeof(SCROLLINFO) );
+        return 0;
+    case SBM_GETSCROLLINFO:
+        push_data( data, (SCROLLINFO *)lparam, sizeof(SCROLLINFO) );
+        return sizeof(SCROLLINFO);
+    case SBM_GETSCROLLBARINFO:
+    {
+        const SCROLLBARINFO *info = (const SCROLLBARINFO *)lparam;
+        size_t size = min( info->cbSize, sizeof(SCROLLBARINFO) );
+        push_data( data, info, size );
+        return size;
     }
-    LeaveCriticalSection(&dde_crst);
-    return ret;
+    case EM_GETSEL:
+    case SBM_GETRANGE:
+    case CB_GETEDITSEL:
+    {
+        size_t size = 0;
+        if (wparam) size += sizeof(DWORD);
+        if (lparam) size += sizeof(DWORD);
+        return size;
+    }
+    case EM_GETRECT:
+    case LB_GETITEMRECT:
+    case CB_GETDROPPEDCONTROLRECT:
+        return sizeof(RECT);
+    case EM_SETRECT:
+    case EM_SETRECTNP:
+        push_data( data, (RECT *)lparam, sizeof(RECT) );
+        return 0;
+    case EM_GETLINE:
+    {
+        WORD *pw = (WORD *)lparam;
+        push_data( data, pw, sizeof(*pw) );
+        return *pw * sizeof(WCHAR);
+    }
+    case EM_SETTABSTOPS:
+    case LB_SETTABSTOPS:
+        if (wparam) push_data( data, (UINT *)lparam, sizeof(UINT) * wparam );
+        return 0;
+    case CB_ADDSTRING:
+    case CB_INSERTSTRING:
+    case CB_FINDSTRING:
+    case CB_FINDSTRINGEXACT:
+    case CB_SELECTSTRING:
+        if (combobox_has_strings( hwnd )) push_string( data, (LPWSTR)lparam );
+        return 0;
+    case CB_GETLBTEXT:
+        if (!combobox_has_strings( hwnd )) return sizeof(ULONG_PTR);
+        return (SendMessageW( hwnd, CB_GETLBTEXTLEN, wparam, 0 ) + 1) * sizeof(WCHAR);
+    case LB_ADDSTRING:
+    case LB_INSERTSTRING:
+    case LB_FINDSTRING:
+    case LB_FINDSTRINGEXACT:
+    case LB_SELECTSTRING:
+        if (listbox_has_strings( hwnd )) push_string( data, (LPWSTR)lparam );
+        return 0;
+    case LB_GETTEXT:
+        if (!listbox_has_strings( hwnd )) return sizeof(ULONG_PTR);
+        return (SendMessageW( hwnd, LB_GETTEXTLEN, wparam, 0 ) + 1) * sizeof(WCHAR);
+    case LB_GETSELITEMS:
+        return wparam * sizeof(UINT);
+    case WM_NEXTMENU:
+    {
+        MDINEXTMENU *mnm = (MDINEXTMENU *)lparam;
+        data->ps.mnm.hmenuIn   = wine_server_user_handle( mnm->hmenuIn );
+        data->ps.mnm.hmenuNext = wine_server_user_handle( mnm->hmenuNext );
+        data->ps.mnm.hwndNext  = wine_server_user_handle( mnm->hwndNext );
+        push_data( data, &data->ps.mnm, sizeof(data->ps.mnm) );
+        return sizeof(data->ps.mnm);
+    }
+    case WM_SIZING:
+    case WM_MOVING:
+        push_data( data, (RECT *)lparam, sizeof(RECT) );
+        return sizeof(RECT);
+    case WM_MDICREATE:
+    {
+        MDICREATESTRUCTW *mcs = (MDICREATESTRUCTW *)lparam;
+        data->ps.mcs.szClass = pack_ptr( mcs->szClass );
+        data->ps.mcs.szTitle = pack_ptr( mcs->szTitle );
+        data->ps.mcs.hOwner  = pack_ptr( mcs->hOwner );
+        data->ps.mcs.x       = mcs->x;
+        data->ps.mcs.y       = mcs->y;
+        data->ps.mcs.cx      = mcs->cx;
+        data->ps.mcs.cy      = mcs->cy;
+        data->ps.mcs.style   = mcs->style;
+        data->ps.mcs.lParam  = mcs->lParam;
+        push_data( data, &data->ps.mcs, sizeof(data->ps.mcs) );
+        if (!IS_INTRESOURCE(mcs->szClass)) push_string( data, mcs->szClass );
+        if (!IS_INTRESOURCE(mcs->szTitle)) push_string( data, mcs->szTitle );
+        return sizeof(data->ps.mcs);
+    }
+    case WM_MDIGETACTIVE:
+        if (lparam) return sizeof(BOOL);
+        return 0;
+    case WM_DEVICECHANGE:
+    {
+        DEV_BROADCAST_HDR *header = (DEV_BROADCAST_HDR *)lparam;
+        if ((wparam & 0x8000) && header) push_data( data, header, header->dbch_size );
+        return 0;
+    }
+    case WM_WINE_KEYBOARD_LL_HOOK:
+    {
+        struct hook_extra_info *h_extra = (struct hook_extra_info *)lparam;
+        data->ps.hook.handle = wine_server_user_handle( h_extra->handle );
+        push_data( data, &data->ps.hook, sizeof(data->ps.hook) );
+        push_data( data, (LPVOID)h_extra->lparam, sizeof(KBDLLHOOKSTRUCT) );
+        return 0;
+    }
+    case WM_WINE_MOUSE_LL_HOOK:
+    {
+        struct hook_extra_info *h_extra = (struct hook_extra_info *)lparam;
+        data->ps.hook.handle = wine_server_user_handle( h_extra->handle );
+        push_data( data, &data->ps.hook, sizeof(data->ps.hook) );
+        push_data( data, (LPVOID)h_extra->lparam, sizeof(MSLLHOOKSTRUCT) );
+        return 0;
+    }
+    case WM_NCPAINT:
+        if (wparam <= 1) return 0;
+        FIXME( "WM_NCPAINT hdc packing not supported yet\n" );
+        data->count = -1;
+        return 0;
+    case WM_PAINT:
+        if (!wparam) return 0;
+        /* fall through */
+
+    /* these contain an HFONT */
+    case WM_SETFONT:
+    case WM_GETFONT:
+    /* these contain an HDC */
+    case WM_ERASEBKGND:
+    case WM_ICONERASEBKGND:
+    case WM_CTLCOLORMSGBOX:
+    case WM_CTLCOLOREDIT:
+    case WM_CTLCOLORLISTBOX:
+    case WM_CTLCOLORBTN:
+    case WM_CTLCOLORDLG:
+    case WM_CTLCOLORSCROLLBAR:
+    case WM_CTLCOLORSTATIC:
+    case WM_PRINT:
+    case WM_PRINTCLIENT:
+    /* these contain an HGLOBAL */
+    case WM_PAINTCLIPBOARD:
+    case WM_SIZECLIPBOARD:
+    /* these contain HICON */
+    case WM_GETICON:
+    case WM_SETICON:
+    case WM_QUERYDRAGICON:
+    case WM_QUERYPARKICON:
+    /* these contain pointers */
+    case WM_DROPOBJECT:
+    case WM_QUERYDROPOBJECT:
+    case WM_DRAGLOOP:
+    case WM_DRAGSELECT:
+    case WM_DRAGMOVE:
+        FIXME( "msg %x (%s) not supported yet\n", message, SPY_GetMsgName(message, hwnd) );
+        data->count = -1;
+        return 0;
+    }
+    return 0;
 }
 
+
 /***********************************************************************
- *		post_dde_message
+ *		unpack_message
  *
- * Post a DDE message
+ * Unpack a message received from another process.
  */
-BOOL post_dde_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, DWORD dest_tid, DWORD type )
+static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lparam,
+                            void **buffer, size_t size )
+{
+    size_t minsize = 0;
+    union packed_structs *ps = *buffer;
+
+    switch(message)
+    {
+    case WM_NCCREATE:
+    case WM_CREATE:
+    {
+        CREATESTRUCTW cs;
+        WCHAR *str = (WCHAR *)(&ps->cs + 1);
+        if (size < sizeof(ps->cs)) return FALSE;
+        size -= sizeof(ps->cs);
+        cs.lpCreateParams = unpack_ptr( ps->cs.lpCreateParams );
+        cs.hInstance      = unpack_ptr( ps->cs.hInstance );
+        cs.hMenu          = wine_server_ptr_handle( ps->cs.hMenu );
+        cs.hwndParent     = wine_server_ptr_handle( ps->cs.hwndParent );
+        cs.cy             = ps->cs.cy;
+        cs.cx             = ps->cs.cx;
+        cs.y              = ps->cs.y;
+        cs.x              = ps->cs.x;
+        cs.style          = ps->cs.style;
+        cs.dwExStyle      = ps->cs.dwExStyle;
+        cs.lpszName       = unpack_ptr( ps->cs.lpszName );
+        cs.lpszClass      = unpack_ptr( ps->cs.lpszClass );
+        if (ps->cs.lpszName >> 16)
+        {
+            if (!check_string( str, size )) return FALSE;
+            cs.lpszName = str;
+            size -= (lstrlenW(str) + 1) * sizeof(WCHAR);
+            str += lstrlenW(str) + 1;
+        }
+        if (ps->cs.lpszClass >> 16)
+        {
+            if (!check_string( str, size )) return FALSE;
+            cs.lpszClass = str;
+        }
+        memcpy( &ps->cs, &cs, sizeof(cs) );
+        break;
+    }
+    case WM_GETTEXT:
+    case WM_ASKCBFORMATNAME:
+        if (!get_buffer_space( buffer, (*wparam * sizeof(WCHAR)) )) return FALSE;
+        break;
+    case WM_WININICHANGE:
+        if (!*lparam) return TRUE;
+        /* fall through */
+    case WM_SETTEXT:
+    case WM_DEVMODECHANGE:
+    case CB_DIR:
+    case LB_DIR:
+    case LB_ADDFILE:
+    case EM_REPLACESEL:
+        if (!check_string( *buffer, size )) return FALSE;
+        break;
+    case WM_GETMINMAXINFO:
+        minsize = sizeof(MINMAXINFO);
+        break;
+    case WM_DRAWITEM:
+    {
+        DRAWITEMSTRUCT dis;
+        if (size < sizeof(ps->dis)) return FALSE;
+        dis.CtlType    = ps->dis.CtlType;
+        dis.CtlID      = ps->dis.CtlID;
+        dis.itemID     = ps->dis.itemID;
+        dis.itemAction = ps->dis.itemAction;
+        dis.itemState  = ps->dis.itemState;
+        dis.hwndItem   = wine_server_ptr_handle( ps->dis.hwndItem );
+        dis.hDC        = wine_server_ptr_handle( ps->dis.hDC );
+        dis.rcItem     = ps->dis.rcItem;
+        dis.itemData   = (ULONG_PTR)unpack_ptr( ps->dis.itemData );
+        memcpy( &ps->dis, &dis, sizeof(dis) );
+        break;
+    }
+    case WM_MEASUREITEM:
+    {
+        MEASUREITEMSTRUCT mis;
+        if (size < sizeof(ps->mis)) return FALSE;
+        mis.CtlType    = ps->mis.CtlType;
+        mis.CtlID      = ps->mis.CtlID;
+        mis.itemID     = ps->mis.itemID;
+        mis.itemWidth  = ps->mis.itemWidth;
+        mis.itemHeight = ps->mis.itemHeight;
+        mis.itemData   = (ULONG_PTR)unpack_ptr( ps->mis.itemData );
+        memcpy( &ps->mis, &mis, sizeof(mis) );
+        break;
+    }
+    case WM_DELETEITEM:
+    {
+        DELETEITEMSTRUCT dls;
+        if (size < sizeof(ps->dls)) return FALSE;
+        dls.CtlType    = ps->dls.CtlType;
+        dls.CtlID      = ps->dls.CtlID;
+        dls.itemID     = ps->dls.itemID;
+        dls.hwndItem   = wine_server_ptr_handle( ps->dls.hwndItem );
+        dls.itemData   = (ULONG_PTR)unpack_ptr( ps->dls.itemData );
+        memcpy( &ps->dls, &dls, sizeof(dls) );
+        break;
+    }
+    case WM_COMPAREITEM:
+    {
+        COMPAREITEMSTRUCT cis;
+        if (size < sizeof(ps->cis)) return FALSE;
+        cis.CtlType    = ps->cis.CtlType;
+        cis.CtlID      = ps->cis.CtlID;
+        cis.hwndItem   = wine_server_ptr_handle( ps->cis.hwndItem );
+        cis.itemID1    = ps->cis.itemID1;
+        cis.itemData1  = (ULONG_PTR)unpack_ptr( ps->cis.itemData1 );
+        cis.itemID2    = ps->cis.itemID2;
+        cis.itemData2  = (ULONG_PTR)unpack_ptr( ps->cis.itemData2 );
+        cis.dwLocaleId = ps->cis.dwLocaleId;
+        memcpy( &ps->cis, &cis, sizeof(cis) );
+        break;
+    }
+    case WM_WINDOWPOSCHANGING:
+    case WM_WINDOWPOSCHANGED:
+    case WM_WINE_SETWINDOWPOS:
+    {
+        WINDOWPOS wp;
+        if (size < sizeof(ps->wp)) return FALSE;
+        wp.hwnd            = wine_server_ptr_handle( ps->wp.hwnd );
+        wp.hwndInsertAfter = wine_server_ptr_handle( ps->wp.hwndInsertAfter );
+        wp.x               = ps->wp.x;
+        wp.y               = ps->wp.y;
+        wp.cx              = ps->wp.cx;
+        wp.cy              = ps->wp.cy;
+        wp.flags           = ps->wp.flags;
+        memcpy( &ps->wp, &wp, sizeof(wp) );
+        break;
+    }
+    case WM_COPYDATA:
+    {
+        COPYDATASTRUCT cds;
+        if (size < sizeof(ps->cds)) return FALSE;
+        cds.dwData = (ULONG_PTR)unpack_ptr( ps->cds.dwData );
+        if (ps->cds.lpData)
+        {
+            cds.cbData = ps->cds.cbData;
+            cds.lpData = &ps->cds + 1;
+            minsize = sizeof(ps->cds) + cds.cbData;
+        }
+        else
+        {
+            cds.cbData = 0;
+            cds.lpData = 0;
+        }
+        memcpy( &ps->cds, &cds, sizeof(cds) );
+        break;
+    }
+    case WM_NOTIFY:
+        /* WM_NOTIFY cannot be sent across processes (MSDN) */
+        return FALSE;
+    case WM_HELP:
+    {
+        HELPINFO hi;
+        if (size < sizeof(ps->hi)) return FALSE;
+        hi.cbSize       = sizeof(hi);
+        hi.iContextType = ps->hi.iContextType;
+        hi.iCtrlId      = ps->hi.iCtrlId;
+        hi.hItemHandle  = wine_server_ptr_handle( ps->hi.hItemHandle );
+        hi.dwContextId  = (ULONG_PTR)unpack_ptr( ps->hi.dwContextId );
+        hi.MousePos     = ps->hi.MousePos;
+        memcpy( &ps->hi, &hi, sizeof(hi) );
+        break;
+    }
+    case WM_STYLECHANGING:
+    case WM_STYLECHANGED:
+        minsize = sizeof(STYLESTRUCT);
+        break;
+    case WM_NCCALCSIZE:
+        if (!*wparam) minsize = sizeof(RECT);
+        else
+        {
+            NCCALCSIZE_PARAMS ncp;
+            WINDOWPOS wp;
+            if (size < sizeof(ps->ncp)) return FALSE;
+            ncp.rgrc[0]        = ps->ncp.rgrc[0];
+            ncp.rgrc[1]        = ps->ncp.rgrc[1];
+            ncp.rgrc[2]        = ps->ncp.rgrc[2];
+            wp.hwnd            = wine_server_ptr_handle( ps->ncp.hwnd );
+            wp.hwndInsertAfter = wine_server_ptr_handle( ps->ncp.hwndInsertAfter );
+            wp.x               = ps->ncp.x;
+            wp.y               = ps->ncp.y;
+            wp.cx              = ps->ncp.cx;
+            wp.cy              = ps->ncp.cy;
+            wp.flags           = ps->ncp.flags;
+            ncp.lppos = (WINDOWPOS *)((NCCALCSIZE_PARAMS *)&ps->ncp + 1);
+            memcpy( &ps->ncp, &ncp, sizeof(ncp) );
+            *ncp.lppos = wp;
+        }
+        break;
+    case WM_GETDLGCODE:
+        if (*lparam)
+        {
+            MSG msg;
+            if (size < sizeof(ps->msg)) return FALSE;
+            msg.hwnd    = wine_server_ptr_handle( ps->msg.hwnd );
+            msg.message = ps->msg.message;
+            msg.wParam  = (ULONG_PTR)unpack_ptr( ps->msg.wParam );
+            msg.lParam  = (ULONG_PTR)unpack_ptr( ps->msg.lParam );
+            msg.time    = ps->msg.time;
+            msg.pt      = ps->msg.pt;
+            memcpy( &ps->msg, &msg, sizeof(msg) );
+            break;
+        }
+        return TRUE;
+    case SBM_SETSCROLLINFO:
+        minsize = sizeof(SCROLLINFO);
+        break;
+    case SBM_GETSCROLLINFO:
+        if (!get_buffer_space( buffer, sizeof(SCROLLINFO ))) return FALSE;
+        break;
+    case SBM_GETSCROLLBARINFO:
+        if (!get_buffer_space( buffer, sizeof(SCROLLBARINFO ))) return FALSE;
+        break;
+    case EM_GETSEL:
+    case SBM_GETRANGE:
+    case CB_GETEDITSEL:
+        if (*wparam || *lparam)
+        {
+            if (!get_buffer_space( buffer, 2*sizeof(DWORD) )) return FALSE;
+            if (*wparam) *wparam = (WPARAM)*buffer;
+            if (*lparam) *lparam = (LPARAM)((DWORD *)*buffer + 1);
+        }
+        return TRUE;
+    case EM_GETRECT:
+    case LB_GETITEMRECT:
+    case CB_GETDROPPEDCONTROLRECT:
+        if (!get_buffer_space( buffer, sizeof(RECT) )) return FALSE;
+        break;
+    case EM_SETRECT:
+    case EM_SETRECTNP:
+        minsize = sizeof(RECT);
+        break;
+    case EM_GETLINE:
+    {
+        WORD len;
+        if (size < sizeof(WORD)) return FALSE;
+        len = *(WORD *)*buffer;
+        if (!get_buffer_space( buffer, (len + 1) * sizeof(WCHAR) )) return FALSE;
+        *lparam = (LPARAM)*buffer + sizeof(WORD);  /* don't erase WORD at start of buffer */
+        return TRUE;
+    }
+    case EM_SETTABSTOPS:
+    case LB_SETTABSTOPS:
+        if (!*wparam) return TRUE;
+        minsize = *wparam * sizeof(UINT);
+        break;
+    case CB_ADDSTRING:
+    case CB_INSERTSTRING:
+    case CB_FINDSTRING:
+    case CB_FINDSTRINGEXACT:
+    case CB_SELECTSTRING:
+    case LB_ADDSTRING:
+    case LB_INSERTSTRING:
+    case LB_FINDSTRING:
+    case LB_FINDSTRINGEXACT:
+    case LB_SELECTSTRING:
+        if (!*buffer) return TRUE;
+        if (!check_string( *buffer, size )) return FALSE;
+        break;
+    case CB_GETLBTEXT:
+    {
+        size = sizeof(ULONG_PTR);
+        if (combobox_has_strings( hwnd ))
+            size = (SendMessageW( hwnd, CB_GETLBTEXTLEN, *wparam, 0 ) + 1) * sizeof(WCHAR);
+        if (!get_buffer_space( buffer, size )) return FALSE;
+        break;
+    }
+    case LB_GETTEXT:
+    {
+        size = sizeof(ULONG_PTR);
+        if (listbox_has_strings( hwnd ))
+            size = (SendMessageW( hwnd, LB_GETTEXTLEN, *wparam, 0 ) + 1) * sizeof(WCHAR);
+        if (!get_buffer_space( buffer, size )) return FALSE;
+        break;
+    }
+    case LB_GETSELITEMS:
+        if (!get_buffer_space( buffer, *wparam * sizeof(UINT) )) return FALSE;
+        break;
+    case WM_NEXTMENU:
+    {
+        MDINEXTMENU mnm;
+        if (size < sizeof(ps->mnm)) return FALSE;
+        mnm.hmenuIn   = wine_server_ptr_handle( ps->mnm.hmenuIn );
+        mnm.hmenuNext = wine_server_ptr_handle( ps->mnm.hmenuNext );
+        mnm.hwndNext  = wine_server_ptr_handle( ps->mnm.hwndNext );
+        memcpy( &ps->mnm, &mnm, sizeof(mnm) );
+        break;
+    }
+    case WM_SIZING:
+    case WM_MOVING:
+        minsize = sizeof(RECT);
+        if (!get_buffer_space( buffer, sizeof(RECT) )) return FALSE;
+        break;
+    case WM_MDICREATE:
+    {
+        MDICREATESTRUCTW mcs;
+        WCHAR *str = (WCHAR *)(&ps->mcs + 1);
+        if (size < sizeof(ps->mcs)) return FALSE;
+        size -= sizeof(ps->mcs);
+
+        mcs.szClass = unpack_ptr( ps->mcs.szClass );
+        mcs.szTitle = unpack_ptr( ps->mcs.szTitle );
+        mcs.hOwner  = unpack_ptr( ps->mcs.hOwner );
+        mcs.x       = ps->mcs.x;
+        mcs.y       = ps->mcs.y;
+        mcs.cx      = ps->mcs.cx;
+        mcs.cy      = ps->mcs.cy;
+        mcs.style   = ps->mcs.style;
+        mcs.lParam  = (LPARAM)unpack_ptr( ps->mcs.lParam );
+        if (ps->mcs.szClass >> 16)
+        {
+            if (!check_string( str, size )) return FALSE;
+            mcs.szClass = str;
+            size -= (lstrlenW(str) + 1) * sizeof(WCHAR);
+            str += lstrlenW(str) + 1;
+        }
+        if (ps->mcs.szTitle >> 16)
+        {
+            if (!check_string( str, size )) return FALSE;
+            mcs.szTitle = str;
+        }
+        memcpy( &ps->mcs, &mcs, sizeof(mcs) );
+        break;
+    }
+    case WM_MDIGETACTIVE:
+        if (!*lparam) return TRUE;
+        if (!get_buffer_space( buffer, sizeof(BOOL) )) return FALSE;
+        break;
+    case WM_DEVICECHANGE:
+        if (!(*wparam & 0x8000)) return TRUE;
+        minsize = sizeof(DEV_BROADCAST_HDR);
+        break;
+    case WM_WINE_KEYBOARD_LL_HOOK:
+    case WM_WINE_MOUSE_LL_HOOK:
+    {
+        struct hook_extra_info h_extra;
+        minsize = sizeof(ps->hook) +
+                  (message == WM_WINE_KEYBOARD_LL_HOOK ? sizeof(KBDLLHOOKSTRUCT)
+                                                       : sizeof(MSLLHOOKSTRUCT));
+        if (size < minsize) return FALSE;
+        h_extra.handle = wine_server_ptr_handle( ps->hook.handle );
+        h_extra.lparam = (LPARAM)(&ps->hook + 1);
+        memcpy( &ps->hook, &h_extra, sizeof(h_extra) );
+        break;
+    }
+    case WM_NCPAINT:
+        if (*wparam <= 1) return TRUE;
+        FIXME( "WM_NCPAINT hdc unpacking not supported\n" );
+        return FALSE;
+    case WM_PAINT:
+        if (!*wparam) return TRUE;
+        /* fall through */
+
+    /* these contain an HFONT */
+    case WM_SETFONT:
+    case WM_GETFONT:
+    /* these contain an HDC */
+    case WM_ERASEBKGND:
+    case WM_ICONERASEBKGND:
+    case WM_CTLCOLORMSGBOX:
+    case WM_CTLCOLOREDIT:
+    case WM_CTLCOLORLISTBOX:
+    case WM_CTLCOLORBTN:
+    case WM_CTLCOLORDLG:
+    case WM_CTLCOLORSCROLLBAR:
+    case WM_CTLCOLORSTATIC:
+    case WM_PRINT:
+    case WM_PRINTCLIENT:
+    /* these contain an HGLOBAL */
+    case WM_PAINTCLIPBOARD:
+    case WM_SIZECLIPBOARD:
+    /* these contain HICON */
+    case WM_GETICON:
+    case WM_SETICON:
+    case WM_QUERYDRAGICON:
+    case WM_QUERYPARKICON:
+    /* these contain pointers */
+    case WM_DROPOBJECT:
+    case WM_QUERYDROPOBJECT:
+    case WM_DRAGLOOP:
+    case WM_DRAGSELECT:
+    case WM_DRAGMOVE:
+        FIXME( "msg %x (%s) not supported yet\n", message, SPY_GetMsgName(message, hwnd) );
+        return FALSE;
+
+    default:
+        return TRUE; /* message doesn't need any unpacking */
+    }
+
+    /* default exit for most messages: check minsize and store buffer in lparam */
+    if (size < minsize) return FALSE;
+    *lparam = (LPARAM)*buffer;
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *		pack_reply
+ *
+ * Pack a reply to a message for sending to another process.
+ */
+static void pack_reply( HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam,
+                        LRESULT res, struct packed_message *data )
+{
+    data->count = 0;
+    switch(message)
+    {
+    case WM_NCCREATE:
+    case WM_CREATE:
+    {
+        CREATESTRUCTW *cs = (CREATESTRUCTW *)lparam;
+        data->ps.cs.lpCreateParams = (ULONG_PTR)cs->lpCreateParams;
+        data->ps.cs.hInstance      = (ULONG_PTR)cs->hInstance;
+        data->ps.cs.hMenu          = wine_server_user_handle( cs->hMenu );
+        data->ps.cs.hwndParent     = wine_server_user_handle( cs->hwndParent );
+        data->ps.cs.cy             = cs->cy;
+        data->ps.cs.cx             = cs->cx;
+        data->ps.cs.y              = cs->y;
+        data->ps.cs.x              = cs->x;
+        data->ps.cs.style          = cs->style;
+        data->ps.cs.dwExStyle      = cs->dwExStyle;
+        data->ps.cs.lpszName       = (ULONG_PTR)cs->lpszName;
+        data->ps.cs.lpszClass      = (ULONG_PTR)cs->lpszClass;
+        push_data( data, &data->ps.cs, sizeof(data->ps.cs) );
+        break;
+    }
+    case WM_GETTEXT:
+    case CB_GETLBTEXT:
+    case LB_GETTEXT:
+        push_data( data, (WCHAR *)lparam, (res + 1) * sizeof(WCHAR) );
+        break;
+    case WM_GETMINMAXINFO:
+        push_data( data, (MINMAXINFO *)lparam, sizeof(MINMAXINFO) );
+        break;
+    case WM_MEASUREITEM:
+    {
+        MEASUREITEMSTRUCT *mis = (MEASUREITEMSTRUCT *)lparam;
+        data->ps.mis.CtlType    = mis->CtlType;
+        data->ps.mis.CtlID      = mis->CtlID;
+        data->ps.mis.itemID     = mis->itemID;
+        data->ps.mis.itemWidth  = mis->itemWidth;
+        data->ps.mis.itemHeight = mis->itemHeight;
+        data->ps.mis.itemData   = mis->itemData;
+        push_data( data, &data->ps.mis, sizeof(data->ps.mis) );
+        break;
+    }
+    case WM_WINDOWPOSCHANGING:
+    case WM_WINDOWPOSCHANGED:
+    {
+        WINDOWPOS *wp = (WINDOWPOS *)lparam;
+        data->ps.wp.hwnd            = wine_server_user_handle( wp->hwnd );
+        data->ps.wp.hwndInsertAfter = wine_server_user_handle( wp->hwndInsertAfter );
+        data->ps.wp.x               = wp->x;
+        data->ps.wp.y               = wp->y;
+        data->ps.wp.cx              = wp->cx;
+        data->ps.wp.cy              = wp->cy;
+        data->ps.wp.flags           = wp->flags;
+        push_data( data, &data->ps.wp, sizeof(data->ps.wp) );
+        break;
+    }
+    case WM_GETDLGCODE:
+        if (lparam)
+        {
+            MSG *msg = (MSG *)lparam;
+            data->ps.msg.hwnd    = wine_server_user_handle( msg->hwnd );
+            data->ps.msg.message = msg->message;
+            data->ps.msg.wParam  = msg->wParam;
+            data->ps.msg.lParam  = msg->lParam;
+            data->ps.msg.time    = msg->time;
+            data->ps.msg.pt      = msg->pt;
+            push_data( data, &data->ps.msg, sizeof(data->ps.msg) );
+        }
+        break;
+    case SBM_GETSCROLLINFO:
+        push_data( data, (SCROLLINFO *)lparam, sizeof(SCROLLINFO) );
+        break;
+    case EM_GETRECT:
+    case LB_GETITEMRECT:
+    case CB_GETDROPPEDCONTROLRECT:
+    case WM_SIZING:
+    case WM_MOVING:
+        push_data( data, (RECT *)lparam, sizeof(RECT) );
+        break;
+    case EM_GETLINE:
+    {
+        WORD *ptr = (WORD *)lparam;
+        push_data( data, ptr, ptr[-1] * sizeof(WCHAR) );
+        break;
+    }
+    case LB_GETSELITEMS:
+        push_data( data, (UINT *)lparam, wparam * sizeof(UINT) );
+        break;
+    case WM_MDIGETACTIVE:
+        if (lparam) push_data( data, (BOOL *)lparam, sizeof(BOOL) );
+        break;
+    case WM_NCCALCSIZE:
+        if (!wparam)
+            push_data( data, (RECT *)lparam, sizeof(RECT) );
+        else
+        {
+            NCCALCSIZE_PARAMS *ncp = (NCCALCSIZE_PARAMS *)lparam;
+            data->ps.ncp.rgrc[0]         = ncp->rgrc[0];
+            data->ps.ncp.rgrc[1]         = ncp->rgrc[1];
+            data->ps.ncp.rgrc[2]         = ncp->rgrc[2];
+            data->ps.ncp.hwnd            = wine_server_user_handle( ncp->lppos->hwnd );
+            data->ps.ncp.hwndInsertAfter = wine_server_user_handle( ncp->lppos->hwndInsertAfter );
+            data->ps.ncp.x               = ncp->lppos->x;
+            data->ps.ncp.y               = ncp->lppos->y;
+            data->ps.ncp.cx              = ncp->lppos->cx;
+            data->ps.ncp.cy              = ncp->lppos->cy;
+            data->ps.ncp.flags           = ncp->lppos->flags;
+            push_data( data, &data->ps.ncp, sizeof(data->ps.ncp) );
+        }
+        break;
+    case EM_GETSEL:
+    case SBM_GETRANGE:
+    case CB_GETEDITSEL:
+        if (wparam) push_data( data, (DWORD *)wparam, sizeof(DWORD) );
+        if (lparam) push_data( data, (DWORD *)lparam, sizeof(DWORD) );
+        break;
+    case WM_NEXTMENU:
+    {
+        MDINEXTMENU *mnm = (MDINEXTMENU *)lparam;
+        data->ps.mnm.hmenuIn   = wine_server_user_handle( mnm->hmenuIn );
+        data->ps.mnm.hmenuNext = wine_server_user_handle( mnm->hmenuNext );
+        data->ps.mnm.hwndNext  = wine_server_user_handle( mnm->hwndNext );
+        push_data( data, &data->ps.mnm, sizeof(data->ps.mnm) );
+        break;
+    }
+    case WM_MDICREATE:
+    {
+        MDICREATESTRUCTW *mcs = (MDICREATESTRUCTW *)lparam;
+        data->ps.mcs.szClass = pack_ptr( mcs->szClass );
+        data->ps.mcs.szTitle = pack_ptr( mcs->szTitle );
+        data->ps.mcs.hOwner  = pack_ptr( mcs->hOwner );
+        data->ps.mcs.x       = mcs->x;
+        data->ps.mcs.y       = mcs->y;
+        data->ps.mcs.cx      = mcs->cx;
+        data->ps.mcs.cy      = mcs->cy;
+        data->ps.mcs.style   = mcs->style;
+        data->ps.mcs.lParam  = mcs->lParam;
+        push_data( data, &data->ps.mcs, sizeof(data->ps.mcs) );
+        break;
+    }
+    case WM_ASKCBFORMATNAME:
+        push_data( data, (WCHAR *)lparam, (lstrlenW((WCHAR *)lparam) + 1) * sizeof(WCHAR) );
+        break;
+    }
+}
+
+
+/***********************************************************************
+ *		unpack_reply
+ *
+ * Unpack a message reply received from another process.
+ */
+static void unpack_reply( HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam,
+                          void *buffer, size_t size )
+{
+    union packed_structs *ps = buffer;
+
+    switch(message)
+    {
+    case WM_NCCREATE:
+    case WM_CREATE:
+        if (size >= sizeof(ps->cs))
+        {
+            CREATESTRUCTW *cs = (CREATESTRUCTW *)lparam;
+            cs->lpCreateParams = unpack_ptr( ps->cs.lpCreateParams );
+            cs->hInstance      = unpack_ptr( ps->cs.hInstance );
+            cs->hMenu          = wine_server_ptr_handle( ps->cs.hMenu );
+            cs->hwndParent     = wine_server_ptr_handle( ps->cs.hwndParent );
+            cs->cy             = ps->cs.cy;
+            cs->cx             = ps->cs.cx;
+            cs->y              = ps->cs.y;
+            cs->x              = ps->cs.x;
+            cs->style          = ps->cs.style;
+            cs->dwExStyle      = ps->cs.dwExStyle;
+            /* don't allow changing name and class pointers */
+        }
+        break;
+    case WM_GETTEXT:
+    case WM_ASKCBFORMATNAME:
+        memcpy( (WCHAR *)lparam, buffer, min( wparam*sizeof(WCHAR), size ));
+        break;
+    case WM_GETMINMAXINFO:
+        memcpy( (MINMAXINFO *)lparam, buffer, min( sizeof(MINMAXINFO), size ));
+        break;
+    case WM_MEASUREITEM:
+        if (size >= sizeof(ps->mis))
+        {
+            MEASUREITEMSTRUCT *mis = (MEASUREITEMSTRUCT *)lparam;
+            mis->CtlType    = ps->mis.CtlType;
+            mis->CtlID      = ps->mis.CtlID;
+            mis->itemID     = ps->mis.itemID;
+            mis->itemWidth  = ps->mis.itemWidth;
+            mis->itemHeight = ps->mis.itemHeight;
+            mis->itemData   = (ULONG_PTR)unpack_ptr( ps->mis.itemData );
+        }
+        break;
+    case WM_WINDOWPOSCHANGING:
+    case WM_WINDOWPOSCHANGED:
+        if (size >= sizeof(ps->wp))
+        {
+            WINDOWPOS *wp = (WINDOWPOS *)lparam;
+            wp->hwnd            = wine_server_ptr_handle( ps->wp.hwnd );
+            wp->hwndInsertAfter = wine_server_ptr_handle( ps->wp.hwndInsertAfter );
+            wp->x               = ps->wp.x;
+            wp->y               = ps->wp.y;
+            wp->cx              = ps->wp.cx;
+            wp->cy              = ps->wp.cy;
+            wp->flags           = ps->wp.flags;
+        }
+        break;
+    case WM_GETDLGCODE:
+        if (lparam && size >= sizeof(ps->msg))
+        {
+            MSG *msg = (MSG *)lparam;
+            msg->hwnd    = wine_server_ptr_handle( ps->msg.hwnd );
+            msg->message = ps->msg.message;
+            msg->wParam  = (ULONG_PTR)unpack_ptr( ps->msg.wParam );
+            msg->lParam  = (ULONG_PTR)unpack_ptr( ps->msg.lParam );
+            msg->time    = ps->msg.time;
+            msg->pt      = ps->msg.pt;
+        }
+        break;
+    case SBM_GETSCROLLINFO:
+        memcpy( (SCROLLINFO *)lparam, buffer, min( sizeof(SCROLLINFO), size ));
+        break;
+    case SBM_GETSCROLLBARINFO:
+        memcpy( (SCROLLBARINFO *)lparam, buffer, min( sizeof(SCROLLBARINFO), size ));
+        break;
+    case EM_GETRECT:
+    case CB_GETDROPPEDCONTROLRECT:
+    case LB_GETITEMRECT:
+    case WM_SIZING:
+    case WM_MOVING:
+        memcpy( (RECT *)lparam, buffer, min( sizeof(RECT), size ));
+        break;
+    case EM_GETLINE:
+        size = min( size, (size_t)*(WORD *)lparam );
+        memcpy( (WCHAR *)lparam, buffer, size );
+        break;
+    case LB_GETSELITEMS:
+        memcpy( (UINT *)lparam, buffer, min( wparam*sizeof(UINT), size ));
+        break;
+    case LB_GETTEXT:
+    case CB_GETLBTEXT:
+        memcpy( (WCHAR *)lparam, buffer, size );
+        break;
+    case WM_NEXTMENU:
+        if (size >= sizeof(ps->mnm))
+        {
+            MDINEXTMENU *mnm = (MDINEXTMENU *)lparam;
+            mnm->hmenuIn   = wine_server_ptr_handle( ps->mnm.hmenuIn );
+            mnm->hmenuNext = wine_server_ptr_handle( ps->mnm.hmenuNext );
+            mnm->hwndNext  = wine_server_ptr_handle( ps->mnm.hwndNext );
+        }
+        break;
+    case WM_MDIGETACTIVE:
+        if (lparam) memcpy( (BOOL *)lparam, buffer, min( sizeof(BOOL), size ));
+        break;
+    case WM_NCCALCSIZE:
+        if (!wparam)
+            memcpy( (RECT *)lparam, buffer, min( sizeof(RECT), size ));
+        else if (size >= sizeof(ps->ncp))
+        {
+            NCCALCSIZE_PARAMS *ncp = (NCCALCSIZE_PARAMS *)lparam;
+            ncp->rgrc[0]                = ps->ncp.rgrc[0];
+            ncp->rgrc[1]                = ps->ncp.rgrc[1];
+            ncp->rgrc[2]                = ps->ncp.rgrc[2];
+            ncp->lppos->hwnd            = wine_server_ptr_handle( ps->ncp.hwnd );
+            ncp->lppos->hwndInsertAfter = wine_server_ptr_handle( ps->ncp.hwndInsertAfter );
+            ncp->lppos->x               = ps->ncp.x;
+            ncp->lppos->y               = ps->ncp.y;
+            ncp->lppos->cx              = ps->ncp.cx;
+            ncp->lppos->cy              = ps->ncp.cy;
+            ncp->lppos->flags           = ps->ncp.flags;
+        }
+        break;
+    case EM_GETSEL:
+    case SBM_GETRANGE:
+    case CB_GETEDITSEL:
+        if (wparam)
+        {
+            memcpy( (DWORD *)wparam, buffer, min( sizeof(DWORD), size ));
+            if (size <= sizeof(DWORD)) break;
+            size -= sizeof(DWORD);
+            buffer = (DWORD *)buffer + 1;
+        }
+        if (lparam) memcpy( (DWORD *)lparam, buffer, min( sizeof(DWORD), size ));
+        break;
+    case WM_MDICREATE:
+        if (size >= sizeof(ps->mcs))
+        {
+            MDICREATESTRUCTW *mcs = (MDICREATESTRUCTW *)lparam;
+            mcs->hOwner  = unpack_ptr( ps->mcs.hOwner );
+            mcs->x       = ps->mcs.x;
+            mcs->y       = ps->mcs.y;
+            mcs->cx      = ps->mcs.cx;
+            mcs->cy      = ps->mcs.cy;
+            mcs->style   = ps->mcs.style;
+            mcs->lParam  = (LPARAM)unpack_ptr( ps->mcs.lParam );
+            /* don't allow changing class and title pointers */
+        }
+        break;
+    default:
+        ERR( "should not happen: unexpected message %x\n", message );
+        break;
+    }
+}
+
+
+/***********************************************************************
+ *           reply_message
+ *
+ * Send a reply to a sent message.
+ */
+static void reply_message( struct received_message_info *info, LRESULT result, BOOL remove )
+{
+    struct packed_message data;
+    int i, replied = info->flags & ISMEX_REPLIED;
+
+    if (info->flags & ISMEX_NOTIFY) return;  /* notify messages don't get replies */
+    if (!remove && replied) return;  /* replied already */
+
+    memset( &data, 0, sizeof(data) );
+    info->flags |= ISMEX_REPLIED;
+
+    if (info->type == MSG_OTHER_PROCESS && !replied)
+    {
+        pack_reply( info->msg.hwnd, info->msg.message, info->msg.wParam,
+                    info->msg.lParam, result, &data );
+    }
+
+    SERVER_START_REQ( reply_message )
+    {
+        req->result = result;
+        req->remove = remove;
+        for (i = 0; i < data.count; i++) wine_server_add_data( req, data.data[i], data.size[i] );
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+
+/***********************************************************************
+ *           handle_internal_message
+ *
+ * Handle an internal Wine message instead of calling the window proc.
+ */
+LRESULT handle_internal_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
+{
+    MSG m;
+    m.hwnd    = hwnd;
+    m.message = msg;
+    m.wParam  = wparam;
+    m.lParam  = lparam;
+    return NtUserCallOneParam( (UINT_PTR)&m, NtUserHandleInternalMessage );
+}
+
+/* since the WM_DDE_ACK response to a WM_DDE_EXECUTE message should contain the handle
+ * to the memory handle, we keep track (in the server side) of all pairs of handle
+ * used (the client passes its value and the content of the memory handle), and
+ * the server stored both values (the client, and the local one, created after the
+ * content). When a ACK message is generated, the list of pair is searched for a
+ * matching pair, so that the client memory handle can be returned.
+ */
+struct DDE_pair {
+    HGLOBAL     client_hMem;
+    HGLOBAL     server_hMem;
+};
+
+static      struct DDE_pair*    dde_pairs;
+static      int                 dde_num_alloc;
+static      int                 dde_num_used;
+
+static CRITICAL_SECTION dde_crst;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &dde_crst,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": dde_crst") }
+};
+static CRITICAL_SECTION dde_crst = { &critsect_debug, -1, 0, 0, 0, 0 };
+
+static BOOL dde_add_pair(HGLOBAL chm, HGLOBAL shm)
+{
+    int  i;
+#define GROWBY  4
+
+    EnterCriticalSection(&dde_crst);
+
+    /* now remember the pair of hMem on both sides */
+    if (dde_num_used == dde_num_alloc)
+    {
+        struct DDE_pair* tmp;
+	if (dde_pairs)
+	    tmp  = HeapReAlloc( GetProcessHeap(), 0, dde_pairs,
+                                            (dde_num_alloc + GROWBY) * sizeof(struct DDE_pair));
+	else
+	    tmp  = HeapAlloc( GetProcessHeap(), 0, 
+                                            (dde_num_alloc + GROWBY) * sizeof(struct DDE_pair));
+
+        if (!tmp)
+        {
+            LeaveCriticalSection(&dde_crst);
+            return FALSE;
+        }
+        dde_pairs = tmp;
+        /* zero out newly allocated part */
+        memset(&dde_pairs[dde_num_alloc], 0, GROWBY * sizeof(struct DDE_pair));
+        dde_num_alloc += GROWBY;
+    }
+#undef GROWBY
+    for (i = 0; i < dde_num_alloc; i++)
+    {
+        if (dde_pairs[i].server_hMem == 0)
+        {
+            dde_pairs[i].client_hMem = chm;
+            dde_pairs[i].server_hMem = shm;
+            dde_num_used++;
+            break;
+        }
+    }
+    LeaveCriticalSection(&dde_crst);
+    return TRUE;
+}
+
+static HGLOBAL dde_get_pair(HGLOBAL shm)
+{
+    int  i;
+    HGLOBAL     ret = 0;
+
+    EnterCriticalSection(&dde_crst);
+    for (i = 0; i < dde_num_alloc; i++)
+    {
+        if (dde_pairs[i].server_hMem == shm)
+        {
+            /* free this pair */
+            dde_pairs[i].server_hMem = 0;
+            dde_num_used--;
+            ret = dde_pairs[i].client_hMem;
+            break;
+        }
+    }
+    LeaveCriticalSection(&dde_crst);
+    return ret;
+}
+
+/***********************************************************************
+ *		post_dde_message
+ *
+ * Post a DDE message
+ */
+static BOOL post_dde_message( struct packed_message *data, const struct send_message_info *info )
 {
     void*       ptr = NULL;
     int         size = 0;
     UINT_PTR    uiLo, uiHi;
     LPARAM      lp;
     HGLOBAL     hunlock = 0;
+    int         i;
     DWORD       res;
     ULONGLONG   hpack;
 
-    if (!UnpackDDElParam( msg, lparam, &uiLo, &uiHi ))
+    if (!UnpackDDElParam( info->msg, info->lparam, &uiLo, &uiHi ))
+        return FALSE;
+
+    lp = info->lparam;
+    switch (info->msg)
+    {
+        /* DDE messages which don't require packing are:
+         * WM_DDE_INITIATE
+         * WM_DDE_TERMINATE
+         * WM_DDE_REQUEST
+         * WM_DDE_UNADVISE
+         */
+    case WM_DDE_ACK:
+        if (HIWORD(uiHi))
+        {
+            /* uiHi should contain a hMem from WM_DDE_EXECUTE */
+            HGLOBAL h = dde_get_pair( (HANDLE)uiHi );
+            if (h)
+            {
+                hpack = pack_ptr( h );
+                /* send back the value of h on the other side */
+                push_data( data, &hpack, sizeof(hpack) );
+                lp = uiLo;
+                TRACE( "send dde-ack %Ix %08Ix => %p\n", uiLo, uiHi, h );
+            }
+        }
+        else
+        {
+            /* uiHi should contain either an atom or 0 */
+            TRACE( "send dde-ack %Ix atom=%Ix\n", uiLo, uiHi );
+            lp = MAKELONG( uiLo, uiHi );
+        }
+        break;
+    case WM_DDE_ADVISE:
+    case WM_DDE_DATA:
+    case WM_DDE_POKE:
+        size = 0;
+        if (uiLo)
+        {
+            size = GlobalSize( (HGLOBAL)uiLo ) ;
+            if ((info->msg == WM_DDE_ADVISE && size < sizeof(DDEADVISE)) ||
+                (info->msg == WM_DDE_DATA   && size < FIELD_OFFSET(DDEDATA, Value)) ||
+                (info->msg == WM_DDE_POKE   && size < FIELD_OFFSET(DDEPOKE, Value))
+                )
+            return FALSE;
+        }
+        else if (info->msg != WM_DDE_DATA) return FALSE;
+
+        lp = uiHi;
+        if (uiLo)
+        {
+            if ((ptr = GlobalLock( (HGLOBAL)uiLo) ))
+            {
+                DDEDATA *dde_data = ptr;
+                TRACE("unused %d, fResponse %d, fRelease %d, fDeferUpd %d, fAckReq %d, cfFormat %d\n",
+                       dde_data->unused, dde_data->fResponse, dde_data->fRelease,
+                       dde_data->reserved, dde_data->fAckReq, dde_data->cfFormat);
+                push_data( data, ptr, size );
+                hunlock = (HGLOBAL)uiLo;
+            }
+        }
+        TRACE( "send ddepack %u %Ix\n", size, uiHi );
+        break;
+    case WM_DDE_EXECUTE:
+        if (info->lparam)
+        {
+            if ((ptr = GlobalLock( (HGLOBAL)info->lparam) ))
+            {
+                push_data(data, ptr, GlobalSize( (HGLOBAL)info->lparam ));
+                /* so that the other side can send it back on ACK */
+                lp = info->lparam;
+                hunlock = (HGLOBAL)info->lparam;
+            }
+        }
+        break;
+    }
+    SERVER_START_REQ( send_message )
+    {
+        req->id      = info->dest_tid;
+        req->type    = info->type;
+        req->flags   = 0;
+        req->win     = wine_server_user_handle( info->hwnd );
+        req->msg     = info->msg;
+        req->wparam  = info->wparam;
+        req->lparam  = lp;
+        req->timeout = TIMEOUT_INFINITE;
+        for (i = 0; i < data->count; i++)
+            wine_server_add_data( req, data->data[i], data->size[i] );
+        if ((res = wine_server_call( req )))
+        {
+            if (res == STATUS_INVALID_PARAMETER)
+                /* FIXME: find a STATUS_ value for this one */
+                SetLastError( ERROR_INVALID_THREAD_ID );
+            else
+                SetLastError( RtlNtStatusToDosError(res) );
+        }
+        else
+            FreeDDElParam(info->msg, info->lparam);
+    }
+    SERVER_END_REQ;
+    if (hunlock) GlobalUnlock(hunlock);
+
+    return !res;
+}
+
+/***********************************************************************
+ *		unpack_dde_message
+ *
+ * Unpack a posted DDE message received from another process.
+ */
+static BOOL unpack_dde_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lparam,
+                                void **buffer, size_t size )
+{
+    UINT_PTR	uiLo, uiHi;
+    HGLOBAL	hMem = 0;
+    void*	ptr;
+
+    switch (message)
+    {
+    case WM_DDE_ACK:
+        if (size)
+        {
+            ULONGLONG hpack;
+            /* hMem is being passed */
+            if (size != sizeof(hpack)) return FALSE;
+            if (!buffer || !*buffer) return FALSE;
+            uiLo = *lparam;
+            memcpy( &hpack, *buffer, size );
+            hMem = unpack_ptr( hpack );
+            uiHi = (UINT_PTR)hMem;
+            TRACE("recv dde-ack %Ix mem=%Ix[%Ix]\n", uiLo, uiHi, GlobalSize( hMem ));
+        }
+        else
+        {
+            uiLo = LOWORD( *lparam );
+            uiHi = HIWORD( *lparam );
+            TRACE("recv dde-ack %Ix atom=%Ix\n", uiLo, uiHi);
+        }
+	*lparam = PackDDElParam( WM_DDE_ACK, uiLo, uiHi );
+	break;
+    case WM_DDE_ADVISE:
+    case WM_DDE_DATA:
+    case WM_DDE_POKE:
+	if ((!buffer || !*buffer) && message != WM_DDE_DATA) return FALSE;
+	uiHi = *lparam;
+        if (size)
+        {
+            if (!(hMem = GlobalAlloc( GMEM_MOVEABLE|GMEM_DDESHARE, size )))
+                return FALSE;
+            if ((ptr = GlobalLock( hMem )))
+            {
+                memcpy( ptr, *buffer, size );
+                GlobalUnlock( hMem );
+            }
+            else
+            {
+                GlobalFree( hMem );
+                return FALSE;
+            }
+        }
+        uiLo = (UINT_PTR)hMem;
+
+	*lparam = PackDDElParam( message, uiLo, uiHi );
+	break;
+    case WM_DDE_EXECUTE:
+	if (size)
+	{
+	    if (!buffer || !*buffer) return FALSE;
+            if (!(hMem = GlobalAlloc( GMEM_MOVEABLE|GMEM_DDESHARE, size ))) return FALSE;
+            if ((ptr = GlobalLock( hMem )))
+	    {
+		memcpy( ptr, *buffer, size );
+		GlobalUnlock( hMem );
+                TRACE( "exec: pairing c=%08Ix s=%p\n", *lparam, hMem );
+                if (!dde_add_pair( (HGLOBAL)*lparam, hMem ))
+                {
+                    GlobalFree( hMem );
+                    return FALSE;
+                }
+            }
+            else
+            {
+                GlobalFree( hMem );
+                return FALSE;
+            }
+	} else return FALSE;
+        *lparam = (LPARAM)hMem;
+        break;
+    }
+    return TRUE;
+}
+
+/***********************************************************************
+ *           call_window_proc
+ *
+ * Call a window procedure and the corresponding hooks.
+ */
+static LRESULT call_window_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
+                                 BOOL unicode, BOOL same_thread, enum wm_char_mapping mapping )
+{
+    LRESULT result = 0;
+    CWPSTRUCT cwp;
+    CWPRETSTRUCT cwpret;
+
+    if (msg & 0x80000000)
+    {
+        result = handle_internal_message( hwnd, msg, wparam, lparam );
+        goto done;
+    }
+
+    /* first the WH_CALLWNDPROC hook */
+    hwnd = WIN_GetFullHandle( hwnd );
+    cwp.lParam  = lparam;
+    cwp.wParam  = wparam;
+    cwp.message = msg;
+    cwp.hwnd    = hwnd;
+    HOOK_CallHooks( WH_CALLWNDPROC, HC_ACTION, same_thread, (LPARAM)&cwp, unicode );
+
+    /* now call the window procedure */
+    if (!WINPROC_call_window( hwnd, msg, wparam, lparam, &result, unicode, mapping )) goto done;
+
+    /* and finally the WH_CALLWNDPROCRET hook */
+    cwpret.lResult = result;
+    cwpret.lParam  = lparam;
+    cwpret.wParam  = wparam;
+    cwpret.message = msg;
+    cwpret.hwnd    = hwnd;
+    HOOK_CallHooks( WH_CALLWNDPROCRET, HC_ACTION, same_thread, (LPARAM)&cwpret, unicode );
+ done:
+    return result;
+}
+
+
+/***********************************************************************
+ *           send_parent_notify
+ *
+ * Send a WM_PARENTNOTIFY to all ancestors of the given window, unless
+ * the window has the WS_EX_NOPARENTNOTIFY style.
+ */
+static void send_parent_notify( HWND hwnd, WORD event, WORD idChild, POINT pt )
+{
+    /* pt has to be in the client coordinates of the parent window */
+    MapWindowPoints( 0, hwnd, &pt, 1 );
+    for (;;)
+    {
+        HWND parent;
+
+        if (!(GetWindowLongW( hwnd, GWL_STYLE ) & WS_CHILD)) break;
+        if (GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_NOPARENTNOTIFY) break;
+        if (!(parent = GetParent(hwnd))) break;
+        if (parent == GetDesktopWindow()) break;
+        MapWindowPoints( hwnd, parent, &pt, 1 );
+        hwnd = parent;
+        SendMessageW( hwnd, WM_PARENTNOTIFY,
+                      MAKEWPARAM( event, idChild ), MAKELPARAM( pt.x, pt.y ) );
+    }
+}
+
+
+/***********************************************************************
+ *          accept_hardware_message
+ *
+ * Tell the server we have passed the message to the app
+ * (even though we may end up dropping it later on)
+ */
+static void accept_hardware_message( UINT hw_id )
+{
+    SERVER_START_REQ( accept_hardware_message )
+    {
+        req->hw_id = hw_id;
+        if (wine_server_call( req ))
+            FIXME("Failed to reply to MSG_HARDWARE message. Message may not be removed from queue.\n");
+    }
+    SERVER_END_REQ;
+}
+
+
+static BOOL process_rawinput_message( MSG *msg, UINT hw_id, const struct hardware_msg_data *msg_data )
+{
+    struct rawinput_thread_data *thread_data = rawinput_thread_data();
+
+    if (msg->message == WM_INPUT_DEVICE_CHANGE)
+        rawinput_update_device_list();
+    else
+    {
+        thread_data->buffer->header.dwSize = RAWINPUT_BUFFER_SIZE;
+        if (!rawinput_from_hardware_message( thread_data->buffer, msg_data )) return FALSE;
+        thread_data->hw_id = hw_id;
+        msg->lParam = (LPARAM)hw_id;
+    }
+
+    msg->pt = point_phys_to_win_dpi( msg->hwnd, msg->pt );
+    return TRUE;
+}
+
+/***********************************************************************
+ *          process_keyboard_message
+ *
+ * returns TRUE if the contents of 'msg' should be passed to the application
+ */
+static BOOL process_keyboard_message( MSG *msg, UINT hw_id, HWND hwnd_filter,
+                                      UINT first, UINT last, BOOL remove )
+{
+    EVENTMSG event;
+
+    if (msg->message == WM_KEYDOWN || msg->message == WM_SYSKEYDOWN ||
+        msg->message == WM_KEYUP || msg->message == WM_SYSKEYUP)
+        switch (msg->wParam)
+        {
+            case VK_LSHIFT: case VK_RSHIFT:
+                msg->wParam = VK_SHIFT;
+                break;
+            case VK_LCONTROL: case VK_RCONTROL:
+                msg->wParam = VK_CONTROL;
+                break;
+            case VK_LMENU: case VK_RMENU:
+                msg->wParam = VK_MENU;
+                break;
+        }
+
+    /* FIXME: is this really the right place for this hook? */
+    event.message = msg->message;
+    event.hwnd    = msg->hwnd;
+    event.time    = msg->time;
+    event.paramL  = (msg->wParam & 0xFF) | (HIWORD(msg->lParam) << 8);
+    event.paramH  = msg->lParam & 0x7FFF;
+    if (HIWORD(msg->lParam) & 0x0100) event.paramH |= 0x8000; /* special_key - bit */
+    HOOK_CallHooks( WH_JOURNALRECORD, HC_ACTION, 0, (LPARAM)&event, TRUE );
+
+    /* check message filters */
+    if (msg->message < first || msg->message > last) return FALSE;
+    if (!check_hwnd_filter( msg, hwnd_filter )) return FALSE;
+
+    if (remove)
+    {
+        if((msg->message == WM_KEYDOWN) &&
+           (msg->hwnd != GetDesktopWindow()))
+        {
+            /* Handle F1 key by sending out WM_HELP message */
+            if (msg->wParam == VK_F1)
+            {
+                PostMessageW( msg->hwnd, WM_KEYF1, 0, 0 );
+            }
+            else if(msg->wParam >= VK_BROWSER_BACK &&
+                    msg->wParam <= VK_LAUNCH_APP2)
+            {
+                /* FIXME: Process keystate */
+                SendMessageW(msg->hwnd, WM_APPCOMMAND, (WPARAM)msg->hwnd, MAKELPARAM(0, (FAPPCOMMAND_KEY | (msg->wParam - VK_BROWSER_BACK + 1))));
+            }
+        }
+        else if (msg->message == WM_KEYUP)
+        {
+            /* Handle VK_APPS key by posting a WM_CONTEXTMENU message */
+            if (msg->wParam == VK_APPS && !MENU_IsMenuActive())
+                PostMessageW(msg->hwnd, WM_CONTEXTMENU, (WPARAM)msg->hwnd, -1);
+        }
+    }
+
+    if (HOOK_CallHooks( WH_KEYBOARD, remove ? HC_ACTION : HC_NOREMOVE,
+                        LOWORD(msg->wParam), msg->lParam, TRUE ))
+    {
+        /* skip this message */
+        HOOK_CallHooks( WH_CBT, HCBT_KEYSKIPPED, LOWORD(msg->wParam), msg->lParam, TRUE );
+        accept_hardware_message( hw_id );
         return FALSE;
+    }
+    if (remove) accept_hardware_message( hw_id );
+    msg->pt = point_phys_to_win_dpi( msg->hwnd, msg->pt );
+
+    if ( remove && msg->message == WM_KEYDOWN )
+        if (ImmProcessKey(msg->hwnd, NtUserGetKeyboardLayout(0), msg->wParam, msg->lParam, 0) )
+            msg->wParam = VK_PROCESSKEY;
+
+    return TRUE;
+}
+
 
-    lp = lparam;
-    switch (msg)
+/***********************************************************************
+ *          process_mouse_message
+ *
+ * returns TRUE if the contents of 'msg' should be passed to the application
+ */
+static BOOL process_mouse_message( MSG *msg, UINT hw_id, ULONG_PTR extra_info, HWND hwnd_filter,
+                                   UINT first, UINT last, BOOL remove )
+{
+    static MSG clk_msg;
+
+    POINT pt;
+    UINT message;
+    INT hittest;
+    EVENTMSG event;
+    GUITHREADINFO info;
+    MOUSEHOOKSTRUCTEX hook;
+    BOOL eatMsg;
+    WPARAM wparam;
+
+    /* find the window to dispatch this mouse message to */
+
+    info.cbSize = sizeof(info);
+    NtUserGetGUIThreadInfo( GetCurrentThreadId(), &info );
+    if (info.hwndCapture)
     {
-        /* DDE messages which don't require packing are:
-         * WM_DDE_INITIATE
-         * WM_DDE_TERMINATE
-         * WM_DDE_REQUEST
-         * WM_DDE_UNADVISE
+        hittest = HTCLIENT;
+        msg->hwnd = info.hwndCapture;
+    }
+    else
+    {
+        HWND orig = msg->hwnd;
+
+        msg->hwnd = WINPOS_WindowFromPoint( msg->hwnd, msg->pt, &hittest );
+        if (!msg->hwnd) /* As a heuristic, try the next window if it's the owner of orig */
+        {
+            HWND next = GetWindow( orig, GW_HWNDNEXT );
+
+            if (next && GetWindow( orig, GW_OWNER ) == next && WIN_IsCurrentThread( next ))
+                msg->hwnd = WINPOS_WindowFromPoint( next, msg->pt, &hittest );
+        }
+    }
+
+    if (!msg->hwnd || !WIN_IsCurrentThread( msg->hwnd ))
+    {
+        accept_hardware_message( hw_id );
+        return FALSE;
+    }
+
+    msg->pt = point_phys_to_win_dpi( msg->hwnd, msg->pt );
+    SetThreadDpiAwarenessContext( GetWindowDpiAwarenessContext( msg->hwnd ));
+
+    /* FIXME: is this really the right place for this hook? */
+    event.message = msg->message;
+    event.time    = msg->time;
+    event.hwnd    = msg->hwnd;
+    event.paramL  = msg->pt.x;
+    event.paramH  = msg->pt.y;
+    HOOK_CallHooks( WH_JOURNALRECORD, HC_ACTION, 0, (LPARAM)&event, TRUE );
+
+    if (!check_hwnd_filter( msg, hwnd_filter )) return FALSE;
+
+    pt = msg->pt;
+    message = msg->message;
+    wparam = msg->wParam;
+    /* Note: windows has no concept of a non-client wheel message */
+    if (message != WM_MOUSEWHEEL)
+    {
+        if (hittest != HTCLIENT)
+        {
+            message += WM_NCMOUSEMOVE - WM_MOUSEMOVE;
+            wparam = hittest;
+        }
+        else
+        {
+            /* coordinates don't get translated while tracking a menu */
+            /* FIXME: should differentiate popups and top-level menus */
+            if (!(info.flags & GUI_INMENUMODE))
+                ScreenToClient( msg->hwnd, &pt );
+        }
+    }
+    msg->lParam = MAKELONG( pt.x, pt.y );
+
+    /* translate double clicks */
+
+    if ((msg->message == WM_LBUTTONDOWN) ||
+        (msg->message == WM_RBUTTONDOWN) ||
+        (msg->message == WM_MBUTTONDOWN) ||
+        (msg->message == WM_XBUTTONDOWN))
+    {
+        BOOL update = remove;
+
+        /* translate double clicks -
+	 * note that ...MOUSEMOVEs can slip in between
+	 * ...BUTTONDOWN and ...BUTTONDBLCLK messages */
+
+        if ((info.flags & (GUI_INMENUMODE|GUI_INMOVESIZE)) ||
+            hittest != HTCLIENT ||
+            (GetClassLongA( msg->hwnd, GCL_STYLE ) & CS_DBLCLKS))
+        {
+           if ((msg->message == clk_msg.message) &&
+               (msg->hwnd == clk_msg.hwnd) &&
+               (msg->wParam == clk_msg.wParam) &&
+               (msg->time - clk_msg.time < NtUserGetDoubleClickTime()) &&
+               (abs(msg->pt.x - clk_msg.pt.x) < GetSystemMetrics(SM_CXDOUBLECLK)/2) &&
+               (abs(msg->pt.y - clk_msg.pt.y) < GetSystemMetrics(SM_CYDOUBLECLK)/2))
+           {
+               message += (WM_LBUTTONDBLCLK - WM_LBUTTONDOWN);
+               if (update)
+               {
+                   clk_msg.message = 0;  /* clear the double click conditions */
+                   update = FALSE;
+               }
+           }
+        }
+        if (message < first || message > last) return FALSE;
+        /* update static double click conditions */
+        if (update) clk_msg = *msg;
+    }
+    else
+    {
+        if (message < first || message > last) return FALSE;
+    }
+    msg->wParam = wparam;
+
+    /* message is accepted now (but may still get dropped) */
+
+    hook.s.pt           = msg->pt;
+    hook.s.hwnd         = msg->hwnd;
+    hook.s.wHitTestCode = hittest;
+    hook.s.dwExtraInfo  = extra_info;
+    hook.mouseData      = msg->wParam;
+    if (HOOK_CallHooks( WH_MOUSE, remove ? HC_ACTION : HC_NOREMOVE,
+                        message, (LPARAM)&hook, TRUE ))
+    {
+        hook.s.pt           = msg->pt;
+        hook.s.hwnd         = msg->hwnd;
+        hook.s.wHitTestCode = hittest;
+        hook.s.dwExtraInfo  = extra_info;
+        hook.mouseData      = msg->wParam;
+        HOOK_CallHooks( WH_CBT, HCBT_CLICKSKIPPED, message, (LPARAM)&hook, TRUE );
+        accept_hardware_message( hw_id );
+        return FALSE;
+    }
+
+    if ((hittest == HTERROR) || (hittest == HTNOWHERE))
+    {
+        SendMessageW( msg->hwnd, WM_SETCURSOR, (WPARAM)msg->hwnd,
+                      MAKELONG( hittest, msg->message ));
+        accept_hardware_message( hw_id );
+        return FALSE;
+    }
+
+    if (remove) accept_hardware_message( hw_id );
+
+    if (!remove || info.hwndCapture)
+    {
+        msg->message = message;
+        return TRUE;
+    }
+
+    eatMsg = FALSE;
+
+    if ((msg->message == WM_LBUTTONDOWN) ||
+        (msg->message == WM_RBUTTONDOWN) ||
+        (msg->message == WM_MBUTTONDOWN) ||
+        (msg->message == WM_XBUTTONDOWN))
+    {
+        /* Send the WM_PARENTNOTIFY,
+         * note that even for double/nonclient clicks
+         * notification message is still WM_L/M/RBUTTONDOWN.
          */
-    case WM_DDE_ACK:
-        if (HIWORD(uiHi))
+        send_parent_notify( msg->hwnd, msg->message, 0, msg->pt );
+
+        /* Activate the window if needed */
+
+        if (msg->hwnd != info.hwndActive)
         {
-            /* uiHi should contain a hMem from WM_DDE_EXECUTE */
-            HGLOBAL h = dde_get_pair( (HANDLE)uiHi );
-            if (h)
+            HWND hwndTop = NtUserGetAncestor( msg->hwnd, GA_ROOT );
+
+            if ((GetWindowLongW( hwndTop, GWL_STYLE ) & (WS_POPUP|WS_CHILD)) != WS_CHILD)
             {
-                hpack = pack_ptr( h );
-                /* send back the value of h on the other side */
-                ptr = &hpack;
-                size = sizeof(hpack);
-                lp = uiLo;
-                TRACE( "send dde-ack %Ix %08Ix => %p\n", uiLo, uiHi, h );
+                LONG ret = SendMessageW( msg->hwnd, WM_MOUSEACTIVATE, (WPARAM)hwndTop,
+                                         MAKELONG( hittest, msg->message ) );
+                switch(ret)
+                {
+                case MA_NOACTIVATEANDEAT:
+                    eatMsg = TRUE;
+                    /* fall through */
+                case MA_NOACTIVATE:
+                    break;
+                case MA_ACTIVATEANDEAT:
+                    eatMsg = TRUE;
+                    /* fall through */
+                case MA_ACTIVATE:
+                case 0:
+                    if (!FOCUS_MouseActivate( hwndTop )) eatMsg = TRUE;
+                    break;
+                default:
+                    WARN( "unknown WM_MOUSEACTIVATE code %d\n", ret );
+                    break;
+                }
             }
         }
-        else
-        {
-            /* uiHi should contain either an atom or 0 */
-            TRACE( "send dde-ack %Ix atom=%Ix\n", uiLo, uiHi );
-            lp = MAKELONG( uiLo, uiHi );
-        }
-        break;
-    case WM_DDE_ADVISE:
-    case WM_DDE_DATA:
-    case WM_DDE_POKE:
-        if (uiLo)
+    }
+
+    /* send the WM_SETCURSOR message */
+
+    /* Windows sends the normal mouse message as the message parameter
+       in the WM_SETCURSOR message even if it's non-client mouse message */
+    SendMessageW( msg->hwnd, WM_SETCURSOR, (WPARAM)msg->hwnd, MAKELONG( hittest, msg->message ));
+
+    msg->message = message;
+    return !eatMsg;
+}
+
+
+/***********************************************************************
+ *           process_hardware_message
+ *
+ * Process a hardware message; return TRUE if message should be passed on to the app
+ */
+static BOOL process_hardware_message( MSG *msg, UINT hw_id, const struct hardware_msg_data *msg_data,
+                                      HWND hwnd_filter, UINT first, UINT last, BOOL remove )
+{
+    DPI_AWARENESS_CONTEXT context;
+    BOOL ret = FALSE;
+
+    get_user_thread_info()->msg_source.deviceType = msg_data->source.device;
+    get_user_thread_info()->msg_source.originId   = msg_data->source.origin;
+
+    /* hardware messages are always in physical coords */
+    context = SetThreadDpiAwarenessContext( DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE );
+
+    if (msg->message == WM_INPUT || msg->message == WM_INPUT_DEVICE_CHANGE)
+        ret = process_rawinput_message( msg, hw_id, msg_data );
+    else if (is_keyboard_message( msg->message ))
+        ret = process_keyboard_message( msg, hw_id, hwnd_filter, first, last, remove );
+    else if (is_mouse_message( msg->message ))
+        ret = process_mouse_message( msg, hw_id, msg_data->info, hwnd_filter, first, last, remove );
+    else
+        ERR( "unknown message type %x\n", msg->message );
+    SetThreadDpiAwarenessContext( context );
+    return ret;
+}
+
+
+/***********************************************************************
+ *           call_sendmsg_callback
+ *
+ * Call the callback function of SendMessageCallback.
+ */
+static inline void call_sendmsg_callback( SENDASYNCPROC callback, HWND hwnd, UINT msg,
+                                          ULONG_PTR data, LRESULT result )
+{
+    if (!callback) return;
+
+    TRACE_(relay)( "\1Call message callback %p (hwnd=%p,msg=%s,data=%08lx,result=%08lx)\n",
+                   callback, hwnd, SPY_GetMsgName( msg, hwnd ), data, result );
+    callback( hwnd, msg, data, result );
+    TRACE_(relay)( "\1Ret  message callback %p (hwnd=%p,msg=%s,data=%08lx,result=%08lx)\n",
+                   callback, hwnd, SPY_GetMsgName( msg, hwnd ), data, result );
+}
+
+
+/***********************************************************************
+ *           peek_message
+ *
+ * Peek for a message matching the given parameters. Return 0 if none are
+ * available; -1 on error.
+ * All pending sent messages are processed before returning.
+ */
+static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags, UINT changed_mask )
+{
+    LRESULT result;
+    struct user_thread_info *thread_info = get_user_thread_info();
+    INPUT_MESSAGE_SOURCE prev_source = thread_info->msg_source;
+    struct received_message_info info, *old_info;
+    unsigned int hw_id = 0;  /* id of previous hardware message */
+    void *buffer;
+    size_t buffer_size = 1024;
+
+    if (!(buffer = HeapAlloc( GetProcessHeap(), 0, buffer_size ))) return -1;
+
+    if (!first && !last) last = ~0;
+    if (hwnd == HWND_BROADCAST) hwnd = HWND_TOPMOST;
+
+    for (;;)
+    {
+        NTSTATUS res;
+        size_t size = 0;
+        const message_data_t *msg_data = buffer;
+
+        thread_info->msg_source = prev_source;
+
+        SERVER_START_REQ( get_message )
         {
-            size = GlobalSize( (HGLOBAL)uiLo ) ;
-            if ((msg == WM_DDE_ADVISE && size < sizeof(DDEADVISE)) ||
-                (msg == WM_DDE_DATA   && size < FIELD_OFFSET(DDEDATA, Value)) ||
-                (msg == WM_DDE_POKE   && size < FIELD_OFFSET(DDEPOKE, Value)))
-                return FALSE;
+            req->flags     = flags;
+            req->get_win   = wine_server_user_handle( hwnd );
+            req->get_first = first;
+            req->get_last  = last;
+            req->hw_id     = hw_id;
+            req->wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
+            req->changed_mask = changed_mask;
+            wine_server_set_reply( req, buffer, buffer_size );
+            if (!(res = wine_server_call( req )))
+            {
+                size = wine_server_reply_size( reply );
+                info.type        = reply->type;
+                info.msg.hwnd    = wine_server_ptr_handle( reply->win );
+                info.msg.message = reply->msg;
+                info.msg.wParam  = reply->wparam;
+                info.msg.lParam  = reply->lparam;
+                info.msg.time    = reply->time;
+                info.msg.pt.x    = reply->x;
+                info.msg.pt.y    = reply->y;
+                hw_id            = 0;
+                thread_info->active_hooks = reply->active_hooks;
+            }
+            else buffer_size = reply->total;
         }
-        else if (msg != WM_DDE_DATA) return FALSE;
+        SERVER_END_REQ;
 
-        lp = uiHi;
-        if (uiLo)
+        if (res)
         {
-            if ((ptr = GlobalLock( (HGLOBAL)uiLo) ))
+            HeapFree( GetProcessHeap(), 0, buffer );
+            if (res == STATUS_PENDING)
             {
-                DDEDATA *dde_data = ptr;
-                TRACE("unused %d, fResponse %d, fRelease %d, fDeferUpd %d, fAckReq %d, cfFormat %d\n",
-                       dde_data->unused, dde_data->fResponse, dde_data->fRelease,
-                       dde_data->reserved, dde_data->fAckReq, dde_data->cfFormat);
-                hunlock = (HGLOBAL)uiLo;
+                thread_info->wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
+                thread_info->changed_mask = changed_mask;
+                return 0;
             }
+            if (res != STATUS_BUFFER_OVERFLOW)
+            {
+                SetLastError( RtlNtStatusToDosError(res) );
+                return -1;
+            }
+            if (!(buffer = HeapAlloc( GetProcessHeap(), 0, buffer_size ))) return -1;
+            continue;
         }
-        TRACE( "send ddepack %u %Ix\n", size, uiHi );
-        break;
-    case WM_DDE_EXECUTE:
-        if (lparam)
+
+        TRACE( "got type %d msg %x (%s) hwnd %p wp %lx lp %lx\n",
+               info.type, info.msg.message,
+               (info.type == MSG_WINEVENT) ? "MSG_WINEVENT" : SPY_GetMsgName(info.msg.message, info.msg.hwnd),
+               info.msg.hwnd, info.msg.wParam, info.msg.lParam );
+
+        switch(info.type)
         {
-            if ((ptr = GlobalLock( (HGLOBAL)lparam) ))
+        case MSG_ASCII:
+        case MSG_UNICODE:
+            info.flags = ISMEX_SEND;
+            break;
+        case MSG_NOTIFY:
+            info.flags = ISMEX_NOTIFY;
+            if (!unpack_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
+                                 &info.msg.lParam, &buffer, size ))
+                continue;
+            break;
+        case MSG_CALLBACK:
+            info.flags = ISMEX_CALLBACK;
+            break;
+        case MSG_CALLBACK_RESULT:
+            if (size >= sizeof(msg_data->callback))
+                call_sendmsg_callback( wine_server_get_ptr(msg_data->callback.callback),
+                                       info.msg.hwnd, info.msg.message,
+                                       msg_data->callback.data, msg_data->callback.result );
+            continue;
+        case MSG_WINEVENT:
+            if (size >= sizeof(msg_data->winevent))
             {
-                size = GlobalSize( (HGLOBAL)lparam );
-                /* so that the other side can send it back on ACK */
-                lp = lparam;
-                hunlock = (HGLOBAL)lparam;
+                struct win_event_hook_params params;
+
+                params.proc = wine_server_get_ptr( msg_data->winevent.hook_proc );
+                size -= sizeof(msg_data->winevent);
+                if (size)
+                {
+                    size = min( size, sizeof(params.module) - sizeof(WCHAR) );
+                    memcpy( params.module, &msg_data->winevent + 1, size );
+                }
+                params.module[size / sizeof(WCHAR)] = 0;
+                size = FIELD_OFFSET( struct win_hook_params, module[size / sizeof(WCHAR) + 1] );
+
+                params.handle    = wine_server_ptr_handle( msg_data->winevent.hook );
+                params.event     = info.msg.message;
+                params.hwnd      = info.msg.hwnd;
+                params.object_id = info.msg.wParam;
+                params.child_id  = info.msg.lParam;
+                params.tid       = msg_data->winevent.tid;
+                params.time      = info.msg.time;
+
+                User32CallWinEventHook( &params, size );
+            }
+            continue;
+        case MSG_HOOK_LL:
+            info.flags = ISMEX_SEND;
+            result = 0;
+            if (info.msg.message == WH_KEYBOARD_LL && size >= sizeof(msg_data->hardware))
+            {
+                KBDLLHOOKSTRUCT hook;
+
+                hook.vkCode      = LOWORD( info.msg.lParam );
+                hook.scanCode    = HIWORD( info.msg.lParam );
+                hook.flags       = msg_data->hardware.flags;
+                hook.time        = info.msg.time;
+                hook.dwExtraInfo = msg_data->hardware.info;
+                TRACE( "calling keyboard LL hook vk %x scan %x flags %x time %u info %lx\n",
+                       hook.vkCode, hook.scanCode, hook.flags, hook.time, hook.dwExtraInfo );
+                result = HOOK_CallHooks( WH_KEYBOARD_LL, HC_ACTION, info.msg.wParam, (LPARAM)&hook, TRUE );
+            }
+            else if (info.msg.message == WH_MOUSE_LL && size >= sizeof(msg_data->hardware))
+            {
+                MSLLHOOKSTRUCT hook;
+
+                hook.pt          = info.msg.pt;
+                hook.mouseData   = info.msg.lParam;
+                hook.flags       = msg_data->hardware.flags;
+                hook.time        = info.msg.time;
+                hook.dwExtraInfo = msg_data->hardware.info;
+                TRACE( "calling mouse LL hook pos %d,%d data %x flags %x time %u info %lx\n",
+                       hook.pt.x, hook.pt.y, hook.mouseData, hook.flags, hook.time, hook.dwExtraInfo );
+                result = HOOK_CallHooks( WH_MOUSE_LL, HC_ACTION, info.msg.wParam, (LPARAM)&hook, TRUE );
             }
+            reply_message( &info, result, TRUE );
+            continue;
+        case MSG_OTHER_PROCESS:
+            info.flags = ISMEX_SEND;
+            if (!unpack_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
+                                 &info.msg.lParam, &buffer, size ))
+            {
+                /* ignore it */
+                reply_message( &info, 0, TRUE );
+                continue;
+            }
+            break;
+        case MSG_HARDWARE:
+            if (size >= sizeof(msg_data->hardware))
+            {
+                hw_id = msg_data->hardware.hw_id;
+                if (!process_hardware_message( &info.msg, hw_id, &msg_data->hardware,
+                                               hwnd, first, last, flags & PM_REMOVE ))
+                {
+                    TRACE("dropping msg %x\n", info.msg.message );
+                    continue;  /* ignore it */
+                }
+                *msg = info.msg;
+                thread_info->GetMessagePosVal = MAKELONG( info.msg.pt.x, info.msg.pt.y );
+                thread_info->GetMessageTimeVal = info.msg.time;
+                thread_info->GetMessageExtraInfoVal = msg_data->hardware.info;
+                HeapFree( GetProcessHeap(), 0, buffer );
+                HOOK_CallHooks( WH_GETMESSAGE, HC_ACTION, flags & PM_REMOVE, (LPARAM)msg, TRUE );
+                return 1;
+            }
+            continue;
+        case MSG_POSTED:
+            if (info.msg.message & 0x80000000)  /* internal message */
+            {
+                if (flags & PM_REMOVE)
+                {
+                    handle_internal_message( info.msg.hwnd, info.msg.message,
+                                             info.msg.wParam, info.msg.lParam );
+                    /* if this is a nested call return right away */
+                    if (first == info.msg.message && last == info.msg.message)
+                    {
+                        HeapFree( GetProcessHeap(), 0, buffer );
+                        return 0;
+                    }
+                }
+                else
+                    peek_message( msg, info.msg.hwnd, info.msg.message,
+                                  info.msg.message, flags | PM_REMOVE, changed_mask );
+                continue;
+            }
+	    if (info.msg.message >= WM_DDE_FIRST && info.msg.message <= WM_DDE_LAST)
+	    {
+		if (!unpack_dde_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
+                                         &info.msg.lParam, &buffer, size ))
+                    continue;  /* ignore it */
+	    }
+            *msg = info.msg;
+            msg->pt = point_phys_to_win_dpi( info.msg.hwnd, info.msg.pt );
+            thread_info->GetMessagePosVal = MAKELONG( msg->pt.x, msg->pt.y );
+            thread_info->GetMessageTimeVal = info.msg.time;
+            thread_info->GetMessageExtraInfoVal = 0;
+            thread_info->msg_source = msg_source_unavailable;
+            HeapFree( GetProcessHeap(), 0, buffer );
+            HOOK_CallHooks( WH_GETMESSAGE, HC_ACTION, flags & PM_REMOVE, (LPARAM)msg, TRUE );
+            return 1;
         }
-        break;
+
+        /* if we get here, we have a sent message; call the window procedure */
+        old_info = thread_info->receive_info;
+        thread_info->receive_info = &info;
+        thread_info->msg_source = msg_source_unavailable;
+        result = call_window_proc( info.msg.hwnd, info.msg.message, info.msg.wParam,
+                                   info.msg.lParam, (info.type != MSG_ASCII), FALSE,
+                                   WMCHAR_MAP_RECVMESSAGE );
+        reply_message( &info, result, TRUE );
+        thread_info->receive_info = old_info;
+
+        /* if some PM_QS* flags were specified, only handle sent messages from now on */
+        if (HIWORD(flags) && !changed_mask) flags = PM_QS_SENDMESSAGE | LOWORD(flags);
+    }
+}
+
+
+/***********************************************************************
+ *           process_sent_messages
+ *
+ * Process all pending sent messages.
+ */
+static inline void process_sent_messages(void)
+{
+    MSG msg;
+    peek_message( &msg, 0, 0, 0, PM_REMOVE | PM_QS_SENDMESSAGE, 0 );
+}
+
+
+/***********************************************************************
+ *           get_server_queue_handle
+ *
+ * Get a handle to the server message queue for the current thread.
+ */
+static HANDLE get_server_queue_handle(void)
+{
+    struct user_thread_info *thread_info = get_user_thread_info();
+    HANDLE ret;
+
+    if (!(ret = thread_info->server_queue))
+    {
+        SERVER_START_REQ( get_msg_queue )
+        {
+            wine_server_call( req );
+            ret = wine_server_ptr_handle( reply->handle );
+        }
+        SERVER_END_REQ;
+        thread_info->server_queue = ret;
+        if (!ret) ERR( "Cannot get server thread queue\n" );
+    }
+    return ret;
+}
+
+
+/***********************************************************************
+ *           wait_message_reply
+ *
+ * Wait until a sent message gets replied to.
+ */
+static void wait_message_reply( UINT flags )
+{
+    struct user_thread_info *thread_info = get_user_thread_info();
+    HANDLE server_queue = get_server_queue_handle();
+    unsigned int wake_mask = QS_SMRESULT | ((flags & SMTO_BLOCK) ? 0 : QS_SENDMESSAGE);
+
+    for (;;)
+    {
+        unsigned int wake_bits = 0;
+
+        SERVER_START_REQ( set_queue_mask )
+        {
+            req->wake_mask    = wake_mask;
+            req->changed_mask = wake_mask;
+            req->skip_wait    = 1;
+            if (!wine_server_call( req )) wake_bits = reply->wake_bits & wake_mask;
+        }
+        SERVER_END_REQ;
+
+        thread_info->wake_mask = thread_info->changed_mask = 0;
+
+        if (wake_bits & QS_SMRESULT) return;  /* got a result */
+        if (wake_bits & QS_SENDMESSAGE)
+        {
+            /* Process the sent message immediately */
+            process_sent_messages();
+            continue;
+        }
+
+        wow_handlers.wait_message( 1, &server_queue, INFINITE, wake_mask, 0 );
+    }
+}
+
+
+/***********************************************************************
+ *           wait_objects
+ *
+ * Wait for multiple objects including the server queue, with specific queue masks.
+ */
+static DWORD wait_objects( DWORD count, const HANDLE *handles, DWORD timeout,
+                           DWORD wake_mask, DWORD changed_mask, DWORD flags )
+{
+    struct user_thread_info *thread_info = get_user_thread_info();
+    DWORD ret;
+
+    assert( count );  /* we must have at least the server queue */
+
+    flush_window_surfaces( TRUE );
+
+    if (thread_info->wake_mask != wake_mask || thread_info->changed_mask != changed_mask)
+    {
+        SERVER_START_REQ( set_queue_mask )
+        {
+            req->wake_mask    = wake_mask;
+            req->changed_mask = changed_mask;
+            req->skip_wait    = 0;
+            wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        thread_info->wake_mask = wake_mask;
+        thread_info->changed_mask = changed_mask;
+    }
+
+    ret = wow_handlers.wait_message( count, handles, timeout, changed_mask, flags );
+
+    if (ret != WAIT_TIMEOUT) thread_info->wake_mask = thread_info->changed_mask = 0;
+    return ret;
+}
+
+
+/***********************************************************************
+ *		put_message_in_queue
+ *
+ * Put a sent message into the destination queue.
+ * For inter-process message, reply_size is set to expected size of reply data.
+ */
+static BOOL put_message_in_queue( const struct send_message_info *info, size_t *reply_size )
+{
+    struct packed_message data;
+    message_data_t msg_data;
+    unsigned int res;
+    int i;
+    timeout_t timeout = TIMEOUT_INFINITE;
+
+    /* Check for INFINITE timeout for compatibility with Win9x,
+     * although Windows >= NT does not do so
+     */
+    if (info->type != MSG_NOTIFY &&
+        info->type != MSG_CALLBACK &&
+        info->type != MSG_POSTED &&
+        info->timeout &&
+        info->timeout != INFINITE)
+    {
+        /* timeout is signed despite the prototype */
+        timeout = (timeout_t)max( 0, (int)info->timeout ) * -10000;
+    }
+
+    memset( &data, 0, sizeof(data) );
+    if (info->type == MSG_OTHER_PROCESS || info->type == MSG_NOTIFY)
+    {
+        *reply_size = pack_message( info->hwnd, info->msg, info->wparam, info->lparam, &data );
+        if (data.count == -1)
+        {
+            WARN( "cannot pack message %x\n", info->msg );
+            return FALSE;
+        }
+    }
+    else if (info->type == MSG_CALLBACK)
+    {
+        msg_data.callback.callback = wine_server_client_ptr( info->callback );
+        msg_data.callback.data     = info->data;
+        msg_data.callback.result   = 0;
+        data.data[0] = &msg_data;
+        data.size[0] = sizeof(msg_data.callback);
+        data.count = 1;
+    }
+    else if (info->type == MSG_POSTED && info->msg >= WM_DDE_FIRST && info->msg <= WM_DDE_LAST)
+    {
+        return post_dde_message( &data, info );
     }
+
     SERVER_START_REQ( send_message )
     {
-        req->id      = dest_tid;
-        req->type    = type;
+        req->id      = info->dest_tid;
+        req->type    = info->type;
         req->flags   = 0;
-        req->win     = wine_server_user_handle( hwnd );
-        req->msg     = msg;
-        req->wparam  = wparam;
-        req->lparam  = lp;
-        req->timeout = TIMEOUT_INFINITE;
-        if (size) wine_server_add_data( req, ptr, size );
+        req->win     = wine_server_user_handle( info->hwnd );
+        req->msg     = info->msg;
+        req->wparam  = info->wparam;
+        req->lparam  = info->lparam;
+        req->timeout = timeout;
+
+        if (info->flags & SMTO_ABORTIFHUNG) req->flags |= SEND_MSG_ABORT_IF_HUNG;
+        for (i = 0; i < data.count; i++) wine_server_add_data( req, data.data[i], data.size[i] );
         if ((res = wine_server_call( req )))
         {
             if (res == STATUS_INVALID_PARAMETER)
@@ -462,118 +3035,307 @@ BOOL post_dde_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, DWORD
             else
                 SetLastError( RtlNtStatusToDosError(res) );
         }
-        else
-            FreeDDElParam( msg, lparam );
     }
     SERVER_END_REQ;
-    if (hunlock) GlobalUnlock(hunlock);
-
     return !res;
 }
 
+
 /***********************************************************************
- *		unpack_dde_message
+ *		retrieve_reply
  *
- * Unpack a posted DDE message received from another process.
+ * Retrieve a message reply from the server.
  */
-BOOL unpack_dde_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lparam,
-                         void **buffer, size_t size )
+static LRESULT retrieve_reply( const struct send_message_info *info,
+                               size_t reply_size, LRESULT *result )
 {
-    UINT_PTR	uiLo, uiHi;
-    HGLOBAL	hMem = 0;
-    void*	ptr;
+    NTSTATUS status;
+    void *reply_data = NULL;
 
-    switch (message)
+    if (reply_size)
     {
-    case WM_DDE_ACK:
-        if (size)
+        if (!(reply_data = HeapAlloc( GetProcessHeap(), 0, reply_size )))
         {
-            ULONGLONG hpack;
-            /* hMem is being passed */
-            if (size != sizeof(hpack)) return FALSE;
-            if (!buffer || !*buffer) return FALSE;
-            uiLo = *lparam;
-            memcpy( &hpack, *buffer, size );
-            hMem = unpack_ptr( hpack );
-            uiHi = (UINT_PTR)hMem;
-            TRACE("recv dde-ack %Ix mem=%Ix[%Ix]\n", uiLo, uiHi, GlobalSize( hMem ));
+            WARN( "no memory for reply, will be truncated\n" );
+            reply_size = 0;
         }
+    }
+    SERVER_START_REQ( get_message_reply )
+    {
+        req->cancel = 1;
+        if (reply_size) wine_server_set_reply( req, reply_data, reply_size );
+        if (!(status = wine_server_call( req ))) *result = reply->result;
+        reply_size = wine_server_reply_size( reply );
+    }
+    SERVER_END_REQ;
+    if (!status && reply_size)
+        unpack_reply( info->hwnd, info->msg, info->wparam, info->lparam, reply_data, reply_size );
+
+    HeapFree( GetProcessHeap(), 0, reply_data );
+
+    TRACE( "hwnd %p msg %x (%s) wp %lx lp %lx got reply %lx (err=%d)\n",
+           info->hwnd, info->msg, SPY_GetMsgName(info->msg, info->hwnd), info->wparam,
+           info->lparam, *result, status );
+
+    /* MSDN states that last error is 0 on timeout, but at least NT4 returns ERROR_TIMEOUT */
+    if (status) SetLastError( RtlNtStatusToDosError(status) );
+    return !status;
+}
+
+
+/***********************************************************************
+ *		send_inter_thread_message
+ */
+static LRESULT send_inter_thread_message( const struct send_message_info *info, LRESULT *res_ptr )
+{
+    size_t reply_size = 0;
+
+    TRACE( "hwnd %p msg %x (%s) wp %lx lp %lx\n",
+           info->hwnd, info->msg, SPY_GetMsgName(info->msg, info->hwnd), info->wparam, info->lparam );
+
+    USER_CheckNotLock();
+
+    if (!put_message_in_queue( info, &reply_size )) return 0;
+
+    /* there's no reply to wait for on notify/callback messages */
+    if (info->type == MSG_NOTIFY || info->type == MSG_CALLBACK) return 1;
+
+    wait_message_reply( info->flags );
+    return retrieve_reply( info, reply_size, res_ptr );
+}
+
+
+/***********************************************************************
+ *		send_inter_thread_callback
+ */
+static LRESULT send_inter_thread_callback( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp,
+                                           LRESULT *result, void *arg )
+{
+    struct send_message_info *info = arg;
+    info->hwnd   = hwnd;
+    info->msg    = msg;
+    info->wparam = wp;
+    info->lparam = lp;
+    return send_inter_thread_message( info, result );
+}
+
+static BOOL is_message_broadcastable(UINT msg)
+{
+    return msg < WM_USER || msg >= 0xc000;
+}
+
+/***********************************************************************
+ *		send_message
+ *
+ * Backend implementation of the various SendMessage functions.
+ */
+static BOOL send_message( struct send_message_info *info, DWORD_PTR *res_ptr, BOOL unicode )
+{
+    struct user_thread_info *thread_info = get_user_thread_info();
+    INPUT_MESSAGE_SOURCE prev_source = thread_info->msg_source;
+    DWORD dest_pid;
+    BOOL ret;
+    LRESULT result;
+
+    if (is_broadcast(info->hwnd))
+    {
+        if (is_message_broadcastable( info->msg ))
+            EnumWindows( broadcast_message_callback, (LPARAM)info );
+        if (res_ptr) *res_ptr = 1;
+        return TRUE;
+    }
+
+    if (!(info->dest_tid = GetWindowThreadProcessId( info->hwnd, &dest_pid ))) return FALSE;
+
+    if (USER_IsExitingThread( info->dest_tid )) return FALSE;
+
+    thread_info->msg_source = msg_source_unavailable;
+    SPY_EnterMessage( SPY_SENDMESSAGE, info->hwnd, info->msg, info->wparam, info->lparam );
+
+    if (info->dest_tid == GetCurrentThreadId())
+    {
+        result = call_window_proc( info->hwnd, info->msg, info->wparam, info->lparam,
+                                   unicode, TRUE, info->wm_char );
+        if (info->type == MSG_CALLBACK)
+            call_sendmsg_callback( info->callback, info->hwnd, info->msg, info->data, result );
+        ret = TRUE;
+    }
+    else
+    {
+        if (dest_pid != GetCurrentProcessId() && (info->type == MSG_ASCII || info->type == MSG_UNICODE))
+            info->type = MSG_OTHER_PROCESS;
+
+        /* MSG_ASCII can be sent unconverted except for WM_CHAR; everything else needs to be Unicode */
+        if (!unicode && is_unicode_message( info->msg ) &&
+            (info->type != MSG_ASCII || info->msg == WM_CHAR))
+            ret = WINPROC_CallProcAtoW( send_inter_thread_callback, info->hwnd, info->msg,
+                                        info->wparam, info->lparam, &result, info, info->wm_char );
         else
+            ret = send_inter_thread_message( info, &result );
+    }
+
+    SPY_ExitMessage( SPY_RESULT_OK, info->hwnd, info->msg, result, info->wparam, info->lparam );
+    thread_info->msg_source = prev_source;
+    if (ret && res_ptr) *res_ptr = result;
+    return ret;
+}
+
+
+/***********************************************************************
+ *		send_hardware_message
+ */
+NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput, UINT flags )
+{
+    struct user_key_state_info *key_state_info = get_user_thread_info()->key_state;
+    struct send_message_info info;
+    int prev_x, prev_y, new_x, new_y;
+    INT counter = NtUserCallOneParam( 0, NtUserIncrementKeyStateCounter );
+    USAGE hid_usage_page, hid_usage;
+    NTSTATUS ret;
+    BOOL wait;
+
+    info.type     = MSG_HARDWARE;
+    info.dest_tid = 0;
+    info.hwnd     = hwnd;
+    info.flags    = 0;
+    info.timeout  = 0;
+
+    if (input->type == INPUT_HARDWARE && rawinput->header.dwType == RIM_TYPEHID)
+    {
+        if (input->u.hi.uMsg == WM_INPUT_DEVICE_CHANGE)
         {
-            uiLo = LOWORD( *lparam );
-            uiHi = HIWORD( *lparam );
-            TRACE("recv dde-ack %Ix atom=%Ix\n", uiLo, uiHi);
+            hid_usage_page = ((USAGE *)rawinput->data.hid.bRawData)[0];
+            hid_usage = ((USAGE *)rawinput->data.hid.bRawData)[1];
         }
-	*lparam = PackDDElParam( WM_DDE_ACK, uiLo, uiHi );
-	break;
-    case WM_DDE_ADVISE:
-    case WM_DDE_DATA:
-    case WM_DDE_POKE:
-	if ((!buffer || !*buffer) && message != WM_DDE_DATA) return FALSE;
-	uiHi = *lparam;
-        if (size)
+        if (input->u.hi.uMsg == WM_INPUT)
         {
-            if (!(hMem = GlobalAlloc( GMEM_MOVEABLE|GMEM_DDESHARE, size )))
-                return FALSE;
-            if ((ptr = GlobalLock( hMem )))
-            {
-                memcpy( ptr, *buffer, size );
-                GlobalUnlock( hMem );
-            }
-            else
+            if (!rawinput_device_get_usages( rawinput->header.hDevice, &hid_usage_page, &hid_usage ))
             {
-                GlobalFree( hMem );
-                return FALSE;
+                WARN( "unable to get HID usages for device %p\n", rawinput->header.hDevice );
+                return STATUS_INVALID_HANDLE;
             }
         }
-        uiLo = (UINT_PTR)hMem;
+    }
 
-	*lparam = PackDDElParam( message, uiLo, uiHi );
-	break;
-    case WM_DDE_EXECUTE:
-	if (size)
-	{
-	    if (!buffer || !*buffer) return FALSE;
-            if (!(hMem = GlobalAlloc( GMEM_MOVEABLE|GMEM_DDESHARE, size ))) return FALSE;
-            if ((ptr = GlobalLock( hMem )))
-	    {
-		memcpy( ptr, *buffer, size );
-		GlobalUnlock( hMem );
-                TRACE( "exec: pairing c=%08Ix s=%p\n", *lparam, hMem );
-                if (!dde_add_pair( (HGLOBAL)*lparam, hMem ))
+    SERVER_START_REQ( send_hardware_message )
+    {
+        req->win        = wine_server_user_handle( hwnd );
+        req->flags      = flags;
+        req->input.type = input->type;
+        switch (input->type)
+        {
+        case INPUT_MOUSE:
+            req->input.mouse.x     = input->u.mi.dx;
+            req->input.mouse.y     = input->u.mi.dy;
+            req->input.mouse.data  = input->u.mi.mouseData;
+            req->input.mouse.flags = input->u.mi.dwFlags;
+            req->input.mouse.time  = input->u.mi.time;
+            req->input.mouse.info  = input->u.mi.dwExtraInfo;
+            break;
+        case INPUT_KEYBOARD:
+            req->input.kbd.vkey  = input->u.ki.wVk;
+            req->input.kbd.scan  = input->u.ki.wScan;
+            req->input.kbd.flags = input->u.ki.dwFlags;
+            req->input.kbd.time  = input->u.ki.time;
+            req->input.kbd.info  = input->u.ki.dwExtraInfo;
+            break;
+        case INPUT_HARDWARE:
+            req->input.hw.msg    = input->u.hi.uMsg;
+            req->input.hw.lparam = MAKELONG( input->u.hi.wParamL, input->u.hi.wParamH );
+            switch (input->u.hi.uMsg)
+            {
+            case WM_INPUT:
+            case WM_INPUT_DEVICE_CHANGE:
+                req->input.hw.rawinput.type = rawinput->header.dwType;
+                switch (rawinput->header.dwType)
                 {
-                    GlobalFree( hMem );
-                    return FALSE;
+                case RIM_TYPEHID:
+                    req->input.hw.rawinput.hid.device = HandleToUlong( rawinput->header.hDevice );
+                    req->input.hw.rawinput.hid.param = rawinput->header.wParam;
+                    req->input.hw.rawinput.hid.usage_page = hid_usage_page;
+                    req->input.hw.rawinput.hid.usage = hid_usage;
+                    req->input.hw.rawinput.hid.count = rawinput->data.hid.dwCount;
+                    req->input.hw.rawinput.hid.length = rawinput->data.hid.dwSizeHid;
+                    wine_server_add_data( req, rawinput->data.hid.bRawData,
+                                          rawinput->data.hid.dwCount * rawinput->data.hid.dwSizeHid );
+                    break;
+                default:
+                    assert( 0 );
+                    break;
                 }
             }
-            else
-            {
-                GlobalFree( hMem );
-                return FALSE;
-            }
-	} else return FALSE;
-        *lparam = (LPARAM)hMem;
-        break;
+            break;
+        }
+        if (key_state_info) wine_server_set_reply( req, key_state_info->state,
+                                                   sizeof(key_state_info->state) );
+        ret = wine_server_call( req );
+        wait = reply->wait;
+        prev_x = reply->prev_x;
+        prev_y = reply->prev_y;
+        new_x  = reply->new_x;
+        new_y  = reply->new_y;
     }
-    return TRUE;
+    SERVER_END_REQ;
+
+    if (!ret)
+    {
+        if (key_state_info)
+        {
+            key_state_info->time    = GetTickCount();
+            key_state_info->counter = counter;
+        }
+        if ((flags & SEND_HWMSG_INJECTED) && (prev_x != new_x || prev_y != new_y))
+            USER_Driver->pSetCursorPos( new_x, new_y );
+    }
+
+    if (wait)
+    {
+        LRESULT ignored;
+        wait_message_reply( 0 );
+        retrieve_reply( &info, 0, &ignored );
+    }
+    return ret;
 }
 
-BOOL process_rawinput_message( MSG *msg, UINT hw_id, const struct hardware_msg_data *msg_data )
+
+/***********************************************************************
+ *		MSG_SendInternalMessageTimeout
+ *
+ * Same as SendMessageTimeoutW but sends the message to a specific thread
+ * without requiring a window handle. Only works for internal Wine messages.
+ */
+LRESULT WINAPI MSG_SendInternalMessageTimeout( DWORD dest_pid, DWORD dest_tid,
+                                               UINT msg, WPARAM wparam, LPARAM lparam,
+                                               UINT flags, UINT timeout, PDWORD_PTR res_ptr )
 {
-    struct rawinput_thread_data *thread_data = rawinput_thread_data();
+    struct send_message_info info;
+    LRESULT ret, result;
 
-    if (msg->message == WM_INPUT_DEVICE_CHANGE)
-        rawinput_update_device_list();
+    assert( msg & 0x80000000 );  /* must be an internal Wine message */
+
+    info.type     = MSG_UNICODE;
+    info.dest_tid = dest_tid;
+    info.hwnd     = 0;
+    info.msg      = msg;
+    info.wparam   = wparam;
+    info.lparam   = lparam;
+    info.flags    = flags;
+    info.timeout  = timeout;
+
+    if (USER_IsExitingThread( dest_tid )) return 0;
+
+    if (dest_tid == GetCurrentThreadId())
+    {
+        result = handle_internal_message( 0, msg, wparam, lparam );
+        ret = 1;
+    }
     else
     {
-        thread_data->buffer->header.dwSize = RAWINPUT_BUFFER_SIZE;
-        if (!rawinput_from_hardware_message( thread_data->buffer, msg_data )) return FALSE;
-        thread_data->hw_id = hw_id;
-        msg->lParam = (LPARAM)hw_id;
+        if (dest_pid != GetCurrentProcessId()) info.type = MSG_OTHER_PROCESS;
+        ret = send_inter_thread_message( &info, &result );
     }
-
-    msg->pt = point_phys_to_win_dpi( msg->hwnd, msg->pt );
-    return TRUE;
+    if (ret && res_ptr) *res_ptr = result;
+    return ret;
 }
 
 
@@ -583,12 +3345,17 @@ BOOL process_rawinput_message( MSG *msg, UINT hw_id, const struct hardware_msg_d
 LRESULT WINAPI SendMessageTimeoutW( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
                                     UINT flags, UINT timeout, PDWORD_PTR res_ptr )
 {
-    struct send_message_timeout_params params = { .flags = flags, .timeout = timeout };
-    LRESULT res;
+    struct send_message_info info;
 
-    res = NtUserMessageCall( hwnd, msg, wparam, lparam, &params, NtUserSendMessageTimeout, FALSE );
-    if (res_ptr) *res_ptr = res;
-    return params.result;
+    info.type    = MSG_UNICODE;
+    info.hwnd    = hwnd;
+    info.msg     = msg;
+    info.wparam  = wparam;
+    info.lparam  = lparam;
+    info.flags   = flags;
+    info.timeout = timeout;
+
+    return send_message( &info, res_ptr, TRUE );
 }
 
 /***********************************************************************
@@ -597,22 +3364,18 @@ LRESULT WINAPI SendMessageTimeoutW( HWND hwnd, UINT msg, WPARAM wparam, LPARAM l
 LRESULT WINAPI SendMessageTimeoutA( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
                                     UINT flags, UINT timeout, PDWORD_PTR res_ptr )
 {
-    struct send_message_timeout_params params = { .flags = flags, .timeout = timeout };
-    LRESULT res = 0;
-
-    if (msg != WM_CHAR || WIN_IsCurrentThread( hwnd ))
-    {
-        res = NtUserMessageCall( hwnd, msg, wparam, lparam, &params,
-                                 NtUserSendMessageTimeout, TRUE );
-    }
-    else if (map_wparam_AtoW( msg, &wparam, WMCHAR_MAP_SENDMESSAGE ))
-    {
-        res = NtUserMessageCall( hwnd, msg, wparam, lparam, &params,
-                                 NtUserSendMessageTimeout, FALSE );
-    }
-
-    if (res_ptr) *res_ptr = res;
-    return params.result;
+    struct send_message_info info;
+
+    info.type    = MSG_ASCII;
+    info.hwnd    = hwnd;
+    info.msg     = msg;
+    info.wparam  = wparam;
+    info.lparam  = lparam;
+    info.flags   = flags;
+    info.timeout = timeout;
+    info.wm_char  = WMCHAR_MAP_SENDMESSAGETIMEOUT;
+
+    return send_message( &info, res_ptr, FALSE );
 }
 
 
@@ -621,7 +3384,19 @@ LRESULT WINAPI SendMessageTimeoutA( HWND hwnd, UINT msg, WPARAM wparam, LPARAM l
  */
 LRESULT WINAPI SendMessageW( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 {
-    return NtUserMessageCall( hwnd, msg, wparam, lparam, NULL, NtUserSendMessage, FALSE );
+    DWORD_PTR res = 0;
+    struct send_message_info info;
+
+    info.type    = MSG_UNICODE;
+    info.hwnd    = hwnd;
+    info.msg     = msg;
+    info.wparam  = wparam;
+    info.lparam  = lparam;
+    info.flags   = SMTO_NORMAL;
+    info.timeout = 0;
+
+    send_message( &info, &res, TRUE );
+    return res;
 }
 
 
@@ -630,14 +3405,20 @@ LRESULT WINAPI SendMessageW( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
  */
 LRESULT WINAPI SendMessageA( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 {
-    if (msg == WM_CHAR && !WIN_IsCurrentThread( hwnd ))
-    {
-        if (!map_wparam_AtoW( msg, &wparam, WMCHAR_MAP_SENDMESSAGE ))
-            return 0;
-        return NtUserMessageCall( hwnd, msg, wparam, lparam, NULL, NtUserSendMessage, FALSE );
-    }
-
-    return NtUserMessageCall( hwnd, msg, wparam, lparam, NULL, NtUserSendMessage, TRUE );
+    DWORD_PTR res = 0;
+    struct send_message_info info;
+
+    info.type    = MSG_ASCII;
+    info.hwnd    = hwnd;
+    info.msg     = msg;
+    info.wparam  = wparam;
+    info.lparam  = lparam;
+    info.flags   = SMTO_NORMAL;
+    info.timeout = 0;
+    info.wm_char  = WMCHAR_MAP_SENDMESSAGE;
+
+    send_message( &info, &res, FALSE );
+    return res;
 }
 
 
@@ -646,10 +3427,23 @@ LRESULT WINAPI SendMessageA( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
  */
 BOOL WINAPI SendNotifyMessageA( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 {
-    if (!WIN_IsCurrentThread( hwnd ) && !map_wparam_AtoW( msg, &wparam, WMCHAR_MAP_SENDMESSAGE ))
+    struct send_message_info info;
+
+    if (is_pointer_message( msg, wparam ))
+    {
+        SetLastError( ERROR_MESSAGE_SYNC_ONLY );
         return FALSE;
+    }
 
-    return NtUserMessageCall( hwnd, msg, wparam, lparam, 0, NtUserSendNotifyMessage, TRUE );
+    info.type    = MSG_NOTIFY;
+    info.hwnd    = hwnd;
+    info.msg     = msg;
+    info.wparam  = wparam;
+    info.lparam  = lparam;
+    info.flags   = 0;
+    info.wm_char = WMCHAR_MAP_SENDMESSAGETIMEOUT;
+
+    return send_message( &info, NULL, FALSE );
 }
 
 
@@ -658,7 +3452,22 @@ BOOL WINAPI SendNotifyMessageA( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lpara
  */
 BOOL WINAPI SendNotifyMessageW( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 {
-    return NtUserMessageCall( hwnd, msg, wparam, lparam, 0, NtUserSendNotifyMessage, FALSE );
+    struct send_message_info info;
+
+    if (is_pointer_message( msg, wparam ))
+    {
+        SetLastError( ERROR_MESSAGE_SYNC_ONLY );
+        return FALSE;
+    }
+
+    info.type    = MSG_NOTIFY;
+    info.hwnd    = hwnd;
+    info.msg     = msg;
+    info.wparam  = wparam;
+    info.lparam  = lparam;
+    info.flags   = 0;
+
+    return send_message( &info, NULL, TRUE );
 }
 
 
@@ -668,12 +3477,25 @@ BOOL WINAPI SendNotifyMessageW( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lpara
 BOOL WINAPI SendMessageCallbackA( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
                                   SENDASYNCPROC callback, ULONG_PTR data )
 {
-    struct send_message_callback_params params = { .callback = callback, .data = data };
+    struct send_message_info info;
 
-    if (!WIN_IsCurrentThread( hwnd ) && !map_wparam_AtoW( msg, &wparam, WMCHAR_MAP_SENDMESSAGE ))
+    if (is_pointer_message( msg, wparam ))
+    {
+        SetLastError( ERROR_MESSAGE_SYNC_ONLY );
         return FALSE;
+    }
 
-    return NtUserMessageCall( hwnd, msg, wparam, lparam, &params, NtUserSendMessageCallback, TRUE );
+    info.type     = MSG_CALLBACK;
+    info.hwnd     = hwnd;
+    info.msg      = msg;
+    info.wparam   = wparam;
+    info.lparam   = lparam;
+    info.callback = callback;
+    info.data     = data;
+    info.flags    = 0;
+    info.wm_char  = WMCHAR_MAP_SENDMESSAGETIMEOUT;
+
+    return send_message( &info, NULL, FALSE );
 }
 
 
@@ -683,8 +3505,24 @@ BOOL WINAPI SendMessageCallbackA( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lpa
 BOOL WINAPI SendMessageCallbackW( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
                                   SENDASYNCPROC callback, ULONG_PTR data )
 {
-    struct send_message_callback_params params = { .callback = callback, .data = data };
-    return NtUserMessageCall( hwnd, msg, wparam, lparam, &params, NtUserSendMessageCallback, FALSE );
+    struct send_message_info info;
+
+    if (is_pointer_message( msg, wparam ))
+    {
+        SetLastError( ERROR_MESSAGE_SYNC_ONLY );
+        return FALSE;
+    }
+
+    info.type     = MSG_CALLBACK;
+    info.hwnd     = hwnd;
+    info.msg      = msg;
+    info.wparam   = wparam;
+    info.lparam   = lparam;
+    info.callback = callback;
+    info.data     = data;
+    info.flags    = 0;
+
+    return send_message( &info, NULL, TRUE );
 }
 
 
@@ -693,7 +3531,11 @@ BOOL WINAPI SendMessageCallbackW( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lpa
  */
 BOOL WINAPI ReplyMessage( LRESULT result )
 {
-    return NtUserReplyMessage( result, NULL );
+    struct received_message_info *info = get_user_thread_info()->receive_info;
+
+    if (!info) return FALSE;
+    reply_message( info, result, FALSE );
+    return TRUE;
 }
 
 
@@ -733,7 +3575,38 @@ BOOL WINAPI PostMessageA( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
  */
 BOOL WINAPI PostMessageW( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 {
-    return NtUserPostMessage( hwnd, msg, wparam, lparam );
+    struct send_message_info info;
+
+    if (is_pointer_message( msg, wparam ))
+    {
+        SetLastError( ERROR_MESSAGE_SYNC_ONLY );
+        return FALSE;
+    }
+
+    TRACE( "hwnd %p msg %x (%s) wp %lx lp %lx\n",
+           hwnd, msg, SPY_GetMsgName(msg, hwnd), wparam, lparam );
+
+    info.type   = MSG_POSTED;
+    info.hwnd   = hwnd;
+    info.msg    = msg;
+    info.wparam = wparam;
+    info.lparam = lparam;
+    info.flags  = 0;
+
+    if (is_broadcast(hwnd))
+    {
+        if (is_message_broadcastable( info.msg ))
+            EnumWindows( broadcast_message_callback, (LPARAM)&info );
+        return TRUE;
+    }
+
+    if (!hwnd) return PostThreadMessageW( GetCurrentThreadId(), msg, wparam, lparam );
+
+    if (!(info.dest_tid = GetWindowThreadProcessId( hwnd, NULL ))) return FALSE;
+
+    if (USER_IsExitingThread( info.dest_tid )) return TRUE;
+
+    return put_message_in_queue( &info, NULL );
 }
 
 
@@ -743,7 +3616,32 @@ BOOL WINAPI PostMessageW( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 BOOL WINAPI PostThreadMessageA( DWORD thread, UINT msg, WPARAM wparam, LPARAM lparam )
 {
     if (!map_wparam_AtoW( msg, &wparam, WMCHAR_MAP_POSTMESSAGE )) return TRUE;
-    return NtUserPostThreadMessage( thread, msg, wparam, lparam );
+    return PostThreadMessageW( thread, msg, wparam, lparam );
+}
+
+
+/**********************************************************************
+ *		PostThreadMessageW  (USER32.@)
+ */
+BOOL WINAPI PostThreadMessageW( DWORD thread, UINT msg, WPARAM wparam, LPARAM lparam )
+{
+    struct send_message_info info;
+
+    if (is_pointer_message( msg, wparam ))
+    {
+        SetLastError( ERROR_MESSAGE_SYNC_ONLY );
+        return FALSE;
+    }
+    if (USER_IsExitingThread( thread )) return TRUE;
+
+    info.type     = MSG_POSTED;
+    info.dest_tid = thread;
+    info.hwnd     = 0;
+    info.msg      = msg;
+    info.wparam   = wparam;
+    info.lparam   = lparam;
+    info.flags    = 0;
+    return put_message_in_queue( &info, NULL );
 }
 
 
@@ -775,12 +3673,57 @@ void WINAPI PostQuitMessage( INT exit_code )
     SERVER_END_REQ;
 }
 
+/* check for driver events if we detect that the app is not properly consuming messages */
+static inline void check_for_driver_events( UINT msg )
+{
+    if (get_user_thread_info()->message_count > 200)
+    {
+        flush_window_surfaces( FALSE );
+        USER_Driver->pMsgWaitForMultipleObjectsEx( 0, NULL, 0, QS_ALLINPUT, 0 );
+    }
+    else if (msg == WM_TIMER || msg == WM_SYSTIMER)
+    {
+        /* driver events should have priority over timers, so make sure we'll check for them soon */
+        get_user_thread_info()->message_count += 100;
+    }
+    else get_user_thread_info()->message_count++;
+}
+
 /***********************************************************************
  *		PeekMessageW  (USER32.@)
  */
 BOOL WINAPI DECLSPEC_HOTPATCH PeekMessageW( MSG *msg_out, HWND hwnd, UINT first, UINT last, UINT flags )
 {
-    return NtUserPeekMessage( msg_out, hwnd, first, last, flags );
+    MSG msg;
+    int ret;
+
+    USER_CheckNotLock();
+    check_for_driver_events( 0 );
+
+    ret = peek_message( &msg, hwnd, first, last, flags, 0 );
+    if (ret < 0) return FALSE;
+
+    if (!ret)
+    {
+        flush_window_surfaces( TRUE );
+        ret = wow_handlers.wait_message( 0, NULL, 0, QS_ALLINPUT, 0 );
+        /* if we received driver events, check again for a pending message */
+        if (ret == WAIT_TIMEOUT || peek_message( &msg, hwnd, first, last, flags, 0 ) <= 0) return FALSE;
+    }
+
+    check_for_driver_events( msg.message );
+
+    /* copy back our internal safe copy of message data to msg_out.
+     * msg_out is a variable from the *program*, so it can't be used
+     * internally as it can get "corrupted" by our use of SendMessage()
+     * (back to the program) inside the message handling itself. */
+    if (!msg_out)
+    {
+        SetLastError( ERROR_NOACCESS );
+        return FALSE;
+    }
+    *msg_out = msg;
+    return TRUE;
 }
 
 
@@ -801,7 +3744,33 @@ BOOL WINAPI DECLSPEC_HOTPATCH PeekMessageA( MSG *msg, HWND hwnd, UINT first, UIN
  */
 BOOL WINAPI DECLSPEC_HOTPATCH GetMessageW( MSG *msg, HWND hwnd, UINT first, UINT last )
 {
-    return NtUserGetMessage( msg, hwnd, first, last );
+    HANDLE server_queue = get_server_queue_handle();
+    unsigned int mask = QS_POSTMESSAGE | QS_SENDMESSAGE;  /* Always selected */
+    int ret;
+
+    USER_CheckNotLock();
+    check_for_driver_events( 0 );
+
+    if (first || last)
+    {
+        if ((first <= WM_KEYLAST) && (last >= WM_KEYFIRST)) mask |= QS_KEY;
+        if ( ((first <= WM_MOUSELAST) && (last >= WM_MOUSEFIRST)) ||
+             ((first <= WM_NCMOUSELAST) && (last >= WM_NCMOUSEFIRST)) ) mask |= QS_MOUSE;
+        if ((first <= WM_TIMER) && (last >= WM_TIMER)) mask |= QS_TIMER;
+        if ((first <= WM_SYSTIMER) && (last >= WM_SYSTIMER)) mask |= QS_TIMER;
+        if ((first <= WM_PAINT) && (last >= WM_PAINT)) mask |= QS_PAINT;
+    }
+    else mask = QS_ALLINPUT;
+
+    while (!(ret = peek_message( msg, hwnd, first, last, PM_REMOVE | (mask << 16), mask )))
+    {
+        wait_objects( 1, &server_queue, INFINITE, mask & (QS_SENDMESSAGE | QS_SMRESULT), mask, 0 );
+    }
+    if (ret < 0) return -1;
+
+    check_for_driver_events( msg->message );
+
+    return (msg->message != WM_QUIT);
 }
 
 
@@ -847,7 +3816,50 @@ BOOL WINAPI IsDialogMessageA( HWND hwndDlg, LPMSG pmsg )
  */
 BOOL WINAPI TranslateMessage( const MSG *msg )
 {
-    return NtUserTranslateMessage( msg, 0 );
+    UINT message;
+    WCHAR wp[8];
+    BYTE state[256];
+    INT len;
+
+    if (msg->message < WM_KEYFIRST || msg->message > WM_KEYLAST) return FALSE;
+    if (msg->message != WM_KEYDOWN && msg->message != WM_SYSKEYDOWN) return TRUE;
+
+    TRACE_(key)("Translating key %s (%04lX), scancode %04x\n",
+                SPY_GetVKeyName(msg->wParam), msg->wParam, HIWORD(msg->lParam));
+
+    switch (msg->wParam)
+    {
+    case VK_PACKET:
+        message = (msg->message == WM_KEYDOWN) ? WM_CHAR : WM_SYSCHAR;
+        TRACE_(key)("PostMessageW(%p,%s,%04x,%08x)\n",
+                    msg->hwnd, SPY_GetMsgName(message, msg->hwnd), HIWORD(msg->lParam), LOWORD(msg->lParam));
+        PostMessageW( msg->hwnd, message, HIWORD(msg->lParam), LOWORD(msg->lParam));
+        return TRUE;
+
+    case VK_PROCESSKEY:
+        return ImmTranslateMessage(msg->hwnd, msg->message, msg->wParam, msg->lParam);
+    }
+
+    NtUserGetKeyboardState( state );
+    len = ToUnicode(msg->wParam, HIWORD(msg->lParam), state, wp, ARRAY_SIZE(wp), 0);
+    if (len == -1)
+    {
+        message = (msg->message == WM_KEYDOWN) ? WM_DEADCHAR : WM_SYSDEADCHAR;
+        TRACE_(key)("-1 -> PostMessageW(%p,%s,%04x,%08lx)\n",
+            msg->hwnd, SPY_GetMsgName(message, msg->hwnd), wp[0], msg->lParam);
+        PostMessageW( msg->hwnd, message, wp[0], msg->lParam );
+    }
+    else if (len > 0)
+    {
+        INT i;
+
+        message = (msg->message == WM_KEYDOWN) ? WM_CHAR : WM_SYSCHAR;
+        TRACE_(key)("%d -> PostMessageW(%p,%s,<x>,%08lx) for <x> in %s\n", len, msg->hwnd,
+            SPY_GetMsgName(message, msg->hwnd), msg->lParam, debugstr_wn(wp, len));
+        for (i = 0; i < len; i++)
+            PostMessageW( msg->hwnd, message, wp[i], msg->lParam );
+    }
+    return TRUE;
 }
 
 
@@ -861,21 +3873,47 @@ LRESULT WINAPI DECLSPEC_HOTPATCH DispatchMessageA( const MSG* msg )
     LRESULT retval;
 
       /* Process timer messages */
-    if (msg->lParam && msg->message == WM_TIMER)
+    if ((msg->message == WM_TIMER) || (msg->message == WM_SYSTIMER))
     {
-        __TRY
-        {
-            retval = CallWindowProcA( (WNDPROC)msg->lParam, msg->hwnd,
-                                      msg->message, msg->wParam, GetTickCount() );
-        }
-        __EXCEPT_ALL
+        if (msg->lParam)
         {
-            retval = 0;
+            __TRY
+            {
+                retval = CallWindowProcA( (WNDPROC)msg->lParam, msg->hwnd,
+                                          msg->message, msg->wParam, GetTickCount() );
+            }
+            __EXCEPT_ALL
+            {
+                retval = 0;
+            }
+            __ENDTRY
+            return retval;
         }
-        __ENDTRY
-        return retval;
     }
-    return NtUserDispatchMessageA( msg );
+    if (!msg->hwnd) return 0;
+
+    SPY_EnterMessage( SPY_DISPATCHMESSAGE, msg->hwnd, msg->message,
+                      msg->wParam, msg->lParam );
+
+    if (!WINPROC_call_window( msg->hwnd, msg->message, msg->wParam, msg->lParam,
+                              &retval, FALSE, WMCHAR_MAP_DISPATCHMESSAGE ))
+    {
+        if (!IsWindow( msg->hwnd )) SetLastError( ERROR_INVALID_WINDOW_HANDLE );
+        else SetLastError( ERROR_MESSAGE_SYNC_ONLY );
+        retval = 0;
+    }
+
+    SPY_ExitMessage( SPY_RESULT_OK, msg->hwnd, msg->message, retval,
+                     msg->wParam, msg->lParam );
+
+    if (msg->message == WM_PAINT)
+    {
+        /* send a WM_NCPAINT and WM_ERASEBKGND if the non-client area is still invalid */
+        HRGN hrgn = CreateRectRgn( 0, 0, 0, 0 );
+        NtUserGetUpdateRgn( msg->hwnd, hrgn, TRUE );
+        DeleteObject( hrgn );
+    }
+    return retval;
 }
 
 
@@ -923,7 +3961,30 @@ LRESULT WINAPI DECLSPEC_HOTPATCH DispatchMessageW( const MSG* msg )
             return retval;
         }
     }
-    return NtUserDispatchMessage( msg );
+    if (!msg->hwnd) return 0;
+
+    SPY_EnterMessage( SPY_DISPATCHMESSAGE, msg->hwnd, msg->message,
+                      msg->wParam, msg->lParam );
+
+    if (!WINPROC_call_window( msg->hwnd, msg->message, msg->wParam, msg->lParam,
+                              &retval, TRUE, WMCHAR_MAP_DISPATCHMESSAGE ))
+    {
+        if (!IsWindow( msg->hwnd )) SetLastError( ERROR_INVALID_WINDOW_HANDLE );
+        else SetLastError( ERROR_MESSAGE_SYNC_ONLY );
+        retval = 0;
+    }
+
+    SPY_ExitMessage( SPY_RESULT_OK, msg->hwnd, msg->message, retval,
+                     msg->wParam, msg->lParam );
+
+    if (msg->message == WM_PAINT)
+    {
+        /* send a WM_NCPAINT and WM_ERASEBKGND if the non-client area is still invalid */
+        HRGN hrgn = CreateRectRgn( 0, 0, 0, 0 );
+        NtUserGetUpdateRgn( msg->hwnd, hrgn, TRUE );
+        DeleteObject( hrgn );
+    }
+    return retval;
 }
 
 
@@ -951,7 +4012,7 @@ LRESULT WINAPI DECLSPEC_HOTPATCH DispatchMessageW( const MSG* msg )
  */
 DWORD WINAPI GetMessagePos(void)
 {
-    return NtUserGetThreadInfo()->message_pos;
+    return get_user_thread_info()->GetMessagePosVal;
 }
 
 
@@ -972,7 +4033,7 @@ DWORD WINAPI GetMessagePos(void)
  */
 LONG WINAPI GetMessageTime(void)
 {
-    return NtUserGetThreadInfo()->message_time;
+    return get_user_thread_info()->GetMessageTimeVal;
 }
 
 
@@ -982,7 +4043,7 @@ LONG WINAPI GetMessageTime(void)
  */
 LPARAM WINAPI GetMessageExtraInfo(void)
 {
-    return NtUserGetThreadInfo()->message_extra;
+    return get_user_thread_info()->GetMessageExtraInfoVal;
 }
 
 
@@ -991,9 +4052,9 @@ LPARAM WINAPI GetMessageExtraInfo(void)
  */
 LPARAM WINAPI SetMessageExtraInfo(LPARAM lParam)
 {
-    struct ntuser_thread_info *thread_info = NtUserGetThreadInfo();
-    LONG old_value = thread_info->message_extra;
-    thread_info->message_extra = lParam;
+    struct user_thread_info *thread_info = get_user_thread_info();
+    LONG old_value = thread_info->GetMessageExtraInfoVal;
+    thread_info->GetMessageExtraInfoVal = lParam;
     return old_value;
 }
 
@@ -1017,7 +4078,31 @@ BOOL WINAPI GetCurrentInputMessageSource( INPUT_MESSAGE_SOURCE *source )
  */
 BOOL WINAPI WaitMessage(void)
 {
-    return NtUserMsgWaitForMultipleObjectsEx( 0, NULL, INFINITE, QS_ALLINPUT, 0 ) != WAIT_FAILED;
+    return (MsgWaitForMultipleObjectsEx( 0, NULL, INFINITE, QS_ALLINPUT, 0 ) != WAIT_FAILED);
+}
+
+
+/***********************************************************************
+ *		MsgWaitForMultipleObjectsEx   (USER32.@)
+ */
+DWORD WINAPI MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *pHandles,
+                                          DWORD timeout, DWORD mask, DWORD flags )
+{
+    HANDLE handles[MAXIMUM_WAIT_OBJECTS];
+    DWORD i;
+
+    if (count > MAXIMUM_WAIT_OBJECTS-1)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return WAIT_FAILED;
+    }
+
+    /* add the queue to the handle list */
+    for (i = 0; i < count; i++) handles[i] = pHandles[i];
+    handles[count] = get_server_queue_handle();
+
+    return wait_objects( count+1, handles, timeout,
+                         (flags & MWMO_INPUTAVAILABLE) ? mask : 0, mask, flags );
 }
 
 
@@ -1027,17 +4112,61 @@ BOOL WINAPI WaitMessage(void)
 DWORD WINAPI MsgWaitForMultipleObjects( DWORD count, const HANDLE *handles,
                                         BOOL wait_all, DWORD timeout, DWORD mask )
 {
-    return NtUserMsgWaitForMultipleObjectsEx( count, handles, timeout, mask,
-                                              wait_all ? MWMO_WAITALL : 0 );
+    return MsgWaitForMultipleObjectsEx( count, handles, timeout, mask,
+                                        wait_all ? MWMO_WAITALL : 0 );
 }
 
 
 /***********************************************************************
  *		WaitForInputIdle (USER32.@)
  */
-DWORD WINAPI WaitForInputIdle( HANDLE process, DWORD timeout )
+DWORD WINAPI WaitForInputIdle( HANDLE hProcess, DWORD dwTimeOut )
 {
-    return NtUserWaitForInputIdle( process, timeout, FALSE );
+    DWORD start_time, elapsed, ret;
+    HANDLE handles[2];
+
+    handles[0] = hProcess;
+    SERVER_START_REQ( get_process_idle_event )
+    {
+        req->handle = wine_server_obj_handle( hProcess );
+        wine_server_call_err( req );
+        handles[1] = wine_server_ptr_handle( reply->event );
+    }
+    SERVER_END_REQ;
+    if (!handles[1]) return WAIT_FAILED;  /* no event to wait on */
+
+    start_time = GetTickCount();
+    elapsed = 0;
+
+    TRACE("waiting for %p\n", handles[1] );
+    do
+    {
+        ret = MsgWaitForMultipleObjects ( 2, handles, FALSE, dwTimeOut - elapsed, QS_SENDMESSAGE );
+        switch (ret)
+        {
+        case WAIT_OBJECT_0:
+            return 0;
+        case WAIT_OBJECT_0+2:
+            process_sent_messages();
+            break;
+        case WAIT_TIMEOUT:
+        case WAIT_FAILED:
+            TRACE("timeout or error\n");
+            return ret;
+        default:
+            TRACE("finished\n");
+            return 0;
+        }
+        if (dwTimeOut != INFINITE)
+        {
+            elapsed = GetTickCount() - start_time;
+            if (elapsed > dwTimeOut)
+                break;
+        }
+    }
+    while (1);
+
+    return WAIT_TIMEOUT;
 }
 
 
@@ -1253,7 +4382,7 @@ BOOL WINAPI SetMessageQueue( INT size )
  */
 BOOL WINAPI MessageBeep( UINT i )
 {
-    return NtUserMessageBeep( i );
+    return NtUserCallOneParam( i, NtUserMessageBeep );
 }
 
 
@@ -1266,23 +4395,12 @@ UINT_PTR WINAPI SetTimer( HWND hwnd, UINT_PTR id, UINT timeout, TIMERPROC proc )
 }
 
 
-/******************************************************************
- *      SetSystemTimer (USER32.@)
- */
-UINT_PTR WINAPI SetSystemTimer( HWND hwnd, UINT_PTR id, UINT timeout, void *unknown )
-{
-    if (unknown) FIXME( "ignoring unknown parameter %p\n", unknown );
-
-    return NtUserSetSystemTimer( hwnd, id, timeout );
-}
-
-
 /***********************************************************************
  *		KillSystemTimer (USER32.@)
  */
 BOOL WINAPI KillSystemTimer( HWND hwnd, UINT_PTR id )
 {
-    return NtUserKillSystemTimer( hwnd, id );
+    return NtUserCallHwndParam( hwnd, id, NtUserKillSystemTimer );
 }
 
 
diff --git a/dlls/user32/nonclient.c b/dlls/user32/nonclient.c
index e677f1aeb66..8b74c0c33b2 100644
--- a/dlls/user32/nonclient.c
+++ b/dlls/user32/nonclient.c
@@ -916,7 +916,7 @@ static void  NC_DrawCaption( HDC  hdc, RECT *rect, HWND hwnd, DWORD  style,
         UINT state;
 
         /* Go get the sysmenu */
-        hSysMenu = NtUserGetSystemMenu(hwnd, FALSE);
+        hSysMenu = GetSystemMenu(hwnd, FALSE);
         state = GetMenuState(hSysMenu, SC_CLOSE, MF_BYCOMMAND);
 
         /* Draw a grayed close button if disabled or if SC_CLOSE is not there */
@@ -1213,7 +1213,7 @@ static void NC_TrackMinMaxBox( HWND hwnd, WORD wParam )
     BOOL pressed = TRUE;
     UINT state;
     DWORD wndStyle = GetWindowLongW( hwnd, GWL_STYLE);
-    HMENU hSysMenu = NtUserGetSystemMenu(hwnd, FALSE);
+    HMENU hSysMenu = GetSystemMenu(hwnd, FALSE);
 
     void  (*paintButton)(HWND, HDC, BOOL, BOOL);
 
@@ -1249,7 +1249,7 @@ static void NC_TrackMinMaxBox( HWND hwnd, WORD wParam )
         BOOL oldstate = pressed;
 
         if (!GetMessageW( &msg, 0, WM_MOUSEFIRST, WM_MOUSELAST )) break;
-        if (NtUserCallMsgFilter( &msg, MSGF_MAX )) continue;
+        if (CallMsgFilterW( &msg, MSGF_MAX )) continue;
 
         if(msg.message == WM_LBUTTONUP)
             break;
@@ -1291,7 +1291,7 @@ static void NC_TrackCloseButton (HWND hwnd, WPARAM wParam, LPARAM lParam)
     MSG msg;
     HDC hdc;
     BOOL pressed = TRUE;
-    HMENU hSysMenu = NtUserGetSystemMenu(hwnd, FALSE);
+    HMENU hSysMenu = GetSystemMenu(hwnd, FALSE);
     UINT state;
 
     if(hSysMenu == 0)
@@ -1314,7 +1314,7 @@ static void NC_TrackCloseButton (HWND hwnd, WPARAM wParam, LPARAM lParam)
         BOOL oldstate = pressed;
 
         if (!GetMessageW( &msg, 0, WM_MOUSEFIRST, WM_MOUSELAST )) break;
-        if (NtUserCallMsgFilter( &msg, MSGF_MAX )) continue;
+        if (CallMsgFilterW( &msg, MSGF_MAX )) continue;
 
         if(msg.message == WM_LBUTTONUP)
             break;
@@ -1464,7 +1464,7 @@ LRESULT NC_HandleNCRButtonDown( HWND hwnd, WPARAM wParam, LPARAM lParam )
         for (;;)
         {
             if (!GetMessageW( &msg, 0, WM_MOUSEFIRST, WM_MOUSELAST )) break;
-            if (NtUserCallMsgFilter( &msg, MSGF_MAX )) continue;
+            if (CallMsgFilterW( &msg, MSGF_MAX )) continue;
             if (msg.message == WM_RBUTTONUP)
             {
                 hittest = NC_HandleNCHitTest( hwnd, msg.pt );
@@ -1508,7 +1508,7 @@ LRESULT NC_HandleNCLButtonDblClk( HWND hwnd, WPARAM wParam, LPARAM lParam )
 
     case HTSYSMENU:
         {
-            HMENU hSysMenu = NtUserGetSystemMenu(hwnd, FALSE);
+            HMENU hSysMenu = GetSystemMenu(hwnd, FALSE);
             UINT state = GetMenuState(hSysMenu, SC_CLOSE, MF_BYCOMMAND);
 
             /* If the close item of the sysmenu is disabled or not present do nothing */
@@ -1540,7 +1540,12 @@ LRESULT NC_HandleSysCommand( HWND hwnd, WPARAM wParam, LPARAM lParam )
 {
     TRACE("hwnd %p WM_SYSCOMMAND %Ix %Ix\n", hwnd, wParam, lParam );
 
-    if (!NtUserMessageCall( hwnd, WM_SYSCOMMAND, wParam, lParam, 0, NtUserDefWindowProc, FALSE ))
+    if (!IsWindowEnabled( hwnd )) return 0;
+
+    if (HOOK_CallHooks( WH_CBT, HCBT_SYSCOMMAND, wParam, lParam, TRUE ))
+        return 0;
+
+    if (!USER_Driver->pSysCommand( hwnd, wParam, lParam ))
         return 0;
 
     switch (wParam & 0xfff0)
@@ -1550,6 +1555,23 @@ LRESULT NC_HandleSysCommand( HWND hwnd, WPARAM wParam, LPARAM lParam )
         WINPOS_SysCommandSizeMove( hwnd, wParam );
         break;
 
+    case SC_MINIMIZE:
+        ShowOwnedPopups(hwnd,FALSE);
+        NtUserShowWindow( hwnd, SW_MINIMIZE );
+        break;
+
+    case SC_MAXIMIZE:
+        if (IsIconic(hwnd))
+            ShowOwnedPopups(hwnd,TRUE);
+        NtUserShowWindow( hwnd, SW_MAXIMIZE );
+        break;
+
+    case SC_RESTORE:
+        if (IsIconic(hwnd))
+            ShowOwnedPopups(hwnd,TRUE);
+        NtUserShowWindow( hwnd, SW_RESTORE );
+        break;
+
     case SC_CLOSE:
         return SendMessageW( hwnd, WM_CLOSE, 0, 0 );
 
diff --git a/dlls/user32/painting.c b/dlls/user32/painting.c
index 29450e6e984..ee9d23b1f71 100644
--- a/dlls/user32/painting.c
+++ b/dlls/user32/painting.c
@@ -35,6 +35,156 @@
 WINE_DEFAULT_DEBUG_CHANNEL(win);
 
 
+/***********************************************************************
+ *   invalidate_dce
+ *
+ * It is called from SetWindowPos() - we have to
+ * mark as dirty all busy DCEs for windows that have pWnd->parent as
+ * an ancestor and whose client rect intersects with specified update
+ * rectangle. In addition, pWnd->parent DCEs may need to be updated if
+ * DCX_CLIPCHILDREN flag is set.
+ */
+void invalidate_dce( WND *win, const RECT *extra_rect )
+{
+    /* FIXME: move callers to win32u */
+    NtUserCallTwoParam( (UINT_PTR)win, (UINT_PTR)extra_rect, NtUserInvalidateDCE );
+}
+
+
+/***********************************************************************
+ *           get_update_region
+ *
+ * Return update region (in screen coordinates) for a window.
+ */
+static HRGN get_update_region( HWND hwnd, UINT *flags, HWND *child )
+{
+    HRGN hrgn = 0;
+    NTSTATUS status;
+    RGNDATA *data;
+    size_t size = 256;
+
+    do
+    {
+        if (!(data = HeapAlloc( GetProcessHeap(), 0, sizeof(*data) + size - 1 )))
+        {
+            SetLastError( ERROR_OUTOFMEMORY );
+            return 0;
+        }
+
+        SERVER_START_REQ( get_update_region )
+        {
+            req->window     = wine_server_user_handle( hwnd );
+            req->from_child = wine_server_user_handle( child ? *child : 0 );
+            req->flags      = *flags;
+            wine_server_set_reply( req, data->Buffer, size );
+            if (!(status = wine_server_call( req )))
+            {
+                size_t reply_size = wine_server_reply_size( reply );
+                data->rdh.dwSize   = sizeof(data->rdh);
+                data->rdh.iType    = RDH_RECTANGLES;
+                data->rdh.nCount   = reply_size / sizeof(RECT);
+                data->rdh.nRgnSize = reply_size;
+                hrgn = ExtCreateRegion( NULL, data->rdh.dwSize + data->rdh.nRgnSize, data );
+                if (child) *child = wine_server_ptr_handle( reply->child );
+                *flags = reply->flags;
+            }
+            else size = reply->total_size;
+        }
+        SERVER_END_REQ;
+        HeapFree( GetProcessHeap(), 0, data );
+    } while (status == STATUS_BUFFER_OVERFLOW);
+
+    if (status) SetLastError( RtlNtStatusToDosError(status) );
+    return hrgn;
+}
+
+
+/***********************************************************************
+ *           copy_bits_from_surface
+ *
+ * Copy bits from a window surface; helper for move_window_bits and move_window_bits_parent.
+ */
+static void copy_bits_from_surface( HWND hwnd, struct window_surface *surface,
+                                    const RECT *dst, const RECT *src )
+{
+    char buffer[FIELD_OFFSET( BITMAPINFO, bmiColors[256] )];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    void *bits;
+    UINT flags = UPDATE_NOCHILDREN | UPDATE_CLIPCHILDREN;
+    HRGN rgn = get_update_region( hwnd, &flags, NULL );
+    HDC hdc = NtUserGetDCEx( hwnd, rgn, DCX_CACHE | DCX_WINDOW | DCX_EXCLUDERGN );
+
+    bits = surface->funcs->get_info( surface, info );
+    surface->funcs->lock( surface );
+    SetDIBitsToDevice( hdc, dst->left, dst->top, dst->right - dst->left, dst->bottom - dst->top,
+                       src->left - surface->rect.left, surface->rect.bottom - src->bottom,
+                       0, surface->rect.bottom - surface->rect.top,
+                       bits, info, DIB_RGB_COLORS );
+    surface->funcs->unlock( surface );
+    NtUserReleaseDC( hwnd, hdc );
+}
+
+
+/***********************************************************************
+ *           move_window_bits
+ *
+ * Move the window bits when a window is resized or its surface recreated.
+ */
+void move_window_bits( HWND hwnd, struct window_surface *old_surface,
+                       struct window_surface *new_surface,
+                       const RECT *visible_rect, const RECT *old_visible_rect,
+                       const RECT *window_rect, const RECT *valid_rects )
+{
+    RECT dst = valid_rects[0];
+    RECT src = valid_rects[1];
+
+    if (new_surface != old_surface ||
+        src.left - old_visible_rect->left != dst.left - visible_rect->left ||
+        src.top - old_visible_rect->top != dst.top - visible_rect->top)
+    {
+        TRACE( "copying %s -> %s\n", wine_dbgstr_rect( &src ), wine_dbgstr_rect( &dst ));
+        OffsetRect( &src, -old_visible_rect->left, -old_visible_rect->top );
+        OffsetRect( &dst, -window_rect->left, -window_rect->top );
+        copy_bits_from_surface( hwnd, old_surface, &dst, &src );
+    }
+}
+
+
+/***********************************************************************
+ *		move_window_bits_parent
+ *
+ * Move the window bits in the parent surface when a child is moved.
+ */
+void move_window_bits_parent( HWND hwnd, HWND parent, const RECT *window_rect, const RECT *valid_rects )
+{
+    struct window_surface *surface;
+    RECT dst = valid_rects[0];
+    RECT src = valid_rects[1];
+    WND *win;
+
+    if (src.left == dst.left && src.top == dst.top) return;
+
+    if (!(win = WIN_GetPtr( parent ))) return;
+    if (win == WND_DESKTOP || win == WND_OTHER_PROCESS) return;
+    if (!(surface = win->surface))
+    {
+        WIN_ReleasePtr( win );
+        return;
+    }
+
+    TRACE( "copying %s -> %s\n", wine_dbgstr_rect( &src ), wine_dbgstr_rect( &dst ));
+    MapWindowPoints( NtUserGetAncestor( hwnd, GA_PARENT ), parent, (POINT *)&src, 2 );
+    OffsetRect( &src, win->client_rect.left - win->visible_rect.left,
+                win->client_rect.top - win->visible_rect.top );
+    OffsetRect( &dst, -window_rect->left, -window_rect->top );
+    window_surface_add_ref( surface );
+    WIN_ReleasePtr( win );
+
+    copy_bits_from_surface( hwnd, surface, &dst, &src );
+    window_surface_release( surface );
+}
+
+
 /*************************************************************************
  *             fix_caret
  *
@@ -240,6 +390,31 @@ BOOL WINAPI ValidateRect( HWND hwnd, const RECT *rect )
 }
 
 
+/***********************************************************************
+ *		ExcludeUpdateRgn (USER32.@)
+ */
+INT WINAPI ExcludeUpdateRgn( HDC hdc, HWND hwnd )
+{
+    HRGN update_rgn = CreateRectRgn( 0, 0, 0, 0 );
+    INT ret = NtUserGetUpdateRgn( hwnd, update_rgn, FALSE );
+
+    if (ret != ERROR)
+    {
+        DPI_AWARENESS_CONTEXT context;
+        POINT pt;
+
+        context = SetThreadDpiAwarenessContext( GetWindowDpiAwarenessContext( hwnd ));
+        GetDCOrgEx( hdc, &pt );
+        MapWindowPoints( 0, hwnd, &pt, 1 );
+        OffsetRgn( update_rgn, -pt.x, -pt.y );
+        ret = ExtSelectClipRgn( hdc, update_rgn, RGN_DIFF );
+        SetThreadDpiAwarenessContext( context );
+    }
+    DeleteObject( update_rgn );
+    return ret;
+}
+
+
 static INT scroll_window( HWND hwnd, INT dx, INT dy, const RECT *rect, const RECT *clipRect,
                           HRGN hrgnUpdate, LPRECT rcUpdate, UINT flags, BOOL is_ex )
 {
@@ -285,7 +460,7 @@ static INT scroll_window( HWND hwnd, INT dx, INT dy, const RECT *rect, const REC
 
         hwndCaret = fix_caret(hwnd, &rc, dx, dy, flags, &moveCaret, &newCaretPos);
         if (hwndCaret)
-            NtUserHideCaret( hwndCaret );
+            HideCaret(hwndCaret);
 
         if (is_ex) dcxflags |= DCX_CACHE;
         if( style & WS_CLIPSIBLINGS) dcxflags |= DCX_CLIPSIBLINGS;
@@ -388,7 +563,7 @@ static INT scroll_window( HWND hwnd, INT dx, INT dy, const RECT *rect, const REC
     if( moveCaret )
         SetCaretPos( newCaretPos.x, newCaretPos.y );
     if( hwndCaret )
-        NtUserShowCaret( hwndCaret );
+        ShowCaret( hwndCaret );
 
     if( bOwnRgn && hrgnUpdate ) DeleteObject( hrgnUpdate );
 
diff --git a/dlls/user32/scroll.c b/dlls/user32/scroll.c
index 8bf1f4312ab..ffbe58cb32a 100644
--- a/dlls/user32/scroll.c
+++ b/dlls/user32/scroll.c
@@ -756,7 +756,7 @@ static void SCROLL_HandleKbdEvent(HWND hwnd, WPARAM wParam, LPARAM lParam)
 
     /* hide caret on first KEYDOWN to prevent flicker */
     if ((lParam & PFD_DOUBLEBUFFER_DONTCARE) == 0)
-        NtUserHideCaret( hwnd );
+        HideCaret(hwnd);
 
     switch(wParam)
     {
@@ -814,7 +814,7 @@ void SCROLL_HandleScrollEvent( HWND hwnd, INT nBar, UINT msg, POINT pt )
         switch(msg)
         {
             case WM_LBUTTONDOWN:  /* Initialise mouse tracking */
-                NtUserHideCaret( hwnd ); /* hide caret while holding down LBUTTON */
+                HideCaret(hwnd);  /* hide caret while holding down LBUTTON */
                 NtUserSetCapture( hwnd );
                 prevPt = pt;
                 g_tracking_info.hit_test = hittest = SCROLL_THUMB;
@@ -826,7 +826,7 @@ void SCROLL_HandleScrollEvent( HWND hwnd, INT nBar, UINT msg, POINT pt )
             case WM_LBUTTONUP:
                 ReleaseCapture();
                 g_tracking_info.hit_test = hittest = SCROLL_NOWHERE;
-                if (hwnd == GetFocus()) NtUserShowCaret( hwnd );
+                if (hwnd==GetFocus()) ShowCaret(hwnd);
                 break;
             case WM_SYSTIMER:
                 pt = prevPt;
@@ -844,7 +844,7 @@ void SCROLL_HandleScrollEvent( HWND hwnd, INT nBar, UINT msg, POINT pt )
     switch(msg)
     {
       case WM_LBUTTONDOWN:  /* Initialise mouse tracking */
-          NtUserHideCaret( hwnd ); /* hide caret while holding down LBUTTON */
+          HideCaret(hwnd);  /* hide caret while holding down LBUTTON */
           g_tracking_info.vertical = vertical;
           g_tracking_info.hit_test = hittest = SCROLL_HitTest( hwnd, nBar, pt, FALSE );
           lastClickPos  = vertical ? (pt.y - rect.top) : (pt.x - rect.left);
@@ -864,12 +864,12 @@ void SCROLL_HandleScrollEvent( HWND hwnd, INT nBar, UINT msg, POINT pt )
 
           tme.cbSize = sizeof(tme);
           tme.dwFlags = TME_QUERY;
-          NtUserTrackMouseEvent( &tme );
+          TrackMouseEvent( &tme );
           if (!(tme.dwFlags & TME_LEAVE) || tme.hwndTrack != hwnd)
           {
               tme.dwFlags = TME_LEAVE;
               tme.hwndTrack = hwnd;
-              NtUserTrackMouseEvent( &tme );
+              TrackMouseEvent( &tme );
           }
 
           break;
@@ -883,12 +883,12 @@ void SCROLL_HandleScrollEvent( HWND hwnd, INT nBar, UINT msg, POINT pt )
 
           tme.cbSize = sizeof(tme);
           tme.dwFlags = TME_QUERY;
-          NtUserTrackMouseEvent( &tme );
+          TrackMouseEvent( &tme );
           if (((tme.dwFlags & (TME_NONCLIENT | TME_LEAVE)) != (TME_NONCLIENT | TME_LEAVE)) || tme.hwndTrack != hwnd)
           {
               tme.dwFlags = TME_NONCLIENT | TME_LEAVE;
               tme.hwndTrack = hwnd;
-              NtUserTrackMouseEvent( &tme );
+              TrackMouseEvent( &tme );
           }
 
           break;
@@ -911,7 +911,7 @@ void SCROLL_HandleScrollEvent( HWND hwnd, INT nBar, UINT msg, POINT pt )
           hittest = SCROLL_NOWHERE;
           ReleaseCapture();
           /* if scrollbar has focus, show back caret */
-          if (hwnd == GetFocus()) NtUserShowCaret( hwnd );
+          if (hwnd==GetFocus()) ShowCaret(hwnd);
           break;
 
       case WM_SYSTIMER:
@@ -950,7 +950,7 @@ void SCROLL_HandleScrollEvent( HWND hwnd, INT nBar, UINT msg, POINT pt )
 	    }
 
 	    NtUserSetSystemTimer( hwnd, SCROLL_TIMER, (msg == WM_LBUTTONDOWN) ?
-                                  SCROLL_FIRST_DELAY : SCROLL_REPEAT_DELAY );
+                                  SCROLL_FIRST_DELAY : SCROLL_REPEAT_DELAY, NULL );
         }
         else KillSystemTimer( hwnd, SCROLL_TIMER );
         break;
@@ -965,7 +965,7 @@ void SCROLL_HandleScrollEvent( HWND hwnd, INT nBar, UINT msg, POINT pt )
                                 SB_PAGEUP, (LPARAM)hwndCtl );
             }
             NtUserSetSystemTimer( hwnd, SCROLL_TIMER, (msg == WM_LBUTTONDOWN) ?
-                                  SCROLL_FIRST_DELAY : SCROLL_REPEAT_DELAY );
+                                  SCROLL_FIRST_DELAY : SCROLL_REPEAT_DELAY, NULL );
         }
         else KillSystemTimer( hwnd, SCROLL_TIMER );
         break;
@@ -1023,7 +1023,7 @@ void SCROLL_HandleScrollEvent( HWND hwnd, INT nBar, UINT msg, POINT pt )
                                 SB_PAGEDOWN, (LPARAM)hwndCtl );
             }
             NtUserSetSystemTimer( hwnd, SCROLL_TIMER, (msg == WM_LBUTTONDOWN) ?
-                                  SCROLL_FIRST_DELAY : SCROLL_REPEAT_DELAY );
+                                  SCROLL_FIRST_DELAY : SCROLL_REPEAT_DELAY, NULL );
         }
         else KillSystemTimer( hwnd, SCROLL_TIMER );
         break;
@@ -1039,7 +1039,7 @@ void SCROLL_HandleScrollEvent( HWND hwnd, INT nBar, UINT msg, POINT pt )
 	    }
 
 	    NtUserSetSystemTimer( hwnd, SCROLL_TIMER, (msg == WM_LBUTTONDOWN) ?
-                                  SCROLL_FIRST_DELAY : SCROLL_REPEAT_DELAY );
+                                  SCROLL_FIRST_DELAY : SCROLL_REPEAT_DELAY, NULL );
         }
         else KillSystemTimer( hwnd, SCROLL_TIMER );
         break;
@@ -1110,7 +1110,7 @@ void SCROLL_TrackScrollBar( HWND hwnd, INT scrollbar, POINT pt )
     do
     {
         if (!GetMessageW( &msg, 0, 0, 0 )) break;
-        if (NtUserCallMsgFilter( &msg, MSGF_SCROLLBAR )) continue;
+        if (CallMsgFilterW( &msg, MSGF_SCROLLBAR )) continue;
         if (msg.message == WM_LBUTTONUP ||
             msg.message == WM_MOUSEMOVE ||
             msg.message == WM_MOUSELEAVE ||
@@ -1468,7 +1468,7 @@ LRESULT WINAPI USER_ScrollBarProc( HWND hwnd, UINT message, WPARAM wParam, LPARA
         break;
 
     case WM_KEYUP:
-        NtUserShowCaret( hwnd );
+        ShowCaret(hwnd);
         break;
 
     case WM_SETFOCUS:
@@ -1480,15 +1480,15 @@ LRESULT WINAPI USER_ScrollBarProc( HWND hwnd, UINT message, WPARAM wParam, LPARA
                                                 &arrowSize, &thumbSize, &thumbPos );
             if (!vertical)
             {
-                NtUserCreateCaret( hwnd, (HBITMAP)1, thumbSize - 2, rect.bottom - rect.top - 2 );
+                CreateCaret(hwnd, (HBITMAP)1, thumbSize-2, rect.bottom-rect.top-2);
                 SetCaretPos(thumbPos+1, rect.top+1);
             }
             else
             {
-                NtUserCreateCaret( hwnd, (HBITMAP)1, rect.right - rect.left - 2, thumbSize - 2);
+                CreateCaret(hwnd, (HBITMAP)1, rect.right-rect.left-2,thumbSize-2);
                 SetCaretPos(rect.top+1, thumbPos+1);
             }
-            NtUserShowCaret( hwnd );
+            ShowCaret(hwnd);
         }
         break;
 
@@ -1506,7 +1506,7 @@ LRESULT WINAPI USER_ScrollBarProc( HWND hwnd, UINT message, WPARAM wParam, LPARA
                 rect.top=thumbPos+1;
                 rect.bottom=rect.top+thumbSize;
             }
-            NtUserHideCaret( hwnd );
+            HideCaret(hwnd);
             InvalidateRect(hwnd,&rect,0);
             DestroyCaret();
         }
diff --git a/dlls/win32u/spy.c b/dlls/user32/spy.c
similarity index 96%
rename from dlls/win32u/spy.c
rename to dlls/user32/spy.c
index ce05dfa1bff..141843e15bb 100644
--- a/dlls/win32u/spy.c
+++ b/dlls/user32/spy.c
@@ -19,16 +19,20 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
-#include "win32u_private.h"
-#include "ntuser_private.h"
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winreg.h"
+#include "win.h"
+#include "user_private.h"
+#include "wine/debug.h"
 #include "commctrl.h"
 #include "commdlg.h"
 #include "richedit.h"
-#include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(message);
 
@@ -2019,7 +2023,7 @@ typedef struct
     WPARAM     wParam;           /* message parameter                  */
     LPARAM     lParam;           /* message parameter                  */
     INT        data_len;         /* length of data to dump             */
-    char       msg_name[60];     /* message name (see debugstr_msg_name) */
+    char       msg_name[60];     /* message name (see SPY_GetMsgName)  */
     WCHAR      wnd_class[60];    /* window class name (full)           */
     WCHAR      wnd_name[16];     /* window name for message            */
 } SPY_INSTANCE;
@@ -2100,16 +2104,13 @@ static const USER_MSG *SPY_Bsearch_Msg( const USER_MSG *msgs, UINT count, UINT c
  */
 static void SPY_GetClassName( SPY_INSTANCE *sp_e )
 {
-    static const WCHAR property_sheet_infoW[] =
-        {'P','r','o','p','e','r','t','y','S','h','e','e','t','I','n','f','o',0};
     /* special code to detect a property sheet dialog   */
-    if ((get_class_long( sp_e->msg_hwnd, GCW_ATOM, FALSE ) == WC_DIALOG) &&
-        (NtUserGetProp( sp_e->msg_hwnd, property_sheet_infoW ))) {
+    if ((GetClassLongW(sp_e->msg_hwnd, GCW_ATOM) == WC_DIALOG) &&
+        (GetPropW(sp_e->msg_hwnd, L"PropertySheetInfo"))) {
         lstrcpyW(sp_e->wnd_class, WC_PROPSHEETW);
     }
     else {
-        UNICODE_STRING str = { .Buffer = sp_e->wnd_class, .MaximumLength = sizeof(sp_e->wnd_class) };
-        NtUserGetClassName( sp_e->msg_hwnd, FALSE, &str );
+        GetClassNameW(sp_e->msg_hwnd, sp_e->wnd_class, ARRAY_SIZE(sp_e->wnd_class));
     }
 }
 
@@ -2130,16 +2131,10 @@ static void SPY_GetMsgStuff( SPY_INSTANCE *sp_e )
 
         if (sp_e->msgnum >= 0xc000)
         {
-            char buf[sizeof(ATOM_BASIC_INFORMATION) + MAX_ATOM_LEN * sizeof(WCHAR)];
-            ATOM_BASIC_INFORMATION *abi = (ATOM_BASIC_INFORMATION *)buf;
-            if (!NtQueryInformationAtom( sp_e->msgnum, AtomBasicInformation, abi, sizeof(buf), NULL ))
+            if (GlobalGetAtomNameA( sp_e->msgnum, sp_e->msg_name+1, sizeof(sp_e->msg_name)-2 ))
             {
-                unsigned int j = 0;
-                sp_e->msg_name[j++] = '\"';
-                j += ntdll_wcstoumbs( abi->Name, abi->NameLength / sizeof(WCHAR),
-                                      sp_e->msg_name + j,  sizeof(sp_e->msg_name) - 3, FALSE );
-                sp_e->msg_name[j++] = '\"';
-                sp_e->msg_name[j] = 0;
+                sp_e->msg_name[0] = '\"';
+                strcat( sp_e->msg_name, "\"" );
                 return;
             }
         }
@@ -2204,13 +2199,13 @@ static void SPY_GetWndName( SPY_INSTANCE *sp_e )
 }
 
 /***********************************************************************
- *           debugstr_msg_name
+ *           SPY_GetMsgName
  *
  *  ****  External function  ****
  *
  *  Get message name
  */
-const char *debugstr_msg_name( UINT msg, HWND hWnd )
+const char *SPY_GetMsgName( UINT msg, HWND hWnd )
 {
     SPY_INSTANCE ext_sp_e;
     DWORD save_error = GetLastError();
@@ -2226,9 +2221,9 @@ const char *debugstr_msg_name( UINT msg, HWND hWnd )
 }
 
 /***********************************************************************
- *           debugstr_vkey_name
+ *           SPY_GetVKeyName
  */
-const char *debugstr_vkey_name(WPARAM wParam)
+const char *SPY_GetVKeyName(WPARAM wParam)
 {
     const char *vk_key_name;
 
@@ -2436,7 +2431,7 @@ static void SPY_DumpStructure(const SPY_INSTANCE *sp_e, BOOL enter)
 
             if (!enter) break;
 
-            unicode = is_window_unicode( sp_e->msg_hwnd );
+            unicode = IsWindowUnicode(sp_e->msg_hwnd);
             cs = (CREATESTRUCTA *)sp_e->lParam;
             TRACE("%s %s ex=%08x style=%08x %d,%d %dx%d parent=%p menu=%p inst=%p params=%p\n",
                   unicode ? debugstr_w((LPCWSTR)cs->lpszName) : debugstr_a(cs->lpszName),
@@ -2493,7 +2488,6 @@ static void SPY_DumpStructure(const SPY_INSTANCE *sp_e, BOOL enter)
                 const SPY_NOTIFY *p;
                 WCHAR from_class[60];
                 DWORD save_error;
-                UNICODE_STRING str = { .Buffer = from_class, .MaximumLength = sizeof(from_class) };
 
                 p = SPY_Bsearch_Notify( pnmh->code );
                 if (p) {
@@ -2505,7 +2499,7 @@ static void SPY_DumpStructure(const SPY_INSTANCE *sp_e, BOOL enter)
                     if (pnmh->code == NM_CUSTOMDRAW) {
                         /* save and restore error code over the next call */
                         save_error = GetLastError();
-                        NtUserGetClassName( pnmh->hwndFrom, FALSE, &str );
+                        GetClassNameW(pnmh->hwndFrom, from_class, ARRAY_SIZE(from_class));
                         SetLastError(save_error);
                         if (wcscmp(TOOLBARCLASSNAMEW, from_class) == 0)
                             dumplen = sizeof(NMTBCUSTOMDRAW)-sizeof(NMHDR);
@@ -2536,64 +2530,61 @@ static void SPY_DumpStructure(const SPY_INSTANCE *sp_e, BOOL enter)
  */
 static BOOL spy_init(void)
 {
+    int i;
+    char buffer[1024];
     HKEY hkey;
     char *exclude;
 
     if (!TRACE_ON(message)) return FALSE;
 
     if (spy_exclude) return TRUE;
-    exclude = calloc( 1, SPY_MAX_MSGNUM + 2 );
+    exclude = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, SPY_MAX_MSGNUM + 2 );
 
     /* @@ Wine registry key: HKCU\Software\Wine\Debug */
-    if ((hkey = reg_open_hkcu_key( "Software\\Wine\\Debug" )))
+    if(!RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\Debug", &hkey))
     {
-        char buffer[2048];
-        KEY_VALUE_PARTIAL_INFORMATION *info = (void *)buffer;
-        unsigned int i, size;
+        DWORD type, count = sizeof(buffer);
 
-        if ((size = query_reg_ascii_value( hkey, "SpyInclude", info, sizeof(buffer) )))
+        buffer[0] = 0;
+        if (!RegQueryValueExA(hkey, "SpyInclude", 0, &type, (LPBYTE) buffer, &count) &&
+            strcmp( buffer, "INCLUDEALL" ))
         {
-            const WCHAR *data = (const WCHAR *)info->Data;
-            for (i = 0; i < size / sizeof(WCHAR); i++) buffer[i] = data[i];
-            buffer[i] = 0;
             TRACE("Include=%s\n", buffer );
-            if (strcmp( buffer, "INCLUDEALL" ))
-            {
-                for (i = 0; i <= SPY_MAX_MSGNUM; i++)
-                    exclude[i] = MessageTypeNames[i] && !strstr(buffer,MessageTypeNames[i]);
-            }
+            for (i = 0; i <= SPY_MAX_MSGNUM; i++)
+                exclude[i] = (MessageTypeNames[i] && !strstr(buffer,MessageTypeNames[i]));
         }
 
-        if ((size = query_reg_ascii_value( hkey, "SpyExclude", info, sizeof(buffer) )))
+        count = sizeof(buffer);
+        buffer[0] = 0;
+        if (!RegQueryValueExA(hkey, "SpyExclude", 0, &type, (LPBYTE) buffer, &count))
         {
-            const WCHAR *data = (const WCHAR *)info->Data;
-            for (i = 0; i < size / sizeof(WCHAR); i++) buffer[i] = data[i];
-            buffer[i] = 0;
             TRACE("Exclude=%s\n", buffer );
             if (!strcmp( buffer, "EXCLUDEALL" ))
                 for (i = 0; i <= SPY_MAX_MSGNUM; i++) exclude[i] = TRUE;
             else
                 for (i = 0; i <= SPY_MAX_MSGNUM; i++)
-                    exclude[i] = MessageTypeNames[i] && strstr(buffer,MessageTypeNames[i]);
+                    exclude[i] = (MessageTypeNames[i] && strstr(buffer,MessageTypeNames[i]));
         }
 
-        if (query_reg_ascii_value( hkey, "SpyExcludeDWP", info, sizeof(buffer) ))
-            exclude[SPY_MAX_MSGNUM + 1] = wcstol( (const WCHAR *)info->Data, NULL, 0 );
+        count = sizeof(buffer);
+        if(!RegQueryValueExA(hkey, "SpyExcludeDWP", 0, &type, (LPBYTE) buffer, &count))
+            exclude[SPY_MAX_MSGNUM + 1] = atoi(buffer);
 
-        NtClose( hkey );
+        RegCloseKey(hkey);
     }
 
     if (InterlockedCompareExchangePointer( (void **)&spy_exclude, exclude, NULL ))
-        free( exclude );
+        HeapFree( GetProcessHeap(), 0, exclude );
 
     return TRUE;
 }
 
 
 /***********************************************************************
- *           spy_enter_message
+ *           SPY_EnterMessage
  */
-void spy_enter_message( INT iFlag, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )
+void SPY_EnterMessage( INT iFlag, HWND hWnd, UINT msg,
+                       WPARAM wParam, LPARAM lParam )
 {
     SPY_INSTANCE sp_e;
     int indent;
@@ -2609,7 +2600,7 @@ void spy_enter_message( INT iFlag, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lP
     SPY_GetMsgStuff(&sp_e);
     indent = get_indent_level();
 
-    /* each SPY_SENDMESSAGE must be complemented by call to spy_exit_message */
+    /* each SPY_SENDMESSAGE must be complemented by call to SPY_ExitMessage */
     switch(iFlag)
     {
     case SPY_DISPATCHMESSAGE:
@@ -2621,7 +2612,7 @@ void spy_enter_message( INT iFlag, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lP
     case SPY_SENDMESSAGE:
         {
             char taskName[20];
-            DWORD tid = get_window_thread( hWnd, NULL );
+            DWORD tid = GetWindowThreadProcessId( hWnd, NULL );
 
             if (tid == GetCurrentThreadId()) strcpy( taskName, "self" );
             else sprintf( taskName, "tid %04x", GetCurrentThreadId() );
@@ -2645,9 +2636,9 @@ void spy_enter_message( INT iFlag, HWND hWnd, UINT msg, WPARAM wParam, LPARAM lP
 
 
 /***********************************************************************
- *           spy_exit_message
+ *           SPY_ExitMessage
  */
-void spy_exit_message( INT iFlag, HWND hWnd, UINT msg, LRESULT lReturn,
+void SPY_ExitMessage( INT iFlag, HWND hWnd, UINT msg, LRESULT lReturn,
                        WPARAM wParam, LPARAM lParam )
 {
     SPY_INSTANCE sp_e;
diff --git a/dlls/user32/sysparams.c b/dlls/user32/sysparams.c
index ec83a1822a5..b392ec35eb5 100644
--- a/dlls/user32/sysparams.c
+++ b/dlls/user32/sysparams.c
@@ -444,7 +444,7 @@ BOOL WINAPI SystemParametersInfoA( UINT uiAction, UINT uiParam,
  */
 INT WINAPI GetSystemMetrics( INT index )
 {
-    return NtUserGetSystemMetrics( index );
+    return NtUserCallOneParam( index, NtUserGetSystemMetrics );
 }
 
 
@@ -453,7 +453,7 @@ INT WINAPI GetSystemMetrics( INT index )
  */
 INT WINAPI GetSystemMetricsForDpi( INT index, UINT dpi )
 {
-    return NtUserGetSystemMetricsForDpi( index, dpi );
+    return NtUserCallTwoParam( index, dpi, NtUserGetSystemMetricsForDpi );
 }
 
 
@@ -486,7 +486,7 @@ BOOL WINAPI SetDoubleClickTime( UINT interval )
  */
 COLORREF WINAPI DECLSPEC_HOTPATCH GetSysColor( INT index )
 {
-    return NtUserGetSysColor( index );
+    return NtUserCallOneParam( index, NtUserGetSysColor );
 }
 
 
@@ -505,7 +505,7 @@ DWORD_PTR WINAPI SetSysColorsTemp( const COLORREF *pPens, const HBRUSH *pBrushes
  */
 HBRUSH WINAPI DECLSPEC_HOTPATCH GetSysColorBrush( INT index )
 {
-    return NtUserGetSysColorBrush( index );
+    return UlongToHandle( NtUserCallOneParam( index, NtUserGetSysColorBrush ));
 }
 
 
@@ -514,7 +514,7 @@ HBRUSH WINAPI DECLSPEC_HOTPATCH GetSysColorBrush( INT index )
  */
 HPEN SYSCOLOR_GetPen( INT index )
 {
-    return NtUserGetSysColorPen( index );
+    return UlongToHandle( NtUserCallOneParam( index, NtUserGetSysColorPen ));
 }
 
 
@@ -523,7 +523,7 @@ HPEN SYSCOLOR_GetPen( INT index )
  */
 HBRUSH SYSCOLOR_Get55AABrush(void)
 {
-    return NtUserGetSysColorBrush( COLOR_55AA_BRUSH );
+    return UlongToHandle( NtUserCallOneParam( COLOR_55AA_BRUSH, NtUserGetSysColorBrush ));
 }
 
 /***********************************************************************
@@ -739,6 +739,16 @@ POINT point_win_to_thread_dpi( HWND hwnd, POINT pt )
     return map_dpi_point( pt, GetDpiForWindow( hwnd ), dpi );
 }
 
+/**********************************************************************
+ *              point_thread_to_win_dpi
+ */
+POINT point_thread_to_win_dpi( HWND hwnd, POINT pt )
+{
+    UINT dpi = get_thread_dpi();
+    if (!dpi) dpi = get_win_monitor_dpi( hwnd );
+    return map_dpi_point( pt, dpi, GetDpiForWindow( hwnd ));
+}
+
 /**********************************************************************
  *              map_dpi_rect
  */
@@ -764,6 +774,16 @@ RECT rect_win_to_thread_dpi( HWND hwnd, RECT rect )
     return map_dpi_rect( rect, GetDpiForWindow( hwnd ), dpi );
 }
 
+/**********************************************************************
+ *              rect_thread_to_win_dpi
+ */
+RECT rect_thread_to_win_dpi( HWND hwnd, RECT rect )
+{
+    UINT dpi = get_thread_dpi();
+    if (!dpi) dpi = get_win_monitor_dpi( hwnd );
+    return map_dpi_rect( rect, dpi, GetDpiForWindow( hwnd ) );
+}
+
 /**********************************************************************
  *              SetProcessDpiAwarenessContext   (USER32.@)
  */
@@ -974,7 +994,7 @@ BOOL WINAPI PhysicalToLogicalPointForPerMonitorDPI( HWND hwnd, POINT *pt )
  */
 HMONITOR WINAPI MonitorFromRect( const RECT *rect, DWORD flags )
 {
-    return NtUserMonitorFromRect( rect, flags );
+    return UlongToHandle( NtUserCallTwoParam( (LONG_PTR)rect, flags, NtUserMonitorFromRect ));
 }
 
 /***********************************************************************
@@ -993,7 +1013,7 @@ HMONITOR WINAPI MonitorFromPoint( POINT pt, DWORD flags )
  */
 HMONITOR WINAPI MonitorFromWindow( HWND hwnd, DWORD flags )
 {
-    return NtUserMonitorFromWindow( hwnd, flags );
+    return UlongToHandle( NtUserCallHwndParam(  hwnd, flags, NtUserMonitorFromWindow ));
 }
 
 /***********************************************************************
@@ -1025,7 +1045,7 @@ BOOL WINAPI GetMonitorInfoA( HMONITOR monitor, LPMONITORINFO info )
  */
 BOOL WINAPI GetMonitorInfoW( HMONITOR monitor, LPMONITORINFO info )
 {
-    return NtUserGetMonitorInfo( monitor, info );
+    return NtUserCallTwoParam( HandleToUlong(monitor), (ULONG_PTR)info, NtUserGetMonitorInfo );
 }
 
 #ifdef __i386__
diff --git a/dlls/user32/tests/clipboard.c b/dlls/user32/tests/clipboard.c
index e05de29805e..537b714a6ac 100644
--- a/dlls/user32/tests/clipboard.c
+++ b/dlls/user32/tests/clipboard.c
@@ -2032,7 +2032,7 @@ static void test_data_handles(void)
     memset( &bmi, 0, sizeof(bmi) );
     bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     result = GetDIBits( hdc, h, 0, 0, NULL, &bmi, 0 );
-    ok( !!result, "GetDIBits failed: %#lx.\n", GetLastError() );
+    todo_wine ok( !!result, "GetDIBits failed: %#lx.\n", GetLastError() );
 
     bitmap = CreateBitmap( 10, 10, 1, 1, NULL );
     h = SetClipboardData( CF_DSPBITMAP, bitmap );
@@ -2050,8 +2050,8 @@ static void test_data_handles(void)
     ok( !!DeleteObject( palette ), "DeleteObject failed.\n" );
     h = GetClipboardData( CF_PALETTE );
     ok( h == palette, "Expected palette %p, got %p.\n", palette, h );
-    ok( !!GetPaletteEntries( h, 0, 1, &entry ), "GetPaletteEntries %p failed.\n", h );
-    ok( entry.peRed == 0x12 && entry.peGreen == 0x34 && entry.peBlue == 0x56,
+    todo_wine ok( !!GetPaletteEntries( h, 0, 1, &entry ), "GetPaletteEntries %p failed.\n", h );
+    todo_wine ok( entry.peRed == 0x12 && entry.peGreen == 0x34 && entry.peBlue == 0x56,
             "Got wrong color (%02x, %02x, %02x).\n", entry.peRed, entry.peGreen, entry.peBlue );
 
     emf = create_emf();
diff --git a/dlls/user32/tests/monitor.c b/dlls/user32/tests/monitor.c
index 4b774037508..94cb7e60382 100644
--- a/dlls/user32/tests/monitor.c
+++ b/dlls/user32/tests/monitor.c
@@ -2164,6 +2164,7 @@ static void _check_display_dc(INT line, HDC hdc, const DEVMODEA *dm, BOOL allow_
     ok_(__FILE__, line)(!!hbmp, "GetCurrentObject failed, error %#lx.\n", GetLastError());
     ret = GetObjectA(hbmp, sizeof(bitmap), &bitmap);
     /* GetObjectA fails on Win7 and older */
+    ok_(__FILE__, line)(ret || broken(!ret), "GetObjectA failed, error %ld.\n", GetLastError());
     if (ret)
     {
         ok_(__FILE__, line)(bitmap.bmType == 0, "Expected bmType %d, got %d.\n", 0, bitmap.bmType);
diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
index 2705914d5e5..472c55ec82c 100644
--- a/dlls/user32/tests/msg.c
+++ b/dlls/user32/tests/msg.c
@@ -10790,7 +10790,8 @@ static void test_timers(void)
            || broken(syscount > 4000 && syscount < 12000) /* win2k3sp0 */,
            "did not get expected count for minimum timeout (%d != ~%d).\n",
            syscount, TIMER_COUNT_EXPECTED);
-        ok(count == 0, "did not get expected count for callback timeout (%d != 0).\n", count);
+        todo_wine ok(count == 0, "did not get expected count for callback timeout (%d != 0).\n",
+                                 count);
         ok(pKillSystemTimer(info.hWnd, id), "KillSystemTimer failed\n");
     }
 
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index c153b6dbfe3..df5af5624dd 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -25,15 +25,15 @@
 # @ stub BuildReasonArray
 @ stdcall CalcChildScroll(long long)
 @ stdcall CalcMenuBar(long long long long ptr) CalcMenuBar
-@ stdcall CallMsgFilter(ptr long) NtUserCallMsgFilter
-@ stdcall CallMsgFilterA(ptr long) NtUserCallMsgFilter
-@ stdcall CallMsgFilterW(ptr long) NtUserCallMsgFilter
+@ stdcall CallMsgFilter(ptr long) CallMsgFilterA
+@ stdcall CallMsgFilterA(ptr long)
+@ stdcall CallMsgFilterW(ptr long)
 @ stdcall CallNextHookEx(long long long long) NtUserCallNextHookEx
 @ stdcall CallWindowProcA(ptr long long long long)
 @ stdcall CallWindowProcW(ptr long long long long)
 @ stdcall CascadeChildWindows(long long)
 @ stdcall CascadeWindows(long long ptr long ptr)
-@ stdcall ChangeClipboardChain(long long) NtUserChangeClipboardChain
+@ stdcall ChangeClipboardChain(long long)
 @ stdcall ChangeDisplaySettingsA(ptr long)
 @ stdcall ChangeDisplaySettingsExA(str ptr long long ptr)
 @ stdcall ChangeDisplaySettingsExW(wstr ptr long long ptr)
@@ -63,7 +63,7 @@
 @ stdcall -import CharUpperBuffW(wstr long)
 @ stdcall -import CharUpperW(wstr)
 @ stdcall CheckDlgButton(long long long)
-@ stdcall CheckMenuItem(long long long) NtUserCheckMenuItem
+@ stdcall CheckMenuItem(long long long)
 @ stdcall CheckMenuRadioItem(long long long long long)
 @ stdcall CheckRadioButton(long long long long)
 @ stdcall ChildWindowFromPoint(long int64)
@@ -73,7 +73,7 @@
 @ stub ClientThreadSetup
 @ stdcall ClientToScreen(long ptr)
 @ stdcall -import ClipCursor(ptr) NtUserClipCursor
-@ stdcall CloseClipboard() NtUserCloseClipboard
+@ stdcall CloseClipboard()
 @ stdcall CloseDesktop(long) NtUserCloseDesktop
 @ stdcall CloseTouchInputHandle(long)
 @ stdcall CloseWindow(long)
@@ -86,7 +86,7 @@
 @ stdcall CountClipboardFormats() NtUserCountClipboardFormats
 @ stdcall CreateAcceleratorTableA(ptr long)
 @ stdcall CreateAcceleratorTableW(ptr long) NtUserCreateAcceleratorTable
-@ stdcall CreateCaret(long long long long) NtUserCreateCaret
+@ stdcall CreateCaret(long long long long)
 @ stdcall CreateCursor(long long long long long ptr ptr)
 @ stdcall CreateDesktopA(str str ptr long long ptr)
 @ stdcall CreateDesktopW(wstr wstr ptr long long ptr)
@@ -153,13 +153,13 @@
 @ stdcall DefWindowProcA(long long long long)
 @ stdcall DefWindowProcW(long long long long)
 @ stdcall DeferWindowPos(long long long long long long long long)
-@ stdcall DeleteMenu(long long long) NtUserDeleteMenu
+@ stdcall DeleteMenu(long long long)
 @ stdcall DeregisterShellHookWindow (long)
 @ stdcall DestroyAcceleratorTable(long) NtUserDestroyAcceleratorTable
 @ stdcall DestroyCaret()
 @ stdcall DestroyCursor(long)
 @ stdcall DestroyIcon(long)
-@ stdcall DestroyMenu(long) NtUserDestroyMenu
+@ stdcall DestroyMenu(long)
 # @ stub DestroyReasons
 @ stdcall DestroyWindow(long) NtUserDestroyWindow
 # @ stub DeviceEventWorker
@@ -202,8 +202,8 @@
 @ stdcall DrawTextExW(long wstr long ptr long ptr)
 @ stdcall DrawTextW(long wstr long ptr long)
 @ stdcall EditWndProc(long long long long) EditWndProcA
-@ stdcall EmptyClipboard() NtUserEmptyClipboard
-@ stdcall EnableMenuItem(long long long) NtUserEnableMenuItem
+@ stdcall EmptyClipboard()
+@ stdcall EnableMenuItem(long long long)
 @ stdcall EnableMouseInPointer(long)
 @ stdcall EnableNonClientDpiScaling(long)
 @ stdcall EnableScrollBar(long long long)
@@ -237,7 +237,7 @@
 @ stdcall EnumWindowStationsW(ptr long)
 @ stdcall EnumWindows(ptr long)
 @ stdcall EqualRect(ptr ptr)
-@ stdcall ExcludeUpdateRgn(long long) NtUserExcludeUpdateRgn
+@ stdcall ExcludeUpdateRgn(long long)
 @ stdcall ExitWindowsEx(long long)
 @ stdcall FillRect(long ptr long)
 @ stdcall FindWindowA(str str)
@@ -259,8 +259,8 @@
 @ stdcall GetAutoRotationState(ptr)
 @ stdcall GetAwarenessFromDpiAwarenessContext(long)
 @ stdcall GetCapture()
-@ stdcall GetCaretBlinkTime() NtUserGetCaretBlinkTime
-@ stdcall GetCaretPos(ptr) NtUserGetCaretPos
+@ stdcall GetCaretBlinkTime()
+@ stdcall GetCaretPos(ptr)
 @ stdcall GetClassInfoA(long str ptr)
 @ stdcall GetClassInfoExA(long str ptr)
 @ stdcall GetClassInfoExW(long wstr ptr)
@@ -338,7 +338,7 @@
 @ stdcall GetMenuItemID(long long)
 @ stdcall GetMenuItemInfoA(long long long ptr)
 @ stdcall GetMenuItemInfoW(long long long ptr)
-@ stdcall GetMenuItemRect(long long long ptr) NtUserGetMenuItemRect
+@ stdcall GetMenuItemRect(long long long ptr)
 @ stdcall GetMenuState(long long long)
 @ stdcall GetMenuStringA(long long ptr long long)
 @ stdcall GetMenuStringW(long long ptr long long)
@@ -381,7 +381,7 @@
 @ stdcall GetSubMenu(long long)
 @ stdcall GetSysColor(long)
 @ stdcall GetSysColorBrush(long)
-@ stdcall GetSystemMenu(long long) NtUserGetSystemMenu
+@ stdcall GetSystemMenu(long long)
 @ stdcall GetSystemMetrics(long)
 @ stdcall GetSystemMetricsForDpi(long long)
 @ stdcall GetTabbedTextExtentA(long str long long ptr)
@@ -412,7 +412,7 @@
 @ stdcall GetWindowModuleFileName(long ptr long) GetWindowModuleFileNameA
 @ stdcall GetWindowModuleFileNameA(long ptr long)
 @ stdcall GetWindowModuleFileNameW(long ptr long)
-@ stdcall GetWindowPlacement(long ptr) NtUserGetWindowPlacement
+@ stdcall GetWindowPlacement(long ptr)
 @ stdcall GetWindowRect(long ptr)
 @ stdcall GetWindowRgn(long long)
 @ stdcall GetWindowRgnBox(long ptr)
@@ -425,7 +425,7 @@
 @ stdcall GrayStringA(long long ptr long long long long long long)
 @ stdcall GrayStringW(long long ptr long long long long long long)
 # @ stub HasSystemSleepStarted
-@ stdcall HideCaret(long) NtUserHideCaret
+@ stdcall HideCaret(long)
 @ stdcall HiliteMenuItem(long long long long)
 # @ stub IMPGetIMEA
 # @ stub IMPGetIMEW
@@ -544,7 +544,7 @@
 @ stdcall MonitorFromWindow(long long)
 @ stdcall MoveWindow(long long long long long long) NtUserMoveWindow
 @ stdcall MsgWaitForMultipleObjects(long ptr long long long)
-@ stdcall MsgWaitForMultipleObjectsEx(long ptr long long long) NtUserMsgWaitForMultipleObjectsEx
+@ stdcall MsgWaitForMultipleObjectsEx(long ptr long long long)
 @ stdcall NotifyWinEvent(long long long long) NtUserNotifyWinEvent
 @ stdcall OemKeyScan(long)
 @ stdcall OemToCharA(str ptr)
@@ -571,7 +571,7 @@
 @ stdcall PostMessageW(long long long long)
 @ stdcall PostQuitMessage(long)
 @ stdcall PostThreadMessageA(long long long long)
-@ stdcall PostThreadMessageW(long long long long) NtUserPostThreadMessage
+@ stdcall PostThreadMessageW(long long long long)
 @ stdcall PrintWindow(long long long)
 @ stdcall PrivateExtractIconExA(str long ptr ptr long)
 @ stdcall PrivateExtractIconExW(wstr long ptr ptr long)
@@ -619,7 +619,7 @@
 @ stdcall ReleaseCapture()
 @ stdcall ReleaseDC(long long) NtUserReleaseDC
 @ stdcall RemoveClipboardFormatListener(long) NtUserRemoveClipboardFormatListener
-@ stdcall RemoveMenu(long long long) NtUserRemoveMenu
+@ stdcall RemoveMenu(long long long)
 @ stdcall RemovePropA(long str)
 @ stdcall RemovePropW(long wstr)
 @ stdcall ReplyMessage(long)
@@ -635,7 +635,7 @@
 @ stdcall SendDlgItemMessageW(long long long long long)
 @ stdcall SendIMEMessageExA(long long)
 @ stdcall SendIMEMessageExW(long long)
-@ stdcall SendInput(long ptr long) NtUserSendInput
+@ stdcall SendInput(long ptr long)
 @ stdcall SendMessageA(long long long long)
 @ stdcall SendMessageCallbackA(long long long long ptr long)
 @ stdcall SendMessageCallbackW(long long long long ptr long)
@@ -655,7 +655,7 @@
 @ stdcall SetClassLongW(long long long)
 @ stdcall SetClassWord(long long long) NtUserSetClassWord
 @ stdcall SetClipboardData(long long)
-@ stdcall SetClipboardViewer(long) NtUserSetClipboardViewer
+@ stdcall SetClipboardViewer(long)
 @ stdcall SetCoalescableTimer(long long long ptr long) NtUserSetTimer
 # @ stub SetConsoleReserveKeys
 @ stdcall -import SetCursor(long) NtUserSetCursor
@@ -673,14 +673,14 @@
 @ stdcall SetFocus(long) NtUserSetFocus
 @ stdcall SetForegroundWindow(long)
 @ stdcall SetGestureConfig(ptr long long ptr long)
-@ stdcall SetInternalWindowPos(long long ptr ptr) NtUserSetInternalWindowPos
+@ stdcall SetInternalWindowPos(long long ptr ptr)
 @ stdcall SetKeyboardState(ptr) NtUserSetKeyboardState
 @ stdcall SetLastErrorEx(long long)
 @ stdcall SetLayeredWindowAttributes(ptr long long long) NtUserSetLayeredWindowAttributes
 @ stdcall SetLogonNotifyWindow(long long)
-@ stdcall SetMenu(long long) NtUserSetMenu
-@ stdcall SetMenuContextHelpId(long long) NtUserSetMenuContextHelpId
-@ stdcall SetMenuDefaultItem(long long long) NtUserSetMenuDefaultItem
+@ stdcall SetMenu(long long)
+@ stdcall SetMenuContextHelpId(long long)
+@ stdcall SetMenuDefaultItem(long long long)
 @ stdcall SetMenuInfo(long ptr)
 @ stdcall SetMenuItemBitmaps(long long long long long)
 @ stdcall SetMenuItemInfoA(long long long ptr)
@@ -707,8 +707,8 @@
 @ stdcall SetSysColors(long ptr ptr) NtUserSetSysColors
 @ stdcall SetSysColorsTemp(ptr ptr long)
 @ stdcall SetSystemCursor(long long)
-@ stdcall SetSystemMenu(long long) NtUserSetSystemMenu
-@ stdcall SetSystemTimer(long long long ptr)
+@ stdcall SetSystemMenu(long long)
+@ stdcall SetSystemTimer(long long long ptr) NtUserSetSystemTimer
 @ stdcall SetTaskmanWindow (long)
 @ stdcall SetThreadDesktop(long) NtUserSetThreadDesktop
 @ stdcall SetThreadDpiAwarenessContext(ptr)
@@ -725,7 +725,7 @@
 @ stdcall -arch=win64 SetWindowLongPtrA(long long long)
 @ stdcall -arch=win64 SetWindowLongPtrW(long long long)
 @ stdcall SetWindowLongW(long long long)
-@ stdcall SetWindowPlacement(long ptr) NtUserSetWindowPlacement
+@ stdcall SetWindowPlacement(long ptr)
 @ stdcall SetWindowPos(long long long long long long long) NtUserSetWindowPos
 @ stdcall SetWindowRgn(long long long) NtUserSetWindowRgn
 @ stdcall SetWindowStationUser(long long)
@@ -736,7 +736,7 @@
 @ stdcall SetWindowsHookExA(long long long long)
 @ stdcall SetWindowsHookExW(long long long long)
 @ stdcall SetWindowsHookW(long ptr)
-@ stdcall ShowCaret(long) NtUserShowCaret
+@ stdcall ShowCaret(long)
 @ stdcall -import ShowCursor(long) NtUserShowCursor
 @ stdcall ShowOwnedPopups(long long)
 @ stdcall ShowScrollBar(long long long)
@@ -762,12 +762,12 @@
 @ stdcall ToAsciiEx(long long ptr ptr long long)
 @ stdcall ToUnicode(long long ptr ptr long long)
 @ stdcall ToUnicodeEx(long long ptr ptr long long long) NtUserToUnicodeEx
-@ stdcall TrackMouseEvent(ptr) NtUserTrackMouseEvent
+@ stdcall TrackMouseEvent(ptr)
 @ stdcall TrackPopupMenu(long long long long long long ptr)
 @ stdcall TrackPopupMenuEx(long long long long long ptr)
 @ stdcall TranslateAccelerator(long long ptr) TranslateAcceleratorA
 @ stdcall TranslateAcceleratorA(long long ptr)
-@ stdcall TranslateAcceleratorW(long long ptr) NtUserTranslateAccelerator
+@ stdcall TranslateAcceleratorW(long long ptr)
 @ stdcall TranslateMDISysAccel(long ptr)
 @ stdcall TranslateMessage(ptr)
 # @ stub TranslateMessageEx
@@ -831,3 +831,13 @@
 @ varargs wsprintfW(wstr wstr)
 @ stdcall wvsprintfA(ptr str ptr)
 @ stdcall wvsprintfW(ptr wstr ptr)
+
+################################################################
+# Wine internal extensions
+#
+# All functions must be prefixed with '__wine_' (for internal functions)
+# or 'wine_' (for user-visible functions) to avoid namespace conflicts.
+#
+@ cdecl __wine_send_input(long ptr ptr)
+@ cdecl __wine_set_pixel_format(long long)
+@ cdecl __wine_set_user_driver(ptr long)
diff --git a/dlls/user32/user_main.c b/dlls/user32/user_main.c
index eeef0d57f62..3640cd32689 100644
--- a/dlls/user32/user_main.c
+++ b/dlls/user32/user_main.c
@@ -26,7 +26,6 @@
 #include "wingdi.h"
 #include "winuser.h"
 #include "imm.h"
-#include "ddk/imm.h"
 
 #include "controls.h"
 #include "user_private.h"
@@ -34,7 +33,6 @@
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(graphics);
-WINE_DECLARE_DEBUG_CHANNEL(message);
 
 HMODULE user32_module = 0;
 
@@ -76,7 +74,7 @@ void USER_CheckNotLock(void)
  */
 UINT WINAPI UserRealizePalette( HDC hdc )
 {
-    return NtUserRealizePalette( hdc );
+    return NtUserCallOneParam( HandleToUlong(hdc), NtUserRealizePalette );
 }
 
 
@@ -142,60 +140,44 @@ static void CDECL notify_ime( HWND hwnd, UINT param )
     if (ime_default) SendMessageW( ime_default, WM_IME_INTERNAL, param, HandleToUlong(hwnd) );
 }
 
-static BOOL WINAPI register_imm( HWND hwnd )
-{
-    return imm_register_window( hwnd );
-}
-
-static void WINAPI unregister_imm( HWND hwnd )
+void WINAPI unregister_imm( HWND hwnd )
 {
     imm_unregister_window( hwnd );
 }
 
 static void CDECL free_win_ptr( WND *win )
 {
+    HeapFree( GetProcessHeap(), 0, win->text );
     HeapFree( GetProcessHeap(), 0, win->pScroll );
+    HeapFree( GetProcessHeap(), 0, win );
 }
 
 static const struct user_callbacks user_funcs =
 {
+    AdjustWindowRectEx,
+    CopyImage,
+    DestroyCaret,
+    DestroyMenu,
     EndMenu,
-    ImmProcessKey,
-    ImmTranslateMessage,
-    NtWaitForMultipleObjects,
+    HideCaret,
+    PostMessageW,
+    SendInput,
+    SendMessageTimeoutW,
+    SendMessageW,
+    SendNotifyMessageW,
+    ShowCaret,
+    WaitForInputIdle,
     free_win_ptr,
-    MENU_GetSysMenu,
     MENU_IsMenuActive,
     notify_ime,
-    post_dde_message,
-    process_rawinput_message,
-    rawinput_device_get_usages,
+    register_builtin_classes,
+    MSG_SendInternalMessageTimeout,
     SCROLL_SetStandardScrollPainted,
-    unpack_dde_message,
-    register_imm,
+    (void *)__wine_set_user_driver,
+    set_window_pos,
     unregister_imm,
 };
 
-static NTSTATUS WINAPI User32CopyImage( const struct copy_image_params *params, ULONG size )
-{
-    HANDLE ret = CopyImage( params->hwnd, params->type, params->dx, params->dy, params->flags );
-    return HandleToUlong( ret );
-}
-
-static NTSTATUS WINAPI User32FreeCachedClipboardData( const struct free_cached_data_params *params,
-                                                      ULONG size )
-{
-    free_cached_data( params->format, params->handle );
-    return 0;
-}
-
-static NTSTATUS WINAPI User32RenderSsynthesizedFormat( const struct render_synthesized_format_params *params,
-                                                       ULONG size )
-{
-    render_synthesized_format( params->format, params->from );
-    return 0;
-}
-
 static BOOL WINAPI User32LoadDriver( const WCHAR *path, ULONG size )
 {
     return LoadLibraryW( path ) != NULL;
@@ -204,15 +186,9 @@ static BOOL WINAPI User32LoadDriver( const WCHAR *path, ULONG size )
 static const void *kernel_callback_table[NtUserCallCount] =
 {
     User32CallEnumDisplayMonitor,
-    User32CallSendAsyncCallback,
     User32CallWinEventHook,
-    User32CallWindowProc,
     User32CallWindowsHook,
-    User32CopyImage,
-    User32FreeCachedClipboardData,
     User32LoadDriver,
-    User32RegisterBuiltinClasses,
-    User32RenderSsynthesizedFormat,
 };
 
 
@@ -288,6 +264,7 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved )
         thread_detach();
         break;
     case DLL_PROCESS_DETACH:
+        USER_unload_driver();
         FreeLibrary(imm32_module);
         break;
     }
@@ -371,24 +348,3 @@ BOOL WINAPI ShutdownBlockReasonDestroy(HWND hwnd)
     SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
     return FALSE;
 }
-
-const char *SPY_GetMsgName( UINT msg, HWND hwnd )
-{
-    return (const char *)NtUserCallHwndParam( hwnd, msg, NtUserSpyGetMsgName );
-}
-
-const char *SPY_GetVKeyName( WPARAM wparam )
-{
-    return (const char *)NtUserCallOneParam( wparam, NtUserSpyGetVKeyName );
-}
-
-void SPY_EnterMessage( INT flag, HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    if (TRACE_ON(message)) NtUserMessageCall( hwnd, msg, wparam, lparam, 0, NtUserSpyEnter, flag );
-}
-
-void SPY_ExitMessage( INT flag, HWND hwnd, UINT msg, LRESULT lreturn, WPARAM wparam, LPARAM lparam )
-{
-    if (TRACE_ON(message)) NtUserMessageCall( hwnd, msg, wparam, lparam, (void *)lreturn,
-                                              NtUserSpyExit, flag );
-}
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index aa3e1565bfa..ab5a3826b90 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -29,6 +29,7 @@
 #include "winreg.h"
 #include "winternl.h"
 #include "hidusage.h"
+#include "wine/gdi_driver.h"
 #include "wine/heap.h"
 
 #define GET_WORD(ptr)  (*(const WORD *)(ptr))
@@ -38,6 +39,12 @@
 #define WINE_MOUSE_HANDLE       ((HANDLE)1)
 #define WINE_KEYBOARD_HANDLE    ((HANDLE)2)
 
+struct window_surface;
+
+extern const struct user_driver_funcs *USER_Driver DECLSPEC_HIDDEN;
+
+extern void USER_unload_driver(void) DECLSPEC_HIDDEN;
+
 struct received_message_info;
 
 /* data to store state for A/W mappings of WM_CHAR */
@@ -76,26 +83,29 @@ extern BOOL rawinput_device_get_usages(HANDLE handle, USAGE *usage_page, USAGE *
 extern struct rawinput_thread_data *rawinput_thread_data(void);
 extern void rawinput_update_device_list(void);
 
-extern BOOL post_dde_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, DWORD dest_tid,
-                              DWORD type ) DECLSPEC_HIDDEN;
-extern BOOL process_rawinput_message( MSG *msg, UINT hw_id,
-                                      const struct hardware_msg_data *msg_data ) DECLSPEC_HIDDEN;
-extern BOOL unpack_dde_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lparam,
-                                void **buffer, size_t size ) DECLSPEC_HIDDEN;
-extern void free_cached_data( UINT format, HANDLE handle ) DECLSPEC_HIDDEN;
-extern HANDLE render_synthesized_format( UINT format, UINT from ) DECLSPEC_HIDDEN;
+extern void create_offscreen_window_surface( const RECT *visible_rect, struct window_surface **surface ) DECLSPEC_HIDDEN;
 
 extern void CLIPBOARD_ReleaseOwner( HWND hwnd ) DECLSPEC_HIDDEN;
 extern BOOL FOCUS_MouseActivate( HWND hwnd ) DECLSPEC_HIDDEN;
 extern BOOL set_capture_window( HWND hwnd, UINT gui_flags, HWND *prev_ret ) DECLSPEC_HIDDEN;
 extern HDC get_display_dc(void) DECLSPEC_HIDDEN;
 extern void release_display_dc( HDC hdc ) DECLSPEC_HIDDEN;
+extern void move_window_bits( HWND hwnd, struct window_surface *old_surface,
+                              struct window_surface *new_surface,
+                              const RECT *visible_rect, const RECT *old_visible_rect,
+                              const RECT *window_rect, const RECT *valid_rects ) DECLSPEC_HIDDEN;
+extern void move_window_bits_parent( HWND hwnd, HWND parent, const RECT *window_rect,
+                                     const RECT *valid_rects ) DECLSPEC_HIDDEN;
 extern void wait_graphics_driver_ready(void) DECLSPEC_HIDDEN;
 extern void *get_hook_proc( void *proc, const WCHAR *module, HMODULE *free_module ) DECLSPEC_HIDDEN;
 extern RECT get_virtual_screen_rect(void) DECLSPEC_HIDDEN;
 extern RECT get_primary_monitor_rect(void) DECLSPEC_HIDDEN;
 extern DWORD get_input_codepage( void ) DECLSPEC_HIDDEN;
 extern BOOL map_wparam_AtoW( UINT message, WPARAM *wparam, enum wm_char_mapping mapping ) DECLSPEC_HIDDEN;
+extern NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput, UINT flags ) DECLSPEC_HIDDEN;
+extern LRESULT WINAPI MSG_SendInternalMessageTimeout( DWORD dest_pid, DWORD dest_tid,
+                                                      UINT msg, WPARAM wparam, LPARAM lparam,
+                                                      UINT flags, UINT timeout, PDWORD_PTR res_ptr ) DECLSPEC_HIDDEN;
 extern HPEN SYSCOLOR_GetPen( INT index ) DECLSPEC_HIDDEN;
 extern HBRUSH SYSCOLOR_Get55AABrush(void) DECLSPEC_HIDDEN;
 extern void SYSPARAMS_Init(void) DECLSPEC_HIDDEN;
@@ -105,14 +115,18 @@ extern BOOL USER_IsExitingThread( DWORD tid ) DECLSPEC_HIDDEN;
 typedef LRESULT (*winproc_callback_t)( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp,
                                        LRESULT *result, void *arg );
 
+extern WNDPROC WINPROC_GetProc( WNDPROC proc, BOOL unicode ) DECLSPEC_HIDDEN;
+extern BOOL WINPROC_IsUnicode( WNDPROC proc, BOOL def_val ) DECLSPEC_HIDDEN;
+
 extern LRESULT WINPROC_CallProcAtoW( winproc_callback_t callback, HWND hwnd, UINT msg,
                                      WPARAM wParam, LPARAM lParam, LRESULT *result, void *arg,
                                      enum wm_char_mapping mapping ) DECLSPEC_HIDDEN;
 
 extern INT_PTR WINPROC_CallDlgProcA( DLGPROC func, HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) DECLSPEC_HIDDEN;
 extern INT_PTR WINPROC_CallDlgProcW( DLGPROC func, HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) DECLSPEC_HIDDEN;
+extern BOOL WINPROC_call_window( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam,
+                                 LRESULT *result, BOOL unicode, enum wm_char_mapping mapping ) DECLSPEC_HIDDEN;
 extern void winproc_init(void) DECLSPEC_HIDDEN;
-extern void get_winproc_params( struct win_proc_params *params ) DECLSPEC_HIDDEN;
 
 extern ATOM get_class_info( HINSTANCE instance, const WCHAR *name, WNDCLASSEXW *info,
                             UNICODE_STRING *name_str, BOOL ansi ) DECLSPEC_HIDDEN;
@@ -120,14 +134,18 @@ extern ATOM get_class_info( HINSTANCE instance, const WCHAR *name, WNDCLASSEXW *
 /* kernel callbacks */
 
 BOOL WINAPI User32CallEnumDisplayMonitor( struct enum_display_monitor_params *params, ULONG size );
-BOOL WINAPI User32CallSendAsyncCallback( const struct send_async_params *params, ULONG size );
 BOOL WINAPI User32CallWinEventHook( const struct win_event_hook_params *params, ULONG size );
-BOOL WINAPI User32CallWindowProc( struct win_proc_params *params, ULONG size );
 BOOL WINAPI User32CallWindowsHook( const struct win_hook_params *params, ULONG size );
-BOOL WINAPI User32RegisterBuiltinClasses( const struct win_hook_params *params, ULONG size );
 
 /* message spy definitions */
 
+#define SPY_DISPATCHMESSAGE       0x0100
+#define SPY_SENDMESSAGE           0x0101
+#define SPY_DEFWNDPROC            0x0102
+
+#define SPY_RESULT_OK             0x0001
+#define SPY_RESULT_DEFWND         0x0002
+
 extern const char *SPY_GetMsgName( UINT msg, HWND hWnd ) DECLSPEC_HIDDEN;
 extern const char *SPY_GetVKeyName(WPARAM wParam) DECLSPEC_HIDDEN;
 extern void SPY_EnterMessage( INT iFlag, HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) DECLSPEC_HIDDEN;
diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 9b9dde82561..81eb1c841fe 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -39,6 +39,15 @@ WINE_DEFAULT_DEBUG_CHANNEL(win);
 static DWORD process_layout = ~0u;
 
 
+/***********************************************************************
+ *           alloc_user_handle
+ */
+HANDLE alloc_user_handle( struct user_object *ptr, unsigned int type )
+{
+    return UlongToHandle( NtUserCallTwoParam( (UINT_PTR)ptr, type, NtUserAllocHandle ));
+}
+
+
 /***********************************************************************
  *           get_user_handle_ptr
  */
@@ -58,6 +67,133 @@ void release_user_handle_ptr( void *ptr )
 }
 
 
+/***********************************************************************
+ *           free_user_handle
+ */
+void *free_user_handle( HANDLE handle, unsigned int type )
+{
+    return UlongToHandle( NtUserCallTwoParam( HandleToUlong(handle), type, NtUserFreeHandle ));
+}
+
+
+/***********************************************************************
+ *           create_window_handle
+ *
+ * Create a window handle with the server.
+ */
+static WND *create_window_handle( HWND parent, HWND owner, UNICODE_STRING *name,
+                                  HINSTANCE instance, BOOL unicode,
+                                  DWORD style, DWORD ex_style )
+{
+    WND *win;
+    HWND handle = 0, full_parent = 0, full_owner = 0;
+    struct tagCLASS *class = NULL;
+    int extra_bytes = 0;
+    DPI_AWARENESS awareness = GetAwarenessFromDpiAwarenessContext( GetThreadDpiAwarenessContext() );
+    UINT dpi = 0;
+
+    SERVER_START_REQ( create_window )
+    {
+        req->parent   = wine_server_user_handle( parent );
+        req->owner    = wine_server_user_handle( owner );
+        req->instance = wine_server_client_ptr( instance );
+        req->dpi      = GetDpiForSystem();
+        req->awareness = awareness;
+        req->style    = style;
+        req->ex_style = ex_style;
+        if (!(req->atom = get_int_atom_value( name )) && name->Length)
+            wine_server_add_data( req, name->Buffer, name->Length );
+        if (!wine_server_call_err( req ))
+        {
+            handle      = wine_server_ptr_handle( reply->handle );
+            full_parent = wine_server_ptr_handle( reply->parent );
+            full_owner  = wine_server_ptr_handle( reply->owner );
+            extra_bytes = reply->extra;
+            dpi         = reply->dpi;
+            awareness   = reply->awareness;
+            class       = wine_server_get_ptr( reply->class_ptr );
+        }
+    }
+    SERVER_END_REQ;
+
+    if (!handle)
+    {
+        WARN( "error %d creating window\n", GetLastError() );
+        return NULL;
+    }
+
+    if (!(win = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY,
+                           sizeof(WND) + extra_bytes - sizeof(win->wExtra) )))
+    {
+        SERVER_START_REQ( destroy_window )
+        {
+            req->handle = wine_server_user_handle( handle );
+            wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
+        return NULL;
+    }
+
+    if (!parent)  /* if parent is 0 we don't have a desktop window yet */
+    {
+        struct user_thread_info *thread_info = get_user_thread_info();
+
+        if (name->Buffer == (LPCWSTR)DESKTOP_CLASS_ATOM)
+        {
+            if (!thread_info->top_window) thread_info->top_window = full_parent ? full_parent : handle;
+            else assert( full_parent == thread_info->top_window );
+            if (full_parent && !NtUserCallHwnd( thread_info->top_window, NtUserCreateDesktopWindow ))
+                ERR( "failed to create desktop window\n" );
+            register_builtin_classes();
+        }
+        else  /* HWND_MESSAGE parent */
+        {
+            if (!thread_info->msg_window && !full_parent) thread_info->msg_window = handle;
+        }
+    }
+
+    USER_Lock();
+
+    win->obj.handle = handle;
+    win->obj.type   = NTUSER_OBJ_WINDOW;
+    win->parent     = full_parent;
+    win->owner      = full_owner;
+    win->class      = class;
+    win->winproc    = get_class_winproc( class );
+    win->cbWndExtra = extra_bytes;
+    win->dpi        = dpi;
+    win->dpi_awareness = awareness;
+    NtUserCallTwoParam( HandleToUlong(handle), (UINT_PTR)win, NtUserSetHandlePtr );
+    if (WINPROC_IsUnicode( win->winproc, unicode )) win->flags |= WIN_ISUNICODE;
+    return win;
+}
+
+
+/***********************************************************************
+ *           free_window_handle
+ *
+ * Free a window handle.
+ */
+static void free_window_handle( HWND hwnd )
+{
+    struct user_object *ptr;
+
+    if ((ptr = get_user_handle_ptr( hwnd, NTUSER_OBJ_WINDOW )) && ptr != OBJ_OTHER_PROCESS)
+    {
+        SERVER_START_REQ( destroy_window )
+        {
+            req->handle = wine_server_user_handle( hwnd );
+            wine_server_call( req );
+            NtUserCallTwoParam( HandleToUlong(hwnd), 0, NtUserSetHandlePtr );
+        }
+        SERVER_END_REQ;
+        USER_Unlock();
+        HeapFree( GetProcessHeap(), 0, ptr );
+    }
+}
+
+
 /*******************************************************************
  *           list_window_children
  *
@@ -106,6 +242,22 @@ static HWND *list_window_children( HDESK desktop, HWND hwnd, UNICODE_STRING *cla
 }
 
 
+/*******************************************************************
+ *           send_parent_notify
+ */
+static void send_parent_notify( HWND hwnd, UINT msg )
+{
+    if ((GetWindowLongW( hwnd, GWL_STYLE ) & (WS_CHILD | WS_POPUP)) == WS_CHILD &&
+        !(GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_NOPARENTNOTIFY))
+    {
+        HWND parent = GetParent(hwnd);
+        if (parent && parent != GetDesktopWindow())
+            SendMessageW( parent, WM_PARENTNOTIFY,
+                          MAKEWPARAM( msg, GetWindowLongPtrW( hwnd, GWLP_ID )), (LPARAM)hwnd );
+    }
+}
+
+
 /*******************************************************************
  *           get_hwnd_message_parent
  *
@@ -113,7 +265,7 @@ static HWND *list_window_children( HDESK desktop, HWND hwnd, UNICODE_STRING *cla
  */
 HWND get_hwnd_message_parent(void)
 {
-    struct ntuser_thread_info *thread_info = NtUserGetThreadInfo();
+    struct user_thread_info *thread_info = get_user_thread_info();
 
     if (!thread_info->msg_window) GetDesktopWindow();  /* trigger creation */
     return thread_info->msg_window;
@@ -127,7 +279,7 @@ HWND get_hwnd_message_parent(void)
  */
 BOOL is_desktop_window( HWND hwnd )
 {
-    struct ntuser_thread_info *thread_info = NtUserGetThreadInfo();
+    struct user_thread_info *thread_info = get_user_thread_info();
 
     if (!hwnd) return FALSE;
     if (hwnd == thread_info->top_window) return TRUE;
@@ -142,6 +294,159 @@ BOOL is_desktop_window( HWND hwnd )
 }
 
 
+/*******************************************************************
+ * Off-screen window surface.
+ */
+
+struct offscreen_window_surface
+{
+    struct window_surface header;
+    CRITICAL_SECTION cs;
+    RECT bounds;
+    char *bits;
+    BITMAPINFO info;
+};
+
+static const struct window_surface_funcs offscreen_window_surface_funcs;
+
+static inline void reset_bounds( RECT *bounds )
+{
+    bounds->left = bounds->top = INT_MAX;
+    bounds->right = bounds->bottom = INT_MIN;
+}
+
+static struct offscreen_window_surface *impl_from_window_surface( struct window_surface *base )
+{
+    if (!base || base->funcs != &offscreen_window_surface_funcs) return NULL;
+    return CONTAINING_RECORD( base, struct offscreen_window_surface, header );
+}
+
+static void CDECL offscreen_window_surface_lock( struct window_surface *base )
+{
+    struct offscreen_window_surface *impl = impl_from_window_surface( base );
+    EnterCriticalSection( &impl->cs );
+}
+
+static void CDECL offscreen_window_surface_unlock( struct window_surface *base )
+{
+    struct offscreen_window_surface *impl = impl_from_window_surface( base );
+    LeaveCriticalSection( &impl->cs );
+}
+
+static RECT *CDECL offscreen_window_surface_get_bounds( struct window_surface *base )
+{
+    struct offscreen_window_surface *impl = impl_from_window_surface( base );
+    return &impl->bounds;
+}
+
+static void *CDECL offscreen_window_surface_get_bitmap_info( struct window_surface *base, BITMAPINFO *info )
+{
+    struct offscreen_window_surface *impl = impl_from_window_surface( base );
+    memcpy( info, &impl->info, offsetof( BITMAPINFO, bmiColors[0] ) );
+    return impl->bits;
+}
+
+static void CDECL offscreen_window_surface_set_region( struct window_surface *base, HRGN region )
+{
+}
+
+static void CDECL offscreen_window_surface_flush( struct window_surface *base )
+{
+    struct offscreen_window_surface *impl = impl_from_window_surface( base );
+    base->funcs->lock( base );
+    reset_bounds( &impl->bounds );
+    base->funcs->unlock( base );
+}
+
+static void CDECL offscreen_window_surface_destroy( struct window_surface *base )
+{
+    struct offscreen_window_surface *impl = impl_from_window_surface( base );
+    impl->cs.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection( &impl->cs );
+    free( impl );
+}
+
+static const struct window_surface_funcs offscreen_window_surface_funcs =
+{
+    offscreen_window_surface_lock,
+    offscreen_window_surface_unlock,
+    offscreen_window_surface_get_bitmap_info,
+    offscreen_window_surface_get_bounds,
+    offscreen_window_surface_set_region,
+    offscreen_window_surface_flush,
+    offscreen_window_surface_destroy
+};
+
+void create_offscreen_window_surface( const RECT *visible_rect, struct window_surface **surface )
+{
+    struct offscreen_window_surface *impl;
+    SIZE_T size;
+    RECT surface_rect = *visible_rect;
+
+    TRACE( "visible_rect %s, surface %p.\n", wine_dbgstr_rect( visible_rect ), surface );
+
+    OffsetRect( &surface_rect, -surface_rect.left, -surface_rect.top );
+    surface_rect.right  = (surface_rect.right + 0x1f) & ~0x1f;
+    surface_rect.bottom = (surface_rect.bottom + 0x1f) & ~0x1f;
+
+    /* check that old surface is an offscreen_window_surface, or release it */
+    if ((impl = impl_from_window_surface( *surface )))
+    {
+        /* if the rect didn't change, keep the same surface */
+        if (EqualRect( &surface_rect, &impl->header.rect )) return;
+        window_surface_release( &impl->header );
+    }
+    else if (*surface) window_surface_release( *surface );
+
+    /* create a new window surface */
+    *surface = NULL;
+    size = surface_rect.right * surface_rect.bottom * 4;
+    if (!(impl = calloc(1, offsetof( struct offscreen_window_surface, info.bmiColors[0] ) + size))) return;
+
+    impl->header.funcs = &offscreen_window_surface_funcs;
+    impl->header.ref = 1;
+    impl->header.rect = surface_rect;
+
+    InitializeCriticalSection( &impl->cs );
+    impl->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": surface");
+    reset_bounds( &impl->bounds );
+
+    impl->bits = (char *)&impl->info.bmiColors[0];
+    impl->info.bmiHeader.biSize        = sizeof( impl->info );
+    impl->info.bmiHeader.biWidth       = surface_rect.right;
+    impl->info.bmiHeader.biHeight      = surface_rect.bottom;
+    impl->info.bmiHeader.biPlanes      = 1;
+    impl->info.bmiHeader.biBitCount    = 32;
+    impl->info.bmiHeader.biCompression = BI_RGB;
+    impl->info.bmiHeader.biSizeImage   = size;
+
+    TRACE( "created window surface %p\n", &impl->header );
+
+    *surface = &impl->header;
+}
+
+/*******************************************************************
+ *           register_window_surface
+ *
+ * Register a window surface in the global list, possibly replacing another one.
+ */
+void register_window_surface( struct window_surface *old, struct window_surface *new )
+{
+    NtUserCallTwoParam( (UINT_PTR)old, (UINT_PTR)new, NtUserRegisterWindowSurface );
+}
+
+
+/*******************************************************************
+ *           flush_window_surfaces
+ *
+ * Flush pending output from all window surfaces.
+ */
+void flush_window_surfaces( BOOL idle )
+{
+    NtUserCallOneParam( idle, NtUserFlushWindowSurfaces );
+}
+
+
 /***********************************************************************
  *           WIN_GetPtr
  *
@@ -402,6 +707,66 @@ other_process:
 }
 
 
+/***********************************************************************
+ *           WIN_FixCoordinates
+ *
+ * Fix the coordinates - Helper for WIN_CreateWindowEx.
+ * returns default show mode in sw.
+ */
+static void WIN_FixCoordinates( CREATESTRUCTW *cs, INT *sw)
+{
+#define IS_DEFAULT(x)  ((x) == CW_USEDEFAULT || (x) == (SHORT)0x8000)
+    if (cs->style & (WS_CHILD | WS_POPUP))
+    {
+        if (IS_DEFAULT(cs->x)) cs->x = cs->y = 0;
+        if (IS_DEFAULT(cs->cx)) cs->cx = cs->cy = 0;
+    }
+    else  /* overlapped window */
+    {
+        HMONITOR monitor;
+        MONITORINFO mon_info;
+        STARTUPINFOW info;
+
+        if (!IS_DEFAULT(cs->x) && !IS_DEFAULT(cs->cx) && !IS_DEFAULT(cs->cy)) return;
+
+        monitor = MonitorFromWindow( cs->hwndParent, MONITOR_DEFAULTTOPRIMARY );
+        mon_info.cbSize = sizeof(mon_info);
+        GetMonitorInfoW( monitor, &mon_info );
+        GetStartupInfoW( &info );
+
+        if (IS_DEFAULT(cs->x))
+        {
+            if (!IS_DEFAULT(cs->y)) *sw = cs->y;
+            cs->x = (info.dwFlags & STARTF_USEPOSITION) ? info.dwX : mon_info.rcWork.left;
+            cs->y = (info.dwFlags & STARTF_USEPOSITION) ? info.dwY : mon_info.rcWork.top;
+        }
+
+        if (IS_DEFAULT(cs->cx))
+        {
+            if (info.dwFlags & STARTF_USESIZE)
+            {
+                cs->cx = info.dwXSize;
+                cs->cy = info.dwYSize;
+            }
+            else
+            {
+                cs->cx = (mon_info.rcWork.right - mon_info.rcWork.left) * 3 / 4 - cs->x;
+                cs->cy = (mon_info.rcWork.bottom - mon_info.rcWork.top) * 3 / 4 - cs->y;
+            }
+        }
+        /* neither x nor cx are default. Check the y values .
+         * In the trace we see Outlook and Outlook Express using
+         * cy set to CW_USEDEFAULT when opening the address book.
+         */
+        else if (IS_DEFAULT(cs->cy))
+        {
+            FIXME("Strange use of CW_USEDEFAULT in nHeight\n");
+            cs->cy = (mon_info.rcWork.bottom - mon_info.rcWork.top) * 3 / 4 - cs->y;
+        }
+    }
+#undef IS_DEFAULT
+}
+
 /***********************************************************************
  *           dump_window_styles
  */
@@ -520,6 +885,40 @@ static BOOL is_default_coord( int x )
     return x == CW_USEDEFAULT || x == 0x8000;
 }
 
+/***********************************************************************
+ *           map_dpi_create_struct
+ */
+static void map_dpi_create_struct( CREATESTRUCTW *cs, UINT dpi_from, UINT dpi_to )
+{
+    if (!dpi_from && !dpi_to) return;
+    if (!dpi_from || !dpi_to)
+    {
+        POINT pt = { cs->x, cs->y };
+        UINT mon_dpi = get_monitor_dpi( MonitorFromPoint( pt, MONITOR_DEFAULTTONEAREST ));
+        if (!dpi_from) dpi_from = mon_dpi;
+        else dpi_to = mon_dpi;
+    }
+    if (dpi_from == dpi_to) return;
+    cs->x = MulDiv( cs->x, dpi_to, dpi_from );
+    cs->y = MulDiv( cs->y, dpi_to, dpi_from );
+    cs->cx = MulDiv( cs->cx, dpi_to, dpi_from );
+    cs->cy = MulDiv( cs->cy, dpi_to, dpi_from );
+}
+
+/***********************************************************************
+ *           fix_exstyle
+ */
+static DWORD fix_exstyle( DWORD style, DWORD exstyle )
+{
+    if ((exstyle & WS_EX_DLGMODALFRAME) ||
+            (!(exstyle & WS_EX_STATICEDGE) &&
+             (style & (WS_DLGFRAME | WS_THICKFRAME))))
+        exstyle |= WS_EX_WINDOWEDGE;
+    else
+        exstyle &= ~WS_EX_WINDOWEDGE;
+    return exstyle;
+}
+
 /***********************************************************************
  *           WIN_CreateWindowEx
  *
@@ -527,14 +926,19 @@ static BOOL is_default_coord( int x )
  */
 HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module, BOOL unicode )
 {
-    HWND hwnd, top_child = 0;
+    INT cx, cy, style, ex_style, sw = SW_SHOW;
+    LRESULT result;
+    RECT rect;
+    WND *wndPtr;
+    HWND hwnd, parent, owner, top_child = 0;
+    UINT win_dpi, thread_dpi = get_thread_dpi();
+    DPI_AWARENESS_CONTEXT context;
     MDICREATESTRUCTW mdi_cs;
     UNICODE_STRING class;
     CBT_CREATEWNDW cbtc;
-    WNDCLASSEXW info;
-    HMENU menu;
+    CREATESTRUCTW cbcs;
 
-    if (!get_class_info( module, className, &info, &class, FALSE )) return FALSE;
+    if (!get_class_info( module, className, NULL, &class, FALSE )) return FALSE;
 
     TRACE("%s %s%s%s ex=%08lx style=%08lx %d,%d %dx%d parent=%p menu=%p inst=%p params=%p\n",
           unicode ? debugstr_w(cs->lpszName) : debugstr_a((LPCSTR)cs->lpszName),
@@ -626,25 +1030,300 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
         }
     }
 
-    /* FIXME: move to win32u */
-    if (!cs->hwndParent && className != (const WCHAR *)DESKTOP_CLASS_ATOM &&
-        (IS_INTRESOURCE(className) || wcsicmp( className, L"Message" )))
+    /* Find the parent window */
+
+    parent = cs->hwndParent;
+    owner = 0;
+
+    if (cs->hwndParent == HWND_MESSAGE)
+    {
+        cs->hwndParent = parent = get_hwnd_message_parent();
+    }
+    else if (cs->hwndParent)
+    {
+        if ((cs->style & (WS_CHILD|WS_POPUP)) != WS_CHILD)
+        {
+            parent = GetDesktopWindow();
+            owner = cs->hwndParent;
+        }
+        else
+        {
+            DWORD parent_style = GetWindowLongW( parent, GWL_EXSTYLE );
+            if ((parent_style & WS_EX_LAYOUTRTL) && !(parent_style & WS_EX_NOINHERITLAYOUT))
+                cs->dwExStyle |= WS_EX_LAYOUTRTL;
+        }
+    }
+    else
+    {
+        if ((cs->style & (WS_CHILD|WS_POPUP)) == WS_CHILD)
+        {
+            WARN("No parent for child window\n" );
+            SetLastError(ERROR_TLW_WITH_WSCHILD);
+            return 0;  /* WS_CHILD needs a parent, but WS_POPUP doesn't */
+        }
+
+        /* are we creating the desktop or HWND_MESSAGE parent itself? */
+        if (className != (LPCWSTR)DESKTOP_CLASS_ATOM &&
+            (IS_INTRESOURCE(className) || wcsicmp( className, L"Message" )))
+        {
+            DWORD layout;
+            GetProcessDefaultLayout( &layout );
+            if (layout & LAYOUT_RTL) cs->dwExStyle |= WS_EX_LAYOUTRTL;
+            parent = GetDesktopWindow();
+        }
+    }
+
+    WIN_FixCoordinates(cs, &sw); /* fix default coordinates */
+    cs->dwExStyle = fix_exstyle(cs->style, cs->dwExStyle);
+
+    /* Create the window structure */
+
+    style = cs->style & ~WS_VISIBLE;
+    ex_style = cs->dwExStyle & ~WS_EX_LAYERED;
+    if (!(wndPtr = create_window_handle( parent, owner, &class, module,
+                                         unicode, style, ex_style )))
+        return 0;
+    hwnd = wndPtr->obj.handle;
+
+    /* Fill the window structure */
+
+    wndPtr->tid            = GetCurrentThreadId();
+    wndPtr->hInstance      = cs->hInstance;
+    wndPtr->text           = NULL;
+    wndPtr->dwStyle        = style;
+    wndPtr->dwExStyle      = ex_style;
+    wndPtr->wIDmenu        = 0;
+    wndPtr->helpContext    = 0;
+    wndPtr->pScroll        = NULL;
+    wndPtr->userdata       = 0;
+    wndPtr->hIcon          = 0;
+    wndPtr->hIconSmall     = 0;
+    wndPtr->hIconSmall2    = 0;
+    wndPtr->hSysMenu       = 0;
+
+    wndPtr->min_pos.x = wndPtr->min_pos.y = -1;
+    wndPtr->max_pos.x = wndPtr->max_pos.y = -1;
+    SetRect( &wndPtr->normal_rect, cs->x, cs->y, cs->x + cs->cx, cs->y + cs->cy );
+
+    if (wndPtr->dwStyle & WS_SYSMENU) SetSystemMenu( hwnd, 0 );
+
+    /* call the WH_CBT hook */
+
+    WIN_ReleasePtr( wndPtr );
+    cbcs = *cs;
+    cbtc.lpcs = &cbcs;
+    cbtc.hwndInsertAfter = HWND_TOP;
+    if (HOOK_CallHooks( WH_CBT, HCBT_CREATEWND, (WPARAM)hwnd, (LPARAM)&cbtc, unicode ) ||
+            !(wndPtr = WIN_GetPtr( hwnd )))
+    {
+        free_window_handle( hwnd );
+        return 0;
+    }
+
+    /*
+     * Correct the window styles.
+     *
+     * It affects only the style loaded into the WIN structure.
+     */
+
+    if ((wndPtr->dwStyle & (WS_CHILD | WS_POPUP)) != WS_CHILD)
+    {
+        wndPtr->dwStyle |= WS_CLIPSIBLINGS;
+        if (!(wndPtr->dwStyle & WS_POPUP))
+            wndPtr->dwStyle |= WS_CAPTION;
+    }
+
+    wndPtr->dwExStyle = cs->dwExStyle;
+    /* WS_EX_WINDOWEDGE depends on some other styles */
+    if ((wndPtr->dwStyle & (WS_DLGFRAME | WS_THICKFRAME)) &&
+            !(wndPtr->dwStyle & (WS_CHILD | WS_POPUP)))
+        wndPtr->dwExStyle |= WS_EX_WINDOWEDGE;
+
+    if (!(wndPtr->dwStyle & (WS_CHILD | WS_POPUP)))
+        wndPtr->flags |= WIN_NEED_SIZE;
+
+    SERVER_START_REQ( set_window_info )
+    {
+        req->handle    = wine_server_user_handle( hwnd );
+        req->flags     = SET_WIN_STYLE | SET_WIN_EXSTYLE | SET_WIN_INSTANCE | SET_WIN_UNICODE;
+        req->style     = wndPtr->dwStyle;
+        req->ex_style  = wndPtr->dwExStyle;
+        req->instance  = wine_server_client_ptr( wndPtr->hInstance );
+        req->is_unicode = (wndPtr->flags & WIN_ISUNICODE) != 0;
+        req->extra_offset = -1;
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+
+    /* Set the window menu */
+
+    if ((wndPtr->dwStyle & (WS_CHILD | WS_POPUP)) != WS_CHILD)
+    {
+        if (cs->hMenu)
+        {
+            if (!MENU_SetMenu(hwnd, cs->hMenu))
+            {
+                WIN_ReleasePtr( wndPtr );
+                free_window_handle( hwnd );
+                return 0;
+            }
+        }
+        else
+        {
+            LPCWSTR menuName = (LPCWSTR)GetClassLongPtrW( hwnd, GCLP_MENUNAME );
+            if (menuName)
+            {
+                cs->hMenu = LoadMenuW( cs->hInstance, menuName );
+                if (cs->hMenu) MENU_SetMenu( hwnd, cs->hMenu );
+            }
+        }
+    }
+    else SetWindowLongPtrW( hwnd, GWLP_ID, (ULONG_PTR)cs->hMenu );
+
+    win_dpi = wndPtr->dpi;
+    WIN_ReleasePtr( wndPtr );
+
+    if (parent) map_dpi_create_struct( cs, thread_dpi, win_dpi );
+
+    context = SetThreadDpiAwarenessContext( GetWindowDpiAwarenessContext( hwnd ));
+
+    /* send the WM_GETMINMAXINFO message and fix the size if needed */
+
+    cx = cs->cx;
+    cy = cs->cy;
+    if ((cs->style & WS_THICKFRAME) || !(cs->style & (WS_POPUP | WS_CHILD)))
+    {
+        MINMAXINFO info = WINPOS_GetMinMaxInfo( hwnd );
+        cx = max( min( cx, info.ptMaxTrackSize.x ), info.ptMinTrackSize.x );
+        cy = max( min( cy, info.ptMaxTrackSize.y ), info.ptMinTrackSize.y );
+    }
+
+    if (cx < 0) cx = 0;
+    if (cy < 0) cy = 0;
+    SetRect( &rect, cs->x, cs->y, cs->x + cx, cs->y + cy );
+    /* check for wraparound */
+    if (cs->x > 0x7fffffff - cx) rect.right = 0x7fffffff;
+    if (cs->y > 0x7fffffff - cy) rect.bottom = 0x7fffffff;
+    if (!set_window_pos( hwnd, 0, SWP_NOZORDER | SWP_NOACTIVATE, &rect, &rect, NULL )) goto failed;
+
+    /* send WM_NCCREATE */
+
+    TRACE( "hwnd %p cs %d,%d %dx%d %s\n", hwnd, cs->x, cs->y, cs->cx, cs->cy, wine_dbgstr_rect(&rect) );
+    if (unicode)
+        result = SendMessageW( hwnd, WM_NCCREATE, 0, (LPARAM)cs );
+    else
+        result = SendMessageA( hwnd, WM_NCCREATE, 0, (LPARAM)cs );
+    if (!result)
+    {
+        WARN( "%p: aborted by WM_NCCREATE\n", hwnd );
+        goto failed;
+    }
+
+    /* create default IME window */
+
+    if (imm_register_window && !is_desktop_window( hwnd ) &&
+        parent != get_hwnd_message_parent() && imm_register_window( hwnd ))
+    {
+        TRACE("register IME window for %p\n", hwnd);
+        win_set_flags( hwnd, WIN_HAS_IME_WIN, 0 );
+    }
+
+    /* send WM_NCCALCSIZE */
+
+    if (WIN_GetRectangles( hwnd, COORDS_PARENT, &rect, NULL ))
+    {
+        /* yes, even if the CBT hook was called with HWND_TOP */
+        HWND insert_after = (GetWindowLongW( hwnd, GWL_STYLE ) & WS_CHILD) ? HWND_BOTTOM : HWND_TOP;
+        RECT client_rect = rect;
+
+        /* the rectangle is in screen coords for WM_NCCALCSIZE when wparam is FALSE */
+        MapWindowPoints( parent, 0, (POINT *)&client_rect, 2 );
+        SendMessageW( hwnd, WM_NCCALCSIZE, FALSE, (LPARAM)&client_rect );
+        MapWindowPoints( 0, parent, (POINT *)&client_rect, 2 );
+        set_window_pos( hwnd, insert_after, SWP_NOACTIVATE, &rect, &client_rect, NULL );
+    }
+    else goto failed;
+
+    /* send WM_CREATE */
+
+    if (unicode)
+        result = SendMessageW( hwnd, WM_CREATE, 0, (LPARAM)cs );
+    else
+        result = SendMessageA( hwnd, WM_CREATE, 0, (LPARAM)cs );
+    if (result == -1) goto failed;
+
+    /* call the driver */
+
+    if (!USER_Driver->pCreateWindow( hwnd )) goto failed;
+
+    NtUserNotifyWinEvent( EVENT_OBJECT_CREATE, hwnd, OBJID_WINDOW, 0 );
+
+    /* send the size messages */
+
+    if (!(win_get_flags( hwnd ) & WIN_NEED_SIZE))
+    {
+        WIN_GetRectangles( hwnd, COORDS_PARENT, NULL, &rect );
+        SendMessageW( hwnd, WM_SIZE, SIZE_RESTORED,
+                      MAKELONG(rect.right-rect.left, rect.bottom-rect.top));
+        SendMessageW( hwnd, WM_MOVE, 0, MAKELONG( rect.left, rect.top ) );
+    }
+
+    /* Show the window, maximizing or minimizing if needed */
+
+    style = WIN_SetStyle( hwnd, 0, WS_MAXIMIZE | WS_MINIMIZE );
+    if (style & (WS_MINIMIZE | WS_MAXIMIZE))
     {
-        DWORD layout;
-        GetProcessDefaultLayout( &layout );
-        if (layout & LAYOUT_RTL) cs->dwExStyle |= WS_EX_LAYOUTRTL;
+        RECT newPos;
+        UINT swFlag = (style & WS_MINIMIZE) ? SW_MINIMIZE : SW_MAXIMIZE;
+
+        swFlag = WINPOS_MinMaximize( hwnd, swFlag, &newPos );
+        swFlag |= SWP_FRAMECHANGED; /* Frame always gets changed */
+        if (!(style & WS_VISIBLE) || (style & WS_CHILD) || GetActiveWindow()) swFlag |= SWP_NOACTIVATE;
+        NtUserSetWindowPos( hwnd, 0, newPos.left, newPos.top, newPos.right - newPos.left,
+                            newPos.bottom - newPos.top, swFlag );
     }
 
-    menu = cs->hMenu;
-    if (!menu && info.lpszMenuName && (cs->style & (WS_CHILD | WS_POPUP)) != WS_CHILD)
-        menu = LoadMenuW( cs->hInstance, info.lpszMenuName );
+    /* Notify the parent window only */
 
-    cbtc.lpcs = cs;
-    hwnd = NtUserCreateWindowEx( cs->dwExStyle, &class, NULL, NULL, cs->style, cs->x, cs->y,
-                                 cs->cx, cs->cy, cs->hwndParent, menu, module,
-                                 cs->lpCreateParams, 0, &cbtc, 0, !unicode );
-    if (!hwnd && menu && menu != cs->hMenu) NtUserDestroyMenu( menu );
+    send_parent_notify( hwnd, WM_CREATE );
+    if (!IsWindow( hwnd ))
+    {
+        SetThreadDpiAwarenessContext( context );
+        return 0;
+    }
+
+    if (parent == GetDesktopWindow())
+        PostMessageW( parent, WM_PARENTNOTIFY, WM_CREATE, (LPARAM)hwnd );
+
+    if (cs->style & WS_VISIBLE)
+    {
+        if (cs->style & WS_MAXIMIZE)
+            sw = SW_SHOW;
+        else if (cs->style & WS_MINIMIZE)
+            sw = SW_SHOWMINIMIZED;
+
+        NtUserShowWindow( hwnd, sw );
+        if (cs->dwExStyle & WS_EX_MDICHILD)
+        {
+            SendMessageW(cs->hwndParent, WM_MDIREFRESHMENU, 0, 0);
+            /* ShowWindow won't activate child windows */
+            NtUserSetWindowPos( hwnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE );
+        }
+    }
+
+    /* Call WH_SHELL hook */
+
+    if (!(GetWindowLongW( hwnd, GWL_STYLE ) & WS_CHILD) && !GetWindow( hwnd, GW_OWNER ))
+        HOOK_CallHooks( WH_SHELL, HSHELL_WINDOWCREATED, (WPARAM)hwnd, 0, TRUE );
+
+    TRACE("created window %p\n", hwnd);
+    SetThreadDpiAwarenessContext( context );
     return hwnd;
+
+failed:
+    NtUserCallHwnd( hwnd, NtUserDestroyWindowHandle );
+    SetThreadDpiAwarenessContext( context );
+    return 0;
 }
 
 
@@ -738,24 +1417,65 @@ BOOL WINAPI OpenIcon( HWND hwnd )
 /***********************************************************************
  *		FindWindowExW (USER32.@)
  */
-HWND WINAPI FindWindowExW( HWND parent, HWND child, const WCHAR *class, const WCHAR *title )
+HWND WINAPI FindWindowExW( HWND parent, HWND child, LPCWSTR className, LPCWSTR title )
 {
-    UNICODE_STRING class_str, title_str;
+    HWND *list;
+    HWND retvalue = 0;
+    int i = 0, len = 0;
+    WCHAR *buffer = NULL;
 
-    if (title) RtlInitUnicodeString( &title_str, title );
+    if (!parent && child) parent = GetDesktopWindow();
+    else if (parent == HWND_MESSAGE) parent = get_hwnd_message_parent();
 
-    if (class)
+    if (title)
     {
-        if (IS_INTRESOURCE(class))
+        len = lstrlenW(title) + 1;  /* one extra char to check for chars beyond the end */
+        if (!(buffer = HeapAlloc( GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR) ))) return 0;
+    }
+
+    if (className)
+    {
+        UNICODE_STRING str;
+        if (IS_INTRESOURCE(className))
         {
-            class_str.Buffer = (WCHAR *)class;
-            class_str.Length = class_str.MaximumLength = 0;
+            str.Buffer = (WCHAR *)className;
+            str.Length = str.MaximumLength = 0;
         }
-        else RtlInitUnicodeString( &class_str, class );
+        else RtlInitUnicodeString( &str, className );
+        list = list_window_children( 0, parent, &str, 0 );
+    }
+    else list = list_window_children( 0, parent, NULL, 0 );
+    if (!list) goto done;
+
+    if (child)
+    {
+        child = WIN_GetFullHandle( child );
+        while (list[i] && list[i] != child) i++;
+        if (!list[i]) goto done;
+        i++;  /* start from next window */
     }
 
-    return NtUserFindWindowEx( parent, child, class ? &class_str : NULL,
-                               title ? &title_str : NULL, 0 );
+    if (title)
+    {
+        while (list[i])
+        {
+            if (NtUserInternalGetWindowText( list[i], buffer, len + 1 ))
+            {
+                if (!wcsicmp( buffer, title )) break;
+            }
+            else
+            {
+                if (!title[0]) break;
+            }
+            i++;
+        }
+    }
+    retvalue = list[i];
+
+ done:
+    HeapFree( GetProcessHeap(), 0, list );
+    HeapFree( GetProcessHeap(), 0, buffer );
+    return retvalue;
 }
 
 
@@ -816,10 +1536,10 @@ HWND WINAPI FindWindowW( LPCWSTR className, LPCWSTR title )
  */
 HWND WINAPI GetDesktopWindow(void)
 {
-    struct ntuser_thread_info *thread_info = NtUserGetThreadInfo();
+    struct user_thread_info *thread_info = get_user_thread_info();
 
     if (thread_info->top_window) return thread_info->top_window;
-    return NtUserGetDesktopWindow();
+    return UlongToHandle( NtUserCallNoParam( NtUserGetDesktopWindow ));
 }
 
 
@@ -828,16 +1548,49 @@ HWND WINAPI GetDesktopWindow(void)
  */
 BOOL WINAPI EnableWindow( HWND hwnd, BOOL enable )
 {
-    return NtUserEnableWindow( hwnd, enable );
+    BOOL retvalue;
+
+    if (is_broadcast(hwnd))
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
+
+    TRACE("( %p, %d )\n", hwnd, enable);
+
+    if (enable)
+    {
+        retvalue = (WIN_SetStyle( hwnd, 0, WS_DISABLED ) & WS_DISABLED) != 0;
+        if (retvalue) SendMessageW( hwnd, WM_ENABLE, TRUE, 0 );
+    }
+    else
+    {
+        SendMessageW( hwnd, WM_CANCELMODE, 0, 0 );
+
+        retvalue = (WIN_SetStyle( hwnd, WS_DISABLED, 0 ) & WS_DISABLED) != 0;
+        if (!retvalue)
+        {
+            if (hwnd == GetFocus())
+                NtUserSetFocus( 0 ); /* A disabled window can't have the focus */
+
+            SendMessageW( hwnd, WM_ENABLE, FALSE, 0 );
+        }
+    }
+    return retvalue;
 }
 
 
 /***********************************************************************
  *		IsWindowEnabled (USER32.@)
  */
-BOOL WINAPI IsWindowEnabled( HWND hwnd )
+BOOL WINAPI IsWindowEnabled(HWND hWnd)
 {
-    return NtUserIsWindowEnabled( hwnd );
+    LONG ret;
+
+    SetLastError(NO_ERROR);
+    ret = GetWindowLongW( hWnd, GWL_STYLE );
+    if (!ret && GetLastError() != NO_ERROR) return FALSE;
+    return !(ret & WS_DISABLED);
 }
 
 /***********************************************************************
@@ -845,7 +1598,7 @@ BOOL WINAPI IsWindowEnabled( HWND hwnd )
  */
 BOOL WINAPI IsWindowUnicode( HWND hwnd )
 {
-    return NtUserIsWindowUnicode( hwnd );
+    return NtUserCallHwnd( hwnd, NtUserIsWindowUnicode );
 }
 
 
@@ -854,7 +1607,7 @@ BOOL WINAPI IsWindowUnicode( HWND hwnd )
  */
 DPI_AWARENESS_CONTEXT WINAPI GetWindowDpiAwarenessContext( HWND hwnd )
 {
-    return NtUserGetWindowDpiAwarenessContext( hwnd );
+    return (DPI_AWARENESS_CONTEXT)NtUserCallHwnd( hwnd, NtUserGetWindowDpiAwarenessContext );
 }
 
 
@@ -863,7 +1616,7 @@ DPI_AWARENESS_CONTEXT WINAPI GetWindowDpiAwarenessContext( HWND hwnd )
  */
 UINT WINAPI GetDpiForWindow( HWND hwnd )
 {
-    return NtUserGetDpiForWindow( hwnd );
+    return NtUserCallHwnd( hwnd, NtUserGetDpiForWindow );
 }
 
 
@@ -872,7 +1625,7 @@ UINT WINAPI GetDpiForWindow( HWND hwnd )
  */
 WORD WINAPI GetWindowWord( HWND hwnd, INT offset )
 {
-    return NtUserGetWindowWord( hwnd, offset );
+    return NtUserCallHwndParam( hwnd, offset, NtUserGetWindowWord );
 }
 
 
@@ -892,7 +1645,7 @@ LONG WINAPI GetWindowLongA( HWND hwnd, INT offset )
         return 0;
 #endif
     default:
-        return NtUserGetWindowLongA( hwnd, offset );
+        return NtUserCallHwndParam( hwnd, offset, NtUserGetWindowLongA );
     }
 }
 
@@ -913,7 +1666,7 @@ LONG WINAPI GetWindowLongW( HWND hwnd, INT offset )
         return 0;
 #endif
     default:
-        return NtUserGetWindowLongW( hwnd, offset );
+        return NtUserCallHwndParam( hwnd, offset, NtUserGetWindowLongW );
     }
 }
 
@@ -1146,7 +1899,7 @@ INT WINAPI GetWindowTextLengthA( HWND hwnd )
 
     /* when window belongs to other process, don't send a message */
     GetCPInfo( CP_ACP, &info );
-    return NtUserGetWindowTextLength( hwnd ) * info.MaxCharSize;
+    return NtUserCallHwnd( hwnd, NtUserGetWindowTextLength ) * info.MaxCharSize;
 }
 
 /*******************************************************************
@@ -1157,7 +1910,7 @@ INT WINAPI GetWindowTextLengthW( HWND hwnd )
     if (WIN_IsCurrentProcess( hwnd )) return SendMessageW( hwnd, WM_GETTEXTLENGTH, 0, 0 );
 
     /* when window belongs to other process, don't send a message */
-    return NtUserGetWindowTextLength( hwnd );
+    return NtUserCallHwnd( hwnd, NtUserGetWindowTextLength );
 }
 
 
@@ -1166,7 +1919,7 @@ INT WINAPI GetWindowTextLengthW( HWND hwnd )
  */
 BOOL WINAPI IsWindow( HWND hwnd )
 {
-    return NtUserIsWindow( hwnd );
+    return NtUserCallHwnd( hwnd, NtUserIsWindow );
 }
 
 
@@ -1175,7 +1928,7 @@ BOOL WINAPI IsWindow( HWND hwnd )
  */
 DWORD WINAPI GetWindowThreadProcessId( HWND hwnd, LPDWORD process )
 {
-    return NtUserGetWindowThread( hwnd, process );
+    return NtUserCallHwndParam( hwnd, (UINT_PTR)process, NtUserGetWindowThread );
 }
 
 
@@ -1184,7 +1937,7 @@ DWORD WINAPI GetWindowThreadProcessId( HWND hwnd, LPDWORD process )
  */
 HWND WINAPI GetParent( HWND hwnd )
 {
-    return NtUserGetParent( hwnd );
+    return UlongToHandle( NtUserCallHwnd( hwnd, NtUserGetParent ));
 }
 
 
@@ -1193,7 +1946,7 @@ HWND WINAPI GetParent( HWND hwnd )
  */
 BOOL WINAPI IsChild( HWND parent, HWND child )
 {
-    return NtUserIsChild( parent, child );
+    return NtUserCallHwndParam( parent, HandleToUlong(child), NtUserIsChild );
 }
 
 
@@ -1202,7 +1955,7 @@ BOOL WINAPI IsChild( HWND parent, HWND child )
  */
 BOOL WINAPI IsWindowVisible( HWND hwnd )
 {
-    return NtUserIsWindowVisible( hwnd );
+    return NtUserCallHwnd( hwnd, NtUserIsWindowVisible );
 }
 
 
@@ -1235,16 +1988,45 @@ HWND WINAPI GetTopWindow( HWND hwnd )
  */
 HWND WINAPI GetWindow( HWND hwnd, UINT rel )
 {
-    return NtUserGetWindowRelative( hwnd, rel );
+    return UlongToHandle( NtUserCallHwndParam( hwnd, rel, NtUserGetWindowRelative ));
 }
 
 
 /*******************************************************************
  *		ShowOwnedPopups (USER32.@)
  */
-BOOL WINAPI ShowOwnedPopups( HWND owner, BOOL show )
+BOOL WINAPI ShowOwnedPopups( HWND owner, BOOL fShow )
 {
-    return NtUserShowOwnedPopups( owner, show );
+    int count = 0;
+    HWND *win_array = WIN_ListChildren( GetDesktopWindow() );
+
+    if (!win_array) return TRUE;
+
+    while (win_array[count]) count++;
+    while (--count >= 0)
+    {
+        if (GetWindow( win_array[count], GW_OWNER ) != owner) continue;
+        if (fShow)
+        {
+            if (win_get_flags( win_array[count] ) & WIN_NEEDS_SHOW_OWNEDPOPUP)
+                /* In Windows, ShowOwnedPopups(TRUE) generates
+                 * WM_SHOWWINDOW messages with SW_PARENTOPENING,
+                 * regardless of the state of the owner
+                 */
+                SendMessageW(win_array[count], WM_SHOWWINDOW, SW_SHOWNORMAL, SW_PARENTOPENING);
+        }
+        else
+        {
+            if (GetWindowLongW( win_array[count], GWL_STYLE ) & WS_VISIBLE)
+                /* In Windows, ShowOwnedPopups(FALSE) generates
+                 * WM_SHOWWINDOW messages with SW_PARENTCLOSING,
+                 * regardless of the state of the owner
+                 */
+                SendMessageW(win_array[count], WM_SHOWWINDOW, SW_HIDE, SW_PARENTCLOSING);
+        }
+    }
+    HeapFree( GetProcessHeap(), 0, win_array );
+    return TRUE;
 }
 
 
@@ -1466,7 +2248,7 @@ BOOL WINAPI FlashWindow( HWND hWnd, BOOL bInvert )
  */
 DWORD WINAPI GetWindowContextHelpId( HWND hwnd )
 {
-    return NtUserGetWindowContextHelpId( hwnd );
+    return NtUserCallHwnd( hwnd, NtUserGetWindowContextHelpId );
 }
 
 
@@ -1585,7 +2367,7 @@ UINT WINAPI GetWindowModuleFileNameW( HWND hwnd, LPWSTR module, UINT size )
  */
 BOOL WINAPI DECLSPEC_HOTPATCH GetWindowInfo( HWND hwnd, WINDOWINFO *info )
 {
-    return NtUserGetWindowInfo( hwnd, info );
+    return NtUserCallHwndParam( hwnd, (UINT_PTR)info, NtUserGetWindowInfo );
 }
 
 /******************************************************************************
@@ -1600,6 +2382,15 @@ BOOL WINAPI SwitchDesktop( HDESK hDesktop)
 }
 
 
+/***********************************************************************
+ *           __wine_set_pixel_format
+ */
+BOOL CDECL __wine_set_pixel_format( HWND hwnd, int format )
+{
+    return NtUserCallHwndParam( hwnd, format, NtUserSetWindowPixelFormat );
+}
+
+
 /*****************************************************************************
  *              UpdateLayeredWindowIndirect  (USER32.@)
  */
@@ -1719,7 +2510,7 @@ BOOL WINAPI SetProcessDefaultLayout( DWORD layout )
  */
 LONG_PTR WINAPI GetWindowLongPtrW( HWND hwnd, INT offset )
 {
-    return NtUserGetWindowLongPtrW( hwnd, offset );
+    return NtUserCallHwndParam( hwnd, offset, NtUserGetWindowLongPtrW );
 }
 
 /*****************************************************************************
@@ -1727,7 +2518,7 @@ LONG_PTR WINAPI GetWindowLongPtrW( HWND hwnd, INT offset )
  */
 LONG_PTR WINAPI GetWindowLongPtrA( HWND hwnd, INT offset )
 {
-    return NtUserGetWindowLongPtrA( hwnd, offset );
+    return NtUserCallHwndParam( hwnd, offset, NtUserGetWindowLongPtrA );
 }
 
 /*****************************************************************************
diff --git a/dlls/user32/win.h b/dlls/user32/win.h
index dfa5fdf3283..79a57de6bb9 100644
--- a/dlls/user32/win.h
+++ b/dlls/user32/win.h
@@ -36,6 +36,8 @@ struct tagDIALOGINFO;
   /* Window functions */
 extern HWND get_hwnd_message_parent(void) DECLSPEC_HIDDEN;
 extern BOOL is_desktop_window( HWND hwnd ) DECLSPEC_HIDDEN;
+extern void register_window_surface( struct window_surface *old, struct window_surface *new ) DECLSPEC_HIDDEN;
+extern void flush_window_surfaces( BOOL idle ) DECLSPEC_HIDDEN;
 extern WND *WIN_GetPtr( HWND hwnd ) DECLSPEC_HIDDEN;
 extern HWND WIN_GetFullHandle( HWND hwnd ) DECLSPEC_HIDDEN;
 extern HWND WIN_IsCurrentProcess( HWND hwnd ) DECLSPEC_HIDDEN;
@@ -60,7 +62,11 @@ static inline void WIN_ReleasePtr( WND *ptr )
 
 extern LRESULT HOOK_CallHooks( INT id, INT code, WPARAM wparam, LPARAM lparam, BOOL unicode ) DECLSPEC_HIDDEN;
 
+extern MINMAXINFO WINPOS_GetMinMaxInfo( HWND hwnd ) DECLSPEC_HIDDEN;
+extern LONG WINPOS_HandleWindowPosChanging(HWND hwnd, WINDOWPOS *winpos) DECLSPEC_HIDDEN;
+extern HWND WINPOS_WindowFromPoint( HWND hwndScope, POINT pt, INT *hittest ) DECLSPEC_HIDDEN;
 extern void WINPOS_ActivateOtherWindow( HWND hwnd ) DECLSPEC_HIDDEN;
+extern UINT WINPOS_MinMaximize( HWND hwnd, UINT cmd, LPRECT rect ) DECLSPEC_HIDDEN;
 extern void WINPOS_SysCommandSizeMove( HWND hwnd, WPARAM wParam ) DECLSPEC_HIDDEN;
 
 extern UINT get_monitor_dpi( HMONITOR monitor ) DECLSPEC_HIDDEN;
@@ -70,8 +76,14 @@ extern POINT map_dpi_point( POINT pt, UINT dpi_from, UINT dpi_to ) DECLSPEC_HIDD
 extern POINT point_win_to_phys_dpi( HWND hwnd, POINT pt ) DECLSPEC_HIDDEN;
 extern POINT point_phys_to_win_dpi( HWND hwnd, POINT pt ) DECLSPEC_HIDDEN;
 extern POINT point_win_to_thread_dpi( HWND hwnd, POINT pt ) DECLSPEC_HIDDEN;
+extern POINT point_thread_to_win_dpi( HWND hwnd, POINT pt ) DECLSPEC_HIDDEN;
 extern RECT map_dpi_rect( RECT rect, UINT dpi_from, UINT dpi_to ) DECLSPEC_HIDDEN;
 extern RECT rect_win_to_thread_dpi( HWND hwnd, RECT rect ) DECLSPEC_HIDDEN;
+extern RECT rect_thread_to_win_dpi( HWND hwnd, RECT rect ) DECLSPEC_HIDDEN;
+
+extern BOOL set_window_pos( HWND hwnd, HWND insert_after, UINT swp_flags,
+                            const RECT *window_rect, const RECT *client_rect,
+                            const RECT *valid_rects ) DECLSPEC_HIDDEN;
 
 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 {
diff --git a/dlls/user32/winpos.c b/dlls/user32/winpos.c
index d38a3df18da..a3c030cf64b 100644
--- a/dlls/user32/winpos.c
+++ b/dlls/user32/winpos.c
@@ -31,6 +31,19 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(win);
 
+#define SWP_AGG_NOGEOMETRYCHANGE \
+    (SWP_NOSIZE | SWP_NOCLIENTSIZE | SWP_NOZORDER)
+#define SWP_AGG_NOPOSCHANGE \
+    (SWP_NOSIZE | SWP_NOMOVE | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE | SWP_NOZORDER)
+#define SWP_AGG_STATUSFLAGS \
+    (SWP_AGG_NOPOSCHANGE | SWP_FRAMECHANGED | SWP_HIDEWINDOW | SWP_SHOWWINDOW)
+#define SWP_AGG_NOCLIENTCHANGE \
+        (SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)
+
+#define HAS_DLGFRAME(style,exStyle) \
+    (((exStyle) & WS_EX_DLGMODALFRAME) || \
+     (((style) & WS_DLGFRAME) && !((style) & WS_BORDER)))
+
 #define HAS_THICKFRAME(style) \
     (((style) & WS_THICKFRAME) && \
      !(((style) & (WS_DLGFRAME|WS_BORDER)) == WS_DLGFRAME))
@@ -44,6 +57,10 @@ WINE_DEFAULT_DEBUG_CHANNEL(win);
 #define ON_BOTTOM_BORDER(hit) \
  (((hit) == HTBOTTOM) || ((hit) == HTBOTTOMLEFT) || ((hit) == HTBOTTOMRIGHT))
 
+#define PLACE_MIN		0x0001
+#define PLACE_MAX		0x0002
+#define PLACE_RECT		0x0004
+
 
 /***********************************************************************
  *		SwitchToThisWindow (USER32.@)
@@ -60,7 +77,7 @@ void WINAPI SwitchToThisWindow( HWND hwnd, BOOL alt_tab )
  */
 BOOL WINAPI GetWindowRect( HWND hwnd, LPRECT rect )
 {
-    BOOL ret = NtUserGetWindowRect( hwnd, rect );
+    BOOL ret = NtUserCallHwndParam( hwnd, (UINT_PTR)rect, NtUserGetWindowRect );
     if (ret) TRACE( "hwnd %p %s\n", hwnd, wine_dbgstr_rect(rect) );
     return ret;
 }
@@ -101,7 +118,102 @@ int WINAPI GetWindowRgnBox( HWND hwnd, LPRECT prect )
  */
 BOOL WINAPI GetClientRect( HWND hwnd, LPRECT rect )
 {
-    return NtUserGetClientRect( hwnd, rect );
+    return NtUserCallHwndParam( hwnd, (UINT_PTR)rect, NtUserGetClientRect );
+}
+
+
+/***********************************************************************
+ *           list_children_from_point
+ *
+ * Get the list of children that can contain point from the server.
+ * Point is in screen coordinates.
+ * Returned list must be freed by caller.
+ */
+static HWND *list_children_from_point( HWND hwnd, POINT pt )
+{
+    HWND *list;
+    int i, size = 128;
+
+    for (;;)
+    {
+        int count = 0;
+
+        if (!(list = HeapAlloc( GetProcessHeap(), 0, size * sizeof(HWND) ))) break;
+
+        SERVER_START_REQ( get_window_children_from_point )
+        {
+            req->parent = wine_server_user_handle( hwnd );
+            req->x = pt.x;
+            req->y = pt.y;
+            req->dpi = get_thread_dpi();
+            wine_server_set_reply( req, list, (size-1) * sizeof(user_handle_t) );
+            if (!wine_server_call( req )) count = reply->count;
+        }
+        SERVER_END_REQ;
+        if (count && count < size)
+        {
+            /* start from the end since HWND is potentially larger than user_handle_t */
+            for (i = count - 1; i >= 0; i--)
+                list[i] = wine_server_ptr_handle( ((user_handle_t *)list)[i] );
+            list[count] = 0;
+            return list;
+        }
+        HeapFree( GetProcessHeap(), 0, list );
+        if (!count) break;
+        size = count + 1;  /* restart with a large enough buffer */
+    }
+    return NULL;
+}
+
+
+/***********************************************************************
+ *           WINPOS_WindowFromPoint
+ *
+ * Find the window and hittest for a given point.
+ */
+HWND WINPOS_WindowFromPoint( HWND hwndScope, POINT pt, INT *hittest )
+{
+    int i, res;
+    HWND ret, *list;
+    POINT win_pt;
+
+    if (!hwndScope) hwndScope = GetDesktopWindow();
+
+    *hittest = HTNOWHERE;
+
+    if (!(list = list_children_from_point( hwndScope, pt ))) return 0;
+
+    /* now determine the hittest */
+
+    for (i = 0; list[i]; i++)
+    {
+        LONG style = GetWindowLongW( list[i], GWL_STYLE );
+
+        /* If window is minimized or disabled, return at once */
+        if (style & WS_DISABLED)
+        {
+            *hittest = HTERROR;
+            break;
+        }
+        /* Send WM_NCCHITTEST (if same thread) */
+        if (!WIN_IsCurrentThread( list[i] ))
+        {
+            *hittest = HTCLIENT;
+            break;
+        }
+        win_pt = point_thread_to_win_dpi( list[i], pt );
+        res = SendMessageW( list[i], WM_NCHITTEST, 0, MAKELPARAM( win_pt.x, win_pt.y ));
+        if (res != HTTRANSPARENT)
+        {
+            *hittest = res;  /* Found the window */
+            break;
+        }
+        /* continue search with next window in z-order */
+    }
+    ret = list[i];
+    HeapFree( GetProcessHeap(), 0, list );
+    TRACE( "scope %p (%d,%d) returning %p\n", hwndScope, pt.x, pt.y, ret );
+    return ret;
 }
 
 
@@ -117,44 +229,216 @@ HWND WINAPI WindowFromPoint( POINT pt )
 /*******************************************************************
  *		ChildWindowFromPoint (USER32.@)
  */
-HWND WINAPI ChildWindowFromPoint( HWND parent, POINT pt )
+HWND WINAPI ChildWindowFromPoint( HWND hwndParent, POINT pt )
 {
-    return NtUserChildWindowFromPointEx( parent, pt.x, pt.y, CWP_ALL );
+    return ChildWindowFromPointEx( hwndParent, pt, CWP_ALL );
 }
 
 /*******************************************************************
  *		RealChildWindowFromPoint (USER32.@)
  */
-HWND WINAPI RealChildWindowFromPoint( HWND parent, POINT pt )
+HWND WINAPI RealChildWindowFromPoint( HWND hwndParent, POINT pt )
 {
-    return NtUserChildWindowFromPointEx( parent, pt.x, pt.y,
-                                         CWP_SKIPTRANSPARENT | CWP_SKIPINVISIBLE );
+    return ChildWindowFromPointEx( hwndParent, pt, CWP_SKIPTRANSPARENT | CWP_SKIPINVISIBLE );
 }
 
 /*******************************************************************
  *		ChildWindowFromPointEx (USER32.@)
  */
-HWND WINAPI ChildWindowFromPointEx( HWND parent, POINT pt, UINT flags )
+HWND WINAPI ChildWindowFromPointEx( HWND hwndParent, POINT pt, UINT uFlags)
+{
+    /* pt is in the client coordinates */
+    HWND *list;
+    int i;
+    RECT rect;
+    HWND retvalue;
+
+    GetClientRect( hwndParent, &rect );
+    if (!PtInRect( &rect, pt )) return 0;
+    if (!(list = WIN_ListChildren( hwndParent ))) return hwndParent;
+
+    for (i = 0; list[i]; i++)
+    {
+        if (!WIN_GetRectangles( list[i], COORDS_PARENT, &rect, NULL )) continue;
+        if (!PtInRect( &rect, pt )) continue;
+        if (uFlags & (CWP_SKIPINVISIBLE|CWP_SKIPDISABLED))
+        {
+            LONG style = GetWindowLongW( list[i], GWL_STYLE );
+            if ((uFlags & CWP_SKIPINVISIBLE) && !(style & WS_VISIBLE)) continue;
+            if ((uFlags & CWP_SKIPDISABLED) && (style & WS_DISABLED)) continue;
+        }
+        if (uFlags & CWP_SKIPTRANSPARENT)
+        {
+            if (GetWindowLongW( list[i], GWL_EXSTYLE ) & WS_EX_TRANSPARENT) continue;
+        }
+        break;
+    }
+    retvalue = list[i];
+    HeapFree( GetProcessHeap(), 0, list );
+    if (!retvalue) retvalue = hwndParent;
+    return retvalue;
+}
+
+
+/*******************************************************************
+ *         WINPOS_GetWinOffset
+ *
+ * Calculate the offset between the origin of the two windows. Used
+ * to implement MapWindowPoints.
+ */
+static BOOL WINPOS_GetWinOffset( HWND hwndFrom, HWND hwndTo, BOOL *mirrored, POINT *ret_offset )
 {
-    return NtUserChildWindowFromPointEx( parent, pt.x, pt.y, flags );
+    WND * wndPtr;
+    POINT offset;
+    BOOL mirror_from, mirror_to, ret;
+    HWND hwnd;
+
+    offset.x = offset.y = 0;
+    *mirrored = mirror_from = mirror_to = FALSE;
+
+    /* Translate source window origin to screen coords */
+    if (hwndFrom)
+    {
+        if (!(wndPtr = WIN_GetPtr( hwndFrom )))
+        {
+            SetLastError( ERROR_INVALID_WINDOW_HANDLE );
+            return FALSE;
+        }
+        if (wndPtr == WND_OTHER_PROCESS) goto other_process;
+        if (wndPtr != WND_DESKTOP)
+        {
+            if (wndPtr->dwExStyle & WS_EX_LAYOUTRTL)
+            {
+                mirror_from = TRUE;
+                offset.x += wndPtr->client_rect.right - wndPtr->client_rect.left;
+            }
+            while (wndPtr->parent)
+            {
+                offset.x += wndPtr->client_rect.left;
+                offset.y += wndPtr->client_rect.top;
+                hwnd = wndPtr->parent;
+                WIN_ReleasePtr( wndPtr );
+                if (!(wndPtr = WIN_GetPtr( hwnd ))) break;
+                if (wndPtr == WND_OTHER_PROCESS) goto other_process;
+                if (wndPtr == WND_DESKTOP) break;
+                if (wndPtr->flags & WIN_CHILDREN_MOVED)
+                {
+                    WIN_ReleasePtr( wndPtr );
+                    goto other_process;
+                }
+            }
+            if (wndPtr && wndPtr != WND_DESKTOP) WIN_ReleasePtr( wndPtr );
+            offset = point_win_to_thread_dpi( hwndFrom, offset );
+        }
+    }
+
+    /* Translate origin to destination window coords */
+    if (hwndTo)
+    {
+        if (!(wndPtr = WIN_GetPtr( hwndTo )))
+        {
+            SetLastError( ERROR_INVALID_WINDOW_HANDLE );
+            return FALSE;
+        }
+        if (wndPtr == WND_OTHER_PROCESS) goto other_process;
+        if (wndPtr != WND_DESKTOP)
+        {
+            POINT pt = { 0, 0 };
+            if (wndPtr->dwExStyle & WS_EX_LAYOUTRTL)
+            {
+                mirror_to = TRUE;
+                pt.x += wndPtr->client_rect.right - wndPtr->client_rect.left;
+            }
+            while (wndPtr->parent)
+            {
+                pt.x += wndPtr->client_rect.left;
+                pt.y += wndPtr->client_rect.top;
+                hwnd = wndPtr->parent;
+                WIN_ReleasePtr( wndPtr );
+                if (!(wndPtr = WIN_GetPtr( hwnd ))) break;
+                if (wndPtr == WND_OTHER_PROCESS) goto other_process;
+                if (wndPtr == WND_DESKTOP) break;
+                if (wndPtr->flags & WIN_CHILDREN_MOVED)
+                {
+                    WIN_ReleasePtr( wndPtr );
+                    goto other_process;
+                }
+            }
+            if (wndPtr && wndPtr != WND_DESKTOP) WIN_ReleasePtr( wndPtr );
+            pt = point_win_to_thread_dpi( hwndTo, pt );
+            offset.x -= pt.x;
+            offset.y -= pt.y;
+        }
+    }
+
+    *mirrored = mirror_from ^ mirror_to;
+    if (mirror_from) offset.x = -offset.x;
+    *ret_offset = offset;
+    return TRUE;
+
+ other_process:  /* one of the parents may belong to another process, do it the hard way */
+    SERVER_START_REQ( get_windows_offset )
+    {
+        req->from = wine_server_user_handle( hwndFrom );
+        req->to   = wine_server_user_handle( hwndTo );
+        req->dpi  = get_thread_dpi();
+        if ((ret = !wine_server_call_err( req )))
+        {
+            ret_offset->x = reply->x;
+            ret_offset->y = reply->y;
+            *mirrored = reply->mirror;
+        }
+    }
+    SERVER_END_REQ;
+    return ret;
 }
 
 
 /*******************************************************************
  *		MapWindowPoints (USER32.@)
  */
-INT WINAPI MapWindowPoints( HWND hwnd_from, HWND hwnd_to, POINT *points, UINT count )
+INT WINAPI MapWindowPoints( HWND hwndFrom, HWND hwndTo, LPPOINT lppt, UINT count )
 {
-    return NtUserMapWindowPoints( hwnd_from, hwnd_to, points, count );
+    BOOL mirrored;
+    POINT offset;
+    UINT i;
+
+    if (!WINPOS_GetWinOffset( hwndFrom, hwndTo, &mirrored, &offset )) return 0;
+
+    for (i = 0; i < count; i++)
+    {
+        lppt[i].x += offset.x;
+        lppt[i].y += offset.y;
+        if (mirrored) lppt[i].x = -lppt[i].x;
+    }
+    if (mirrored && count == 2)  /* special case for rectangle */
+    {
+        int tmp = lppt[0].x;
+        lppt[0].x = lppt[1].x;
+        lppt[1].x = tmp;
+    }
+    return MAKELONG( LOWORD(offset.x), LOWORD(offset.y) );
 }
 
 
 /*******************************************************************
  *		ClientToScreen (USER32.@)
  */
-BOOL WINAPI ClientToScreen( HWND hwnd, POINT *pt )
+BOOL WINAPI ClientToScreen( HWND hwnd, LPPOINT lppnt )
 {
-    return NtUserClientToScreen( hwnd, pt );
+    POINT offset;
+    BOOL mirrored;
+
+    if (!hwnd)
+    {
+        SetLastError( ERROR_INVALID_WINDOW_HANDLE );
+        return FALSE;
+    }
+    if (!WINPOS_GetWinOffset( hwnd, 0, &mirrored, &offset )) return FALSE;
+    lppnt->x += offset.x;
+    lppnt->y += offset.y;
+    if (mirrored) lppnt->x = -lppnt->x;
+    return TRUE;
 }
 
 
@@ -163,7 +447,7 @@ BOOL WINAPI ClientToScreen( HWND hwnd, POINT *pt )
  */
 BOOL WINAPI ScreenToClient( HWND hwnd, POINT *pt )
 {
-    return NtUserScreenToClient( hwnd, pt );
+    return NtUserCallHwndParam( hwnd, (UINT_PTR)pt, NtUserScreenToClient );
 }
 
 
@@ -216,6 +500,293 @@ BOOL WINAPI BringWindowToTop( HWND hwnd )
 }
 
 
+/*******************************************************************
+ *           get_work_rect
+ *
+ * Get the work area that a maximized window can cover, depending on style.
+ */
+static BOOL get_work_rect( HWND hwnd, RECT *rect )
+{
+    HMONITOR monitor = MonitorFromWindow( hwnd, MONITOR_DEFAULTTOPRIMARY );
+    MONITORINFO mon_info;
+    DWORD style;
+
+    if (!monitor) return FALSE;
+
+    mon_info.cbSize = sizeof(mon_info);
+    GetMonitorInfoW( monitor, &mon_info );
+    *rect = mon_info.rcMonitor;
+
+    style = GetWindowLongW( hwnd, GWL_STYLE );
+    if (style & WS_MAXIMIZEBOX)
+    {
+        if ((style & WS_CAPTION) == WS_CAPTION || !(style & (WS_CHILD | WS_POPUP)))
+            *rect = mon_info.rcWork;
+    }
+    return TRUE;
+}
+
+
+/*******************************************************************
+ *           WINPOS_GetMinMaxInfo
+ *
+ * Get the minimized and maximized information for a window.
+ */
+MINMAXINFO WINPOS_GetMinMaxInfo( HWND hwnd )
+{
+    MINMAXINFO info;
+    NtUserCallHwndParam( hwnd, (UINT_PTR)&info, NtUserGetMinMaxInfo );
+    return info;
+}
+
+
+static POINT get_first_minimized_child_pos( const RECT *parent, const MINIMIZEDMETRICS *mm,
+                                            int width, int height )
+{
+    POINT ret;
+
+    if (mm->iArrange & ARW_STARTRIGHT)
+        ret.x = parent->right - mm->iHorzGap - width;
+    else
+        ret.x = parent->left + mm->iHorzGap;
+    if (mm->iArrange & ARW_STARTTOP)
+        ret.y = parent->top + mm->iVertGap;
+    else
+        ret.y = parent->bottom - mm->iVertGap - height;
+
+    return ret;
+}
+
+static void get_next_minimized_child_pos( const RECT *parent, const MINIMIZEDMETRICS *mm,
+                                          int width, int height, POINT *pos )
+{
+    BOOL next;
+
+    if (mm->iArrange & ARW_UP) /* == ARW_DOWN */
+    {
+        if (mm->iArrange & ARW_STARTTOP)
+        {
+            pos->y += height + mm->iVertGap;
+            if ((next = pos->y + height > parent->bottom))
+                pos->y = parent->top + mm->iVertGap;
+        }
+        else
+        {
+            pos->y -= height + mm->iVertGap;
+            if ((next = pos->y < parent->top))
+                pos->y = parent->bottom - mm->iVertGap - height;
+        }
+
+        if (next)
+        {
+            if (mm->iArrange & ARW_STARTRIGHT)
+                pos->x -= width + mm->iHorzGap;
+            else
+                pos->x += width + mm->iHorzGap;
+        }
+    }
+    else
+    {
+        if (mm->iArrange & ARW_STARTRIGHT)
+        {
+            pos->x -= width + mm->iHorzGap;
+            if ((next = pos->x < parent->left))
+                pos->x = parent->right - mm->iHorzGap - width;
+        }
+        else
+        {
+            pos->x += width + mm->iHorzGap;
+            if ((next = pos->x + width > parent->right))
+                pos->x = parent->left + mm->iHorzGap;
+        }
+
+        if (next)
+        {
+            if (mm->iArrange & ARW_STARTTOP)
+                pos->y += height + mm->iVertGap;
+            else
+                pos->y -= height + mm->iVertGap;
+        }
+    }
+}
+
+static POINT get_minimized_pos( HWND hwnd, POINT pt )
+{
+    RECT rect, rectParent;
+    HWND parent, child;
+    HRGN hrgn, tmp;
+    MINIMIZEDMETRICS metrics;
+    int width, height;
+
+    parent = NtUserGetAncestor( hwnd, GA_PARENT );
+    if (parent == GetDesktopWindow())
+    {
+        MONITORINFO mon_info;
+        HMONITOR monitor = MonitorFromWindow( hwnd, MONITOR_DEFAULTTOPRIMARY );
+
+        mon_info.cbSize = sizeof( mon_info );
+        GetMonitorInfoW( monitor, &mon_info );
+        rectParent = mon_info.rcWork;
+    }
+    else GetClientRect( parent, &rectParent );
+
+    if ((pt.x >= rectParent.left) && (pt.x + GetSystemMetrics( SM_CXMINIMIZED ) < rectParent.right) &&
+        (pt.y >= rectParent.top) && (pt.y + GetSystemMetrics( SM_CYMINIMIZED ) < rectParent.bottom))
+        return pt;  /* The icon already has a suitable position */
+
+    width = GetSystemMetrics( SM_CXMINIMIZED );
+    height = GetSystemMetrics( SM_CYMINIMIZED );
+
+    metrics.cbSize = sizeof(metrics);
+    SystemParametersInfoW( SPI_GETMINIMIZEDMETRICS, sizeof(metrics), &metrics, 0 );
+
+    /* Check if another icon already occupies this spot */
+    /* FIXME: this is completely inefficient */
+
+    hrgn = CreateRectRgn( 0, 0, 0, 0 );
+    tmp = CreateRectRgn( 0, 0, 0, 0 );
+    for (child = GetWindow( parent, GW_CHILD ); child; child = GetWindow( child, GW_HWNDNEXT ))
+    {
+        if (child == hwnd) continue;
+        if ((GetWindowLongW( child, GWL_STYLE ) & (WS_VISIBLE|WS_MINIMIZE)) != (WS_VISIBLE|WS_MINIMIZE))
+            continue;
+        if (WIN_GetRectangles( child, COORDS_PARENT, &rect, NULL ))
+        {
+            SetRectRgn( tmp, rect.left, rect.top, rect.right, rect.bottom );
+            CombineRgn( hrgn, hrgn, tmp, RGN_OR );
+        }
+    }
+    DeleteObject( tmp );
+
+    pt = get_first_minimized_child_pos( &rectParent, &metrics, width, height );
+    for (;;)
+    {
+        SetRect( &rect, pt.x, pt.y, pt.x + width, pt.y + height );
+        if (!RectInRegion( hrgn, &rect ))
+            break;
+
+        get_next_minimized_child_pos( &rectParent, &metrics, width, height, &pt );
+    }
+
+    DeleteObject( hrgn );
+    return pt;
+}
+
+
+/***********************************************************************
+ *           WINPOS_MinMaximize
+ */
+UINT WINPOS_MinMaximize( HWND hwnd, UINT cmd, LPRECT rect )
+{
+    UINT swpFlags = 0;
+    LONG old_style;
+    MINMAXINFO minmax;
+    WINDOWPLACEMENT wpl;
+
+    TRACE("%p %u\n", hwnd, cmd );
+
+    wpl.length = sizeof(wpl);
+    GetWindowPlacement( hwnd, &wpl );
+
+    if (HOOK_CallHooks( WH_CBT, HCBT_MINMAX, (WPARAM)hwnd, cmd, TRUE ))
+        return SWP_NOSIZE | SWP_NOMOVE;
+
+    if (IsIconic( hwnd ))
+    {
+        switch (cmd)
+        {
+        case SW_SHOWMINNOACTIVE:
+        case SW_SHOWMINIMIZED:
+        case SW_FORCEMINIMIZE:
+        case SW_MINIMIZE:
+            wpl.ptMinPosition = get_minimized_pos( hwnd, wpl.ptMinPosition );
+
+            SetRect( rect, wpl.ptMinPosition.x, wpl.ptMinPosition.y,
+                     wpl.ptMinPosition.x + GetSystemMetrics(SM_CXMINIMIZED),
+                     wpl.ptMinPosition.y + GetSystemMetrics(SM_CYMINIMIZED) );
+            return SWP_NOSIZE | SWP_NOMOVE;
+        }
+        if (!SendMessageW( hwnd, WM_QUERYOPEN, 0, 0 )) return SWP_NOSIZE | SWP_NOMOVE;
+        swpFlags |= SWP_NOCOPYBITS;
+    }
+
+    switch( cmd )
+    {
+    case SW_SHOWMINNOACTIVE:
+    case SW_SHOWMINIMIZED:
+    case SW_FORCEMINIMIZE:
+    case SW_MINIMIZE:
+        if (IsZoomed( hwnd )) win_set_flags( hwnd, WIN_RESTORE_MAX, 0 );
+        else win_set_flags( hwnd, 0, WIN_RESTORE_MAX );
+
+        if (GetFocus() == hwnd)
+        {
+            if (GetWindowLongW(hwnd, GWL_STYLE) & WS_CHILD)
+                NtUserSetFocus( NtUserGetAncestor( hwnd, GA_PARENT ));
+            else
+                NtUserSetFocus( 0 );
+        }
+
+        old_style = WIN_SetStyle( hwnd, WS_MINIMIZE, WS_MAXIMIZE );
+
+        wpl.ptMinPosition = get_minimized_pos( hwnd, wpl.ptMinPosition );
+
+        if (!(old_style & WS_MINIMIZE)) swpFlags |= SWP_STATECHANGED;
+        SetRect( rect, wpl.ptMinPosition.x, wpl.ptMinPosition.y,
+                 wpl.ptMinPosition.x + GetSystemMetrics(SM_CXMINIMIZED),
+                 wpl.ptMinPosition.y + GetSystemMetrics(SM_CYMINIMIZED) );
+        swpFlags |= SWP_NOCOPYBITS;
+        break;
+
+    case SW_MAXIMIZE:
+        old_style = GetWindowLongW( hwnd, GWL_STYLE );
+        if ((old_style & WS_MAXIMIZE) && (old_style & WS_VISIBLE)) return SWP_NOSIZE | SWP_NOMOVE;
+
+        minmax = WINPOS_GetMinMaxInfo( hwnd );
+
+        old_style = WIN_SetStyle( hwnd, WS_MAXIMIZE, WS_MINIMIZE );
+        if (old_style & WS_MINIMIZE)
+            win_set_flags( hwnd, WIN_RESTORE_MAX, 0 );
+
+        if (!(old_style & WS_MAXIMIZE)) swpFlags |= SWP_STATECHANGED;
+        SetRect( rect, minmax.ptMaxPosition.x, minmax.ptMaxPosition.y,
+                 minmax.ptMaxPosition.x + minmax.ptMaxSize.x, minmax.ptMaxPosition.y + minmax.ptMaxSize.y );
+        break;
+
+    case SW_SHOWNOACTIVATE:
+        win_set_flags( hwnd, 0, WIN_RESTORE_MAX );
+        /* fall through */
+    case SW_SHOWNORMAL:
+    case SW_RESTORE:
+    case SW_SHOWDEFAULT: /* FIXME: should have its own handler */
+        old_style = WIN_SetStyle( hwnd, 0, WS_MINIMIZE | WS_MAXIMIZE );
+        if (old_style & WS_MINIMIZE)
+        {
+            if (win_get_flags( hwnd ) & WIN_RESTORE_MAX)
+            {
+                /* Restore to maximized position */
+                minmax = WINPOS_GetMinMaxInfo( hwnd );
+                WIN_SetStyle( hwnd, WS_MAXIMIZE, 0 );
+                swpFlags |= SWP_STATECHANGED;
+                SetRect( rect, minmax.ptMaxPosition.x, minmax.ptMaxPosition.y,
+                         minmax.ptMaxPosition.x + minmax.ptMaxSize.x, minmax.ptMaxPosition.y + minmax.ptMaxSize.y );
+                break;
+            }
+        }
+        else if (!(old_style & WS_MAXIMIZE)) break;
+
+        swpFlags |= SWP_STATECHANGED;
+
+        /* Restore to normal position */
+
+        *rect = wpl.rcNormalPosition;
+        break;
+    }
+
+    return swpFlags;
+}
+
+
 /***********************************************************************
  *		GetInternalWindowPos (USER32.@)
  */
@@ -225,7 +796,7 @@ UINT WINAPI GetInternalWindowPos( HWND hwnd, LPRECT rectWnd,
     WINDOWPLACEMENT wndpl;
 
     wndpl.length = sizeof(wndpl);
-    if (NtUserGetWindowPlacement( hwnd, &wndpl ))
+    if (GetWindowPlacement( hwnd, &wndpl ))
     {
 	if (rectWnd) *rectWnd = wndpl.rcNormalPosition;
 	if (ptIcon)  *ptIcon = wndpl.ptMinPosition;
@@ -235,6 +806,183 @@ UINT WINAPI GetInternalWindowPos( HWND hwnd, LPRECT rectWnd,
 }
 
 
+static RECT get_maximized_work_rect( HWND hwnd )
+{
+    RECT work_rect = { 0 };
+
+    if ((GetWindowLongW( hwnd, GWL_STYLE ) & (WS_MINIMIZE | WS_MAXIMIZE)) == WS_MAXIMIZE)
+    {
+        if (!get_work_rect( hwnd, &work_rect ))
+            work_rect = get_primary_monitor_rect();
+    }
+    return work_rect;
+}
+
+
+/*******************************************************************
+ *           update_maximized_pos
+ *
+ * For top level windows covering the work area, we might have to
+ * "forget" the maximized position. Windows presumably does this
+ * to avoid situations where the border style changes, which would
+ * lead the window to be outside the screen, or the window gets
+ * reloaded on a different screen, and the "saved" position no
+ * longer applies to it (despite being maximized).
+ *
+ * Some applications (e.g. Imperiums: Greek Wars) depend on this.
+ */
+static void update_maximized_pos( WND *wnd, RECT *work_rect )
+{
+    if (wnd->parent && wnd->parent != GetDesktopWindow())
+        return;
+
+    if (wnd->dwStyle & WS_MAXIMIZE)
+    {
+        if (wnd->window_rect.left  <= work_rect->left  && wnd->window_rect.top    <= work_rect->top &&
+            wnd->window_rect.right >= work_rect->right && wnd->window_rect.bottom >= work_rect->bottom)
+            wnd->max_pos.x = wnd->max_pos.y = -1;
+    }
+    else
+        wnd->max_pos.x = wnd->max_pos.y = -1;
+}
+
+
+/***********************************************************************
+ *		GetWindowPlacement (USER32.@)
+ *
+ * Win95:
+ * Fails if wndpl->length of Win95 (!) apps is invalid.
+ */
+BOOL WINAPI GetWindowPlacement( HWND hwnd, WINDOWPLACEMENT *wndpl )
+{
+    return NtUserCallHwndParam( hwnd, (UINT_PTR)wndpl, NtUserGetWindowPlacement );
+}
+
+/* make sure the specified rect is visible on screen */
+static void make_rect_onscreen( RECT *rect )
+{
+    MONITORINFO info;
+    HMONITOR monitor = MonitorFromRect( rect, MONITOR_DEFAULTTONEAREST );
+
+    info.cbSize = sizeof(info);
+    if (!monitor || !GetMonitorInfoW( monitor, &info )) return;
+    /* FIXME: map coordinates from rcWork to rcMonitor */
+    if (rect->right <= info.rcWork.left)
+    {
+        rect->right += info.rcWork.left - rect->left;
+        rect->left = info.rcWork.left;
+    }
+    else if (rect->left >= info.rcWork.right)
+    {
+        rect->left += info.rcWork.right - rect->right;
+        rect->right = info.rcWork.right;
+    }
+    if (rect->bottom <= info.rcWork.top)
+    {
+        rect->bottom += info.rcWork.top - rect->top;
+        rect->top = info.rcWork.top;
+    }
+    else if (rect->top >= info.rcWork.bottom)
+    {
+        rect->top += info.rcWork.bottom - rect->bottom;
+        rect->bottom = info.rcWork.bottom;
+    }
+}
+
+/* make sure the specified point is visible on screen */
+static void make_point_onscreen( POINT *pt )
+{
+    RECT rect;
+
+    SetRect( &rect, pt->x, pt->y, pt->x + 1, pt->y + 1 );
+    make_rect_onscreen( &rect );
+    pt->x = rect.left;
+    pt->y = rect.top;
+}
+
+
+/***********************************************************************
+ *           WINPOS_SetPlacement
+ */
+static BOOL WINPOS_SetPlacement( HWND hwnd, const WINDOWPLACEMENT *wndpl, UINT flags )
+{
+    DWORD style;
+    RECT work_rect = get_maximized_work_rect( hwnd );
+    WND *pWnd = WIN_GetPtr( hwnd );
+    WINDOWPLACEMENT wp = *wndpl;
+
+    if (flags & PLACE_MIN) make_point_onscreen( &wp.ptMinPosition );
+    if (flags & PLACE_MAX) make_point_onscreen( &wp.ptMaxPosition );
+    if (flags & PLACE_RECT) make_rect_onscreen( &wp.rcNormalPosition );
+
+    TRACE( "%p: setting min %d,%d max %d,%d normal %s flags %x adjusted to min %d,%d max %d,%d normal %s\n",
+           hwnd, wndpl->ptMinPosition.x, wndpl->ptMinPosition.y,
+           wndpl->ptMaxPosition.x, wndpl->ptMaxPosition.y,
+           wine_dbgstr_rect(&wndpl->rcNormalPosition), flags,
+           wp.ptMinPosition.x, wp.ptMinPosition.y, wp.ptMaxPosition.x, wp.ptMaxPosition.y,
+           wine_dbgstr_rect(&wp.rcNormalPosition) );
+
+    if (!pWnd || pWnd == WND_OTHER_PROCESS || pWnd == WND_DESKTOP) return FALSE;
+
+    if (flags & PLACE_MIN) pWnd->min_pos = point_thread_to_win_dpi( hwnd, wp.ptMinPosition );
+    if (flags & PLACE_MAX)
+    {
+        pWnd->max_pos = point_thread_to_win_dpi( hwnd, wp.ptMaxPosition );
+        update_maximized_pos( pWnd, &work_rect );
+    }
+    if (flags & PLACE_RECT) pWnd->normal_rect = rect_thread_to_win_dpi( hwnd, wp.rcNormalPosition );
+
+    style = pWnd->dwStyle;
+
+    WIN_ReleasePtr( pWnd );
+
+    if( style & WS_MINIMIZE )
+    {
+        if (flags & PLACE_MIN)
+        {
+            NtUserSetWindowPos( hwnd, 0, wp.ptMinPosition.x, wp.ptMinPosition.y, 0, 0,
+                                SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
+        }
+    }
+    else if( style & WS_MAXIMIZE )
+    {
+        if (flags & PLACE_MAX)
+            NtUserSetWindowPos( hwnd, 0, wp.ptMaxPosition.x, wp.ptMaxPosition.y, 0, 0,
+                                SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
+    }
+    else if( flags & PLACE_RECT )
+        NtUserSetWindowPos( hwnd, 0, wp.rcNormalPosition.left, wp.rcNormalPosition.top,
+                            wp.rcNormalPosition.right - wp.rcNormalPosition.left,
+                            wp.rcNormalPosition.bottom - wp.rcNormalPosition.top,
+                            SWP_NOZORDER | SWP_NOACTIVATE );
+
+    NtUserShowWindow( hwnd, wndpl->showCmd );
+
+    if (IsIconic( hwnd ))
+    {
+        /* SDK: ...valid only the next time... */
+        if( wndpl->flags & WPF_RESTORETOMAXIMIZED )
+            win_set_flags( hwnd, WIN_RESTORE_MAX, 0 );
+    }
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *		SetWindowPlacement (USER32.@)
+ *
+ * Win95:
+ * Fails if wndpl->length of Win95 (!) apps is invalid.
+ */
+BOOL WINAPI SetWindowPlacement( HWND hwnd, const WINDOWPLACEMENT *wpl )
+{
+    UINT flags = PLACE_MAX | PLACE_RECT;
+    if (!wpl) return FALSE;
+    if (wpl->flags & WPF_SETMINPOSITION) flags |= PLACE_MIN;
+    return WINPOS_SetPlacement( hwnd, wpl, flags );
+}
+
+
 /***********************************************************************
  *		AnimateWindow (USER32.@)
  *		Shows/Hides a window with an animation
@@ -260,6 +1008,33 @@ BOOL WINAPI AnimateWindow(HWND hwnd, DWORD dwTime, DWORD dwFlags)
 	return TRUE;
 }
 
+/***********************************************************************
+ *		SetInternalWindowPos (USER32.@)
+ */
+void WINAPI SetInternalWindowPos( HWND hwnd, UINT showCmd,
+                                    LPRECT rect, LPPOINT pt )
+{
+    WINDOWPLACEMENT wndpl;
+    UINT flags;
+
+    wndpl.length  = sizeof(wndpl);
+    wndpl.showCmd = showCmd;
+    wndpl.flags = flags = 0;
+
+    if( pt )
+    {
+        flags |= PLACE_MIN;
+        wndpl.flags |= WPF_SETMINPOSITION;
+        wndpl.ptMinPosition = *pt;
+    }
+    if( rect )
+    {
+        flags |= PLACE_RECT;
+        wndpl.rcNormalPosition = *rect;
+    }
+    WINPOS_SetPlacement( hwnd, &wndpl, flags );
+}
+
 
 /*******************************************************************
  *         can_activate_window
@@ -323,12 +1098,264 @@ void WINPOS_ActivateOtherWindow(HWND hwnd)
 }
 
 
+/***********************************************************************
+ *           WINPOS_HandleWindowPosChanging
+ *
+ * Default handling for a WM_WINDOWPOSCHANGING. Called from DefWindowProc().
+ */
+LONG WINPOS_HandleWindowPosChanging( HWND hwnd, WINDOWPOS *winpos )
+{
+    LONG style = GetWindowLongW( hwnd, GWL_STYLE );
+
+    if (winpos->flags & SWP_NOSIZE) return 0;
+    if ((style & WS_THICKFRAME) || ((style & (WS_POPUP | WS_CHILD)) == 0))
+    {
+	MINMAXINFO info = WINPOS_GetMinMaxInfo( hwnd );
+        winpos->cx = min( winpos->cx, info.ptMaxTrackSize.x );
+        winpos->cy = min( winpos->cy, info.ptMaxTrackSize.y );
+	if (!(style & WS_MINIMIZE))
+	{
+            winpos->cx = max( winpos->cx, info.ptMinTrackSize.x );
+            winpos->cy = max( winpos->cy, info.ptMinTrackSize.y );
+	}
+    }
+    return 0;
+}
+
+
+/***********************************************************************
+ *		update_surface_region
+ */
+static void update_surface_region( HWND hwnd )
+{
+    NTSTATUS status;
+    HRGN region = 0;
+    RGNDATA *data;
+    size_t size = 256;
+    WND *win = WIN_GetPtr( hwnd );
+
+    if (!win || win == WND_DESKTOP || win == WND_OTHER_PROCESS) return;
+    if (!win->surface) goto done;
+
+    do
+    {
+        if (!(data = HeapAlloc( GetProcessHeap(), 0, FIELD_OFFSET( RGNDATA, Buffer[size] )))) goto done;
+
+        SERVER_START_REQ( get_surface_region )
+        {
+            req->window = wine_server_user_handle( hwnd );
+            wine_server_set_reply( req, data->Buffer, size );
+            if (!(status = wine_server_call( req )))
+            {
+                size_t reply_size = wine_server_reply_size( reply );
+                if (reply_size)
+                {
+                    data->rdh.dwSize   = sizeof(data->rdh);
+                    data->rdh.iType    = RDH_RECTANGLES;
+                    data->rdh.nCount   = reply_size / sizeof(RECT);
+                    data->rdh.nRgnSize = reply_size;
+                    region = ExtCreateRegion( NULL, data->rdh.dwSize + data->rdh.nRgnSize, data );
+                    OffsetRgn( region, -reply->visible_rect.left, -reply->visible_rect.top );
+                }
+            }
+            else size = reply->total_size;
+        }
+        SERVER_END_REQ;
+        HeapFree( GetProcessHeap(), 0, data );
+    } while (status == STATUS_BUFFER_OVERFLOW);
+
+    if (status) goto done;
+
+    win->surface->funcs->set_region( win->surface, region );
+    if (region) DeleteObject( region );
+
+done:
+    WIN_ReleasePtr( win );
+}
+
+
+/***********************************************************************
+ *		set_window_pos
+ *
+ * Backend implementation of SetWindowPos.
+ */
+BOOL set_window_pos( HWND hwnd, HWND insert_after, UINT swp_flags,
+                     const RECT *window_rect, const RECT *client_rect, const RECT *valid_rects )
+{
+    WND *win;
+    HWND surface_win = 0, parent = NtUserGetAncestor( hwnd, GA_PARENT );
+    BOOL ret, needs_update = FALSE;
+    RECT visible_rect, old_visible_rect, old_window_rect, old_client_rect, extra_rects[3];
+    struct window_surface *old_surface, *new_surface = NULL;
+    struct window_surface *dummy_surface = (struct window_surface *)NtUserCallHwnd( 0, NtUserGetDummySurface );
+
+    if (!parent || parent == GetDesktopWindow())
+    {
+        new_surface = dummy_surface;  /* provide a default surface for top-level windows */
+        window_surface_add_ref( new_surface );
+    }
+    visible_rect = *window_rect;
+    if (!(ret = USER_Driver->pWindowPosChanging( hwnd, insert_after, swp_flags,
+                                                 window_rect, client_rect, &visible_rect, &new_surface )))
+    {
+        if (IsRectEmpty( window_rect )) visible_rect = *window_rect;
+        else
+        {
+            visible_rect = get_virtual_screen_rect();
+            IntersectRect( &visible_rect, &visible_rect, window_rect );
+        }
+    }
+
+    WIN_GetRectangles( hwnd, COORDS_SCREEN, &old_window_rect, NULL );
+    if (IsRectEmpty( &valid_rects[0] )) valid_rects = NULL;
+
+    if (!(win = WIN_GetPtr( hwnd )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
+    {
+        if (new_surface) window_surface_release( new_surface );
+        return FALSE;
+    }
+
+    /* create or update window surface for top-level windows if the driver doesn't implement WindowPosChanging */
+    if (!ret && new_surface && !IsRectEmpty( &visible_rect ) &&
+        (!(GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED) ||
+           NtUserGetLayeredWindowAttributes( hwnd, NULL, NULL, NULL )))
+    {
+        window_surface_release( new_surface );
+        if ((new_surface = win->surface)) window_surface_add_ref( new_surface );
+        create_offscreen_window_surface( &visible_rect, &new_surface );
+    }
+
+    old_visible_rect = win->visible_rect;
+    old_client_rect = win->client_rect;
+    old_surface = win->surface;
+    if (old_surface != new_surface) swp_flags |= SWP_FRAMECHANGED;  /* force refreshing non-client area */
+    if (new_surface == dummy_surface) swp_flags |= SWP_NOREDRAW;
+    else if (old_surface == dummy_surface)
+    {
+        swp_flags |= SWP_NOCOPYBITS;
+        valid_rects = NULL;
+    }
+
+    SERVER_START_REQ( set_window_pos )
+    {
+        req->handle        = wine_server_user_handle( hwnd );
+        req->previous      = wine_server_user_handle( insert_after );
+        req->swp_flags     = swp_flags;
+        req->window.left   = window_rect->left;
+        req->window.top    = window_rect->top;
+        req->window.right  = window_rect->right;
+        req->window.bottom = window_rect->bottom;
+        req->client.left   = client_rect->left;
+        req->client.top    = client_rect->top;
+        req->client.right  = client_rect->right;
+        req->client.bottom = client_rect->bottom;
+        if (!EqualRect( window_rect, &visible_rect ) || new_surface || valid_rects)
+        {
+            extra_rects[0] = extra_rects[1] = visible_rect;
+            if (new_surface)
+            {
+                extra_rects[1] = new_surface->rect;
+                OffsetRect( &extra_rects[1], visible_rect.left, visible_rect.top );
+            }
+            if (valid_rects) extra_rects[2] = valid_rects[0];
+            else SetRectEmpty( &extra_rects[2] );
+            wine_server_add_data( req, extra_rects, sizeof(extra_rects) );
+        }
+        if (new_surface) req->paint_flags |= SET_WINPOS_PAINT_SURFACE;
+        if (win->pixel_format) req->paint_flags |= SET_WINPOS_PIXEL_FORMAT;
+
+        if ((ret = !wine_server_call( req )))
+        {
+            win->dwStyle    = reply->new_style;
+            win->dwExStyle  = reply->new_ex_style;
+            win->window_rect  = *window_rect;
+            win->client_rect  = *client_rect;
+            win->visible_rect = visible_rect;
+            win->surface      = new_surface;
+            surface_win       = wine_server_ptr_handle( reply->surface_win );
+            needs_update      = reply->needs_update;
+            if (GetWindowLongW( win->parent, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL)
+            {
+                RECT client;
+                GetClientRect( win->parent, &client );
+                mirror_rect( &client, &win->window_rect );
+                mirror_rect( &client, &win->client_rect );
+                mirror_rect( &client, &win->visible_rect );
+            }
+            /* if an RTL window is resized the children have moved */
+            if (win->dwExStyle & WS_EX_LAYOUTRTL &&
+                client_rect->right - client_rect->left != old_client_rect.right - old_client_rect.left)
+                win->flags |= WIN_CHILDREN_MOVED;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (ret)
+    {
+        if (needs_update) update_surface_region( surface_win );
+        if (((swp_flags & SWP_AGG_NOPOSCHANGE) != SWP_AGG_NOPOSCHANGE) ||
+            (swp_flags & (SWP_HIDEWINDOW | SWP_SHOWWINDOW | SWP_STATECHANGED | SWP_FRAMECHANGED)))
+            invalidate_dce( win, &old_window_rect );
+    }
+
+    WIN_ReleasePtr( win );
+
+    if (ret)
+    {
+        TRACE( "win %p surface %p -> %p\n", hwnd, old_surface, new_surface );
+        register_window_surface( old_surface, new_surface );
+        if (old_surface)
+        {
+            if (valid_rects)
+            {
+                move_window_bits( hwnd, old_surface, new_surface, &visible_rect,
+                                  &old_visible_rect, window_rect, valid_rects );
+                valid_rects = NULL;  /* prevent the driver from trying to also move the bits */
+            }
+            window_surface_release( old_surface );
+        }
+        else if (surface_win && surface_win != hwnd)
+        {
+            if (valid_rects)
+            {
+                RECT rects[2];
+                int x_offset = old_visible_rect.left - visible_rect.left;
+                int y_offset = old_visible_rect.top - visible_rect.top;
+
+                /* if all that happened is that the whole window moved, copy everything */
+                if (!(swp_flags & SWP_FRAMECHANGED) &&
+                    old_visible_rect.right  - visible_rect.right  == x_offset &&
+                    old_visible_rect.bottom - visible_rect.bottom == y_offset &&
+                    old_client_rect.left    - client_rect->left   == x_offset &&
+                    old_client_rect.right   - client_rect->right  == x_offset &&
+                    old_client_rect.top     - client_rect->top    == y_offset &&
+                    old_client_rect.bottom  - client_rect->bottom == y_offset &&
+                    EqualRect( &valid_rects[0], client_rect ))
+                {
+                    rects[0] = visible_rect;
+                    rects[1] = old_visible_rect;
+                    valid_rects = rects;
+                }
+                move_window_bits_parent( hwnd, surface_win, window_rect, valid_rects );
+                valid_rects = NULL;  /* prevent the driver from trying to also move the bits */
+            }
+        }
+
+        USER_Driver->pWindowPosChanged( hwnd, insert_after, swp_flags, window_rect,
+                                        client_rect, &visible_rect, valid_rects, new_surface );
+    }
+    else if (new_surface) window_surface_release( new_surface );
+
+    return ret;
+}
+
+
 /***********************************************************************
  *		BeginDeferWindowPos (USER32.@)
  */
 HDWP WINAPI BeginDeferWindowPos( INT count )
 {
-    return NtUserBeginDeferWindowPos( count );
+    return UlongToHandle( NtUserCallOneParam( count, NtUserBeginDeferWindowPos ));
 }
 
 
@@ -356,7 +1383,43 @@ BOOL WINAPI EndDeferWindowPos( HDWP hdwp )
  */
 UINT WINAPI ArrangeIconicWindows( HWND parent )
 {
-    return NtUserArrangeIconicWindows( parent );
+    int width, height, count = 0;
+    RECT rectParent;
+    HWND hwndChild;
+    POINT pt;
+    MINIMIZEDMETRICS metrics;
+
+    metrics.cbSize = sizeof(metrics);
+    SystemParametersInfoW( SPI_GETMINIMIZEDMETRICS, sizeof(metrics), &metrics, 0 );
+    width = GetSystemMetrics( SM_CXMINIMIZED );
+    height = GetSystemMetrics( SM_CYMINIMIZED );
+
+    if (parent == GetDesktopWindow())
+    {
+        MONITORINFO mon_info;
+        HMONITOR monitor = MonitorFromWindow( 0, MONITOR_DEFAULTTOPRIMARY );
+
+        mon_info.cbSize = sizeof( mon_info );
+        GetMonitorInfoW( monitor, &mon_info );
+        rectParent = mon_info.rcWork;
+    }
+    else GetClientRect( parent, &rectParent );
+
+    pt = get_first_minimized_child_pos( &rectParent, &metrics, width, height );
+
+    hwndChild = GetWindow( parent, GW_CHILD );
+    while (hwndChild)
+    {
+        if( IsIconic( hwndChild ) )
+        {
+            NtUserSetWindowPos( hwndChild, 0, pt.x, pt.y, 0, 0,
+                                SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
+            get_next_minimized_child_pos( &rectParent, &metrics, width, height, &pt );
+            count++;
+        }
+        hwndChild = GetWindow( hwndChild, GW_HWNDNEXT );
+    }
+    return count;
 }
 
 
@@ -431,7 +1494,7 @@ static LONG start_size_move( HWND hwnd, WPARAM wParam, POINT *capturePoint, LONG
         while(!hittest)
         {
             if (!GetMessageW( &msg, 0, 0, 0 )) return 0;
-            if (NtUserCallMsgFilter( &msg, MSGF_SIZE )) continue;
+            if (CallMsgFilterW( &msg, MSGF_SIZE )) continue;
 
             switch(msg.message)
             {
@@ -542,7 +1605,7 @@ void WINPOS_SysCommandSizeMove( HWND hwnd, WPARAM wParam )
 
       /* Get min/max info */
 
-    minmax = NtUserGetMinMaxInfo( hwnd );
+    minmax = WINPOS_GetMinMaxInfo( hwnd );
     WIN_GetRectangles( hwnd, COORDS_PARENT, &sizingRect, NULL );
     origRect = sizingRect;
     if (style & WS_CHILD)
@@ -597,7 +1660,7 @@ void WINPOS_SysCommandSizeMove( HWND hwnd, WPARAM wParam )
         int dx = 0, dy = 0;
 
         if (!GetMessageW( &msg, 0, 0, 0 )) break;
-        if (NtUserCallMsgFilter( &msg, MSGF_SIZE )) continue;
+        if (CallMsgFilterW( &msg, MSGF_SIZE )) continue;
 
         /* Exit on button-up, Return, or Esc */
         if ((msg.message == WM_LBUTTONUP) ||
diff --git a/dlls/user32/winproc.c b/dlls/user32/winproc.c
index 098bd17fbc0..b8eda38040a 100644
--- a/dlls/user32/winproc.c
+++ b/dlls/user32/winproc.c
@@ -29,32 +29,16 @@
 #include "wingdi.h"
 #include "controls.h"
 #include "win.h"
-#include "dbt.h"
 #include "user_private.h"
 #include "wine/asm.h"
 #include "wine/debug.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(msg);
+WINE_DECLARE_DEBUG_CHANNEL(msg);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
 
+#define MAX_WINPROC_RECURSION  64
 #define WINPROC_PROC16  ((void *)1)  /* placeholder for 16-bit window procs */
 
-union packed_structs
-{
-    struct packed_CREATESTRUCTW cs;
-    struct packed_DRAWITEMSTRUCT dis;
-    struct packed_MEASUREITEMSTRUCT mis;
-    struct packed_DELETEITEMSTRUCT dls;
-    struct packed_COMPAREITEMSTRUCT cis;
-    struct packed_WINDOWPOS wp;
-    struct packed_COPYDATASTRUCT cds;
-    struct packed_HELPINFO hi;
-    struct packed_NCCALCSIZE_PARAMS ncp;
-    struct packed_MSG msg;
-    struct packed_MDINEXTMENU mnm;
-    struct packed_MDICREATESTRUCTW mcs;
-};
-
 static inline void *get_buffer( void *static_buffer, size_t size, size_t need )
 {
     if (size >= need) return static_buffer;
@@ -171,6 +155,29 @@ static LRESULT call_dialog_proc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp, LRES
 }
 
 
+/**********************************************************************
+ *	     WINPROC_GetProc
+ *
+ * Get a window procedure pointer that can be passed to the Windows program.
+ */
+WNDPROC WINPROC_GetProc( WNDPROC proc, BOOL unicode )
+{
+    WINDOWPROC *ptr = handle_to_proc( proc );
+
+    if (!ptr || ptr == WINPROC_PROC16) return proc;
+    if (unicode)
+    {
+        if (ptr->procW) return ptr->procW;
+        return proc;
+    }
+    else
+    {
+        if (ptr->procA) return ptr->procA;
+        return proc;
+    }
+}
+
+
 /**********************************************************************
  *	     WINPROC_AllocProc
  *
@@ -186,6 +193,22 @@ static WNDPROC WINPROC_AllocProc( WNDPROC func, BOOL unicode )
 }
 
 
+/**********************************************************************
+ *	     WINPROC_IsUnicode
+ *
+ * Return the window procedure type, or the default value if not a winproc handle.
+ */
+BOOL WINPROC_IsUnicode( WNDPROC proc, BOOL def_val )
+{
+    WINDOWPROC *ptr = handle_to_proc( proc );
+
+    if (!ptr) return def_val;
+    if (ptr == WINPROC_PROC16) return FALSE;  /* 16-bit is always A */
+    if (ptr->procA && ptr->procW) return def_val;  /* can be both */
+    return (ptr->procW != NULL);
+}
+
+
 /**********************************************************************
  *	     WINPROC_TestLBForStr
  *
@@ -723,6 +746,8 @@ static void dispatch_win_proc_params( struct win_proc_params *params )
 {
     DPI_AWARENESS_CONTEXT context = SetThreadDpiAwarenessContext( params->dpi_awareness );
 
+    USER_CheckNotLock();
+
     if (!params->ansi)
     {
         if (params->procW == WINPROC_PROC16)
@@ -805,501 +830,99 @@ static void dispatch_win_proc_params( struct win_proc_params *params )
     SetThreadDpiAwarenessContext( context );
 }
 
-/* make sure that there is space for 'size' bytes in buffer, growing it if needed */
-static inline void *get_buffer_space( void **buffer, size_t size, size_t prev_size )
-{
-    if (prev_size > size && !(*buffer = HeapAlloc( GetProcessHeap(), 0, size ))) return NULL;
-    return *buffer;
-}
-
-/* check whether a combobox expects strings or ids in CB_ADDSTRING/CB_INSERTSTRING */
-static inline BOOL combobox_has_strings( HWND hwnd )
-{
-    DWORD style = GetWindowLongA( hwnd, GWL_STYLE );
-    return (!(style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)) || (style & CBS_HASSTRINGS));
-}
 
-/* check whether a listbox expects strings or ids in LB_ADDSTRING/LB_INSERTSTRING */
-static inline BOOL listbox_has_strings( HWND hwnd )
-{
-    DWORD style = GetWindowLongA( hwnd, GWL_STYLE );
-    return (!(style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)) || (style & LBS_HASSTRINGS));
-}
-
-/* unpack a potentially 64-bit pointer, returning 0 when truncated */
-static inline void *unpack_ptr( ULONGLONG ptr64 )
-{
-    if ((ULONG_PTR)ptr64 != ptr64) return 0;
-    return (void *)(ULONG_PTR)ptr64;
-}
-
-/* convert a server handle to a generic handle */
-static inline HANDLE unpack_handle( UINT handle )
-{
-    return (HANDLE)(INT_PTR)(int)handle;
-}
-
-/* make sure that the buffer contains a valid null-terminated Unicode string */
-static inline BOOL check_string( LPCWSTR str, size_t size )
-{
-    for (size /= sizeof(WCHAR); size; size--, str++)
-        if (!*str) return TRUE;
-    return FALSE;
-}
-
-/***********************************************************************
- *		unpack_message
+/**********************************************************************
+ *		WINPROC_call_window
  *
- * Unpack a message received from another process.
+ * Call the window procedure of the specified window.
  */
-static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lparam,
-                            void **buffer, size_t size )
+BOOL WINPROC_call_window( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam,
+                          LRESULT *result, BOOL unicode, enum wm_char_mapping mapping )
 {
-    size_t minsize = 0, prev_size = size;
-    union packed_structs *ps = *buffer;
+    struct user_thread_info *thread_info = get_user_thread_info();
+    struct win_proc_params params;
+    WINDOWPROC *proc;
+    WND *wndPtr;
 
-    switch(message)
-    {
-    case WM_NCCREATE:
-    case WM_CREATE:
+    if (!(wndPtr = WIN_GetPtr( hwnd ))) return FALSE;
+    if (wndPtr == WND_OTHER_PROCESS || wndPtr == WND_DESKTOP) return FALSE;
+    if (wndPtr->tid != GetCurrentThreadId())
     {
-        CREATESTRUCTW cs;
-        WCHAR *str = (WCHAR *)(&ps->cs + 1);
-        if (size < sizeof(ps->cs)) return FALSE;
-        size -= sizeof(ps->cs);
-        cs.lpCreateParams = unpack_ptr( ps->cs.lpCreateParams );
-        cs.hInstance      = unpack_ptr( ps->cs.hInstance );
-        cs.hMenu          = unpack_handle( ps->cs.hMenu );
-        cs.hwndParent     = unpack_handle( ps->cs.hwndParent );
-        cs.cy             = ps->cs.cy;
-        cs.cx             = ps->cs.cx;
-        cs.y              = ps->cs.y;
-        cs.x              = ps->cs.x;
-        cs.style          = ps->cs.style;
-        cs.dwExStyle      = ps->cs.dwExStyle;
-        cs.lpszName       = unpack_ptr( ps->cs.lpszName );
-        cs.lpszClass      = unpack_ptr( ps->cs.lpszClass );
-        if (ps->cs.lpszName >> 16)
-        {
-            if (!check_string( str, size )) return FALSE;
-            cs.lpszName = str;
-            size -= (lstrlenW(str) + 1) * sizeof(WCHAR);
-            str += lstrlenW(str) + 1;
-        }
-        if (ps->cs.lpszClass >> 16)
-        {
-            if (!check_string( str, size )) return FALSE;
-            cs.lpszClass = str;
-        }
-        memcpy( &ps->cs, &cs, sizeof(cs) );
-        break;
-    }
-    case WM_GETTEXT:
-    case WM_ASKCBFORMATNAME:
-        if (!get_buffer_space( buffer, (*wparam * sizeof(WCHAR)), size )) return FALSE;
-        break;
-    case WM_WININICHANGE:
-        if (!*lparam) return TRUE;
-        /* fall through */
-    case WM_SETTEXT:
-    case WM_DEVMODECHANGE:
-    case CB_DIR:
-    case LB_DIR:
-    case LB_ADDFILE:
-    case EM_REPLACESEL:
-        if (!check_string( *buffer, size )) return FALSE;
-        break;
-    case WM_GETMINMAXINFO:
-        minsize = sizeof(MINMAXINFO);
-        break;
-    case WM_DRAWITEM:
-    {
-        DRAWITEMSTRUCT dis;
-        if (size < sizeof(ps->dis)) return FALSE;
-        dis.CtlType    = ps->dis.CtlType;
-        dis.CtlID      = ps->dis.CtlID;
-        dis.itemID     = ps->dis.itemID;
-        dis.itemAction = ps->dis.itemAction;
-        dis.itemState  = ps->dis.itemState;
-        dis.hwndItem   = unpack_handle( ps->dis.hwndItem );
-        dis.hDC        = unpack_handle( ps->dis.hDC );
-        dis.rcItem     = ps->dis.rcItem;
-        dis.itemData   = (ULONG_PTR)unpack_ptr( ps->dis.itemData );
-        memcpy( &ps->dis, &dis, sizeof(dis) );
-        break;
-    }
-    case WM_MEASUREITEM:
-    {
-        MEASUREITEMSTRUCT mis;
-        if (size < sizeof(ps->mis)) return FALSE;
-        mis.CtlType    = ps->mis.CtlType;
-        mis.CtlID      = ps->mis.CtlID;
-        mis.itemID     = ps->mis.itemID;
-        mis.itemWidth  = ps->mis.itemWidth;
-        mis.itemHeight = ps->mis.itemHeight;
-        mis.itemData   = (ULONG_PTR)unpack_ptr( ps->mis.itemData );
-        memcpy( &ps->mis, &mis, sizeof(mis) );
-        break;
-    }
-    case WM_DELETEITEM:
-    {
-        DELETEITEMSTRUCT dls;
-        if (size < sizeof(ps->dls)) return FALSE;
-        dls.CtlType    = ps->dls.CtlType;
-        dls.CtlID      = ps->dls.CtlID;
-        dls.itemID     = ps->dls.itemID;
-        dls.hwndItem   = unpack_handle( ps->dls.hwndItem );
-        dls.itemData   = (ULONG_PTR)unpack_ptr( ps->dls.itemData );
-        memcpy( &ps->dls, &dls, sizeof(dls) );
-        break;
-    }
-    case WM_COMPAREITEM:
-    {
-        COMPAREITEMSTRUCT cis;
-        if (size < sizeof(ps->cis)) return FALSE;
-        cis.CtlType    = ps->cis.CtlType;
-        cis.CtlID      = ps->cis.CtlID;
-        cis.hwndItem   = unpack_handle( ps->cis.hwndItem );
-        cis.itemID1    = ps->cis.itemID1;
-        cis.itemData1  = (ULONG_PTR)unpack_ptr( ps->cis.itemData1 );
-        cis.itemID2    = ps->cis.itemID2;
-        cis.itemData2  = (ULONG_PTR)unpack_ptr( ps->cis.itemData2 );
-        cis.dwLocaleId = ps->cis.dwLocaleId;
-        memcpy( &ps->cis, &cis, sizeof(cis) );
-        break;
-    }
-    case WM_WINDOWPOSCHANGING:
-    case WM_WINDOWPOSCHANGED:
-    {
-        WINDOWPOS wp;
-        if (size < sizeof(ps->wp)) return FALSE;
-        wp.hwnd            = unpack_handle( ps->wp.hwnd );
-        wp.hwndInsertAfter = unpack_handle( ps->wp.hwndInsertAfter );
-        wp.x               = ps->wp.x;
-        wp.y               = ps->wp.y;
-        wp.cx              = ps->wp.cx;
-        wp.cy              = ps->wp.cy;
-        wp.flags           = ps->wp.flags;
-        memcpy( &ps->wp, &wp, sizeof(wp) );
-        break;
-    }
-    case WM_COPYDATA:
-    {
-        COPYDATASTRUCT cds;
-        if (size < sizeof(ps->cds)) return FALSE;
-        cds.dwData = (ULONG_PTR)unpack_ptr( ps->cds.dwData );
-        if (ps->cds.lpData)
-        {
-            cds.cbData = ps->cds.cbData;
-            cds.lpData = &ps->cds + 1;
-            minsize = sizeof(ps->cds) + cds.cbData;
-        }
-        else
-        {
-            cds.cbData = 0;
-            cds.lpData = 0;
-        }
-        memcpy( &ps->cds, &cds, sizeof(cds) );
-        break;
-    }
-    case WM_NOTIFY:
-        /* WM_NOTIFY cannot be sent across processes (MSDN) */
+        WIN_ReleasePtr( wndPtr );
         return FALSE;
-    case WM_HELP:
-    {
-        HELPINFO hi;
-        if (size < sizeof(ps->hi)) return FALSE;
-        hi.cbSize       = sizeof(hi);
-        hi.iContextType = ps->hi.iContextType;
-        hi.iCtrlId      = ps->hi.iCtrlId;
-        hi.hItemHandle  = unpack_handle( ps->hi.hItemHandle );
-        hi.dwContextId  = (ULONG_PTR)unpack_ptr( ps->hi.dwContextId );
-        hi.MousePos     = ps->hi.MousePos;
-        memcpy( &ps->hi, &hi, sizeof(hi) );
-        break;
     }
-    case WM_STYLECHANGING:
-    case WM_STYLECHANGED:
-        minsize = sizeof(STYLESTRUCT);
-        break;
-    case WM_NCCALCSIZE:
-        if (!*wparam) minsize = sizeof(RECT);
-        else
-        {
-            NCCALCSIZE_PARAMS ncp;
-            WINDOWPOS wp;
-            if (size < sizeof(ps->ncp)) return FALSE;
-            ncp.rgrc[0]        = ps->ncp.rgrc[0];
-            ncp.rgrc[1]        = ps->ncp.rgrc[1];
-            ncp.rgrc[2]        = ps->ncp.rgrc[2];
-            wp.hwnd            = unpack_handle( ps->ncp.hwnd );
-            wp.hwndInsertAfter = unpack_handle( ps->ncp.hwndInsertAfter );
-            wp.x               = ps->ncp.x;
-            wp.y               = ps->ncp.y;
-            wp.cx              = ps->ncp.cx;
-            wp.cy              = ps->ncp.cy;
-            wp.flags           = ps->ncp.flags;
-            ncp.lppos = (WINDOWPOS *)((NCCALCSIZE_PARAMS *)&ps->ncp + 1);
-            memcpy( &ps->ncp, &ncp, sizeof(ncp) );
-            *ncp.lppos = wp;
-        }
-        break;
-    case WM_GETDLGCODE:
-        if (*lparam)
-        {
-            MSG msg;
-            if (size < sizeof(ps->msg)) return FALSE;
-            msg.hwnd    = unpack_handle( ps->msg.hwnd );
-            msg.message = ps->msg.message;
-            msg.wParam  = (ULONG_PTR)unpack_ptr( ps->msg.wParam );
-            msg.lParam  = (ULONG_PTR)unpack_ptr( ps->msg.lParam );
-            msg.time    = ps->msg.time;
-            msg.pt      = ps->msg.pt;
-            memcpy( &ps->msg, &msg, sizeof(msg) );
-            break;
-        }
-        return TRUE;
-    case SBM_SETSCROLLINFO:
-        minsize = sizeof(SCROLLINFO);
-        break;
-    case SBM_GETSCROLLINFO:
-        if (!get_buffer_space( buffer, sizeof(SCROLLINFO), size )) return FALSE;
-        break;
-    case SBM_GETSCROLLBARINFO:
-        if (!get_buffer_space( buffer, sizeof(SCROLLBARINFO), size )) return FALSE;
-        break;
-    case EM_GETSEL:
-    case SBM_GETRANGE:
-    case CB_GETEDITSEL:
-        if (*wparam || *lparam)
-        {
-            if (!get_buffer_space( buffer, 2*sizeof(DWORD), size )) return FALSE;
-            if (*wparam) *wparam = (WPARAM)*buffer;
-            if (*lparam) *lparam = (LPARAM)((DWORD *)*buffer + 1);
-        }
-        return TRUE;
-    case EM_GETRECT:
-    case LB_GETITEMRECT:
-    case CB_GETDROPPEDCONTROLRECT:
-        if (!get_buffer_space( buffer, sizeof(RECT), size )) return FALSE;
-        break;
-    case EM_SETRECT:
-    case EM_SETRECTNP:
-        minsize = sizeof(RECT);
-        break;
-    case EM_GETLINE:
-    {
-        WORD len;
-        if (size < sizeof(WORD)) return FALSE;
-        len = *(WORD *)*buffer;
-        if (!get_buffer_space( buffer, (len + 1) * sizeof(WCHAR), size )) return FALSE;
-        *lparam = (LPARAM)*buffer + sizeof(WORD);  /* don't erase WORD at start of buffer */
-        return TRUE;
-    }
-    case EM_SETTABSTOPS:
-    case LB_SETTABSTOPS:
-        if (!*wparam) return TRUE;
-        minsize = *wparam * sizeof(UINT);
-        break;
-    case CB_ADDSTRING:
-    case CB_INSERTSTRING:
-    case CB_FINDSTRING:
-    case CB_FINDSTRINGEXACT:
-    case CB_SELECTSTRING:
-    case LB_ADDSTRING:
-    case LB_INSERTSTRING:
-    case LB_FINDSTRING:
-    case LB_FINDSTRINGEXACT:
-    case LB_SELECTSTRING:
-        if (!*buffer) return TRUE;
-        if (!check_string( *buffer, size )) return FALSE;
-        break;
-    case CB_GETLBTEXT:
-    {
-        size = sizeof(ULONG_PTR);
-        if (combobox_has_strings( hwnd ))
-            size = (SendMessageW( hwnd, CB_GETLBTEXTLEN, *wparam, 0 ) + 1) * sizeof(WCHAR);
-        if (!get_buffer_space( buffer, size, prev_size )) return FALSE;
-        break;
-    }
-    case LB_GETTEXT:
+    params.func = wndPtr->winproc;
+    proc = handle_to_proc( wndPtr->winproc );
+    params.ansi_dst = !(wndPtr->flags & WIN_ISUNICODE);
+    params.is_dialog = wndPtr->dlgInfo != NULL;
+    WIN_ReleasePtr( wndPtr );
+
+    params.hwnd = WIN_GetFullHandle( hwnd );
+    params.msg = msg;
+    params.wparam = wParam;
+    params.lparam = lParam;
+    params.result = result;
+    params.ansi = !unicode;
+    params.mapping = mapping;
+    params.dpi_awareness = GetWindowDpiAwarenessContext( params.hwnd );
+
+    if (!proc)
     {
-        size = sizeof(ULONG_PTR);
-        if (listbox_has_strings( hwnd ))
-            size = (SendMessageW( hwnd, LB_GETTEXTLEN, *wparam, 0 ) + 1) * sizeof(WCHAR);
-        if (!get_buffer_space( buffer, size, prev_size )) return FALSE;
-        break;
+        params.procW = params.procA = NULL;
     }
-    case LB_GETSELITEMS:
-        if (!get_buffer_space( buffer, *wparam * sizeof(UINT), size )) return FALSE;
-        break;
-    case WM_NEXTMENU:
+    else if (proc == WINPROC_PROC16)
     {
-        MDINEXTMENU mnm;
-        if (size < sizeof(ps->mnm)) return FALSE;
-        mnm.hmenuIn   = unpack_handle( ps->mnm.hmenuIn );
-        mnm.hmenuNext = unpack_handle( ps->mnm.hmenuNext );
-        mnm.hwndNext  = unpack_handle( ps->mnm.hwndNext );
-        memcpy( &ps->mnm, &mnm, sizeof(mnm) );
-        break;
+        params.procW = params.procA = WINPROC_PROC16;
     }
-    case WM_SIZING:
-    case WM_MOVING:
-        minsize = sizeof(RECT);
-        if (!get_buffer_space( buffer, sizeof(RECT), size )) return FALSE;
-        break;
-    case WM_MDICREATE:
+    else
     {
-        MDICREATESTRUCTW mcs;
-        WCHAR *str = (WCHAR *)(&ps->mcs + 1);
-        if (size < sizeof(ps->mcs)) return FALSE;
-        size -= sizeof(ps->mcs);
-
-        mcs.szClass = unpack_ptr( ps->mcs.szClass );
-        mcs.szTitle = unpack_ptr( ps->mcs.szTitle );
-        mcs.hOwner  = unpack_ptr( ps->mcs.hOwner );
-        mcs.x       = ps->mcs.x;
-        mcs.y       = ps->mcs.y;
-        mcs.cx      = ps->mcs.cx;
-        mcs.cy      = ps->mcs.cy;
-        mcs.style   = ps->mcs.style;
-        mcs.lParam  = (LPARAM)unpack_ptr( ps->mcs.lParam );
-        if (ps->mcs.szClass >> 16)
-        {
-            if (!check_string( str, size )) return FALSE;
-            mcs.szClass = str;
-            size -= (lstrlenW(str) + 1) * sizeof(WCHAR);
-            str += lstrlenW(str) + 1;
-        }
-        if (ps->mcs.szTitle >> 16)
-        {
-            if (!check_string( str, size )) return FALSE;
-            mcs.szTitle = str;
-        }
-        memcpy( &ps->mcs, &mcs, sizeof(mcs) );
-        break;
+        params.procA = proc->procA;
+        params.procW = proc->procW;
     }
-    case WM_MDIGETACTIVE:
-        if (!*lparam) return TRUE;
-        if (!get_buffer_space( buffer, sizeof(BOOL), size )) return FALSE;
-        break;
-    case WM_DEVICECHANGE:
-        if (!(*wparam & 0x8000)) return TRUE;
-        minsize = sizeof(DEV_BROADCAST_HDR);
-        break;
-    case WM_NCPAINT:
-        if (*wparam <= 1) return TRUE;
-        FIXME( "WM_NCPAINT hdc unpacking not supported\n" );
-        return FALSE;
-    case WM_PAINT:
-        if (!*wparam) return TRUE;
-        /* fall through */
 
-    /* these contain an HFONT */
-    case WM_SETFONT:
-    case WM_GETFONT:
-    /* these contain an HDC */
-    case WM_ERASEBKGND:
-    case WM_ICONERASEBKGND:
-    case WM_CTLCOLORMSGBOX:
-    case WM_CTLCOLOREDIT:
-    case WM_CTLCOLORLISTBOX:
-    case WM_CTLCOLORBTN:
-    case WM_CTLCOLORDLG:
-    case WM_CTLCOLORSCROLLBAR:
-    case WM_CTLCOLORSTATIC:
-    case WM_PRINT:
-    case WM_PRINTCLIENT:
-    /* these contain an HGLOBAL */
-    case WM_PAINTCLIPBOARD:
-    case WM_SIZECLIPBOARD:
-    /* these contain HICON */
-    case WM_GETICON:
-    case WM_SETICON:
-    case WM_QUERYDRAGICON:
-    case WM_QUERYPARKICON:
-    /* these contain pointers */
-    case WM_DROPOBJECT:
-    case WM_QUERYDROPOBJECT:
-    case WM_DRAGLOOP:
-    case WM_DRAGSELECT:
-    case WM_DRAGMOVE:
-        FIXME( "msg %x (%s) not supported yet\n", message, SPY_GetMsgName(message, hwnd) );
-        return FALSE;
+    if (thread_info->recursion_count > MAX_WINPROC_RECURSION) return FALSE;
+    thread_info->recursion_count++;
 
-    default:
-        return TRUE; /* message doesn't need any unpacking */
-    }
+    dispatch_win_proc_params( &params );
 
-    /* default exit for most messages: check minsize and store buffer in lparam */
-    if (size < minsize) return FALSE;
-    *lparam = (LPARAM)*buffer;
+    thread_info->recursion_count--;
     return TRUE;
 }
 
-BOOL WINAPI User32CallWindowProc( struct win_proc_params *params, ULONG size )
-{
-
-    if (params->needs_unpack)
-    {
-        char stack_buffer[128];
-        void *buffer;
-        LRESULT result;
-        MSG msg;
 
-        if (size > sizeof(*params))
-        {
-            size -= sizeof(*params);
-            buffer = params + 1;
-        }
-        else
-        {
-            size = sizeof(stack_buffer);
-            buffer = stack_buffer;
-        }
-        if (!unpack_message( params->hwnd, params->msg, &params->wparam,
-                             &params->lparam, &buffer, size ))
-            return 0;
-        params->result = &result;
-
-        msg.hwnd    = params->hwnd;
-        msg.message = params->msg;
-        msg.wParam  = params->wparam;
-        msg.lParam  = params->lparam;
-        dispatch_win_proc_params( params );
-
-        NtUserReplyMessage( result, &msg );
-        if (buffer != stack_buffer && buffer != params + 1)
-            HeapFree( GetProcessHeap(), 0, buffer );
-    }
-    else dispatch_win_proc_params( params );
-    return TRUE;
-}
-
-void get_winproc_params( struct win_proc_params *params )
+static void init_win_proc_params( struct win_proc_params *info, WNDPROC func, HWND hwnd, UINT msg,
+                                  WPARAM wparam, LPARAM lparam, LRESULT *result, BOOL ansi )
 {
-    WINDOWPROC *proc = handle_to_proc( params->func );
+    WINDOWPROC *proc;
 
-    if (!proc)
+    USER_CheckNotLock();
+
+    info->hwnd = WIN_GetFullHandle( hwnd );
+    info->msg = msg;
+    info->wparam = wparam;
+    info->lparam = lparam;
+    info->result = result;
+    info->ansi = info->ansi_dst = ansi;
+    info->is_dialog = FALSE;
+    info->mapping = WMCHAR_MAP_CALLWINDOWPROC;
+    info->dpi_awareness = GetWindowDpiAwarenessContext( info->hwnd );
+    info->func = func;
+
+    if (!(proc = handle_to_proc( func )))
     {
-        params->procW = params->procA = NULL;
+        info->procW = info->procA = NULL;
     }
     else if (proc == WINPROC_PROC16)
     {
-        params->procW = params->procA = WINPROC_PROC16;
+        info->procW = info->procA = WINPROC_PROC16;
     }
     else
     {
-        params->procA = proc->procA;
-        params->procW = proc->procW;
+        info->procA = proc->procA;
+        info->procW = proc->procW;
     }
 }
 
-BOOL WINAPI User32CallSendAsyncCallback( const struct send_async_params *params, ULONG size )
-{
-    params->callback( params->hwnd, params->msg, params->data, params->result );
-    return TRUE;
-}
 
 /**********************************************************************
  *		CallWindowProcA (USER32.@)
@@ -1330,10 +953,8 @@ LRESULT WINAPI CallWindowProcA( WNDPROC func, HWND hwnd, UINT msg, WPARAM wParam
     struct win_proc_params params;
     LRESULT result;
 
-    params.func = func;
-    params.result = &result;
-    if (!NtUserMessageCall( hwnd, msg, wParam, lParam, &params, NtUserCallWindowProc, TRUE ))
-        return 0;
+    if (!func) return 0;
+    init_win_proc_params( &params, func, hwnd, msg, wParam, lParam, &result, TRUE );
     dispatch_win_proc_params( &params );
     return result;
 }
@@ -1349,10 +970,8 @@ LRESULT WINAPI CallWindowProcW( WNDPROC func, HWND hwnd, UINT msg, WPARAM wParam
     struct win_proc_params params;
     LRESULT result;
 
-    params.func = func;
-    params.result = &result;
-    if (!NtUserMessageCall( hwnd, msg, wParam, lParam, &params, NtUserCallWindowProc, FALSE ))
-        return 0;
+    if (!func) return 0;
+    init_win_proc_params( &params, func, hwnd, msg, wParam, lParam, &result, FALSE );
     dispatch_win_proc_params( &params );
     return result;
 }
@@ -1482,6 +1101,14 @@ static LRESULT WINAPI StaticWndProcW( HWND hwnd, UINT msg, WPARAM wParam, LPARAM
     return wow_handlers.static_proc( hwnd, msg, wParam, lParam, TRUE );
 }
 
+static DWORD wait_message( DWORD count, const HANDLE *handles, DWORD timeout, DWORD mask, DWORD flags )
+{
+    DWORD ret = USER_Driver->pMsgWaitForMultipleObjectsEx( count, handles, timeout, mask, flags );
+    if (ret == WAIT_TIMEOUT && !count && !timeout) NtYieldExecution();
+    if ((mask & QS_INPUT) == QS_INPUT) get_user_thread_info()->message_count = 0;
+    return ret;
+}
+
 /**********************************************************************
  *		UserRegisterWowHandlers (USER32.@)
  *
@@ -1497,6 +1124,7 @@ void WINAPI UserRegisterWowHandlers( const struct wow_handlers16 *new, struct wo
     orig->mdiclient_proc  = MDIClientWndProc_common;
     orig->scrollbar_proc  = ScrollBarWndProc_common;
     orig->static_proc     = StaticWndProc_common;
+    orig->wait_message    = wait_message;
     orig->create_window   = WIN_CreateWindowEx;
     orig->get_win_handle  = WIN_GetFullHandle;
     orig->alloc_winproc   = WINPROC_AllocProc;
@@ -1515,6 +1143,7 @@ struct wow_handlers16 wow_handlers =
     MDIClientWndProc_common,
     ScrollBarWndProc_common,
     StaticWndProc_common,
+    wait_message,
     WIN_CreateWindowEx,
     NULL,  /* call_window_proc */
     NULL,  /* call_dialog_proc */
diff --git a/dlls/win32u/Makefile.in b/dlls/win32u/Makefile.in
index d58ed6bb41c..2dea3682064 100644
--- a/dlls/win32u/Makefile.in
+++ b/dlls/win32u/Makefile.in
@@ -18,7 +18,6 @@ C_SRCS = \
 	cursoricon.c \
 	dc.c \
 	dce.c \
-	defwnd.c \
 	dib.c \
 	dibdrv/bitblt.c \
 	dibdrv/dc.c \
@@ -44,7 +43,6 @@ C_SRCS = \
 	pen.c \
 	printdrv.c \
 	region.c \
-	spy.c \
 	syscall.c \
 	sysparams.c \
 	vertical.c \
diff --git a/dlls/win32u/bitblt.c b/dlls/win32u/bitblt.c
index 302a3ef77eb..d7bbd353b2d 100644
--- a/dlls/win32u/bitblt.c
+++ b/dlls/win32u/bitblt.c
@@ -48,18 +48,18 @@ BOOL intersect_vis_rectangles( struct bitblt_coords *dst, struct bitblt_coords *
 
     if ((src->width == dst->width) && (src->height == dst->height)) /* no stretching */
     {
-        OffsetRect( &src->visrect, dst->x - src->x, dst->y - src->y );
+        offset_rect( &src->visrect, dst->x - src->x, dst->y - src->y );
         if (!intersect_rect( &rect, &src->visrect, &dst->visrect )) return FALSE;
         src->visrect = dst->visrect = rect;
-        OffsetRect( &src->visrect, src->x - dst->x, src->y - dst->y );
+        offset_rect( &src->visrect, src->x - dst->x, src->y - dst->y );
     }
     else  /* stretching */
     {
         /* map source rectangle into destination coordinates */
         rect = src->visrect;
-        OffsetRect( &rect,
-                    -src->x - (src->width < 0 ? 1 : 0),
-                    -src->y - (src->height < 0 ? 1 : 0) );
+        offset_rect( &rect,
+                     -src->x - (src->width < 0 ? 1 : 0),
+                     -src->y - (src->height < 0 ? 1 : 0));
         rect.left   = rect.left * dst->width / src->width;
         rect.top    = rect.top * dst->height / src->height;
         rect.right  = rect.right * dst->width / src->width;
@@ -82,7 +82,7 @@ BOOL intersect_vis_rectangles( struct bitblt_coords *dst, struct bitblt_coords *
                  (src->y < src->visrect.top || src->y + src->height > src->visrect.bottom))
             dst->y -= rect.bottom - (dst->height - rect.top);
 
-        OffsetRect( &rect, dst->x, dst->y );
+        offset_rect( &rect, dst->x, dst->y );
 
         /* avoid rounding errors */
         rect.left--;
@@ -93,9 +93,9 @@ BOOL intersect_vis_rectangles( struct bitblt_coords *dst, struct bitblt_coords *
 
         /* map destination rectangle back to source coordinates */
         rect = dst->visrect;
-        OffsetRect( &rect,
-                    -dst->x - (dst->width < 0 ? 1 : 0),
-                    -dst->y - (dst->height < 0 ? 1 : 0) );
+        offset_rect( &rect,
+                     -dst->x - (dst->width < 0 ? 1 : 0),
+                     -dst->y - (dst->height < 0 ? 1 : 0));
         rect.left   = src->x + rect.left * src->width / dst->width;
         rect.top    = src->y + rect.top * src->height / dst->height;
         rect.right  = src->x + rect.right * src->width / dst->width;
@@ -139,7 +139,7 @@ static BOOL get_vis_rectangles( DC *dc_dst, struct bitblt_coords *dst,
 
     /* get the source visible rectangle */
 
-    if (!src) return !IsRectEmpty( &dst->visrect );
+    if (!src) return !is_rect_empty( &dst->visrect );
 
     rect.left   = src->log_x;
     rect.top    = src->log_y;
@@ -158,7 +158,7 @@ static BOOL get_vis_rectangles( DC *dc_dst, struct bitblt_coords *dst,
     get_bounding_rect( &rect, src->x, src->y, src->width, src->height );
 
     if (!clip_device_rect( dc_src, &src->visrect, &rect )) return FALSE;
-    if (IsRectEmpty( &dst->visrect )) return FALSE;
+    if (is_rect_empty( &dst->visrect )) return FALSE;
 
     return intersect_vis_rectangles( dst, src );
 }
@@ -479,7 +479,7 @@ BOOL CDECL nulldrv_GradientFill( PHYSDEV dev, TRIVERTEX *vert_array, ULONG nvert
     src = dst;
     src.x -= dst.visrect.left;
     src.y -= dst.visrect.top;
-    OffsetRect( &src.visrect, -dst.visrect.left, -dst.visrect.top );
+    offset_rect( &src.visrect, -dst.visrect.left, -dst.visrect.top );
     for (i = 0; i < nvert; i++)
     {
         pts[i].x -= dst.visrect.left;
@@ -789,7 +789,7 @@ BOOL WINAPI NtGdiMaskBlt( HDC hdcDest, INT nXDest, INT nYDest, INT nWidth, INT n
                             nXSrc, nYSrc, FRGND_ROP3(dwRop), bk_color, 0 );
 
     hbrMask = NtGdiCreatePatternBrushInternal( hbmMask, FALSE, FALSE );
-    hbrDst = NtGdiSelectBrush( hdcDest, GetStockObject(NULL_BRUSH) );
+    hbrDst = NtGdiSelectBrush( hdcDest, get_stock_object(NULL_BRUSH) );
 
     /* make bitmap */
     hDC1 = NtGdiCreateCompatibleDC( hdcDest );
@@ -992,7 +992,7 @@ BOOL WINAPI NtGdiAlphaBlend( HDC hdcDst, int xDst, int yDst, int widthDst, int h
 
         if (src.x < 0 || src.y < 0 || src.width < 0 || src.height < 0 ||
             src.log_width < 0 || src.log_height < 0 ||
-            (!IsRectEmpty( &dcSrc->device_rect ) &&
+            (!is_rect_empty( &dcSrc->device_rect ) &&
              (src.width > dcSrc->device_rect.right - dcSrc->attr->vis_rect.left - src.x ||
               src.height > dcSrc->device_rect.bottom - dcSrc->attr->vis_rect.top - src.y)))
         {
diff --git a/dlls/win32u/bitmap.c b/dlls/win32u/bitmap.c
index 5d93ee69ee0..2be88715948 100644
--- a/dlls/win32u/bitmap.c
+++ b/dlls/win32u/bitmap.c
@@ -391,7 +391,7 @@ HGDIOBJ WINAPI NtGdiSelectBitmap( HDC hdc, HGDIOBJ handle )
         goto done;
     }
 
-    if (handle != GetStockObject( DEFAULT_BITMAP ) && GDI_get_ref_count( handle ))
+    if (handle != get_stock_object( DEFAULT_BITMAP ) && GDI_get_ref_count( handle ))
     {
         WARN( "Bitmap already selected in another DC\n" );
         GDI_ReleaseObj( handle );
diff --git a/dlls/win32u/class.c b/dlls/win32u/class.c
index 1a6c92edc3a..657ccd03ebd 100644
--- a/dlls/win32u/class.c
+++ b/dlls/win32u/class.c
@@ -37,28 +37,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(class);
 WINE_DECLARE_DEBUG_CHANNEL(win);
 
 #define MAX_WINPROCS  4096
-#define WINPROC_PROC16  ((void *)1)  /* placeholder for 16-bit window procs */
-
-typedef struct tagCLASS
-{
-    struct list  entry;         /* Entry in class list */
-    UINT         style;         /* Class style */
-    BOOL         local;         /* Local class? */
-    WNDPROC      winproc;       /* Window procedure */
-    INT          cbClsExtra;    /* Class extra bytes */
-    INT          cbWndExtra;    /* Window extra bytes */
-    struct dce  *dce;           /* Opaque pointer to class DCE */
-    UINT_PTR     instance;      /* Module that created the task */
-    HICON        hIcon;         /* Default icon */
-    HICON        hIconSm;       /* Default small icon */
-    HICON        hIconSmIntern; /* Internal small icon, derived from hIcon */
-    HCURSOR      hCursor;       /* Default cursor */
-    HBRUSH       hbrBackground; /* Default background */
-    ATOM         atomName;      /* Name of the class */
-    WCHAR        name[MAX_ATOM_LEN + 1];
-    WCHAR       *basename;      /* Base name for redirected classes, pointer within 'name'. */
-    struct client_menu_name menu_name; /* Default menu name */
-} CLASS;
+#define WINPROC_PROC16  ((WINDOWPROC *)1)  /* placeholder for 16-bit window procs */
 
 static WINDOWPROC winproc_array[MAX_WINPROCS];
 static UINT winproc_used = NB_BUILTIN_WINPROCS;
@@ -66,7 +45,7 @@ static pthread_mutex_t winproc_lock = PTHREAD_MUTEX_INITIALIZER;
 
 static struct list class_list = LIST_INIT( class_list );
 
-HINSTANCE user32_module = 0;
+static HINSTANCE user32_module;
 
 /* find an existing winproc for a given function and type */
 /* FIXME: probably should do something more clever than a linear search */
@@ -184,25 +163,6 @@ BOOL is_winproc_unicode( WNDPROC proc, BOOL def_val )
     return ptr->procW != NULL;
 }
 
-void get_winproc_params( struct win_proc_params *params )
-{
-    WINDOWPROC *proc = get_winproc_ptr( params->func );
-
-    if (!proc)
-    {
-        params->procW = params->procA = NULL;
-    }
-    else if (proc == WINPROC_PROC16)
-    {
-        params->procW = params->procA = WINPROC_PROC16;
-    }
-    else
-    {
-        params->procA = proc->procA;
-        params->procW = proc->procW;
-    }
-}
-
 /***********************************************************************
  *	     NtUserInitializeClientPfnArrays   (win32u.@)
  */
@@ -323,14 +283,6 @@ static CLASS *find_class( HINSTANCE module, UNICODE_STRING *name )
     return NULL;
 }
 
-/***********************************************************************
- *           get_class_winproc
- */
-WNDPROC get_class_winproc( CLASS *class )
-{
-    return class->winproc;
-}
-
 /***********************************************************************
  *           get_class_dce
  */
@@ -443,12 +395,12 @@ ATOM WINAPI NtUserRegisterClassExWOW( const WNDCLASSEXW *wc, UNICODE_STRING *nam
     class->hCursor       = wc->hCursor;
     class->hbrBackground = wc->hbrBackground;
     class->winproc       = alloc_winproc( wc->lpfnWndProc, ansi );
-    if (client_menu_name) class->menu_name = *client_menu_name;
-    if (wc->hIcon && !wc->hIconSm)
-        class->hIconSmIntern = CopyImage( wc->hIcon, IMAGE_ICON,
-                                          get_system_metrics( SM_CXSMICON ),
-                                          get_system_metrics( SM_CYSMICON ),
-                                          LR_COPYFROMRESOURCE );
+    class->menu_name     = *client_menu_name;
+    if (wc->hIcon && !wc->hIconSm && user_callbacks)
+        class->hIconSmIntern = user_callbacks->pCopyImage( wc->hIcon, IMAGE_ICON,
+                                                           get_system_metrics( SM_CXSMICON ),
+                                                           get_system_metrics( SM_CYSMICON ),
+                                                           LR_COPYFROMRESOURCE );
     release_class_ptr( class );
     return atom;
 }
@@ -699,20 +651,20 @@ static ULONG_PTR set_class_long( HWND hwnd, INT offset, LONG_PTR newval, UINT si
             NtUserDestroyCursor( class->hIconSmIntern, 0 );
             class->hIconSmIntern = NULL;
         }
-        if (newval && !class->hIconSm)
-            class->hIconSmIntern = CopyImage( (HICON)newval, IMAGE_ICON,
-                                              get_system_metrics( SM_CXSMICON ),
-                                              get_system_metrics( SM_CYSMICON ),
-                                              LR_COPYFROMRESOURCE );
+        if (newval && !class->hIconSm && user_callbacks)
+            class->hIconSmIntern = user_callbacks->pCopyImage( (HICON)newval, IMAGE_ICON,
+                                                               get_system_metrics( SM_CXSMICON ),
+                                                               get_system_metrics( SM_CYSMICON ),
+                      LR_COPYFROMRESOURCE );
         class->hIcon = (HICON)newval;
         break;
     case GCLP_HICONSM:
         retval = (ULONG_PTR)class->hIconSm;
-        if (retval && !newval && class->hIcon)
-            class->hIconSmIntern = CopyImage( class->hIcon, IMAGE_ICON,
-                                              get_system_metrics( SM_CXSMICON ),
-                                              get_system_metrics( SM_CYSMICON ),
-                                              LR_COPYFROMRESOURCE );
+        if (retval && !newval && class->hIcon && user_callbacks)
+            class->hIconSmIntern = user_callbacks->pCopyImage( class->hIcon, IMAGE_ICON,
+                                                               get_system_metrics( SM_CXSMICON ),
+                                                               get_system_metrics( SM_CYSMICON ),
+                                                               LR_COPYFROMRESOURCE );
         else if (newval && class->hIconSmIntern)
         {
             NtUserDestroyCursor( class->hIconSmIntern, 0 );
@@ -972,19 +924,3 @@ WORD get_class_word( HWND hwnd, INT offset )
     release_class_ptr( class );
     return retvalue;
 }
-
-static void register_builtins(void)
-{
-    void *ret_ptr;
-    ULONG ret_len;
-    KeUserModeCallback( NtUserRegisterBuiltinClasses, NULL, 0, &ret_ptr, &ret_len );
-}
-
-/***********************************************************************
- *           register_builtin_classes
- */
-void register_builtin_classes(void)
-{
-    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
-    pthread_once( &init_once, register_builtins );
-}
diff --git a/dlls/win32u/clipboard.c b/dlls/win32u/clipboard.c
index 0ddbc62f444..585a2aae631 100644
--- a/dlls/win32u/clipboard.c
+++ b/dlls/win32u/clipboard.c
@@ -27,30 +27,13 @@
 #pragma makedep unix
 #endif
 
-#include <pthread.h>
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
 #include "win32u_private.h"
-#include "ntgdi_private.h"
 #include "ntuser_private.h"
 #include "wine/server.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
-static pthread_mutex_t clipboard_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-struct cached_format
-{
-    struct list entry;       /* entry in cache list */
-    UINT        format;      /* format id */
-    UINT        seqno;       /* sequence number when the data was set */
-    HANDLE      handle;      /* original data handle */
-};
-
-static struct list cached_formats = LIST_INIT( cached_formats );
-static struct list formats_to_free = LIST_INIT( formats_to_free );
-
 
 /* get a debug string for a format id */
 static const char *debugstr_format( UINT id )
@@ -93,167 +76,6 @@ static const char *debugstr_format( UINT id )
     }
 }
 
-/* retrieve a data format from the cache */
-static struct cached_format *get_cached_format( UINT format )
-{
-    struct cached_format *cache;
-
-    LIST_FOR_EACH_ENTRY( cache, &cached_formats, struct cached_format, entry )
-        if (cache->format == format) return cache;
-    return NULL;
-}
-
-/* free a single cached format */
-static void free_cached_data( struct cached_format *cache )
-{
-    struct free_cached_data_params params;
-    void *ret_ptr;
-    ULONG ret_len;
-
-    switch (cache->format)
-    {
-    case CF_BITMAP:
-    case CF_PALETTE:
-        make_gdi_object_system( cache->handle, FALSE );
-    case CF_DSPBITMAP:
-        NtGdiDeleteObjectApp( cache->handle );
-        break;
-
-    default:
-        params.format = cache->format;
-        params.handle = cache->handle;
-        KeUserModeCallback( NtUserFreeCachedClipboardData, &params, sizeof(params),
-                            &ret_ptr, &ret_len );
-        break;
-    }
-    free( cache );
-}
-
-/* free all the data in the cache */
-static void free_cached_formats( struct list *list )
-{
-    struct list *ptr;
-
-    while ((ptr = list_head( list )))
-    {
-        list_remove( ptr );
-        free_cached_data( LIST_ENTRY( ptr, struct cached_format, entry ));
-    }
-}
-
-/* clear global memory formats; special types are freed on EmptyClipboard */
-static void invalidate_memory_formats( struct list *free_list )
-{
-    struct cached_format *cache, *next;
-
-    LIST_FOR_EACH_ENTRY_SAFE( cache, next, &cached_formats, struct cached_format, entry )
-    {
-        switch (cache->format)
-        {
-        case CF_BITMAP:
-        case CF_DSPBITMAP:
-        case CF_PALETTE:
-        case CF_ENHMETAFILE:
-        case CF_DSPENHMETAFILE:
-        case CF_METAFILEPICT:
-        case CF_DSPMETAFILEPICT:
-            continue;
-        default:
-            list_remove( &cache->entry );
-            list_add_tail( free_list, &cache->entry );
-            break;
-        }
-    }
-}
-
-/**************************************************************************
- *           NtUserOpenClipboard    (win32u.@)
- */
-BOOL WINAPI NtUserOpenClipboard( HWND hwnd, ULONG unk )
-{
-    struct list free_list = LIST_INIT( free_list );
-    BOOL ret;
-    HWND owner;
-
-    TRACE( "%p\n", hwnd );
-
-    user_driver->pUpdateClipboard();
-
-    pthread_mutex_lock( &clipboard_mutex );
-
-    SERVER_START_REQ( open_clipboard )
-    {
-        req->window = wine_server_user_handle( hwnd );
-        ret = !wine_server_call_err( req );
-        owner = wine_server_ptr_handle( reply->owner );
-    }
-    SERVER_END_REQ;
-
-    if (ret && !is_current_process_window( owner )) invalidate_memory_formats( &free_list );
-
-    pthread_mutex_unlock( &clipboard_mutex );
-    free_cached_formats( &free_list );
-    return ret;
-}
-
-/**************************************************************************
- *           NtUserCloseClipboard    (win32u.@)
- */
-BOOL WINAPI NtUserCloseClipboard(void)
-{
-    HWND viewer = 0, owner = 0;
-    BOOL ret;
-
-    TRACE( "\n" );
-
-    SERVER_START_REQ( close_clipboard )
-    {
-        if ((ret = !wine_server_call_err( req )))
-        {
-            viewer = wine_server_ptr_handle( reply->viewer );
-            owner = wine_server_ptr_handle( reply->owner );
-        }
-    }
-    SERVER_END_REQ;
-
-    if (viewer) NtUserMessageCall( viewer, WM_DRAWCLIPBOARD, (WPARAM)owner, 0,
-                                   0, NtUserSendNotifyMessage, FALSE );
-    return ret;
-}
-
-/**************************************************************************
- *           NtUserEmptyClipboard    (win32u.@)
- */
-BOOL WINAPI NtUserEmptyClipboard(void)
-{
-    BOOL ret;
-    HWND owner = NtUserGetClipboardOwner();
-    struct list free_list = LIST_INIT( free_list );
-
-    TRACE( "owner %p\n", owner );
-
-    if (owner) send_message_timeout( owner, WM_DESTROYCLIPBOARD, 0, 0, SMTO_ABORTIFHUNG,
-                                     5000, NULL, FALSE );
-
-    pthread_mutex_lock( &clipboard_mutex );
-
-    SERVER_START_REQ( empty_clipboard )
-    {
-        ret = !wine_server_call_err( req );
-    }
-    SERVER_END_REQ;
-
-    if (ret)
-    {
-        list_move_tail( &free_list, &formats_to_free );
-        list_move_tail( &free_list, &cached_formats );
-    }
-
-    pthread_mutex_unlock( &clipboard_mutex );
-    free_cached_formats( &free_list );
-    return ret;
-}
-
 /**************************************************************************
  *           NtUserCountClipboardFormats    (win32u.@)
  */
@@ -384,32 +206,6 @@ HWND WINAPI NtUserGetClipboardOwner(void)
     return owner;
 }
 
-/**************************************************************************
- *           NtUserSetClipboardViewer    (win32u.@)
- */
-HWND WINAPI NtUserSetClipboardViewer( HWND hwnd )
-{
-    HWND prev = 0, owner = 0;
-
-    SERVER_START_REQ( set_clipboard_viewer )
-    {
-        req->viewer = wine_server_user_handle( hwnd );
-        if (!wine_server_call_err( req ))
-        {
-            prev = wine_server_ptr_handle( reply->old_viewer );
-            owner = wine_server_ptr_handle( reply->owner );
-        }
-    }
-    SERVER_END_REQ;
-
-    if (hwnd)
-        NtUserMessageCall( hwnd, WM_DRAWCLIPBOARD, (WPARAM)owner, 0,
-                           NULL, NtUserSendNotifyMessage, FALSE );
-
-    TRACE( "%p returning %p\n", hwnd, prev );
-    return prev;
-}
-
 /**************************************************************************
  *           NtUserGetClipboardViewer    (win32u.@)
  */
@@ -427,32 +223,6 @@ HWND WINAPI NtUserGetClipboardViewer(void)
     return viewer;
 }
 
-/**************************************************************************
- *           NtUserChangeClipboardChain    (win32u.@)
- */
-BOOL WINAPI NtUserChangeClipboardChain( HWND hwnd, HWND next )
-{
-    NTSTATUS status;
-    HWND viewer;
-
-    if (!hwnd) return FALSE;
-
-    SERVER_START_REQ( set_clipboard_viewer )
-    {
-        req->viewer = wine_server_user_handle( next );
-        req->previous = wine_server_user_handle( hwnd );
-        status = wine_server_call( req );
-        viewer = wine_server_ptr_handle( reply->old_viewer );
-    }
-    SERVER_END_REQ;
-
-    if (status == STATUS_PENDING)
-        return !send_message( viewer, WM_CHANGECBCHAIN, (WPARAM)hwnd, (LPARAM)next );
-
-    if (status) SetLastError( RtlNtStatusToDosError( status ));
-    return !status;
-}
-
 /**************************************************************************
  *	     NtUserGetOpenClipboardWindow    (win32u.@)
  */
@@ -487,26 +257,6 @@ DWORD WINAPI NtUserGetClipboardSequenceNumber(void)
     return seqno;
 }
 
-/* see EnumClipboardFormats */
-UINT enum_clipboard_formats( UINT format )
-{
-    UINT ret = 0;
-
-    SERVER_START_REQ( enum_clipboard_formats )
-    {
-        req->previous = format;
-        if (!wine_server_call_err( req ))
-        {
-            ret = reply->format;
-            SetLastError( ERROR_SUCCESS );
-        }
-    }
-    SERVER_END_REQ;
-
-    TRACE( "%s -> %s\n", debugstr_format( format ), debugstr_format( ret ));
-    return ret;
-}
-
 /**************************************************************************
  *	     NtUserAddClipboardFormatListener    (win32u.@)
  */
@@ -561,190 +311,5 @@ void release_clipboard_owner( HWND hwnd )
 
     if (viewer)
         NtUserMessageCall( viewer, WM_DRAWCLIPBOARD, (WPARAM)owner, 0,
-                           0, NtUserSendNotifyMessage, FALSE );
-}
-
-/**************************************************************************
- *           NtUserSetClipboardData    (win32u.@)
- */
-NTSTATUS WINAPI NtUserSetClipboardData( UINT format, HANDLE data, struct set_clipboard_params *params )
-{
-    struct cached_format *cache = NULL, *prev = NULL;
-    void *ptr = NULL;
-    data_size_t size = 0;
-    NTSTATUS status = STATUS_SUCCESS;
-
-    TRACE( "%s %p\n", debugstr_format( format ), data );
-
-    if (params->cache_only)
-    {
-        pthread_mutex_lock( &clipboard_mutex );
-        if ((cache = get_cached_format( format )) && cache->seqno == params->seqno)
-            cache->handle = data;
-        else
-            status = STATUS_UNSUCCESSFUL;
-        pthread_mutex_unlock( &clipboard_mutex );
-        return status;
-    }
-
-    if (params->data)
-    {
-        ptr = params->data;
-        size = params->size;
-        if (data)
-        {
-            if (!(cache = malloc( sizeof(*cache) ))) goto done;
-            cache->format = format;
-            cache->handle = data;
-        }
-
-        if (format == CF_BITMAP || format == CF_PALETTE)
-        {
-            make_gdi_object_system( cache->handle, TRUE );
-        }
-    }
-
-    pthread_mutex_lock( &clipboard_mutex );
-
-    SERVER_START_REQ( set_clipboard_data )
-    {
-        req->format = format;
-        NtQueryDefaultLocale( TRUE, &req->lcid );
-        wine_server_add_data( req, ptr, size );
-        if (!(status = wine_server_call( req )))
-        {
-            if (cache) cache->seqno = reply->seqno;
-        }
-    }
-    SERVER_END_REQ;
-
-    if (!status)
-    {
-        /* free the previous entry if any */
-        if ((prev = get_cached_format( format ))) list_remove( &prev->entry );
-        if (cache) list_add_tail( &cached_formats, &cache->entry );
-    }
-    else free( cache );
-
-    pthread_mutex_unlock( &clipboard_mutex );
-    if (prev) free_cached_data( prev );
-
-done:
-    return status;
-}
-
-/**************************************************************************
- *           NtUserGetClipboardData    (win32u.@)
- */
-HANDLE WINAPI NtUserGetClipboardData( UINT format, struct get_clipboard_params *params )
-{
-    struct cached_format *cache = NULL;
-    NTSTATUS status;
-    UINT from, data_seqno;
-    size_t size;
-    HWND owner;
-    BOOL render = TRUE;
-
-    for (;;)
-    {
-        pthread_mutex_lock( &clipboard_mutex );
-
-        if (!params->data_only) cache = get_cached_format( format );
-
-        SERVER_START_REQ( get_clipboard_data )
-        {
-            req->format = format;
-            req->render = render;
-            if (cache && cache->handle)
-            {
-                req->cached = 1;
-                req->seqno = cache->seqno;
-            }
-            wine_server_set_reply( req, params->data, params->size );
-            status = wine_server_call( req );
-            from = reply->from;
-            size = reply->total;
-            data_seqno = reply->seqno;
-            owner = wine_server_ptr_handle( reply->owner );
-        }
-        SERVER_END_REQ;
-
-        params->size = size;
-
-        if (!status && size)
-        {
-            if (cache)
-            {
-                if (cache->handle && data_seqno == cache->seqno)  /* we can reuse the cached data */
-                {
-                    HANDLE ret = cache->handle;
-                    pthread_mutex_unlock( &clipboard_mutex );
-                    TRACE( "%s returning %p\n", debugstr_format( format ), ret );
-                    return ret;
-                }
-
-                /* cache entry is stale, remove it */
-                list_remove( &cache->entry );
-                list_add_tail( &formats_to_free, &cache->entry );
-            }
-
-            if (params->data_only)
-            {
-                pthread_mutex_unlock( &clipboard_mutex );
-                return params->data;
-            }
-
-            /* allocate new cache entry */
-            if (!(cache = malloc( sizeof(*cache) )))
-            {
-                pthread_mutex_unlock( &clipboard_mutex );
-                return 0;
-            }
-
-            cache->format = format;
-            cache->seqno  = data_seqno;
-            cache->handle = NULL;
-            params->seqno = cache->seqno;
-            list_add_tail( &cached_formats, &cache->entry );
-            pthread_mutex_unlock( &clipboard_mutex );
-            TRACE( "%s needs unmarshaling\n", debugstr_format( format ) );
-            params->data_size = ~0;
-            return 0;
-        }
-        pthread_mutex_unlock( &clipboard_mutex );
-
-        if (status == STATUS_BUFFER_OVERFLOW)
-        {
-            params->data_size = size;
-            return 0;
-        }
-        if (status == STATUS_OBJECT_NAME_NOT_FOUND) return 0; /* no such format */
-        if (status)
-        {
-            SetLastError( RtlNtStatusToDosError( status ));
-            TRACE( "%s error %08x\n", debugstr_format( format ), status );
-            return 0;
-        }
-        if (render)  /* try rendering it */
-        {
-            render = FALSE;
-            if (from)
-            {
-                struct render_synthesized_format_params params = { .format = format, .from = from };
-                ULONG ret_len;
-                void *ret_ptr;
-                KeUserModeCallback( NtUserRenderSynthesizedFormat, &params, sizeof(params),
-                                    &ret_ptr, &ret_len );
-                continue;
-            }
-            if (owner)
-            {
-                TRACE( "%s sending WM_RENDERFORMAT to %p\n", debugstr_format( format ), owner );
-                send_message( owner, WM_RENDERFORMAT, format, 0 );
-                continue;
-            }
-        }
-        TRACE( "%s returning 0\n", debugstr_format( format ));
-        return 0;
-    }
+                           0, FNID_SENDNOTIFYMESSAGE, FALSE );
 }
diff --git a/dlls/win32u/clipping.c b/dlls/win32u/clipping.c
index 11027824362..704d5142855 100644
--- a/dlls/win32u/clipping.c
+++ b/dlls/win32u/clipping.c
@@ -37,8 +37,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(clipping);
 static inline BOOL get_dc_device_rect( DC *dc, RECT *rect )
 {
     *rect = dc->device_rect;
-    OffsetRect( rect, -dc->attr->vis_rect.left, -dc->attr->vis_rect.top );
-    return !IsRectEmpty( rect );
+    offset_rect( rect, -dc->attr->vis_rect.left, -dc->attr->vis_rect.top );
+    return !is_rect_empty( rect );
 }
 
 /***********************************************************************
@@ -201,10 +201,10 @@ INT WINAPI NtGdiExtSelectClipRgn( HDC hdc, HRGN rgn, INT mode )
 }
 
 /***********************************************************************
- *           set_visible_region
+ *           __wine_set_visible_region   (win32u.@)
  */
-void set_visible_region( HDC hdc, HRGN hrgn, const RECT *vis_rect, const RECT *device_rect,
-                         struct window_surface *surface )
+void CDECL __wine_set_visible_region( HDC hdc, HRGN hrgn, const RECT *vis_rect, const RECT *device_rect,
+                                      struct window_surface *surface )
 {
     DC * dc;
 
@@ -377,7 +377,7 @@ INT WINAPI NtGdiGetAppClipBox( HDC hdc, RECT *rect )
     }
     else
     {
-        ret = IsRectEmpty( &dc->attr->vis_rect ) ? ERROR : SIMPLEREGION;
+        ret = is_rect_empty( &dc->attr->vis_rect ) ? ERROR : SIMPLEREGION;
         *rect = dc->attr->vis_rect;
     }
 
@@ -442,7 +442,7 @@ INT WINAPI NtGdiGetRandomRgn( HDC hDC, HRGN hRgn, INT iCode )
             if (NtCurrentTeb()->Peb->OSPlatformId != VER_PLATFORM_WIN32s)
                 NtGdiOffsetRgn( hRgn, dc->attr->vis_rect.left, dc->attr->vis_rect.top );
         }
-        else if (!IsRectEmpty( &dc->device_rect ))
+        else if (!is_rect_empty( &dc->device_rect ))
             NtGdiSetRectRgn( hRgn, dc->device_rect.left, dc->device_rect.top,
                              dc->device_rect.right, dc->device_rect.bottom );
         else
diff --git a/dlls/win32u/cursoricon.c b/dlls/win32u/cursoricon.c
index e51feb87115..d59acfcc7fd 100644
--- a/dlls/win32u/cursoricon.c
+++ b/dlls/win32u/cursoricon.c
@@ -786,18 +786,3 @@ ULONG_PTR set_icon_param( HICON handle, ULONG_PTR param )
     }
     return ret;
 }
-
-/******************************************************************************
- *	     CopyImage (win32u.so)
- */
-HANDLE WINAPI CopyImage( HANDLE hwnd, UINT type, INT dx, INT dy, UINT flags )
-{
-    void *ret_ptr;
-    ULONG ret_len;
-    NTSTATUS ret;
-    struct copy_image_params params =
-        { .hwnd = hwnd, .type = type, .dx = dx, .dy = dy, .flags = flags };
-
-    ret = KeUserModeCallback( NtUserCopyImage, &params, sizeof(params), &ret_ptr, &ret_len );
-    return UlongToHandle( ret );
-}
diff --git a/dlls/win32u/dc.c b/dlls/win32u/dc.c
index 95dd2651929..e597b31474b 100644
--- a/dlls/win32u/dc.c
+++ b/dlls/win32u/dc.c
@@ -217,10 +217,10 @@ DC *alloc_dc_ptr( DWORD magic )
     dc->physDev             = &dc->nulldrv;
     dc->thread              = GetCurrentThreadId();
     dc->refcount            = 1;
-    dc->hPen                = GDI_inc_ref_count( GetStockObject( BLACK_PEN ));
-    dc->hBrush              = GDI_inc_ref_count( GetStockObject( WHITE_BRUSH ));
-    dc->hFont               = GDI_inc_ref_count( GetStockObject( SYSTEM_FONT ));
-    dc->hPalette            = GetStockObject( DEFAULT_PALETTE );
+    dc->hPen                = GDI_inc_ref_count( get_stock_object( BLACK_PEN ));
+    dc->hBrush              = GDI_inc_ref_count( get_stock_object( WHITE_BRUSH ));
+    dc->hFont               = GDI_inc_ref_count( get_stock_object( SYSTEM_FONT ));
+    dc->hPalette            = get_stock_object( DEFAULT_PALETTE );
 
     set_initial_dc_state( dc );
 
@@ -274,13 +274,7 @@ void free_dc_ptr( DC *dc )
     GDI_dec_ref_count( dc->hPen );
     GDI_dec_ref_count( dc->hBrush );
     GDI_dec_ref_count( dc->hFont );
-    if (dc->hBitmap)
-    {
-        if (dc->is_display)
-            NtGdiDeleteClientObj( dc->hBitmap );
-        else
-            GDI_dec_ref_count( dc->hBitmap );
-    }
+    if (dc->hBitmap) GDI_dec_ref_count( dc->hBitmap );
     free_gdi_handle( dc->hSelf );
     free_dc_state( dc );
 }
@@ -471,11 +465,11 @@ static BOOL reset_dc_state( HDC hdc )
     set_initial_dc_state( dc );
     set_bk_color( dc, RGB( 255, 255, 255 ));
     set_text_color( dc, RGB( 0, 0, 0 ));
-    NtGdiSelectBrush( hdc, GetStockObject( WHITE_BRUSH ));
-    NtGdiSelectFont( hdc, GetStockObject( SYSTEM_FONT ));
-    NtGdiSelectPen( hdc, GetStockObject( BLACK_PEN ));
+    NtGdiSelectBrush( hdc, get_stock_object( WHITE_BRUSH ));
+    NtGdiSelectFont( hdc, get_stock_object( SYSTEM_FONT ));
+    NtGdiSelectPen( hdc, get_stock_object( BLACK_PEN ));
     NtGdiSetVirtualResolution( hdc, 0, 0, 0, 0 );
-    NtUserSelectPalette( hdc, GetStockObject( DEFAULT_PALETTE ), FALSE );
+    NtUserSelectPalette( hdc, get_stock_object( DEFAULT_PALETTE ), FALSE );
     NtGdiSetBoundsRect( hdc, NULL, DCB_DISABLE );
     NtGdiAbortPath( hdc );
 
@@ -730,10 +724,7 @@ HDC WINAPI NtGdiOpenDCW( UNICODE_STRING *device, const DEVMODEW *devmode, UNICOD
     if (!(dc = alloc_dc_ptr( NTGDI_OBJ_DC ))) return 0;
     hdc = dc->hSelf;
 
-    if (is_display)
-        dc->hBitmap = NtGdiCreateClientObj( NTGDI_OBJ_SURF );
-    else
-        dc->hBitmap = GDI_inc_ref_count( GetStockObject( DEFAULT_BITMAP ));
+    dc->hBitmap = GDI_inc_ref_count( get_stock_object( DEFAULT_BITMAP ));
 
     TRACE("(device=%s, output=%s): returning %p\n",
           debugstr_us(device), debugstr_us(output), dc->hSelf );
@@ -764,13 +755,6 @@ HDC WINAPI NtGdiOpenDCW( UNICODE_STRING *device, const DEVMODEW *devmode, UNICOD
 
     DC_InitDC( dc );
     release_dc_ptr( dc );
-
-    if (driver_info && driver_info->cVersion == NTGDI_WIN16_DIB &&
-        !create_dib_surface( hdc, pdev ))
-    {
-        NtGdiDeleteObjectApp( hdc );
-        return 0;
-    }
     return hdc;
 }
 
@@ -800,7 +784,7 @@ HDC WINAPI NtGdiCreateCompatibleDC( HDC hdc )
 
     TRACE("(%p): returning %p\n", hdc, dc->hSelf );
 
-    dc->hBitmap = GDI_inc_ref_count( GetStockObject( DEFAULT_BITMAP ));
+    dc->hBitmap = GDI_inc_ref_count( get_stock_object( DEFAULT_BITMAP ));
     dc->attr->vis_rect.left   = 0;
     dc->attr->vis_rect.top    = 0;
     dc->attr->vis_rect.right  = 1;
@@ -1349,7 +1333,7 @@ UINT WINAPI NtGdiGetBoundsRect( HDC hdc, RECT *rect, UINT flags )
 
     if (rect)
     {
-        if (IsRectEmpty( &dc->bounds ))
+        if (is_rect_empty( &dc->bounds ))
         {
             rect->left = rect->top = rect->right = rect->bottom = 0;
             ret = DCB_RESET;
@@ -1394,7 +1378,7 @@ UINT WINAPI NtGdiSetBoundsRect( HDC hdc, const RECT *rect, UINT flags )
     }
 
     ret = (dc->bounds_enabled ? DCB_ENABLE : DCB_DISABLE) |
-          (IsRectEmpty( &dc->bounds ) ? ret & DCB_SET : DCB_SET);
+          (is_rect_empty( &dc->bounds ) ? ret & DCB_SET : DCB_SET);
 
     if (flags & DCB_RESET) reset_bounds( &dc->bounds );
 
diff --git a/dlls/win32u/dce.c b/dlls/win32u/dce.c
index fbde3f3d0ec..c09a97ce5b7 100644
--- a/dlls/win32u/dce.c
+++ b/dlls/win32u/dce.c
@@ -34,17 +34,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(win);
 
-struct dce
-{
-    struct list entry;         /* entry in global DCE list */
-    HDC         hdc;
-    HWND        hwnd;
-    HRGN        clip_rgn;
-    DWORD       flags;
-    LONG        count;         /* usage count; 0 or 1 for cache DCEs, always 1 for window DCEs,
-                                  always >= 1 for class DCEs */
-};
-
 static struct list dce_list = LIST_INIT(dce_list);
 
 #define DCE_CACHE_SIZE 64
@@ -56,17 +45,17 @@ static pthread_mutex_t surfaces_lock = PTHREAD_MUTEX_INITIALIZER;
  * Dummy window surface for windows that shouldn't get painted.
  */
 
-static void dummy_surface_lock( struct window_surface *window_surface )
+static void CDECL dummy_surface_lock( struct window_surface *window_surface )
 {
     /* nothing to do */
 }
 
-static void dummy_surface_unlock( struct window_surface *window_surface )
+static void CDECL dummy_surface_unlock( struct window_surface *window_surface )
 {
     /* nothing to do */
 }
 
-static void *dummy_surface_get_bitmap_info( struct window_surface *window_surface, BITMAPINFO *info )
+static void *CDECL dummy_surface_get_bitmap_info( struct window_surface *window_surface, BITMAPINFO *info )
 {
     static DWORD dummy_data;
 
@@ -84,23 +73,23 @@ static void *dummy_surface_get_bitmap_info( struct window_surface *window_surfac
     return &dummy_data;
 }
 
-static RECT *dummy_surface_get_bounds( struct window_surface *window_surface )
+static RECT *CDECL dummy_surface_get_bounds( struct window_surface *window_surface )
 {
     static RECT dummy_bounds;
     return &dummy_bounds;
 }
 
-static void dummy_surface_set_region( struct window_surface *window_surface, HRGN region )
+static void CDECL dummy_surface_set_region( struct window_surface *window_surface, HRGN region )
 {
     /* nothing to do */
 }
 
-static void dummy_surface_flush( struct window_surface *window_surface )
+static void CDECL dummy_surface_flush( struct window_surface *window_surface )
 {
     /* nothing to do */
 }
 
-static void dummy_surface_destroy( struct window_surface *window_surface )
+static void CDECL dummy_surface_destroy( struct window_surface *window_surface )
 {
     /* nothing to do */
 }
@@ -118,261 +107,6 @@ static const struct window_surface_funcs dummy_surface_funcs =
 
 struct window_surface dummy_surface = { &dummy_surface_funcs, { NULL, NULL }, 1, { 0, 0, 1, 1 } };
 
-/*******************************************************************
- * Off-screen window surface.
- */
-
-struct offscreen_window_surface
-{
-    struct window_surface header;
-    pthread_mutex_t mutex;
-    RECT bounds;
-    char *bits;
-    BITMAPINFO info;
-};
-
-static const struct window_surface_funcs offscreen_window_surface_funcs;
-
-static struct offscreen_window_surface *impl_from_window_surface( struct window_surface *base )
-{
-    if (!base || base->funcs != &offscreen_window_surface_funcs) return NULL;
-    return CONTAINING_RECORD( base, struct offscreen_window_surface, header );
-}
-
-static void offscreen_window_surface_lock( struct window_surface *base )
-{
-    struct offscreen_window_surface *impl = impl_from_window_surface( base );
-    pthread_mutex_lock( &impl->mutex );
-}
-
-static void offscreen_window_surface_unlock( struct window_surface *base )
-{
-    struct offscreen_window_surface *impl = impl_from_window_surface( base );
-    pthread_mutex_unlock( &impl->mutex );
-}
-
-static RECT *offscreen_window_surface_get_bounds( struct window_surface *base )
-{
-    struct offscreen_window_surface *impl = impl_from_window_surface( base );
-    return &impl->bounds;
-}
-
-static void *offscreen_window_surface_get_bitmap_info( struct window_surface *base, BITMAPINFO *info )
-{
-    struct offscreen_window_surface *impl = impl_from_window_surface( base );
-    info->bmiHeader = impl->info.bmiHeader;
-    return impl->bits;
-}
-
-static void offscreen_window_surface_set_region( struct window_surface *base, HRGN region )
-{
-}
-
-static void offscreen_window_surface_flush( struct window_surface *base )
-{
-    struct offscreen_window_surface *impl = impl_from_window_surface( base );
-    base->funcs->lock( base );
-    reset_bounds( &impl->bounds );
-    base->funcs->unlock( base );
-}
-
-static void offscreen_window_surface_destroy( struct window_surface *base )
-{
-    struct offscreen_window_surface *impl = impl_from_window_surface( base );
-    free( impl );
-}
-
-static const struct window_surface_funcs offscreen_window_surface_funcs =
-{
-    offscreen_window_surface_lock,
-    offscreen_window_surface_unlock,
-    offscreen_window_surface_get_bitmap_info,
-    offscreen_window_surface_get_bounds,
-    offscreen_window_surface_set_region,
-    offscreen_window_surface_flush,
-    offscreen_window_surface_destroy
-};
-
-void create_offscreen_window_surface( const RECT *visible_rect, struct window_surface **surface )
-{
-    struct offscreen_window_surface *impl;
-    SIZE_T size;
-    RECT surface_rect = *visible_rect;
-    pthread_mutexattr_t attr;
-
-    TRACE( "visible_rect %s, surface %p.\n", wine_dbgstr_rect( visible_rect ), surface );
-
-    OffsetRect( &surface_rect, -surface_rect.left, -surface_rect.top );
-    surface_rect.right  = (surface_rect.right + 0x1f) & ~0x1f;
-    surface_rect.bottom = (surface_rect.bottom + 0x1f) & ~0x1f;
-
-    /* check that old surface is an offscreen_window_surface, or release it */
-    if ((impl = impl_from_window_surface( *surface )))
-    {
-        /* if the rect didn't change, keep the same surface */
-        if (EqualRect( &surface_rect, &impl->header.rect )) return;
-        window_surface_release( &impl->header );
-    }
-    else if (*surface) window_surface_release( *surface );
-
-    /* create a new window surface */
-    *surface = NULL;
-    size = surface_rect.right * surface_rect.bottom * 4;
-    if (!(impl = calloc(1, offsetof( struct offscreen_window_surface, info.bmiColors[0] ) + size))) return;
-
-    impl->header.funcs = &offscreen_window_surface_funcs;
-    impl->header.ref = 1;
-    impl->header.rect = surface_rect;
-
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( &impl->mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
-
-    reset_bounds( &impl->bounds );
-
-    impl->bits = (char *)&impl->info.bmiColors[0];
-    impl->info.bmiHeader.biSize        = sizeof( impl->info );
-    impl->info.bmiHeader.biWidth       = surface_rect.right;
-    impl->info.bmiHeader.biHeight      = surface_rect.bottom;
-    impl->info.bmiHeader.biPlanes      = 1;
-    impl->info.bmiHeader.biBitCount    = 32;
-    impl->info.bmiHeader.biCompression = BI_RGB;
-    impl->info.bmiHeader.biSizeImage   = size;
-
-    TRACE( "created window surface %p\n", &impl->header );
-
-    *surface = &impl->header;
-}
-
-/* window surface used to implement the DIB.DRV driver */
-
-struct dib_window_surface
-{
-    struct window_surface header;
-    RECT                  bounds;
-    void                 *bits;
-    UINT                  info_size;
-    BITMAPINFO            info;   /* variable size, must be last */
-};
-
-static struct dib_window_surface *get_dib_surface( struct window_surface *surface )
-{
-    return (struct dib_window_surface *)surface;
-}
-
-/***********************************************************************
- *           dib_surface_lock
- */
-static void dib_surface_lock( struct window_surface *window_surface )
-{
-    /* nothing to do */
-}
-
-/***********************************************************************
- *           dib_surface_unlock
- */
-static void dib_surface_unlock( struct window_surface *window_surface )
-{
-    /* nothing to do */
-}
-
-/***********************************************************************
- *           dib_surface_get_bitmap_info
- */
-static void *dib_surface_get_bitmap_info( struct window_surface *window_surface, BITMAPINFO *info )
-{
-    struct dib_window_surface *surface = get_dib_surface( window_surface );
-
-    memcpy( info, &surface->info, surface->info_size );
-    return surface->bits;
-}
-
-/***********************************************************************
- *           dib_surface_get_bounds
- */
-static RECT *dib_surface_get_bounds( struct window_surface *window_surface )
-{
-    struct dib_window_surface *surface = get_dib_surface( window_surface );
-
-    return &surface->bounds;
-}
-
-/***********************************************************************
- *           dib_surface_set_region
- */
-static void dib_surface_set_region( struct window_surface *window_surface, HRGN region )
-{
-    /* nothing to do */
-}
-
-/***********************************************************************
- *           dib_surface_flush
- */
-static void dib_surface_flush( struct window_surface *window_surface )
-{
-    /* nothing to do */
-}
-
-/***********************************************************************
- *           dib_surface_destroy
- */
-static void dib_surface_destroy( struct window_surface *window_surface )
-{
-    struct dib_window_surface *surface = get_dib_surface( window_surface );
-
-    TRACE( "freeing %p\n", surface );
-    free( surface );
-}
-
-static const struct window_surface_funcs dib_surface_funcs =
-{
-    dib_surface_lock,
-    dib_surface_unlock,
-    dib_surface_get_bitmap_info,
-    dib_surface_get_bounds,
-    dib_surface_set_region,
-    dib_surface_flush,
-    dib_surface_destroy
-};
-
-BOOL create_dib_surface( HDC hdc, const BITMAPINFO *info )
-{
-    struct dib_window_surface *surface;
-    int color = 0;
-    HRGN region;
-    RECT rect;
-
-    if (info->bmiHeader.biBitCount <= 8)
-        color = info->bmiHeader.biClrUsed ? info->bmiHeader.biClrUsed : (1 << info->bmiHeader.biBitCount);
-    else if (info->bmiHeader.biCompression == BI_BITFIELDS)
-        color = 3;
-
-    surface = calloc( 1, offsetof( struct dib_window_surface, info.bmiColors[color] ));
-    if (!surface) return FALSE;
-
-    rect.left   = 0;
-    rect.top    = 0;
-    rect.right  = info->bmiHeader.biWidth;
-    rect.bottom = abs(info->bmiHeader.biHeight);
-
-    surface->header.funcs = &dib_surface_funcs;
-    surface->header.rect  = rect;
-    surface->header.ref   = 1;
-    surface->info_size    = offsetof( BITMAPINFO, bmiColors[color] );
-    surface->bits         = (char *)info + surface->info_size;
-    memcpy( &surface->info, info, surface->info_size );
-
-    TRACE( "created %p %ux%u for info %p bits %p\n",
-           surface, rect.right, rect.bottom, info, surface->bits );
-
-    region = NtGdiCreateRectRgn( rect.left, rect.top, rect.right, rect.bottom );
-    set_visible_region( hdc, region, &rect, &rect, &surface->header );
-    TRACE( "using hdc %p surface %p\n", hdc, surface );
-    window_surface_release( &surface->header );
-    return TRUE;
-}
-
 /*******************************************************************
  *           register_window_surface
  *
@@ -528,7 +262,7 @@ static void update_visible_region( struct dce *dce )
     }
 
     if (!surface) SetRectEmpty( &top_rect );
-    set_visible_region( dce->hdc, vis_rgn, &win_rect, &top_rect, surface );
+    __wine_set_visible_region( dce->hdc, vis_rgn, &win_rect, &top_rect, surface );
     if (surface) window_surface_release( surface );
 }
 
@@ -539,7 +273,7 @@ static void release_dce( struct dce *dce )
 {
     if (!dce->hwnd) return;  /* already released */
 
-    set_visible_region( dce->hdc, 0, &dummy_surface.rect, &dummy_surface.rect, &dummy_surface );
+    __wine_set_visible_region( dce->hdc, 0, &dummy_surface.rect, &dummy_surface.rect, &dummy_surface );
     user_driver->pReleaseDC( dce->hwnd, dce->hdc );
 
     if (dce->clip_rgn) NtGdiDeleteObjectApp( dce->clip_rgn );
@@ -1245,90 +979,6 @@ static BOOL send_erase( HWND hwnd, UINT flags, HRGN client_rgn,
     return need_erase;
 }
 
-/***********************************************************************
- *           copy_bits_from_surface
- *
- * Copy bits from a window surface; helper for move_window_bits and move_window_bits_parent.
- */
-static void copy_bits_from_surface( HWND hwnd, struct window_surface *surface,
-                                    const RECT *dst, const RECT *src )
-{
-    char buffer[FIELD_OFFSET( BITMAPINFO, bmiColors[256] )];
-    BITMAPINFO *info = (BITMAPINFO *)buffer;
-    void *bits;
-    UINT flags = UPDATE_NOCHILDREN | UPDATE_CLIPCHILDREN;
-    HRGN rgn = get_update_region( hwnd, &flags, NULL );
-    HDC hdc = NtUserGetDCEx( hwnd, rgn, DCX_CACHE | DCX_WINDOW | DCX_EXCLUDERGN );
-
-    bits = surface->funcs->get_info( surface, info );
-    surface->funcs->lock( surface );
-    NtGdiSetDIBitsToDeviceInternal( hdc, dst->left, dst->top, dst->right - dst->left, dst->bottom - dst->top,
-                                    src->left - surface->rect.left, surface->rect.bottom - src->bottom,
-                                    0, surface->rect.bottom - surface->rect.top,
-                                    bits, info, DIB_RGB_COLORS, 0, 0, FALSE, NULL );
-    surface->funcs->unlock( surface );
-    NtUserReleaseDC( hwnd, hdc );
-}
-
-/***********************************************************************
- *           move_window_bits
- *
- * Move the window bits when a window is resized or its surface recreated.
- */
-void move_window_bits( HWND hwnd, struct window_surface *old_surface,
-                       struct window_surface *new_surface,
-                       const RECT *visible_rect, const RECT *old_visible_rect,
-                       const RECT *window_rect, const RECT *valid_rects )
-{
-    RECT dst = valid_rects[0];
-    RECT src = valid_rects[1];
-
-    if (new_surface != old_surface ||
-        src.left - old_visible_rect->left != dst.left - visible_rect->left ||
-        src.top - old_visible_rect->top != dst.top - visible_rect->top)
-    {
-        TRACE( "copying %s -> %s\n", wine_dbgstr_rect( &src ), wine_dbgstr_rect( &dst ));
-        OffsetRect( &src, -old_visible_rect->left, -old_visible_rect->top );
-        OffsetRect( &dst, -window_rect->left, -window_rect->top );
-        copy_bits_from_surface( hwnd, old_surface, &dst, &src );
-    }
-}
-
-
-/***********************************************************************
- *           move_window_bits_parent
- *
- * Move the window bits in the parent surface when a child is moved.
- */
-void move_window_bits_parent( HWND hwnd, HWND parent, const RECT *window_rect, const RECT *valid_rects )
-{
-    struct window_surface *surface;
-    RECT dst = valid_rects[0];
-    RECT src = valid_rects[1];
-    WND *win;
-
-    if (src.left == dst.left && src.top == dst.top) return;
-
-    if (!(win = get_win_ptr( parent ))) return;
-    if (win == WND_DESKTOP || win == WND_OTHER_PROCESS) return;
-    if (!(surface = win->surface))
-    {
-        release_win_ptr( win );
-        return;
-    }
-
-    TRACE( "copying %s -> %s\n", wine_dbgstr_rect( &src ), wine_dbgstr_rect( &dst ));
-    map_window_points( NtUserGetAncestor( hwnd, GA_PARENT ), parent, (POINT *)&src, 2, get_thread_dpi() );
-    OffsetRect( &src, win->client_rect.left - win->visible_rect.left,
-                win->client_rect.top - win->visible_rect.top );
-    OffsetRect( &dst, -window_rect->left, -window_rect->top );
-    window_surface_add_ref( surface );
-    release_win_ptr( win );
-
-    copy_bits_from_surface( hwnd, surface, &dst, &src );
-    window_surface_release( surface );
-}
-
 /***********************************************************************
  *           NtUserBeginPaint (win32u.@)
  */
@@ -1340,7 +990,7 @@ HDC WINAPI NtUserBeginPaint( HWND hwnd, PAINTSTRUCT *ps )
     RECT rect;
     UINT flags = UPDATE_NONCLIENT | UPDATE_ERASE | UPDATE_PAINT | UPDATE_INTERNALPAINT | UPDATE_NOCHILDREN;
 
-    NtUserHideCaret( hwnd );
+    if (user_callbacks) user_callbacks->pHideCaret( hwnd );
 
     if (!(hrgn = send_ncpaint( hwnd, NULL, &flags ))) return 0;
 
@@ -1364,7 +1014,7 @@ HDC WINAPI NtUserBeginPaint( HWND hwnd, PAINTSTRUCT *ps )
  */
 BOOL WINAPI NtUserEndPaint( HWND hwnd, const PAINTSTRUCT *ps )
 {
-    NtUserShowCaret( hwnd );
+    if (user_callbacks) user_callbacks->pShowCaret( hwnd );
     flush_window_surfaces( FALSE );
     if (!ps) return FALSE;
     release_dc( hwnd, ps->hdc, TRUE );
@@ -1432,7 +1082,6 @@ static void update_now( HWND hwnd, UINT rdw_flags )
  */
 BOOL WINAPI NtUserRedrawWindow( HWND hwnd, const RECT *rect, HRGN hrgn, UINT flags )
 {
-    LARGE_INTEGER zero = { .QuadPart = 0 };
     static const RECT empty;
     BOOL ret;
 
@@ -1453,7 +1102,7 @@ BOOL WINAPI NtUserRedrawWindow( HWND hwnd, const RECT *rect, HRGN hrgn, UINT fla
     }
 
     /* process pending expose events before painting */
-    if (flags & RDW_UPDATENOW) user_driver->pMsgWaitForMultipleObjectsEx( 0, NULL, &zero, QS_PAINT, 0 );
+    if (flags & RDW_UPDATENOW) user_driver->pMsgWaitForMultipleObjectsEx( 0, NULL, 0, QS_PAINT, 0 );
 
     if (rect && !hrgn)
     {
@@ -1550,27 +1199,3 @@ BOOL WINAPI NtUserGetUpdateRect( HWND hwnd, RECT *rect, BOOL erase )
     if (need_erase) flags |= UPDATE_DELAYED_ERASE;
     return get_update_flags( hwnd, NULL, &flags ) && (flags & UPDATE_PAINT);
 }
-
-/***********************************************************************
- *           NtUserExcludeUpdateRgn (win32u.@)
- */
-INT WINAPI NtUserExcludeUpdateRgn( HDC hdc, HWND hwnd )
-{
-    HRGN update_rgn = NtGdiCreateRectRgn( 0, 0, 0, 0 );
-    INT ret = NtUserGetUpdateRgn( hwnd, update_rgn, FALSE );
-
-    if (ret != ERROR)
-    {
-        DPI_AWARENESS_CONTEXT context;
-        POINT pt;
-
-        context = set_thread_dpi_awareness_context( get_window_dpi_awareness_context( hwnd ));
-        NtGdiGetDCPoint( hdc, NtGdiGetDCOrg, &pt );
-        map_window_points( 0, hwnd, &pt, 1, get_thread_dpi() );
-        NtGdiOffsetRgn( update_rgn, -pt.x, -pt.y );
-        ret = NtGdiExtSelectClipRgn( hdc, update_rgn, RGN_DIFF );
-        set_thread_dpi_awareness_context( context );
-    }
-    NtGdiDeleteObjectApp( update_rgn );
-    return ret;
-}
diff --git a/dlls/win32u/defwnd.c b/dlls/win32u/defwnd.c
deleted file mode 100644
index 9b4edc90eaa..00000000000
--- a/dlls/win32u/defwnd.c
+++ /dev/null
@@ -1,427 +0,0 @@
-/*
- * Default window procedure
- *
- * Copyright 1993, 1996 Alexandre Julliard
- * Copyright 1995 Alex Korobka
- * Copyright 2022 Jacek Caban for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include "win32u_private.h"
-#include "ntuser_private.h"
-#include "wine/server.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(win);
-
-
-void fill_rect( HDC dc, const RECT *rect, HBRUSH hbrush )
-{
-    HBRUSH prev_brush;
-
-    if (hbrush <= (HBRUSH)(COLOR_MENUBAR + 1)) hbrush = get_sys_color_brush( HandleToULong(hbrush) - 1 );
-
-    prev_brush = NtGdiSelectBrush( dc, hbrush );
-    NtGdiPatBlt( dc, rect->left, rect->top, rect->right - rect->left, rect->bottom - rect->top, PATCOPY );
-    if (prev_brush) NtGdiSelectBrush( dc, prev_brush );
-}
-
-/***********************************************************************
- *           AdjustWindowRectEx (win32u.so)
- */
-BOOL WINAPI AdjustWindowRectEx( RECT *rect, DWORD style, BOOL menu, DWORD ex_style )
-{
-    NONCLIENTMETRICSW ncm;
-    int adjust = 0;
-
-    ncm.cbSize = sizeof(ncm);
-    NtUserSystemParametersInfo( SPI_GETNONCLIENTMETRICS, 0, &ncm, 0 );
-
-    if ((ex_style & (WS_EX_STATICEDGE|WS_EX_DLGMODALFRAME)) == WS_EX_STATICEDGE)
-        adjust = 1; /* for the outer frame always present */
-    else if ((ex_style & WS_EX_DLGMODALFRAME) || (style & (WS_THICKFRAME|WS_DLGFRAME)))
-        adjust = 2; /* outer */
-
-    if (style & WS_THICKFRAME)
-        adjust += ncm.iBorderWidth + ncm.iPaddedBorderWidth; /* The resize border */
-
-    if ((style & (WS_BORDER|WS_DLGFRAME)) || (ex_style & WS_EX_DLGMODALFRAME))
-        adjust++; /* The other border */
-
-    InflateRect( rect, adjust, adjust );
-
-    if ((style & WS_CAPTION) == WS_CAPTION)
-    {
-        if (ex_style & WS_EX_TOOLWINDOW)
-            rect->top -= ncm.iSmCaptionHeight + 1;
-        else
-            rect->top -= ncm.iCaptionHeight + 1;
-    }
-    if (menu) rect->top -= ncm.iMenuHeight + 1;
-
-    if (ex_style & WS_EX_CLIENTEDGE)
-        InflateRect( rect, get_system_metrics(SM_CXEDGE), get_system_metrics(SM_CYEDGE) );
-    return TRUE;
-}
-
-static BOOL set_window_text( HWND hwnd, const void *text, BOOL ansi )
-{
-    static const WCHAR emptyW[] = { 0 };
-    WCHAR *str;
-    WND *win;
-
-    /* check for string, as static icons, bitmaps (SS_ICON, SS_BITMAP)
-     * may have child window IDs instead of window name */
-    if (text && IS_INTRESOURCE(text)) return FALSE;
-
-    if (text)
-    {
-        if (ansi) str = towstr( text );
-        else str = wcsdup( text );
-        if (!str) return FALSE;
-    }
-    else str = NULL;
-
-    TRACE( "%s\n", debugstr_w(str) );
-
-    if (!(win = get_win_ptr( hwnd )))
-    {
-        free( str );
-        return FALSE;
-    }
-
-    free( win->text );
-    win->text = str;
-    SERVER_START_REQ( set_window_text )
-    {
-        req->handle = wine_server_user_handle( hwnd );
-        if (str) wine_server_add_data( req, str, lstrlenW( str ) * sizeof(WCHAR) );
-        wine_server_call( req );
-    }
-    SERVER_END_REQ;
-
-    release_win_ptr( win );
-
-    user_driver->pSetWindowText( hwnd, str ? str : emptyW );
-
-    return TRUE;
-}
-
-static HICON get_window_icon( HWND hwnd, WPARAM type )
-{
-    HICON ret;
-    WND *win;
-
-    if (!(win = get_win_ptr( hwnd ))) return 0;
-
-    switch(type)
-    {
-    case ICON_SMALL:
-        ret = win->hIconSmall;
-        break;
-    case ICON_BIG:
-        ret = win->hIcon;
-        break;
-    case ICON_SMALL2:
-        ret = win->hIconSmall ? win->hIconSmall : win->hIconSmall2;
-        break;
-    default:
-        ret = 0;
-        break;
-    }
-
-    release_win_ptr( win );
-    return ret;
-}
-
-static HICON set_window_icon( HWND hwnd, WPARAM type, HICON icon )
-{
-    HICON ret = 0;
-    WND *win;
-
-    if (!(win = get_win_ptr( hwnd ))) return 0;
-
-    switch (type)
-    {
-    case ICON_SMALL:
-        ret = win->hIconSmall;
-        if (ret && !icon && win->hIcon)
-        {
-            win->hIconSmall2 = CopyImage( win->hIcon, IMAGE_ICON,
-                                          get_system_metrics( SM_CXSMICON ),
-                                          get_system_metrics( SM_CYSMICON ), 0 );
-        }
-        else if (icon && win->hIconSmall2)
-        {
-            NtUserDestroyCursor( win->hIconSmall2, 0 );
-            win->hIconSmall2 = NULL;
-        }
-        win->hIconSmall = icon;
-        break;
-
-    case ICON_BIG:
-        ret = win->hIcon;
-        if (win->hIconSmall2)
-        {
-            NtUserDestroyCursor( win->hIconSmall2, 0 );
-            win->hIconSmall2 = NULL;
-        }
-        if (icon && !win->hIconSmall)
-        {
-            win->hIconSmall2 = CopyImage( icon, IMAGE_ICON,
-                                          get_system_metrics( SM_CXSMICON ),
-                                          get_system_metrics( SM_CYSMICON ), 0 );
-        }
-        win->hIcon = icon;
-        break;
-    }
-    release_win_ptr( win );
-
-    user_driver->pSetWindowIcon( hwnd, type, icon );
-    return ret;
-}
-
-static LONG handle_window_pos_changing( HWND hwnd, WINDOWPOS *winpos )
-{
-    LONG style = get_window_long( hwnd, GWL_STYLE );
-
-    if (winpos->flags & SWP_NOSIZE) return 0;
-    if ((style & WS_THICKFRAME) || ((style & (WS_POPUP | WS_CHILD)) == 0))
-    {
-        MINMAXINFO info = get_min_max_info( hwnd );
-        winpos->cx = min( winpos->cx, info.ptMaxTrackSize.x );
-        winpos->cy = min( winpos->cy, info.ptMaxTrackSize.y );
-        if (!(style & WS_MINIMIZE))
-        {
-            winpos->cx = max( winpos->cx, info.ptMinTrackSize.x );
-            winpos->cy = max( winpos->cy, info.ptMinTrackSize.y );
-        }
-    }
-    return 0;
-}
-
-static LRESULT handle_sys_command( HWND hwnd, WPARAM wparam, LPARAM lparam )
-{
-    if (!is_window_enabled( hwnd )) return 0;
-
-    if (call_hooks( WH_CBT, HCBT_SYSCOMMAND, wparam, lparam, TRUE ))
-        return 0;
-
-    if (!user_driver->pSysCommand( hwnd, wparam, lparam ))
-        return 0;
-
-    switch (wparam & 0xfff0)
-    {
-    case SC_MINIMIZE:
-        show_owned_popups( hwnd, FALSE );
-        NtUserShowWindow( hwnd, SW_MINIMIZE );
-        break;
-
-    case SC_MAXIMIZE:
-        if (is_iconic(hwnd)) show_owned_popups( hwnd, TRUE );
-        NtUserShowWindow( hwnd, SW_MAXIMIZE );
-        break;
-
-    case SC_RESTORE:
-        if (is_iconic( hwnd )) show_owned_popups( hwnd, TRUE );
-        NtUserShowWindow( hwnd, SW_RESTORE );
-        break;
-
-    default:
-        return 1; /* handle on client side */
-    }
-    return 0;
-}
-
-LRESULT default_window_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, BOOL ansi )
-{
-    LRESULT result = 0;
-
-    switch (msg)
-    {
-    case WM_NCCREATE:
-        if (lparam)
-        {
-            CREATESTRUCTW *cs = (CREATESTRUCTW *)lparam;
-            set_window_text( hwnd, cs->lpszName, ansi );
-            result = 1;
-        }
-        break;
-
-    case WM_NCDESTROY:
-        {
-            WND *win = get_win_ptr( hwnd );
-            if (!win) return 0;
-            free( win->text );
-            win->text = NULL;
-            if (user_callbacks) user_callbacks->free_win_ptr( win );
-            win->pScroll = NULL;
-            release_win_ptr( win );
-            break;
-        }
-
-    case WM_WINDOWPOSCHANGING:
-        return handle_window_pos_changing( hwnd, (WINDOWPOS *)lparam );
-
-    case WM_PAINTICON:
-    case WM_PAINT:
-        {
-            PAINTSTRUCT ps;
-            HDC hdc = NtUserBeginPaint( hwnd, &ps );
-            if (hdc)
-            {
-                HICON icon;
-                if (is_iconic(hwnd) && ((icon = UlongToHandle( get_class_long( hwnd, GCLP_HICON, FALSE )))))
-                {
-                    RECT rc;
-                    int x, y;
-
-                    get_client_rect( hwnd, &rc );
-                    x = (rc.right - rc.left - get_system_metrics( SM_CXICON )) / 2;
-                    y = (rc.bottom - rc.top - get_system_metrics( SM_CYICON )) / 2;
-                    TRACE( "Painting class icon: vis rect=(%s)\n", wine_dbgstr_rect(&ps.rcPaint) );
-                    NtUserDrawIconEx( hdc, x, y, icon, 0, 0, 0, 0, DI_NORMAL | DI_COMPAT | DI_DEFAULTSIZE );
-                }
-                NtUserEndPaint( hwnd, &ps );
-            }
-            break;
-        }
-
-    case WM_SYNCPAINT:
-        NtUserRedrawWindow ( hwnd, NULL, 0, RDW_ERASENOW | RDW_ERASE | RDW_ALLCHILDREN );
-        return 0;
-
-    case WM_SETREDRAW:
-        if (wparam) set_window_style( hwnd, WS_VISIBLE, 0 );
-        else
-        {
-            NtUserRedrawWindow( hwnd, NULL, 0, RDW_ALLCHILDREN | RDW_VALIDATE );
-            set_window_style( hwnd, 0, WS_VISIBLE );
-        }
-        return 0;
-
-    case WM_CLOSE:
-        NtUserDestroyWindow( hwnd );
-        return 0;
-
-    case WM_MOUSEACTIVATE:
-        if (get_window_long( hwnd, GWL_STYLE ) & WS_CHILD)
-        {
-            result = send_message( get_parent(hwnd), WM_MOUSEACTIVATE, wparam, lparam );
-            if (result) break;
-        }
-
-        /* Caption clicks are handled by NC_HandleNCLButtonDown() */
-        result = HIWORD(lparam) == WM_LBUTTONDOWN && LOWORD(lparam) == HTCAPTION ?
-            MA_NOACTIVATE : MA_ACTIVATE;
-        break;
-
-    case WM_ACTIVATE:
-        /* The default action in Windows is to set the keyboard focus to
-         * the window, if it's being activated and not minimized */
-        if (LOWORD(wparam) != WA_INACTIVE && !is_iconic( hwnd )) NtUserSetFocus( hwnd );
-        break;
-
-    case WM_MOUSEWHEEL:
-        if (get_window_long( hwnd, GWL_STYLE ) & WS_CHILD)
-            result = send_message( get_parent( hwnd ), WM_MOUSEWHEEL, wparam, lparam );
-        break;
-
-    case WM_ERASEBKGND:
-    case WM_ICONERASEBKGND:
-        {
-            RECT rect;
-            HDC hdc = (HDC)wparam;
-            HBRUSH hbr = UlongToHandle( get_class_long( hwnd, GCLP_HBRBACKGROUND, FALSE ));
-            if (!hbr) break;
-
-            if (get_class_long( hwnd, GCL_STYLE, FALSE ) & CS_PARENTDC)
-            {
-                /* can't use GetClipBox with a parent DC or we fill the whole parent */
-                get_client_rect( hwnd, &rect );
-                NtGdiTransformPoints( hdc, (POINT *)&rect, (POINT *)&rect, 1, NtGdiDPtoLP );
-            }
-            else NtGdiGetAppClipBox( hdc, &rect );
-            fill_rect( hdc, &rect, hbr );
-            return 1;
-        }
-
-    case WM_GETDLGCODE:
-        break;
-
-    case WM_SETTEXT:
-        result = set_window_text( hwnd, (void *)lparam, ansi );
-        break;
-
-    case WM_SETICON:
-        result = (LRESULT)set_window_icon( hwnd, wparam, (HICON)lparam );
-        break;
-
-    case WM_GETICON:
-        result = (LRESULT)get_window_icon( hwnd, wparam );
-        break;
-
-    case WM_SYSCOMMAND:
-        result = handle_sys_command( hwnd, wparam, lparam );
-        break;
-    }
-
-    return result;
-}
-
-LRESULT desktop_window_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    static const WCHAR wine_display_device_guidW[] =
-        {'_','_','w','i','n','e','_','d','i','s','p','l','a','y','_','d','e','v','i','c','e',
-         '_','g','u','i','d',0};
-
-    switch (msg)
-    {
-    case WM_NCCREATE:
-    {
-        CREATESTRUCTW *cs = (CREATESTRUCTW *)lparam;
-        const GUID *guid = cs->lpCreateParams;
-
-        if (guid)
-        {
-            ATOM atom = 0;
-            char buffer[37];
-            WCHAR bufferW[37];
-
-            if (NtUserGetAncestor( hwnd, GA_PARENT )) return FALSE;  /* refuse to create non-desktop window */
-
-            sprintf( buffer, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
-                     (unsigned int)guid->Data1, guid->Data2, guid->Data3,
-                     guid->Data4[0], guid->Data4[1], guid->Data4[2], guid->Data4[3],
-                     guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7] );
-            NtAddAtom( bufferW, asciiz_to_unicode( bufferW, buffer ) - sizeof(WCHAR), &atom );
-            NtUserSetProp( hwnd, wine_display_device_guidW, ULongToHandle( atom ) );
-        }
-        return TRUE;
-    }
-    case WM_NCCALCSIZE:
-        return 0;
-
-    default:
-        if (msg >= WM_USER && hwnd == get_desktop_window())
-            return user_driver->pDesktopWindowProc( hwnd, msg, wparam, lparam );
-    }
-
-    return default_window_proc( hwnd, msg, wparam, lparam, FALSE );
-}
diff --git a/dlls/win32u/dib.c b/dlls/win32u/dib.c
index 7a6df3da7cc..ee82d1a8ed8 100644
--- a/dlls/win32u/dib.c
+++ b/dlls/win32u/dib.c
@@ -733,10 +733,10 @@ INT WINAPI SetDIBits( HDC hdc, HBITMAP hbitmap, UINT startscan,
 
     result = lines;
 
-    OffsetRect( &src.visrect, 0, src_to_dst_offset );
+    offset_rect( &src.visrect, 0, src_to_dst_offset );
     if (!intersect_rect( &dst.visrect, &src.visrect, &dst.visrect )) goto done;
     src.visrect = dst.visrect;
-    OffsetRect( &src.visrect, 0, -src_to_dst_offset );
+    offset_rect( &src.visrect, 0, -src_to_dst_offset );
 
     src.x      = src.visrect.left;
     src.y      = src.visrect.top;
@@ -859,11 +859,11 @@ INT CDECL nulldrv_SetDIBitsToDevice( PHYSDEV dev, INT x_dst, INT y_dst, DWORD cx
     rect.bottom = dst.y + cy;
     if (!clip_visrect( dc, &dst.visrect, &rect )) goto done;
 
-    OffsetRect( &src.visrect, dst.x - src.x, dst.y - src.y );
+    offset_rect( &src.visrect, dst.x - src.x, dst.y - src.y );
     intersect_rect( &rect, &src.visrect, &dst.visrect );
     src.visrect = dst.visrect = rect;
-    OffsetRect( &src.visrect, src.x - dst.x, src.y - dst.y );
-    if (IsRectEmpty( &dst.visrect )) goto done;
+    offset_rect( &src.visrect, src.x - dst.x, src.y - dst.y );
+    if (is_rect_empty( &dst.visrect )) goto done;
     if (clip) NtGdiOffsetRgn( clip, dst.x - src.x, dst.y - src.y );
 
     dev = GET_DC_PHYSDEV( dc, pPutImage );
@@ -1308,10 +1308,10 @@ INT WINAPI NtGdiGetDIBitsInternal( HDC hdc, HBITMAP hbitmap, UINT startscan, UIN
             if (lines < dst.visrect.bottom) dst.visrect.bottom = lines;
         }
 
-        OffsetRect( &dst.visrect, 0, dst_to_src_offset );
+        offset_rect( &dst.visrect, 0, dst_to_src_offset );
         empty_rect = !intersect_rect( &src.visrect, &src.visrect, &dst.visrect );
         dst.visrect = src.visrect;
-        OffsetRect( &dst.visrect, 0, -dst_to_src_offset );
+        offset_rect( &dst.visrect, 0, -dst_to_src_offset );
 
         if (dst_info->bmiHeader.biHeight > 0)
         {
diff --git a/dlls/win32u/dibdrv/bitblt.c b/dlls/win32u/dibdrv/bitblt.c
index 131100b01b0..76330679e59 100644
--- a/dlls/win32u/dibdrv/bitblt.c
+++ b/dlls/win32u/dibdrv/bitblt.c
@@ -716,7 +716,7 @@ static DWORD copy_src_bits( dib_info *src, RECT *src_rect )
     src->bits.free = free_heap_bits;
     src->bits.param = NULL;
 
-    OffsetRect( src_rect, 0, -src_rect->top );
+    offset_rect( src_rect, 0, -src_rect->top );
     return ERROR_SUCCESS;
 }
 
@@ -757,7 +757,7 @@ static DWORD execute_rop( dibdrv_physdev *pdev, const RECT *dst_rect, dib_info *
     rects[SRC] = *src_rect;
     rects[DST] = *dst_rect;
     rects[TMP] = *dst_rect;
-    OffsetRect( &rects[TMP], -rects[TMP].left, -rects[TMP].top );
+    offset_rect( &rects[TMP], -rects[TMP].left, -rects[TMP].top );
 
     for ( ; *opcode; opcode++)
     {
@@ -868,7 +868,7 @@ static DWORD get_image_dib_info( dib_info *dib, BITMAPINFO *info,
         if (dib->stride < 0) bits->ptr = (char *)bits->ptr + (dib->height - 1) * dib->stride;
         src->x += dib->rect.left;
         src->y += dib->rect.top;
-        OffsetRect( &src->visrect, dib->rect.left, dib->rect.top );
+        offset_rect( &src->visrect, dib->rect.left, dib->rect.top );
     }
     return ERROR_SUCCESS;
 }
@@ -1275,7 +1275,7 @@ DWORD stretch_bitmapinfo( const BITMAPINFO *src_info, void *src_bits, struct bit
                 last_row.top = dst_start.y - v_params.dst_inc;
                 last_row.bottom = last_row.top + 1;
                 this_row = last_row;
-                OffsetRect( &this_row, 0, v_params.dst_inc );
+                offset_rect( &this_row, 0, v_params.dst_inc );
                 copy_rect( &dst_dib, &this_row, &dst_dib, &last_row, NULL, R2_COPYPEN );
             }
 
@@ -1315,7 +1315,7 @@ done:
     *src = *dst;
     src->x -= src->visrect.left;
     src->y -= src->visrect.top;
-    OffsetRect( &src->visrect, -src->visrect.left, -src->visrect.top );
+    offset_rect( &src->visrect, -src->visrect.left, -src->visrect.top );
     return ERROR_SUCCESS;
 }
 
diff --git a/dlls/win32u/dibdrv/dc.c b/dlls/win32u/dibdrv/dc.c
index 7c60466d9ee..f29651773c0 100644
--- a/dlls/win32u/dibdrv/dc.c
+++ b/dlls/win32u/dibdrv/dc.c
@@ -244,7 +244,7 @@ DWORD convert_bitmapinfo( const BITMAPINFO *src_info, void *src_bits, struct bit
     /* update coordinates, the destination rectangle is always stored at 0,0 */
     src->x -= src->visrect.left;
     src->y -= src->visrect.top;
-    OffsetRect( &src->visrect, -src->visrect.left, -src->visrect.top );
+    offset_rect( &src->visrect, -src->visrect.left, -src->visrect.top );
     return ERROR_SUCCESS;
 }
 
@@ -254,7 +254,7 @@ int get_dib_rect( const dib_info *dib, RECT *rc )
     rc->top    = max( 0, -dib->rect.top );
     rc->right  = min( dib->rect.right, dib->width ) - dib->rect.left;
     rc->bottom = min( dib->rect.bottom, dib->height ) - dib->rect.top;
-    return !IsRectEmpty( rc );
+    return !is_rect_empty( rc );
 }
 
 int clip_rect_to_dib( const dib_info *dib, RECT *rc )
@@ -317,8 +317,8 @@ void add_clipped_bounds( dibdrv_physdev *dev, const RECT *rect, HRGN clip )
     }
     else rc = *rect;
 
-    if (IsRectEmpty( &rc )) return;
-    OffsetRect( &rc, dev->dib.rect.left, dev->dib.rect.top );
+    if (is_rect_empty( &rc )) return;
+    offset_rect( &rc, dev->dib.rect.left, dev->dib.rect.top );
     add_bounds_rect( dev->bounds, &rc );
 }
 
@@ -709,9 +709,6 @@ const struct gdi_dc_funcs dib_driver =
     dibdrv_StrokePath,                  /* pStrokePath */
     NULL,                               /* pUnrealizePalette */
     NULL,                               /* pD3DKMTCheckVidPnExclusiveOwnership */
-    NULL,                               /* pD3DKMTCloseAdapter */
-    NULL,                               /* pD3DKMTOpenAdapterFromLuid */
-    NULL,                               /* pD3DKMTQueryVideoMemoryInfo */
     NULL,                               /* pD3DKMTSetVidPnSourceOwner */
     GDI_PRIORITY_DIB_DRV                /* priority */
 };
@@ -745,7 +742,7 @@ static inline void lock_surface( struct windrv_physdev *dev )
 {
     /* gdi_lock should not be locked */
     dev->surface->funcs->lock( dev->surface );
-    if (IsRectEmpty( dev->dibdrv->bounds )) dev->start_ticks = NtGetTickCount();
+    if (is_rect_empty( dev->dibdrv->bounds )) dev->start_ticks = NtGetTickCount();
 }
 
 static inline void unlock_surface( struct windrv_physdev *dev )
@@ -791,7 +788,7 @@ void dibdrv_set_window_surface( DC *dc, struct window_surface *surface )
         bits = surface->funcs->get_info( surface, info );
         init_dib_info_from_bitmapinfo( &dibdrv->dib, info, bits );
         dibdrv->dib.rect = dc->attr->vis_rect;
-        OffsetRect( &dibdrv->dib.rect, -dc->device_rect.left, -dc->device_rect.top );
+        offset_rect( &dibdrv->dib.rect, -dc->device_rect.left, -dc->device_rect.top );
         dibdrv->bounds = surface->funcs->get_bounds( surface );
         DC_InitDC( dc );
     }
@@ -1266,9 +1263,6 @@ static const struct gdi_dc_funcs window_driver =
     NULL,                               /* pStrokePath */
     NULL,                               /* pUnrealizePalette */
     NULL,                               /* pD3DKMTCheckVidPnExclusiveOwnership */
-    NULL,                               /* pD3DKMTCloseAdapter */
-    NULL,                               /* pD3DKMTOpenAdapterFromLuid */
-    NULL,                               /* pD3DKMTQueryVideoMemoryInfo */
     NULL,                               /* pD3DKMTSetVidPnSourceOwner */
     GDI_PRIORITY_DIB_DRV + 10           /* priority */
 };
diff --git a/dlls/win32u/dibdrv/objects.c b/dlls/win32u/dibdrv/objects.c
index d9979a05fa6..d137daa1f33 100644
--- a/dlls/win32u/dibdrv/objects.c
+++ b/dlls/win32u/dibdrv/objects.c
@@ -1351,7 +1351,7 @@ static void add_join( dibdrv_physdev *pdev, HRGN region, HRGN round_cap, const P
         /* fall through */
     case PS_JOIN_ROUND:
         NtGdiGetRgnBox( round_cap, &rect );
-        OffsetRect( &rect, pt->x, pt->y );
+        offset_rect( &rect, pt->x, pt->y );
         if (clip_rect_to_dib( &pdev->dib, &rect ))
         {
             NtGdiOffsetRgn( round_cap, pt->x, pt->y );
@@ -1497,13 +1497,13 @@ static BOOL wide_line_segment( dibdrv_physdev *pdev, HRGN total,
         }
 
         if (dx > 0 && dy > 0)
-            SetRect( &clip_rect, seg_pts[0].x, seg_pts[1].y, seg_pts[2].x, seg_pts[3].y );
+            set_rect( &clip_rect, seg_pts[0].x, seg_pts[1].y, seg_pts[2].x, seg_pts[3].y );
         else if (dx > 0 && dy < 0)
-            SetRect( &clip_rect, seg_pts[1].x, seg_pts[2].y, seg_pts[3].x, seg_pts[0].y );
+            set_rect( &clip_rect, seg_pts[1].x, seg_pts[2].y, seg_pts[3].x, seg_pts[0].y );
         else if (dx < 0 && dy > 0)
-            SetRect( &clip_rect, seg_pts[3].x, seg_pts[0].y, seg_pts[1].x, seg_pts[2].y );
+            set_rect( &clip_rect, seg_pts[3].x, seg_pts[0].y, seg_pts[1].x, seg_pts[2].y );
         else
-            SetRect( &clip_rect, seg_pts[2].x, seg_pts[3].y, seg_pts[0].x, seg_pts[1].y );
+            set_rect( &clip_rect, seg_pts[2].x, seg_pts[3].y, seg_pts[0].x, seg_pts[1].y );
         if (clip_rect_to_dib( &pdev->dib, &clip_rect ))
         {
             segment = create_polygon_region( seg_pts, 4, ALTERNATE );
@@ -1779,7 +1779,7 @@ COLORREF CDECL dibdrv_SetDCPenColor( PHYSDEV dev, COLORREF color )
     dibdrv_physdev *pdev = get_dibdrv_pdev(dev);
     DC *dc = get_physdev_dc( dev );
 
-    if (dc->hPen == GetStockObject( DC_PEN ))
+    if (dc->hPen == get_stock_object( DC_PEN ))
         pdev->pen_brush.colorref = color;
 
     return color;
@@ -2145,7 +2145,7 @@ HBRUSH CDECL dibdrv_SelectBrush( PHYSDEV dev, HBRUSH hbrush, const struct brush_
 
     NtGdiExtGetObjectW( hbrush, sizeof(logbrush), &logbrush );
 
-    if (hbrush == GetStockObject( DC_BRUSH ))
+    if (hbrush == get_stock_object( DC_BRUSH ))
         logbrush.lbColor = dc->attr->brush_color;
 
     select_brush( pdev, &pdev->brush, &logbrush, pattern, TRUE );
@@ -2197,7 +2197,7 @@ HPEN CDECL dibdrv_SelectPen( PHYSDEV dev, HPEN hpen, const struct brush_pattern
     pdev->pen_endcap = logpen.lopnStyle & PS_ENDCAP_MASK;
     pdev->pen_width  = get_pen_device_width( dc, logpen.lopnWidth.x );
 
-    if (hpen == GetStockObject( DC_PEN ))
+    if (hpen == get_stock_object( DC_PEN ))
         logbrush.lbColor = dc->attr->pen_color;
 
     set_dash_pattern( &pdev->pen_pattern, 0, NULL );
@@ -2265,7 +2265,7 @@ COLORREF CDECL dibdrv_SetDCBrushColor( PHYSDEV dev, COLORREF color )
     dibdrv_physdev *pdev = get_dibdrv_pdev(dev);
     DC *dc = get_physdev_dc( dev );
 
-    if (dc->hBrush == GetStockObject( DC_BRUSH ))
+    if (dc->hBrush == get_stock_object( DC_BRUSH ))
     {
         LOGBRUSH logbrush = { BS_SOLID, color, 0 };
         select_brush( pdev, &pdev->brush, &logbrush, NULL, TRUE );
diff --git a/dlls/win32u/dibdrv/primitives.c b/dlls/win32u/dibdrv/primitives.c
index 3633c687e78..c3cbc57155e 100644
--- a/dlls/win32u/dibdrv/primitives.c
+++ b/dlls/win32u/dibdrv/primitives.c
@@ -275,7 +275,7 @@ static void solid_rects_32(const dib_info *dib, int num, const RECT *rc, DWORD a
 
     for(i = 0; i < num; i++, rc++)
     {
-        assert( !IsRectEmpty( rc ));
+        assert( !is_rect_empty( rc ));
 
         start = get_pixel_ptr_32(dib, rc->left, rc->top);
         if (and)
@@ -307,7 +307,7 @@ static void solid_rects_24(const dib_info *dib, int num, const RECT *rc, DWORD a
         int left = dib->rect.left + rc->left;
         int right = dib->rect.left + rc->right;
 
-        assert( !IsRectEmpty( rc ));
+        assert( !is_rect_empty( rc ));
 
         if ((left & ~3) == (right & ~3)) /* Special case for lines that start and end in the same DWORD triplet */
         {
@@ -426,7 +426,7 @@ static void solid_rects_16(const dib_info *dib, int num, const RECT *rc, DWORD a
 
     for(i = 0; i < num; i++, rc++)
     {
-        assert( !IsRectEmpty( rc ));
+        assert( !is_rect_empty( rc ));
 
         start = get_pixel_ptr_16(dib, rc->left, rc->top);
         if (and)
@@ -446,7 +446,7 @@ static void solid_rects_8(const dib_info *dib, int num, const RECT *rc, DWORD an
 
     for(i = 0; i < num; i++, rc++)
     {
-        assert( !IsRectEmpty( rc ));
+        assert( !is_rect_empty( rc ));
 
         start = get_pixel_ptr_8(dib, rc->left, rc->top);
         if (and)
@@ -471,7 +471,7 @@ static void solid_rects_4(const dib_info *dib, int num, const RECT *rc, DWORD an
         int left = dib->rect.left + rc->left;
         int right = dib->rect.left + rc->right;
 
-        assert( !IsRectEmpty( rc ));
+        assert( !is_rect_empty( rc ));
 
         start = get_pixel_ptr_4(dib, rc->left, rc->top);
         if (and)
@@ -520,7 +520,7 @@ static void solid_rects_1(const dib_info *dib, int num, const RECT *rc, DWORD an
         int left = dib->rect.left + rc->left;
         int right = dib->rect.left + rc->right;
 
-        assert( !IsRectEmpty( rc ));
+        assert( !is_rect_empty( rc ));
 
         start = get_pixel_ptr_1(dib, rc->left, rc->top);
 
@@ -7466,7 +7466,7 @@ static void calc_halftone_params( const struct bitblt_coords *dst, const struct
     get_bounding_rect( dst_rect, dst->x, dst->y, dst->width, dst->height );
     intersect_rect( src_rect, &src->visrect, src_rect );
     intersect_rect( dst_rect, &dst->visrect, dst_rect );
-    OffsetRect( dst_rect, -dst_rect->left, -dst_rect->top );
+    offset_rect( dst_rect, -dst_rect->left, -dst_rect->top );
 
     src_width = src_rect->right - src_rect->left;
     src_height = src_rect->bottom - src_rect->top;
diff --git a/dlls/win32u/driver.c b/dlls/win32u/driver.c
index 1f538d100ed..f5520dc873a 100644
--- a/dlls/win32u/driver.c
+++ b/dlls/win32u/driver.c
@@ -215,7 +215,7 @@ static INT CDECL nulldrv_GetDeviceCaps( PHYSDEV dev, INT cap )
             dc = get_nulldrv_dc( dev );
             memset( &devmode, 0, sizeof(devmode) );
             devmode.dmSize = sizeof(devmode);
-            RtlInitUnicodeString( &display, dc->display );
+            init_unicode_string( &display, dc->display );
             if (NtUserEnumDisplaySettings( &display, ENUM_CURRENT_SETTINGS, &devmode, 0 ) &&
                 (devmode.dmFields & DM_BITSPERPEL) && devmode.dmBitsPerPel)
                 return devmode.dmBitsPerPel;
@@ -267,7 +267,7 @@ static INT CDECL nulldrv_GetDeviceCaps( PHYSDEV dev, INT cap )
 
         memset( &devmode, 0, sizeof(devmode) );
         devmode.dmSize = sizeof(devmode);
-        RtlInitUnicodeString( &display, dc->display );
+        init_unicode_string( &display, dc->display );
         if (NtUserEnumDisplaySettings( &display, ENUM_CURRENT_SETTINGS, &devmode, 0 ) &&
             devmode.dmDisplayFrequency)
             return devmode.dmDisplayFrequency;
@@ -550,21 +550,6 @@ static NTSTATUS CDECL nulldrv_D3DKMTCheckVidPnExclusiveOwnership( const D3DKMT_C
     return STATUS_PROCEDURE_NOT_FOUND;
 }
 
-static NTSTATUS CDECL nulldrv_D3DKMTCloseAdapter( const D3DKMT_CLOSEADAPTER *desc )
-{
-    return STATUS_PROCEDURE_NOT_FOUND;
-}
-
-static NTSTATUS CDECL nulldrv_D3DKMTOpenAdapterFromLuid( D3DKMT_OPENADAPTERFROMLUID *desc )
-{
-    return STATUS_PROCEDURE_NOT_FOUND;
-}
-
-static NTSTATUS CDECL nulldrv_D3DKMTQueryVideoMemoryInfo( D3DKMT_QUERYVIDEOMEMORYINFO *desc )
-{
-    return STATUS_PROCEDURE_NOT_FOUND;
-}
-
 static NTSTATUS CDECL nulldrv_D3DKMTSetVidPnSourceOwner( const D3DKMT_SETVIDPNSOURCEOWNER *desc )
 {
     return STATUS_PROCEDURE_NOT_FOUND;
@@ -662,9 +647,6 @@ const struct gdi_dc_funcs null_driver =
     nulldrv_StrokePath,                 /* pStrokePath */
     nulldrv_UnrealizePalette,           /* pUnrealizePalette */
     nulldrv_D3DKMTCheckVidPnExclusiveOwnership, /* pD3DKMTCheckVidPnExclusiveOwnership */
-    nulldrv_D3DKMTCloseAdapter,         /* pD3DKMTCloseAdapter */
-    nulldrv_D3DKMTOpenAdapterFromLuid,  /* pD3DKMTOpenAdapterFromLuid */
-    nulldrv_D3DKMTQueryVideoMemoryInfo, /* pD3DKMTQueryVideoMemoryInfo */
     nulldrv_D3DKMTSetVidPnSourceOwner,  /* pD3DKMTSetVidPnSourceOwner */
 
     GDI_PRIORITY_NULL_DRV               /* priority */
@@ -677,111 +659,106 @@ const struct gdi_dc_funcs null_driver =
  * These are fallbacks for entry points that are not implemented in the real driver.
  */
 
-static BOOL nulldrv_ActivateKeyboardLayout( HKL layout, UINT flags )
+static BOOL CDECL nulldrv_ActivateKeyboardLayout( HKL layout, UINT flags )
 {
     return TRUE;
 }
 
-static void nulldrv_Beep(void)
+static void CDECL nulldrv_Beep(void)
 {
 }
 
-static UINT nulldrv_GetKeyboardLayoutList( INT size, HKL *layouts )
+static UINT CDECL nulldrv_GetKeyboardLayoutList( INT size, HKL *layouts )
 {
     return ~0; /* use default implementation */
 }
 
-static INT nulldrv_GetKeyNameText( LONG lparam, LPWSTR buffer, INT size )
+static INT CDECL nulldrv_GetKeyNameText( LONG lparam, LPWSTR buffer, INT size )
 {
     return -1; /* use default implementation */
 }
 
-static UINT nulldrv_MapVirtualKeyEx( UINT code, UINT type, HKL layout )
+static UINT CDECL nulldrv_MapVirtualKeyEx( UINT code, UINT type, HKL layout )
 {
     return -1; /* use default implementation */
 }
 
-static BOOL nulldrv_RegisterHotKey( HWND hwnd, UINT modifiers, UINT vk )
+static BOOL CDECL nulldrv_RegisterHotKey( HWND hwnd, UINT modifiers, UINT vk )
 {
     return TRUE;
 }
 
-static INT nulldrv_ToUnicodeEx( UINT virt, UINT scan, const BYTE *state, LPWSTR str,
-                                int size, UINT flags, HKL layout )
+static INT CDECL nulldrv_ToUnicodeEx( UINT virt, UINT scan, const BYTE *state, LPWSTR str,
+                                      int size, UINT flags, HKL layout )
 {
     return -2; /* use default implementation */
 }
 
-static void nulldrv_UnregisterHotKey( HWND hwnd, UINT modifiers, UINT vk )
+static void CDECL nulldrv_UnregisterHotKey( HWND hwnd, UINT modifiers, UINT vk )
 {
 }
 
-static SHORT nulldrv_VkKeyScanEx( WCHAR ch, HKL layout )
+static SHORT CDECL nulldrv_VkKeyScanEx( WCHAR ch, HKL layout )
 {
     return -256; /* use default implementation */
 }
 
-static LRESULT nulldrv_DesktopWindowProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
+static void CDECL nulldrv_DestroyCursorIcon( HCURSOR cursor )
 {
-    return default_window_proc( hwnd, msg, wparam, lparam, FALSE );
 }
 
-static void nulldrv_DestroyCursorIcon( HCURSOR cursor )
+static void CDECL nulldrv_SetCursor( HCURSOR cursor )
 {
 }
 
-static void nulldrv_SetCursor( HCURSOR cursor )
-{
-}
-
-static BOOL nulldrv_GetCursorPos( LPPOINT pt )
+static BOOL CDECL nulldrv_GetCursorPos( LPPOINT pt )
 {
     return TRUE;
 }
 
-static BOOL nulldrv_SetCursorPos( INT x, INT y )
+static BOOL CDECL nulldrv_SetCursorPos( INT x, INT y )
 {
     return TRUE;
 }
 
-static BOOL nulldrv_ClipCursor( LPCRECT clip )
+static BOOL CDECL nulldrv_ClipCursor( LPCRECT clip )
 {
     return TRUE;
 }
 
-static void nulldrv_UpdateClipboard(void)
+static void CDECL nulldrv_UpdateClipboard(void)
 {
 }
 
-static LONG nulldrv_ChangeDisplaySettingsEx( LPCWSTR name, LPDEVMODEW mode, HWND hwnd,
-                                             DWORD flags, LPVOID lparam )
+static LONG CDECL nulldrv_ChangeDisplaySettingsEx( LPCWSTR name, LPDEVMODEW mode, HWND hwnd,
+                                                   DWORD flags, LPVOID lparam )
 {
     return DISP_CHANGE_FAILED;
 }
 
-static BOOL nulldrv_EnumDisplaySettingsEx( LPCWSTR name, DWORD num, LPDEVMODEW mode, DWORD flags )
+static BOOL CDECL nulldrv_EnumDisplaySettingsEx( LPCWSTR name, DWORD num, LPDEVMODEW mode, DWORD flags )
 {
     return FALSE;
 }
 
-static void nulldrv_UpdateDisplayDevices( const struct gdi_device_manager *manager,
-                                          BOOL force, void *param )
+static void CDECL nulldrv_UpdateDisplayDevices( const struct gdi_device_manager *manager,
+                                                BOOL force, void *param )
 {
     manager->add_monitor( NULL, param ); /* use virtual monitor */
 }
 
-static BOOL nulldrv_CreateDesktopWindow( HWND hwnd )
+static BOOL CDECL nulldrv_CreateDesktopWindow( HWND hwnd )
 {
     return TRUE;
 }
 
-static BOOL nodrv_CreateWindow( HWND hwnd )
+static BOOL CDECL nodrv_CreateWindow( HWND hwnd )
 {
     static int warned;
     HWND parent = NtUserGetAncestor( hwnd, GA_PARENT );
 
     /* HWND_MESSAGE windows don't need a graphics driver */
-    if (!parent || parent == NtUserGetThreadInfo()->msg_window) return TRUE;
+    if (!parent || parent == get_user_thread_info()->msg_window) return TRUE;
     if (warned++) return FALSE;
 
     ERR_(winediag)( "Application tried to create a window, but no driver could be loaded.\n" );
@@ -789,42 +766,75 @@ static BOOL nodrv_CreateWindow( HWND hwnd )
     return FALSE;
 }
 
-static BOOL nulldrv_CreateWindow( HWND hwnd )
+static BOOL CDECL nulldrv_CreateWindow( HWND hwnd )
 {
     return TRUE;
 }
 
-static void nulldrv_DestroyWindow( HWND hwnd )
+static void CDECL nulldrv_DestroyWindow( HWND hwnd )
+{
+}
+
+static void CDECL nulldrv_FlashWindowEx( FLASHWINFO *info )
+{
+}
+
+static void CDECL nulldrv_GetDC( HDC hdc, HWND hwnd, HWND top_win, const RECT *win_rect,
+                                 const RECT *top_rect, DWORD flags )
 {
 }
 
-static void nulldrv_FlashWindowEx( FLASHWINFO *info )
+/* helper for kernel32->ntdll timeout format conversion */
+static inline LARGE_INTEGER *get_nt_timeout( LARGE_INTEGER *time, DWORD timeout )
 {
+    if (timeout == INFINITE) return NULL;
+    time->QuadPart = (ULONGLONG)timeout * -10000;
+    return time;
 }
 
-static void nulldrv_GetDC( HDC hdc, HWND hwnd, HWND top_win, const RECT *win_rect,
-                           const RECT *top_rect, DWORD flags )
+static HANDLE normalize_std_handle( HANDLE handle )
 {
+    if (handle == (HANDLE)STD_INPUT_HANDLE)
+        return NtCurrentTeb()->Peb->ProcessParameters->hStdInput;
+    if (handle == (HANDLE)STD_OUTPUT_HANDLE)
+        return NtCurrentTeb()->Peb->ProcessParameters->hStdOutput;
+    if (handle == (HANDLE)STD_ERROR_HANDLE)
+        return NtCurrentTeb()->Peb->ProcessParameters->hStdError;
+
+    return handle;
 }
 
-static NTSTATUS nulldrv_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                                     const LARGE_INTEGER *timeout,
-                                                     DWORD mask, DWORD flags )
+static DWORD CDECL nulldrv_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles, DWORD timeout,
+                                                        DWORD mask, DWORD flags )
 {
-    if (!count && timeout && !timeout->QuadPart) return WAIT_TIMEOUT;
+    NTSTATUS status;
+    HANDLE hloc[MAXIMUM_WAIT_OBJECTS];
+    LARGE_INTEGER time;
+    unsigned int i;
+
+    if (!count && !timeout) return WAIT_TIMEOUT;
+    if (count > MAXIMUM_WAIT_OBJECTS)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return WAIT_FAILED;
+    }
+    for (i = 0; i < count; i++) hloc[i] = normalize_std_handle( handles[i] );
 
-    if (!user_callbacks)
-        return NtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                         !!(flags & MWMO_ALERTABLE), timeout );
-    return user_callbacks->pNtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                                      !!(flags & MWMO_ALERTABLE), timeout );
+    status = NtWaitForMultipleObjects( count, hloc, !(flags & MWMO_WAITALL), !!(flags & MWMO_ALERTABLE),
+                                       get_nt_timeout( &time, timeout ) );
+    if (HIWORD(status))  /* is it an error code? */
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        status = WAIT_FAILED;
+    }
+    return status;
 }
 
-static void nulldrv_ReleaseDC( HWND hwnd, HDC hdc )
+static void CDECL nulldrv_ReleaseDC( HWND hwnd, HDC hdc )
 {
 }
 
-static BOOL nulldrv_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update )
+static BOOL CDECL nulldrv_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update )
 {
     RECT rect;
 
@@ -833,90 +843,99 @@ static BOOL nulldrv_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update )
                         hdc, rect.left - dx, rect.top - dy, SRCCOPY, 0, 0 );
 }
 
-static void nulldrv_SetCapture( HWND hwnd, UINT flags )
+static void CDECL nulldrv_SetCapture( HWND hwnd, UINT flags )
 {
 }
 
-static void nulldrv_SetFocus( HWND hwnd )
+static void CDECL nulldrv_SetFocus( HWND hwnd )
 {
 }
 
-static void nulldrv_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags )
+static void CDECL nulldrv_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags )
 {
 }
 
-static void nulldrv_SetParent( HWND hwnd, HWND parent, HWND old_parent )
+static void CDECL nulldrv_SetParent( HWND hwnd, HWND parent, HWND old_parent )
 {
 }
 
-static void nulldrv_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
+static void CDECL nulldrv_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
 {
 }
 
-static void nulldrv_SetWindowIcon( HWND hwnd, UINT type, HICON icon )
+static void CDECL nulldrv_SetWindowIcon( HWND hwnd, UINT type, HICON icon )
 {
 }
 
-static void nulldrv_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
+static void CDECL nulldrv_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
 {
 }
 
-static void nulldrv_SetWindowText( HWND hwnd, LPCWSTR text )
+static void CDECL nulldrv_SetWindowText( HWND hwnd, LPCWSTR text )
 {
 }
 
-static UINT nulldrv_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp )
+static UINT CDECL nulldrv_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp )
 {
     return ~0; /* use default implementation */
 }
 
-static LRESULT nulldrv_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam )
+static LRESULT CDECL nulldrv_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam )
 {
     return -1;
 }
 
-static BOOL nulldrv_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
-                                         const RECT *window_rect )
+static BOOL CDECL nulldrv_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                               const RECT *window_rect )
 {
     return TRUE;
 }
 
-static LRESULT nulldrv_WindowMessage( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
+static LRESULT CDECL nulldrv_WindowMessage( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 {
     return 0;
 }
 
-static BOOL nulldrv_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flags,
-                                       const RECT *window_rect, const RECT *client_rect,
-                                       RECT *visible_rect, struct window_surface **surface )
+static BOOL CDECL nulldrv_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                             const RECT *window_rect, const RECT *client_rect,
+                                             RECT *visible_rect, struct window_surface **surface )
 {
     return FALSE;
 }
 
-static void nulldrv_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
-                                      const RECT *window_rect, const RECT *client_rect,
-                                      const RECT *visible_rect, const RECT *valid_rects,
-                                      struct window_surface *surface )
+static void CDECL nulldrv_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                            const RECT *window_rect, const RECT *client_rect,
+                                            const RECT *visible_rect, const RECT *valid_rects,
+                                            struct window_surface *surface )
 {
 }
 
-static BOOL nulldrv_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param, UINT flags )
+static BOOL CDECL nulldrv_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param, UINT flags )
 {
     return FALSE;
 }
 
-static const struct vulkan_funcs *nulldrv_wine_get_vulkan_driver( UINT version )
+static const struct vulkan_funcs * CDECL nulldrv_wine_get_vulkan_driver( UINT version )
 {
     return NULL;
 }
 
-static struct opengl_funcs *nulldrv_wine_get_wgl_driver( UINT version )
+static struct opengl_funcs * CDECL nulldrv_wine_get_wgl_driver( UINT version )
 {
     return (void *)-1;
 }
 
-static void nulldrv_ThreadDetach( void )
+static void CDECL nulldrv_ThreadDetach( void )
+{
+}
+
+static BOOL setup_null_driver(void)
 {
+    if (user_callbacks)
+        user_callbacks->set_user_driver( &null_user_driver, WINE_GDI_DRIVER_VERSION );
+    else
+        __wine_set_display_driver( &null_user_driver, WINE_GDI_DRIVER_VERSION );
+    return TRUE;
 }
 
 static const WCHAR guid_key_prefixW[] =
@@ -975,11 +994,7 @@ static BOOL load_desktop_driver( HWND hwnd )
             ret = KeUserModeCallback( NtUserLoadDriver, info->Data, info->DataLength,
                                       &ret_ptr, &ret_len );
         }
-        else
-        {
-            __wine_set_user_driver( &null_user_driver, WINE_GDI_DRIVER_VERSION );
-            ret = TRUE;
-        }
+        else ret = setup_null_driver();
     }
     else if ((size = query_reg_ascii_value( hkey, "DriverError", info, sizeof(buf) )))
     {
@@ -1010,7 +1025,7 @@ static const struct user_driver_funcs *load_driver(void)
             || (flags.dwFlags & WSF_VISIBLE))
             null_user_driver.pCreateWindow = nodrv_CreateWindow;
 
-        __wine_set_user_driver( &null_user_driver, WINE_GDI_DRIVER_VERSION );
+        setup_null_driver();
     }
 
     return user_driver;
@@ -1025,210 +1040,189 @@ const struct gdi_dc_funcs *get_display_driver(void)
     return &user_driver->dc_funcs;
 }
 
-static BOOL loaderdrv_ActivateKeyboardLayout( HKL layout, UINT flags )
+static BOOL CDECL loaderdrv_ActivateKeyboardLayout( HKL layout, UINT flags )
 {
     return load_driver()->pActivateKeyboardLayout( layout, flags );
 }
 
-static void loaderdrv_Beep(void)
+static void CDECL loaderdrv_Beep(void)
 {
     load_driver()->pBeep();
 }
 
-static INT loaderdrv_GetKeyNameText( LONG lparam, LPWSTR buffer, INT size )
+static INT CDECL loaderdrv_GetKeyNameText( LONG lparam, LPWSTR buffer, INT size )
 {
     return load_driver()->pGetKeyNameText( lparam, buffer, size );
 }
 
-static UINT loaderdrv_GetKeyboardLayoutList( INT size, HKL *layouts )
+static UINT CDECL loaderdrv_GetKeyboardLayoutList( INT size, HKL *layouts )
 {
     return load_driver()->pGetKeyboardLayoutList( size, layouts );
 }
 
-static UINT loaderdrv_MapVirtualKeyEx( UINT code, UINT type, HKL layout )
+static UINT CDECL loaderdrv_MapVirtualKeyEx( UINT code, UINT type, HKL layout )
 {
     return load_driver()->pMapVirtualKeyEx( code, type, layout );
 }
 
-static INT loaderdrv_ToUnicodeEx( UINT virt, UINT scan, const BYTE *state, LPWSTR str,
+static INT CDECL loaderdrv_ToUnicodeEx( UINT virt, UINT scan, const BYTE *state, LPWSTR str,
                                         int size, UINT flags, HKL layout )
 {
     return load_driver()->pToUnicodeEx( virt, scan, state, str, size, flags, layout );
 }
 
-static BOOL loaderdrv_RegisterHotKey( HWND hwnd, UINT modifiers, UINT vk )
+static BOOL CDECL loaderdrv_RegisterHotKey( HWND hwnd, UINT modifiers, UINT vk )
 {
     return load_driver()->pRegisterHotKey( hwnd, modifiers, vk );
 }
 
-static void loaderdrv_UnregisterHotKey( HWND hwnd, UINT modifiers, UINT vk )
+static void CDECL loaderdrv_UnregisterHotKey( HWND hwnd, UINT modifiers, UINT vk )
 {
     load_driver()->pUnregisterHotKey( hwnd, modifiers, vk );
 }
 
-static SHORT loaderdrv_VkKeyScanEx( WCHAR ch, HKL layout )
+static SHORT CDECL loaderdrv_VkKeyScanEx( WCHAR ch, HKL layout )
 {
     return load_driver()->pVkKeyScanEx( ch, layout );
 }
 
-static LONG loaderdrv_ChangeDisplaySettingsEx( LPCWSTR name, LPDEVMODEW mode, HWND hwnd,
+static LONG CDECL loaderdrv_ChangeDisplaySettingsEx( LPCWSTR name, LPDEVMODEW mode, HWND hwnd,
                                                      DWORD flags, LPVOID lparam )
 {
     return load_driver()->pChangeDisplaySettingsEx( name, mode, hwnd, flags, lparam );
 }
 
-static BOOL loaderdrv_EnumDisplaySettingsEx( LPCWSTR name, DWORD num, LPDEVMODEW mode, DWORD flags )
+static BOOL CDECL loaderdrv_EnumDisplaySettingsEx( LPCWSTR name, DWORD num, LPDEVMODEW mode, DWORD flags )
 {
     return load_driver()->pEnumDisplaySettingsEx( name, num, mode, flags );
 }
 
-static void loaderdrv_SetCursor( HCURSOR cursor )
+static void CDECL loaderdrv_SetCursor( HCURSOR cursor )
 {
     load_driver()->pSetCursor( cursor );
 }
 
-static BOOL loaderdrv_GetCursorPos( POINT *pt )
+static BOOL CDECL loaderdrv_GetCursorPos( POINT *pt )
 {
     return load_driver()->pGetCursorPos( pt );
 }
 
-static BOOL loaderdrv_SetCursorPos( INT x, INT y )
+static BOOL CDECL loaderdrv_SetCursorPos( INT x, INT y )
 {
     return load_driver()->pSetCursorPos( x, y );
 }
 
-static BOOL loaderdrv_ClipCursor( const RECT *clip )
+static BOOL CDECL loaderdrv_ClipCursor( const RECT *clip )
 {
     return load_driver()->pClipCursor( clip );
 }
 
-static LRESULT nulldrv_ClipboardWindowProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    return 0;
-}
-
-static void loaderdrv_UpdateClipboard(void)
+static void CDECL loaderdrv_UpdateClipboard(void)
 {
     load_driver()->pUpdateClipboard();
 }
 
-static void loaderdrv_UpdateDisplayDevices( const struct gdi_device_manager *manager,
-                                            BOOL force, void *param )
+static void CDECL loaderdrv_UpdateDisplayDevices( const struct gdi_device_manager *manager,
+                                                  BOOL force, void *param )
 {
     load_driver()->pUpdateDisplayDevices( manager, force, param );
 }
 
-static BOOL loaderdrv_CreateDesktopWindow( HWND hwnd )
+static BOOL CDECL loaderdrv_CreateDesktopWindow( HWND hwnd )
 {
     return load_driver()->pCreateDesktopWindow( hwnd );
 }
 
-static BOOL loaderdrv_CreateWindow( HWND hwnd )
-{
-    return load_driver()->pCreateWindow( hwnd );
-}
-
-static void loaderdrv_GetDC( HDC hdc, HWND hwnd, HWND top_win, const RECT *win_rect,
-                             const RECT *top_rect, DWORD flags )
+static void CDECL loaderdrv_GetDC( HDC hdc, HWND hwnd, HWND top_win, const RECT *win_rect,
+                                   const RECT *top_rect, DWORD flags )
 {
     load_driver()->pGetDC( hdc, hwnd, top_win, win_rect, top_rect, flags );
 }
 
-static void loaderdrv_FlashWindowEx( FLASHWINFO *info )
+static void CDECL loaderdrv_FlashWindowEx( FLASHWINFO *info )
 {
     load_driver()->pFlashWindowEx( info );
 }
 
-static void loaderdrv_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags )
+static void CDECL loaderdrv_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags )
 {
     load_driver()->pSetLayeredWindowAttributes( hwnd, key, alpha, flags );
 }
 
-static void loaderdrv_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
+static void CDECL loaderdrv_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
 {
     load_driver()->pSetWindowRgn( hwnd, hrgn, redraw );
 }
 
-static BOOL loaderdrv_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
-                                           const RECT *window_rect )
+static BOOL CDECL loaderdrv_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                                 const RECT *window_rect )
 {
     return load_driver()->pUpdateLayeredWindow( hwnd, info, window_rect );
 }
 
-static const struct vulkan_funcs * loaderdrv_wine_get_vulkan_driver( UINT version )
+static const struct vulkan_funcs * CDECL loaderdrv_wine_get_vulkan_driver( UINT version )
 {
     return load_driver()->pwine_get_vulkan_driver( version );
 }
 
 static const struct user_driver_funcs lazy_load_driver =
 {
-    { NULL },
     /* keyboard functions */
-    loaderdrv_ActivateKeyboardLayout,
-    loaderdrv_Beep,
-    loaderdrv_GetKeyNameText,
-    loaderdrv_GetKeyboardLayoutList,
-    loaderdrv_MapVirtualKeyEx,
-    loaderdrv_RegisterHotKey,
-    loaderdrv_ToUnicodeEx,
-    loaderdrv_UnregisterHotKey,
-    loaderdrv_VkKeyScanEx,
+    .pActivateKeyboardLayout = loaderdrv_ActivateKeyboardLayout,
+    .pBeep = loaderdrv_Beep,
+    .pGetKeyNameText = loaderdrv_GetKeyNameText,
+    .pGetKeyboardLayoutList = loaderdrv_GetKeyboardLayoutList,
+    .pMapVirtualKeyEx = loaderdrv_MapVirtualKeyEx,
+    .pToUnicodeEx = loaderdrv_ToUnicodeEx,
+    .pRegisterHotKey = loaderdrv_RegisterHotKey,
+    .pUnregisterHotKey = loaderdrv_UnregisterHotKey,
+    .pVkKeyScanEx = loaderdrv_VkKeyScanEx,
     /* cursor/icon functions */
-    nulldrv_DestroyCursorIcon,
-    loaderdrv_SetCursor,
-    loaderdrv_GetCursorPos,
-    loaderdrv_SetCursorPos,
-    loaderdrv_ClipCursor,
+    .pDestroyCursorIcon = nulldrv_DestroyCursorIcon,
+    .pSetCursor = loaderdrv_SetCursor,
+    .pGetCursorPos = loaderdrv_GetCursorPos,
+    .pSetCursorPos = loaderdrv_SetCursorPos,
+    .pClipCursor = loaderdrv_ClipCursor,
     /* clipboard functions */
-    nulldrv_ClipboardWindowProc,
-    loaderdrv_UpdateClipboard,
+    .pUpdateClipboard = loaderdrv_UpdateClipboard,
     /* display modes */
-    loaderdrv_ChangeDisplaySettingsEx,
-    loaderdrv_EnumDisplaySettingsEx,
-    loaderdrv_UpdateDisplayDevices,
+    .pChangeDisplaySettingsEx = loaderdrv_ChangeDisplaySettingsEx,
+    .pEnumDisplaySettingsEx = loaderdrv_EnumDisplaySettingsEx,
+    .pUpdateDisplayDevices = loaderdrv_UpdateDisplayDevices,
     /* windowing functions */
-    loaderdrv_CreateDesktopWindow,
-    loaderdrv_CreateWindow,
-    nulldrv_DesktopWindowProc,
-    nulldrv_DestroyWindow,
-    loaderdrv_FlashWindowEx,
-    loaderdrv_GetDC,
-    nulldrv_MsgWaitForMultipleObjectsEx,
-    nulldrv_ReleaseDC,
-    nulldrv_ScrollDC,
-    nulldrv_SetCapture,
-    nulldrv_SetFocus,
-    loaderdrv_SetLayeredWindowAttributes,
-    nulldrv_SetParent,
-    loaderdrv_SetWindowRgn,
-    nulldrv_SetWindowIcon,
-    nulldrv_SetWindowStyle,
-    nulldrv_SetWindowText,
-    nulldrv_ShowWindow,
-    nulldrv_SysCommand,
-    loaderdrv_UpdateLayeredWindow,
-    nulldrv_WindowMessage,
-    nulldrv_WindowPosChanging,
-    nulldrv_WindowPosChanged,
+    .pCreateDesktopWindow = loaderdrv_CreateDesktopWindow,
+    .pDestroyWindow = nulldrv_DestroyWindow,
+    .pFlashWindowEx = loaderdrv_FlashWindowEx,
+    .pGetDC = loaderdrv_GetDC,
+    .pSetCapture = nulldrv_SetCapture,
+    .pSetLayeredWindowAttributes = loaderdrv_SetLayeredWindowAttributes,
+    .pSetParent = nulldrv_SetParent,
+    .pSetWindowRgn = loaderdrv_SetWindowRgn,
+    .pSetWindowStyle = nulldrv_SetWindowStyle,
+    .pMsgWaitForMultipleObjectsEx = nulldrv_MsgWaitForMultipleObjectsEx,
+    .pReleaseDC =  nulldrv_ReleaseDC,
+    .pScrollDC = nulldrv_ScrollDC,
+    .pSetFocus = nulldrv_SetFocus,
+    .pShowWindow = nulldrv_ShowWindow,
+    .pUpdateLayeredWindow = loaderdrv_UpdateLayeredWindow,
+    .pWindowMessage = nulldrv_WindowMessage,
     /* system parameters */
-    nulldrv_SystemParametersInfo,
+    .pSystemParametersInfo = nulldrv_SystemParametersInfo,
     /* vulkan support */
-    loaderdrv_wine_get_vulkan_driver,
+    .pwine_get_vulkan_driver = loaderdrv_wine_get_vulkan_driver,
     /* opengl support */
-    nulldrv_wine_get_wgl_driver,
+    .pwine_get_wgl_driver = nulldrv_wine_get_wgl_driver,
     /* thread management */
-    nulldrv_ThreadDetach,
+    .pThreadDetach = nulldrv_ThreadDetach,
 };
 
 const struct user_driver_funcs *user_driver = &lazy_load_driver;
 
 /******************************************************************************
- *	     __wine_set_user_driver   (win32u.@)
+ *	     __wine_set_display_driver   (win32u.@)
  */
-void CDECL __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT version )
+void CDECL __wine_set_display_driver( struct user_driver_funcs *driver, UINT version )
 {
-    struct user_driver_funcs *driver, *prev;
-
     if (version != WINE_GDI_DRIVER_VERSION)
     {
         ERR( "version mismatch, driver wants %u but win32u has %u\n",
@@ -1236,9 +1230,6 @@ void CDECL __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT v
         return;
     }
 
-    driver = malloc( sizeof(*driver) );
-    *driver = *funcs;
-
 #define SET_USER_FUNC(name) \
     do { if (!driver->p##name) driver->p##name = nulldrv_##name; } while(0)
 
@@ -1256,14 +1247,12 @@ void CDECL __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT v
     SET_USER_FUNC(GetCursorPos);
     SET_USER_FUNC(SetCursorPos);
     SET_USER_FUNC(ClipCursor);
-    SET_USER_FUNC(ClipboardWindowProc);
     SET_USER_FUNC(UpdateClipboard);
     SET_USER_FUNC(ChangeDisplaySettingsEx);
     SET_USER_FUNC(EnumDisplaySettingsEx);
     SET_USER_FUNC(UpdateDisplayDevices);
     SET_USER_FUNC(CreateDesktopWindow);
     SET_USER_FUNC(CreateWindow);
-    SET_USER_FUNC(DesktopWindowProc);
     SET_USER_FUNC(DestroyWindow);
     SET_USER_FUNC(FlashWindowEx);
     SET_USER_FUNC(GetDC);
@@ -1290,13 +1279,7 @@ void CDECL __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT v
     SET_USER_FUNC(ThreadDetach);
 #undef SET_USER_FUNC
 
-    prev = InterlockedCompareExchangePointer( (void **)&user_driver, driver, (void *)&lazy_load_driver );
-    if (prev != &lazy_load_driver)
-    {
-        /* another thread beat us to it */
-        free( driver );
-        driver = prev;
-    }
+    InterlockedExchangePointer( (void **)&user_driver, driver );
 }
 
 /******************************************************************************
@@ -1351,9 +1334,6 @@ NTSTATUS WINAPI NtGdiDdDDICloseAdapter( const D3DKMT_CLOSEADAPTER *desc )
     if (!desc || !desc->hAdapter)
         return STATUS_INVALID_PARAMETER;
 
-    if (get_display_driver()->pD3DKMTCloseAdapter)
-        get_display_driver()->pD3DKMTCloseAdapter( desc );
-
     pthread_mutex_lock( &driver_lock );
     LIST_FOR_EACH_ENTRY( adapter, &d3dkmt_adapters, struct d3dkmt_adapter, entry )
     {
@@ -1404,10 +1384,6 @@ NTSTATUS WINAPI NtGdiDdDDIOpenAdapterFromLuid( D3DKMT_OPENADAPTERFROMLUID *desc
     desc->hAdapter = adapter->handle = ++handle_start;
     list_add_tail( &d3dkmt_adapters, &adapter->entry );
     pthread_mutex_unlock( &driver_lock );
-
-    if (get_display_driver()->pD3DKMTOpenAdapterFromLuid)
-        get_display_driver()->pD3DKMTOpenAdapterFromLuid( desc );
-
     return STATUS_SUCCESS;
 }
 
@@ -1498,37 +1474,6 @@ NTSTATUS WINAPI NtGdiDdDDIQueryStatistics( D3DKMT_QUERYSTATISTICS *stats )
     return STATUS_SUCCESS;
 }
 
-/******************************************************************************
- *           NtGdiDdDDIQueryVideoMemoryInfo    (win32u.@)
- */
-NTSTATUS WINAPI NtGdiDdDDIQueryVideoMemoryInfo( D3DKMT_QUERYVIDEOMEMORYINFO *desc )
-{
-    OBJECT_BASIC_INFORMATION info;
-    NTSTATUS status;
-
-    TRACE("(%p)\n", desc);
-
-    if (!desc || !desc->hAdapter ||
-        (desc->MemorySegmentGroup != D3DKMT_MEMORY_SEGMENT_GROUP_LOCAL &&
-         desc->MemorySegmentGroup != D3DKMT_MEMORY_SEGMENT_GROUP_NON_LOCAL))
-        return STATUS_INVALID_PARAMETER;
-
-    /* FIXME: Wine currently doesn't support linked adapters */
-    if (desc->PhysicalAdapterIndex > 0)
-        return STATUS_INVALID_PARAMETER;
-
-    status = NtQueryObject(desc->hProcess ? desc->hProcess : GetCurrentProcess(),
-                           ObjectBasicInformation, &info, sizeof(info), NULL);
-    if (status != STATUS_SUCCESS)
-        return status;
-    if (!(info.GrantedAccess & PROCESS_QUERY_INFORMATION))
-        return STATUS_ACCESS_DENIED;
-
-    if (!get_display_driver()->pD3DKMTQueryVideoMemoryInfo)
-        return STATUS_PROCEDURE_NOT_FOUND;
-    return get_display_driver()->pD3DKMTQueryVideoMemoryInfo(desc);
-}
-
 /******************************************************************************
  *           NtGdiDdDDISetQueuedLimit    (win32u.@)
  */
diff --git a/dlls/win32u/emfdrv.c b/dlls/win32u/emfdrv.c
index 848a5bbaa4b..81481953288 100644
--- a/dlls/win32u/emfdrv.c
+++ b/dlls/win32u/emfdrv.c
@@ -523,9 +523,6 @@ static const struct gdi_dc_funcs emfdrv_driver =
     EMFDRV_StrokePath,               /* pStrokePath */
     NULL,                            /* pUnrealizePalette */
     NULL,                            /* pD3DKMTCheckVidPnExclusiveOwnership */
-    NULL,                            /* pD3DKMTCloseAdapter */
-    NULL,                            /* pD3DKMTOpenAdapterFromLuid */
-    NULL,                            /* pD3DKMTQueryVideoMemoryInfo */
     NULL,                            /* pD3DKMTSetVidPnSourceOwner */
     GDI_PRIORITY_GRAPHICS_DRV        /* priority */
 };
diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 571379976a5..22df0fafc96 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -199,9 +199,15 @@ static struct font_gamma_ramp font_gamma_ramp;
 static void add_face_to_cache( struct gdi_font_face *face );
 static void remove_face_from_cache( struct gdi_font_face *face );
 
-static CPTABLEINFO utf8_cp;
-static CPTABLEINFO oem_cp;
-CPTABLEINFO ansi_cp = { 0 };
+UINT get_acp(void)
+{
+    return ((const WORD *)NtCurrentTeb()->Peb->AnsiCodePageData)[1];
+}
+
+static UINT get_oemcp(void)
+{
+    return ((const WORD *)NtCurrentTeb()->Peb->OemCodePageData)[1];
+}
 
 static inline WCHAR facename_tolower( WCHAR c )
 {
@@ -271,6 +277,15 @@ static inline INT INTERNAL_YWSTODS(DC *dc, INT height)
     return pt[1].y - pt[0].y;
 }
 
+static inline WCHAR *strdupW( const WCHAR *p )
+{
+    WCHAR *ret;
+    DWORD len = (lstrlenW(p) + 1) * sizeof(WCHAR);
+    ret = malloc( len );
+    memcpy(ret, p, len);
+    return ret;
+}
+
 static INT FONT_GetObjectW( HGDIOBJ handle, INT count, LPVOID buffer );
 static BOOL FONT_DeleteObject( HGDIOBJ handle );
 
@@ -352,11 +367,6 @@ static const struct nls_update_font_list
       "coure.fon", "serife.fon", "smalle.fon", "sserife.fon", "sseriff.fon",
       "Tahoma","Times New Roman"  /* FIXME unverified */
     },
-    /* UTF-8 */
-    { CP_UTF8, CP_UTF8, "vga850.fon", "vgafix.fon", "vgasys.fon",
-      "coure.fon", "serife.fon", "smalle.fon", "sserife.fon", "sseriff.fon",
-      "Tahoma", "Times New Roman"  /* FIXME unverified */
-    },
     /* Eastern Europe */
     { 1250, 852, "vga852.fon", "vgafixe.fon", "vgasyse.fon",
       "couree.fon", "serifee.fon", "smallee.fon", "sserifee.fon", "sseriffe.fon",
@@ -460,6 +470,14 @@ static const struct nls_update_font_list
     }
 };
 
+static inline BOOL is_dbcs_ansi_cp(UINT ansi_cp)
+{
+    return ( ansi_cp == 932       /* CP932 for Japanese */
+            || ansi_cp == 936     /* CP936 for Chinese Simplified */
+            || ansi_cp == 949     /* CP949 for Korean */
+            || ansi_cp == 950 );  /* CP950 for Chinese Traditional */
+}
+
 static pthread_mutex_t font_lock = PTHREAD_MUTEX_INITIALIZER;
 
 #ifndef WINE_FONT_DIR
@@ -1164,8 +1182,8 @@ static struct gdi_font_face *create_face( struct gdi_font_family *family, const
     struct gdi_font_face *face = calloc( 1, sizeof(*face) );
 
     face->refcount   = 1;
-    face->style_name = wcsdup( style );
-    face->full_name  = wcsdup( fullname );
+    face->style_name = strdupW( style );
+    face->full_name  = strdupW( fullname );
     face->face_index = index;
     face->fs         = fs;
     face->ntmFlags   = ntmflags;
@@ -1173,7 +1191,7 @@ static struct gdi_font_face *create_face( struct gdi_font_family *family, const
     face->flags      = flags;
     face->data_ptr   = data_ptr;
     face->data_size  = data_size;
-    if (file) face->file = wcsdup( file );
+    if (file) face->file = strdupW( file );
     if (size) face->size = *size;
     else face->scalable = TRUE;
     if (insert_face_in_family_list( face, family )) return face;
@@ -1864,9 +1882,10 @@ static struct gdi_font_face *find_matching_face( const LOGFONTW *lf, CHARSETINFO
        corresponding to the current ansi codepage */
     if (!csi->fs.fsCsb[0])
     {
-        if (!translate_charset_info( (DWORD *)(INT_PTR)ansi_cp.CodePage, csi, TCI_SRCCODEPAGE ))
+        INT acp = get_acp();
+        if (!translate_charset_info( (DWORD *)(INT_PTR)acp, csi, TCI_SRCCODEPAGE ))
         {
-            FIXME( "TCI failed on codepage %d\n", ansi_cp.CodePage );
+            FIXME( "TCI failed on codepage %d\n", acp );
             csi->fs.fsCsb[0] = 0;
         }
     }
@@ -2036,9 +2055,9 @@ static struct gdi_font *create_gdi_font( const struct gdi_font_face *face, const
     font->ntmFlags = face->ntmFlags;
     font->aa_flags = HIWORD( face->flags );
     if (!family_name) family_name = face->family->family_name;
-    font->otm.otmpFamilyName = (char *)wcsdup( family_name );
-    font->otm.otmpStyleName = (char *)wcsdup( face->style_name );
-    font->otm.otmpFaceName = (char *)wcsdup( face->full_name );
+    font->otm.otmpFamilyName = (char *)strdupW( family_name );
+    font->otm.otmpStyleName = (char *)strdupW( face->style_name );
+    font->otm.otmpFaceName = (char *)strdupW( face->full_name );
     return font;
 }
 
@@ -2456,7 +2475,7 @@ static void create_child_font_list( struct gdi_font *font )
      * if not SYMBOL or OEM then we also get all the fonts for Microsoft
      * Sans Serif.  This is how asian windows get default fallbacks for fonts
      */
-    if (ansi_cp.MaximumCharacterSize == 2 && font->charset != SYMBOL_CHARSET && font->charset != OEM_CHARSET &&
+    if (is_dbcs_ansi_cp(get_acp()) && font->charset != SYMBOL_CHARSET && font->charset != OEM_CHARSET &&
         facename_compare( font_name, microsoft_sans_serifW, -1 ) != 0)
     {
         if ((font_link = find_gdi_font_link( microsoft_sans_serifW )))
@@ -2587,12 +2606,12 @@ static void set_value_key(HKEY hkey, const char *name, const char *value)
     }
 }
 
-static void update_font_association_info(void)
+static void update_font_association_info(UINT current_ansi_codepage)
 {
     static const WCHAR associated_charsetW[] =
         { 'A','s','s','o','c','i','a','t','e','d',' ','C','h','a','r','s','e','t' };
 
-    if (ansi_cp.MaximumCharacterSize == 2)
+    if (is_dbcs_ansi_cp(current_ansi_codepage))
     {
         HKEY hkey;
         if ((hkey = reg_create_key( NULL, font_assoc_keyW, sizeof(font_assoc_keyW), 0, NULL )))
@@ -2601,7 +2620,7 @@ static void update_font_association_info(void)
             if ((hsubkey = reg_create_key( hkey, associated_charsetW, sizeof(associated_charsetW),
                                            0, NULL )))
             {
-                switch (ansi_cp.CodePage)
+                switch (current_ansi_codepage)
                 {
                 case 932:
                     set_value_key(hsubkey, "ANSI(00)", "NO");
@@ -2638,7 +2657,7 @@ static void set_multi_value_key( HKEY hkey, const WCHAR *name, const char *value
         reg_delete_value( hkey, name );
 }
 
-static void update_font_system_link_info(void)
+static void update_font_system_link_info(UINT current_ansi_codepage)
 {
     static const char system_link_simplified_chinese[] =
         "SIMSUN.TTC,SimSun\0"
@@ -2672,7 +2691,7 @@ static void update_font_system_link_info(void)
         const char *link;
         DWORD len;
 
-        switch (ansi_cp.CodePage)
+        switch (current_ansi_codepage)
         {
         case 932:
             link = system_link_japanese;
@@ -2703,14 +2722,13 @@ static void update_font_system_link_info(void)
 
 static void update_codepage( UINT screen_dpi )
 {
-    USHORT utf8_hdr[2] = { 0, CP_UTF8 };
     char value_buffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data[40 * sizeof(WCHAR)])];
     KEY_VALUE_PARTIAL_INFORMATION *info = (void *)value_buffer;
     char cpbuf[40];
     WCHAR cpbufW[40];
     HKEY hkey;
     DWORD size;
-    UINT i;
+    UINT i, ansi_cp, oem_cp;
     DWORD font_dpi = 0;
     BOOL done = FALSE, cp_match = FALSE;
 
@@ -2720,16 +2738,9 @@ static void update_codepage( UINT screen_dpi )
     if (size == sizeof(DWORD) && info->Type == REG_DWORD)
         font_dpi = *(DWORD *)info->Data;
 
-    RtlInitCodePageTable( utf8_hdr, &utf8_cp );
-    if (NtCurrentTeb()->Peb->AnsiCodePageData)
-        RtlInitCodePageTable( NtCurrentTeb()->Peb->AnsiCodePageData, &ansi_cp );
-    else
-        ansi_cp = utf8_cp;
-    if (NtCurrentTeb()->Peb->OemCodePageData)
-        RtlInitCodePageTable( NtCurrentTeb()->Peb->OemCodePageData, &oem_cp );
-    else
-        oem_cp = utf8_cp;
-    sprintf( cpbuf, "%u,%u", ansi_cp.CodePage, oem_cp.CodePage );
+    ansi_cp = get_acp();
+    oem_cp = get_oemcp();
+    sprintf( cpbuf, "%u,%u", ansi_cp, oem_cp );
     asciiz_to_unicode( cpbufW, cpbuf );
 
     if (query_reg_ascii_value( wine_fonts_key, "Codepages", info, sizeof(value_buffer) ))
@@ -2737,18 +2748,17 @@ static void update_codepage( UINT screen_dpi )
         cp_match = !wcscmp( (const WCHAR *)info->Data, cpbufW );
         if (cp_match && screen_dpi == font_dpi) return;  /* already set correctly */
         TRACE( "updating registry, codepages/logpixels changed %s/%u -> %u,%u/%u\n",
-               debugstr_w((const WCHAR *)info->Data), font_dpi, ansi_cp.CodePage, oem_cp.CodePage, screen_dpi );
+               debugstr_w((const WCHAR *)info->Data), font_dpi, ansi_cp, oem_cp, screen_dpi );
     }
     else TRACE("updating registry, codepages/logpixels changed none -> %u,%u/%u\n",
-               ansi_cp.CodePage, oem_cp.CodePage, screen_dpi);
+               ansi_cp, oem_cp, screen_dpi);
 
     set_reg_ascii_value( wine_fonts_key, "Codepages", cpbuf );
     set_reg_value( wine_fonts_key, log_pixelsW, REG_DWORD, &screen_dpi, sizeof(screen_dpi) );
 
     for (i = 0; i < ARRAY_SIZE(nls_update_font_list); i++)
     {
-        if (nls_update_font_list[i].ansi_cp == ansi_cp.CodePage &&
-            nls_update_font_list[i].oem_cp == oem_cp.CodePage)
+        if (nls_update_font_list[i].ansi_cp == ansi_cp && nls_update_font_list[i].oem_cp == oem_cp)
         {
             HKEY software_hkey;
             if ((software_hkey = reg_create_key( NULL, software_config_keyW,
@@ -2816,14 +2826,14 @@ static void update_codepage( UINT screen_dpi )
         }
     }
     if (!done)
-        FIXME("there is no font defaults for codepages %u,%u\n", ansi_cp.CodePage, oem_cp.CodePage);
+        FIXME("there is no font defaults for codepages %u,%u\n", ansi_cp, oem_cp);
 
     /* update locale dependent font association info and font system link info in registry.
        update only when codepages changed, not logpixels. */
     if (!cp_match)
     {
-        update_font_association_info();
-        update_font_system_link_info();
+        update_font_association_info(ansi_cp);
+        update_font_system_link_info(ansi_cp);
     }
 }
 
@@ -2869,11 +2879,11 @@ struct enum_charset
     DWORD script;
 };
 
-static BOOL is_complex_script_ansi_cp(void)
+static BOOL is_complex_script_ansi_cp( UINT ansi_cp )
 {
-    return (ansi_cp.CodePage == 874 /* Thai */
-            || ansi_cp.CodePage == 1255 /* Hebrew */
-            || ansi_cp.CodePage == 1256 /* Arabic */
+    return (ansi_cp == 874 /* Thai */
+            || ansi_cp == 1255 /* Hebrew */
+            || ansi_cp == 1256 /* Arabic */
         );
 }
 
@@ -2900,11 +2910,12 @@ static DWORD create_enum_charset_list(DWORD charset, struct enum_charset *list)
     }
     else /* charset is DEFAULT_CHARSET or invalid. */
     {
+        int acp = get_acp();
         DWORD mask = 0;
 
         /* Set the current codepage's charset as the first element. */
-        if (!is_complex_script_ansi_cp() &&
-            translate_charset_info( (DWORD *)(INT_PTR)ansi_cp.CodePage, &csi, TCI_SRCCODEPAGE ) &&
+        if (!is_complex_script_ansi_cp(acp) &&
+            translate_charset_info( (DWORD *)(INT_PTR)acp, &csi, TCI_SRCCODEPAGE ) &&
             csi.fs.fsCsb[0] != 0)
         {
             list->mask    = csi.fs.fsCsb[0];
@@ -3199,13 +3210,11 @@ static UINT get_glyph_index_symbol( struct gdi_font *font, UINT glyph )
 CPTABLEINFO *get_cptable( WORD cp )
 {
     static CPTABLEINFO tables[100];
+    CPTABLEINFO *info;
     unsigned int i;
     USHORT *ptr;
     SIZE_T size;
 
-    if (cp == CP_ACP) return &ansi_cp;
-    if (cp == CP_UTF8) return &utf8_cp;
-
     for (i = 0; i < ARRAY_SIZE(tables) && tables[i].CodePage; i++)
         if (tables[i].CodePage == cp) return &tables[i];
     if (NtGetNlsSectionPtr( 11, cp, NULL, (void **)&ptr, &size )) return NULL;
@@ -3214,32 +3223,96 @@ CPTABLEINFO *get_cptable( WORD cp )
         ERR( "too many code pages\n" );
         return NULL;
     }
-    RtlInitCodePageTable( ptr, &tables[i] );
-    return &tables[i];
+
+    info = &tables[i];
+    info->CodePage             = ptr[1];
+    info->MaximumCharacterSize = ptr[2];
+    info->DefaultChar          = ptr[3];
+    info->UniDefaultChar       = ptr[4];
+    info->TransDefaultChar     = ptr[5];
+    info->TransUniDefaultChar  = ptr[6];
+    memcpy( info->LeadByte, ptr + 7, sizeof(info->LeadByte) );
+    ptr += ptr[0];
+
+    info->WideCharTable = ptr + ptr[0] + 1;
+    info->MultiByteTable = ++ptr;
+    ptr += 256;
+    if (*ptr++) ptr += 256;  /* glyph table */
+    info->DBCSRanges = ptr;
+    if (*ptr)  /* dbcs ranges */
+    {
+        info->DBCSCodePage = 1;
+        info->DBCSOffsets  = ptr + 1;
+    }
+    else
+    {
+        info->DBCSCodePage = 0;
+        info->DBCSOffsets  = NULL;
+    }
+
+    return info;
 }
 
 DWORD win32u_wctomb( CPTABLEINFO *info, char *dst, DWORD dstlen, const WCHAR *src, DWORD srclen )
 {
-    DWORD ret;
+    DWORD i, ret;
 
-    if (info->CodePage == CP_UTF8)
-        RtlUnicodeToUTF8N( dst, dstlen, &ret, src, srclen * sizeof(WCHAR) );
-    else
-        RtlUnicodeToCustomCPN( info, dst, dstlen, &ret, src, srclen * sizeof(WCHAR) );
+    if (!info && !(info = get_cptable( get_acp() ))) return 0;
 
+    srclen /= sizeof(WCHAR);
+    if (info->DBCSCodePage)
+    {
+        WCHAR *uni2cp = info->WideCharTable;
+
+        for (i = dstlen; srclen && i; i--, srclen--, src++)
+        {
+            if (uni2cp[*src] & 0xff00)
+            {
+                if (i == 1) break;  /* do not output a partial char */
+                i--;
+                *dst++ = uni2cp[*src] >> 8;
+            }
+            *dst++ = (char)uni2cp[*src];
+        }
+        ret = dstlen - i;
+    }
+    else
+    {
+        char *uni2cp = info->WideCharTable;
+        ret = min( srclen, dstlen );
+        for (i = 0; i < ret; i++) dst[i] = uni2cp[src[i]];
+    }
     return ret;
 }
 
 DWORD win32u_mbtowc( CPTABLEINFO *info, WCHAR *dst, DWORD dstlen, const char *src, DWORD srclen )
 {
-    DWORD ret;
+    DWORD i, ret;
 
-    if (info->CodePage == CP_UTF8)
-        RtlUTF8ToUnicodeN( dst, dstlen * sizeof(WCHAR), &ret, src, srclen );
-    else
-        RtlCustomCPToUnicodeN( info, dst, dstlen * sizeof(WCHAR), &ret, src, srclen );
+    if (!info && !(info = get_cptable( get_acp() ))) return 0;
 
-    return ret / sizeof(WCHAR);
+    dstlen /= sizeof(WCHAR);
+    if (info->DBCSOffsets)
+    {
+        for (i = dstlen; srclen && i; i--, srclen--, src++, dst++)
+        {
+            USHORT off = info->DBCSOffsets[(unsigned char)*src];
+            if (off && srclen > 1)
+            {
+                src++;
+                srclen--;
+                *dst = info->DBCSOffsets[off + (unsigned char)*src];
+            }
+            else *dst = info->MultiByteTable[(unsigned char)*src];
+        }
+        ret = dstlen - i;
+    }
+    else
+    {
+        ret = min( srclen, dstlen );
+        for (i = 0; i < ret; i++) dst[i] = info->MultiByteTable[(unsigned char)src[i]];
+    }
+    return ret * sizeof(WCHAR);
 }
 
 static BOOL wc_to_index( UINT cp, WCHAR wc, unsigned char *dst, BOOL allow_default )
@@ -3248,18 +3321,7 @@ static BOOL wc_to_index( UINT cp, WCHAR wc, unsigned char *dst, BOOL allow_defau
 
     if (!(info = get_cptable( cp ))) return FALSE;
 
-    if (info->CodePage == CP_UTF8)
-    {
-        if (wc < 0x80)
-        {
-            *dst = wc;
-            return TRUE;
-        }
-        if (!allow_default) return FALSE;
-        *dst = info->DefaultChar;
-        return TRUE;
-    }
-    else if (info->DBCSCodePage)
+    if (info->DBCSCodePage)
     {
         WCHAR *uni2cp = info->WideCharTable;
         if (uni2cp[wc] & 0xff00) return FALSE;
@@ -3970,7 +4032,7 @@ static void get_nearest_charset( const WCHAR *family_name, struct gdi_font_face
 
     int i;
 
-    if (translate_charset_info( (DWORD*)(INT_PTR)ansi_cp.CodePage, csi, TCI_SRCCODEPAGE ))
+    if (translate_charset_info( (DWORD*)(INT_PTR)get_acp(), csi, TCI_SRCCODEPAGE ))
     {
         const struct gdi_font_link *font_link;
 
@@ -3990,7 +4052,7 @@ static void get_nearest_charset( const WCHAR *family_name, struct gdi_font_face
 
     FIXME("returning DEFAULT_CHARSET face->fs.fsCsb[0] = %08x file = %s\n",
 	  face->fs.fsCsb[0], debugstr_w(face->file));
-    csi->ciACP = ansi_cp.CodePage;
+    csi->ciACP = get_acp();
     csi->ciCharset = DEFAULT_CHARSET;
 }
 
@@ -4268,9 +4330,6 @@ const struct gdi_dc_funcs font_driver =
     NULL,                           /* pStrokePath */
     NULL,                           /* pUnrealizePalette */
     NULL,                           /* pD3DKMTCheckVidPnExclusiveOwnership */
-    NULL,                           /* pD3DKMTCloseAdapter */
-    NULL,                           /* pD3DKMTOpenAdapterFromLuid */
-    NULL,                           /* pD3DKMTQueryVideoMemoryInfo */
     NULL,                           /* pD3DKMTSetVidPnSourceOwner */
     GDI_PRIORITY_FONT_DRV           /* priority */
 };
@@ -4583,10 +4642,10 @@ static void update_font_code_page( DC *dc, HANDLE font )
     else {
         switch(charset) {
         case OEM_CHARSET:
-            dc->attr->font_code_page = oem_cp.CodePage;
+            dc->attr->font_code_page = get_oemcp();
             break;
         case DEFAULT_CHARSET:
-            dc->attr->font_code_page = ansi_cp.CodePage;
+            dc->attr->font_code_page = get_acp();
             break;
 
         case VISCII_CHARSET:
@@ -5618,7 +5677,7 @@ BOOL WINAPI NtGdiExtTextOutW( HDC hdc, INT x, INT y, UINT flags, const RECT *lpr
                 text_box.bottom = y + tm.tmDescent;
 
                 if (flags & ETO_CLIPPED) intersect_rect( &text_box, &text_box, &rc );
-                if (!IsRectEmpty( &text_box ))
+                if (!is_rect_empty( &text_box ))
                     physdev->funcs->pExtTextOut( physdev, 0, 0, ETO_OPAQUE, &text_box, NULL, 0, NULL );
             }
         }
@@ -5637,7 +5696,7 @@ done:
         UINT size = NtGdiGetOutlineTextMetricsInternalW( hdc, 0, NULL, 0 );
         OUTLINETEXTMETRICW* otm = NULL;
         POINT pts[5];
-        HPEN hpen = NtGdiSelectPen( hdc, GetStockObject(NULL_PEN) );
+        HPEN hpen = NtGdiSelectPen( hdc, get_stock_object(NULL_PEN) );
         HBRUSH hbrush = NtGdiCreateSolidBrush( dc->attr->text_color, NULL );
 
         hbrush = NtGdiSelectBrush(hdc, hbrush);
diff --git a/dlls/win32u/freetype.c b/dlls/win32u/freetype.c
index f00df7ed86d..b6063a14570 100644
--- a/dlls/win32u/freetype.c
+++ b/dlls/win32u/freetype.c
@@ -584,6 +584,24 @@ static BOOL is_subpixel_rendering_enabled( void )
 }
 
 
+static LPWSTR strdupW(LPCWSTR p)
+{
+    LPWSTR ret;
+    DWORD len = (lstrlenW(p) + 1) * sizeof(WCHAR);
+    ret = malloc( len );
+    memcpy(ret, p, len);
+    return ret;
+}
+
+static WCHAR *towstr(const char *str)
+{
+    DWORD len = strlen(str) + 1;
+    WCHAR *wstr = malloc( len * sizeof(WCHAR) );
+    win32u_mbtowc( NULL, wstr, len * sizeof(WCHAR), str, len );
+    return wstr;
+}
+
+
 static const LANGID mac_langid_table[] =
 {
     MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT),                /* TT_MAC_LANGID_ENGLISH */
@@ -782,8 +800,9 @@ static WCHAR *copy_name_table_string( const FT_SfntName *name )
     case TT_PLATFORM_MACINTOSH:
         if (!(cp = get_mac_code_page( name ))) return NULL;
         ret = malloc( (name->string_len + 1) * sizeof(WCHAR) );
-        i = win32u_mbtowc( cp, ret, name->string_len, (char *)name->string, name->string_len );
-        ret[i] = 0;
+        i = win32u_mbtowc( cp, ret, name->string_len * sizeof(WCHAR),
+                           (char *)name->string, name->string_len );
+        ret[i / sizeof(WCHAR)] = 0;
         return ret;
     }
     return NULL;
@@ -1141,14 +1160,15 @@ static WCHAR *decode_opentype_name( struct opentype_name *name )
     {
         CPTABLEINFO *cptable = get_cptable( name->codepage );
         if (!cptable) return NULL;
-        len = win32u_mbtowc( cptable, buffer, ARRAY_SIZE(buffer), name->bytes, name->length );
+        len = win32u_mbtowc( cptable, buffer, sizeof(buffer), name->bytes, name->length );
+        len /= sizeof(WCHAR);
     }
 
     buffer[ARRAY_SIZE(buffer) - 1] = 0;
     if (len == ARRAY_SIZE(buffer)) WARN("Truncated font name %s -> %s\n", debugstr_an(name->bytes, name->length), debugstr_w(buffer));
     else buffer[len] = 0;
 
-    return wcsdup( buffer );
+    return strdupW( buffer );
 }
 
 struct unix_face
@@ -2524,7 +2544,7 @@ static BOOL freetype_get_glyph_index( struct gdi_font *font, UINT *glyph, BOOL u
             DWORD len;
             char ch;
 
-            len = win32u_wctomb( &ansi_cp, &ch, 1, &wc, 1 );
+            len = win32u_wctomb( NULL, &ch, 1, &wc, sizeof(wc) );
             if (len) *glyph = get_glyph_index_symbol( font, (unsigned char)ch );
         }
         return TRUE;
@@ -3667,7 +3687,7 @@ static BOOL freetype_set_outline_text_metrics( struct gdi_font *font )
     {
         static const WCHAR fake_nameW[] = {'f','a','k','e',' ','n','a','m','e', 0};
         FIXME("failed to read full_nameW for font %s!\n", wine_dbgstr_w((WCHAR *)font->otm.otmpFamilyName));
-        font->otm.otmpFullName = (char *)wcsdup( fake_nameW );
+        font->otm.otmpFullName = (char *)strdupW(fake_nameW);
     }
     needed = sizeof(font->otm) + (lstrlenW( (WCHAR *)font->otm.otmpFamilyName ) + 1 +
                                   lstrlenW( (WCHAR *)font->otm.otmpStyleName ) + 1 +
diff --git a/dlls/win32u/gdiobj.c b/dlls/win32u/gdiobj.c
index edb21456d8d..e47271e6108 100644
--- a/dlls/win32u/gdiobj.c
+++ b/dlls/win32u/gdiobj.c
@@ -464,22 +464,40 @@ void make_gdi_object_system( HGDIOBJ handle, BOOL set)
 /******************************************************************************
  *      get_default_fonts
  */
-static const struct DefaultFontInfo* get_default_fonts(void)
+static const struct DefaultFontInfo* get_default_fonts(UINT charset)
 {
-    unsigned int n;
-    CHARSETINFO csi;
+        unsigned int n;
 
-    if (ansi_cp.CodePage == CP_UTF8) return &default_fonts[0];
+        for(n = 0; n < ARRAY_SIZE( default_fonts ); n++)
+        {
+                if ( default_fonts[n].charset == charset )
+                        return &default_fonts[n];
+        }
 
-    csi.ciCharset = ANSI_CHARSET;
-    translate_charset_info( ULongToPtr(ansi_cp.CodePage), &csi, TCI_SRCCODEPAGE );
+        FIXME( "unhandled charset 0x%08x - use ANSI_CHARSET for default stock objects\n", charset );
+        return &default_fonts[0];
+}
 
-    for(n = 0; n < ARRAY_SIZE( default_fonts ); n++)
-        if ( default_fonts[n].charset == csi.ciCharset )
-            return &default_fonts[n];
 
-    FIXME( "unhandled charset 0x%08x - use ANSI_CHARSET for default stock objects\n", csi.ciCharset );
-    return &default_fonts[0];
+/******************************************************************************
+ *      get_default_charset    (internal)
+ *
+ * get the language-dependent charset that can handle CP_ACP correctly.
+ */
+static UINT get_default_charset( void )
+{
+    CHARSETINFO     csi;
+    UINT    uACP;
+
+    uACP = get_acp();
+    csi.ciCharset = ANSI_CHARSET;
+    if ( !translate_charset_info( ULongToPtr(uACP), &csi, TCI_SRCCODEPAGE ) )
+    {
+        FIXME( "unhandled codepage %u - use ANSI_CHARSET for default stock objects\n", uACP );
+        return ANSI_CHARSET;
+    }
+
+    return csi.ciCharset;
 }
 
 
@@ -586,10 +604,7 @@ static void init_gdi_shared(void)
     NtCurrentTeb()->Peb->GdiSharedHandleTable = gdi_shared;
 }
 
-/***********************************************************************
- *           GetStockObject    (win32u.so)
- */
-HGDIOBJ WINAPI GetStockObject( INT obj )
+HGDIOBJ get_stock_object( INT obj )
 {
     assert( obj >= 0 && obj <= STOCK_LAST + 1 && obj != 9 );
 
@@ -641,7 +656,7 @@ static void init_stock_objects( unsigned int dpi )
     create_font( &AnsiVarFont );
 
     /* language-dependent stock fonts */
-    deffonts = get_default_fonts();
+    deffonts = get_default_fonts(get_default_charset());
     create_font( &deffonts->SystemFont );
     create_font( &deffonts->DeviceDefaultFont );
 
@@ -1046,14 +1061,10 @@ static struct unix_funcs unix_funcs =
     NtGdiCreateDIBitmapInternal,
     NtGdiCreateMetafileDC,
     NtGdiDdDDICheckVidPnExclusiveOwnership,
-    NtGdiDdDDICloseAdapter,
     NtGdiDdDDICreateDCFromMemory,
     NtGdiDdDDIDestroyDCFromMemory,
     NtGdiDdDDIDestroyDevice,
     NtGdiDdDDIEscape,
-    NtGdiDdDDIOpenAdapterFromDeviceName,
-    NtGdiDdDDIOpenAdapterFromLuid,
-    NtGdiDdDDIQueryVideoMemoryInfo,
     NtGdiDdDDISetVidPnSourceOwner,
     NtGdiDeleteObjectApp,
     NtGdiDoPalette,
@@ -1146,100 +1157,68 @@ static struct unix_funcs unix_funcs =
     NtUserCallNoParam,
     NtUserCallOneParam,
     NtUserCallTwoParam,
-    NtUserChangeClipboardChain,
     NtUserChangeDisplaySettings,
     NtUserClipCursor,
-    NtUserCloseClipboard,
     NtUserCountClipboardFormats,
-    NtUserCreateCaret,
-    NtUserCreateWindowEx,
     NtUserDeferWindowPosAndBand,
     NtUserDestroyCursor,
-    NtUserDestroyMenu,
     NtUserDestroyWindow,
-    NtUserDispatchMessage,
     NtUserDrawIconEx,
-    NtUserEmptyClipboard,
-    NtUserEnableMenuItem,
     NtUserEndDeferWindowPosEx,
     NtUserEndPaint,
     NtUserEnumDisplayDevices,
     NtUserEnumDisplayMonitors,
     NtUserEnumDisplaySettings,
-    NtUserExcludeUpdateRgn,
     NtUserFlashWindowEx,
     NtUserGetAsyncKeyState,
     NtUserGetClassInfoEx,
-    NtUserGetClipboardData,
     NtUserGetCursorInfo,
     NtUserGetDCEx,
     NtUserGetDisplayConfigBufferSizes,
     NtUserGetIconInfo,
     NtUserGetKeyNameText,
     NtUserGetKeyboardLayoutList,
-    NtUserGetMessage,
     NtUserGetPriorityClipboardFormat,
     NtUserGetQueueStatus,
-    NtUserGetSystemMenu,
     NtUserGetUpdateRect,
     NtUserGetUpdateRgn,
     NtUserGetUpdatedClipboardFormats,
-    NtUserGetWindowPlacement,
-    NtUserHideCaret,
     NtUserIsClipboardFormatAvailable,
     NtUserMapVirtualKeyEx,
-    NtUserMessageCall,
     NtUserMoveWindow,
-    NtUserMsgWaitForMultipleObjectsEx,
-    NtUserOpenClipboard,
-    NtUserPeekMessage,
-    NtUserPostMessage,
-    NtUserPostThreadMessage,
     NtUserRedrawWindow,
     NtUserRegisterClassExWOW,
     NtUserRegisterHotKey,
     NtUserReleaseDC,
     NtUserScrollDC,
     NtUserSelectPalette,
-    NtUserSendInput,
     NtUserSetActiveWindow,
     NtUserSetCapture,
-    NtUserSetClipboardData,
     NtUserSetClassLong,
     NtUserSetClassLongPtr,
     NtUserSetClassWord,
-    NtUserSetClipboardViewer,
     NtUserSetCursor,
     NtUserSetCursorIconData,
     NtUserSetCursorPos,
     NtUserSetFocus,
-    NtUserSetInternalWindowPos,
     NtUserSetLayeredWindowAttributes,
-    NtUserSetMenu,
     NtUserSetParent,
     NtUserSetSysColors,
-    NtUserSetSystemMenu,
     NtUserSetWindowLong,
     NtUserSetWindowLongPtr,
-    NtUserSetWindowPlacement,
     NtUserSetWindowPos,
     NtUserSetWindowRgn,
     NtUserSetWindowWord,
-    NtUserShowCaret,
     NtUserShowCursor,
     NtUserShowWindow,
     NtUserShowWindowAsync,
     NtUserSystemParametersInfo,
     NtUserSystemParametersInfoForDpi,
     NtUserToUnicodeEx,
-    NtUserTrackMouseEvent,
-    NtUserTranslateAccelerator,
-    NtUserTranslateMessage,
     NtUserUnregisterClass,
     NtUserUnregisterHotKey,
     NtUserUpdateLayeredWindow,
     NtUserVkKeyScanEx,
-    NtUserWaitForInputIdle,
     NtUserWindowFromPoint,
 
     SetDIBits,
@@ -1248,8 +1227,8 @@ static struct unix_funcs unix_funcs =
     __wine_get_icm_profile,
     __wine_get_vulkan_driver,
     __wine_get_wgl_driver,
-    __wine_send_input,
-    __wine_set_user_driver,
+    __wine_set_display_driver,
+    __wine_set_visible_region,
 };
 
 NTSTATUS gdi_init(void)
diff --git a/dlls/win32u/hook.c b/dlls/win32u/hook.c
index a271693622a..21e00d1ff3c 100644
--- a/dlls/win32u/hook.c
+++ b/dlls/win32u/hook.c
@@ -172,17 +172,6 @@ BOOL unhook_windows_hook( INT id, HOOKPROC proc )
     return !status;
 }
 
-/***********************************************************************
- *           NtUserCallMsgFilter (win32u.@)
- */
-BOOL WINAPI NtUserCallMsgFilter( MSG *msg, INT code )
-{
-    /* FIXME: We should use NtCallbackReturn instead of passing (potentially kernel) pointer
-     * like that, but we need to consequently use syscall thunks first for that to work. */
-    if (call_hooks( WH_SYSMSGFILTER, code, 0, (LPARAM)msg, TRUE )) return TRUE;
-    return call_hooks( WH_MSGFILTER, code, 0, (LPARAM)msg, TRUE );
-}
-
 static UINT get_ll_hook_timeout(void)
 {
     /* FIXME: should retrieve LowLevelHooksTimeout in HKEY_CURRENT_USER\Control Panel\Desktop */
@@ -211,14 +200,16 @@ static LRESULT call_hook( struct win_hook_params *info )
         switch(info->id)
         {
         case WH_KEYBOARD_LL:
-            send_internal_message_timeout( info->pid, info->tid, WM_WINE_KEYBOARD_LL_HOOK,
-                                           info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
-                                           get_ll_hook_timeout(), &ret );
+            if (!user_callbacks) break;
+            user_callbacks->send_ll_message( info->pid, info->tid, WM_WINE_KEYBOARD_LL_HOOK,
+                                             info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
+                                             get_ll_hook_timeout(), &ret );
             break;
         case WH_MOUSE_LL:
-            send_internal_message_timeout( info->pid, info->tid, WM_WINE_MOUSE_LL_HOOK,
-                                           info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
-                                           get_ll_hook_timeout(), &ret );
+            if (!user_callbacks) break;
+            user_callbacks->send_ll_message( info->pid, info->tid, WM_WINE_MOUSE_LL_HOOK,
+                                             info->wparam, (LPARAM)&h_extra, SMTO_ABORTIFHUNG,
+                                             get_ll_hook_timeout(), &ret );
             break;
         default:
             ERR("Unknown hook id %d\n", info->id);
diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 2b196fb5b1d..5cd2cdd0970 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -2,14 +2,10 @@
  * USER Input processing
  *
  * Copyright 1993 Bob Amstadt
- * Copyright 1993 David Metcalfe
  * Copyright 1996 Albrecht Kleine
- * Copyright 1996 Frans van Dorsselaer
  * Copyright 1997 David Faure
  * Copyright 1998 Morten Welinder
  * Copyright 1998 Ulrich Weigand
- * Copyright 2001 Eric Pouech
- * Copyright 2002 Alexandre Julliard
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -30,8 +26,6 @@
 #pragma makedep unix
 #endif
 
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
 #include "win32u_private.h"
 #include "ntuser_private.h"
 #include "wine/server.h"
@@ -71,110 +65,13 @@ BOOL WINAPI NtUserAttachThreadInput( DWORD from, DWORD to, BOOL attach )
     return ret;
 }
 
-/***********************************************************************
- *           __wine_send_input  (win32u.@)
- *
- * Internal SendInput function to allow the graphics driver to inject real events.
- */
-BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput )
-{
-    return set_ntstatus( send_hardware_message( hwnd, input, rawinput, 0 ));
-}
-
-/***********************************************************************
- *		update_mouse_coords
- *
- * Helper for NtUserSendInput.
- */
-static void update_mouse_coords( INPUT *input )
-{
-    if (!(input->mi.dwFlags & MOUSEEVENTF_MOVE)) return;
-
-    if (input->mi.dwFlags & MOUSEEVENTF_ABSOLUTE)
-    {
-        RECT rc;
-
-        if (input->mi.dwFlags & MOUSEEVENTF_VIRTUALDESK)
-            rc = get_virtual_screen_rect( 0 );
-        else
-            rc = get_primary_monitor_rect( 0 );
-
-        input->mi.dx = rc.left + ((input->mi.dx * (rc.right - rc.left)) >> 16);
-        input->mi.dy = rc.top  + ((input->mi.dy * (rc.bottom - rc.top)) >> 16);
-    }
-    else
-    {
-        int accel[3];
-
-        /* dx and dy can be negative numbers for relative movements */
-        NtUserSystemParametersInfo( SPI_GETMOUSE, 0, accel, 0 );
-
-        if (!accel[2]) return;
-
-        if (abs( input->mi.dx ) > accel[0])
-        {
-            input->mi.dx *= 2;
-            if (abs( input->mi.dx ) > accel[1] && accel[2] == 2) input->mi.dx *= 2;
-        }
-        if (abs(input->mi.dy) > accel[0])
-        {
-            input->mi.dy *= 2;
-            if (abs( input->mi.dy ) > accel[1] && accel[2] == 2) input->mi.dy *= 2;
-        }
-    }
-}
-
 /***********************************************************************
  *           NtUserSendInput  (win32u.@)
  */
 UINT WINAPI NtUserSendInput( UINT count, INPUT *inputs, int size )
 {
-    UINT i;
-    NTSTATUS status = STATUS_SUCCESS;
-
-    if (size != sizeof(INPUT))
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return 0;
-    }
-
-    if (!count)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return 0;
-    }
-
-    if (!inputs)
-    {
-        SetLastError( ERROR_NOACCESS );
-        return 0;
-    }
-
-    for (i = 0; i < count; i++)
-    {
-        INPUT input = inputs[i];
-        switch (input.type)
-        {
-        case INPUT_MOUSE:
-            /* we need to update the coordinates to what the server expects */
-            update_mouse_coords( &input );
-            /* fallthrough */
-        case INPUT_KEYBOARD:
-            status = send_hardware_message( 0, &input, NULL, SEND_HWMSG_INJECTED );
-            break;
-        case INPUT_HARDWARE:
-            SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
-            return 0;
-        }
-
-        if (status)
-        {
-            SetLastError( RtlNtStatusToDosError(status) );
-            break;
-        }
-    }
-
-    return i;
+    if (!user_callbacks) return 0;
+    return user_callbacks->pSendInput( count, inputs, size );
 }
 
 /***********************************************************************
@@ -268,8 +165,7 @@ BOOL WINAPI NtUserGetCursorInfo( CURSORINFO *info )
 
 static void check_for_events( UINT flags )
 {
-    LARGE_INTEGER zero = { .QuadPart = 0 };
-    if (user_driver->pMsgWaitForMultipleObjectsEx( 0, NULL, &zero, flags, 0 ) == WAIT_TIMEOUT)
+    if (user_driver->pMsgWaitForMultipleObjectsEx( 0, NULL, 0, flags, 0 ) == WAIT_TIMEOUT)
         flush_window_surfaces( TRUE );
 }
 
@@ -1176,224 +1072,6 @@ int WINAPI NtUserGetMouseMovePointsEx( UINT size, MOUSEMOVEPOINT *ptin, MOUSEMOV
     return copied;
 }
 
-static WORD get_key_state(void)
-{
-    WORD ret = 0;
-
-    if (get_system_metrics( SM_SWAPBUTTON ))
-    {
-        if (NtUserGetAsyncKeyState(VK_RBUTTON) & 0x80) ret |= MK_LBUTTON;
-        if (NtUserGetAsyncKeyState(VK_LBUTTON) & 0x80) ret |= MK_RBUTTON;
-    }
-    else
-    {
-        if (NtUserGetAsyncKeyState(VK_LBUTTON) & 0x80) ret |= MK_LBUTTON;
-        if (NtUserGetAsyncKeyState(VK_RBUTTON) & 0x80) ret |= MK_RBUTTON;
-    }
-    if (NtUserGetAsyncKeyState(VK_MBUTTON) & 0x80)  ret |= MK_MBUTTON;
-    if (NtUserGetAsyncKeyState(VK_SHIFT) & 0x80)    ret |= MK_SHIFT;
-    if (NtUserGetAsyncKeyState(VK_CONTROL) & 0x80)  ret |= MK_CONTROL;
-    if (NtUserGetAsyncKeyState(VK_XBUTTON1) & 0x80) ret |= MK_XBUTTON1;
-    if (NtUserGetAsyncKeyState(VK_XBUTTON2) & 0x80) ret |= MK_XBUTTON2;
-    return ret;
-}
-
-struct tracking_list
-{
-    TRACKMOUSEEVENT info;
-    POINT pos; /* center of hover rectangle */
-};
-
-/* FIXME: move tracking stuff into per-thread data */
-static struct tracking_list tracking_info;
-
-static void check_mouse_leave( HWND hwnd, int hittest )
-{
-    if (tracking_info.info.hwndTrack != hwnd)
-    {
-        if (tracking_info.info.dwFlags & TME_NONCLIENT)
-            NtUserPostMessage( tracking_info.info.hwndTrack, WM_NCMOUSELEAVE, 0, 0 );
-        else
-            NtUserPostMessage( tracking_info.info.hwndTrack, WM_MOUSELEAVE, 0, 0 );
-
-        tracking_info.info.dwFlags &= ~TME_LEAVE;
-    }
-    else
-    {
-        if (hittest == HTCLIENT)
-        {
-            if (tracking_info.info.dwFlags & TME_NONCLIENT)
-            {
-                NtUserPostMessage( tracking_info.info.hwndTrack, WM_NCMOUSELEAVE, 0, 0 );
-                tracking_info.info.dwFlags &= ~TME_LEAVE;
-            }
-        }
-        else
-        {
-            if (!(tracking_info.info.dwFlags & TME_NONCLIENT))
-            {
-                NtUserPostMessage( tracking_info.info.hwndTrack, WM_MOUSELEAVE, 0, 0 );
-                tracking_info.info.dwFlags &= ~TME_LEAVE;
-            }
-        }
-    }
-}
-
-void update_mouse_tracking_info( HWND hwnd )
-{
-    int hover_width = 0, hover_height = 0, hittest;
-    POINT pos;
-
-    TRACE( "hwnd %p\n", hwnd );
-
-    get_cursor_pos( &pos );
-    hwnd = window_from_point( hwnd, pos, &hittest );
-
-    TRACE( "point %s hwnd %p hittest %d\n", wine_dbgstr_point(&pos), hwnd, hittest );
-
-    NtUserSystemParametersInfo( SPI_GETMOUSEHOVERWIDTH, 0, &hover_width, 0 );
-    NtUserSystemParametersInfo( SPI_GETMOUSEHOVERHEIGHT, 0, &hover_height, 0 );
-
-    TRACE( "tracked pos %s, current pos %s, hover width %d, hover height %d\n",
-           wine_dbgstr_point(&tracking_info.pos), wine_dbgstr_point(&pos),
-           hover_width, hover_height );
-
-    if (tracking_info.info.dwFlags & TME_LEAVE)
-        check_mouse_leave( hwnd, hittest );
-
-    if (tracking_info.info.hwndTrack != hwnd)
-        tracking_info.info.dwFlags &= ~TME_HOVER;
-
-    if (tracking_info.info.dwFlags & TME_HOVER)
-    {
-        /* has the cursor moved outside the rectangle centered around pos? */
-        if ((abs( pos.x - tracking_info.pos.x ) > (hover_width / 2)) ||
-            (abs( pos.y - tracking_info.pos.y ) > (hover_height / 2)))
-        {
-            tracking_info.pos = pos;
-        }
-        else
-        {
-            if (hittest == HTCLIENT)
-            {
-                screen_to_client(hwnd, &pos);
-                TRACE( "client cursor pos %s\n", wine_dbgstr_point(&pos) );
-
-                NtUserPostMessage( tracking_info.info.hwndTrack, WM_MOUSEHOVER,
-                                   get_key_state(), MAKELPARAM( pos.x, pos.y ) );
-            }
-            else
-            {
-                if (tracking_info.info.dwFlags & TME_NONCLIENT)
-                    NtUserPostMessage( tracking_info.info.hwndTrack, WM_NCMOUSEHOVER,
-                                       hittest, MAKELPARAM( pos.x, pos.y ) );
-            }
-
-            /* stop tracking mouse hover */
-            tracking_info.info.dwFlags &= ~TME_HOVER;
-        }
-    }
-
-    /* stop the timer if the tracking list is empty */
-    if (!(tracking_info.info.dwFlags & (TME_HOVER | TME_LEAVE)))
-    {
-        kill_system_timer( tracking_info.info.hwndTrack, SYSTEM_TIMER_TRACK_MOUSE );
-        tracking_info.info.hwndTrack = 0;
-        tracking_info.info.dwFlags = 0;
-        tracking_info.info.dwHoverTime = 0;
-    }
-}
-
-/***********************************************************************
- *           NtUserTrackMouseEvent    (win32u.@)
- */
-BOOL WINAPI NtUserTrackMouseEvent( TRACKMOUSEEVENT *info )
-{
-    DWORD hover_time;
-    int hittest;
-    HWND hwnd;
-    POINT pos;
-
-    TRACE( "size %u, flags %#x, hwnd %p, time %u\n",
-           info->cbSize, info->dwFlags, info->hwndTrack, info->dwHoverTime );
-
-    if (info->cbSize != sizeof(TRACKMOUSEEVENT))
-    {
-        WARN( "wrong size %u\n", info->cbSize );
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return FALSE;
-    }
-
-    if (info->dwFlags & TME_QUERY)
-    {
-        *info = tracking_info.info;
-        info->cbSize = sizeof(TRACKMOUSEEVENT);
-        return TRUE;
-    }
-
-    if (!is_window( info->hwndTrack ))
-    {
-        SetLastError( ERROR_INVALID_WINDOW_HANDLE );
-        return FALSE;
-    }
-
-    hover_time = (info->dwFlags & TME_HOVER) ? info->dwHoverTime : HOVER_DEFAULT;
-
-    if (hover_time == HOVER_DEFAULT || hover_time == 0)
-        NtUserSystemParametersInfo( SPI_GETMOUSEHOVERTIME, 0, &hover_time, 0 );
-
-    get_cursor_pos( &pos );
-    hwnd = window_from_point( info->hwndTrack, pos, &hittest );
-    TRACE( "point %s hwnd %p hittest %d\n", wine_dbgstr_point(&pos), hwnd, hittest );
-
-    if (info->dwFlags & ~(TME_CANCEL | TME_HOVER | TME_LEAVE | TME_NONCLIENT))
-        FIXME( "ignoring flags %#x\n", info->dwFlags & ~(TME_CANCEL | TME_HOVER | TME_LEAVE | TME_NONCLIENT) );
-
-    if (info->dwFlags & TME_CANCEL)
-    {
-        if (tracking_info.info.hwndTrack == info->hwndTrack)
-        {
-            tracking_info.info.dwFlags &= ~(info->dwFlags & ~TME_CANCEL);
-
-            /* if we aren't tracking on hover or leave remove this entry */
-            if (!(tracking_info.info.dwFlags & (TME_HOVER | TME_LEAVE)))
-            {
-                kill_system_timer( tracking_info.info.hwndTrack, SYSTEM_TIMER_TRACK_MOUSE );
-                tracking_info.info.hwndTrack = 0;
-                tracking_info.info.dwFlags = 0;
-                tracking_info.info.dwHoverTime = 0;
-            }
-        }
-    }
-    else
-    {
-        /* In our implementation, it's possible that another window will receive
-         * WM_MOUSEMOVE and call TrackMouseEvent before TrackMouseEventProc is
-         * called. In such a situation, post the WM_MOUSELEAVE now. */
-        if ((tracking_info.info.dwFlags & TME_LEAVE) && tracking_info.info.hwndTrack != NULL)
-            check_mouse_leave(hwnd, hittest);
-
-        kill_system_timer( tracking_info.info.hwndTrack, SYSTEM_TIMER_TRACK_MOUSE );
-        tracking_info.info.hwndTrack = 0;
-        tracking_info.info.dwFlags = 0;
-        tracking_info.info.dwHoverTime = 0;
-
-        if (info->hwndTrack == hwnd)
-        {
-            /* Adding new mouse event to the tracking list */
-            tracking_info.info = *info;
-            tracking_info.info.dwHoverTime = hover_time;
-
-            /* Initialize HoverInfo variables even if not hover tracking */
-            tracking_info.pos = pos;
-
-            NtUserSetSystemTimer( tracking_info.info.hwndTrack, SYSTEM_TIMER_TRACK_MOUSE, hover_time );
-        }
-    }
-
-    return TRUE;
-}
-
 /**********************************************************************
  *		set_capture_window
  */
@@ -1483,14 +1161,6 @@ HWND get_active_window(void)
     return NtUserGetGUIThreadInfo( GetCurrentThreadId(), &info ) ? info.hwndActive : 0;
 }
 
-/* see GetCapture */
-HWND get_capture(void)
-{
-    GUITHREADINFO info;
-    info.cbSize = sizeof(info);
-    return NtUserGetGUIThreadInfo( GetCurrentThreadId(), &info ) ? info.hwndCapture : 0;
-}
-
 /* see GetFocus */
 HWND get_focus(void)
 {
@@ -1583,9 +1253,9 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
     if (hwnd)
     {
         /* send palette messages */
-        if (send_message( hwnd, WM_QUERYNEWPALETTE, 0, 0 ))
-            send_message_timeout( HWND_BROADCAST, WM_PALETTEISCHANGING, (WPARAM)hwnd, 0,
-                                  SMTO_ABORTIFHUNG, 2000, NULL, FALSE );
+        if (send_message( hwnd, WM_QUERYNEWPALETTE, 0, 0 ) && user_callbacks)
+            user_callbacks->pSendMessageTimeoutW( HWND_BROADCAST, WM_PALETTEISCHANGING, (WPARAM)hwnd, 0,
+                                                  SMTO_ABORTIFHUNG, 2000, NULL );
         if (!is_window(hwnd)) return FALSE;
     }
 
@@ -1625,7 +1295,7 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
                       MAKEWPARAM( mouse ? WA_CLICKACTIVE : WA_ACTIVE, is_iconic(hwnd) ),
                       (LPARAM)previous );
         if (NtUserGetAncestor( hwnd, GA_PARENT ) == get_desktop_window())
-            NtUserPostMessage( get_desktop_window(), WM_PARENTNOTIFY, WM_NCACTIVATE, (LPARAM)hwnd );
+            post_message( get_desktop_window(), WM_PARENTNOTIFY, WM_NCACTIVATE, (LPARAM)hwnd );
     }
 
     /* now change focus if necessary */
@@ -1760,386 +1430,15 @@ BOOL set_foreground_window( HWND hwnd, BOOL mouse )
     {
         if (send_msg_old)  /* old window belongs to other thread */
             NtUserMessageCall( previous, WM_WINE_SETACTIVEWINDOW, 0, 0,
-                               0, NtUserSendNotifyMessage, FALSE );
+                               0, FNID_SENDNOTIFYMESSAGE, FALSE );
         else if (send_msg_new)  /* old window belongs to us but new one to other thread */
             ret = set_active_window( 0, NULL, mouse, TRUE );
 
         if (send_msg_new)  /* new window belongs to other thread */
             NtUserMessageCall( hwnd, WM_WINE_SETACTIVEWINDOW, (WPARAM)hwnd, 0,
-                               0, NtUserSendNotifyMessage, FALSE );
+                               0, FNID_SENDNOTIFYMESSAGE, FALSE );
         else  /* new window belongs to us */
             ret = set_active_window( hwnd, NULL, mouse, TRUE );
     }
     return ret;
 }
-
-struct
-{
-    HBITMAP bitmap;
-    unsigned int timeout;
-} caret = {0, 500};
-
-static void display_caret( HWND hwnd, const RECT *r )
-{
-    HDC dc, mem_dc;
-
-    /* do not use DCX_CACHE here, since coördinates are in logical units */
-    if (!(dc = NtUserGetDCEx( hwnd, 0, DCX_USESTYLE )))
-        return;
-    mem_dc = NtGdiCreateCompatibleDC(dc);
-    if (mem_dc)
-    {
-        HBITMAP prev_bitmap;
-
-        prev_bitmap = NtGdiSelectBitmap( mem_dc, caret.bitmap );
-        NtGdiBitBlt( dc, r->left, r->top, r->right-r->left, r->bottom-r->top, mem_dc, 0, 0, SRCINVERT, 0, 0 );
-        NtGdiSelectBitmap( mem_dc, prev_bitmap );
-        NtGdiDeleteObjectApp( mem_dc );
-    }
-    NtUserReleaseDC( hwnd, dc );
-}
-
-static unsigned int get_caret_registry_timeout(void)
-{
-    char value_buffer[FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data[11 * sizeof(WCHAR)])];
-    KEY_VALUE_PARTIAL_INFORMATION *value = (void *)value_buffer;
-    unsigned int ret = 500;
-    HKEY key;
-
-    if (!(key = reg_open_hkcu_key( "Control Panel\\Desktop" )))
-        return ret;
-
-    if (query_reg_ascii_value( key, "CursorBlinkRate", value, sizeof(value_buffer) ))
-        ret = wcstoul( (WCHAR *)value->Data, NULL, 10 );
-    NtClose( key );
-    return ret;
-}
-
-/*****************************************************************
- *           NtUserCreateCaret  (win32u.@)
- */
-BOOL WINAPI NtUserCreateCaret( HWND hwnd, HBITMAP bitmap, int width, int height )
-{
-    HBITMAP caret_bitmap = 0;
-    int old_state = 0;
-    int hidden = 0;
-    HWND prev = 0;
-    BOOL ret;
-    RECT r;
-
-    TRACE( "hwnd %p, bitmap %p, width %d, height %d\n", hwnd, bitmap, width, height );
-
-    if (!hwnd) return FALSE;
-
-    if (bitmap && bitmap != (HBITMAP)1)
-    {
-        BITMAP bitmap_data;
-
-        if (!NtGdiExtGetObjectW( bitmap, sizeof(bitmap_data), &bitmap_data )) return FALSE;
-        caret_bitmap = NtGdiCreateBitmap( bitmap_data.bmWidth, bitmap_data.bmHeight,
-                                          bitmap_data.bmPlanes, bitmap_data.bmBitsPixel, NULL );
-        if (caret_bitmap)
-        {
-            size_t size = bitmap_data.bmWidthBytes * bitmap_data.bmHeight;
-            BYTE *bits = malloc( size );
-
-            NtGdiGetBitmapBits( bitmap, size, bits );
-            NtGdiSetBitmapBits( caret_bitmap, size, bits );
-            free( bits );
-        }
-    }
-    else
-    {
-        HDC dc;
-
-        if (!width) width = get_system_metrics( SM_CXBORDER );
-        if (!height) height = get_system_metrics( SM_CYBORDER );
-
-        /* create the uniform bitmap on the fly */
-        dc = NtUserGetDCEx( hwnd, 0, DCX_USESTYLE );
-        if (dc)
-        {
-            HDC mem_dc = NtGdiCreateCompatibleDC( dc );
-            if (mem_dc)
-            {
-                if ((caret_bitmap = NtGdiCreateCompatibleBitmap( mem_dc, width, height )))
-                {
-                    HBITMAP prev_bitmap = NtGdiSelectBitmap( mem_dc, caret_bitmap );
-                    SetRect( &r, 0, 0, width, height );
-                    fill_rect( mem_dc, &r, GetStockObject( bitmap ? GRAY_BRUSH : WHITE_BRUSH ));
-                    NtGdiSelectBitmap( mem_dc, prev_bitmap );
-                }
-                NtGdiDeleteObjectApp( mem_dc );
-            }
-            NtUserReleaseDC( hwnd, dc );
-        }
-    }
-    if (!caret_bitmap) return FALSE;
-
-    SERVER_START_REQ( set_caret_window )
-    {
-        req->handle = wine_server_user_handle( hwnd );
-        req->width  = width;
-        req->height = height;
-        if ((ret = !wine_server_call_err( req )))
-        {
-            prev      = wine_server_ptr_handle( reply->previous );
-            r.left    = reply->old_rect.left;
-            r.top     = reply->old_rect.top;
-            r.right   = reply->old_rect.right;
-            r.bottom  = reply->old_rect.bottom;
-            old_state = reply->old_state;
-            hidden    = reply->old_hide;
-        }
-    }
-    SERVER_END_REQ;
-    if (!ret) return FALSE;
-
-    if (prev && !hidden)  /* hide the previous one */
-    {
-        /* FIXME: won't work if prev belongs to a different process */
-        kill_system_timer( prev, SYSTEM_TIMER_CARET );
-        if (old_state) display_caret( prev, &r );
-    }
-
-    if (caret.bitmap) NtGdiDeleteObjectApp( caret.bitmap );
-    caret.bitmap = caret_bitmap;
-    caret.timeout = get_caret_registry_timeout();
-    return TRUE;
-}
-
-/*******************************************************************
- *              destroy_caret
- */
-BOOL destroy_caret(void)
-{
-    int old_state = 0;
-    int hidden = 0;
-    HWND prev = 0;
-    BOOL ret;
-    RECT r;
-
-    SERVER_START_REQ( set_caret_window )
-    {
-        req->handle = 0;
-        req->width  = 0;
-        req->height = 0;
-        if ((ret = !wine_server_call_err( req )))
-        {
-            prev      = wine_server_ptr_handle( reply->previous );
-            r.left    = reply->old_rect.left;
-            r.top     = reply->old_rect.top;
-            r.right   = reply->old_rect.right;
-            r.bottom  = reply->old_rect.bottom;
-            old_state = reply->old_state;
-            hidden    = reply->old_hide;
-        }
-    }
-    SERVER_END_REQ;
-
-    if (ret && prev && !hidden)
-    {
-        /* FIXME: won't work if prev belongs to a different process */
-        kill_system_timer( prev, SYSTEM_TIMER_CARET );
-        if (old_state) display_caret( prev, &r );
-    }
-    if (caret.bitmap) NtGdiDeleteObjectApp( caret.bitmap );
-    caret.bitmap = 0;
-    return ret;
-}
-
-/*****************************************************************
- *           NtUserGetCaretBlinkTime  (win32u.@)
- */
-UINT WINAPI NtUserGetCaretBlinkTime(void)
-{
-    return caret.timeout;
-}
-
-/*******************************************************************
- *              set_caret_blink_time
- */
-BOOL set_caret_blink_time( unsigned int time )
-{
-    TRACE( "time %u\n", time );
-
-    caret.timeout = time;
-    /* FIXME: update the timer */
-    return TRUE;
-}
-
-/*****************************************************************
- *           NtUserGetCaretPos  (win32u.@)
- */
-BOOL WINAPI NtUserGetCaretPos( POINT *pt )
-{
-    BOOL ret;
-
-    SERVER_START_REQ( set_caret_info )
-    {
-        req->flags  = 0;  /* don't set anything */
-        req->handle = 0;
-        req->x      = 0;
-        req->y      = 0;
-        req->hide   = 0;
-        req->state  = 0;
-        if ((ret = !wine_server_call_err( req )))
-        {
-            pt->x = reply->old_rect.left;
-            pt->y = reply->old_rect.top;
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-/*******************************************************************
- *              set_caret_pos
- */
-BOOL set_caret_pos( int x, int y )
-{
-    int old_state = 0;
-    int hidden = 0;
-    HWND hwnd = 0;
-    BOOL ret;
-    RECT r;
-
-    TRACE( "(%d, %d)\n", x, y );
-
-    SERVER_START_REQ( set_caret_info )
-    {
-        req->flags  = SET_CARET_POS|SET_CARET_STATE;
-        req->handle = 0;
-        req->x      = x;
-        req->y      = y;
-        req->hide   = 0;
-        req->state  = CARET_STATE_ON_IF_MOVED;
-        if ((ret = !wine_server_call_err( req )))
-        {
-            hwnd      = wine_server_ptr_handle( reply->full_handle );
-            r.left    = reply->old_rect.left;
-            r.top     = reply->old_rect.top;
-            r.right   = reply->old_rect.right;
-            r.bottom  = reply->old_rect.bottom;
-            old_state = reply->old_state;
-            hidden    = reply->old_hide;
-        }
-    }
-    SERVER_END_REQ;
-    if (ret && !hidden && (x != r.left || y != r.top))
-    {
-        if (old_state) display_caret( hwnd, &r );
-        r.right += x - r.left;
-        r.bottom += y - r.top;
-        r.left = x;
-        r.top = y;
-        display_caret( hwnd, &r );
-        NtUserSetSystemTimer( hwnd, SYSTEM_TIMER_CARET, caret.timeout );
-    }
-    return ret;
-}
-
-/*****************************************************************
- *           NtUserShowCaret  (win32u.@)
- */
-BOOL WINAPI NtUserShowCaret( HWND hwnd )
-{
-    int hidden = 0;
-    BOOL ret;
-    RECT r;
-
-    SERVER_START_REQ( set_caret_info )
-    {
-        req->flags  = SET_CARET_HIDE | SET_CARET_STATE;
-        req->handle = wine_server_user_handle( hwnd );
-        req->x      = 0;
-        req->y      = 0;
-        req->hide   = -1;
-        req->state  = CARET_STATE_ON;
-        if ((ret = !wine_server_call_err( req )))
-        {
-            hwnd      = wine_server_ptr_handle( reply->full_handle );
-            r.left    = reply->old_rect.left;
-            r.top     = reply->old_rect.top;
-            r.right   = reply->old_rect.right;
-            r.bottom  = reply->old_rect.bottom;
-            hidden    = reply->old_hide;
-        }
-    }
-    SERVER_END_REQ;
-
-    if (ret && hidden == 1)  /* hidden was 1 so it's now 0 */
-    {
-        display_caret( hwnd, &r );
-        NtUserSetSystemTimer( hwnd, SYSTEM_TIMER_CARET, caret.timeout );
-    }
-    return ret;
-}
-
-/*****************************************************************
- *           NtUserHideCaret  (win32u.@)
- */
-BOOL WINAPI NtUserHideCaret( HWND hwnd )
-{
-    int old_state = 0;
-    int hidden = 0;
-    BOOL ret;
-    RECT r;
-
-    SERVER_START_REQ( set_caret_info )
-    {
-        req->flags  = SET_CARET_HIDE | SET_CARET_STATE;
-        req->handle = wine_server_user_handle( hwnd );
-        req->x      = 0;
-        req->y      = 0;
-        req->hide   = 1;
-        req->state  = CARET_STATE_OFF;
-        if ((ret = !wine_server_call_err( req )))
-        {
-            hwnd      = wine_server_ptr_handle( reply->full_handle );
-            r.left    = reply->old_rect.left;
-            r.top     = reply->old_rect.top;
-            r.right   = reply->old_rect.right;
-            r.bottom  = reply->old_rect.bottom;
-            old_state = reply->old_state;
-            hidden    = reply->old_hide;
-        }
-    }
-    SERVER_END_REQ;
-
-    if (ret && !hidden)
-    {
-        if (old_state) display_caret( hwnd, &r );
-        kill_system_timer( hwnd, SYSTEM_TIMER_CARET );
-    }
-    return ret;
-}
-
-void toggle_caret( HWND hwnd )
-{
-    BOOL ret;
-    RECT r;
-    int hidden = 0;
-
-    SERVER_START_REQ( set_caret_info )
-    {
-        req->flags  = SET_CARET_STATE;
-        req->handle = wine_server_user_handle( hwnd );
-        req->x      = 0;
-        req->y      = 0;
-        req->hide   = 0;
-        req->state  = CARET_STATE_TOGGLE;
-        if ((ret = !wine_server_call( req )))
-        {
-            hwnd      = wine_server_ptr_handle( reply->full_handle );
-            r.left    = reply->old_rect.left;
-            r.top     = reply->old_rect.top;
-            r.right   = reply->old_rect.right;
-            r.bottom  = reply->old_rect.bottom;
-            hidden    = reply->old_hide;
-        }
-    }
-    SERVER_END_REQ;
-
-    if (ret && !hidden) display_caret( hwnd, &r );
-}
diff --git a/dlls/win32u/menu.c b/dlls/win32u/menu.c
index a6aeae045e2..921c5752536 100644
--- a/dlls/win32u/menu.c
+++ b/dlls/win32u/menu.c
@@ -25,10 +25,8 @@
 
 #include "win32u_private.h"
 #include "ntuser_private.h"
-#include "wine/server.h"
 #include "wine/debug.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(menu);
 WINE_DECLARE_DEBUG_CHANNEL(accel);
 
 /* the accelerator user object */
@@ -39,26 +37,6 @@ struct accelerator
     ACCEL              table[1];
 };
 
-/* maximum allowed depth of any branch in the menu tree.
- * This value is slightly larger than in windows (25) to
- * stay on the safe side. */
-#define MAXMENUDEPTH 30
-
-/* (other menu->FocusedItem values give the position of the focused item) */
-#define NO_SELECTED_ITEM  0xffff
-
-/* macro to test that flags do not indicate bitmap, ownerdraw or separator */
-#define IS_STRING_ITEM(flags) (MENU_ITEM_TYPE ((flags)) == MF_STRING)
-#define IS_MAGIC_BITMAP(id)     ((id) && ((INT_PTR)(id) < 12) && ((INT_PTR)(id) >= -1))
-
-#define MENUITEMINFO_TYPE_MASK                                          \
-    (MFT_STRING | MFT_BITMAP | MFT_OWNERDRAW | MFT_SEPARATOR |          \
-     MFT_MENUBARBREAK | MFT_MENUBREAK | MFT_RADIOCHECK |                \
-     MFT_RIGHTORDER | MFT_RIGHTJUSTIFY /* same as MF_HELP */ )
-#define TYPE_MASK  (MENUITEMINFO_TYPE_MASK | MF_POPUP | MF_SYSMENU)
-#define STATE_MASK (~TYPE_MASK)
-#define MENUITEMINFO_STATE_MASK (STATE_MASK & ~(MF_BYPOSITION | MF_MOUSESELECT))
-
 /**********************************************************************
  *           NtUserCopyAcceleratorTable   (win32u.@)
  */
@@ -128,1202 +106,16 @@ BOOL WINAPI NtUserDestroyAcceleratorTable( HACCEL handle )
     return TRUE;
 }
 
-#define MENUFLAG(bit,text) \
-  do { \
-      if (flags & (bit)) { flags &= ~(bit); strcat(buf, (text)); } \
-  } while (0)
-
-static const char *debugstr_menuitem( const MENUITEM *item )
-{
-    static const char *const hbmmenus[] = { "HBMMENU_CALLBACK", "", "HBMMENU_SYSTEM",
-        "HBMMENU_MBAR_RESTORE", "HBMMENU_MBAR_MINIMIZE", "UNKNOWN BITMAP", "HBMMENU_MBAR_CLOSE",
-        "HBMMENU_MBAR_CLOSE_D", "HBMMENU_MBAR_MINIMIZE_D", "HBMMENU_POPUP_CLOSE",
-        "HBMMENU_POPUP_RESTORE", "HBMMENU_POPUP_MAXIMIZE", "HBMMENU_POPUP_MINIMIZE" };
-    char buf[256];
-    UINT flags;
-
-    if (!item) return "NULL";
-
-    sprintf( buf, "{ ID=0x%lx", item->wID );
-    if (item->hSubMenu) sprintf( buf + strlen(buf), ", Sub=%p", item->hSubMenu );
-
-    flags = item->fType;
-    if (flags)
-    {
-        strcat( buf, ", fType=" );
-        MENUFLAG( MFT_SEPARATOR, "sep" );
-        MENUFLAG( MFT_OWNERDRAW, "own" );
-        MENUFLAG( MFT_BITMAP, "bit" );
-        MENUFLAG( MF_POPUP, "pop" );
-        MENUFLAG( MFT_MENUBARBREAK, "barbrk" );
-        MENUFLAG( MFT_MENUBREAK, "brk");
-        MENUFLAG( MFT_RADIOCHECK, "radio" );
-        MENUFLAG( MFT_RIGHTORDER, "rorder" );
-        MENUFLAG( MF_SYSMENU, "sys" );
-        MENUFLAG( MFT_RIGHTJUSTIFY, "right" );  /* same as MF_HELP */
-        if (flags) sprintf( buf + strlen(buf), "+0x%x", flags );
-    }
-
-    flags = item->fState;
-    if (flags)
-    {
-        strcat( buf, ", State=" );
-        MENUFLAG( MFS_GRAYED, "grey" );
-        MENUFLAG( MFS_DEFAULT, "default" );
-        MENUFLAG( MFS_DISABLED, "dis" );
-        MENUFLAG( MFS_CHECKED, "check" );
-        MENUFLAG( MFS_HILITE, "hi" );
-        MENUFLAG( MF_USECHECKBITMAPS, "usebit" );
-        MENUFLAG( MF_MOUSESELECT, "mouse" );
-        if (flags) sprintf( buf + strlen(buf), "+0x%x", flags );
-    }
-
-    if (item->hCheckBit)   sprintf( buf + strlen(buf), ", Chk=%p", item->hCheckBit );
-    if (item->hUnCheckBit) sprintf( buf + strlen(buf), ", Unc=%p", item->hUnCheckBit );
-    if (item->text)        sprintf( buf + strlen(buf), ", Text=%s", debugstr_w(item->text) );
-    if (item->dwItemData)  sprintf( buf + strlen(buf), ", ItemData=0x%08lx", item->dwItemData );
-
-    if (item->hbmpItem)
-    {
-        if (IS_MAGIC_BITMAP( item->hbmpItem ))
-            sprintf( buf + strlen(buf), ", hbitmap=%s", hbmmenus[(INT_PTR)item->hbmpItem + 1] );
-        else
-            sprintf( buf + strlen(buf), ", hbitmap=%p", item->hbmpItem );
-    }
-    return wine_dbg_sprintf( "%s  }", buf );
-}
-
-#undef MENUFLAG
-
-static POPUPMENU *grab_menu_ptr( HMENU handle )
-{
-    POPUPMENU *menu = get_user_handle_ptr( handle, NTUSER_OBJ_MENU );
-
-    if (menu == OBJ_OTHER_PROCESS)
-    {
-        WARN( "other process menu %p\n", handle );
-        return NULL;
-    }
-
-    if (menu)
-        menu->refcount++;
-    else
-        WARN( "invalid menu handle=%p\n", handle );
-    return menu;
-}
-
-static void release_menu_ptr( POPUPMENU *menu )
-{
-    if (menu)
-    {
-        menu->refcount--;
-        release_user_handle_ptr( menu );
-    }
-}
-
-/* see IsMenu */
-static BOOL is_menu( HMENU handle )
-{
-    POPUPMENU *menu;
-    BOOL is_menu;
-
-    menu = grab_menu_ptr( handle );
-    is_menu = menu != NULL;
-    release_menu_ptr( menu );
-
-    if (!is_menu) SetLastError( ERROR_INVALID_MENU_HANDLE );
-    return is_menu;
-}
-
-/***********************************************************************
- *           get_win_sys_menu
- *
- * Get the system menu of a window
- */
-static HMENU get_win_sys_menu( HWND hwnd )
-{
-    HMENU ret = 0;
-    WND *win = get_win_ptr( hwnd );
-    if (win && win != WND_OTHER_PROCESS && win != WND_DESKTOP)
-    {
-        ret = win->hSysMenu;
-        release_win_ptr( win );
-    }
-    return ret;
-}
-
-static POPUPMENU *find_menu_item( HMENU handle, UINT id, UINT flags, UINT *pos )
-{
-    UINT fallback_pos = ~0u, i;
-    POPUPMENU *menu;
-
-    menu = grab_menu_ptr( handle );
-    if (!menu)
-        return NULL;
-
-    if (flags & MF_BYPOSITION)
-    {
-        if (id >= menu->nItems)
-        {
-            release_menu_ptr( menu );
-            return NULL;
-        }
-
-        if (pos) *pos = id;
-        return menu;
-    }
-    else
-    {
-        MENUITEM *item = menu->items;
-        for (i = 0; i < menu->nItems; i++, item++)
-        {
-            if (item->fType & MF_POPUP)
-            {
-                POPUPMENU *submenu = find_menu_item( item->hSubMenu, id, flags, pos );
-
-                if (submenu)
-                {
-                    release_menu_ptr( menu );
-                    return submenu;
-                }
-                else if (item->wID == id)
-                {
-                    /* fallback to this item if nothing else found */
-                    fallback_pos = i;
-                }
-            }
-            else if (item->wID == id)
-            {
-                if (pos) *pos = i;
-                return menu;
-            }
-        }
-    }
-
-    if (fallback_pos != ~0u)
-        *pos = fallback_pos;
-    else
-    {
-        release_menu_ptr( menu );
-        menu = NULL;
-    }
-
-    return menu;
-}
-
-static POPUPMENU *insert_menu_item( HMENU handle, UINT id, UINT flags, UINT *ret_pos )
-{
-    MENUITEM *new_items;
-    POPUPMENU *menu;
-    UINT pos = id;
-
-    /* Find where to insert new item */
-    if (!(menu = find_menu_item(handle, id, flags, &pos)))
-    {
-        if (!(menu = grab_menu_ptr(handle)))
-            return NULL;
-        pos = menu->nItems;
-    }
-
-    /* Make sure that MDI system buttons stay on the right side.
-     * Note: XP treats only bitmap handles 1 - 6 as "magic" ones
-     * regardless of their id.
-     */
-    while (pos > 0 && (INT_PTR)menu->items[pos - 1].hbmpItem >= (INT_PTR)HBMMENU_SYSTEM &&
-           (INT_PTR)menu->items[pos - 1].hbmpItem <= (INT_PTR)HBMMENU_MBAR_CLOSE_D)
-        pos--;
-
-    TRACE( "inserting at %u flags %x\n", pos, flags );
-
-    new_items = malloc( sizeof(MENUITEM) * (menu->nItems + 1) );
-    if (!new_items)
-    {
-        release_menu_ptr( menu );
-        return NULL;
-    }
-    if (menu->nItems > 0)
-    {
-        /* Copy the old array into the new one */
-        if (pos > 0) memcpy( new_items, menu->items, pos * sizeof(MENUITEM) );
-        if (pos < menu->nItems) memcpy( &new_items[pos + 1], &menu->items[pos],
-                                        (menu->nItems - pos) * sizeof(MENUITEM) );
-        free( menu->items );
-    }
-    menu->items = new_items;
-    menu->nItems++;
-    memset( &new_items[pos], 0, sizeof(*new_items) );
-    menu->Height = 0; /* force size recalculate */
-
-    *ret_pos = pos;
-    return menu;
-}
-
-static BOOL is_win_menu_disallowed( HWND hwnd )
-{
-    return (get_window_long(hwnd, GWL_STYLE) & (WS_CHILD | WS_POPUP)) == WS_CHILD;
-}
-
-/***********************************************************************
- *           find_submenu
- *
- * Find a Sub menu. Return the position of the submenu, and modifies
- * *hmenu in case it is found in another sub-menu.
- * If the submenu cannot be found, NO_SELECTED_ITEM is returned.
- */
-static UINT find_submenu( HMENU *handle_ptr, HMENU target )
-{
-    POPUPMENU *menu;
-    MENUITEM *item;
-    UINT i;
-
-    if (*handle_ptr == (HMENU)0xffff || !(menu = grab_menu_ptr( *handle_ptr )))
-        return NO_SELECTED_ITEM;
-
-    item = menu->items;
-    for (i = 0; i < menu->nItems; i++, item++)
-    {
-        if(!(item->fType & MF_POPUP)) continue;
-        if (item->hSubMenu == target)
-        {
-            release_menu_ptr( menu );
-            return i;
-        }
-        else
-        {
-            HMENU hsubmenu = item->hSubMenu;
-            UINT pos = find_submenu( &hsubmenu, target );
-            if (pos != NO_SELECTED_ITEM)
-            {
-                *handle_ptr = hsubmenu;
-                release_menu_ptr( menu );
-                return pos;
-            }
-        }
-    }
-
-    release_menu_ptr( menu );
-    return NO_SELECTED_ITEM;
-}
-
 /* see GetMenu */
 HMENU get_menu( HWND hwnd )
 {
     return UlongToHandle( get_window_long( hwnd, GWLP_ID ));
 }
 
-/* see CreateMenu and CreatePopupMenu */
-HMENU create_menu( BOOL is_popup )
-{
-    POPUPMENU *menu;
-    HMENU handle;
-
-    if (!(menu = calloc( 1, sizeof(*menu) ))) return 0;
-    menu->FocusedItem = NO_SELECTED_ITEM;
-    menu->refcount = 1;
-    if (is_popup) menu->wFlags |= MF_POPUP;
-
-    if (!(handle = alloc_user_handle( &menu->obj, NTUSER_OBJ_MENU ))) free( menu );
-
-    TRACE( "return %p\n", handle );
-    return handle;
-}
-
 /**********************************************************************
  *         NtUserDestroyMenu   (win32u.@)
  */
-BOOL WINAPI NtUserDestroyMenu( HMENU handle )
-{
-    POPUPMENU *menu;
-
-    TRACE( "(%p)\n", handle );
-
-    if (!(menu = free_user_handle( handle, NTUSER_OBJ_MENU ))) return FALSE;
-    if (menu == OBJ_OTHER_PROCESS) return FALSE;
-
-    /* DestroyMenu should not destroy system menu popup owner */
-    if ((menu->wFlags & (MF_POPUP | MF_SYSMENU)) == MF_POPUP && menu->hWnd)
-    {
-        NtUserDestroyWindow( menu->hWnd );
-        menu->hWnd = 0;
-    }
-
-    /* recursively destroy submenus */
-    if (menu->items)
-    {
-        MENUITEM *item = menu->items;
-        int i;
-
-        for (i = menu->nItems; i > 0; i--, item++)
-        {
-            if (item->fType & MF_POPUP) NtUserDestroyMenu( item->hSubMenu );
-            free( item->text );
-        }
-        free( menu->items );
-    }
-
-    free( menu );
-    return TRUE;
-}
-
-/*******************************************************************
- *           set_window_menu
- *
- * Helper for NtUserSetMenu that does not call NtUserSetWindowPos.
- */
-BOOL set_window_menu( HWND hwnd, HMENU handle )
-{
-    TRACE( "(%p, %p);\n", hwnd, handle );
-
-    if (handle && !is_menu( handle ))
-    {
-        WARN( "%p is not a menu handle\n", handle );
-        return FALSE;
-    }
-
-    if (is_win_menu_disallowed( hwnd ))
-        return FALSE;
-
-    hwnd = get_full_window_handle( hwnd );
-    if (get_capture() == hwnd)
-        set_capture_window( 0, GUI_INMENUMODE, NULL );  /* release the capture */
-
-    if (handle)
-    {
-        POPUPMENU *menu;
-
-        if (!(menu = grab_menu_ptr( handle ))) return FALSE;
-        menu->hWnd = hwnd;
-        menu->Height = 0;  /* Make sure we recalculate the size */
-        release_menu_ptr(menu);
-    }
-
-    NtUserSetWindowLong( hwnd, GWLP_ID, (LONG_PTR)handle, FALSE );
-    return TRUE;
-}
-
-/**********************************************************************
- *           NtUserSetMenu    (win32u.@)
- */
-BOOL WINAPI NtUserSetMenu( HWND hwnd, HMENU menu )
-{
-    if (!set_window_menu( hwnd, menu ))
-        return FALSE;
-
-    NtUserSetWindowPos( hwnd, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE |
-                        SWP_NOACTIVATE | SWP_NOZORDER | SWP_FRAMECHANGED );
-    return TRUE;
-}
-
-/*******************************************************************
- *           NtUserCheckMenuItem    (win32u.@)
- */
-DWORD WINAPI NtUserCheckMenuItem( HMENU handle, UINT id, UINT flags )
-{
-    POPUPMENU *menu;
-    MENUITEM *item;
-    DWORD ret;
-    UINT pos;
-
-    if (!(menu = find_menu_item(handle, id, flags, &pos)))
-        return -1;
-    item = &menu->items[pos];
-
-    ret = item->fState & MF_CHECKED;
-    if (flags & MF_CHECKED) item->fState |= MF_CHECKED;
-    else item->fState &= ~MF_CHECKED;
-    release_menu_ptr(menu);
-    return ret;
-}
-
-/**********************************************************************
- *           NtUserEnableMenuItem    (win32u.@)
- */
-BOOL WINAPI NtUserEnableMenuItem( HMENU handle, UINT id, UINT flags )
-{
-    UINT oldflags, pos;
-    POPUPMENU *menu;
-    MENUITEM *item;
-
-    TRACE( "(%p, %04x, %04x)\n", handle, id, flags );
-
-    /* Get the Popupmenu to access the owner menu */
-    if (!(menu = find_menu_item( handle, id, flags, &pos )))
-	return ~0u;
-
-    item = &menu->items[pos];
-    oldflags = item->fState & (MF_GRAYED | MF_DISABLED);
-    item->fState ^= (oldflags ^ flags) & (MF_GRAYED | MF_DISABLED);
-
-    /* If the close item in the system menu change update the close button */
-    if (item->wID == SC_CLOSE && oldflags != flags && menu->hSysMenuOwner)
-    {
-        POPUPMENU *parent_menu;
-        RECT rc;
-        HWND hwnd;
-
-        /* Get the parent menu to access */
-        parent_menu = grab_menu_ptr( menu->hSysMenuOwner );
-        release_menu_ptr( menu );
-        if (!parent_menu)
-            return ~0u;
-
-        hwnd = parent_menu->hWnd;
-        release_menu_ptr( parent_menu );
-
-        /* Refresh the frame to reflect the change */
-        get_window_rects( hwnd, COORDS_CLIENT, &rc, NULL, get_thread_dpi() );
-        rc.bottom = 0;
-        NtUserRedrawWindow( hwnd, &rc, 0, RDW_FRAME | RDW_INVALIDATE | RDW_NOCHILDREN );
-    }
-    else
-        release_menu_ptr( menu );
-
-    return oldflags;
-}
-
-/* see DrawMenuBar */
-BOOL draw_menu_bar( HWND hwnd )
-{
-    HMENU handle;
-
-    if (!is_window( hwnd )) return FALSE;
-    if (is_win_menu_disallowed( hwnd )) return TRUE;
-
-    if ((handle = get_menu( hwnd )))
-    {
-        POPUPMENU *menu = grab_menu_ptr( handle );
-        if (menu)
-        {
-            menu->Height = 0; /* Make sure we call MENU_MenuBarCalcSize */
-            menu->hwndOwner = hwnd;
-            release_menu_ptr( menu );
-        }
-    }
-
-    return NtUserSetWindowPos( hwnd, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE |
-                               SWP_NOACTIVATE | SWP_NOZORDER | SWP_FRAMECHANGED );
-}
-
-/**********************************************************************
- *           NtUserGetMenuItemRect    (win32u.@)
- */
-BOOL WINAPI NtUserGetMenuItemRect( HWND hwnd, HMENU handle, UINT item, RECT *rect )
-{
-    POPUPMENU *menu;
-    UINT pos;
-    RECT window_rect;
-
-    TRACE( "(%p,%p,%d,%p)\n", hwnd, handle, item, rect );
-
-    if (!rect)
-        return FALSE;
-
-    if (!(menu = find_menu_item( handle, item, MF_BYPOSITION, &pos )))
-        return FALSE;
-
-    if (!hwnd) hwnd = menu->hWnd;
-    if (!hwnd)
-    {
-        release_menu_ptr( menu );
-        return FALSE;
-    }
-
-    *rect = menu->items[pos].rect;
-    OffsetRect( rect, menu->items_rect.left, menu->items_rect.top );
-
-    /* Popup menu item draws in the client area */
-    if (menu->wFlags & MF_POPUP) map_window_points( hwnd, 0, (POINT *)rect, 2, get_thread_dpi() );
-    else
-    {
-        /* Sysmenu draws in the non-client area */
-        get_window_rect( hwnd, &window_rect, get_thread_dpi() );
-        OffsetRect( rect, window_rect.left, window_rect.top );
-    }
-
-    release_menu_ptr(menu);
-    return TRUE;
-}
-
-static BOOL set_menu_info( HMENU handle, const MENUINFO *info )
-{
-    POPUPMENU *menu;
-
-    if (!(menu = grab_menu_ptr( handle ))) return FALSE;
-
-    if (info->fMask & MIM_BACKGROUND) menu->hbrBack = info->hbrBack;
-    if (info->fMask & MIM_HELPID)     menu->dwContextHelpID = info->dwContextHelpID;
-    if (info->fMask & MIM_MAXHEIGHT)  menu->cyMax = info->cyMax;
-    if (info->fMask & MIM_MENUDATA)   menu->dwMenuData = info->dwMenuData;
-    if (info->fMask & MIM_STYLE)      menu->dwStyle = info->dwStyle;
-
-    if (info->fMask & MIM_APPLYTOSUBMENUS)
-    {
-        int i;
-        MENUITEM *item = menu->items;
-        for (i = menu->nItems; i; i--, item++)
-            if (item->fType & MF_POPUP)
-                set_menu_info( item->hSubMenu, info);
-    }
-
-    release_menu_ptr( menu );
-    return TRUE;
-}
-
-/**********************************************************************
- *           NtUserThunkedMenuInfo    (win32u.@)
- */
-BOOL WINAPI NtUserThunkedMenuInfo( HMENU menu, const MENUINFO *info )
-{
-    TRACE( "(%p %p)\n", menu, info );
-
-    if (!info)
-    {
-        SetLastError( ERROR_NOACCESS );
-        return FALSE;
-    }
-
-    if (!set_menu_info( menu, info ))
-    {
-        SetLastError( ERROR_INVALID_MENU_HANDLE );
-        return FALSE;
-    }
-
-    if (info->fMask & MIM_STYLE)
-    {
-        if (info->dwStyle & MNS_AUTODISMISS) FIXME("MNS_AUTODISMISS unimplemented\n");
-        if (info->dwStyle & MNS_DRAGDROP) FIXME("MNS_DRAGDROP unimplemented\n");
-        if (info->dwStyle & MNS_MODELESS) FIXME("MNS_MODELESS unimplemented\n");
-    }
-    return TRUE;
-}
-
-/* see GetMenuInfo */
-BOOL get_menu_info( HMENU handle, MENUINFO *info )
-{
-    POPUPMENU *menu;
-
-    TRACE( "(%p %p)\n", handle, info );
-
-    if (!info || info->cbSize != sizeof(MENUINFO) || !(menu = grab_menu_ptr( handle )))
-    {
-        SetLastError( ERROR_INVALID_PARAMETER);
-        return FALSE;
-    }
-
-    if (info->fMask & MIM_BACKGROUND) info->hbrBack = menu->hbrBack;
-    if (info->fMask & MIM_HELPID)     info->dwContextHelpID = menu->dwContextHelpID;
-    if (info->fMask & MIM_MAXHEIGHT)  info->cyMax = menu->cyMax;
-    if (info->fMask & MIM_MENUDATA)   info->dwMenuData = menu->dwMenuData;
-    if (info->fMask & MIM_STYLE)      info->dwStyle = menu->dwStyle;
-
-    release_menu_ptr(menu);
-    return TRUE;
-}
-
-/**********************************************************************
- *           menu_depth
- *
- * detect if there are loops in the menu tree (or the depth is too large)
- */
-static int menu_depth( POPUPMENU *pmenu, int depth)
-{
-    int i, subdepth;
-    MENUITEM *item;
-
-    if (++depth > MAXMENUDEPTH) return depth;
-    item = pmenu->items;
-    subdepth = depth;
-    for (i = 0; i < pmenu->nItems && subdepth <= MAXMENUDEPTH; i++, item++)
-    {
-        POPUPMENU *submenu = item->hSubMenu ? grab_menu_ptr( item->hSubMenu ) : NULL;
-        if (submenu)
-        {
-            int bdepth = menu_depth( submenu, depth);
-            if (bdepth > subdepth) subdepth = bdepth;
-            release_menu_ptr( submenu );
-        }
-        if (subdepth > MAXMENUDEPTH)
-            TRACE( "<- hmenu %p\n", item->hSubMenu );
-    }
-
-    return subdepth;
-}
-
-static BOOL set_menu_item_info( MENUITEM *menu, const MENUITEMINFOW *info )
-{
-    if (!menu) return FALSE;
-
-    TRACE( "%s\n", debugstr_menuitem( menu ));
-
-    if (info->fMask & MIIM_FTYPE )
-    {
-        menu->fType &= ~MENUITEMINFO_TYPE_MASK;
-        menu->fType |= info->fType & MENUITEMINFO_TYPE_MASK;
-    }
-    if (info->fMask & MIIM_STRING )
-    {
-        const WCHAR *text = info->dwTypeData;
-        /* free the string when used */
-        free( menu->text );
-        if (!text)
-            menu->text = NULL;
-        else if ((menu->text = malloc( (lstrlenW(text) + 1) * sizeof(WCHAR) )))
-            lstrcpyW( menu->text, text );
-    }
-
-    if (info->fMask & MIIM_STATE)
-         /* Other menu items having MFS_DEFAULT are not converted
-           to normal items */
-         menu->fState = info->fState & MENUITEMINFO_STATE_MASK;
-
-    if (info->fMask & MIIM_ID)
-        menu->wID = info->wID;
-
-    if (info->fMask & MIIM_SUBMENU)
-    {
-        menu->hSubMenu = info->hSubMenu;
-        if (menu->hSubMenu)
-        {
-            POPUPMENU *submenu = grab_menu_ptr( menu->hSubMenu );
-            if (!submenu)
-            {
-                SetLastError( ERROR_INVALID_PARAMETER);
-                return FALSE;
-            }
-            if (menu_depth( submenu, 0 ) > MAXMENUDEPTH)
-            {
-                ERR( "Loop detected in menu hierarchy or maximum menu depth exceeded\n" );
-                menu->hSubMenu = 0;
-                release_menu_ptr( submenu );
-                return FALSE;
-            }
-            submenu->wFlags |= MF_POPUP;
-            menu->fType |= MF_POPUP;
-            release_menu_ptr( submenu );
-        }
-        else
-            menu->fType &= ~MF_POPUP;
-    }
-
-    if (info->fMask & MIIM_CHECKMARKS)
-    {
-        menu->hCheckBit = info->hbmpChecked;
-        menu->hUnCheckBit = info->hbmpUnchecked;
-    }
-    if (info->fMask & MIIM_DATA)
-        menu->dwItemData = info->dwItemData;
-
-    if (info->fMask & MIIM_BITMAP)
-        menu->hbmpItem = info->hbmpItem;
-
-    if (!menu->text && !(menu->fType & MFT_OWNERDRAW) && !menu->hbmpItem)
-        menu->fType |= MFT_SEPARATOR;
-
-    TRACE( "to: %s\n", debugstr_menuitem( menu ));
-    return TRUE;
-}
-
-/* see GetMenuState */
-static UINT get_menu_state( HMENU handle, UINT item_id, UINT flags )
-{
-    POPUPMENU *menu;
-    UINT state, pos;
-    MENUITEM *item;
-
-    TRACE( "(menu=%p, id=%04x, flags=%04x);\n", handle, item_id, flags );
-
-    if (!(menu = find_menu_item( handle, item_id, flags, &pos )))
-        return -1;
-
-    item = &menu->items[pos];
-    TRACE( "  item: %s\n", debugstr_menuitem( item ));
-    if (item->fType & MF_POPUP)
-    {
-        POPUPMENU *submenu = grab_menu_ptr( item->hSubMenu );
-        if (submenu)
-            state = (submenu->nItems << 8) | ((item->fState | item->fType) & 0xff);
-        else
-            state = -1;
-        release_menu_ptr( submenu );
-    }
-    else
-    {
-        state = item->fType | item->fState;
-    }
-    release_menu_ptr(menu);
-    return state;
-}
-
-/**********************************************************************
- *           NtUserThunkedMenuItemInfo    (win32u.@)
- */
-UINT WINAPI NtUserThunkedMenuItemInfo( HMENU handle, UINT pos, UINT flags, UINT method,
-                                       MENUITEMINFOW *info, UNICODE_STRING *str )
-{
-    POPUPMENU *menu;
-    UINT i;
-    BOOL ret;
-
-    switch (method)
-    {
-    case NtUserInsertMenuItem:
-        if (!info || info->cbSize != sizeof(*info))
-        {
-            SetLastError( ERROR_INVALID_PARAMETER );
-            return FALSE;
-        }
-
-        if (!(menu = insert_menu_item( handle, pos, flags, &i )))
-        {
-            /* workaround for Word 95: pretend that SC_TASKLIST item exists */
-            if (pos == SC_TASKLIST && !(flags & MF_BYPOSITION)) return TRUE;
-            return FALSE;
-        }
-
-        ret = set_menu_item_info( &menu->items[i], info );
-        if (!ret) NtUserRemoveMenu( handle, pos, flags );
-        release_menu_ptr(menu);
-        break;
-
-    case NtUserSetMenuItemInfo:
-        if (!info || info->cbSize != sizeof(*info))
-        {
-            SetLastError( ERROR_INVALID_PARAMETER );
-            return FALSE;
-        }
-
-        if (!(menu = find_menu_item( handle, pos, flags, &i )))
-        {
-            /* workaround for Word 95: pretend that SC_TASKLIST item exists */
-            if (pos == SC_TASKLIST && !(flags & MF_BYPOSITION)) return TRUE;
-            return FALSE;
-        }
-
-        ret = set_menu_item_info( &menu->items[i], info );
-        if (ret) menu->Height = 0; /* force size recalculate */
-        release_menu_ptr(menu);
-        break;
-
-    case NtUserGetMenuState:
-        return get_menu_state( handle, pos, flags );
-
-    default:
-        FIXME( "unsupported method %u\n", method );
-        return FALSE;
-    }
-
-    return ret;
-}
-
-/* see GetMenuItemCount */
-INT get_menu_item_count( HMENU handle )
-{
-    POPUPMENU *menu;
-    INT count;
-
-    if (!(menu = grab_menu_ptr( handle ))) return -1;
-    count = menu->nItems;
-    release_menu_ptr(menu);
-
-    TRACE( "(%p) returning %d\n", handle, count );
-    return count;
-}
-
-/**********************************************************************
- *           NtUserRemoveMenu    (win32u.@)
- */
-BOOL WINAPI NtUserRemoveMenu( HMENU handle, UINT id, UINT flags )
-{
-    POPUPMENU *menu;
-    UINT pos;
-
-    TRACE( "(menu=%p id=%#x flags=%04x)\n", handle, id, flags );
-
-    if (!(menu = find_menu_item( handle, id, flags, &pos )))
-        return FALSE;
-
-    /* Remove item */
-    free( menu->items[pos].text );
-
-    if (--menu->nItems == 0)
-    {
-        free( menu->items );
-        menu->items = NULL;
-    }
-    else
-    {
-        MENUITEM *new_items, *item = &menu->items[pos];
-
-        while (pos < menu->nItems)
-        {
-            *item = item[1];
-            item++;
-            pos++;
-        }
-        new_items = realloc( menu->items, menu->nItems * sizeof(MENUITEM) );
-        if (new_items) menu->items = new_items;
-    }
-
-    release_menu_ptr(menu);
-    return TRUE;
-}
-
-/**********************************************************************
- *         NtUserDeleteMenu    (win32u.@)
- */
-BOOL WINAPI NtUserDeleteMenu( HMENU handle, UINT id, UINT flags )
-{
-    POPUPMENU *menu;
-    UINT pos;
-
-    if (!(menu = find_menu_item( handle, id, flags, &pos )))
-        return FALSE;
-
-    if (menu->items[pos].fType & MF_POPUP)
-        NtUserDestroyMenu( menu->items[pos].hSubMenu );
-
-    NtUserRemoveMenu( menu->obj.handle, pos, flags | MF_BYPOSITION );
-    release_menu_ptr( menu );
-    return TRUE;
-}
-
-/**********************************************************************
- *           NtUserSetMenuContextHelpId    (win32u.@)
- */
-BOOL WINAPI NtUserSetMenuContextHelpId( HMENU handle, DWORD id )
-{
-    POPUPMENU *menu;
-
-    TRACE( "(%p 0x%08x)\n", handle, id );
-
-    if (!(menu = grab_menu_ptr( handle ))) return FALSE;
-    menu->dwContextHelpID = id;
-    release_menu_ptr( menu );
-    return TRUE;
-}
-
-/* see GetSubMenu */
-static HMENU get_sub_menu( HMENU handle, INT pos )
+BOOL WINAPI NtUserDestroyMenu( HMENU menu )
 {
-    POPUPMENU *menu;
-    HMENU submenu;
-    UINT i;
-
-    if (!(menu = find_menu_item( handle, pos, MF_BYPOSITION, &i )))
-        return 0;
-
-    if (menu->items[i].fType & MF_POPUP)
-        submenu = menu->items[i].hSubMenu;
-    else
-        submenu = 0;
-
-    release_menu_ptr(menu);
-    return submenu;
-}
-
-/**********************************************************************
- *           NtUserGetSystemMenu    (win32u.@)
- */
-HMENU WINAPI NtUserGetSystemMenu( HWND hwnd, BOOL revert )
-{
-    WND *win = get_win_ptr( hwnd );
-    HMENU retvalue = 0;
-
-    if (win == WND_DESKTOP || !win) return 0;
-    if (win == WND_OTHER_PROCESS)
-    {
-        if (is_window( hwnd )) FIXME( "not supported on other process window %p\n", hwnd );
-        return 0;
-    }
-
-    if (win->hSysMenu && revert)
-    {
-        NtUserDestroyMenu( win->hSysMenu );
-        win->hSysMenu = 0;
-    }
-
-    if (!win->hSysMenu && (win->dwStyle & WS_SYSMENU) && user_callbacks)
-        win->hSysMenu = user_callbacks->get_sys_menu( hwnd, 0 );
-
-    if (win->hSysMenu)
-    {
-        POPUPMENU *menu;
-        retvalue = get_sub_menu( win->hSysMenu, 0 );
-
-        /* Store the dummy sysmenu handle to facilitate the refresh */
-        /* of the close button if the SC_CLOSE item change */
-        menu = grab_menu_ptr( retvalue );
-        if (menu)
-        {
-            menu->hSysMenuOwner = win->hSysMenu;
-            release_menu_ptr( menu );
-        }
-    }
-
-    release_win_ptr( win );
-    return revert ? 0 : retvalue;
-}
-
-/**********************************************************************
- *           NtUserSetSystemMenu    (win32u.@)
- */
-BOOL WINAPI NtUserSetSystemMenu( HWND hwnd, HMENU menu )
-{
-    WND *win = get_win_ptr( hwnd );
-
-    if (!win || win == WND_OTHER_PROCESS || win == WND_DESKTOP) return FALSE;
-
-    if (win->hSysMenu) NtUserDestroyMenu( win->hSysMenu );
-    win->hSysMenu = user_callbacks ? user_callbacks->get_sys_menu( hwnd, menu ) : NULL;
-    release_win_ptr( win );
-    return TRUE;
-}
-
-/**********************************************************************
- *           NtUserSetMenuDefaultItem    (win32u.@)
- */
-BOOL WINAPI NtUserSetMenuDefaultItem( HMENU handle, UINT item, UINT bypos )
-{
-    MENUITEM *menu_item;
-    POPUPMENU *menu;
-    unsigned int i;
-    BOOL ret = FALSE;
-
-    TRACE( "(%p,%d,%d)\n", handle, item, bypos );
-
-    if (!(menu = grab_menu_ptr( handle ))) return FALSE;
-
-    /* reset all default-item flags */
-    menu_item = menu->items;
-    for (i = 0; i < menu->nItems; i++, menu_item++)
-    {
-        menu_item->fState &= ~MFS_DEFAULT;
-    }
-
-    if (item != -1)
-    {
-        menu_item = menu->items;
-
-        if (bypos)
-        {
-            ret = item < menu->nItems;
-            if (ret) menu->items[item].fState |= MFS_DEFAULT;
-        }
-        else
-        {
-            for (i = 0; i < menu->nItems; i++)
-            {
-                if (menu->items[i].wID == item)
-                {
-                    menu->items[i].fState |= MFS_DEFAULT;
-                    ret = TRUE;
-                }
-            }
-        }
-    }
-    else ret = TRUE;
-
-    release_menu_ptr( menu );
-    return ret;
-}
-
-/**********************************************************************
- *           translate_accelerator
- */
-static BOOL translate_accelerator( HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam,
-                                   BYTE virt, WORD key, WORD cmd )
-{
-    INT mask = 0;
-    UINT msg = 0;
-
-    if (wparam != key) return FALSE;
-
-    if (NtUserGetKeyState( VK_CONTROL ) & 0x8000) mask |= FCONTROL;
-    if (NtUserGetKeyState( VK_MENU ) & 0x8000)    mask |= FALT;
-    if (NtUserGetKeyState( VK_SHIFT ) & 0x8000)   mask |= FSHIFT;
-
-    if (message == WM_CHAR || message == WM_SYSCHAR)
-    {
-        if (!(virt & FVIRTKEY) && (mask & FALT) == (virt & FALT))
-        {
-            TRACE_(accel)( "found accel for WM_CHAR: ('%c')\n", LOWORD(wparam) & 0xff );
-            goto found;
-        }
-    }
-    else
-    {
-        if (virt & FVIRTKEY)
-        {
-            TRACE_(accel)( "found accel for virt_key %04lx (scan %04x)\n",
-                           wparam, 0xff & HIWORD(lparam) );
-
-            if (mask == (virt & (FSHIFT | FCONTROL | FALT))) goto found;
-            TRACE_(accel)( ", but incorrect SHIFT/CTRL/ALT-state\n" );
-        }
-        else
-        {
-            if (!(lparam & 0x01000000))  /* no special_key */
-            {
-                if ((virt & FALT) && (lparam & 0x20000000)) /* ALT pressed */
-                {
-                    TRACE_(accel)( "found accel for Alt-%c\n", LOWORD(wparam) & 0xff );
-                    goto found;
-                }
-            }
-        }
-    }
-    return FALSE;
-
-found:
-    if (message == WM_KEYUP || message == WM_SYSKEYUP)
-        msg = 1;
-    else
-    {
-        HMENU menu_handle, submenu, sys_menu;
-        UINT sys_stat = ~0u, stat = ~0u, pos;
-        POPUPMENU *menu;
-
-        menu_handle = (get_window_long( hwnd, GWL_STYLE ) & WS_CHILD) ? 0 : get_menu(hwnd);
-        sys_menu = get_win_sys_menu( hwnd );
-
-        /* find menu item and ask application to initialize it */
-        /* 1. in the system menu */
-        if ((menu = find_menu_item( sys_menu, cmd, MF_BYCOMMAND, NULL )))
-        {
-            submenu = menu->obj.handle;
-            release_menu_ptr( menu );
-
-            if (get_capture())
-                msg = 2;
-            if (!is_window_enabled( hwnd ))
-                msg = 3;
-            else
-            {
-                send_message( hwnd, WM_INITMENU, (WPARAM)sys_menu, 0 );
-                if (submenu != sys_menu)
-                {
-                    pos = find_submenu( &sys_menu, submenu );
-                    TRACE_(accel)( "sys_menu = %p, submenu = %p, pos = %d\n",
-                                   sys_menu, submenu, pos );
-                    send_message( hwnd, WM_INITMENUPOPUP, (WPARAM)submenu, MAKELPARAM(pos, TRUE) );
-                }
-                sys_stat = get_menu_state( get_sub_menu( sys_menu, 0 ), cmd, MF_BYCOMMAND );
-            }
-        }
-        else /* 2. in the window's menu */
-        {
-            if ((menu = find_menu_item( menu_handle, cmd, MF_BYCOMMAND, NULL )))
-            {
-                submenu = menu->obj.handle;
-                release_menu_ptr( menu );
-
-                if (get_capture())
-                    msg = 2;
-                if (!is_window_enabled( hwnd ))
-                    msg = 3;
-                else
-                {
-                    send_message( hwnd, WM_INITMENU, (WPARAM)menu_handle, 0 );
-                    if(submenu != menu_handle)
-                    {
-                        pos = find_submenu( &menu_handle, submenu );
-                        TRACE_(accel)( "menu_handle = %p, submenu = %p, pos = %d\n",
-                                       menu_handle, submenu, pos );
-                        send_message( hwnd, WM_INITMENUPOPUP, (WPARAM)submenu,
-                                      MAKELPARAM(pos, FALSE) );
-                    }
-                    stat = get_menu_state( menu_handle, cmd, MF_BYCOMMAND );
-                }
-            }
-        }
-
-        if (msg == 0)
-        {
-            if (sys_stat != ~0u)
-            {
-                if (sys_stat & (MF_DISABLED|MF_GRAYED))
-                    msg = 4;
-                else
-                    msg = WM_SYSCOMMAND;
-            }
-            else
-            {
-                if (stat != ~0u)
-                {
-                    if (is_iconic( hwnd ))
-                        msg = 5;
-                    else
-                    {
-                        if (stat & (MF_DISABLED|MF_GRAYED))
-                            msg = 6;
-                        else
-                            msg = WM_COMMAND;
-                    }
-                }
-                else
-                    msg = WM_COMMAND;
-            }
-        }
-    }
-
-    if (msg == WM_COMMAND)
-    {
-        TRACE_(accel)( ", sending WM_COMMAND, wparam=%0x\n", 0x10000 | cmd );
-        send_message( hwnd, msg, 0x10000 | cmd, 0 );
-    }
-    else if (msg == WM_SYSCOMMAND)
-    {
-        TRACE_(accel)( ", sending WM_SYSCOMMAND, wparam=%0x\n", cmd );
-        send_message( hwnd, msg, cmd, 0x00010000 );
-    }
-    else
-    {
-        /*  some reasons for NOT sending the WM_{SYS}COMMAND message:
-         *   #0: unknown (please report!)
-         *   #1: for WM_KEYUP,WM_SYSKEYUP
-         *   #2: mouse is captured
-         *   #3: window is disabled
-         *   #4: it's a disabled system menu option
-         *   #5: it's a menu option, but window is iconic
-         *   #6: it's a menu option, but disabled
-         */
-        TRACE_(accel)( ", but won't send WM_{SYS}COMMAND, reason is #%d\n", msg );
-        if (!msg) ERR_(accel)( " unknown reason\n" );
-    }
-    return TRUE;
-}
-
-/**********************************************************************
- *           NtUserTranslateAccelerator     (win32u.@)
- */
-INT WINAPI NtUserTranslateAccelerator( HWND hwnd, HACCEL accel, MSG *msg )
-{
-    ACCEL data[32], *ptr = data;
-    int i, count;
-
-    if (!hwnd) return 0;
-
-    if (msg->message != WM_KEYDOWN &&
-        msg->message != WM_SYSKEYDOWN &&
-        msg->message != WM_CHAR &&
-        msg->message != WM_SYSCHAR)
-        return 0;
-
-    TRACE_(accel)("accel %p, hwnd %p, msg->hwnd %p, msg->message %04x, wParam %08lx, lParam %08lx\n",
-                  accel,hwnd,msg->hwnd,msg->message,msg->wParam,msg->lParam);
-
-    if (!(count = NtUserCopyAcceleratorTable( accel, NULL, 0 ))) return 0;
-    if (count > ARRAY_SIZE( data ))
-    {
-        if (!(ptr = malloc( count * sizeof(*ptr) ))) return 0;
-    }
-    count = NtUserCopyAcceleratorTable( accel, ptr, count );
-    for (i = 0; i < count; i++)
-    {
-        if (translate_accelerator( hwnd, msg->message, msg->wParam, msg->lParam,
-                                   ptr[i].fVirt, ptr[i].key, ptr[i].cmd))
-            break;
-    }
-    if (ptr != data) free( ptr );
-    return (i < count);
+    return user_callbacks && user_callbacks->pDestroyMenu( menu );
 }
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index bc6db20d164..853182b6e94 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -24,2621 +24,112 @@
 #pragma makedep unix
 #endif
 
-#include <assert.h>
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
 #include "win32u_private.h"
 #include "ntuser_private.h"
-#include "hidusage.h"
-#include "dbt.h"
-#include "dde.h"
 #include "wine/server.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(msg);
-WINE_DECLARE_DEBUG_CHANNEL(key);
-WINE_DECLARE_DEBUG_CHANNEL(relay);
 
-#define MAX_WINPROC_RECURSION  64
-
-#define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
-#define WM_NCMOUSELAST  (WM_NCMOUSEFIRST+(WM_MOUSELAST-WM_MOUSEFIRST))
-
-#define MAX_PACK_COUNT 4
-
-struct packed_hook_extra_info
-{
-    user_handle_t handle;
-    DWORD         __pad;
-    ULONGLONG     lparam;
-};
-
-/* the structures are unpacked on top of the packed ones, so make sure they fit */
-C_ASSERT( sizeof(struct packed_CREATESTRUCTW) >= sizeof(CREATESTRUCTW) );
-C_ASSERT( sizeof(struct packed_DRAWITEMSTRUCT) >= sizeof(DRAWITEMSTRUCT) );
-C_ASSERT( sizeof(struct packed_MEASUREITEMSTRUCT) >= sizeof(MEASUREITEMSTRUCT) );
-C_ASSERT( sizeof(struct packed_DELETEITEMSTRUCT) >= sizeof(DELETEITEMSTRUCT) );
-C_ASSERT( sizeof(struct packed_COMPAREITEMSTRUCT) >= sizeof(COMPAREITEMSTRUCT) );
-C_ASSERT( sizeof(struct packed_WINDOWPOS) >= sizeof(WINDOWPOS) );
-C_ASSERT( sizeof(struct packed_COPYDATASTRUCT) >= sizeof(COPYDATASTRUCT) );
-C_ASSERT( sizeof(struct packed_HELPINFO) >= sizeof(HELPINFO) );
-C_ASSERT( sizeof(struct packed_NCCALCSIZE_PARAMS) >= sizeof(NCCALCSIZE_PARAMS) + sizeof(WINDOWPOS) );
-C_ASSERT( sizeof(struct packed_MSG) >= sizeof(MSG) );
-C_ASSERT( sizeof(struct packed_MDINEXTMENU) >= sizeof(MDINEXTMENU) );
-C_ASSERT( sizeof(struct packed_MDICREATESTRUCTW) >= sizeof(MDICREATESTRUCTW) );
-C_ASSERT( sizeof(struct packed_hook_extra_info) >= sizeof(struct hook_extra_info) );
-
-union packed_structs
-{
-    struct packed_CREATESTRUCTW cs;
-    struct packed_DRAWITEMSTRUCT dis;
-    struct packed_MEASUREITEMSTRUCT mis;
-    struct packed_DELETEITEMSTRUCT dls;
-    struct packed_COMPAREITEMSTRUCT cis;
-    struct packed_WINDOWPOS wp;
-    struct packed_COPYDATASTRUCT cds;
-    struct packed_HELPINFO hi;
-    struct packed_NCCALCSIZE_PARAMS ncp;
-    struct packed_MSG msg;
-    struct packed_MDINEXTMENU mnm;
-    struct packed_MDICREATESTRUCTW mcs;
-    struct packed_hook_extra_info hook;
-};
-
-/* description of the data fields that need to be packed along with a sent message */
-struct packed_message
-{
-    union packed_structs ps;
-    int                  count;
-    const void          *data[MAX_PACK_COUNT];
-    size_t               size[MAX_PACK_COUNT];
-};
-
-/* structure to group all parameters for sent messages of the various kinds */
-struct send_message_info
-{
-    enum message_type type;
-    DWORD             dest_tid;
-    HWND              hwnd;
-    UINT              msg;
-    WPARAM            wparam;
-    LPARAM            lparam;
-    UINT              flags;      /* flags for SendMessageTimeout */
-    UINT              timeout;    /* timeout for SendMessageTimeout */
-    SENDASYNCPROC     callback;   /* callback function for SendMessageCallback */
-    ULONG_PTR         data;       /* callback data */
-    enum wm_char_mapping wm_char;
-};
-
-static const INPUT_MESSAGE_SOURCE msg_source_unavailable = { IMDT_UNAVAILABLE, IMO_UNAVAILABLE };
-
-/* flag for messages that contain pointers */
-/* 32 messages per entry, messages 0..31 map to bits 0..31 */
-
-#define SET(msg) (1 << ((msg) & 31))
-
-static const unsigned int message_pointer_flags[] =
-{
-    /* 0x00 - 0x1f */
-    SET(WM_CREATE) | SET(WM_SETTEXT) | SET(WM_GETTEXT) |
-    SET(WM_WININICHANGE) | SET(WM_DEVMODECHANGE),
-    /* 0x20 - 0x3f */
-    SET(WM_GETMINMAXINFO) | SET(WM_DRAWITEM) | SET(WM_MEASUREITEM) | SET(WM_DELETEITEM) |
-    SET(WM_COMPAREITEM),
-    /* 0x40 - 0x5f */
-    SET(WM_WINDOWPOSCHANGING) | SET(WM_WINDOWPOSCHANGED) | SET(WM_COPYDATA) | SET(WM_HELP),
-    /* 0x60 - 0x7f */
-    SET(WM_STYLECHANGING) | SET(WM_STYLECHANGED),
-    /* 0x80 - 0x9f */
-    SET(WM_NCCREATE) | SET(WM_NCCALCSIZE) | SET(WM_GETDLGCODE),
-    /* 0xa0 - 0xbf */
-    SET(EM_GETSEL) | SET(EM_GETRECT) | SET(EM_SETRECT) | SET(EM_SETRECTNP),
-    /* 0xc0 - 0xdf */
-    SET(EM_REPLACESEL) | SET(EM_GETLINE) | SET(EM_SETTABSTOPS),
-    /* 0xe0 - 0xff */
-    SET(SBM_GETRANGE) | SET(SBM_SETSCROLLINFO) | SET(SBM_GETSCROLLINFO) | SET(SBM_GETSCROLLBARINFO),
-    /* 0x100 - 0x11f */
-    0,
-    /* 0x120 - 0x13f */
-    0,
-    /* 0x140 - 0x15f */
-    SET(CB_GETEDITSEL) | SET(CB_ADDSTRING) | SET(CB_DIR) | SET(CB_GETLBTEXT) |
-    SET(CB_INSERTSTRING) | SET(CB_FINDSTRING) | SET(CB_SELECTSTRING) |
-    SET(CB_GETDROPPEDCONTROLRECT) | SET(CB_FINDSTRINGEXACT),
-    /* 0x160 - 0x17f */
-    0,
-    /* 0x180 - 0x19f */
-    SET(LB_ADDSTRING) | SET(LB_INSERTSTRING) | SET(LB_GETTEXT) | SET(LB_SELECTSTRING) |
-    SET(LB_DIR) | SET(LB_FINDSTRING) |
-    SET(LB_GETSELITEMS) | SET(LB_SETTABSTOPS) | SET(LB_ADDFILE) | SET(LB_GETITEMRECT),
-    /* 0x1a0 - 0x1bf */
-    SET(LB_FINDSTRINGEXACT),
-    /* 0x1c0 - 0x1df */
-    0,
-    /* 0x1e0 - 0x1ff */
-    0,
-    /* 0x200 - 0x21f */
-    SET(WM_NEXTMENU) | SET(WM_SIZING) | SET(WM_MOVING) | SET(WM_DEVICECHANGE),
-    /* 0x220 - 0x23f */
-    SET(WM_MDICREATE) | SET(WM_MDIGETACTIVE) | SET(WM_DROPOBJECT) |
-    SET(WM_QUERYDROPOBJECT) | SET(WM_DRAGLOOP) | SET(WM_DRAGSELECT) | SET(WM_DRAGMOVE),
-    /* 0x240 - 0x25f */
-    0,
-    /* 0x260 - 0x27f */
-    0,
-    /* 0x280 - 0x29f */
-    0,
-    /* 0x2a0 - 0x2bf */
-    0,
-    /* 0x2c0 - 0x2df */
-    0,
-    /* 0x2e0 - 0x2ff */
-    0,
-    /* 0x300 - 0x31f */
-    SET(WM_ASKCBFORMATNAME)
-};
-
-/* check whether a given message type includes pointers */
-static inline BOOL is_pointer_message( UINT message, WPARAM wparam )
-{
-    if (message >= 8*sizeof(message_pointer_flags)) return FALSE;
-    if (message == WM_DEVICECHANGE && !(wparam & 0x8000)) return FALSE;
-    return (message_pointer_flags[message / 32] & SET(message)) != 0;
-}
-
-#undef SET
-
-static BOOL init_win_proc_params( struct win_proc_params *params, HWND hwnd, UINT msg,
-                                  WPARAM wparam, LPARAM lparam, BOOL ansi )
-{
-    if (!params->func) return FALSE;
-
-    user_check_not_lock();
-
-    params->hwnd = get_full_window_handle( hwnd );
-    params->msg = msg;
-    params->wparam = wparam;
-    params->lparam = lparam;
-    params->ansi = params->ansi_dst = ansi;
-    params->is_dialog = FALSE;
-    params->needs_unpack = FALSE;
-    params->mapping = WMCHAR_MAP_CALLWINDOWPROC;
-    params->dpi_awareness = get_window_dpi_awareness_context( params->hwnd );
-    get_winproc_params( params );
-    return TRUE;
-}
-
-static BOOL init_window_call_params( struct win_proc_params *params, HWND hwnd, UINT msg, WPARAM wParam,
-                                     LPARAM lParam, LRESULT *result, BOOL ansi,
-                                     enum wm_char_mapping mapping )
-{
-    WND *win;
-
-    user_check_not_lock();
-
-    if (!(win = get_win_ptr( hwnd ))) return FALSE;
-    if (win == WND_OTHER_PROCESS || win == WND_DESKTOP) return FALSE;
-    if (win->tid != GetCurrentThreadId())
-    {
-        release_win_ptr( win );
-        return FALSE;
-    }
-    params->func = win->winproc;
-    params->ansi_dst = !(win->flags & WIN_ISUNICODE);
-    params->is_dialog = win->dlgInfo != NULL;
-    release_win_ptr( win );
-
-    params->hwnd = get_full_window_handle( hwnd );
-    get_winproc_params( params );
-    params->msg = msg;
-    params->wparam = wParam;
-    params->lparam = lParam;
-    params->result = result;
-    params->ansi = ansi;
-    params->needs_unpack = FALSE;
-    params->mapping = mapping;
-    params->dpi_awareness = get_window_dpi_awareness_context( params->hwnd );
-    return TRUE;
-}
-
-static BOOL dispatch_win_proc_params( struct win_proc_params *params, size_t size )
-{
-    struct user_thread_info *thread_info = get_user_thread_info();
-    void *ret_ptr;
-    ULONG ret_len;
-
-    if (thread_info->recursion_count > MAX_WINPROC_RECURSION) return FALSE;
-    thread_info->recursion_count++;
-
-    KeUserModeCallback( NtUserCallWinProc, params, size, &ret_ptr, &ret_len );
-
-    thread_info->recursion_count--;
-    return TRUE;
-}
-
-/* add a data field to a packed message */
-static inline void push_data( struct packed_message *data, const void *ptr, size_t size )
-{
-    data->data[data->count] = ptr;
-    data->size[data->count] = size;
-    data->count++;
-}
-
-/* pack a pointer into a 32/64 portable format */
-static inline ULONGLONG pack_ptr( const void *ptr )
-{
-    return (ULONG_PTR)ptr;
-}
-
-/* unpack a potentially 64-bit pointer, returning 0 when truncated */
-static inline void *unpack_ptr( ULONGLONG ptr64 )
-{
-    if ((ULONG_PTR)ptr64 != ptr64) return 0;
-    return (void *)(ULONG_PTR)ptr64;
-}
-
-/* add a string to a packed message */
-static inline void push_string( struct packed_message *data, LPCWSTR str )
-{
-    push_data( data, str, (lstrlenW(str) + 1) * sizeof(WCHAR) );
-}
-
-/* check whether a combobox expects strings or ids in CB_ADDSTRING/CB_INSERTSTRING */
-static inline BOOL combobox_has_strings( HWND hwnd )
-{
-    DWORD style = get_window_long( hwnd, GWL_STYLE );
-    return (!(style & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)) || (style & CBS_HASSTRINGS));
-}
-
-/* check whether a listbox expects strings or ids in LB_ADDSTRING/LB_INSERTSTRING */
-static inline BOOL listbox_has_strings( HWND hwnd )
-{
-    DWORD style = get_window_long( hwnd, GWL_STYLE );
-    return (!(style & (LBS_OWNERDRAWFIXED | LBS_OWNERDRAWVARIABLE)) || (style & LBS_HASSTRINGS));
-}
-
-/* check whether message is in the range of keyboard messages */
-static inline BOOL is_keyboard_message( UINT message )
-{
-    return (message >= WM_KEYFIRST && message <= WM_KEYLAST);
-}
-
-/* check whether message is in the range of mouse messages */
-static inline BOOL is_mouse_message( UINT message )
-{
-    return ((message >= WM_NCMOUSEFIRST && message <= WM_NCMOUSELAST) ||
-            (message >= WM_MOUSEFIRST && message <= WM_MOUSELAST));
-}
-
-/* check whether message matches the specified hwnd filter */
-static inline BOOL check_hwnd_filter( const MSG *msg, HWND hwnd_filter )
-{
-    if (!hwnd_filter || hwnd_filter == get_desktop_window()) return TRUE;
-    return (msg->hwnd == hwnd_filter || is_child( hwnd_filter, msg->hwnd ));
-}
-
-/***********************************************************************
- *           unpack_message
- *
- * Unpack a message received from another process.
- */
-static BOOL unpack_message( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lparam,
-                            void **buffer, size_t size )
-{
-    size_t minsize = 0;
-    union packed_structs *ps = *buffer;
-
-    switch(message)
-    {
-    case WM_WINE_SETWINDOWPOS:
-    {
-        WINDOWPOS wp;
-        if (size < sizeof(ps->wp)) return FALSE;
-        wp.hwnd            = wine_server_ptr_handle( ps->wp.hwnd );
-        wp.hwndInsertAfter = wine_server_ptr_handle( ps->wp.hwndInsertAfter );
-        wp.x               = ps->wp.x;
-        wp.y               = ps->wp.y;
-        wp.cx              = ps->wp.cx;
-        wp.cy              = ps->wp.cy;
-        wp.flags           = ps->wp.flags;
-        memcpy( &ps->wp, &wp, sizeof(wp) );
-        break;
-    }
-    case WM_WINE_KEYBOARD_LL_HOOK:
-    case WM_WINE_MOUSE_LL_HOOK:
-    {
-        struct hook_extra_info h_extra;
-        minsize = sizeof(ps->hook) +
-                  (message == WM_WINE_KEYBOARD_LL_HOOK ? sizeof(KBDLLHOOKSTRUCT)
-                                                       : sizeof(MSLLHOOKSTRUCT));
-        if (size < minsize) return FALSE;
-        h_extra.handle = wine_server_ptr_handle( ps->hook.handle );
-        h_extra.lparam = (LPARAM)(&ps->hook + 1);
-        memcpy( &ps->hook, &h_extra, sizeof(h_extra) );
-        break;
-    }
-    default:
-        return TRUE;  /* message doesn't need any unpacking */
-    }
-
-    /* default exit for most messages: check minsize and store buffer in lparam */
-    if (size < minsize) return FALSE;
-    *lparam = (LPARAM)*buffer;
-    return TRUE;
-}
-
-/***********************************************************************
- *           pack_message
- *
- * Pack a message for sending to another process.
- * Return the size of the data we expect in the message reply.
- * Set data->count to -1 if there is an error.
- */
-static size_t pack_message( HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam,
-                            struct packed_message *data )
-{
-    data->count = 0;
-    switch(message)
-    {
-    case WM_NCCREATE:
-    case WM_CREATE:
-    {
-        CREATESTRUCTW *cs = (CREATESTRUCTW *)lparam;
-        data->ps.cs.lpCreateParams = pack_ptr( cs->lpCreateParams );
-        data->ps.cs.hInstance      = pack_ptr( cs->hInstance );
-        data->ps.cs.hMenu          = wine_server_user_handle( cs->hMenu );
-        data->ps.cs.hwndParent     = wine_server_user_handle( cs->hwndParent );
-        data->ps.cs.cy             = cs->cy;
-        data->ps.cs.cx             = cs->cx;
-        data->ps.cs.y              = cs->y;
-        data->ps.cs.x              = cs->x;
-        data->ps.cs.style          = cs->style;
-        data->ps.cs.dwExStyle      = cs->dwExStyle;
-        data->ps.cs.lpszName       = pack_ptr( cs->lpszName );
-        data->ps.cs.lpszClass      = pack_ptr( cs->lpszClass );
-        push_data( data, &data->ps.cs, sizeof(data->ps.cs) );
-        if (!IS_INTRESOURCE(cs->lpszName)) push_string( data, cs->lpszName );
-        if (!IS_INTRESOURCE(cs->lpszClass)) push_string( data, cs->lpszClass );
-        return sizeof(data->ps.cs);
-    }
-    case WM_GETTEXT:
-    case WM_ASKCBFORMATNAME:
-        return wparam * sizeof(WCHAR);
-    case WM_WININICHANGE:
-        if (lparam) push_string(data, (LPWSTR)lparam );
-        return 0;
-    case WM_SETTEXT:
-    case WM_DEVMODECHANGE:
-    case CB_DIR:
-    case LB_DIR:
-    case LB_ADDFILE:
-    case EM_REPLACESEL:
-        push_string( data, (LPWSTR)lparam );
-        return 0;
-    case WM_GETMINMAXINFO:
-        push_data( data, (MINMAXINFO *)lparam, sizeof(MINMAXINFO) );
-        return sizeof(MINMAXINFO);
-    case WM_DRAWITEM:
-    {
-        DRAWITEMSTRUCT *dis = (DRAWITEMSTRUCT *)lparam;
-        data->ps.dis.CtlType    = dis->CtlType;
-        data->ps.dis.CtlID      = dis->CtlID;
-        data->ps.dis.itemID     = dis->itemID;
-        data->ps.dis.itemAction = dis->itemAction;
-        data->ps.dis.itemState  = dis->itemState;
-        data->ps.dis.hwndItem   = wine_server_user_handle( dis->hwndItem );
-        data->ps.dis.hDC        = wine_server_user_handle( dis->hDC );  /* FIXME */
-        data->ps.dis.rcItem     = dis->rcItem;
-        data->ps.dis.itemData   = dis->itemData;
-        push_data( data, &data->ps.dis, sizeof(data->ps.dis) );
-        return 0;
-    }
-    case WM_MEASUREITEM:
-    {
-        MEASUREITEMSTRUCT *mis = (MEASUREITEMSTRUCT *)lparam;
-        data->ps.mis.CtlType    = mis->CtlType;
-        data->ps.mis.CtlID      = mis->CtlID;
-        data->ps.mis.itemID     = mis->itemID;
-        data->ps.mis.itemWidth  = mis->itemWidth;
-        data->ps.mis.itemHeight = mis->itemHeight;
-        data->ps.mis.itemData   = mis->itemData;
-        push_data( data, &data->ps.mis, sizeof(data->ps.mis) );
-        return sizeof(data->ps.mis);
-    }
-    case WM_DELETEITEM:
-    {
-        DELETEITEMSTRUCT *dls = (DELETEITEMSTRUCT *)lparam;
-        data->ps.dls.CtlType    = dls->CtlType;
-        data->ps.dls.CtlID      = dls->CtlID;
-        data->ps.dls.itemID     = dls->itemID;
-        data->ps.dls.hwndItem   = wine_server_user_handle( dls->hwndItem );
-        data->ps.dls.itemData   = dls->itemData;
-        push_data( data, &data->ps.dls, sizeof(data->ps.dls) );
-        return 0;
-    }
-    case WM_COMPAREITEM:
-    {
-        COMPAREITEMSTRUCT *cis = (COMPAREITEMSTRUCT *)lparam;
-        data->ps.cis.CtlType    = cis->CtlType;
-        data->ps.cis.CtlID      = cis->CtlID;
-        data->ps.cis.hwndItem   = wine_server_user_handle( cis->hwndItem );
-        data->ps.cis.itemID1    = cis->itemID1;
-        data->ps.cis.itemData1  = cis->itemData1;
-        data->ps.cis.itemID2    = cis->itemID2;
-        data->ps.cis.itemData2  = cis->itemData2;
-        data->ps.cis.dwLocaleId = cis->dwLocaleId;
-        push_data( data, &data->ps.cis, sizeof(data->ps.cis) );
-        return 0;
-    }
-    case WM_WINE_SETWINDOWPOS:
-    case WM_WINDOWPOSCHANGING:
-    case WM_WINDOWPOSCHANGED:
-    {
-        WINDOWPOS *wp = (WINDOWPOS *)lparam;
-        data->ps.wp.hwnd            = wine_server_user_handle( wp->hwnd );
-        data->ps.wp.hwndInsertAfter = wine_server_user_handle( wp->hwndInsertAfter );
-        data->ps.wp.x               = wp->x;
-        data->ps.wp.y               = wp->y;
-        data->ps.wp.cx              = wp->cx;
-        data->ps.wp.cy              = wp->cy;
-        data->ps.wp.flags           = wp->flags;
-        push_data( data, &data->ps.wp, sizeof(data->ps.wp) );
-        return sizeof(data->ps.wp);
-    }
-    case WM_COPYDATA:
-    {
-        COPYDATASTRUCT *cds = (COPYDATASTRUCT *)lparam;
-        data->ps.cds.cbData = cds->cbData;
-        data->ps.cds.dwData = cds->dwData;
-        data->ps.cds.lpData = pack_ptr( cds->lpData );
-        push_data( data, &data->ps.cds, sizeof(data->ps.cds) );
-        if (cds->lpData) push_data( data, cds->lpData, cds->cbData );
-        return 0;
-    }
-    case WM_NOTIFY:
-        /* WM_NOTIFY cannot be sent across processes (MSDN) */
-        data->count = -1;
-        return 0;
-    case WM_HELP:
-    {
-        HELPINFO *hi = (HELPINFO *)lparam;
-        data->ps.hi.iContextType = hi->iContextType;
-        data->ps.hi.iCtrlId      = hi->iCtrlId;
-        data->ps.hi.hItemHandle  = wine_server_user_handle( hi->hItemHandle );
-        data->ps.hi.dwContextId  = hi->dwContextId;
-        data->ps.hi.MousePos     = hi->MousePos;
-        push_data( data, &data->ps.hi, sizeof(data->ps.hi) );
-        return 0;
-    }
-    case WM_STYLECHANGING:
-    case WM_STYLECHANGED:
-        push_data( data, (STYLESTRUCT *)lparam, sizeof(STYLESTRUCT) );
-        return 0;
-    case WM_NCCALCSIZE:
-        if (!wparam)
-        {
-            push_data( data, (RECT *)lparam, sizeof(RECT) );
-            return sizeof(RECT);
-        }
-        else
-        {
-            NCCALCSIZE_PARAMS *ncp = (NCCALCSIZE_PARAMS *)lparam;
-            data->ps.ncp.rgrc[0]         = ncp->rgrc[0];
-            data->ps.ncp.rgrc[1]         = ncp->rgrc[1];
-            data->ps.ncp.rgrc[2]         = ncp->rgrc[2];
-            data->ps.ncp.hwnd            = wine_server_user_handle( ncp->lppos->hwnd );
-            data->ps.ncp.hwndInsertAfter = wine_server_user_handle( ncp->lppos->hwndInsertAfter );
-            data->ps.ncp.x               = ncp->lppos->x;
-            data->ps.ncp.y               = ncp->lppos->y;
-            data->ps.ncp.cx              = ncp->lppos->cx;
-            data->ps.ncp.cy              = ncp->lppos->cy;
-            data->ps.ncp.flags           = ncp->lppos->flags;
-            push_data( data, &data->ps.ncp, sizeof(data->ps.ncp) );
-            return sizeof(data->ps.ncp);
-        }
-    case WM_GETDLGCODE:
-        if (lparam)
-        {
-            MSG *msg = (MSG *)lparam;
-            data->ps.msg.hwnd    = wine_server_user_handle( msg->hwnd );
-            data->ps.msg.message = msg->message;
-            data->ps.msg.wParam  = msg->wParam;
-            data->ps.msg.lParam  = msg->lParam;
-            data->ps.msg.time    = msg->time;
-            data->ps.msg.pt      = msg->pt;
-            push_data( data, &data->ps.msg, sizeof(data->ps.msg) );
-            return sizeof(data->ps.msg);
-        }
-        return 0;
-    case SBM_SETSCROLLINFO:
-        push_data( data, (SCROLLINFO *)lparam, sizeof(SCROLLINFO) );
-        return 0;
-    case SBM_GETSCROLLINFO:
-        push_data( data, (SCROLLINFO *)lparam, sizeof(SCROLLINFO) );
-        return sizeof(SCROLLINFO);
-    case SBM_GETSCROLLBARINFO:
-    {
-        const SCROLLBARINFO *info = (const SCROLLBARINFO *)lparam;
-        size_t size = min( info->cbSize, sizeof(SCROLLBARINFO) );
-        push_data( data, info, size );
-        return size;
-    }
-    case EM_GETSEL:
-    case SBM_GETRANGE:
-    case CB_GETEDITSEL:
-    {
-        size_t size = 0;
-        if (wparam) size += sizeof(DWORD);
-        if (lparam) size += sizeof(DWORD);
-        return size;
-    }
-    case EM_GETRECT:
-    case LB_GETITEMRECT:
-    case CB_GETDROPPEDCONTROLRECT:
-        return sizeof(RECT);
-    case EM_SETRECT:
-    case EM_SETRECTNP:
-        push_data( data, (RECT *)lparam, sizeof(RECT) );
-        return 0;
-    case EM_GETLINE:
-    {
-        WORD *pw = (WORD *)lparam;
-        push_data( data, pw, sizeof(*pw) );
-        return *pw * sizeof(WCHAR);
-    }
-    case EM_SETTABSTOPS:
-    case LB_SETTABSTOPS:
-        if (wparam) push_data( data, (UINT *)lparam, sizeof(UINT) * wparam );
-        return 0;
-    case CB_ADDSTRING:
-    case CB_INSERTSTRING:
-    case CB_FINDSTRING:
-    case CB_FINDSTRINGEXACT:
-    case CB_SELECTSTRING:
-        if (combobox_has_strings( hwnd )) push_string( data, (LPWSTR)lparam );
-        return 0;
-    case CB_GETLBTEXT:
-        if (!combobox_has_strings( hwnd )) return sizeof(ULONG_PTR);
-        return (send_message( hwnd, CB_GETLBTEXTLEN, wparam, 0 ) + 1) * sizeof(WCHAR);
-    case LB_ADDSTRING:
-    case LB_INSERTSTRING:
-    case LB_FINDSTRING:
-    case LB_FINDSTRINGEXACT:
-    case LB_SELECTSTRING:
-        if (listbox_has_strings( hwnd )) push_string( data, (LPWSTR)lparam );
-        return 0;
-    case LB_GETTEXT:
-        if (!listbox_has_strings( hwnd )) return sizeof(ULONG_PTR);
-        return (send_message( hwnd, LB_GETTEXTLEN, wparam, 0 ) + 1) * sizeof(WCHAR);
-    case LB_GETSELITEMS:
-        return wparam * sizeof(UINT);
-    case WM_NEXTMENU:
-    {
-        MDINEXTMENU *mnm = (MDINEXTMENU *)lparam;
-        data->ps.mnm.hmenuIn   = wine_server_user_handle( mnm->hmenuIn );
-        data->ps.mnm.hmenuNext = wine_server_user_handle( mnm->hmenuNext );
-        data->ps.mnm.hwndNext  = wine_server_user_handle( mnm->hwndNext );
-        push_data( data, &data->ps.mnm, sizeof(data->ps.mnm) );
-        return sizeof(data->ps.mnm);
-    }
-    case WM_SIZING:
-    case WM_MOVING:
-        push_data( data, (RECT *)lparam, sizeof(RECT) );
-        return sizeof(RECT);
-    case WM_MDICREATE:
-    {
-        MDICREATESTRUCTW *mcs = (MDICREATESTRUCTW *)lparam;
-        data->ps.mcs.szClass = pack_ptr( mcs->szClass );
-        data->ps.mcs.szTitle = pack_ptr( mcs->szTitle );
-        data->ps.mcs.hOwner  = pack_ptr( mcs->hOwner );
-        data->ps.mcs.x       = mcs->x;
-        data->ps.mcs.y       = mcs->y;
-        data->ps.mcs.cx      = mcs->cx;
-        data->ps.mcs.cy      = mcs->cy;
-        data->ps.mcs.style   = mcs->style;
-        data->ps.mcs.lParam  = mcs->lParam;
-        push_data( data, &data->ps.mcs, sizeof(data->ps.mcs) );
-        if (!IS_INTRESOURCE(mcs->szClass)) push_string( data, mcs->szClass );
-        if (!IS_INTRESOURCE(mcs->szTitle)) push_string( data, mcs->szTitle );
-        return sizeof(data->ps.mcs);
-    }
-    case WM_MDIGETACTIVE:
-        if (lparam) return sizeof(BOOL);
-        return 0;
-    case WM_DEVICECHANGE:
-    {
-        DEV_BROADCAST_HDR *header = (DEV_BROADCAST_HDR *)lparam;
-        if ((wparam & 0x8000) && header) push_data( data, header, header->dbch_size );
-        return 0;
-    }
-    case WM_WINE_KEYBOARD_LL_HOOK:
-    {
-        struct hook_extra_info *h_extra = (struct hook_extra_info *)lparam;
-        data->ps.hook.handle = wine_server_user_handle( h_extra->handle );
-        push_data( data, &data->ps.hook, sizeof(data->ps.hook) );
-        push_data( data, (LPVOID)h_extra->lparam, sizeof(KBDLLHOOKSTRUCT) );
-        return 0;
-    }
-    case WM_WINE_MOUSE_LL_HOOK:
-    {
-        struct hook_extra_info *h_extra = (struct hook_extra_info *)lparam;
-        data->ps.hook.handle = wine_server_user_handle( h_extra->handle );
-        push_data( data, &data->ps.hook, sizeof(data->ps.hook) );
-        push_data( data, (LPVOID)h_extra->lparam, sizeof(MSLLHOOKSTRUCT) );
-        return 0;
-    }
-    case WM_NCPAINT:
-        if (wparam <= 1) return 0;
-        FIXME( "WM_NCPAINT hdc packing not supported yet\n" );
-        data->count = -1;
-        return 0;
-    case WM_PAINT:
-        if (!wparam) return 0;
-        /* fall through */
-
-    /* these contain an HFONT */
-    case WM_SETFONT:
-    case WM_GETFONT:
-    /* these contain an HDC */
-    case WM_ERASEBKGND:
-    case WM_ICONERASEBKGND:
-    case WM_CTLCOLORMSGBOX:
-    case WM_CTLCOLOREDIT:
-    case WM_CTLCOLORLISTBOX:
-    case WM_CTLCOLORBTN:
-    case WM_CTLCOLORDLG:
-    case WM_CTLCOLORSCROLLBAR:
-    case WM_CTLCOLORSTATIC:
-    case WM_PRINT:
-    case WM_PRINTCLIENT:
-    /* these contain an HGLOBAL */
-    case WM_PAINTCLIPBOARD:
-    case WM_SIZECLIPBOARD:
-    /* these contain HICON */
-    case WM_GETICON:
-    case WM_SETICON:
-    case WM_QUERYDRAGICON:
-    case WM_QUERYPARKICON:
-    /* these contain pointers */
-    case WM_DROPOBJECT:
-    case WM_QUERYDROPOBJECT:
-    case WM_DRAGLOOP:
-    case WM_DRAGSELECT:
-    case WM_DRAGMOVE:
-        FIXME( "msg %x (%s) not supported yet\n", message, debugstr_msg_name(message, hwnd) );
-        data->count = -1;
-        return 0;
-    }
-    return 0;
-}
-
-/***********************************************************************
- *           pack_reply
- *
- * Pack a reply to a message for sending to another process.
- */
-static void pack_reply( HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam,
-                        LRESULT res, struct packed_message *data )
-{
-    data->count = 0;
-    switch(message)
-    {
-    case WM_NCCREATE:
-    case WM_CREATE:
-    {
-        CREATESTRUCTW *cs = (CREATESTRUCTW *)lparam;
-        data->ps.cs.lpCreateParams = (ULONG_PTR)cs->lpCreateParams;
-        data->ps.cs.hInstance      = (ULONG_PTR)cs->hInstance;
-        data->ps.cs.hMenu          = wine_server_user_handle( cs->hMenu );
-        data->ps.cs.hwndParent     = wine_server_user_handle( cs->hwndParent );
-        data->ps.cs.cy             = cs->cy;
-        data->ps.cs.cx             = cs->cx;
-        data->ps.cs.y              = cs->y;
-        data->ps.cs.x              = cs->x;
-        data->ps.cs.style          = cs->style;
-        data->ps.cs.dwExStyle      = cs->dwExStyle;
-        data->ps.cs.lpszName       = (ULONG_PTR)cs->lpszName;
-        data->ps.cs.lpszClass      = (ULONG_PTR)cs->lpszClass;
-        push_data( data, &data->ps.cs, sizeof(data->ps.cs) );
-        break;
-    }
-    case WM_GETTEXT:
-    case CB_GETLBTEXT:
-    case LB_GETTEXT:
-        push_data( data, (WCHAR *)lparam, (res + 1) * sizeof(WCHAR) );
-        break;
-    case WM_GETMINMAXINFO:
-        push_data( data, (MINMAXINFO *)lparam, sizeof(MINMAXINFO) );
-        break;
-    case WM_MEASUREITEM:
-    {
-        MEASUREITEMSTRUCT *mis = (MEASUREITEMSTRUCT *)lparam;
-        data->ps.mis.CtlType    = mis->CtlType;
-        data->ps.mis.CtlID      = mis->CtlID;
-        data->ps.mis.itemID     = mis->itemID;
-        data->ps.mis.itemWidth  = mis->itemWidth;
-        data->ps.mis.itemHeight = mis->itemHeight;
-        data->ps.mis.itemData   = mis->itemData;
-        push_data( data, &data->ps.mis, sizeof(data->ps.mis) );
-        break;
-    }
-    case WM_WINDOWPOSCHANGING:
-    case WM_WINDOWPOSCHANGED:
-    {
-        WINDOWPOS *wp = (WINDOWPOS *)lparam;
-        data->ps.wp.hwnd            = wine_server_user_handle( wp->hwnd );
-        data->ps.wp.hwndInsertAfter = wine_server_user_handle( wp->hwndInsertAfter );
-        data->ps.wp.x               = wp->x;
-        data->ps.wp.y               = wp->y;
-        data->ps.wp.cx              = wp->cx;
-        data->ps.wp.cy              = wp->cy;
-        data->ps.wp.flags           = wp->flags;
-        push_data( data, &data->ps.wp, sizeof(data->ps.wp) );
-        break;
-    }
-    case WM_GETDLGCODE:
-        if (lparam)
-        {
-            MSG *msg = (MSG *)lparam;
-            data->ps.msg.hwnd    = wine_server_user_handle( msg->hwnd );
-            data->ps.msg.message = msg->message;
-            data->ps.msg.wParam  = msg->wParam;
-            data->ps.msg.lParam  = msg->lParam;
-            data->ps.msg.time    = msg->time;
-            data->ps.msg.pt      = msg->pt;
-            push_data( data, &data->ps.msg, sizeof(data->ps.msg) );
-        }
-        break;
-    case SBM_GETSCROLLINFO:
-        push_data( data, (SCROLLINFO *)lparam, sizeof(SCROLLINFO) );
-        break;
-    case EM_GETRECT:
-    case LB_GETITEMRECT:
-    case CB_GETDROPPEDCONTROLRECT:
-    case WM_SIZING:
-    case WM_MOVING:
-        push_data( data, (RECT *)lparam, sizeof(RECT) );
-        break;
-    case EM_GETLINE:
-    {
-        WORD *ptr = (WORD *)lparam;
-        push_data( data, ptr, ptr[-1] * sizeof(WCHAR) );
-        break;
-    }
-    case LB_GETSELITEMS:
-        push_data( data, (UINT *)lparam, wparam * sizeof(UINT) );
-        break;
-    case WM_MDIGETACTIVE:
-        if (lparam) push_data( data, (BOOL *)lparam, sizeof(BOOL) );
-        break;
-    case WM_NCCALCSIZE:
-        if (!wparam)
-            push_data( data, (RECT *)lparam, sizeof(RECT) );
-        else
-        {
-            NCCALCSIZE_PARAMS *ncp = (NCCALCSIZE_PARAMS *)lparam;
-            data->ps.ncp.rgrc[0]         = ncp->rgrc[0];
-            data->ps.ncp.rgrc[1]         = ncp->rgrc[1];
-            data->ps.ncp.rgrc[2]         = ncp->rgrc[2];
-            data->ps.ncp.hwnd            = wine_server_user_handle( ncp->lppos->hwnd );
-            data->ps.ncp.hwndInsertAfter = wine_server_user_handle( ncp->lppos->hwndInsertAfter );
-            data->ps.ncp.x               = ncp->lppos->x;
-            data->ps.ncp.y               = ncp->lppos->y;
-            data->ps.ncp.cx              = ncp->lppos->cx;
-            data->ps.ncp.cy              = ncp->lppos->cy;
-            data->ps.ncp.flags           = ncp->lppos->flags;
-            push_data( data, &data->ps.ncp, sizeof(data->ps.ncp) );
-        }
-        break;
-    case EM_GETSEL:
-    case SBM_GETRANGE:
-    case CB_GETEDITSEL:
-        if (wparam) push_data( data, (DWORD *)wparam, sizeof(DWORD) );
-        if (lparam) push_data( data, (DWORD *)lparam, sizeof(DWORD) );
-        break;
-    case WM_NEXTMENU:
-    {
-        MDINEXTMENU *mnm = (MDINEXTMENU *)lparam;
-        data->ps.mnm.hmenuIn   = wine_server_user_handle( mnm->hmenuIn );
-        data->ps.mnm.hmenuNext = wine_server_user_handle( mnm->hmenuNext );
-        data->ps.mnm.hwndNext  = wine_server_user_handle( mnm->hwndNext );
-        push_data( data, &data->ps.mnm, sizeof(data->ps.mnm) );
-        break;
-    }
-    case WM_MDICREATE:
-    {
-        MDICREATESTRUCTW *mcs = (MDICREATESTRUCTW *)lparam;
-        data->ps.mcs.szClass = pack_ptr( mcs->szClass );
-        data->ps.mcs.szTitle = pack_ptr( mcs->szTitle );
-        data->ps.mcs.hOwner  = pack_ptr( mcs->hOwner );
-        data->ps.mcs.x       = mcs->x;
-        data->ps.mcs.y       = mcs->y;
-        data->ps.mcs.cx      = mcs->cx;
-        data->ps.mcs.cy      = mcs->cy;
-        data->ps.mcs.style   = mcs->style;
-        data->ps.mcs.lParam  = mcs->lParam;
-        push_data( data, &data->ps.mcs, sizeof(data->ps.mcs) );
-        break;
-    }
-    case WM_ASKCBFORMATNAME:
-        push_data( data, (WCHAR *)lparam, (lstrlenW((WCHAR *)lparam) + 1) * sizeof(WCHAR) );
-        break;
-    }
-}
-
-/***********************************************************************
- *           unpack_reply
- *
- * Unpack a message reply received from another process.
- */
-static void unpack_reply( HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam,
-                          void *buffer, size_t size )
-{
-    union packed_structs *ps = buffer;
-
-    switch(message)
-    {
-    case WM_NCCREATE:
-    case WM_CREATE:
-        if (size >= sizeof(ps->cs))
-        {
-            CREATESTRUCTW *cs = (CREATESTRUCTW *)lparam;
-            cs->lpCreateParams = unpack_ptr( ps->cs.lpCreateParams );
-            cs->hInstance      = unpack_ptr( ps->cs.hInstance );
-            cs->hMenu          = wine_server_ptr_handle( ps->cs.hMenu );
-            cs->hwndParent     = wine_server_ptr_handle( ps->cs.hwndParent );
-            cs->cy             = ps->cs.cy;
-            cs->cx             = ps->cs.cx;
-            cs->y              = ps->cs.y;
-            cs->x              = ps->cs.x;
-            cs->style          = ps->cs.style;
-            cs->dwExStyle      = ps->cs.dwExStyle;
-            /* don't allow changing name and class pointers */
-        }
-        break;
-    case WM_GETTEXT:
-    case WM_ASKCBFORMATNAME:
-        memcpy( (WCHAR *)lparam, buffer, min( wparam*sizeof(WCHAR), size ));
-        break;
-    case WM_GETMINMAXINFO:
-        memcpy( (MINMAXINFO *)lparam, buffer, min( sizeof(MINMAXINFO), size ));
-        break;
-    case WM_MEASUREITEM:
-        if (size >= sizeof(ps->mis))
-        {
-            MEASUREITEMSTRUCT *mis = (MEASUREITEMSTRUCT *)lparam;
-            mis->CtlType    = ps->mis.CtlType;
-            mis->CtlID      = ps->mis.CtlID;
-            mis->itemID     = ps->mis.itemID;
-            mis->itemWidth  = ps->mis.itemWidth;
-            mis->itemHeight = ps->mis.itemHeight;
-            mis->itemData   = (ULONG_PTR)unpack_ptr( ps->mis.itemData );
-        }
-        break;
-    case WM_WINDOWPOSCHANGING:
-    case WM_WINDOWPOSCHANGED:
-        if (size >= sizeof(ps->wp))
-        {
-            WINDOWPOS *wp = (WINDOWPOS *)lparam;
-            wp->hwnd            = wine_server_ptr_handle( ps->wp.hwnd );
-            wp->hwndInsertAfter = wine_server_ptr_handle( ps->wp.hwndInsertAfter );
-            wp->x               = ps->wp.x;
-            wp->y               = ps->wp.y;
-            wp->cx              = ps->wp.cx;
-            wp->cy              = ps->wp.cy;
-            wp->flags           = ps->wp.flags;
-        }
-        break;
-    case WM_GETDLGCODE:
-        if (lparam && size >= sizeof(ps->msg))
-        {
-            MSG *msg = (MSG *)lparam;
-            msg->hwnd    = wine_server_ptr_handle( ps->msg.hwnd );
-            msg->message = ps->msg.message;
-            msg->wParam  = (ULONG_PTR)unpack_ptr( ps->msg.wParam );
-            msg->lParam  = (ULONG_PTR)unpack_ptr( ps->msg.lParam );
-            msg->time    = ps->msg.time;
-            msg->pt      = ps->msg.pt;
-        }
-        break;
-    case SBM_GETSCROLLINFO:
-        memcpy( (SCROLLINFO *)lparam, buffer, min( sizeof(SCROLLINFO), size ));
-        break;
-    case SBM_GETSCROLLBARINFO:
-        memcpy( (SCROLLBARINFO *)lparam, buffer, min( sizeof(SCROLLBARINFO), size ));
-        break;
-    case EM_GETRECT:
-    case CB_GETDROPPEDCONTROLRECT:
-    case LB_GETITEMRECT:
-    case WM_SIZING:
-    case WM_MOVING:
-        memcpy( (RECT *)lparam, buffer, min( sizeof(RECT), size ));
-        break;
-    case EM_GETLINE:
-        size = min( size, (size_t)*(WORD *)lparam );
-        memcpy( (WCHAR *)lparam, buffer, size );
-        break;
-    case LB_GETSELITEMS:
-        memcpy( (UINT *)lparam, buffer, min( wparam*sizeof(UINT), size ));
-        break;
-    case LB_GETTEXT:
-    case CB_GETLBTEXT:
-        memcpy( (WCHAR *)lparam, buffer, size );
-        break;
-    case WM_NEXTMENU:
-        if (size >= sizeof(ps->mnm))
-        {
-            MDINEXTMENU *mnm = (MDINEXTMENU *)lparam;
-            mnm->hmenuIn   = wine_server_ptr_handle( ps->mnm.hmenuIn );
-            mnm->hmenuNext = wine_server_ptr_handle( ps->mnm.hmenuNext );
-            mnm->hwndNext  = wine_server_ptr_handle( ps->mnm.hwndNext );
-        }
-        break;
-    case WM_MDIGETACTIVE:
-        if (lparam) memcpy( (BOOL *)lparam, buffer, min( sizeof(BOOL), size ));
-        break;
-    case WM_NCCALCSIZE:
-        if (!wparam)
-            memcpy( (RECT *)lparam, buffer, min( sizeof(RECT), size ));
-        else if (size >= sizeof(ps->ncp))
-        {
-            NCCALCSIZE_PARAMS *ncp = (NCCALCSIZE_PARAMS *)lparam;
-            ncp->rgrc[0]                = ps->ncp.rgrc[0];
-            ncp->rgrc[1]                = ps->ncp.rgrc[1];
-            ncp->rgrc[2]                = ps->ncp.rgrc[2];
-            ncp->lppos->hwnd            = wine_server_ptr_handle( ps->ncp.hwnd );
-            ncp->lppos->hwndInsertAfter = wine_server_ptr_handle( ps->ncp.hwndInsertAfter );
-            ncp->lppos->x               = ps->ncp.x;
-            ncp->lppos->y               = ps->ncp.y;
-            ncp->lppos->cx              = ps->ncp.cx;
-            ncp->lppos->cy              = ps->ncp.cy;
-            ncp->lppos->flags           = ps->ncp.flags;
-        }
-        break;
-    case EM_GETSEL:
-    case SBM_GETRANGE:
-    case CB_GETEDITSEL:
-        if (wparam)
-        {
-            memcpy( (DWORD *)wparam, buffer, min( sizeof(DWORD), size ));
-            if (size <= sizeof(DWORD)) break;
-            size -= sizeof(DWORD);
-            buffer = (DWORD *)buffer + 1;
-        }
-        if (lparam) memcpy( (DWORD *)lparam, buffer, min( sizeof(DWORD), size ));
-        break;
-    case WM_MDICREATE:
-        if (size >= sizeof(ps->mcs))
-        {
-            MDICREATESTRUCTW *mcs = (MDICREATESTRUCTW *)lparam;
-            mcs->hOwner  = unpack_ptr( ps->mcs.hOwner );
-            mcs->x       = ps->mcs.x;
-            mcs->y       = ps->mcs.y;
-            mcs->cx      = ps->mcs.cx;
-            mcs->cy      = ps->mcs.cy;
-            mcs->style   = ps->mcs.style;
-            mcs->lParam  = (LPARAM)unpack_ptr( ps->mcs.lParam );
-            /* don't allow changing class and title pointers */
-        }
-        break;
-    default:
-        ERR( "should not happen: unexpected message %x\n", message );
-        break;
-    }
-}
-
-/***********************************************************************
- *           reply_message
- *
- * Send a reply to a sent message.
- */
-static void reply_message( struct received_message_info *info, LRESULT result, MSG *msg )
-{
-    struct packed_message data;
-    int i, replied = info->flags & ISMEX_REPLIED;
-    BOOL remove = msg != NULL;
-
-    if (info->flags & ISMEX_NOTIFY) return;  /* notify messages don't get replies */
-    if (!remove && replied) return;  /* replied already */
-
-    memset( &data, 0, sizeof(data) );
-    info->flags |= ISMEX_REPLIED;
-
-    if (info->type == MSG_OTHER_PROCESS && !replied)
-    {
-        if (!msg) msg = &info->msg;
-        pack_reply( msg->hwnd, msg->message, msg->wParam, msg->lParam, result, &data );
-    }
-
-    SERVER_START_REQ( reply_message )
-    {
-        req->result = result;
-        req->remove = remove;
-        for (i = 0; i < data.count; i++) wine_server_add_data( req, data.data[i], data.size[i] );
-        wine_server_call( req );
-    }
-    SERVER_END_REQ;
-}
-
-/***********************************************************************
- *           reply_message_result
- *
- * Send a reply to a sent message and update thread receive info.
- */
-BOOL reply_message_result( LRESULT result, MSG *msg )
-{
-    struct received_message_info *info = get_user_thread_info()->receive_info;
-
-    if (!info) return FALSE;
-    reply_message( info, result, msg );
-    if (msg) get_user_thread_info()->receive_info = info->prev;
-    return TRUE;
-}
-
-/***********************************************************************
- *           handle_internal_message
- *
- * Handle an internal Wine message instead of calling the window proc.
- */
-static LRESULT handle_internal_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    switch(msg)
-    {
-    case WM_WINE_DESTROYWINDOW:
-        return destroy_window( hwnd );
-    case WM_WINE_SETWINDOWPOS:
-        if (is_desktop_window( hwnd )) return 0;
-        return set_window_pos( (WINDOWPOS *)lparam, 0, 0 );
-    case WM_WINE_SHOWWINDOW:
-        if (is_desktop_window( hwnd )) return 0;
-        return NtUserShowWindow( hwnd, wparam );
-    case WM_WINE_SETPARENT:
-        if (is_desktop_window( hwnd )) return 0;
-        return HandleToUlong( NtUserSetParent( hwnd, UlongToHandle(wparam) ));
-    case WM_WINE_SETWINDOWLONG:
-        return set_window_long( hwnd, (short)LOWORD(wparam), HIWORD(wparam), lparam, FALSE );
-    case WM_WINE_SETSTYLE:
-        if (is_desktop_window( hwnd )) return 0;
-        return set_window_style( hwnd, wparam, lparam );
-    case WM_WINE_SETACTIVEWINDOW:
-        if (!wparam && NtUserGetForegroundWindow() == hwnd) return 0;
-        return (LRESULT)NtUserSetActiveWindow( (HWND)wparam );
-    case WM_WINE_KEYBOARD_LL_HOOK:
-    case WM_WINE_MOUSE_LL_HOOK:
-    {
-        struct hook_extra_info *h_extra = (struct hook_extra_info *)lparam;
-
-        return call_current_hook( h_extra->handle, HC_ACTION, wparam, h_extra->lparam );
-    }
-    case WM_WINE_CLIPCURSOR:
-        if (wparam)
-        {
-            RECT rect;
-            get_clip_cursor( &rect );
-            return user_driver->pClipCursor( &rect );
-        }
-        return user_driver->pClipCursor( NULL );
-    case WM_WINE_UPDATEWINDOWSTATE:
-        update_window_state( hwnd );
-        return 0;
-    default:
-        if (msg >= WM_WINE_FIRST_DRIVER_MSG && msg <= WM_WINE_LAST_DRIVER_MSG)
-            return user_driver->pWindowMessage( hwnd, msg, wparam, lparam );
-        FIXME( "unknown internal message %x\n", msg );
-        return 0;
-    }
-}
-
-/**********************************************************************
- *           NtUserGetGUIThreadInfo  (win32u.@)
- */
-BOOL WINAPI NtUserGetGUIThreadInfo( DWORD id, GUITHREADINFO *info )
-{
-    BOOL ret;
-
-    if (info->cbSize != sizeof(*info))
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return FALSE;
-    }
-
-    SERVER_START_REQ( get_thread_input )
-    {
-        req->tid = id;
-        if ((ret = !wine_server_call_err( req )))
-        {
-            info->flags          = 0;
-            info->hwndActive     = wine_server_ptr_handle( reply->active );
-            info->hwndFocus      = wine_server_ptr_handle( reply->focus );
-            info->hwndCapture    = wine_server_ptr_handle( reply->capture );
-            info->hwndMenuOwner  = wine_server_ptr_handle( reply->menu_owner );
-            info->hwndMoveSize   = wine_server_ptr_handle( reply->move_size );
-            info->hwndCaret      = wine_server_ptr_handle( reply->caret );
-            info->rcCaret.left   = reply->rect.left;
-            info->rcCaret.top    = reply->rect.top;
-            info->rcCaret.right  = reply->rect.right;
-            info->rcCaret.bottom = reply->rect.bottom;
-            if (reply->menu_owner) info->flags |= GUI_INMENUMODE;
-            if (reply->move_size) info->flags |= GUI_INMOVESIZE;
-            if (reply->caret) info->flags |= GUI_CARETBLINKING;
-        }
-    }
-    SERVER_END_REQ;
-    return ret;
-}
-
-/***********************************************************************
- *           call_window_proc
- *
- * Call a window procedure and the corresponding hooks.
- */
-static LRESULT call_window_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                 BOOL unicode, BOOL same_thread, enum wm_char_mapping mapping,
-                                 BOOL needs_unpack, void *buffer, size_t size )
-{
-    struct win_proc_params p, *params = &p;
-    LRESULT result = 0;
-    CWPSTRUCT cwp;
-    CWPRETSTRUCT cwpret;
-
-    if (msg & 0x80000000)
-        return handle_internal_message( hwnd, msg, wparam, lparam );
-
-    if (!needs_unpack) size = 0;
-    if (!is_current_thread_window( hwnd )) return 0;
-    if (size && !(params = malloc( sizeof(*params) + size ))) return 0;
-    if (!init_window_call_params( params, hwnd, msg, wparam, lparam, &result, !unicode, mapping ))
-    {
-        if (params != &p) free( params );
-        return 0;
-    }
-
-    params->needs_unpack = needs_unpack;
-    if (size) memcpy( params + 1, buffer, size );
-
-    /* first the WH_CALLWNDPROC hook */
-    cwp.lParam  = lparam;
-    cwp.wParam  = wparam;
-    cwp.message = msg;
-    cwp.hwnd    = params->hwnd;
-    call_hooks( WH_CALLWNDPROC, HC_ACTION, same_thread, (LPARAM)&cwp, unicode );
-
-    dispatch_win_proc_params( params, sizeof(*params) + size );
-    if (params != &p) free( params );
-
-    /* and finally the WH_CALLWNDPROCRET hook */
-    cwpret.lResult = result;
-    cwpret.lParam  = lparam;
-    cwpret.wParam  = wparam;
-    cwpret.message = msg;
-    cwpret.hwnd    = params->hwnd;
-    call_hooks( WH_CALLWNDPROCRET, HC_ACTION, same_thread, (LPARAM)&cwpret, unicode );
-    return result;
-}
-
-/***********************************************************************
- *           call_sendmsg_callback
- *
- * Call the callback function of SendMessageCallback.
- */
-static inline void call_sendmsg_callback( SENDASYNCPROC callback, HWND hwnd, UINT msg,
-                                          ULONG_PTR data, LRESULT result )
-{
-    struct send_async_params params;
-    void *ret_ptr;
-    ULONG ret_len;
-
-    if (!callback) return;
-
-    params.callback = callback;
-    params.hwnd     = hwnd;
-    params.msg      = msg;
-    params.data     = data;
-    params.result   = result;
-
-    TRACE_(relay)( "\1Call message callback %p (hwnd=%p,msg=%s,data=%08lx,result=%08lx)\n",
-                   callback, hwnd, debugstr_msg_name( msg, hwnd ), data, result );
-
-    KeUserModeCallback( NtUserCallSendAsyncCallback, &params, sizeof(params), &ret_ptr, &ret_len );
-
-    TRACE_(relay)( "\1Ret  message callback %p (hwnd=%p,msg=%s,data=%08lx,result=%08lx)\n",
-                   callback, hwnd, debugstr_msg_name( msg, hwnd ), data, result );
-}
-
-/***********************************************************************
- *          accept_hardware_message
- *
- * Tell the server we have passed the message to the app
- * (even though we may end up dropping it later on)
- */
-static void accept_hardware_message( UINT hw_id )
-{
-    SERVER_START_REQ( accept_hardware_message )
-    {
-        req->hw_id = hw_id;
-        if (wine_server_call( req ))
-            FIXME("Failed to reply to MSG_HARDWARE message. Message may not be removed from queue.\n");
-    }
-    SERVER_END_REQ;
-}
-
-/***********************************************************************
- *           send_parent_notify
- *
- * Send a WM_PARENTNOTIFY to all ancestors of the given window, unless
- * the window has the WS_EX_NOPARENTNOTIFY style.
- */
-static void send_parent_notify( HWND hwnd, WORD event, WORD idChild, POINT pt )
-{
-    /* pt has to be in the client coordinates of the parent window */
-    map_window_points( 0, hwnd, &pt, 1, get_thread_dpi() );
-    for (;;)
-    {
-        HWND parent;
-
-        if (!(get_window_long( hwnd, GWL_STYLE ) & WS_CHILD)) break;
-        if (get_window_long( hwnd, GWL_EXSTYLE ) & WS_EX_NOPARENTNOTIFY) break;
-        if (!(parent = get_parent( hwnd ))) break;
-        if (parent == get_desktop_window()) break;
-        map_window_points( hwnd, parent, &pt, 1, get_thread_dpi() );
-        hwnd = parent;
-        send_message( hwnd, WM_PARENTNOTIFY,
-                      MAKEWPARAM( event, idChild ), MAKELPARAM( pt.x, pt.y ) );
-    }
-}
-
-/***********************************************************************
- *          process_keyboard_message
- *
- * returns TRUE if the contents of 'msg' should be passed to the application
- */
-static BOOL process_keyboard_message( MSG *msg, UINT hw_id, HWND hwnd_filter,
-                                      UINT first, UINT last, BOOL remove )
-{
-    EVENTMSG event;
-
-    if (msg->message == WM_KEYDOWN || msg->message == WM_SYSKEYDOWN ||
-        msg->message == WM_KEYUP || msg->message == WM_SYSKEYUP)
-        switch (msg->wParam)
-        {
-            case VK_LSHIFT: case VK_RSHIFT:
-                msg->wParam = VK_SHIFT;
-                break;
-            case VK_LCONTROL: case VK_RCONTROL:
-                msg->wParam = VK_CONTROL;
-                break;
-            case VK_LMENU: case VK_RMENU:
-                msg->wParam = VK_MENU;
-                break;
-        }
-
-    /* FIXME: is this really the right place for this hook? */
-    event.message = msg->message;
-    event.hwnd    = msg->hwnd;
-    event.time    = msg->time;
-    event.paramL  = (msg->wParam & 0xFF) | (HIWORD(msg->lParam) << 8);
-    event.paramH  = msg->lParam & 0x7FFF;
-    if (HIWORD(msg->lParam) & 0x0100) event.paramH |= 0x8000; /* special_key - bit */
-    call_hooks( WH_JOURNALRECORD, HC_ACTION, 0, (LPARAM)&event, TRUE );
-
-    /* check message filters */
-    if (msg->message < first || msg->message > last) return FALSE;
-    if (!check_hwnd_filter( msg, hwnd_filter )) return FALSE;
-
-    if (remove)
-    {
-        if((msg->message == WM_KEYDOWN) &&
-           (msg->hwnd != get_desktop_window()))
-        {
-            /* Handle F1 key by sending out WM_HELP message */
-            if (msg->wParam == VK_F1)
-            {
-                NtUserPostMessage( msg->hwnd, WM_KEYF1, 0, 0 );
-            }
-            else if(msg->wParam >= VK_BROWSER_BACK &&
-                    msg->wParam <= VK_LAUNCH_APP2)
-            {
-                /* FIXME: Process keystate */
-                send_message( msg->hwnd, WM_APPCOMMAND, (WPARAM)msg->hwnd,
-                              MAKELPARAM(0, (FAPPCOMMAND_KEY | (msg->wParam - VK_BROWSER_BACK + 1))) );
-            }
-        }
-        else if (msg->message == WM_KEYUP)
-        {
-            /* Handle VK_APPS key by posting a WM_CONTEXTMENU message */
-            if (msg->wParam == VK_APPS && user_callbacks && !user_callbacks->is_menu_active())
-                NtUserPostMessage( msg->hwnd, WM_CONTEXTMENU, (WPARAM)msg->hwnd, -1 );
-        }
-    }
-
-    if (call_hooks( WH_KEYBOARD, remove ? HC_ACTION : HC_NOREMOVE,
-                    LOWORD(msg->wParam), msg->lParam, TRUE ))
-    {
-        /* skip this message */
-        call_hooks( WH_CBT, HCBT_KEYSKIPPED, LOWORD(msg->wParam), msg->lParam, TRUE );
-        accept_hardware_message( hw_id );
-        return FALSE;
-    }
-    if (remove) accept_hardware_message( hw_id );
-    msg->pt = point_phys_to_win_dpi( msg->hwnd, msg->pt );
-
-    if (remove && msg->message == WM_KEYDOWN && user_callbacks)
-        if (user_callbacks->pImmProcessKey( msg->hwnd, NtUserGetKeyboardLayout(0),
-                                            msg->wParam, msg->lParam, 0 ))
-            msg->wParam = VK_PROCESSKEY;
-
-    return TRUE;
-}
-
-/***********************************************************************
- *          process_mouse_message
- *
- * returns TRUE if the contents of 'msg' should be passed to the application
- */
-static BOOL process_mouse_message( MSG *msg, UINT hw_id, ULONG_PTR extra_info, HWND hwnd_filter,
-                                   UINT first, UINT last, BOOL remove )
-{
-    static MSG clk_msg;
-
-    POINT pt;
-    UINT message;
-    INT hittest;
-    EVENTMSG event;
-    GUITHREADINFO info;
-    MOUSEHOOKSTRUCTEX hook;
-    BOOL eat_msg;
-    WPARAM wparam;
-
-    /* find the window to dispatch this mouse message to */
-
-    info.cbSize = sizeof(info);
-    NtUserGetGUIThreadInfo( GetCurrentThreadId(), &info );
-    if (info.hwndCapture)
-    {
-        hittest = HTCLIENT;
-        msg->hwnd = info.hwndCapture;
-    }
-    else
-    {
-        HWND orig = msg->hwnd;
-
-        msg->hwnd = window_from_point( msg->hwnd, msg->pt, &hittest );
-        if (!msg->hwnd) /* As a heuristic, try the next window if it's the owner of orig */
-        {
-            HWND next = get_window_relative( orig, GW_HWNDNEXT );
-
-            if (next && get_window_relative( orig, GW_OWNER ) == next &&
-                is_current_thread_window( next ))
-                msg->hwnd = window_from_point( next, msg->pt, &hittest );
-        }
-    }
-
-    if (!msg->hwnd || !is_current_thread_window( msg->hwnd ))
-    {
-        accept_hardware_message( hw_id );
-        return FALSE;
-    }
-
-    msg->pt = point_phys_to_win_dpi( msg->hwnd, msg->pt );
-    set_thread_dpi_awareness_context( get_window_dpi_awareness_context( msg->hwnd ));
-
-    /* FIXME: is this really the right place for this hook? */
-    event.message = msg->message;
-    event.time    = msg->time;
-    event.hwnd    = msg->hwnd;
-    event.paramL  = msg->pt.x;
-    event.paramH  = msg->pt.y;
-    call_hooks( WH_JOURNALRECORD, HC_ACTION, 0, (LPARAM)&event, TRUE );
-
-    if (!check_hwnd_filter( msg, hwnd_filter )) return FALSE;
-
-    pt = msg->pt;
-    message = msg->message;
-    wparam = msg->wParam;
-    /* Note: windows has no concept of a non-client wheel message */
-    if (message != WM_MOUSEWHEEL)
-    {
-        if (hittest != HTCLIENT)
-        {
-            message += WM_NCMOUSEMOVE - WM_MOUSEMOVE;
-            wparam = hittest;
-        }
-        else
-        {
-            /* coordinates don't get translated while tracking a menu */
-            /* FIXME: should differentiate popups and top-level menus */
-            if (!(info.flags & GUI_INMENUMODE))
-                screen_to_client( msg->hwnd, &pt );
-        }
-    }
-    msg->lParam = MAKELONG( pt.x, pt.y );
-
-    /* translate double clicks */
-
-    if (msg->message == WM_LBUTTONDOWN ||
-        msg->message == WM_RBUTTONDOWN ||
-        msg->message == WM_MBUTTONDOWN ||
-        msg->message == WM_XBUTTONDOWN)
-    {
-        BOOL update = remove;
-
-        /* translate double clicks -
-	 * note that ...MOUSEMOVEs can slip in between
-	 * ...BUTTONDOWN and ...BUTTONDBLCLK messages */
-
-        if ((info.flags & (GUI_INMENUMODE|GUI_INMOVESIZE)) ||
-            hittest != HTCLIENT ||
-            (get_class_long( msg->hwnd, GCL_STYLE, FALSE ) & CS_DBLCLKS))
-        {
-           if ((msg->message == clk_msg.message) &&
-               (msg->hwnd == clk_msg.hwnd) &&
-               (msg->wParam == clk_msg.wParam) &&
-               (msg->time - clk_msg.time < NtUserGetDoubleClickTime()) &&
-               (abs(msg->pt.x - clk_msg.pt.x) < get_system_metrics( SM_CXDOUBLECLK ) / 2) &&
-               (abs(msg->pt.y - clk_msg.pt.y) < get_system_metrics( SM_CYDOUBLECLK ) / 2))
-           {
-               message += (WM_LBUTTONDBLCLK - WM_LBUTTONDOWN);
-               if (update)
-               {
-                   clk_msg.message = 0;  /* clear the double click conditions */
-                   update = FALSE;
-               }
-           }
-        }
-        if (message < first || message > last) return FALSE;
-        /* update static double click conditions */
-        if (update) clk_msg = *msg;
-    }
-    else
-    {
-        if (message < first || message > last) return FALSE;
-    }
-    msg->wParam = wparam;
-
-    /* message is accepted now (but may still get dropped) */
-
-    hook.pt           = msg->pt;
-    hook.hwnd         = msg->hwnd;
-    hook.wHitTestCode = hittest;
-    hook.dwExtraInfo  = extra_info;
-    hook.mouseData    = msg->wParam;
-    if (call_hooks( WH_MOUSE, remove ? HC_ACTION : HC_NOREMOVE, message, (LPARAM)&hook, TRUE ))
-    {
-        hook.pt           = msg->pt;
-        hook.hwnd         = msg->hwnd;
-        hook.wHitTestCode = hittest;
-        hook.dwExtraInfo  = extra_info;
-        hook.mouseData    = msg->wParam;
-        call_hooks( WH_CBT, HCBT_CLICKSKIPPED, message, (LPARAM)&hook, TRUE );
-        accept_hardware_message( hw_id );
-        return FALSE;
-    }
-
-    if ((hittest == HTERROR) || (hittest == HTNOWHERE))
-    {
-        send_message( msg->hwnd, WM_SETCURSOR, (WPARAM)msg->hwnd, MAKELONG( hittest, msg->message ));
-        accept_hardware_message( hw_id );
-        return FALSE;
-    }
-
-    if (remove) accept_hardware_message( hw_id );
-
-    if (!remove || info.hwndCapture)
-    {
-        msg->message = message;
-        return TRUE;
-    }
-
-    eat_msg = FALSE;
-
-    if (msg->message == WM_LBUTTONDOWN ||
-        msg->message == WM_RBUTTONDOWN ||
-        msg->message == WM_MBUTTONDOWN ||
-        msg->message == WM_XBUTTONDOWN)
-    {
-        /* Send the WM_PARENTNOTIFY,
-         * note that even for double/nonclient clicks
-         * notification message is still WM_L/M/RBUTTONDOWN.
-         */
-        send_parent_notify( msg->hwnd, msg->message, 0, msg->pt );
-
-        /* Activate the window if needed */
-
-        if (msg->hwnd != info.hwndActive)
-        {
-            HWND hwndTop = NtUserGetAncestor( msg->hwnd, GA_ROOT );
-
-            if ((get_window_long( hwndTop, GWL_STYLE ) & (WS_POPUP|WS_CHILD)) != WS_CHILD)
-            {
-                LONG ret = send_message( msg->hwnd, WM_MOUSEACTIVATE, (WPARAM)hwndTop,
-                                         MAKELONG( hittest, msg->message ) );
-                switch(ret)
-                {
-                case MA_NOACTIVATEANDEAT:
-                    eat_msg = TRUE;
-                    /* fall through */
-                case MA_NOACTIVATE:
-                    break;
-                case MA_ACTIVATEANDEAT:
-                    eat_msg = TRUE;
-                    /* fall through */
-                case MA_ACTIVATE:
-                case 0:
-                    if (!set_foreground_window( hwndTop, TRUE )) eat_msg = TRUE;
-                    break;
-                default:
-                    WARN( "unknown WM_MOUSEACTIVATE code %d\n", ret );
-                    break;
-                }
-            }
-        }
-    }
-
-    /* send the WM_SETCURSOR message */
-
-    /* Windows sends the normal mouse message as the message parameter
-       in the WM_SETCURSOR message even if it's non-client mouse message */
-    send_message( msg->hwnd, WM_SETCURSOR, (WPARAM)msg->hwnd, MAKELONG( hittest, msg->message ));
-
-    msg->message = message;
-    return !eat_msg;
-}
-
-/***********************************************************************
- *           process_hardware_message
- *
- * Process a hardware message; return TRUE if message should be passed on to the app
- */
-static BOOL process_hardware_message( MSG *msg, UINT hw_id, const struct hardware_msg_data *msg_data,
-                                      HWND hwnd_filter, UINT first, UINT last, BOOL remove )
-{
-    DPI_AWARENESS_CONTEXT context;
-    BOOL ret = FALSE;
-
-    get_user_thread_info()->msg_source.deviceType = msg_data->source.device;
-    get_user_thread_info()->msg_source.originId   = msg_data->source.origin;
-
-    /* hardware messages are always in physical coords */
-    context = set_thread_dpi_awareness_context( DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE );
-
-    if (msg->message == WM_INPUT || msg->message == WM_INPUT_DEVICE_CHANGE)
-        ret = user_callbacks && user_callbacks->process_rawinput_message( msg, hw_id, msg_data );
-    else if (is_keyboard_message( msg->message ))
-        ret = process_keyboard_message( msg, hw_id, hwnd_filter, first, last, remove );
-    else if (is_mouse_message( msg->message ))
-        ret = process_mouse_message( msg, hw_id, msg_data->info, hwnd_filter, first, last, remove );
-    else
-        ERR( "unknown message type %x\n", msg->message );
-    set_thread_dpi_awareness_context( context );
-    return ret;
-}
-
-/***********************************************************************
- *           peek_message
- *
- * Peek for a message matching the given parameters. Return 0 if none are
- * available; -1 on error.
- * All pending sent messages are processed before returning.
- */
-static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags, UINT changed_mask )
-{
-    LRESULT result;
-    struct user_thread_info *thread_info = get_user_thread_info();
-    INPUT_MESSAGE_SOURCE prev_source = thread_info->msg_source;
-    struct received_message_info info;
-    unsigned int hw_id = 0;  /* id of previous hardware message */
-    void *buffer;
-    size_t buffer_size = 1024;
-
-    if (!(buffer = malloc( buffer_size ))) return -1;
-
-    if (!first && !last) last = ~0;
-    if (hwnd == HWND_BROADCAST) hwnd = HWND_TOPMOST;
-
-    for (;;)
-    {
-        NTSTATUS res;
-        size_t size = 0;
-        const message_data_t *msg_data = buffer;
-        BOOL needs_unpack = FALSE;
-
-        thread_info->msg_source = prev_source;
-
-        SERVER_START_REQ( get_message )
-        {
-            req->flags     = flags;
-            req->get_win   = wine_server_user_handle( hwnd );
-            req->get_first = first;
-            req->get_last  = last;
-            req->hw_id     = hw_id;
-            req->wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
-            req->changed_mask = changed_mask;
-            wine_server_set_reply( req, buffer, buffer_size );
-            if (!(res = wine_server_call( req )))
-            {
-                size = wine_server_reply_size( reply );
-                info.type        = reply->type;
-                info.msg.hwnd    = wine_server_ptr_handle( reply->win );
-                info.msg.message = reply->msg;
-                info.msg.wParam  = reply->wparam;
-                info.msg.lParam  = reply->lparam;
-                info.msg.time    = reply->time;
-                info.msg.pt.x    = reply->x;
-                info.msg.pt.y    = reply->y;
-                hw_id            = 0;
-                thread_info->active_hooks = reply->active_hooks;
-            }
-            else buffer_size = reply->total;
-        }
-        SERVER_END_REQ;
-
-        if (res)
-        {
-            free( buffer );
-            if (res == STATUS_PENDING)
-            {
-                thread_info->wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
-                thread_info->changed_mask = changed_mask;
-                return 0;
-            }
-            if (res != STATUS_BUFFER_OVERFLOW)
-            {
-                SetLastError( RtlNtStatusToDosError(res) );
-                return -1;
-            }
-            if (!(buffer = malloc( buffer_size ))) return -1;
-            continue;
-        }
-
-        TRACE( "got type %d msg %x (%s) hwnd %p wp %lx lp %lx\n",
-               info.type, info.msg.message,
-               (info.type == MSG_WINEVENT) ? "MSG_WINEVENT" : debugstr_msg_name(info.msg.message, info.msg.hwnd),
-               info.msg.hwnd, info.msg.wParam, info.msg.lParam );
-
-        switch(info.type)
-        {
-        case MSG_ASCII:
-        case MSG_UNICODE:
-            info.flags = ISMEX_SEND;
-            break;
-        case MSG_NOTIFY:
-            info.flags = ISMEX_NOTIFY;
-            if (!unpack_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
-                                 &info.msg.lParam, &buffer, size ))
-                continue;
-            needs_unpack = TRUE;
-            break;
-        case MSG_CALLBACK:
-            info.flags = ISMEX_CALLBACK;
-            break;
-        case MSG_CALLBACK_RESULT:
-            if (size >= sizeof(msg_data->callback))
-                call_sendmsg_callback( wine_server_get_ptr(msg_data->callback.callback),
-                                       info.msg.hwnd, info.msg.message,
-                                       msg_data->callback.data, msg_data->callback.result );
-            continue;
-        case MSG_WINEVENT:
-            if (size >= sizeof(msg_data->winevent))
-            {
-                struct win_event_hook_params params;
-                void *ret_ptr;
-                ULONG ret_len;
-
-                params.proc = wine_server_get_ptr( msg_data->winevent.hook_proc );
-                size -= sizeof(msg_data->winevent);
-                if (size)
-                {
-                    size = min( size, sizeof(params.module) - sizeof(WCHAR) );
-                    memcpy( params.module, &msg_data->winevent + 1, size );
-                }
-                params.module[size / sizeof(WCHAR)] = 0;
-                size = FIELD_OFFSET( struct win_hook_params, module[size / sizeof(WCHAR) + 1] );
-
-                params.handle    = wine_server_ptr_handle( msg_data->winevent.hook );
-                params.event     = info.msg.message;
-                params.hwnd      = info.msg.hwnd;
-                params.object_id = info.msg.wParam;
-                params.child_id  = info.msg.lParam;
-                params.tid       = msg_data->winevent.tid;
-                params.time      = info.msg.time;
-
-                KeUserModeCallback( NtUserCallWinEventHook, &params, size, &ret_ptr, &ret_len );
-            }
-            continue;
-        case MSG_HOOK_LL:
-            info.flags = ISMEX_SEND;
-            result = 0;
-            if (info.msg.message == WH_KEYBOARD_LL && size >= sizeof(msg_data->hardware))
-            {
-                KBDLLHOOKSTRUCT hook;
-
-                hook.vkCode      = LOWORD( info.msg.lParam );
-                hook.scanCode    = HIWORD( info.msg.lParam );
-                hook.flags       = msg_data->hardware.flags;
-                hook.time        = info.msg.time;
-                hook.dwExtraInfo = msg_data->hardware.info;
-                TRACE( "calling keyboard LL hook vk %x scan %x flags %x time %u info %lx\n",
-                       hook.vkCode, hook.scanCode, hook.flags, hook.time, hook.dwExtraInfo );
-                result = call_hooks( WH_KEYBOARD_LL, HC_ACTION, info.msg.wParam, (LPARAM)&hook, TRUE );
-            }
-            else if (info.msg.message == WH_MOUSE_LL && size >= sizeof(msg_data->hardware))
-            {
-                MSLLHOOKSTRUCT hook;
-
-                hook.pt          = info.msg.pt;
-                hook.mouseData   = info.msg.lParam;
-                hook.flags       = msg_data->hardware.flags;
-                hook.time        = info.msg.time;
-                hook.dwExtraInfo = msg_data->hardware.info;
-                TRACE( "calling mouse LL hook pos %d,%d data %x flags %x time %u info %lx\n",
-                       hook.pt.x, hook.pt.y, hook.mouseData, hook.flags, hook.time, hook.dwExtraInfo );
-                result = call_hooks( WH_MOUSE_LL, HC_ACTION, info.msg.wParam, (LPARAM)&hook, TRUE );
-            }
-            reply_message( &info, result, &info.msg );
-            continue;
-        case MSG_OTHER_PROCESS:
-            info.flags = ISMEX_SEND;
-            if (!unpack_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
-                                 &info.msg.lParam, &buffer, size ))
-            {
-                /* ignore it */
-                reply_message( &info, 0, &info.msg );
-                continue;
-            }
-            needs_unpack = TRUE;
-            break;
-        case MSG_HARDWARE:
-            if (size >= sizeof(msg_data->hardware))
-            {
-                hw_id = msg_data->hardware.hw_id;
-                if (!process_hardware_message( &info.msg, hw_id, &msg_data->hardware,
-                                               hwnd, first, last, flags & PM_REMOVE ))
-                {
-                    TRACE("dropping msg %x\n", info.msg.message );
-                    continue;  /* ignore it */
-                }
-                *msg = info.msg;
-                thread_info->client_info.message_pos   = MAKELONG( info.msg.pt.x, info.msg.pt.y );
-                thread_info->client_info.message_time  = info.msg.time;
-                thread_info->client_info.message_extra = msg_data->hardware.info;
-                free( buffer );
-                call_hooks( WH_GETMESSAGE, HC_ACTION, flags & PM_REMOVE, (LPARAM)msg, TRUE );
-                return 1;
-            }
-            continue;
-        case MSG_POSTED:
-            if (info.msg.message & 0x80000000)  /* internal message */
-            {
-                if (flags & PM_REMOVE)
-                {
-                    handle_internal_message( info.msg.hwnd, info.msg.message,
-                                             info.msg.wParam, info.msg.lParam );
-                    /* if this is a nested call return right away */
-                    if (first == info.msg.message && last == info.msg.message)
-                    {
-                        free( buffer );
-                        return 0;
-                    }
-                }
-                else
-                    peek_message( msg, info.msg.hwnd, info.msg.message,
-                                  info.msg.message, flags | PM_REMOVE, changed_mask );
-                continue;
-            }
-            if (info.msg.message >= WM_DDE_FIRST && info.msg.message <= WM_DDE_LAST)
-            {
-                if (!user_callbacks->unpack_dde_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
-                                                         &info.msg.lParam, &buffer, size ))
-                    continue;  /* ignore it */
-            }
-            *msg = info.msg;
-            msg->pt = point_phys_to_win_dpi( info.msg.hwnd, info.msg.pt );
-            thread_info->client_info.message_pos   = MAKELONG( msg->pt.x, msg->pt.y );
-            thread_info->client_info.message_time  = info.msg.time;
-            thread_info->client_info.message_extra = 0;
-            thread_info->msg_source = msg_source_unavailable;
-            free( buffer );
-            call_hooks( WH_GETMESSAGE, HC_ACTION, flags & PM_REMOVE, (LPARAM)msg, TRUE );
-            return 1;
-        }
-
-        /* if we get here, we have a sent message; call the window procedure */
-        info.prev = thread_info->receive_info;
-        thread_info->receive_info = &info;
-        thread_info->msg_source = msg_source_unavailable;
-        result = call_window_proc( info.msg.hwnd, info.msg.message, info.msg.wParam,
-                                   info.msg.lParam, (info.type != MSG_ASCII), FALSE,
-                                   WMCHAR_MAP_RECVMESSAGE, needs_unpack, buffer, size );
-        if (thread_info->receive_info == &info)
-            reply_message_result( result, &info.msg );
-
-        /* if some PM_QS* flags were specified, only handle sent messages from now on */
-        if (HIWORD(flags) && !changed_mask) flags = PM_QS_SENDMESSAGE | LOWORD(flags);
-    }
-}
-
-/***********************************************************************
- *           process_sent_messages
- *
- * Process all pending sent messages.
- */
-static void process_sent_messages(void)
-{
-    MSG msg;
-    peek_message( &msg, 0, 0, 0, PM_REMOVE | PM_QS_SENDMESSAGE, 0 );
-}
-
-/***********************************************************************
- *           get_server_queue_handle
- *
- * Get a handle to the server message queue for the current thread.
- */
-static HANDLE get_server_queue_handle(void)
-{
-    struct user_thread_info *thread_info = get_user_thread_info();
-    HANDLE ret;
-
-    if (!(ret = thread_info->server_queue))
-    {
-        SERVER_START_REQ( get_msg_queue )
-        {
-            wine_server_call( req );
-            ret = wine_server_ptr_handle( reply->handle );
-        }
-        SERVER_END_REQ;
-        thread_info->server_queue = ret;
-        if (!ret) ERR( "Cannot get server thread queue\n" );
-    }
-    return ret;
-}
-
-/* check for driver events if we detect that the app is not properly consuming messages */
-static inline void check_for_driver_events( UINT msg )
-{
-    if (get_user_thread_info()->message_count > 200)
-    {
-        LARGE_INTEGER zero = { .QuadPart = 0 };
-        flush_window_surfaces( FALSE );
-        user_driver->pMsgWaitForMultipleObjectsEx( 0, NULL, &zero, QS_ALLINPUT, 0 );
-    }
-    else if (msg == WM_TIMER || msg == WM_SYSTIMER)
-    {
-        /* driver events should have priority over timers, so make sure we'll check for them soon */
-        get_user_thread_info()->message_count += 100;
-    }
-    else get_user_thread_info()->message_count++;
-}
-
-/* helper for kernel32->ntdll timeout format conversion */
-static inline LARGE_INTEGER *get_nt_timeout( LARGE_INTEGER *time, DWORD timeout )
-{
-    if (timeout == INFINITE) return NULL;
-    time->QuadPart = (ULONGLONG)timeout * -10000;
-    return time;
-}
-
-/* wait for message or signaled handle */
-static DWORD wait_message( DWORD count, const HANDLE *handles, DWORD timeout, DWORD mask, DWORD flags )
-{
-    LARGE_INTEGER time;
-    DWORD ret, lock;
-    void *ret_ptr;
-    ULONG ret_len;
-
-    if (enable_thunk_lock)
-        lock = KeUserModeCallback( NtUserThunkLock, NULL, 0, &ret_ptr, &ret_len );
-
-    ret = user_driver->pMsgWaitForMultipleObjectsEx( count, handles, get_nt_timeout( &time, timeout ),
-                                                     mask, flags );
-    if (HIWORD(ret))  /* is it an error code? */
-    {
-        SetLastError( RtlNtStatusToDosError(ret) );
-        ret = WAIT_FAILED;
-    }
-    if (ret == WAIT_TIMEOUT && !count && !timeout) NtYieldExecution();
-    if ((mask & QS_INPUT) == QS_INPUT) get_user_thread_info()->message_count = 0;
-
-    if (enable_thunk_lock)
-        KeUserModeCallback( NtUserThunkLock, &lock, sizeof(lock), &ret_ptr, &ret_len );
-
-    return ret;
-}
-
-/***********************************************************************
- *           wait_objects
- *
- * Wait for multiple objects including the server queue, with specific queue masks.
- */
-static DWORD wait_objects( DWORD count, const HANDLE *handles, DWORD timeout,
-                           DWORD wake_mask, DWORD changed_mask, DWORD flags )
-{
-    struct user_thread_info *thread_info = get_user_thread_info();
-    DWORD ret;
-
-    assert( count );  /* we must have at least the server queue */
-
-    flush_window_surfaces( TRUE );
-
-    if (thread_info->wake_mask != wake_mask || thread_info->changed_mask != changed_mask)
-    {
-        SERVER_START_REQ( set_queue_mask )
-        {
-            req->wake_mask    = wake_mask;
-            req->changed_mask = changed_mask;
-            req->skip_wait    = 0;
-            wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        thread_info->wake_mask = wake_mask;
-        thread_info->changed_mask = changed_mask;
-    }
-
-    ret = wait_message( count, handles, timeout, changed_mask, flags );
-
-    if (ret != WAIT_TIMEOUT) thread_info->wake_mask = thread_info->changed_mask = 0;
-    return ret;
-}
-
-static HANDLE normalize_std_handle( HANDLE handle )
-{
-    if (handle == (HANDLE)STD_INPUT_HANDLE)
-        return NtCurrentTeb()->Peb->ProcessParameters->hStdInput;
-    if (handle == (HANDLE)STD_OUTPUT_HANDLE)
-        return NtCurrentTeb()->Peb->ProcessParameters->hStdOutput;
-    if (handle == (HANDLE)STD_ERROR_HANDLE)
-        return NtCurrentTeb()->Peb->ProcessParameters->hStdError;
-
-    return handle;
-}
-
-/***********************************************************************
- *           NtUserMsgWaitForMultipleObjectsEx   (win32u.@)
- */
-DWORD WINAPI NtUserMsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                                DWORD timeout, DWORD mask, DWORD flags )
-{
-    HANDLE wait_handles[MAXIMUM_WAIT_OBJECTS];
-    DWORD i;
-
-    if (count > MAXIMUM_WAIT_OBJECTS-1)
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return WAIT_FAILED;
-    }
-
-    /* add the queue to the handle list */
-    for (i = 0; i < count; i++) wait_handles[i] = normalize_std_handle( handles[i] );
-    wait_handles[count] = get_server_queue_handle();
-
-    return wait_objects( count+1, wait_handles, timeout,
-                         (flags & MWMO_INPUTAVAILABLE) ? mask : 0, mask, flags );
-}
-
-/***********************************************************************
- *           NtUserWaitForInputIdle (win32u.@)
- */
-DWORD WINAPI NtUserWaitForInputIdle( HANDLE process, DWORD timeout, BOOL wow )
-{
-    DWORD start_time, elapsed, ret;
-    HANDLE handles[2];
-
-    handles[0] = process;
-    SERVER_START_REQ( get_process_idle_event )
-    {
-        req->handle = wine_server_obj_handle( process );
-        wine_server_call_err( req );
-        handles[1] = wine_server_ptr_handle( reply->event );
-    }
-    SERVER_END_REQ;
-    if (!handles[1]) return WAIT_FAILED;  /* no event to wait on */
-
-    start_time = NtGetTickCount();
-    elapsed = 0;
-
-    TRACE("waiting for %p\n", handles[1] );
-
-    for (;;)
-    {
-        ret = NtUserMsgWaitForMultipleObjectsEx( 2, handles, timeout - elapsed, QS_SENDMESSAGE, 0 );
-        switch (ret)
-        {
-        case WAIT_OBJECT_0:
-            return 0;
-        case WAIT_OBJECT_0+2:
-            process_sent_messages();
-            break;
-        case WAIT_TIMEOUT:
-        case WAIT_FAILED:
-            TRACE("timeout or error\n");
-            return ret;
-        default:
-            TRACE("finished\n");
-            return 0;
-        }
-        if (timeout != INFINITE)
-        {
-            elapsed = NtGetTickCount() - start_time;
-            if (elapsed > timeout)
-                break;
-        }
-    }
-
-    return WAIT_TIMEOUT;
-}
-
-/***********************************************************************
- *           NtUserPeekMessage  (win32u.@)
- */
-BOOL WINAPI NtUserPeekMessage( MSG *msg_out, HWND hwnd, UINT first, UINT last, UINT flags )
-{
-    MSG msg;
-    int ret;
-
-    user_check_not_lock();
-    check_for_driver_events( 0 );
-
-    ret = peek_message( &msg, hwnd, first, last, flags, 0 );
-    if (ret < 0) return FALSE;
-
-    if (!ret)
-    {
-        flush_window_surfaces( TRUE );
-        ret = wait_message( 0, NULL, 0, QS_ALLINPUT, 0 );
-        /* if we received driver events, check again for a pending message */
-        if (ret == WAIT_TIMEOUT || peek_message( &msg, hwnd, first, last, flags, 0 ) <= 0) return FALSE;
-    }
-
-    check_for_driver_events( msg.message );
-
-    /* copy back our internal safe copy of message data to msg_out.
-     * msg_out is a variable from the *program*, so it can't be used
-     * internally as it can get "corrupted" by our use of SendMessage()
-     * (back to the program) inside the message handling itself. */
-    if (!msg_out)
-    {
-        SetLastError( ERROR_NOACCESS );
-        return FALSE;
-    }
-    *msg_out = msg;
-    return TRUE;
-}
-
-/***********************************************************************
- *           NtUserGetMessage  (win32u.@)
- */
-BOOL WINAPI NtUserGetMessage( MSG *msg, HWND hwnd, UINT first, UINT last )
-{
-    HANDLE server_queue = get_server_queue_handle();
-    unsigned int mask = QS_POSTMESSAGE | QS_SENDMESSAGE;  /* Always selected */
-    int ret;
-
-    user_check_not_lock();
-    check_for_driver_events( 0 );
-
-    if (first || last)
-    {
-        if ((first <= WM_KEYLAST) && (last >= WM_KEYFIRST)) mask |= QS_KEY;
-        if ( ((first <= WM_MOUSELAST) && (last >= WM_MOUSEFIRST)) ||
-             ((first <= WM_NCMOUSELAST) && (last >= WM_NCMOUSEFIRST)) ) mask |= QS_MOUSE;
-        if ((first <= WM_TIMER) && (last >= WM_TIMER)) mask |= QS_TIMER;
-        if ((first <= WM_SYSTIMER) && (last >= WM_SYSTIMER)) mask |= QS_TIMER;
-        if ((first <= WM_PAINT) && (last >= WM_PAINT)) mask |= QS_PAINT;
-    }
-    else mask = QS_ALLINPUT;
-
-    while (!(ret = peek_message( msg, hwnd, first, last, PM_REMOVE | (mask << 16), mask )))
-    {
-        wait_objects( 1, &server_queue, INFINITE, mask & (QS_SENDMESSAGE | QS_SMRESULT), mask, 0 );
-    }
-    if (ret < 0) return -1;
-
-    check_for_driver_events( msg->message );
-
-    return msg->message != WM_QUIT;
-}
-
-/***********************************************************************
- *           put_message_in_queue
- *
- * Put a sent message into the destination queue.
- * For inter-process message, reply_size is set to expected size of reply data.
- */
-static BOOL put_message_in_queue( const struct send_message_info *info, size_t *reply_size )
-{
-    struct packed_message data;
-    message_data_t msg_data;
-    unsigned int res;
-    int i;
-    timeout_t timeout = TIMEOUT_INFINITE;
-
-    /* Check for INFINITE timeout for compatibility with Win9x,
-     * although Windows >= NT does not do so
-     */
-    if (info->type != MSG_NOTIFY &&
-        info->type != MSG_CALLBACK &&
-        info->type != MSG_POSTED &&
-        info->timeout &&
-        info->timeout != INFINITE)
-    {
-        /* timeout is signed despite the prototype */
-        timeout = (timeout_t)max( 0, (int)info->timeout ) * -10000;
-    }
-
-    memset( &data, 0, sizeof(data) );
-    if (info->type == MSG_OTHER_PROCESS || info->type == MSG_NOTIFY)
-    {
-        *reply_size = pack_message( info->hwnd, info->msg, info->wparam, info->lparam, &data );
-        if (data.count == -1)
-        {
-            WARN( "cannot pack message %x\n", info->msg );
-            return FALSE;
-        }
-    }
-    else if (info->type == MSG_CALLBACK)
-    {
-        msg_data.callback.callback = wine_server_client_ptr( info->callback );
-        msg_data.callback.data     = info->data;
-        msg_data.callback.result   = 0;
-        data.data[0] = &msg_data;
-        data.size[0] = sizeof(msg_data.callback);
-        data.count = 1;
-    }
-    else if (info->type == MSG_POSTED && info->msg >= WM_DDE_FIRST && info->msg <= WM_DDE_LAST)
-    {
-        return user_callbacks && user_callbacks->post_dde_message( info->hwnd, info->msg,
-                info->wparam, info->lparam, info->dest_tid, info->type );
-    }
-
-    SERVER_START_REQ( send_message )
-    {
-        req->id      = info->dest_tid;
-        req->type    = info->type;
-        req->flags   = 0;
-        req->win     = wine_server_user_handle( info->hwnd );
-        req->msg     = info->msg;
-        req->wparam  = info->wparam;
-        req->lparam  = info->lparam;
-        req->timeout = timeout;
-
-        if (info->flags & SMTO_ABORTIFHUNG) req->flags |= SEND_MSG_ABORT_IF_HUNG;
-        for (i = 0; i < data.count; i++) wine_server_add_data( req, data.data[i], data.size[i] );
-        if ((res = wine_server_call( req )))
-        {
-            if (res == STATUS_INVALID_PARAMETER)
-                /* FIXME: find a STATUS_ value for this one */
-                SetLastError( ERROR_INVALID_THREAD_ID );
-            else
-                SetLastError( RtlNtStatusToDosError(res) );
-        }
-    }
-    SERVER_END_REQ;
-    return !res;
-}
-
-/***********************************************************************
- *           wait_message_reply
- *
- * Wait until a sent message gets replied to.
- */
-static void wait_message_reply( UINT flags )
-{
-    struct user_thread_info *thread_info = get_user_thread_info();
-    HANDLE server_queue = get_server_queue_handle();
-    unsigned int wake_mask = QS_SMRESULT | ((flags & SMTO_BLOCK) ? 0 : QS_SENDMESSAGE);
-
-    for (;;)
-    {
-        unsigned int wake_bits = 0;
-
-        SERVER_START_REQ( set_queue_mask )
-        {
-            req->wake_mask    = wake_mask;
-            req->changed_mask = wake_mask;
-            req->skip_wait    = 1;
-            if (!wine_server_call( req )) wake_bits = reply->wake_bits & wake_mask;
-        }
-        SERVER_END_REQ;
-
-        thread_info->wake_mask = thread_info->changed_mask = 0;
-
-        if (wake_bits & QS_SMRESULT) return;  /* got a result */
-        if (wake_bits & QS_SENDMESSAGE)
-        {
-            /* Process the sent message immediately */
-            process_sent_messages();
-            continue;
-        }
-
-        wait_message( 1, &server_queue, INFINITE, wake_mask, 0 );
-    }
-}
 
 /***********************************************************************
- *           retrieve_reply
+ *           handle_internal_message
  *
- * Retrieve a message reply from the server.
+ * Handle an internal Wine message instead of calling the window proc.
  */
-static LRESULT retrieve_reply( const struct send_message_info *info,
-                               size_t reply_size, LRESULT *result )
+LRESULT handle_internal_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 {
-    NTSTATUS status;
-    void *reply_data = NULL;
-
-    if (reply_size)
+    switch(msg)
     {
-        if (!(reply_data = malloc( reply_size )))
-        {
-            WARN( "no memory for reply, will be truncated\n" );
-            reply_size = 0;
-        }
-    }
-    SERVER_START_REQ( get_message_reply )
+    case WM_WINE_DESTROYWINDOW:
+        return destroy_window( hwnd );
+    case WM_WINE_SETWINDOWPOS:
+        if (is_desktop_window( hwnd )) return 0;
+        return set_window_pos( (WINDOWPOS *)lparam, 0, 0 );
+    case WM_WINE_SHOWWINDOW:
+        if (is_desktop_window( hwnd )) return 0;
+        return NtUserShowWindow( hwnd, wparam );
+    case WM_WINE_SETPARENT:
+        if (is_desktop_window( hwnd )) return 0;
+        return HandleToUlong( NtUserSetParent( hwnd, UlongToHandle(wparam) ));
+    case WM_WINE_SETWINDOWLONG:
+        return set_window_long( hwnd, (short)LOWORD(wparam), HIWORD(wparam), lparam, FALSE );
+    case WM_WINE_SETSTYLE:
+        if (is_desktop_window( hwnd )) return 0;
+        return set_window_style( hwnd, wparam, lparam );
+    case WM_WINE_SETACTIVEWINDOW:
+        if (!wparam && NtUserGetForegroundWindow() == hwnd) return 0;
+        return (LRESULT)NtUserSetActiveWindow( (HWND)wparam );
+    case WM_WINE_KEYBOARD_LL_HOOK:
+    case WM_WINE_MOUSE_LL_HOOK:
     {
-        req->cancel = 1;
-        if (reply_size) wine_server_set_reply( req, reply_data, reply_size );
-        if (!(status = wine_server_call( req ))) *result = reply->result;
-        reply_size = wine_server_reply_size( reply );
-    }
-    SERVER_END_REQ;
-    if (!status && reply_size)
-        unpack_reply( info->hwnd, info->msg, info->wparam, info->lparam, reply_data, reply_size );
-
-    free( reply_data );
-
-    TRACE( "hwnd %p msg %x (%s) wp %lx lp %lx got reply %lx (err=%d)\n",
-           info->hwnd, info->msg, debugstr_msg_name(info->msg, info->hwnd), info->wparam,
-           info->lparam, *result, status );
-
-    /* MSDN states that last error is 0 on timeout, but at least NT4 returns ERROR_TIMEOUT */
-    if (status) SetLastError( RtlNtStatusToDosError(status) );
-    return !status;
-}
-
-/***********************************************************************
- *           send_inter_thread_message
- */
-static LRESULT send_inter_thread_message( const struct send_message_info *info, LRESULT *res_ptr )
-{
-    size_t reply_size = 0;
-
-    TRACE( "hwnd %p msg %x (%s) wp %lx lp %lx\n",
-           info->hwnd, info->msg, debugstr_msg_name(info->msg, info->hwnd), info->wparam, info->lparam );
-
-    user_check_not_lock();
-
-    if (!put_message_in_queue( info, &reply_size )) return 0;
-
-    /* there's no reply to wait for on notify/callback messages */
-    if (info->type == MSG_NOTIFY || info->type == MSG_CALLBACK) return 1;
-
-    wait_message_reply( info->flags );
-    return retrieve_reply( info, reply_size, res_ptr );
-}
-
-/***********************************************************************
- *           send_internal_message_timeout
- *
- * Same as SendMessageTimeoutW but sends the message to a specific thread
- * without requiring a window handle. Only works for internal Wine messages.
- */
-LRESULT send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
-                                       UINT msg, WPARAM wparam, LPARAM lparam,
-                                       UINT flags, UINT timeout, PDWORD_PTR res_ptr )
-{
-    LRESULT ret, result = 0;
-
-    assert( msg & 0x80000000 );  /* must be an internal Wine message */
-
-    if (is_exiting_thread( dest_tid )) return 0;
+        struct hook_extra_info *h_extra = (struct hook_extra_info *)lparam;
 
-    if (dest_tid == GetCurrentThreadId())
-    {
-        result = handle_internal_message( 0, msg, wparam, lparam );
-        ret = 1;
+        return call_current_hook( h_extra->handle, HC_ACTION, wparam, h_extra->lparam );
     }
-    else
-    {
-        struct send_message_info info;
-
-        info.type     = dest_pid == GetCurrentProcessId() ? MSG_UNICODE : MSG_OTHER_PROCESS;
-        info.dest_tid = dest_tid;
-        info.hwnd     = 0;
-        info.msg      = msg;
-        info.wparam   = wparam;
-        info.lparam   = lparam;
-        info.flags    = flags;
-        info.timeout  = timeout;
-
-        ret = send_inter_thread_message( &info, &result );
+    case WM_WINE_CLIPCURSOR:
+        if (wparam)
+        {
+            RECT rect;
+            get_clip_cursor( &rect );
+            return user_driver->pClipCursor( &rect );
+        }
+        return user_driver->pClipCursor( NULL );
+    case WM_WINE_UPDATEWINDOWSTATE:
+        update_window_state( hwnd );
+        return 0;
+    default:
+        if (msg >= WM_WINE_FIRST_DRIVER_MSG && msg <= WM_WINE_LAST_DRIVER_MSG)
+            return user_driver->pWindowMessage( hwnd, msg, wparam, lparam );
+        FIXME( "unknown internal message %x\n", msg );
+        return 0;
     }
-    if (ret && res_ptr) *res_ptr = result;
-    return ret;
 }
 
 /***********************************************************************
- *		send_hardware_message
+ *           NtUserWaitForInputIdle (win32u.@)
  */
-NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput, UINT flags )
+DWORD WINAPI NtUserWaitForInputIdle( HANDLE process, DWORD timeout, BOOL wow )
 {
-    struct user_key_state_info *key_state_info = get_user_thread_info()->key_state;
-    struct send_message_info info;
-    int prev_x, prev_y, new_x, new_y;
-    INT counter = global_key_state_counter;
-    USAGE hid_usage_page, hid_usage;
-    NTSTATUS ret;
-    BOOL wait;
-
-    info.type     = MSG_HARDWARE;
-    info.dest_tid = 0;
-    info.hwnd     = hwnd;
-    info.flags    = 0;
-    info.timeout  = 0;
-
-    if (input->type == INPUT_HARDWARE && rawinput->header.dwType == RIM_TYPEHID)
-    {
-        if (input->hi.uMsg == WM_INPUT_DEVICE_CHANGE)
-        {
-            hid_usage_page = ((USAGE *)rawinput->data.hid.bRawData)[0];
-            hid_usage = ((USAGE *)rawinput->data.hid.bRawData)[1];
-        }
-        if (input->hi.uMsg == WM_INPUT && user_callbacks &&
-            !user_callbacks->rawinput_device_get_usages( rawinput->header.hDevice,
-                                                         &hid_usage_page, &hid_usage ))
-        {
-            WARN( "unable to get HID usages for device %p\n", rawinput->header.hDevice );
-            return STATUS_INVALID_HANDLE;
-        }
-    }
-
-    SERVER_START_REQ( send_hardware_message )
-    {
-        req->win        = wine_server_user_handle( hwnd );
-        req->flags      = flags;
-        req->input.type = input->type;
-        switch (input->type)
-        {
-        case INPUT_MOUSE:
-            req->input.mouse.x     = input->mi.dx;
-            req->input.mouse.y     = input->mi.dy;
-            req->input.mouse.data  = input->mi.mouseData;
-            req->input.mouse.flags = input->mi.dwFlags;
-            req->input.mouse.time  = input->mi.time;
-            req->input.mouse.info  = input->mi.dwExtraInfo;
-            break;
-        case INPUT_KEYBOARD:
-            req->input.kbd.vkey  = input->ki.wVk;
-            req->input.kbd.scan  = input->ki.wScan;
-            req->input.kbd.flags = input->ki.dwFlags;
-            req->input.kbd.time  = input->ki.time;
-            req->input.kbd.info  = input->ki.dwExtraInfo;
-            break;
-        case INPUT_HARDWARE:
-            req->input.hw.msg    = input->hi.uMsg;
-            req->input.hw.lparam = MAKELONG( input->hi.wParamL, input->hi.wParamH );
-            switch (input->hi.uMsg)
-            {
-            case WM_INPUT:
-            case WM_INPUT_DEVICE_CHANGE:
-                req->input.hw.rawinput.type = rawinput->header.dwType;
-                switch (rawinput->header.dwType)
-                {
-                case RIM_TYPEHID:
-                    req->input.hw.rawinput.hid.device = HandleToUlong( rawinput->header.hDevice );
-                    req->input.hw.rawinput.hid.param = rawinput->header.wParam;
-                    req->input.hw.rawinput.hid.usage_page = hid_usage_page;
-                    req->input.hw.rawinput.hid.usage = hid_usage;
-                    req->input.hw.rawinput.hid.count = rawinput->data.hid.dwCount;
-                    req->input.hw.rawinput.hid.length = rawinput->data.hid.dwSizeHid;
-                    wine_server_add_data( req, rawinput->data.hid.bRawData,
-                                          rawinput->data.hid.dwCount * rawinput->data.hid.dwSizeHid );
-                    break;
-                default:
-                    assert( 0 );
-                    break;
-                }
-            }
-            break;
-        }
-        if (key_state_info) wine_server_set_reply( req, key_state_info->state,
-                                                   sizeof(key_state_info->state) );
-        ret = wine_server_call( req );
-        wait = reply->wait;
-        prev_x = reply->prev_x;
-        prev_y = reply->prev_y;
-        new_x  = reply->new_x;
-        new_y  = reply->new_y;
-    }
-    SERVER_END_REQ;
-
-    if (!ret)
-    {
-        if (key_state_info)
-        {
-            key_state_info->time    = NtGetTickCount();
-            key_state_info->counter = counter;
-        }
-        if ((flags & SEND_HWMSG_INJECTED) && (prev_x != new_x || prev_y != new_y))
-            user_driver->pSetCursorPos( new_x, new_y );
-    }
-
-    if (wait)
-    {
-        LRESULT ignored;
-        wait_message_reply( 0 );
-        retrieve_reply( &info, 0, &ignored );
-    }
-    return ret;
+    if (!user_callbacks) return 0;
+    return user_callbacks->pWaitForInputIdle( process, timeout );
 }
 
 /**********************************************************************
- *           dispatch_message
+ *	     NtUserGetGUIThreadInfo  (win32u.@)
  */
-LRESULT dispatch_message( const MSG *msg, BOOL ansi )
+BOOL WINAPI NtUserGetGUIThreadInfo( DWORD id, GUITHREADINFO *info )
 {
-    struct win_proc_params params;
-    LRESULT retval = 0;
-
-    /* Process timer messages */
-    if (msg->lParam && msg->message == WM_TIMER)
-    {
-        params.func = (WNDPROC)msg->lParam;
-        params.result = &retval; /* FIXME */
-        if (!init_win_proc_params( &params, msg->hwnd, msg->message,
-                                   msg->wParam, NtGetTickCount(), ansi ))
-            return 0;
-        __TRY
-        {
-            dispatch_win_proc_params( &params, sizeof(params) );
-        }
-        __EXCEPT
-        {
-            retval = 0;
-        }
-        __ENDTRY
-        return retval;
-    }
-    if (msg->message == WM_SYSTIMER)
-    {
-        switch (msg->wParam)
-        {
-            case SYSTEM_TIMER_CARET:
-                toggle_caret( msg->hwnd );
-                return 0;
-
-            case SYSTEM_TIMER_TRACK_MOUSE:
-                update_mouse_tracking_info( msg->hwnd );
-                return 0;
-        }
-    }
-
-    if (!msg->hwnd) return 0;
-
-    spy_enter_message( SPY_DISPATCHMESSAGE, msg->hwnd, msg->message, msg->wParam, msg->lParam );
-
-    if (init_window_call_params( &params, msg->hwnd, msg->message, msg->wParam, msg->lParam,
-                                 &retval, ansi, WMCHAR_MAP_DISPATCHMESSAGE ))
-        dispatch_win_proc_params( &params, sizeof(params) );
-    else if (!is_window( msg->hwnd )) SetLastError( ERROR_INVALID_WINDOW_HANDLE );
-    else SetLastError( ERROR_MESSAGE_SYNC_ONLY );
-
-    spy_exit_message( SPY_RESULT_OK, msg->hwnd, msg->message, retval, msg->wParam, msg->lParam );
+    BOOL ret;
 
-    if (msg->message == WM_PAINT)
+    if (info->cbSize != sizeof(*info))
     {
-        /* send a WM_NCPAINT and WM_ERASEBKGND if the non-client area is still invalid */
-        HRGN hrgn = NtGdiCreateRectRgn( 0, 0, 0, 0 );
-        NtUserGetUpdateRgn( msg->hwnd, hrgn, TRUE );
-        NtGdiDeleteObjectApp( hrgn );
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
     }
-    return retval;
-}
-
-/**********************************************************************
- *           NtUserDispatchMessage  (win32u.@)
- */
-LRESULT WINAPI NtUserDispatchMessage( const MSG *msg )
-{
-    return dispatch_message( msg, FALSE );
-}
-
-static BOOL is_message_broadcastable( UINT msg )
-{
-    return msg < WM_USER || msg >= 0xc000;
-}
-
-/***********************************************************************
- *           broadcast_message
- */
-static BOOL broadcast_message( struct send_message_info *info, DWORD_PTR *res_ptr )
-{
-    HWND *list;
 
-    if (is_message_broadcastable( info->msg ) &&
-        (list = list_window_children( 0, get_desktop_window(), NULL, 0 )))
+    SERVER_START_REQ( get_thread_input )
     {
-        int i;
-
-        for (i = 0; list[i]; i++)
+        req->tid = id;
+        if ((ret = !wine_server_call_err( req )))
         {
-            if (!is_window(list[i])) continue;
-            if ((get_window_long( list[i], GWL_STYLE ) & (WS_POPUP|WS_CHILD)) == WS_CHILD)
-                continue;
-
-            switch(info->type)
-            {
-            case MSG_UNICODE:
-                send_message_timeout( list[i], info->msg, info->wparam, info->lparam,
-                                      info->flags, info->timeout, NULL, FALSE );
-                break;
-            case MSG_ASCII:
-                send_message_timeout( list[i], info->msg, info->wparam, info->lparam,
-                                      info->flags, info->timeout, NULL, TRUE );
-                break;
-            case MSG_NOTIFY:
-                NtUserMessageCall( list[i], info->msg, info->wparam, info->lparam,
-                                   0, NtUserSendNotifyMessage, FALSE );
-                break;
-            case MSG_CALLBACK:
-                {
-                    struct send_message_callback_params params =
-                        { .callback = info->callback, .data = info->data };
-                    NtUserMessageCall( list[i], info->msg, info->wparam, info->lparam,
-                                       &params, NtUserSendMessageCallback, FALSE );
-                    break;
-                }
-            case MSG_POSTED:
-                NtUserPostMessage( list[i], info->msg, info->wparam, info->lparam );
-                break;
-            default:
-                ERR( "bad type %d\n", info->type );
-                break;
-            }
+            info->flags          = 0;
+            info->hwndActive     = wine_server_ptr_handle( reply->active );
+            info->hwndFocus      = wine_server_ptr_handle( reply->focus );
+            info->hwndCapture    = wine_server_ptr_handle( reply->capture );
+            info->hwndMenuOwner  = wine_server_ptr_handle( reply->menu_owner );
+            info->hwndMoveSize   = wine_server_ptr_handle( reply->move_size );
+            info->hwndCaret      = wine_server_ptr_handle( reply->caret );
+            info->rcCaret.left   = reply->rect.left;
+            info->rcCaret.top    = reply->rect.top;
+            info->rcCaret.right  = reply->rect.right;
+            info->rcCaret.bottom = reply->rect.bottom;
+            if (reply->menu_owner) info->flags |= GUI_INMENUMODE;
+            if (reply->move_size) info->flags |= GUI_INMOVESIZE;
+            if (reply->caret) info->flags |= GUI_CARETBLINKING;
         }
     }
-
-    if (res_ptr) *res_ptr = 1;
-    return TRUE;
-}
-
-/***********************************************************************
- *           process_message
- *
- * Backend implementation of the various SendMessage functions.
- */
-static BOOL process_message( struct send_message_info *info, DWORD_PTR *res_ptr, BOOL ansi )
-{
-    struct user_thread_info *thread_info = get_user_thread_info();
-    INPUT_MESSAGE_SOURCE prev_source = thread_info->msg_source;
-    DWORD dest_pid;
-    BOOL ret;
-    LRESULT result;
-
-    if (is_broadcast( info->hwnd )) return broadcast_message( info, res_ptr );
-
-    if (!(info->dest_tid = get_window_thread( info->hwnd, &dest_pid ))) return FALSE;
-    if (is_exiting_thread( info->dest_tid )) return FALSE;
-
-    thread_info->msg_source = msg_source_unavailable;
-    spy_enter_message( SPY_SENDMESSAGE, info->hwnd, info->msg, info->wparam, info->lparam );
-
-    if (info->dest_tid == GetCurrentThreadId())
-    {
-        result = call_window_proc( info->hwnd, info->msg, info->wparam, info->lparam,
-                                   !ansi, TRUE, info->wm_char, FALSE, NULL, 0 );
-        if (info->type == MSG_CALLBACK)
-            call_sendmsg_callback( info->callback, info->hwnd, info->msg, info->data, result );
-        ret = TRUE;
-    }
-    else
-    {
-        if (dest_pid != GetCurrentProcessId() && (info->type == MSG_ASCII || info->type == MSG_UNICODE))
-            info->type = MSG_OTHER_PROCESS;
-        ret = send_inter_thread_message( info, &result );
-    }
-
-    spy_exit_message( SPY_RESULT_OK, info->hwnd, info->msg, result, info->wparam, info->lparam );
-    thread_info->msg_source = prev_source;
-    if (ret && res_ptr) *res_ptr = result;
+    SERVER_END_REQ;
     return ret;
 }
 
@@ -2677,11 +168,12 @@ UINT_PTR WINAPI NtUserSetTimer( HWND hwnd, UINT_PTR id, UINT timeout, TIMERPROC
 /***********************************************************************
  *           NtUserSetSystemTimer (win32u.@)
  */
-UINT_PTR WINAPI NtUserSetSystemTimer( HWND hwnd, UINT_PTR id, UINT timeout )
+UINT_PTR WINAPI NtUserSetSystemTimer( HWND hwnd, UINT_PTR id, UINT timeout, TIMERPROC proc )
 {
     UINT_PTR ret;
+    WNDPROC winproc = 0;
 
-    TRACE( "window %p, id %#lx, timeout %u\n", hwnd, id, timeout );
+    if (proc) winproc = alloc_winproc( (WNDPROC)proc, TRUE );
 
     timeout = min( max( USER_TIMER_MINIMUM, timeout ), USER_TIMER_MAXIMUM );
 
@@ -2691,7 +183,7 @@ UINT_PTR WINAPI NtUserSetSystemTimer( HWND hwnd, UINT_PTR id, UINT timeout )
         req->msg    = WM_SYSTIMER;
         req->id     = id;
         req->rate   = timeout;
-        req->lparam = 0;
+        req->lparam = (ULONG_PTR)winproc;
         if (!wine_server_call_err( req ))
         {
             ret = reply->id;
@@ -2701,6 +193,7 @@ UINT_PTR WINAPI NtUserSetSystemTimer( HWND hwnd, UINT_PTR id, UINT timeout )
     }
     SERVER_END_REQ;
 
+    TRACE( "Added %p %lx %p timeout %d\n", hwnd, id, winproc, timeout );
     return ret;
 }
 
@@ -2738,245 +231,37 @@ BOOL kill_system_timer( HWND hwnd, UINT_PTR id )
     return ret;
 }
 
-static LRESULT send_window_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, BOOL ansi )
-{
-    struct send_message_info info;
-    DWORD_PTR res = 0;
-
-    info.type    = ansi ? MSG_ASCII : MSG_UNICODE;
-    info.hwnd    = hwnd;
-    info.msg     = msg;
-    info.wparam  = wparam;
-    info.lparam  = lparam;
-    info.flags   = SMTO_NORMAL;
-    info.timeout = 0;
-    info.wm_char = WMCHAR_MAP_SENDMESSAGETIMEOUT;
-
-    process_message( &info, &res, ansi );
-    return res;
-}
-
-/* see SendMessageTimeoutW */
-LRESULT send_message_timeout( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                              UINT flags, UINT timeout, DWORD_PTR *res_ptr, BOOL ansi )
-{
-    struct send_message_info info;
-
-    info.type    = ansi ? MSG_ASCII : MSG_UNICODE;
-    info.hwnd    = hwnd;
-    info.msg     = msg;
-    info.wparam  = wparam;
-    info.lparam  = lparam;
-    info.flags   = flags;
-    info.timeout = timeout;
-    info.wm_char = WMCHAR_MAP_SENDMESSAGETIMEOUT;
-
-    return process_message( &info, res_ptr, ansi );
-}
-
 /* see SendMessageW */
 LRESULT send_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 {
-    return send_window_message( hwnd, msg, wparam, lparam, FALSE );
+    /* FIXME: move implementation from user32 */
+    if (!user_callbacks) return 0;
+    return user_callbacks->pSendMessageW( hwnd, msg, wparam, lparam );
 }
 
 /* see SendNotifyMessageW */
 static BOOL send_notify_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, BOOL ansi )
 {
-    struct send_message_info info;
-
-    if (is_pointer_message( msg, wparam ))
-    {
-        SetLastError( ERROR_MESSAGE_SYNC_ONLY );
-        return FALSE;
-    }
-
-    info.type    = MSG_NOTIFY;
-    info.hwnd    = hwnd;
-    info.msg     = msg;
-    info.wparam  = wparam;
-    info.lparam  = lparam;
-    info.flags   = 0;
-    info.wm_char = WMCHAR_MAP_SENDMESSAGETIMEOUT;
-
-    return process_message( &info, NULL, ansi );
-}
-
-/* see SendMessageCallbackW */
-static BOOL send_message_callback( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                   const struct send_message_callback_params *params, BOOL ansi )
-{
-    struct send_message_info info;
-
-    if (is_pointer_message( msg, wparam ))
-    {
-        SetLastError( ERROR_MESSAGE_SYNC_ONLY );
-        return FALSE;
-    }
-
-    info.type     = MSG_CALLBACK;
-    info.hwnd     = hwnd;
-    info.msg      = msg;
-    info.wparam   = wparam;
-    info.lparam   = lparam;
-    info.callback = params->callback;
-    info.data     = params->data;
-    info.flags    = 0;
-    info.wm_char  = WMCHAR_MAP_SENDMESSAGETIMEOUT;
-
-    return process_message( &info, NULL, ansi );
-}
-
-/***********************************************************************
- *           NtUserPostMessage  (win32u.@)
- */
-BOOL WINAPI NtUserPostMessage( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    struct send_message_info info;
-
-    if (is_pointer_message( msg, wparam ))
-    {
-        SetLastError( ERROR_MESSAGE_SYNC_ONLY );
-        return FALSE;
-    }
-
-    TRACE( "hwnd %p msg %x (%s) wp %lx lp %lx\n",
-           hwnd, msg, debugstr_msg_name(msg, hwnd), wparam, lparam );
-
-    info.type   = MSG_POSTED;
-    info.hwnd   = hwnd;
-    info.msg    = msg;
-    info.wparam = wparam;
-    info.lparam = lparam;
-    info.flags  = 0;
-
-    if (is_broadcast(hwnd)) return broadcast_message( &info, NULL );
-
-    if (!hwnd) return NtUserPostThreadMessage( GetCurrentThreadId(), msg, wparam, lparam );
-
-    if (!(info.dest_tid = get_window_thread( hwnd, NULL ))) return FALSE;
-
-    if (is_exiting_thread( info.dest_tid )) return TRUE;
-
-    return put_message_in_queue( &info, NULL );
+    return user_callbacks && user_callbacks->pSendNotifyMessageW( hwnd, msg, wparam, lparam );
 }
 
-/**********************************************************************
- *           NtUserPostThreadMessage  (win32u.@)
- */
-BOOL WINAPI NtUserPostThreadMessage( DWORD thread, UINT msg, WPARAM wparam, LPARAM lparam )
+/* see PostMessageW */
+LRESULT post_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
 {
-    struct send_message_info info;
-
-    if (is_pointer_message( msg, wparam ))
-    {
-        SetLastError( ERROR_MESSAGE_SYNC_ONLY );
-        return FALSE;
-    }
-    if (is_exiting_thread( thread )) return TRUE;
-
-    info.type     = MSG_POSTED;
-    info.dest_tid = thread;
-    info.hwnd     = 0;
-    info.msg      = msg;
-    info.wparam   = wparam;
-    info.lparam   = lparam;
-    info.flags    = 0;
-    return put_message_in_queue( &info, NULL );
+    /* FIXME: move implementation from user32 */
+    if (!user_callbacks) return 0;
+    return user_callbacks->pPostMessageW( hwnd, msg, wparam, lparam );
 }
 
-LRESULT WINAPI NtUserMessageCall( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                  void *result_info, DWORD type, BOOL ansi )
+BOOL WINAPI NtUserMessageCall( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
+                               ULONG_PTR result_info, DWORD type, BOOL ansi )
 {
     switch (type)
     {
-    case NtUserDesktopWindowProc:
-        return desktop_window_proc( hwnd, msg, wparam, lparam );
-    case NtUserDefWindowProc:
-        return default_window_proc( hwnd, msg, wparam, lparam, ansi );
-    case NtUserCallWindowProc:
-        return init_win_proc_params( (struct win_proc_params *)result_info, hwnd, msg,
-                                     wparam, lparam, ansi );
-    case NtUserSendMessage:
-        return send_window_message( hwnd, msg, wparam, lparam, ansi );
-    case NtUserSendMessageTimeout:
-        {
-            struct send_message_timeout_params *params = (void *)result_info;
-            DWORD_PTR res = 0;
-            params->result = send_message_timeout( hwnd, msg, wparam, lparam, params->flags,
-                                                   params->timeout, &res, ansi );
-            return res;
-        }
-    case NtUserSendNotifyMessage:
+    case FNID_SENDNOTIFYMESSAGE:
         return send_notify_message( hwnd, msg, wparam, lparam, ansi );
-    case NtUserSendMessageCallback:
-        return send_message_callback( hwnd, msg, wparam, lparam, (void *)result_info, ansi );
-    case NtUserClipboardWindowProc:
-        return user_driver->pClipboardWindowProc( hwnd, msg, wparam, lparam );
-    case NtUserSpyEnter:
-        spy_enter_message( ansi, hwnd, msg, wparam, lparam );
-        return 0;
-    case NtUserSpyExit:
-        spy_exit_message( ansi, hwnd, msg, (LPARAM)result_info, wparam, lparam );
-        return 0;
     default:
-        FIXME( "%p %x %lx %lx %p %x %x\n", hwnd, msg, wparam, lparam, result_info, type, ansi );
+        FIXME( "%p %x %lx %lx %lx %x %x\n", hwnd, msg, wparam, lparam, result_info, type, ansi );
     }
     return 0;
 }
-
-/***********************************************************************
- *           NtUserTranslateMessage (win32u.@)
- */
-BOOL WINAPI NtUserTranslateMessage( const MSG *msg, UINT flags )
-{
-    UINT message;
-    WCHAR wp[8];
-    BYTE state[256];
-    INT len;
-
-    if (flags) FIXME( "unsupported flags %x\n", flags );
-
-    if (msg->message < WM_KEYFIRST || msg->message > WM_KEYLAST) return FALSE;
-    if (msg->message != WM_KEYDOWN && msg->message != WM_SYSKEYDOWN) return TRUE;
-
-    TRACE_(key)( "Translating key %s (%04lX), scancode %04x\n",
-                 debugstr_vkey_name( msg->wParam ), msg->wParam, HIWORD(msg->lParam) );
-
-    switch (msg->wParam)
-    {
-    case VK_PACKET:
-        message = (msg->message == WM_KEYDOWN) ? WM_CHAR : WM_SYSCHAR;
-        TRACE_(key)( "PostMessageW(%p,%s,%04x,%08x)\n", msg->hwnd,
-                     debugstr_msg_name( message, msg->hwnd ),
-                     HIWORD(msg->lParam), LOWORD(msg->lParam) );
-        NtUserPostMessage( msg->hwnd, message, HIWORD(msg->lParam), LOWORD(msg->lParam) );
-        return TRUE;
-
-    case VK_PROCESSKEY:
-        return user_callbacks && user_callbacks->pImmTranslateMessage( msg->hwnd, msg->message,
-                                                                       msg->wParam, msg->lParam );
-    }
-
-    NtUserGetKeyboardState( state );
-    len = NtUserToUnicodeEx( msg->wParam, HIWORD(msg->lParam), state, wp, ARRAY_SIZE(wp), 0,
-                             NtUserGetKeyboardLayout(0) );
-    if (len == -1)
-    {
-        message = msg->message == WM_KEYDOWN ? WM_DEADCHAR : WM_SYSDEADCHAR;
-        TRACE_(key)( "-1 -> PostMessageW(%p,%s,%04x,%08lx)\n",
-                     msg->hwnd, debugstr_msg_name( message, msg->hwnd ), wp[0], msg->lParam );
-        NtUserPostMessage( msg->hwnd, message, wp[0], msg->lParam );
-    }
-    else if (len > 0)
-    {
-        INT i;
-
-        message = msg->message == WM_KEYDOWN ? WM_CHAR : WM_SYSCHAR;
-        TRACE_(key)( "%d -> PostMessageW(%p,%s,<x>,%08lx) for <x> in %s\n", len, msg->hwnd,
-                     debugstr_msg_name(message, msg->hwnd), msg->lParam, debugstr_wn(wp, len) );
-        for (i = 0; i < len; i++)
-            NtUserPostMessage( msg->hwnd, message, wp[i], msg->lParam );
-    }
-    return TRUE;
-}
diff --git a/dlls/win32u/ntgdi_private.h b/dlls/win32u/ntgdi_private.h
index b04f7a87e34..75cddc00fb3 100644
--- a/dlls/win32u/ntgdi_private.h
+++ b/dlls/win32u/ntgdi_private.h
@@ -159,8 +159,6 @@ extern void free_brush_pattern( struct brush_pattern *pattern ) DECLSPEC_HIDDEN;
 /* clipping.c */
 extern BOOL clip_device_rect( DC *dc, RECT *dst, const RECT *src ) DECLSPEC_HIDDEN;
 extern BOOL clip_visrect( DC *dc, RECT *dst, const RECT *src ) DECLSPEC_HIDDEN;
-extern void set_visible_region( HDC hdc, HRGN hrgn, const RECT *vis_rect,
-                                const RECT *device_rect, struct window_surface *surface );
 extern void update_dc_clipping( DC * dc ) DECLSPEC_HIDDEN;
 
 /* Return the total DC region (if any) */
@@ -339,6 +337,7 @@ extern int add_gdi_face( const WCHAR *family_name, const WCHAR *second_name,
                          DWORD ntmflags, DWORD version, DWORD flags,
                          const struct bitmap_font_size *size ) DECLSPEC_HIDDEN;
 extern UINT font_init(void) DECLSPEC_HIDDEN;
+extern UINT get_acp(void) DECLSPEC_HIDDEN;
 extern CPTABLEINFO *get_cptable( WORD cp ) DECLSPEC_HIDDEN;
 extern const struct font_backend_funcs *init_freetype_lib(void) DECLSPEC_HIDDEN;
 
@@ -381,6 +380,7 @@ extern void GDI_ReleaseObj( HGDIOBJ ) DECLSPEC_HIDDEN;
 extern UINT GDI_get_ref_count( HGDIOBJ handle ) DECLSPEC_HIDDEN;
 extern HGDIOBJ GDI_inc_ref_count( HGDIOBJ handle ) DECLSPEC_HIDDEN;
 extern BOOL GDI_dec_ref_count( HGDIOBJ handle ) DECLSPEC_HIDDEN;
+extern HGDIOBJ get_stock_object( INT obj ) DECLSPEC_HIDDEN;
 extern DWORD get_gdi_object_type( HGDIOBJ obj ) DECLSPEC_HIDDEN;
 extern void make_gdi_object_system( HGDIOBJ handle, BOOL set ) DECLSPEC_HIDDEN;
 
@@ -531,13 +531,38 @@ static inline DC *get_physdev_dc( PHYSDEV dev )
     return get_nulldrv_dc( dev );
 }
 
+BOOL WINAPI FontIsLinked(HDC);
+
+BOOL WINAPI SetVirtualResolution(HDC hdc, DWORD horz_res, DWORD vert_res, DWORD horz_size, DWORD vert_size);
+
+static inline BOOL is_rect_empty( const RECT *rect )
+{
+    return (rect->left >= rect->right || rect->top >= rect->bottom);
+}
+
 static inline BOOL intersect_rect( RECT *dst, const RECT *src1, const RECT *src2 )
 {
     dst->left   = max( src1->left, src2->left );
     dst->top    = max( src1->top, src2->top );
     dst->right  = min( src1->right, src2->right );
     dst->bottom = min( src1->bottom, src2->bottom );
-    return !IsRectEmpty( dst );
+    return !is_rect_empty( dst );
+}
+
+static inline void offset_rect( RECT *rect, int offset_x, int offset_y )
+{
+    rect->left   += offset_x;
+    rect->top    += offset_y;
+    rect->right  += offset_x;
+    rect->bottom += offset_y;
+}
+
+static inline void set_rect( RECT *rect, int left, int top, int right, int bottom )
+{
+    rect->left = left;
+    rect->top = top;
+    rect->right = right;
+    rect->bottom = bottom;
 }
 
 static inline void order_rect( RECT *rect )
@@ -584,9 +609,9 @@ static inline void reset_bounds( RECT *bounds )
 
 static inline void union_rect( RECT *dest, const RECT *src1, const RECT *src2 )
 {
-    if (IsRectEmpty( src1 ))
+    if (is_rect_empty( src1 ))
     {
-        if (IsRectEmpty( src2 ))
+        if (is_rect_empty( src2 ))
         {
             reset_bounds( dest );
             return;
@@ -595,7 +620,7 @@ static inline void union_rect( RECT *dest, const RECT *src1, const RECT *src2 )
     }
     else
     {
-        if (IsRectEmpty( src2 )) *dest = *src1;
+        if (is_rect_empty( src2 )) *dest = *src1;
         else
         {
             dest->left   = min( src1->left, src2->left );
@@ -608,7 +633,7 @@ static inline void union_rect( RECT *dest, const RECT *src1, const RECT *src2 )
 
 static inline void add_bounds_rect( RECT *bounds, const RECT *rect )
 {
-    if (IsRectEmpty( rect )) return;
+    if (is_rect_empty( rect )) return;
     bounds->left   = min( bounds->left, rect->left );
     bounds->top    = min( bounds->top, rect->top );
     bounds->right  = max( bounds->right, rect->right );
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index e39e3f54169..ac562773262 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -28,38 +28,37 @@
 struct dce;
 struct tagWND;
 
-struct hardware_msg_data;
-
 struct user_callbacks
 {
+    BOOL (WINAPI *pAdjustWindowRectEx)( RECT *, DWORD, BOOL, DWORD );
+    HANDLE (WINAPI *pCopyImage)( HANDLE, UINT, INT, INT, UINT );
+    BOOL (WINAPI *pDestroyCaret)(void);
+    BOOL (WINAPI *pDestroyMenu)( HMENU );
     BOOL (WINAPI *pEndMenu)(void);
-    BOOL (WINAPI *pImmProcessKey)(HWND, HKL, UINT, LPARAM, DWORD);
-    BOOL (WINAPI *pImmTranslateMessage)(HWND, UINT, WPARAM, LPARAM);
-    NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,BOOLEAN,const LARGE_INTEGER*);
+    BOOL (WINAPI *pHideCaret)( HWND hwnd );
+    BOOL (WINAPI *pPostMessageW)( HWND, UINT, WPARAM, LPARAM );
+    UINT (WINAPI *pSendInput)( UINT count, INPUT *inputs, int size );
+    LRESULT (WINAPI *pSendMessageTimeoutW)( HWND, UINT, WPARAM, LPARAM, UINT, UINT, PDWORD_PTR );
+    LRESULT (WINAPI *pSendMessageW)( HWND, UINT, WPARAM, LPARAM );
+    BOOL (WINAPI *pSendNotifyMessageW)( HWND, UINT, WPARAM, LPARAM );
+    BOOL (WINAPI *pShowCaret)( HWND hwnd );
+    DWORD (WINAPI *pWaitForInputIdle)( HANDLE, DWORD );
     void (CDECL *free_win_ptr)( struct tagWND *win );
-    HMENU (CDECL *get_sys_menu)( HWND hwnd, HMENU popup );
     HWND (CDECL *is_menu_active)(void);
     void (CDECL *notify_ime)( HWND hwnd, UINT param );
-    BOOL (CDECL *post_dde_message)( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, DWORD dest_tid,
-                                    DWORD type );
-    BOOL (CDECL *process_rawinput_message)( MSG *msg, UINT hw_id, const struct hardware_msg_data *msg_data );
-    BOOL (CDECL *rawinput_device_get_usages)(HANDLE handle, USHORT *usage_page, USHORT *usage);
+    void (CDECL *register_builtin_classes)(void);
+    LRESULT (WINAPI *send_ll_message)( DWORD, DWORD, UINT, WPARAM, LPARAM, UINT, UINT, PDWORD_PTR );
     void (WINAPI *set_standard_scroll_painted)( HWND hwnd, INT bar, BOOL visible );
-    BOOL (CDECL *unpack_dde_message)( HWND hwnd, UINT message, WPARAM *wparam, LPARAM *lparam,
-                                      void **buffer, size_t size );
-    BOOL (WINAPI *register_imm)( HWND hwnd );
+    void (CDECL *set_user_driver)( void *, UINT );
+    BOOL (CDECL *set_window_pos)( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                  const RECT *window_rect, const RECT *client_rect,
+                                  const RECT *valid_rects );
     void (WINAPI *unregister_imm)( HWND hwnd );
 };
 
 #define WM_SYSTIMER         0x0118
 #define WM_POPUPSYSTEMMENU  0x0313
 
-enum system_timer_id
-{
-    SYSTEM_TIMER_TRACK_MOUSE = 0xfffa,
-    SYSTEM_TIMER_CARET = 0xffff,
-};
-
 struct user_object
 {
     HANDLE       handle;
@@ -70,6 +69,7 @@ struct user_object
 
 HANDLE alloc_user_handle( struct user_object *ptr, unsigned int type ) DECLSPEC_HIDDEN;
 void *get_user_handle_ptr( HANDLE handle, unsigned int type ) DECLSPEC_HIDDEN;
+void set_user_handle_ptr( HANDLE handle, struct user_object *ptr ) DECLSPEC_HIDDEN;
 void release_user_handle_ptr( void *ptr ) DECLSPEC_HIDDEN;
 void *free_user_handle( HANDLE handle, unsigned int type ) DECLSPEC_HIDDEN;
 
@@ -137,7 +137,6 @@ static inline BOOL is_broadcast( HWND hwnd )
 /* no attempt is made to keep the layout compatible with the Windows one */
 struct user_thread_info
 {
-    struct ntuser_thread_info     client_info;            /* Data shared with client */
     HANDLE                        server_queue;           /* Handle to server-side queue */
     DWORD                         wake_mask;              /* Current queue wake mask */
     DWORD                         changed_mask;           /* Current queue changed mask */
@@ -151,9 +150,14 @@ struct user_thread_info
     INPUT_MESSAGE_SOURCE          msg_source;             /* Message source for current message */
     struct received_message_info *receive_info;           /* Message being currently received */
     struct wm_char_mapping_data  *wmchar_data;            /* Data for WM_CHAR mappings */
+    DWORD                         GetMessageTimeVal;      /* Value for GetMessageTime */
+    DWORD                         GetMessagePosVal;       /* Value for GetMessagePos */
+    ULONG_PTR                     GetMessageExtraInfoVal; /* Value for GetMessageExtraInfo */
     struct user_key_state_info   *key_state;              /* Cache of global key state */
     HKL                           kbd_layout;             /* Current keyboard layout */
     DWORD                         kbd_layout_id;          /* Current keyboard layout ID */
+    HWND                          top_window;             /* Desktop window */
+    HWND                          msg_window;             /* HWND_MESSAGE parent window */
     struct rawinput_thread_data  *rawinput;               /* RawInput thread local data / buffer */
     UINT                          spy_indent;             /* Current spy indent */
 };
@@ -195,55 +199,6 @@ enum builtin_winprocs
     NB_BUILTIN_AW_WINPROCS = WINPROC_DESKTOP
 };
 
-/* FIXME: make it private to menu.c */
-
-/* Menu item structure */
-typedef struct menu_item
-{
-    /* ----------- MENUITEMINFO Stuff ----------- */
-    UINT      fType;          /* Item type. */
-    UINT      fState;         /* Item state.  */
-    UINT_PTR  wID;            /* Item id.  */
-    HMENU     hSubMenu;       /* Pop-up menu.  */
-    HBITMAP   hCheckBit;      /* Bitmap when checked.  */
-    HBITMAP   hUnCheckBit;    /* Bitmap when unchecked.  */
-    LPWSTR    text;           /* Item text. */
-    ULONG_PTR dwItemData;     /* Application defined.  */
-    LPWSTR    dwTypeData;     /* depends on fMask */
-    HBITMAP   hbmpItem;       /* bitmap */
-    /* ----------- Wine stuff ----------- */
-    RECT      rect;           /* Item area (relative to the items_rect),
-                               * see MENU_AdjustMenuItemRect(). */
-    UINT      xTab;           /* X position of text after Tab */
-    SIZE      bmpsize;        /* size needed for the HBMMENU_CALLBACK bitmap */
-} MENUITEM;
-
-typedef struct
-{
-    struct user_object obj;
-    WORD        wFlags;       /* Menu flags (MF_POPUP, MF_SYSMENU) */
-    WORD	Width;        /* Width of the whole menu */
-    WORD	Height;       /* Height of the whole menu */
-    UINT        nItems;       /* Number of items in the menu */
-    HWND        hWnd;         /* Window containing the menu */
-    struct menu_item *items;  /* Array of menu items */
-    UINT        FocusedItem;  /* Currently focused item */
-    HWND	hwndOwner;    /* window receiving the messages for ownerdraw */
-    BOOL        bScrolling;   /* Scroll arrows are active */
-    UINT        nScrollPos;   /* Current scroll position */
-    UINT        nTotalHeight; /* Total height of menu items inside menu */
-    RECT        items_rect;   /* Rectangle within which the items lie.  Excludes margins and scroll arrows */
-    LONG        refcount;
-    /* ------------ MENUINFO members ------ */
-    DWORD	dwStyle;	/* Extended menu style */
-    UINT	cyMax;		/* max height of the whole menu, 0 is screen height */
-    HBRUSH	hbrBack;	/* brush for menu background */
-    DWORD	dwContextHelpID;
-    ULONG_PTR	dwMenuData;	/* application defined value */
-    HMENU       hSysMenuOwner;  /* Handle to the dummy sys menu holder */
-    WORD        textOffset;     /* Offset of text when items have both bitmaps and text */
-} POPUPMENU, *LPPOPUPMENU;
-
 /* FIXME: make it private to class.c */
 typedef struct tagWINDOWPROC
 {
@@ -256,6 +211,18 @@ typedef struct tagWINDOWPROC
 
 #define MAX_ATOM_LEN 255
 
+/* FIXME: make it private to dce.c */
+struct dce
+{
+    struct list entry;         /* entry in global DCE list */
+    HDC         hdc;
+    HWND        hwnd;
+    HRGN        clip_rgn;
+    DWORD       flags;
+    LONG        count;         /* usage count; 0 or 1 for cache DCEs, always 1 for window DCEs,
+                                  always >= 1 for class DCEs */
+};
+
 /* Built-in class names (see _Undocumented_Windows_ p.418) */
 #define POPUPMENU_CLASS_ATOM MAKEINTATOM(32768)  /* PopupMenu */
 #define DESKTOP_CLASS_ATOM   MAKEINTATOM(32769)  /* Desktop */
@@ -263,45 +230,38 @@ typedef struct tagWINDOWPROC
 #define WINSWITCH_CLASS_ATOM MAKEINTATOM(32771)  /* WinSwitch */
 #define ICONTITLE_CLASS_ATOM MAKEINTATOM(32772)  /* IconTitle */
 
-/* message spy definitions */
-
-#define SPY_DISPATCHMESSAGE       0x0100
-#define SPY_SENDMESSAGE           0x0101
-#define SPY_DEFWNDPROC            0x0102
-
-#define SPY_RESULT_OK             0x0001
-#define SPY_RESULT_DEFWND         0x0002
-
-/* info about the message currently being received by the current thread */
-struct received_message_info
+typedef struct tagCLASS
 {
-    UINT  type;
-    MSG   msg;
-    UINT  flags;  /* InSendMessageEx return flags */
-    struct received_message_info *prev;
-};
-
-extern const char *debugstr_msg_name( UINT msg, HWND hwnd ) DECLSPEC_HIDDEN;
-extern const char *debugstr_vkey_name( WPARAM wParam ) DECLSPEC_HIDDEN;
-extern void spy_enter_message( INT flag, HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
-extern void spy_exit_message( INT flag, HWND hwnd, UINT msg,
-                              LRESULT lreturn, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
+    struct list      entry;         /* Entry in class list */
+    UINT             style;         /* Class style */
+    BOOL             local;         /* Local class? */
+    WNDPROC          winproc;       /* Window procedure */
+    INT              cbClsExtra;    /* Class extra bytes */
+    INT              cbWndExtra;    /* Window extra bytes */
+    struct client_menu_name menu_name; /* Default menu name */
+    struct dce      *dce;           /* Opaque pointer to class DCE */
+    UINT_PTR         instance;      /* Module that created the task */
+    HICON            hIcon;         /* Default icon */
+    HICON            hIconSm;       /* Default small icon */
+    HICON            hIconSmIntern; /* Internal small icon, derived from hIcon */
+    HCURSOR          hCursor;       /* Default cursor */
+    HBRUSH           hbrBackground; /* Default background */
+    ATOM             atomName;      /* Name of the class */
+    WCHAR            name[MAX_ATOM_LEN + 1];
+    WCHAR           *basename;      /* Base name for redirected classes, pointer within 'name'. */
+} CLASS;
 
 /* class.c */
-extern HINSTANCE user32_module DECLSPEC_HIDDEN;
 WNDPROC alloc_winproc( WNDPROC func, BOOL ansi ) DECLSPEC_HIDDEN;
 WINDOWPROC *get_winproc_ptr( WNDPROC handle ) DECLSPEC_HIDDEN;
 BOOL is_winproc_unicode( WNDPROC proc, BOOL def_val ) DECLSPEC_HIDDEN;
 DWORD get_class_long( HWND hwnd, INT offset, BOOL ansi ) DECLSPEC_HIDDEN;
-WNDPROC get_class_winproc( struct tagCLASS *class ) DECLSPEC_HIDDEN;
 ULONG_PTR get_class_long_ptr( HWND hwnd, INT offset, BOOL ansi ) DECLSPEC_HIDDEN;
 WORD get_class_word( HWND hwnd, INT offset ) DECLSPEC_HIDDEN;
 ATOM get_int_atom_value( UNICODE_STRING *name ) DECLSPEC_HIDDEN;
 WNDPROC get_winproc( WNDPROC proc, BOOL ansi ) DECLSPEC_HIDDEN;
-void get_winproc_params( struct win_proc_params *params ) DECLSPEC_HIDDEN;
 struct dce *get_class_dce( struct tagCLASS *class ) DECLSPEC_HIDDEN;
 struct dce *set_class_dce( struct tagCLASS *class, struct dce *dce ) DECLSPEC_HIDDEN;
-extern void register_builtin_classes(void) DECLSPEC_HIDDEN;
 
 /* cursoricon.c */
 HICON alloc_cursoricon_handle( BOOL is_icon ) DECLSPEC_HIDDEN;
@@ -310,6 +270,9 @@ HICON alloc_cursoricon_handle( BOOL is_icon ) DECLSPEC_HIDDEN;
 extern void free_dce( struct dce *dce, HWND hwnd ) DECLSPEC_HIDDEN;
 extern void invalidate_dce( WND *win, const RECT *extra_rect ) DECLSPEC_HIDDEN;
 
+/* message.c */
+LRESULT handle_internal_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
+
 /* window.c */
 HANDLE alloc_user_handle( struct user_object *ptr, unsigned int type ) DECLSPEC_HIDDEN;
 void *free_user_handle( HANDLE handle, unsigned int type ) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/painting.c b/dlls/win32u/painting.c
index 9b973eeb757..87871e23ff0 100644
--- a/dlls/win32u/painting.c
+++ b/dlls/win32u/painting.c
@@ -112,7 +112,7 @@ BOOL CDECL nulldrv_InvertRgn( PHYSDEV dev, HRGN rgn )
     INT prev_rop = dc->attr->rop_mode;
     BOOL ret;
     dc->attr->rop_mode = R2_NOT;
-    ret = NtGdiFillRgn( dev->hdc, rgn, GetStockObject(BLACK_BRUSH) );
+    ret = NtGdiFillRgn( dev->hdc, rgn, get_stock_object(BLACK_BRUSH) );
     dc->attr->rop_mode = prev_rop;
     return ret;
 }
@@ -958,7 +958,7 @@ BOOL WINAPI NtUserScrollDC( HDC hdc, INT dx, INT dy, const RECT *scroll, const R
     else
         NtGdiGetAppClipBox( hdc, &clip_rect );
     src_rect = clip_rect;
-    OffsetRect( &clip_rect, -dx, -dy );
+    offset_rect( &clip_rect, -dx, -dy );
     intersect_rect( &src_rect, &src_rect, &clip_rect );
 
     /* if an scroll rectangle is specified, only the pixels within that
diff --git a/dlls/win32u/palette.c b/dlls/win32u/palette.c
index 217a96bb027..2a394ba7eba 100644
--- a/dlls/win32u/palette.c
+++ b/dlls/win32u/palette.c
@@ -196,7 +196,7 @@ static UINT set_palette_entries( HPALETTE hpalette, UINT start, UINT count,
 
     TRACE("hpal=%p,start=%i,count=%i\n",hpalette,start,count );
 
-    if (hpalette == GetStockObject(DEFAULT_PALETTE)) return 0;
+    if (hpalette == get_stock_object(DEFAULT_PALETTE)) return 0;
     palPtr = GDI_GetObjPtr( hpalette, NTGDI_OBJ_PAL );
     if (!palPtr) return 0;
 
@@ -249,7 +249,7 @@ static BOOL animate_palette( HPALETTE hPal, UINT StartIndex, UINT NumEntries,
 {
     TRACE("%p (%i - %i)\n", hPal, StartIndex,StartIndex+NumEntries);
 
-    if( hPal != GetStockObject(DEFAULT_PALETTE) )
+    if( hPal != get_stock_object(DEFAULT_PALETTE) )
     {
         PALETTEOBJ * palPtr;
         UINT pal_entries;
@@ -405,7 +405,7 @@ COLORREF CDECL nulldrv_GetNearestColor( PHYSDEV dev, COLORREF color )
         PALETTEENTRY entry;
         HPALETTE hpal = dc->hPalette;
 
-        if (!hpal) hpal = GetStockObject( DEFAULT_PALETTE );
+        if (!hpal) hpal = get_stock_object( DEFAULT_PALETTE );
         if (spec_type == 2) /* PALETTERGB */
             index = NtGdiGetNearestPaletteIndex( hpal, color );
         else  /* PALETTEINDEX */
@@ -514,7 +514,7 @@ HPALETTE WINAPI NtUserSelectPalette( HDC hdc, HPALETTE hpal, WORD bkg )
 
     TRACE("%p %p\n", hdc, hpal );
 
-    if (!bkg && hpal != GetStockObject( DEFAULT_PALETTE ))
+    if (!bkg && hpal != get_stock_object( DEFAULT_PALETTE ))
     {
         HWND hwnd = NtUserWindowFromDC( hdc );
         if (hwnd)
@@ -555,7 +555,7 @@ UINT realize_palette( HDC hdc )
 
     /* FIXME: move primary palette handling from user32 */
 
-    if( dc->hPalette == GetStockObject( DEFAULT_PALETTE ))
+    if( dc->hPalette == get_stock_object( DEFAULT_PALETTE ))
     {
         PHYSDEV physdev = GET_DC_PHYSDEV( dc, pRealizeDefaultPalette );
         realized = physdev->funcs->pRealizeDefaultPalette( physdev );
@@ -583,8 +583,9 @@ UINT realize_palette( HDC hdc )
     {
         /* send palette change notification */
         HWND hwnd = NtUserWindowFromDC( hdc );
-        if (hwnd) send_message_timeout( HWND_BROADCAST, WM_PALETTECHANGED, HandleToUlong(hwnd), 0,
-                                        SMTO_ABORTIFHUNG, 2000, NULL, FALSE );
+        if (hwnd) user_callbacks->pSendMessageTimeoutW( HWND_BROADCAST, WM_PALETTECHANGED,
+                                                        HandleToUlong(hwnd), 0, SMTO_ABORTIFHUNG,
+                                                        2000, NULL );
     }
     return realized;
 }
diff --git a/dlls/win32u/path.c b/dlls/win32u/path.c
index 0032ee1a5ab..93a124953af 100644
--- a/dlls/win32u/path.c
+++ b/dlls/win32u/path.c
@@ -2120,9 +2120,6 @@ const struct gdi_dc_funcs path_driver =
     NULL,                               /* pStrokePath */
     NULL,                               /* pUnrealizePalette */
     NULL,                               /* pD3DKMTCheckVidPnExclusiveOwnership */
-    NULL,                               /* pD3DKMTCloseAdapter */
-    NULL,                               /* pD3DKMTOpenAdapterFromLuid */
-    NULL,                               /* pD3DKMTQueryVideoMemoryInfo */
     NULL,                               /* pD3DKMTSetVidPnSourceOwner */
     GDI_PRIORITY_PATH_DRV               /* priority */
 };
diff --git a/dlls/win32u/pen.c b/dlls/win32u/pen.c
index af371108c46..a6a14163827 100644
--- a/dlls/win32u/pen.c
+++ b/dlls/win32u/pen.c
@@ -96,7 +96,7 @@ HPEN create_pen( INT style, INT width, COLORREF color )
 HPEN WINAPI NtGdiCreatePen( INT style, INT width, COLORREF color, HBRUSH brush )
 {
     if (brush) FIXME( "brush not supported\n" );
-    if (style == PS_NULL) return GetStockObject( NULL_PEN );
+    if (style == PS_NULL) return get_stock_object( NULL_PEN );
     return create_pen( style, width, color );
 }
 
diff --git a/dlls/win32u/syscall.c b/dlls/win32u/syscall.c
index a5ad95cd4b6..d19ab54fa90 100644
--- a/dlls/win32u/syscall.c
+++ b/dlls/win32u/syscall.c
@@ -51,8 +51,11 @@ static void * const syscalls[] =
     NtGdiCreateRectRgn,
     NtGdiCreateRoundRectRgn,
     NtGdiCreateSolidBrush,
+    NtGdiDdDDICloseAdapter,
     NtGdiDdDDICreateDevice,
+    NtGdiDdDDIOpenAdapterFromDeviceName,
     NtGdiDdDDIOpenAdapterFromHdc,
+    NtGdiDdDDIOpenAdapterFromLuid,
     NtGdiDdDDIQueryStatistics,
     NtGdiDdDDISetQueuedLimit,
     NtGdiDeleteClientObj,
@@ -103,23 +106,16 @@ static void * const syscalls[] =
     NtUserAddClipboardFormatListener,
     NtUserAttachThreadInput,
     NtUserBuildHwndList,
-    NtUserCallMsgFilter,
-    NtUserCheckMenuItem,
-    NtUserChildWindowFromPointEx,
     NtUserCloseDesktop,
     NtUserCloseWindowStation,
     NtUserCopyAcceleratorTable,
     NtUserCreateAcceleratorTable,
     NtUserCreateDesktopEx,
     NtUserCreateWindowStation,
-    NtUserDeleteMenu,
     NtUserDestroyAcceleratorTable,
     NtUserFindExistingCursorIcon,
-    NtUserFindWindowEx,
     NtUserGetAncestor,
     NtUserGetAtomName,
-    NtUserGetCaretBlinkTime,
-    NtUserGetCaretPos,
     NtUserGetClassName,
     NtUserGetClipboardFormatName,
     NtUserGetClipboardOwner,
@@ -137,7 +133,6 @@ static void * const syscalls[] =
     NtUserGetKeyboardLayoutName,
     NtUserGetKeyboardState,
     NtUserGetLayeredWindowAttributes,
-    NtUserGetMenuItemRect,
     NtUserGetMouseMovePointsEx,
     NtUserGetObjectInformation,
     NtUserGetOpenClipboardWindow,
@@ -155,11 +150,8 @@ static void * const syscalls[] =
     NtUserOpenInputDesktop,
     NtUserOpenWindowStation,
     NtUserRemoveClipboardFormatListener,
-    NtUserRemoveMenu,
     NtUserRemoveProp,
     NtUserSetKeyboardState,
-    NtUserSetMenuContextHelpId,
-    NtUserSetMenuDefaultItem,
     NtUserSetObjectInformation,
     NtUserSetProcessDpiAwarenessContext,
     NtUserSetProcessWindowStation,
@@ -169,8 +161,6 @@ static void * const syscalls[] =
     NtUserSetTimer,
     NtUserSetWinEventHook,
     NtUserSetWindowsHookEx,
-    NtUserThunkedMenuInfo,
-    NtUserThunkedMenuItemInfo,
     NtUserUnhookWinEvent,
     NtUserUnhookWindowsHookEx,
     NtUserWindowFromDC,
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index b68bfa3a7ce..d43fa30e0e4 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -230,8 +230,6 @@ static struct list monitors = LIST_INIT(monitors);
 static INT64 last_query_display_time;
 static pthread_mutex_t display_lock = PTHREAD_MUTEX_INITIALIZER;
 
-BOOL enable_thunk_lock = FALSE;
-
 static struct monitor virtual_monitor =
 {
     .handle = NULLDRV_DEFAULT_HMONITOR,
@@ -1393,7 +1391,7 @@ UINT get_win_monitor_dpi( HWND hwnd )
 /**********************************************************************
  *           get_thread_dpi_awareness
  */
-DPI_AWARENESS get_thread_dpi_awareness(void)
+static DPI_AWARENESS get_thread_dpi_awareness(void)
 {
     struct user_thread_info *info = get_user_thread_info();
     ULONG_PTR context = info->dpi_awareness;
@@ -1508,34 +1506,6 @@ POINT map_dpi_point( POINT pt, UINT dpi_from, UINT dpi_to )
     return pt;
 }
 
-/**********************************************************************
- *              point_phys_to_win_dpi
- */
-POINT point_phys_to_win_dpi( HWND hwnd, POINT pt )
-{
-    return map_dpi_point( pt, get_win_monitor_dpi( hwnd ), get_dpi_for_window( hwnd ));
-}
-
-/**********************************************************************
- *              point_thread_to_win_dpi
- */
-POINT point_thread_to_win_dpi( HWND hwnd, POINT pt )
-{
-    UINT dpi = get_thread_dpi();
-    if (!dpi) dpi = get_win_monitor_dpi( hwnd );
-    return map_dpi_point( pt, dpi, get_dpi_for_window( hwnd ));
-}
-
-/**********************************************************************
- *              rect_thread_to_win_dpi
- */
-RECT rect_thread_to_win_dpi( HWND hwnd, RECT rect )
-{
-    UINT dpi = get_thread_dpi();
-    if (!dpi) dpi = get_win_monitor_dpi( hwnd );
-    return map_dpi_rect( rect, dpi, get_dpi_for_window( hwnd ) );
-}
-
 /* map value from system dpi to standard 96 dpi for storing in the registry */
 static int map_from_system_dpi( int val )
 {
@@ -1567,27 +1537,6 @@ RECT get_virtual_screen_rect( UINT dpi )
     return rect;
 }
 
-static BOOL is_window_rect_full_screen( const RECT *rect )
-{
-    struct monitor *monitor;
-    BOOL ret = FALSE;
-
-    if (!lock_display_devices()) return FALSE;
-
-    LIST_FOR_EACH_ENTRY( monitor, &monitors, struct monitor, entry )
-    {
-        if (rect->left <= monitor->rc_monitor.left && rect->right >= monitor->rc_monitor.right &&
-            rect->top <= monitor->rc_monitor.top && rect->bottom >= monitor->rc_monitor.bottom)
-        {
-            ret = TRUE;
-            break;
-        }
-    }
-
-    unlock_display_devices();
-    return ret;
-}
-
 RECT get_display_rect( const WCHAR *display )
 {
     struct monitor *monitor;
@@ -2011,7 +1960,7 @@ BOOL WINAPI NtUserEnumDisplayMonitors( HDC hdc, RECT *rect, MONITORENUMPROC proc
 
         monrect = map_dpi_rect( monitor->rc_monitor, get_monitor_dpi( monitor->handle ),
                                 get_thread_dpi() );
-        OffsetRect( &monrect, -origin.x, -origin.y );
+        offset_rect( &monrect, -origin.x, -origin.y );
         if (!intersect_rect( &monrect, &monrect, &limit )) continue;
 
         enum_info[count].handle = monitor->handle;
@@ -2090,7 +2039,7 @@ HMONITOR monitor_from_rect( const RECT *rect, DWORD flags, UINT dpi )
     RECT r;
 
     r = map_dpi_rect( *rect, dpi, system_dpi );
-    if (IsRectEmpty( &r ))
+    if (is_rect_empty( &r ))
     {
         r.right = r.left + 1;
         r.bottom = r.top + 1;
@@ -2164,7 +2113,7 @@ HMONITOR monitor_from_window( HWND hwnd, DWORD flags, UINT dpi )
     TRACE( "(%p, 0x%08x)\n", hwnd, flags );
 
     wp.length = sizeof(wp);
-    if (is_iconic( hwnd ) && NtUserGetWindowPlacement( hwnd, &wp ))
+    if (is_iconic( hwnd ) && get_window_placement( hwnd, &wp ))
         return monitor_from_rect( &wp.rcNormalPosition, flags, dpi );
 
     if (get_window_rect( hwnd, &rect, dpi ))
@@ -2700,7 +2649,7 @@ static void logfont16to32( const LOGFONT16 *font16, LPLOGFONTW font32 )
     font32->lfClipPrecision = font16->lfClipPrecision;
     font32->lfQuality = font16->lfQuality;
     font32->lfPitchAndFamily = font16->lfPitchAndFamily;
-    win32u_mbtowc( &ansi_cp, font32->lfFaceName, LF_FACESIZE, font16->lfFaceName,
+    win32u_mbtowc( NULL, font32->lfFaceName, LF_FACESIZE, font16->lfFaceName,
                    strlen( font16->lfFaceName ));
     font32->lfFaceName[LF_FACESIZE-1] = 0;
 }
@@ -2802,7 +2751,7 @@ static BOOL get_font_entry( union sysparam_all_entry *entry, UINT int_param, voi
                   debugstr_a( entry->hdr.regval ));
             /* fall through */
         case 0: /* use the default GUI font */
-            NtGdiExtGetObjectW( GetStockObject( DEFAULT_GUI_FONT ), sizeof(font), &font );
+            NtGdiExtGetObjectW( get_stock_object( DEFAULT_GUI_FONT ), sizeof(font), &font );
             font.lfHeight = map_from_system_dpi( font.lfHeight );
             font.lfWeight = entry->font.weight;
             entry->font.val = font;
@@ -2841,7 +2790,7 @@ static BOOL set_font_entry( union sysparam_all_entry *entry, UINT int_param, voi
 /* initialize a font (binary) parameter */
 static BOOL init_font_entry( union sysparam_all_entry *entry )
 {
-    NtGdiExtGetObjectW( GetStockObject( DEFAULT_GUI_FONT ), sizeof(entry->font.val), &entry->font.val );
+    NtGdiExtGetObjectW( get_stock_object( DEFAULT_GUI_FONT ), sizeof(entry->font.val), &entry->font.val );
     entry->font.val.lfHeight = map_from_system_dpi( entry->font.val.lfHeight );
     entry->font.val.lfWeight = entry->font.weight;
     get_real_fontname( &entry->font.val, entry->font.fullname );
@@ -4144,8 +4093,9 @@ BOOL WINAPI NtUserSystemParametersInfo( UINT action, UINT val, void *ptr, UINT w
     {
         static const WCHAR emptyW[1];
         if (winini & (SPIF_SENDWININICHANGE | SPIF_SENDCHANGE))
-            send_message_timeout( HWND_BROADCAST, WM_SETTINGCHANGE, action, (LPARAM) emptyW,
-                                  SMTO_ABORTIFHUNG, 2000, NULL, FALSE );
+            user_callbacks->pSendMessageTimeoutW( HWND_BROADCAST, WM_SETTINGCHANGE,
+                                                  action, (LPARAM) emptyW,
+                                                  SMTO_ABORTIFHUNG, 2000, NULL );
     }
     TRACE( "(%u, %u, %p, %u) ret %d\n", action, val, ptr, winini, ret );
     return ret;
@@ -4270,7 +4220,7 @@ int get_system_metrics( int index )
     case SM_PENWINDOWS:
         return 0;
     case SM_DBCSENABLED:
-        return ansi_cp.MaximumCharacterSize > 1;
+        return get_cptable(get_acp())->MaximumCharacterSize > 1;
     case SM_CMOUSEBUTTONS:
         return 3;
     case SM_SECURE:
@@ -4526,7 +4476,7 @@ static HBRUSH get_55aa_brush(void)
     return brush_55aa;
 }
 
-HBRUSH get_sys_color_brush( unsigned int index )
+static HBRUSH get_sys_color_brush( unsigned int index )
 {
     if (index == COLOR_55AA_BRUSH) return get_55aa_brush();
     if (index >= ARRAY_SIZE( system_colors )) return 0;
@@ -4587,8 +4537,8 @@ BOOL WINAPI NtUserSetSysColors( INT count, const INT *colors, const COLORREF *va
             set_entry( &system_colors[colors[i]], values[i], 0, 0 );
 
     /* Send WM_SYSCOLORCHANGE message to all windows */
-    send_message_timeout( HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0,
-                          SMTO_ABORTIFHUNG, 2000, NULL, FALSE );
+    user_callbacks->pSendMessageTimeoutW( HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0,
+                                          SMTO_ABORTIFHUNG, 2000, NULL );
     /* Repaint affected portions of all visible windows */
     NtUserRedrawWindow( 0, NULL, 0, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW | RDW_ALLCHILDREN );
     return TRUE;
@@ -4673,27 +4623,19 @@ ULONG_PTR WINAPI NtUserCallNoParam( ULONG code )
 {
     switch(code)
     {
-    case NtUserCallNoParam_DestroyCaret:
-        return destroy_caret();
-
-    case NtUserCallNoParam_GetDesktopWindow:
+    case NtUserGetDesktopWindow:
         return HandleToUlong( get_desktop_window() );
-
-    case NtUserCallNoParam_GetInputState:
+    case NtUserGetInputState:
         return get_input_state();
-
-    case NtUserCallNoParam_ReleaseCapture:
+    case NtUserReleaseCapture:
         return release_capture();
-
     /* temporary exports */
     case NtUserExitingThread:
         exiting_thread_id = GetCurrentThreadId();
         return 0;
-
     case NtUserThreadDetach:
         thread_detach();
         return 0;
-
     default:
         FIXME( "invalid code %u\n", code );
         return 0;
@@ -4707,72 +4649,36 @@ ULONG_PTR WINAPI NtUserCallOneParam( ULONG_PTR arg, ULONG code )
 {
     switch(code)
     {
-    case NtUserCallOneParam_BeginDeferWindowPos:
+    case NtUserBeginDeferWindowPos:
         return HandleToUlong( begin_defer_window_pos( arg ));
-
-    case NtUserCallOneParam_CreateCursorIcon:
+    case NtUserCreateCursorIcon:
         return HandleToUlong( alloc_cursoricon_handle( arg ));
-
-    case NtUserCallOneParam_CreateMenu:
-        return HandleToUlong( create_menu( arg ) );
-
-    case NtUserCallOneParam_DispatchMessageA:
-        return dispatch_message( (const MSG *)arg, TRUE );
-
-    case NtUserCallOneParam_EnableDC:
+    case NtUserEnableDC:
         return set_dce_flags( UlongToHandle(arg), DCHF_ENABLEDC );
-
-    case NtUserCallOneParam_EnableThunkLock:
-        enable_thunk_lock = arg;
-        return 0;
-
-    case NtUserCallOneParam_EnumClipboardFormats:
-        return enum_clipboard_formats( arg );
-
-    case NtUserCallOneParam_GetClipCursor:
+    case NtUserGetClipCursor:
         return get_clip_cursor( (RECT *)arg );
-
-    case NtUserCallOneParam_GetCursorPos:
+    case NtUserGetCursorPos:
         return get_cursor_pos( (POINT *)arg );
-
-    case NtUserCallOneParam_GetIconParam:
+    case NtUserGetIconParam:
         return get_icon_param( UlongToHandle(arg) );
-
-    case NtUserCallOneParam_GetMenuItemCount:
-        return get_menu_item_count( UlongToHandle(arg) );
-
-    case NtUserCallOneParam_GetSysColor:
+    case NtUserGetSysColor:
         return get_sys_color( arg );
-
-    case NtUserCallOneParam_IsWindowRectFullScreen:
-        return is_window_rect_full_screen( (const RECT *)arg );
-
-    case NtUserCallOneParam_RealizePalette:
+    case NtUserRealizePalette:
         return realize_palette( UlongToHandle(arg) );
-
-    case NtUserCallOneParam_GetPrimaryMonitorRect:
+    case NtUserGetPrimaryMonitorRect:
         *(RECT *)arg = get_primary_monitor_rect( 0 );
         return 1;
-
-    case NtUserCallOneParam_GetSysColorBrush:
+    case NtUserGetSysColorBrush:
         return HandleToUlong( get_sys_color_brush(arg) );
-
-    case NtUserCallOneParam_GetSysColorPen:
+    case NtUserGetSysColorPen:
         return HandleToUlong( get_sys_color_pen(arg) );
-
-    case NtUserCallOneParam_GetSystemMetrics:
+    case NtUserGetSystemMetrics:
         return get_system_metrics( arg );
-
-    case NtUserCallOneParam_GetVirtualScreenRect:
+    case NtUserGetVirtualScreenRect:
         *(RECT *)arg = get_virtual_screen_rect( 0 );
         return 1;
-
-    case NtUserCallOneParam_MessageBeep:
+    case NtUserMessageBeep:
         return message_beep( arg );
-
-    case NtUserCallOneParam_SetCaretBlinkTime:
-        return set_caret_blink_time( arg );
-
     /* temporary exports */
     case NtUserCallHooks:
         {
@@ -4780,13 +4686,20 @@ ULONG_PTR WINAPI NtUserCallOneParam( ULONG_PTR arg, ULONG code )
             return call_hooks( params->id, params->code, params->wparam, params->lparam,
                                params->next_unicode );
         }
-
+    case NtUserFlushWindowSurfaces:
+        flush_window_surfaces( arg );
+        return 0;
     case NtUserGetDeskPattern:
         return get_entry( &entry_DESKPATTERN, 256, (WCHAR *)arg );
-
     case NtUserGetWinProcPtr:
         return (UINT_PTR)get_winproc_ptr( UlongToHandle(arg) );
-
+    case NtUserHandleInternalMessage:
+        {
+            MSG *msg = (MSG *)arg;
+            return handle_internal_message( msg->hwnd, msg->message, msg->wParam, msg->lParam );
+        }
+    case NtUserIncrementKeyStateCounter:
+        return InterlockedAdd( &global_key_state_counter, arg );
     case NtUserLock:
         switch( arg )
         {
@@ -4794,13 +4707,8 @@ ULONG_PTR WINAPI NtUserCallOneParam( ULONG_PTR arg, ULONG code )
         case 1: user_unlock(); return 0;
         default: user_check_not_lock(); return 0;
         }
-
     case NtUserSetCallbacks:
         return (UINT_PTR)InterlockedExchangePointer( (void **)&user_callbacks, (void *)arg );
-
-    case NtUserSpyGetVKeyName:
-        return (UINT_PTR)debugstr_vkey_name( arg );
-
     default:
         FIXME( "invalid code %u\n", code );
         return 0;
@@ -4814,37 +4722,36 @@ ULONG_PTR WINAPI NtUserCallTwoParam( ULONG_PTR arg1, ULONG_PTR arg2, ULONG code
 {
     switch(code)
     {
-    case NtUserCallTwoParam_GetMenuInfo:
-        return get_menu_info( UlongToHandle(arg1), (MENUINFO *)arg2 );
-
-    case NtUserCallTwoParam_GetMonitorInfo:
+    case NtUserGetMonitorInfo:
         return get_monitor_info( UlongToHandle(arg1), (MONITORINFO *)arg2 );
-
-    case NtUserCallTwoParam_GetSystemMetricsForDpi:
+    case NtUserGetSystemMetricsForDpi:
         return get_system_metrics_for_dpi( arg1, arg2 );
-
-    case NtUserCallTwoParam_MonitorFromRect:
+    case NtUserMirrorRgn:
+        return mirror_window_region( UlongToHandle(arg1), UlongToHandle(arg2) );
+    case NtUserMonitorFromRect:
         return HandleToUlong( monitor_from_rect( (const RECT *)arg1, arg2, get_thread_dpi() ));
-
-    case NtUserCallTwoParam_ReplyMessage:
-        return reply_message_result( arg1, (MSG *)arg2 );
-
-    case NtUserCallTwoParam_SetCaretPos:
-        return set_caret_pos( arg1, arg2 );
-
-    case NtUserCallTwoParam_SetIconParam:
+    case NtUserSetIconParam:
         return set_icon_param( UlongToHandle(arg1), arg2 );
-
-    case NtUserCallTwoParam_UnhookWindowsHook:
+    case NtUserUnhookWindowsHook:
         return unhook_windows_hook( arg1, (HOOKPROC)arg2 );
-
     /* temporary exports */
+    case NtUserAllocHandle:
+        return HandleToUlong( alloc_user_handle( (struct user_object *)arg1, arg2 ));
     case NtUserAllocWinProc:
         return (UINT_PTR)alloc_winproc( (WNDPROC)arg1, arg2 );
-
+    case NtUserFreeHandle:
+        return (UINT_PTR)free_user_handle( UlongToHandle(arg1), arg2 );
     case NtUserGetHandlePtr:
         return (UINT_PTR)get_user_handle_ptr( UlongToHandle(arg1), arg2 );
-
+    case NtUserInvalidateDCE:
+        invalidate_dce( (void *)arg1, (const RECT *)arg2 );
+        return 0;
+    case NtUserRegisterWindowSurface:
+        register_window_surface( (struct window_surface *)arg1, (struct window_surface *)arg2 );
+        return 0;
+    case NtUserSetHandlePtr:
+        set_user_handle_ptr( UlongToHandle(arg1), (struct user_object *)arg2 );
+        return 0;
     default:
         FIXME( "invalid code %u\n", code );
         return 0;
diff --git a/dlls/win32u/tests/win32u.c b/dlls/win32u/tests/win32u.c
index 11820859358..40ea1e58687 100644
--- a/dlls/win32u/tests/win32u.c
+++ b/dlls/win32u/tests/win32u.c
@@ -381,248 +381,6 @@ static void test_cursoricon(void)
     ok(ret, "Destroy icon failed, error %lu.\n", GetLastError());
 }
 
-static LRESULT WINAPI test_message_call_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    switch (msg)
-    {
-    case WM_SETTEXT:
-        ok( !wcscmp( (const WCHAR *)lparam, L"test" ),
-            "lparam = %s\n", wine_dbgstr_w( (const WCHAR *)lparam ));
-        return 6;
-    case WM_USER:
-        ok( wparam == 1, "wparam = %Iu\n", wparam );
-        ok( lparam == 2, "lparam = %Iu\n", lparam );
-        return 3;
-    case WM_USER + 1:
-        return lparam;
-    }
-
-    return DefWindowProcW( hwnd, msg, wparam, lparam );
-}
-
-static void WINAPI test_message_callback( HWND hwnd, UINT msg, ULONG_PTR data, LRESULT result )
-{
-    ok( msg == WM_USER, "msg = %u\n", msg );
-    ok( data == 10, "data = %Iu\n", data );
-    ok( result == 3, "result = %Iu\n", result );
-}
-
-static void test_message_call(void)
-{
-    const LPARAM large_lparam = (LPARAM)(3 + ((ULONGLONG)1 << 60));
-    struct send_message_callback_params callback_params = {
-        .callback = test_message_callback,
-        .data = 10,
-    };
-    struct send_message_timeout_params smp;
-    WNDCLASSW cls = { 0 };
-    LRESULT res;
-    HWND hwnd;
-
-    cls.lpfnWndProc = test_message_call_proc;
-    cls.lpszClassName = L"TestClass";
-    RegisterClassW( &cls );
-
-    hwnd = CreateWindowExW( 0, L"TestClass", NULL, WS_POPUP, 0,0,0,0,0,0,0, NULL );
-
-    res = NtUserMessageCall( hwnd, WM_USER, 1, 2, (void *)0xdeadbeef, NtUserSendMessage, FALSE );
-    ok( res == 3, "res = %Iu\n", res );
-
-    res = NtUserMessageCall( hwnd, WM_USER, 1, 2, (void *)0xdeadbeef, NtUserSendMessage, TRUE );
-    ok( res == 3, "res = %Iu\n", res );
-
-    res = NtUserMessageCall( hwnd, WM_SETTEXT, 0, (LPARAM)L"test", NULL, NtUserSendMessage, FALSE );
-    ok( res == 6, "res = %Iu\n", res );
-
-    res = NtUserMessageCall( hwnd, WM_SETTEXT, 0, (LPARAM)"test", NULL, NtUserSendMessage, TRUE );
-    ok( res == 6, "res = %Iu\n", res );
-
-    SetLastError( 0xdeadbeef );
-    res = NtUserMessageCall( UlongToHandle(0xdeadbeef), WM_USER, 1, 2, 0, NtUserSendMessage, TRUE );
-    ok( !res, "res = %Iu\n", res );
-    ok( GetLastError() == ERROR_INVALID_WINDOW_HANDLE, "GetLastError() = %lu\n", GetLastError());
-
-    res = NtUserMessageCall( hwnd, WM_USER + 1, 0, large_lparam, 0, NtUserSendMessage, FALSE );
-    ok( res == large_lparam, "res = %Iu\n", res );
-
-    smp.flags = 0;
-    smp.timeout = 10;
-    smp.result = 0xdeadbeef;
-    res = NtUserMessageCall( hwnd, WM_USER, 1, 2, &smp, NtUserSendMessageTimeout, FALSE );
-    ok( res == 3, "res = %Iu\n", res );
-    ok( smp.result == 1, "smp.result = %Iu\n", smp.result );
-
-    smp.flags = 0;
-    smp.timeout = 10;
-    smp.result = 0xdeadbeef;
-    res = NtUserMessageCall( hwnd, WM_USER + 1, 0, large_lparam,
-                             &smp, NtUserSendMessageTimeout, FALSE );
-    ok( res == large_lparam, "res = %Iu\n", res );
-    ok( smp.result == 1, "smp.result = %Iu\n", smp.result );
-
-    res = NtUserMessageCall( hwnd, WM_USER, 1, 2, (void *)0xdeadbeef,
-                             NtUserSendNotifyMessage, FALSE );
-    ok( res == 1, "res = %Iu\n", res );
-
-    res = NtUserMessageCall( hwnd, WM_USER, 1, 2, &callback_params,
-                             NtUserSendMessageCallback, FALSE );
-    ok( res == 1, "res = %Iu\n", res );
-
-    DestroyWindow( hwnd );
-    UnregisterClassW( L"TestClass", NULL );
-}
-
-static void test_window_text(void)
-{
-    WCHAR buf[512];
-    LRESULT res;
-    int len;
-    HWND hwnd;
-
-    hwnd = CreateWindowExW( 0, L"static", NULL, WS_POPUP, 0,0,0,0,0,0,0, NULL );
-
-    memset( buf, 0xcc, sizeof(buf) );
-    len = NtUserInternalGetWindowText( hwnd, buf, ARRAYSIZE(buf) );
-    ok( len == 0, "len = %d\n", len );
-    ok( !buf[0], "buf = %s\n", wine_dbgstr_w(buf) );
-
-    res = NtUserMessageCall( hwnd, WM_SETTEXT, 0, (LPARAM)L"test", 0, NtUserDefWindowProc, FALSE );
-    ok( res == 1, "res = %Id\n", res );
-
-    memset( buf, 0xcc, sizeof(buf) );
-    len = NtUserInternalGetWindowText( hwnd, buf, ARRAYSIZE(buf) );
-    ok( len == 4, "len = %d\n", len );
-    ok( !lstrcmpW( buf, L"test" ), "buf = %s\n", wine_dbgstr_w(buf) );
-
-    res = NtUserMessageCall( hwnd, WM_SETTEXT, 0, (LPARAM)"TestA", 0, NtUserDefWindowProc, TRUE );
-    ok( res == 1, "res = %Id\n", res );
-
-    memset( buf, 0xcc, sizeof(buf) );
-    len = NtUserInternalGetWindowText( hwnd, buf, ARRAYSIZE(buf) );
-    ok( len == 5, "len = %d\n", len );
-    ok( !lstrcmpW( buf, L"TestA" ), "buf = %s\n", wine_dbgstr_w(buf) );
-
-    DestroyWindow( hwnd );
-}
-
-#define test_menu_item_id(a, b, c) test_menu_item_id_(a, b, c, __LINE__)
-static void test_menu_item_id_( HMENU menu, int pos, int expect, int line )
-{
-    MENUITEMINFOW item;
-    BOOL ret;
-
-    item.cbSize = sizeof(item);
-    item.fMask = MIIM_ID;
-    ret = GetMenuItemInfoW( menu, pos, TRUE, &item );
-    ok_(__FILE__,line)( ret, "GetMenuItemInfoW failed: %lu\n", GetLastError() );
-    ok_(__FILE__,line)( item.wID == expect, "got if %d, expected %d\n", item.wID, expect );
-}
-
-static void test_menu(void)
-{
-    MENUITEMINFOW item;
-    HMENU menu;
-    int count;
-    BOOL ret;
-
-    menu = CreateMenu();
-
-    memset( &item, 0, sizeof(item) );
-    item.cbSize = sizeof(item);
-    item.fMask = MIIM_ID;
-    item.wID = 10;
-    ret = NtUserThunkedMenuItemInfo( menu, 0, MF_BYPOSITION, NtUserInsertMenuItem, &item, NULL );
-    ok( ret, "InsertMenuItemW failed: %lu\n", GetLastError() );
-
-    count = GetMenuItemCount( menu );
-    ok( count == 1, "count = %d\n", count );
-
-    item.wID = 20;
-    ret = NtUserThunkedMenuItemInfo( menu, 1, MF_BYPOSITION, NtUserInsertMenuItem, &item, NULL );
-    ok( ret, "InsertMenuItemW failed: %lu\n", GetLastError() );
-
-    count = GetMenuItemCount( menu );
-    ok( count == 2, "count = %d\n", count );
-    test_menu_item_id( menu, 0, 10 );
-    test_menu_item_id( menu, 1, 20 );
-
-    item.wID = 30;
-    ret = NtUserThunkedMenuItemInfo( menu, 1, MF_BYPOSITION, NtUserInsertMenuItem, &item, NULL );
-    ok( ret, "InsertMenuItemW failed: %lu\n", GetLastError() );
-
-    count = GetMenuItemCount( menu );
-    ok( count == 3, "count = %d\n", count );
-    test_menu_item_id( menu, 0, 10 );
-    test_menu_item_id( menu, 1, 30 );
-    test_menu_item_id( menu, 2, 20 );
-
-    item.wID = 50;
-    ret = NtUserThunkedMenuItemInfo( menu, 10, 0, NtUserInsertMenuItem, &item, NULL );
-    ok( ret, "InsertMenuItemW failed: %lu\n", GetLastError() );
-
-    count = GetMenuItemCount( menu );
-    ok( count == 4, "count = %d\n", count );
-    test_menu_item_id( menu, 0, 50 );
-    test_menu_item_id( menu, 1, 10 );
-    test_menu_item_id( menu, 2, 30 );
-    test_menu_item_id( menu, 3, 20 );
-
-    item.wID = 60;
-    ret = NtUserThunkedMenuItemInfo( menu, 1, MF_BYPOSITION, NtUserSetMenuItemInfo, &item, NULL );
-    ok( ret, "InsertMenuItemW failed: %lu\n", GetLastError() );
-
-    count = GetMenuItemCount( menu );
-    ok( count == 4, "count = %d\n", count );
-    test_menu_item_id( menu, 1, 60 );
-
-    ret = NtUserDestroyMenu( menu );
-    ok( ret, "NtUserDestroyMenu failed: %lu\n", GetLastError() );
-}
-
-static MSG *msg_ptr;
-
-static LRESULT WINAPI hook_proc( INT code, WPARAM wparam, LPARAM lparam )
-{
-    msg_ptr = (MSG *)lparam;
-    ok( code == 100, "code = %d\n", code );
-    ok( msg_ptr->time == 1, "time = %lx\n", msg_ptr->time );
-    ok( msg_ptr->wParam == 10, "wParam = %Ix\n", msg_ptr->wParam );
-    ok( msg_ptr->lParam == 20, "lParam = %Ix\n", msg_ptr->lParam );
-    msg_ptr->time = 3;
-    msg_ptr->wParam = 1;
-    msg_ptr->lParam = 2;
-    return CallNextHookEx( NULL, code, wparam, lparam );
-}
-
-static void test_message_filter(void)
-{
-    HHOOK hook;
-    MSG msg;
-    BOOL ret;
-
-    hook = SetWindowsHookExW( WH_MSGFILTER, hook_proc, NULL, GetCurrentThreadId() );
-    ok( hook != NULL, "SetWindowsHookExW failed\n");
-
-    memset( &msg, 0, sizeof(msg) );
-    msg.time = 1;
-    msg.wParam = 10;
-    msg.lParam = 20;
-    ret = NtUserCallMsgFilter( &msg, 100 );
-    ok( !ret, "CallMsgFilterW returned: %x\n", ret );
-    todo_wine
-    ok( msg_ptr != &msg, "our ptr was passed directly to hook\n" );
-
-    if (sizeof(void *) == 8) /* on some Windows versions, msg is not modified on wow64 */
-    {
-        ok( msg.time == 3, "time = %lx\n", msg.time );
-        ok( msg.wParam == 1, "wParam = %Ix\n", msg.wParam );
-        ok( msg.lParam == 2, "lParam = %Ix\n", msg.lParam );
-    }
-
-    ret = NtUserUnhookWindowsHookEx( hook );
-    ok( ret, "NtUserUnhookWindowsHook failed: %lu\n", GetLastError() );
-}
-
 START_TEST(win32u)
 {
     /* native win32u.dll fails if user32 is not loaded, so make sure it's fully initialized */
@@ -633,10 +391,6 @@ START_TEST(win32u)
     test_class();
     test_NtUserBuildHwndList();
     test_cursoricon();
-    test_message_call();
-    test_window_text();
-    test_menu();
-    test_message_filter();
 
     test_NtUserCloseWindowStation();
 }
diff --git a/dlls/win32u/win32u.spec b/dlls/win32u/win32u.spec
index 48c10fd45d3..87357074571 100644
--- a/dlls/win32u/win32u.spec
+++ b/dlls/win32u/win32u.spec
@@ -187,7 +187,7 @@
 @ stub NtGdiDdDDICheckOcclusion
 @ stub NtGdiDdDDICheckSharedResourceAccess
 @ stdcall NtGdiDdDDICheckVidPnExclusiveOwnership(ptr)
-@ stdcall NtGdiDdDDICloseAdapter(ptr)
+@ stdcall -syscall NtGdiDdDDICloseAdapter(ptr)
 @ stub NtGdiDdDDIConfigureSharedResource
 @ stub NtGdiDdDDICreateAllocation
 @ stub NtGdiDdDDICreateBundleObject
@@ -268,9 +268,9 @@
 @ stub NtGdiDdDDINetDispStartMiracastDisplayDevice
 @ stub NtGdiDdDDINetDispStopMiracastDisplayDevice
 @ stub NtGdiDdDDIOfferAllocations
-@ stdcall NtGdiDdDDIOpenAdapterFromDeviceName(ptr)
+@ stdcall -syscall NtGdiDdDDIOpenAdapterFromDeviceName(ptr)
 @ stdcall -syscall NtGdiDdDDIOpenAdapterFromHdc(ptr)
-@ stdcall NtGdiDdDDIOpenAdapterFromLuid(ptr)
+@ stdcall -syscall NtGdiDdDDIOpenAdapterFromLuid(ptr)
 @ stub NtGdiDdDDIOpenBundleObjectNtHandleFromName
 @ stub NtGdiDdDDIOpenKeyedMutex
 @ stub NtGdiDdDDIOpenKeyedMutex2
@@ -307,7 +307,7 @@
 @ stub NtGdiDdDDIQueryResourceInfoFromNtHandle
 @ stdcall -syscall NtGdiDdDDIQueryStatistics(ptr)
 @ stub NtGdiDdDDIQueryVidPnExclusiveOwnership
-@ stdcall NtGdiDdDDIQueryVideoMemoryInfo(ptr)
+@ stub NtGdiDdDDIQueryVideoMemoryInfo
 @ stub NtGdiDdDDIReclaimAllocations
 @ stub NtGdiDdDDIReclaimAllocations2
 @ stub NtGdiDdDDIReleaseKeyedMutex
@@ -776,24 +776,24 @@
 @ stub NtUserCallHwndParamLock
 @ stub NtUserCallHwndParamLockSafe
 @ stub NtUserCallHwndSafe
-@ stdcall -syscall NtUserCallMsgFilter(ptr long)
+@ stub NtUserCallMsgFilter
 @ stdcall NtUserCallNextHookEx(long long long long)
 @ stdcall NtUserCallNoParam(long)
 @ stdcall NtUserCallOneParam(long long)
 @ stdcall NtUserCallTwoParam(long long long)
 @ stub NtUserCanBrokerForceForeground
-@ stdcall NtUserChangeClipboardChain(long long)
+@ stub NtUserChangeClipboardChain
 @ stdcall NtUserChangeDisplaySettings(ptr ptr long long ptr)
 @ stub NtUserChangeWindowMessageFilterEx
 @ stub NtUserCheckAccessForIntegrityLevel
-@ stdcall -syscall NtUserCheckMenuItem(long long long)
+@ stub NtUserCheckMenuItem
 @ stub NtUserCheckProcessForClipboardAccess
 @ stub NtUserCheckProcessSession
 @ stub NtUserCheckWindowThreadDesktop
-@ stdcall -syscall NtUserChildWindowFromPointEx(long long long long)
+@ stub NtUserChildWindowFromPointEx
 @ stub NtUserClearForeground
 @ stdcall NtUserClipCursor(ptr)
-@ stdcall NtUserCloseClipboard()
+@ stub NtUserCloseClipboard
 @ stdcall -syscall NtUserCloseDesktop(long)
 @ stdcall -syscall NtUserCloseWindowStation(long)
 @ stub NtUserCompositionInputSinkLuidFromPoint
@@ -807,14 +807,14 @@
 @ stdcall -syscall NtUserCreateAcceleratorTable(ptr long)
 @ stub NtUserCreateActivationGroup
 @ stub NtUserCreateActivationObject
-@ stdcall NtUserCreateCaret(long long long long)
+@ stub NtUserCreateCaret
 @ stub NtUserCreateDCompositionHwndTarget
 @ stdcall -syscall NtUserCreateDesktopEx(ptr ptr ptr long long long)
 @ stub NtUserCreateEmptyCursorObject
 @ stub NtUserCreateInputContext
 @ stub NtUserCreateLocalMemHandle
 @ stub NtUserCreatePalmRejectionDelayZone
-@ stdcall NtUserCreateWindowEx(long ptr ptr ptr long long long long long long long long ptr long long long long)
+@ stub NtUserCreateWindowEx
 @ stub NtUserCreateWindowGroup
 @ stdcall -syscall NtUserCreateWindowStation(ptr long long long long long long)
 @ stub NtUserCtxDisplayIOCtl
@@ -824,7 +824,7 @@
 @ stdcall NtUserDeferWindowPosAndBand(long long long long long long long long long long)
 @ stub NtUserDelegateCapturePointers
 @ stub NtUserDelegateInput
-@ stdcall -syscall NtUserDeleteMenu(long long long)
+@ stub NtUserDeleteMenu
 @ stub NtUserDeleteWindowGroup
 @ stdcall -syscall NtUserDestroyAcceleratorTable(long)
 @ stub NtUserDestroyActivationGroup
@@ -832,14 +832,14 @@
 @ stdcall NtUserDestroyCursor(long long)
 @ stub NtUserDestroyDCompositionHwndTarget
 @ stub NtUserDestroyInputContext
-@ stdcall NtUserDestroyMenu(long)
+@ stub NtUserDestroyMenu
 @ stub NtUserDestroyPalmRejectionDelayZone
 @ stdcall NtUserDestroyWindow(long)
 @ stub NtUserDisableImmersiveOwner
 @ stub NtUserDisableProcessWindowFiltering
 @ stub NtUserDisableThreadIme
 @ stub NtUserDiscardPointerFrameMessages
-@ stdcall NtUserDispatchMessage(ptr)
+@ stub NtUserDispatchMessage
 @ stub NtUserDisplayConfigGetDeviceInfo
 @ stub NtUserDisplayConfigSetDeviceInfo
 @ stub NtUserDoSoundConnect
@@ -857,10 +857,10 @@
 @ stub NtUserDwmKernelShutdown
 @ stub NtUserDwmKernelStartup
 @ stub NtUserDwmValidateWindow
-@ stdcall NtUserEmptyClipboard()
+@ stub NtUserEmptyClipboard
 @ stub NtUserEnableChildWindowDpiMessage
 @ stub NtUserEnableIAMAccess
-@ stdcall NtUserEnableMenuItem(long long long)
+@ stub NtUserEnableMenuItem
 @ stub NtUserEnableMouseInPointer
 @ stub NtUserEnableMouseInPointerForWindow
 @ stub NtUserEnableMouseInputForCursorSuppression
@@ -879,10 +879,10 @@
 @ stdcall NtUserEnumDisplayMonitors(long ptr ptr long)
 @ stdcall NtUserEnumDisplaySettings(ptr long ptr long)
 @ stub NtUserEvent
-@ stdcall NtUserExcludeUpdateRgn(long long)
+@ stub NtUserExcludeUpdateRgn
 @ stub NtUserFillWindow
 @ stdcall -syscall NtUserFindExistingCursorIcon(ptr ptr ptr)
-@ stdcall -syscall NtUserFindWindowEx(long long ptr ptr long)
+@ stub NtUserFindWindowEx
 @ stdcall NtUserFlashWindowEx(ptr)
 @ stub NtUserForceWindowToDpiForTest
 @ stub NtUserFrostCrashedWindow
@@ -896,13 +896,13 @@
 @ stub NtUserGetAutoRotationState
 @ stub NtUserGetCIMSSM
 @ stub NtUserGetCPD
-@ stdcall -syscall NtUserGetCaretBlinkTime()
-@ stdcall -syscall NtUserGetCaretPos(ptr)
+@ stub NtUserGetCaretBlinkTime
+@ stub NtUserGetCaretPos
 @ stdcall NtUserGetClassInfoEx(ptr ptr ptr ptr long)
 @ stdcall -syscall NtUserGetClassName(long long ptr)
 @ stub NtUserGetClipCursor
 @ stub NtUserGetClipboardAccessToken
-@ stdcall NtUserGetClipboardData(long ptr)
+@ stub NtUserGetClipboardData
 @ stdcall -syscall NtUserGetClipboardFormatName(long ptr long)
 @ stdcall -syscall NtUserGetClipboardOwner()
 @ stdcall -syscall NtUserGetClipboardSequenceNumber()
@@ -954,8 +954,8 @@
 @ stub NtUserGetListBoxInfo
 @ stub NtUserGetMenuBarInfo
 @ stub NtUserGetMenuIndex
-@ stdcall -syscall NtUserGetMenuItemRect(long long long ptr)
-@ stdcall NtUserGetMessage(ptr long long long)
+@ stub NtUserGetMenuItemRect
+@ stub NtUserGetMessage
 @ stdcall -syscall NtUserGetMouseMovePointsEx(long ptr ptr long long)
 @ stdcall -syscall NtUserGetObjectInformation(long long long long ptr)
 @ stub NtUserGetOemBitmapSize
@@ -994,7 +994,7 @@
 @ stub NtUserGetScrollBarInfo
 @ stub NtUserGetSharedWindowData
 @ stdcall -syscall NtUserGetSystemDpiForProcess(long)
-@ stdcall NtUserGetSystemMenu(long long)
+@ stub NtUserGetSystemMenu
 @ stdcall -syscall NtUserGetThreadDesktop(long)
 @ stub NtUserGetThreadState
 @ stub NtUserGetTitleBarInfo
@@ -1014,13 +1014,13 @@
 @ stub NtUserGetWindowFeedbackSetting
 @ stub NtUserGetWindowGroupId
 @ stub NtUserGetWindowMinimizeRect
-@ stdcall NtUserGetWindowPlacement(long ptr)
+@ stub NtUserGetWindowPlacement
 @ stub NtUserGetWindowProcessHandle
 @ stdcall -syscall NtUserGetWindowRgnEx(long long long)
 @ stub NtUserGhostWindowFromHungWindow
 @ stub NtUserHandleDelegatedInput
 @ stub NtUserHardErrorControl
-@ stdcall NtUserHideCaret(long)
+@ stub NtUserHideCaret
 @ stub NtUserHidePointerContactVisualization
 @ stub NtUserHiliteMenuItem
 @ stub NtUserHungWindowFromGhostWindow
@@ -1079,18 +1079,18 @@
 @ stdcall NtUserMapVirtualKeyEx(long long long)
 @ stub NtUserMarkWindowForRawMouse
 @ stub NtUserMenuItemFromPoint
-@ stdcall NtUserMessageCall(long long long long long long long)
+@ stub NtUserMessageCall
 @ stub NtUserMinInitialize
 @ stub NtUserMinMaximize
 @ stub NtUserModifyUserStartupInfoFlags
 @ stub NtUserModifyWindowTouchCapability
 @ stdcall NtUserMoveWindow(long long long long long long)
-@ stdcall NtUserMsgWaitForMultipleObjectsEx(long ptr long long long)
+@ stub NtUserMsgWaitForMultipleObjectsEx
 @ stub NtUserNavigateFocus
 @ stub NtUserNotifyIMEStatus
 @ stub NtUserNotifyProcessCreate
 @ stdcall -syscall NtUserNotifyWinEvent(long long long long)
-@ stdcall NtUserOpenClipboard(long long)
+@ stub NtUserOpenClipboard
 @ stdcall -syscall NtUserOpenDesktop(ptr long long)
 @ stdcall -syscall NtUserOpenInputDesktop(long long long)
 @ stub NtUserOpenThreadDesktop
@@ -1098,13 +1098,13 @@
 @ stub NtUserPaintDesktop
 @ stub NtUserPaintMenuBar
 @ stub NtUserPaintMonitor
-@ stdcall NtUserPeekMessage(ptr long long long long)
+@ stub NtUserPeekMessage
 @ stub NtUserPerMonitorDPIPhysicalToLogicalPoint
 @ stub NtUserPhysicalToLogicalDpiPointForWindow
 @ stub NtUserPhysicalToLogicalPoint
 @ stub NtUserPostKeyboardInputMessage
-@ stdcall NtUserPostMessage(long long long long)
-@ stdcall NtUserPostThreadMessage(long long long long)
+@ stub NtUserPostMessage
+@ stub NtUserPostThreadMessage
 @ stub NtUserPrintWindow
 @ stub NtUserProcessConnect
 @ stub NtUserProcessInkFeedbackCommand
@@ -1147,7 +1147,7 @@
 @ stub NtUserRemoteStopScreenUpdates
 @ stdcall -syscall NtUserRemoveClipboardFormatListener(long)
 @ stub NtUserRemoveInjectionDevice
-@ stdcall -syscall NtUserRemoveMenu(long long long)
+@ stub NtUserRemoveMenu
 @ stdcall -syscall NtUserRemoveProp(long wstr)
 @ stub NtUserRemoveVisualIdentifier
 @ stub NtUserReportInertia
@@ -1159,7 +1159,7 @@
 @ stub NtUserScrollWindowEx
 @ stdcall NtUserSelectPalette(long long long)
 @ stub NtUserSendEventMessage
-@ stdcall NtUserSendInput(long ptr long)
+@ stub NtUserSendInput
 @ stub NtUserSendInteractiveControlHapticsReport
 @ stub NtUserSetActivationFilter
 @ stub NtUserSetActiveProcessForMonitor
@@ -1174,8 +1174,8 @@
 @ stdcall NtUserSetClassLong(long long long long)
 @ stdcall NtUserSetClassLongPtr(long long long long)
 @ stdcall NtUserSetClassWord(long long long)
-@ stdcall NtUserSetClipboardData(long ptr ptr)
-@ stdcall NtUserSetClipboardViewer(long)
+@ stub NtUserSetClipboardData
+@ stub NtUserSetClipboardViewer
 @ stub NtUserSetCoreWindow
 @ stub NtUserSetCoreWindowPartner
 @ stdcall NtUserSetCursor(long)
@@ -1201,14 +1201,14 @@
 @ stub NtUserSetInputServiceState
 @ stub NtUserSetInteractiveControlFocus
 @ stub NtUserSetInteractiveCtrlRotationAngle
-@ stdcall NtUserSetInternalWindowPos(long long ptr ptr)
+@ stub NtUserSetInternalWindowPos
 @ stdcall -syscall NtUserSetKeyboardState(ptr)
 @ stdcall NtUserSetLayeredWindowAttributes(ptr long long long)
 @ stub NtUserSetMagnificationDesktopMagnifierOffsetsDWMUpdated
 @ stub NtUserSetManipulationInputTarget
-@ stdcall NtUserSetMenu(long long)
-@ stdcall -syscall NtUserSetMenuContextHelpId(long long)
-@ stdcall -syscall NtUserSetMenuDefaultItem(long long long)
+@ stub NtUserSetMenu
+@ stub NtUserSetMenuContextHelpId
+@ stub NtUserSetMenuDefaultItem
 @ stub NtUserSetMenuFlagRtoL
 @ stub NtUserSetMirrorRendering
 @ stub NtUserSetMonitorWorkArea
@@ -1229,8 +1229,8 @@
 @ stub NtUserSetShellWindowEx
 @ stdcall NtUserSetSysColors(long ptr ptr)
 @ stub NtUserSetSystemCursor
-@ stdcall NtUserSetSystemMenu(long long)
-@ stdcall -syscall NtUserSetSystemTimer(long long long)
+@ stub NtUserSetSystemMenu
+@ stdcall -syscall NtUserSetSystemTimer(long long long ptr)
 @ stub NtUserSetTargetForResourceBrokering
 @ stdcall -syscall NtUserSetThreadDesktop(long)
 @ stub NtUserSetThreadInputBlocked
@@ -1248,7 +1248,7 @@
 @ stub NtUserSetWindowGroup
 @ stdcall NtUserSetWindowLong(long long long long)
 @ stdcall NtUserSetWindowLongPtr(long long long long)
-@ stdcall NtUserSetWindowPlacement(long ptr)
+@ stub NtUserSetWindowPlacement
 @ stdcall NtUserSetWindowPos(long long long long long long long)
 @ stdcall NtUserSetWindowRgn(long long long)
 @ stub NtUserSetWindowRgnEx
@@ -1257,7 +1257,7 @@
 @ stdcall NtUserSetWindowWord(long long long)
 @ stub NtUserSetWindowsHookAW
 @ stdcall -syscall NtUserSetWindowsHookEx(ptr ptr long long ptr long)
-@ stdcall NtUserShowCaret(long)
+@ stub NtUserShowCaret
 @ stdcall NtUserShowCursor(long)
 @ stub NtUserShowScrollBar
 @ stub NtUserShowSystemCursor
@@ -1274,15 +1274,15 @@
 @ stdcall NtUserSystemParametersInfo(long long ptr long)
 @ stdcall NtUserSystemParametersInfoForDpi(long long ptr long long)
 @ stub NtUserTestForInteractiveUser
-@ stdcall -syscall NtUserThunkedMenuInfo(long ptr)
-@ stdcall -syscall NtUserThunkedMenuItemInfo(long long long long ptr ptr)
+@ stub NtUserThunkedMenuInfo
+@ stub NtUserThunkedMenuItemInfo
 @ stdcall NtUserToUnicodeEx(long long ptr ptr long long long)
-@ stdcall NtUserTrackMouseEvent(ptr)
+@ stub NtUserTrackMouseEvent
 @ stub NtUserTrackPopupMenuEx
 @ stub NtUserTransformPoint
 @ stub NtUserTransformRect
-@ stdcall NtUserTranslateAccelerator(long long ptr)
-@ stdcall NtUserTranslateMessage(ptr long)
+@ stub NtUserTranslateAccelerator
+@ stub NtUserTranslateMessage
 @ stub NtUserUndelegateInput
 @ stdcall -syscall NtUserUnhookWinEvent(long)
 @ stdcall -syscall NtUserUnhookWindowsHookEx(long)
@@ -1305,7 +1305,7 @@
 @ stdcall NtUserVkKeyScanEx(long long)
 @ stub NtUserWOWCleanup
 @ stub NtUserWaitAvailableMessageEx
-@ stdcall NtUserWaitForInputIdle(long long long)
+@ stub NtUserWaitForInputIdle
 @ stub NtUserWaitForMsgAndEvent
 @ stub NtUserWaitForRedirectionStartComplete
 @ stub NtUserWaitMessage
@@ -1320,9 +1320,11 @@
 ################################################################
 # Wine internal extensions
 
+# user32
+@ cdecl __wine_set_visible_region(long long ptr ptr ptr)
+
 # Graphics drivers
-@ cdecl __wine_send_input(long ptr ptr)
-@ cdecl __wine_set_user_driver(ptr long)
+@ cdecl __wine_set_display_driver(ptr long)
 
 # OpenGL
 @ cdecl __wine_get_wgl_driver(long long)
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 053fb25fe36..361bec31ec8 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -58,14 +58,10 @@ struct unix_funcs
                                                      ULONG flags, HANDLE xform );
     HDC      (WINAPI *pNtGdiCreateMetafileDC)( HDC hdc );
     NTSTATUS (WINAPI *pNtGdiDdDDICheckVidPnExclusiveOwnership)( const D3DKMT_CHECKVIDPNEXCLUSIVEOWNERSHIP *desc );
-    NTSTATUS (WINAPI *pNtGdiDdDDICloseAdapter)( const D3DKMT_CLOSEADAPTER *desc );
     NTSTATUS (WINAPI *pNtGdiDdDDICreateDCFromMemory)( D3DKMT_CREATEDCFROMMEMORY *desc );
     NTSTATUS (WINAPI *pNtGdiDdDDIDestroyDCFromMemory)( const D3DKMT_DESTROYDCFROMMEMORY *desc );
     NTSTATUS (WINAPI *pNtGdiDdDDIDestroyDevice)( const D3DKMT_DESTROYDEVICE *desc );
     NTSTATUS (WINAPI *pNtGdiDdDDIEscape)( const D3DKMT_ESCAPE *desc );
-    NTSTATUS (WINAPI *pNtGdiDdDDIOpenAdapterFromDeviceName)( D3DKMT_OPENADAPTERFROMDEVICENAME *desc );
-    NTSTATUS (WINAPI *pNtGdiDdDDIOpenAdapterFromLuid)( D3DKMT_OPENADAPTERFROMLUID *desc );
-    NTSTATUS (WINAPI *pNtGdiDdDDIQueryVideoMemoryInfo)( D3DKMT_QUERYVIDEOMEMORYINFO *desc );
     NTSTATUS (WINAPI *pNtGdiDdDDISetVidPnSourceOwner)( const D3DKMT_SETVIDPNSOURCEOWNER *desc );
     BOOL     (WINAPI *pNtGdiDeleteObjectApp)( HGDIOBJ obj );
     LONG     (WINAPI *pNtGdiDoPalette)( HGDIOBJ handle, WORD start, WORD count, void *entries,
@@ -195,29 +191,17 @@ struct unix_funcs
     ULONG_PTR (WINAPI *pNtUserCallNoParam)( ULONG code );
     ULONG_PTR (WINAPI *pNtUserCallOneParam)( ULONG_PTR arg, ULONG code );
     ULONG_PTR (WINAPI *pNtUserCallTwoParam)( ULONG_PTR arg1, ULONG_PTR arg2, ULONG code );
-    BOOL     (WINAPI *pNtUserChangeClipboardChain)( HWND hwnd, HWND next );
     LONG     (WINAPI *pNtUserChangeDisplaySettings)( UNICODE_STRING *devname, DEVMODEW *devmode, HWND hwnd,
                                                      DWORD flags, void *lparam );
     BOOL     (WINAPI *pNtUserClipCursor)( const RECT *rect );
-    BOOL     (WINAPI *pNtUserCloseClipboard)(void);
     INT      (WINAPI *pNtUserCountClipboardFormats)(void);
-    BOOL     (WINAPI *pNtUserCreateCaret)( HWND hwnd, HBITMAP bitmap, int width, int height );
-    HWND     (WINAPI *pNtUserCreateWindowEx)( DWORD ex_style, UNICODE_STRING *class_name,
-                                              UNICODE_STRING *version, UNICODE_STRING *window_name,
-                                              DWORD style, INT x, INT y, INT width, INT height,
-                                              HWND parent, HMENU menu, HINSTANCE instance, void *params,
-                                              DWORD flags, CBT_CREATEWNDW *cbtc, DWORD unk, BOOL ansi );
     HDWP     (WINAPI *pNtUserDeferWindowPosAndBand)( HDWP hdwp, HWND hwnd, HWND after,
                                                      INT x, INT y, INT cx, INT cy,
                                                      UINT flags, UINT unk1, UINT unk2 );
     BOOL     (WINAPI *pNtUserDestroyCursor)( HCURSOR cursor, ULONG arg );
-    BOOL     (WINAPI *pNtUserDestroyMenu)( HMENU handle );
     BOOL     (WINAPI *pNtUserDestroyWindow)( HWND hwnd );
-    LRESULT  (WINAPI *pNtUserDispatchMessage)( const MSG *msg );
     BOOL     (WINAPI *pNtUserDrawIconEx)( HDC hdc, INT x0, INT y0, HICON icon, INT width,
                                           INT height, UINT istep, HBRUSH hbr, UINT flags );
-    BOOL     (WINAPI *pNtUserEmptyClipboard)(void);
-    BOOL     (WINAPI *pNtUserEnableMenuItem)( HMENU handle, UINT id, UINT flags );
     BOOL     (WINAPI *pNtUserEndDeferWindowPosEx)( HDWP hdwp, BOOL async );
     BOOL     (WINAPI *pNtUserEndPaint)( HWND hwnd, const PAINTSTRUCT *ps );
     NTSTATUS (WINAPI *pNtUserEnumDisplayDevices)( UNICODE_STRING *device, DWORD index,
@@ -225,12 +209,10 @@ struct unix_funcs
     BOOL     (WINAPI *pNtUserEnumDisplayMonitors)( HDC hdc, RECT *rect, MONITORENUMPROC proc, LPARAM lp );
     BOOL     (WINAPI *pNtUserEnumDisplaySettings)( UNICODE_STRING *device, DWORD mode,
                                                    DEVMODEW *dev_mode, DWORD flags );
-    INT      (WINAPI *pNtUserExcludeUpdateRgn)( HDC hdc, HWND hwnd );
     BOOL     (WINAPI *pNtUserFlashWindowEx)( FLASHWINFO *info );
     SHORT    (WINAPI *pNtUserGetAsyncKeyState)( INT key );
     ATOM     (WINAPI *pNtUserGetClassInfoEx)( HINSTANCE instance, UNICODE_STRING *name, WNDCLASSEXW *wc,
                                               struct client_menu_name *menu_name, BOOL ansi );
-    HANDLE   (WINAPI *pNtUserGetClipboardData)( UINT format, struct get_clipboard_params *params );
     BOOL     (WINAPI *pNtUserGetCursorInfo)( CURSORINFO *info );
     HDC      (WINAPI *pNtUserGetDCEx)( HWND hwnd, HRGN clip_rgn, DWORD flags );
     LONG     (WINAPI *pNtUserGetDisplayConfigBufferSizes)( UINT32 flags, UINT32 *num_path_info,
@@ -239,26 +221,14 @@ struct unix_funcs
                                            UNICODE_STRING *res_name, DWORD *bpp, LONG unk );
     INT      (WINAPI *pNtUserGetKeyNameText)( LONG lparam, WCHAR *buffer, INT size );
     UINT     (WINAPI *pNtUserGetKeyboardLayoutList)( INT size, HKL *layouts );
-    BOOL     (WINAPI *pNtUserGetMessage)( MSG *msg, HWND hwnd, UINT first, UINT last );
     INT      (WINAPI *pNtUserGetPriorityClipboardFormat)( UINT *list, INT count );
     DWORD    (WINAPI *pNtUserGetQueueStatus)( UINT flags );
-    HMENU    (WINAPI *pNtUserGetSystemMenu)( HWND hwnd, BOOL revert );
     BOOL     (WINAPI *pNtUserGetUpdateRect)( HWND hwnd, RECT *rect, BOOL erase );
     INT      (WINAPI *pNtUserGetUpdateRgn)( HWND hwnd, HRGN hrgn, BOOL erase );
     BOOL     (WINAPI *pNtUserGetUpdatedClipboardFormats)( UINT *formats, UINT size, UINT *out_size );
-    BOOL     (WINAPI *pNtUserGetWindowPlacement)( HWND hwnd, WINDOWPLACEMENT *placement );
-    BOOL     (WINAPI *pNtUserHideCaret)( HWND hwnd );
     BOOL     (WINAPI *pNtUserIsClipboardFormatAvailable)( UINT format );
     UINT     (WINAPI *pNtUserMapVirtualKeyEx)( UINT code, UINT type, HKL layout );
-    LRESULT  (WINAPI *pNtUserMessageCall)( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                           void *result_info, DWORD type, BOOL ansi );
     BOOL     (WINAPI *pNtUserMoveWindow)( HWND hwnd, INT x, INT y, INT cx, INT cy, BOOL repaint );
-    DWORD    (WINAPI *pNtUserMsgWaitForMultipleObjectsEx)( DWORD count, const HANDLE *handles,
-                                                           DWORD timeout, DWORD mask, DWORD flags );
-    BOOL     (WINAPI *pNtUserOpenClipboard)( HWND hwnd, ULONG unk );
-    BOOL     (WINAPI *pNtUserPeekMessage)( MSG *msg_out, HWND hwnd, UINT first, UINT last, UINT flags );
-    BOOL     (WINAPI *pNtUserPostMessage)( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam );
-    BOOL     (WINAPI *pNtUserPostThreadMessage)( DWORD thread, UINT msg, WPARAM wparam, LPARAM lparam );
     BOOL     (WINAPI *pNtUserRedrawWindow)( HWND hwnd, const RECT *rect, HRGN hrgn, UINT flags );
     ATOM     (WINAPI *pNtUserRegisterClassExWOW)( const WNDCLASSEXW *wc, UNICODE_STRING *name,
                                                   UNICODE_STRING *version,
@@ -269,33 +239,24 @@ struct unix_funcs
     BOOL     (WINAPI *pNtUserScrollDC)( HDC hdc, INT dx, INT dy, const RECT *scroll, const RECT *clip,
                                         HRGN ret_update_rgn, RECT *update_rect );
     HPALETTE (WINAPI *pNtUserSelectPalette)( HDC hdc, HPALETTE hpal, WORD bkg );
-    UINT     (WINAPI *pNtUserSendInput)( UINT count, INPUT *inputs, int size );
     HWND     (WINAPI *pNtUserSetActiveWindow)( HWND hwnd );
     HWND     (WINAPI *pNtUserSetCapture)( HWND hwnd );
-    NTSTATUS (WINAPI *pNtUserSetClipboardData)( UINT format, HANDLE handle,
-                                                struct set_clipboard_params *params );
     DWORD    (WINAPI *pNtUserSetClassLong)( HWND hwnd, INT offset, LONG newval, BOOL ansi );
     ULONG_PTR (WINAPI *pNtUserSetClassLongPtr)( HWND hwnd, INT offset, LONG_PTR newval, BOOL ansi );
     WORD     (WINAPI *pNtUserSetClassWord)( HWND hwnd, INT offset, WORD newval );
-    HWND     (WINAPI *pNtUserSetClipboardViewer)( HWND hwnd );
     HCURSOR  (WINAPI *pNtUserSetCursor)( HCURSOR cursor );
     BOOL     (WINAPI *pNtUserSetCursorIconData)( HCURSOR cursor, UNICODE_STRING *module,
                                                  UNICODE_STRING *res_name, struct cursoricon_desc *desc );
     BOOL     (WINAPI *pNtUserSetCursorPos)( INT x, INT y );
     HWND     (WINAPI *pNtUserSetFocus)( HWND hwnd );
-    void     (WINAPI *pNtUserSetInternalWindowPos)( HWND hwnd, UINT cmd, RECT *rect, POINT *pt );
     BOOL     (WINAPI *pNtUserSetLayeredWindowAttributes)( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags );
-    BOOL     (WINAPI *pNtUserSetMenu)( HWND hwnd, HMENU menu );
     HWND     (WINAPI *pNtUserSetParent)( HWND hwnd, HWND parent );
     BOOL     (WINAPI *pNtUserSetSysColors)( INT count, const INT *colors, const COLORREF *values );
-    BOOL     (WINAPI *pNtUserSetSystemMenu)( HWND hwnd, HMENU menu );
     LONG     (WINAPI *pNtUserSetWindowLong)( HWND hwnd, INT offset, LONG newval, BOOL ansi );
     LONG_PTR (WINAPI *pNtUserSetWindowLongPtr)( HWND hwnd, INT offset, LONG_PTR newval, BOOL ansi );
-    BOOL     (WINAPI *pNtUserSetWindowPlacement)( HWND hwnd, const WINDOWPLACEMENT *wpl );
     BOOL     (WINAPI *pNtUserSetWindowPos)( HWND hwnd, HWND after, INT x, INT y, INT cx, INT cy, UINT flags );
     int      (WINAPI *pNtUserSetWindowRgn)( HWND hwnd, HRGN hrgn, BOOL redraw );
     WORD     (WINAPI *pNtUserSetWindowWord)( HWND hwnd, INT offset, WORD newval );
-    BOOL     (WINAPI *pNtUserShowCaret)( HWND hwnd );
     INT      (WINAPI *pNtUserShowCursor)( BOOL show );
     BOOL     (WINAPI *pNtUserShowWindow)( HWND hwnd, INT cmd );
     BOOL     (WINAPI *pNtUserShowWindowAsync)( HWND hwnd, INT cmd );
@@ -304,9 +265,6 @@ struct unix_funcs
                                                          UINT winini, UINT dpi );
     INT      (WINAPI *pNtUserToUnicodeEx)( UINT virt, UINT scan, const BYTE *state,
                                            WCHAR *str, int size, UINT flags, HKL layout );
-    BOOL     (WINAPI *pNtUserTrackMouseEvent)( TRACKMOUSEEVENT *info );
-    INT      (WINAPI *pNtUserTranslateAccelerator)( HWND hwnd, HACCEL accel, MSG *msg );
-    BOOL     (WINAPI *pNtUserTranslateMessage)( const MSG *msg, UINT flags );
     BOOL     (WINAPI *pNtUserUnregisterClass)( UNICODE_STRING *name, HINSTANCE instance,
                                                struct client_menu_name *client_menu_name );
     BOOL     (WINAPI *pNtUserUnregisterHotKey)( HWND hwnd, INT id );
@@ -315,7 +273,6 @@ struct unix_funcs
                                                    COLORREF key, const BLENDFUNCTION *blend,
                                                    DWORD flags, const RECT *dirty );
     WORD     (WINAPI *pNtUserVkKeyScanEx)( WCHAR chr, HKL layout );
-    DWORD    (WINAPI *pNtUserWaitForInputIdle)( HANDLE process, DWORD timeout, BOOL wow );
     HWND     (WINAPI *pNtUserWindowFromPoint)( LONG x, LONG y );
 
     /* Wine-specific functions */
@@ -327,12 +284,12 @@ struct unix_funcs
     BOOL (CDECL *get_icm_profile)( HDC hdc, BOOL allow_default, DWORD *size, WCHAR *filename );
     const struct vulkan_funcs * (CDECL *get_vulkan_driver)( UINT version );
     struct opengl_funcs * (CDECL *get_wgl_driver)( HDC hdc, UINT version );
-    BOOL (CDECL *wine_send_input)( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput );
-    void (CDECL *set_user_driver)( const struct user_driver_funcs *funcs, UINT version );
+    void (CDECL *set_display_driver)( struct user_driver_funcs *funcs, UINT version );
+    void (CDECL *set_visible_region)( HDC hdc, HRGN hrgn, const RECT *vis_rect, const RECT *device_rect,
+                                      struct window_surface *surface );
 };
 
 /* clipboard.c */
-extern UINT enum_clipboard_formats( UINT format ) DECLSPEC_HIDDEN;
 extern void release_clipboard_owner( HWND hwnd ) DECLSPEC_HIDDEN;
 
 /* cursoricon.c */
@@ -343,87 +300,46 @@ extern ULONG_PTR set_icon_param( HICON handle, ULONG_PTR param ) DECLSPEC_HIDDEN
 
 /* dce.c */
 extern struct window_surface dummy_surface DECLSPEC_HIDDEN;
-extern BOOL create_dib_surface( HDC hdc, const BITMAPINFO *info ) DECLSPEC_HIDDEN;
-extern void create_offscreen_window_surface( const RECT *visible_rect,
-                                             struct window_surface **surface ) DECLSPEC_HIDDEN;
-extern void erase_now( HWND hwnd, UINT rdw_flags ) DECLSPEC_HIDDEN;
 extern void flush_window_surfaces( BOOL idle ) DECLSPEC_HIDDEN;
-extern void move_window_bits( HWND hwnd, struct window_surface *old_surface,
-                              struct window_surface *new_surface,
-                              const RECT *visible_rect, const RECT *old_visible_rect,
-                              const RECT *window_rect, const RECT *valid_rects ) DECLSPEC_HIDDEN;
-extern void move_window_bits_parent( HWND hwnd, HWND parent, const RECT *window_rect,
-                                     const RECT *valid_rects ) DECLSPEC_HIDDEN;
 extern void register_window_surface( struct window_surface *old,
                                      struct window_surface *new ) DECLSPEC_HIDDEN;
 
-/* defwnd.c */
-extern LRESULT default_window_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                    BOOL ansi ) DECLSPEC_HIDDEN;
-extern LRESULT desktop_window_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
-extern void fill_rect( HDC dc, const RECT *rect, HBRUSH hbrush ) DECLSPEC_HIDDEN;
-
 /* hook.c */
 extern LRESULT call_current_hook( HHOOK hhook, INT code, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
 extern LRESULT call_hooks( INT id, INT code, WPARAM wparam, LPARAM lparam, BOOL unicode ) DECLSPEC_HIDDEN;
 extern BOOL unhook_windows_hook( INT id, HOOKPROC proc ) DECLSPEC_HIDDEN;
 
 /* input.c */
-extern BOOL destroy_caret(void) DECLSPEC_HIDDEN;
 extern LONG global_key_state_counter DECLSPEC_HIDDEN;
 extern HWND get_active_window(void) DECLSPEC_HIDDEN;
-extern HWND get_capture(void) DECLSPEC_HIDDEN;
 extern BOOL get_cursor_pos( POINT *pt ) DECLSPEC_HIDDEN;
 extern HWND get_focus(void) DECLSPEC_HIDDEN;
 extern DWORD get_input_state(void) DECLSPEC_HIDDEN;
 extern BOOL WINAPI release_capture(void) DECLSPEC_HIDDEN;
 extern BOOL set_capture_window( HWND hwnd, UINT gui_flags, HWND *prev_ret ) DECLSPEC_HIDDEN;
-extern BOOL set_caret_blink_time( unsigned int time ) DECLSPEC_HIDDEN;
-extern BOOL set_caret_pos( int x, int y ) DECLSPEC_HIDDEN;
 extern BOOL set_foreground_window( HWND hwnd, BOOL mouse ) DECLSPEC_HIDDEN;
-extern void toggle_caret( HWND hwnd ) DECLSPEC_HIDDEN;
-extern void update_mouse_tracking_info( HWND hwnd ) DECLSPEC_HIDDEN;
 
 /* menu.c */
-extern HMENU create_menu( BOOL is_popup ) DECLSPEC_HIDDEN;
-extern BOOL draw_menu_bar( HWND hwnd ) DECLSPEC_HIDDEN;
 extern HMENU get_menu( HWND hwnd ) DECLSPEC_HIDDEN;
-extern BOOL get_menu_info( HMENU handle, MENUINFO *info ) DECLSPEC_HIDDEN;
-extern INT get_menu_item_count( HMENU handle ) DECLSPEC_HIDDEN;
-extern BOOL set_window_menu( HWND hwnd, HMENU handle ) DECLSPEC_HIDDEN;
 
 /* message.c */
-extern LRESULT dispatch_message( const MSG *msg, BOOL ansi ) DECLSPEC_HIDDEN;
 extern BOOL kill_system_timer( HWND hwnd, UINT_PTR id ) DECLSPEC_HIDDEN;
-extern BOOL reply_message_result( LRESULT result, MSG *msg ) DECLSPEC_HIDDEN;
-extern NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput,
-                                       UINT flags ) DECLSPEC_HIDDEN;
-extern LRESULT send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid, UINT msg, WPARAM wparam,
-                                              LPARAM lparam, UINT flags, UINT timeout,
-                                              PDWORD_PTR res_ptr ) DECLSPEC_HIDDEN;
+extern LRESULT post_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
 extern LRESULT send_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
-extern LRESULT send_message_timeout( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                     UINT flags, UINT timeout, PDWORD_PTR res_ptr, BOOL ansi );
 
 /* sysparams.c */
-extern BOOL enable_thunk_lock DECLSPEC_HIDDEN;
 extern RECT get_display_rect( const WCHAR *display ) DECLSPEC_HIDDEN;
 extern UINT get_monitor_dpi( HMONITOR monitor ) DECLSPEC_HIDDEN;
 extern BOOL get_monitor_info( HMONITOR handle, MONITORINFO *info ) DECLSPEC_HIDDEN;
 extern UINT get_win_monitor_dpi( HWND hwnd ) DECLSPEC_HIDDEN;
 extern RECT get_primary_monitor_rect( UINT dpi ) DECLSPEC_HIDDEN;
-extern HBRUSH get_sys_color_brush( unsigned int index ) DECLSPEC_HIDDEN;
 extern UINT get_system_dpi(void) DECLSPEC_HIDDEN;
 extern int get_system_metrics( int index ) DECLSPEC_HIDDEN;
 extern UINT get_thread_dpi(void) DECLSPEC_HIDDEN;
-extern DPI_AWARENESS get_thread_dpi_awareness(void) DECLSPEC_HIDDEN;
 extern RECT get_virtual_screen_rect( UINT dpi ) DECLSPEC_HIDDEN;
 extern BOOL is_exiting_thread( DWORD tid ) DECLSPEC_HIDDEN;
 extern POINT map_dpi_point( POINT pt, UINT dpi_from, UINT dpi_to ) DECLSPEC_HIDDEN;
 extern RECT map_dpi_rect( RECT rect, UINT dpi_from, UINT dpi_to ) DECLSPEC_HIDDEN;
-extern POINT point_phys_to_win_dpi( HWND hwnd, POINT pt ) DECLSPEC_HIDDEN;
-extern POINT point_thread_to_win_dpi( HWND hwnd, POINT pt ) DECLSPEC_HIDDEN;
-extern RECT rect_thread_to_win_dpi( HWND hwnd, RECT rect ) DECLSPEC_HIDDEN;
 extern HMONITOR monitor_from_point( POINT pt, DWORD flags, UINT dpi ) DECLSPEC_HIDDEN;
 extern HMONITOR monitor_from_rect( const RECT *rect, DWORD flags, UINT dpi ) DECLSPEC_HIDDEN;
 extern HMONITOR monitor_from_window( HWND hwnd, DWORD flags, UINT dpi ) DECLSPEC_HIDDEN;
@@ -432,6 +348,9 @@ extern void user_lock(void) DECLSPEC_HIDDEN;
 extern void user_unlock(void) DECLSPEC_HIDDEN;
 extern void user_check_not_lock(void) DECLSPEC_HIDDEN;
 
+/* windc.c */
+extern void erase_now( HWND hwnd, UINT rdw_flags ) DECLSPEC_HIDDEN;
+
 /* window.c */
 struct tagWND;
 extern HDWP begin_defer_window_pos( INT count ) DECLSPEC_HIDDEN;
@@ -441,18 +360,14 @@ extern BOOL get_client_rect( HWND hwnd, RECT *rect ) DECLSPEC_HIDDEN;
 extern HWND get_desktop_window(void) DECLSPEC_HIDDEN;
 extern UINT get_dpi_for_window( HWND hwnd ) DECLSPEC_HIDDEN;
 extern HWND get_full_window_handle( HWND hwnd ) DECLSPEC_HIDDEN;
-extern HWND get_parent( HWND hwnd ) DECLSPEC_HIDDEN;
 extern HWND get_hwnd_message_parent(void) DECLSPEC_HIDDEN;
 extern DPI_AWARENESS_CONTEXT get_window_dpi_awareness_context( HWND hwnd ) DECLSPEC_HIDDEN;
-extern MINMAXINFO get_min_max_info( HWND hwnd ) DECLSPEC_HIDDEN;
-extern HWND get_window_relative( HWND hwnd, UINT rel ) DECLSPEC_HIDDEN;
+extern BOOL get_window_placement( HWND hwnd, WINDOWPLACEMENT *placement ) DECLSPEC_HIDDEN;
 extern DWORD get_window_thread( HWND hwnd, DWORD *process ) DECLSPEC_HIDDEN;
 extern HWND is_current_process_window( HWND hwnd ) DECLSPEC_HIDDEN;
 extern HWND is_current_thread_window( HWND hwnd ) DECLSPEC_HIDDEN;
 extern BOOL is_desktop_window( HWND hwnd ) DECLSPEC_HIDDEN;
 extern BOOL is_iconic( HWND hwnd ) DECLSPEC_HIDDEN;
-extern BOOL is_window_enabled( HWND hwnd ) DECLSPEC_HIDDEN;
-extern BOOL is_window_unicode( HWND hwnd ) DECLSPEC_HIDDEN;
 extern DWORD get_window_long( HWND hwnd, INT offset ) DECLSPEC_HIDDEN;
 extern BOOL get_window_rect( HWND hwnd, RECT *rect, UINT dpi ) DECLSPEC_HIDDEN;
 enum coords_relative;
@@ -463,14 +378,11 @@ extern HWND *list_window_children( HDESK desktop, HWND hwnd, UNICODE_STRING *cla
 extern int map_window_points( HWND hwnd_from, HWND hwnd_to, POINT *points, UINT count,
                               UINT dpi ) DECLSPEC_HIDDEN;
 extern void map_window_region( HWND from, HWND to, HRGN hrgn ) DECLSPEC_HIDDEN;
-extern BOOL screen_to_client( HWND hwnd, POINT *pt ) DECLSPEC_HIDDEN;
 extern LONG_PTR set_window_long( HWND hwnd, INT offset, UINT size, LONG_PTR newval,
                                  BOOL ansi ) DECLSPEC_HIDDEN;
 extern BOOL set_window_pos( WINDOWPOS *winpos, int parent_x, int parent_y ) DECLSPEC_HIDDEN;
 extern ULONG set_window_style( HWND hwnd, ULONG set_bits, ULONG clear_bits ) DECLSPEC_HIDDEN;
-extern BOOL show_owned_popups( HWND owner, BOOL show ) DECLSPEC_HIDDEN;
 extern void update_window_state( HWND hwnd ) DECLSPEC_HIDDEN;
-extern HWND window_from_point( HWND hwnd, POINT pt, INT *hittest ) DECLSPEC_HIDDEN;
 
 /* to release pointers retrieved by win_get_ptr */
 static inline void release_win_ptr( struct tagWND *ptr )
@@ -525,31 +437,102 @@ static inline WCHAR win32u_towupper( WCHAR ch )
     return RtlUpcaseUnicodeChar( ch );
 }
 
-extern CPTABLEINFO ansi_cp DECLSPEC_HIDDEN;
-
-DWORD win32u_mbtowc( CPTABLEINFO *info, WCHAR *dst, DWORD dstlen, const char *src,
-                     DWORD srclen ) DECLSPEC_HIDDEN;
-DWORD win32u_wctomb( CPTABLEINFO *info, char *dst, DWORD dstlen, const WCHAR *src,
-                     DWORD srclen ) DECLSPEC_HIDDEN;
-
-static inline WCHAR *win32u_wcsdup( const WCHAR *str )
+static inline LONG win32u_wcstol( LPCWSTR s, LPWSTR *end, INT base )
 {
-    DWORD size = (lstrlenW( str ) + 1) * sizeof(WCHAR);
-    WCHAR *ret = malloc( size );
-    if (ret) memcpy( ret, str, size );
+    BOOL negative = FALSE, empty = TRUE;
+    LONG ret = 0;
+
+    if (base < 0 || base == 1 || base > 36) return 0;
+    if (end) *end = (WCHAR *)s;
+    while (*s == ' ' || *s == '\t') s++;
+
+    if (*s == '-')
+    {
+        negative = TRUE;
+        s++;
+    }
+    else if (*s == '+') s++;
+
+    if ((base == 0 || base == 16) && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
+    {
+        base = 16;
+        s += 2;
+    }
+    if (base == 0) base = s[0] != '0' ? 10 : 8;
+
+    while (*s)
+    {
+        int v;
+
+        if ('0' <= *s && *s <= '9') v = *s - '0';
+        else if ('A' <= *s && *s <= 'Z') v = *s - 'A' + 10;
+        else if ('a' <= *s && *s <= 'z') v = *s - 'a' + 10;
+        else break;
+        if (v >= base) break;
+        if (negative) v = -v;
+        s++;
+        empty = FALSE;
+
+        if (!negative && (ret > MAXLONG / base || ret * base > MAXLONG - v))
+            ret = MAXLONG;
+        else if (negative && (ret < (LONG)MINLONG / base || ret * base < (LONG)(MINLONG - v)))
+            ret = MINLONG;
+        else
+            ret = ret * base + v;
+    }
+
+    if (end && !empty) *end = (WCHAR *)s;
     return ret;
 }
 
-static inline WCHAR *towstr( const char *str )
+static inline ULONG win32u_wcstoul( const WCHAR *s, WCHAR **end, int base )
 {
-    DWORD len = strlen( str ) + 1;
-    WCHAR *ret = malloc( len * sizeof(WCHAR) );
-    if (ret) win32u_mbtowc( &ansi_cp, ret, len, str, len );
-    return ret;
+    BOOL negative = FALSE, empty = TRUE;
+    ULONG ret = 0;
+
+    if (base < 0 || base == 1 || base > 36) return 0;
+    if (end) *end = (WCHAR *)s;
+    while (*s == ' ' || *s == '\t') s++;
+
+    if (*s == '-')
+    {
+        negative = TRUE;
+        s++;
+    }
+    else if (*s == '+') s++;
+
+    if ((base == 0 || base == 16) && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
+    {
+        base = 16;
+        s += 2;
+    }
+    if (base == 0) base = s[0] != '0' ? 10 : 8;
+
+    while (*s)
+    {
+        int v;
+
+        if ('0' <= *s && *s <= '9') v = *s - '0';
+        else if ('A' <= *s && *s <= 'Z') v = *s - 'A' + 10;
+        else if ('a' <= *s && *s <= 'z') v = *s - 'a' + 10;
+        else break;
+        if (v >= base) break;
+        s++;
+        empty = FALSE;
+
+        if (ret > MAXDWORD / base || ret * base > MAXDWORD - v)
+            ret = MAXDWORD;
+        else
+            ret = ret * base + v;
+    }
+
+    if (end && !empty) *end = (WCHAR *)s;
+    return negative ? -ret : ret;
 }
 
 #define towupper(c)     win32u_towupper(c)
-#define wcsdup(s)       win32u_wcsdup(s)
+#define wcstol(s,e,b)   win32u_wcstol(s,e,b)
+#define wcstoul(s,e,b)  win32u_wcstoul(s,e,b)
 
 static inline void ascii_to_unicode( WCHAR *dst, const char *src, size_t len )
 {
@@ -563,11 +546,23 @@ static inline UINT asciiz_to_unicode( WCHAR *dst, const char *src )
     return (p - dst) * sizeof(WCHAR);
 }
 
+DWORD win32u_mbtowc( CPTABLEINFO *info, WCHAR *dst, DWORD dstlen, const char *src,
+                     DWORD srclen ) DECLSPEC_HIDDEN;
+DWORD win32u_wctomb( CPTABLEINFO *info, char *dst, DWORD dstlen, const WCHAR *src,
+                     DWORD srclen ) DECLSPEC_HIDDEN;
+
 static inline BOOL is_win9x(void)
 {
     return NtCurrentTeb()->Peb->OSPlatformId == VER_PLATFORM_WIN32s;
 }
 
+static inline void init_unicode_string( UNICODE_STRING *str, const WCHAR *data )
+{
+    str->Length = lstrlenW(data) * sizeof(WCHAR);
+    str->MaximumLength = str->Length + sizeof(WCHAR);
+    str->Buffer = (WCHAR *)data;
+}
+
 static inline const char *debugstr_us( const UNICODE_STRING *us )
 {
     if (!us) return "<null>";
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 338063f5fb5..4195ad41881 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -48,10 +48,6 @@ static void *user_handles[NB_USER_HANDLES];
 #define SWP_AGG_NOCLIENTCHANGE \
         (SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)
 
-#define PLACE_MIN		0x0001
-#define PLACE_MAX		0x0002
-#define PLACE_RECT		0x0004
-
 /***********************************************************************
  *           alloc_user_handle
  */
@@ -104,7 +100,7 @@ void *get_user_handle_ptr( HANDLE handle, unsigned int type )
 /***********************************************************************
  *           set_user_handle_ptr
  */
-static void set_user_handle_ptr( HANDLE handle, struct user_object *ptr )
+void set_user_handle_ptr( HANDLE handle, struct user_object *ptr )
 {
     WORD index = USER_HANDLE_TO_INDEX(handle);
     assert( index < NB_USER_HANDLES );
@@ -170,7 +166,7 @@ static WND *next_thread_window_ptr( HWND *hwnd )
  */
 HWND get_hwnd_message_parent(void)
 {
-    struct ntuser_thread_info *thread_info = NtUserGetThreadInfo();
+    struct user_thread_info *thread_info = get_user_thread_info();
 
     if (!thread_info->msg_window) get_desktop_window(); /* trigger creation */
     return thread_info->msg_window;
@@ -222,7 +218,7 @@ HWND get_full_window_handle( HWND hwnd )
  */
 BOOL is_desktop_window( HWND hwnd )
 {
-    struct ntuser_thread_info *thread_info = NtUserGetThreadInfo();
+    struct user_thread_info *thread_info = get_user_thread_info();
 
     if (!hwnd) return FALSE;
     if (hwnd == thread_info->top_window) return TRUE;
@@ -348,7 +344,7 @@ DWORD get_window_thread( HWND hwnd, DWORD *process )
 }
 
 /* see GetParent */
-HWND get_parent( HWND hwnd )
+static HWND get_parent( HWND hwnd )
 {
     HWND retval = 0;
     WND *win;
@@ -483,7 +479,7 @@ HWND WINAPI NtUserSetParent( HWND hwnd, HWND parent )
 }
 
 /* see GetWindow */
-HWND get_window_relative( HWND hwnd, UINT rel )
+static HWND get_window_relative( HWND hwnd, UINT rel )
 {
     HWND retval = 0;
 
@@ -785,7 +781,7 @@ static BOOL is_window_drawable( HWND hwnd, BOOL icon )
 }
 
 /* see IsWindowUnicode */
-BOOL is_window_unicode( HWND hwnd )
+static BOOL is_window_unicode( HWND hwnd )
 {
     WND *win;
     BOOL ret = FALSE;
@@ -811,51 +807,6 @@ BOOL is_window_unicode( HWND hwnd )
     return ret;
 }
 
-/* see EnableWindow */
-static BOOL enable_window( HWND hwnd, BOOL enable )
-{
-    BOOL ret;
-
-    if (is_broadcast(hwnd))
-    {
-        SetLastError( ERROR_INVALID_PARAMETER );
-        return FALSE;
-    }
-
-    TRACE( "( %p, %d )\n", hwnd, enable );
-
-    if (enable)
-    {
-        ret = (set_window_style( hwnd, 0, WS_DISABLED ) & WS_DISABLED) != 0;
-        if (ret) send_message( hwnd, WM_ENABLE, TRUE, 0 );
-    }
-    else
-    {
-        send_message( hwnd, WM_CANCELMODE, 0, 0 );
-
-        ret = (set_window_style( hwnd, WS_DISABLED, 0 ) & WS_DISABLED) != 0;
-        if (!ret)
-        {
-            if (hwnd == get_focus())
-                NtUserSetFocus( 0 ); /* A disabled window can't have the focus */
-
-            send_message( hwnd, WM_ENABLE, FALSE, 0 );
-        }
-    }
-    return ret;
-}
-
-/* see IsWindowEnabled */
-BOOL is_window_enabled( HWND hwnd )
-{
-    LONG ret;
-
-    SetLastError( NO_ERROR );
-    ret = get_window_long( hwnd, GWL_STYLE );
-    if (!ret && GetLastError() != NO_ERROR) return FALSE;
-    return !(ret & WS_DISABLED);
-}
-
 /* see GetWindowDpiAwarenessContext */
 DPI_AWARENESS_CONTEXT get_window_dpi_awareness_context( HWND hwnd )
 {
@@ -1662,8 +1613,8 @@ BOOL get_window_rects( HWND hwnd, enum coords_relative relative, RECT *window_re
                 win = parent;
                 if (win->parent)
                 {
-                    OffsetRect( &window, win->client_rect.left, win->client_rect.top );
-                    OffsetRect( &client, win->client_rect.left, win->client_rect.top );
+                    offset_rect( &window, win->client_rect.left, win->client_rect.top );
+                    offset_rect( &client, win->client_rect.left, win->client_rect.top );
                 }
             }
             break;
@@ -1732,230 +1683,6 @@ static BOOL get_window_info( HWND hwnd, WINDOWINFO *info )
     return TRUE;
 }
 
-/***********************************************************************
- *           update_surface_region
- */
-static void update_surface_region( HWND hwnd )
-{
-    NTSTATUS status;
-    HRGN region = 0;
-    RGNDATA *data;
-    size_t size = 256;
-    WND *win = get_win_ptr( hwnd );
-
-    if (!win || win == WND_DESKTOP || win == WND_OTHER_PROCESS) return;
-    if (!win->surface) goto done;
-
-    do
-    {
-        if (!(data = malloc( FIELD_OFFSET( RGNDATA, Buffer[size] )))) goto done;
-
-        SERVER_START_REQ( get_surface_region )
-        {
-            req->window = wine_server_user_handle( hwnd );
-            wine_server_set_reply( req, data->Buffer, size );
-            if (!(status = wine_server_call( req )))
-            {
-                size_t reply_size = wine_server_reply_size( reply );
-                if (reply_size)
-                {
-                    data->rdh.dwSize   = sizeof(data->rdh);
-                    data->rdh.iType    = RDH_RECTANGLES;
-                    data->rdh.nCount   = reply_size / sizeof(RECT);
-                    data->rdh.nRgnSize = reply_size;
-                    region = NtGdiExtCreateRegion( NULL, data->rdh.dwSize + data->rdh.nRgnSize, data );
-                    NtGdiOffsetRgn( region, -reply->visible_rect.left, -reply->visible_rect.top );
-                }
-            }
-            else size = reply->total_size;
-        }
-        SERVER_END_REQ;
-        free( data );
-    } while (status == STATUS_BUFFER_OVERFLOW);
-
-    if (status) goto done;
-
-    win->surface->funcs->set_region( win->surface, region );
-    if (region) NtGdiDeleteObjectApp( region );
-
-done:
-    release_win_ptr( win );
-}
-
-/***********************************************************************
- *           apply_window_pos
- *
- * Backend implementation of SetWindowPos.
- */
-static BOOL apply_window_pos( HWND hwnd, HWND insert_after, UINT swp_flags,
-                              const RECT *window_rect, const RECT *client_rect, const RECT *valid_rects )
-{
-    WND *win;
-    HWND surface_win = 0, parent = NtUserGetAncestor( hwnd, GA_PARENT );
-    BOOL ret, needs_update = FALSE;
-    RECT visible_rect, old_visible_rect, old_window_rect, old_client_rect, extra_rects[3];
-    struct window_surface *old_surface, *new_surface = NULL;
-
-    if (!parent || parent == get_desktop_window())
-    {
-        new_surface = &dummy_surface;  /* provide a default surface for top-level windows */
-        window_surface_add_ref( new_surface );
-    }
-    visible_rect = *window_rect;
-    if (!(ret = user_driver->pWindowPosChanging( hwnd, insert_after, swp_flags,
-                                                 window_rect, client_rect, &visible_rect, &new_surface )))
-    {
-        if (IsRectEmpty( window_rect )) visible_rect = *window_rect;
-        else
-        {
-            visible_rect = get_virtual_screen_rect( get_thread_dpi() );
-            intersect_rect( &visible_rect, &visible_rect, window_rect );
-        }
-    }
-
-    get_window_rects( hwnd, COORDS_SCREEN, &old_window_rect, NULL, get_thread_dpi() );
-    if (IsRectEmpty( &valid_rects[0] )) valid_rects = NULL;
-
-    if (!(win = get_win_ptr( hwnd )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
-    {
-        if (new_surface) window_surface_release( new_surface );
-        return FALSE;
-    }
-
-    /* create or update window surface for top-level windows if the driver doesn't implement WindowPosChanging */
-    if (!ret && new_surface && !IsRectEmpty( &visible_rect ) &&
-        (!(get_window_long( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED) ||
-           NtUserGetLayeredWindowAttributes( hwnd, NULL, NULL, NULL )))
-    {
-        window_surface_release( new_surface );
-        if ((new_surface = win->surface)) window_surface_add_ref( new_surface );
-        create_offscreen_window_surface( &visible_rect, &new_surface );
-    }
-
-    old_visible_rect = win->visible_rect;
-    old_client_rect = win->client_rect;
-    old_surface = win->surface;
-    if (old_surface != new_surface) swp_flags |= SWP_FRAMECHANGED;  /* force refreshing non-client area */
-    if (new_surface == &dummy_surface) swp_flags |= SWP_NOREDRAW;
-    else if (old_surface == &dummy_surface)
-    {
-        swp_flags |= SWP_NOCOPYBITS;
-        valid_rects = NULL;
-    }
-
-    SERVER_START_REQ( set_window_pos )
-    {
-        req->handle        = wine_server_user_handle( hwnd );
-        req->previous      = wine_server_user_handle( insert_after );
-        req->swp_flags     = swp_flags;
-        req->window.left   = window_rect->left;
-        req->window.top    = window_rect->top;
-        req->window.right  = window_rect->right;
-        req->window.bottom = window_rect->bottom;
-        req->client.left   = client_rect->left;
-        req->client.top    = client_rect->top;
-        req->client.right  = client_rect->right;
-        req->client.bottom = client_rect->bottom;
-        if (!EqualRect( window_rect, &visible_rect ) || new_surface || valid_rects)
-        {
-            extra_rects[0] = extra_rects[1] = visible_rect;
-            if (new_surface)
-            {
-                extra_rects[1] = new_surface->rect;
-                OffsetRect( &extra_rects[1], visible_rect.left, visible_rect.top );
-            }
-            if (valid_rects) extra_rects[2] = valid_rects[0];
-            else SetRectEmpty( &extra_rects[2] );
-            wine_server_add_data( req, extra_rects, sizeof(extra_rects) );
-        }
-        if (new_surface) req->paint_flags |= SET_WINPOS_PAINT_SURFACE;
-        if (win->pixel_format) req->paint_flags |= SET_WINPOS_PIXEL_FORMAT;
-
-        if ((ret = !wine_server_call( req )))
-        {
-            win->dwStyle      = reply->new_style;
-            win->dwExStyle    = reply->new_ex_style;
-            win->window_rect  = *window_rect;
-            win->client_rect  = *client_rect;
-            win->visible_rect = visible_rect;
-            win->surface      = new_surface;
-            surface_win       = wine_server_ptr_handle( reply->surface_win );
-            needs_update      = reply->needs_update;
-            if (get_window_long( win->parent, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL)
-            {
-                RECT client;
-                get_window_rects( win->parent, COORDS_CLIENT, NULL, &client, get_thread_dpi() );
-                mirror_rect( &client, &win->window_rect );
-                mirror_rect( &client, &win->client_rect );
-                mirror_rect( &client, &win->visible_rect );
-            }
-            /* if an RTL window is resized the children have moved */
-            if (win->dwExStyle & WS_EX_LAYOUTRTL &&
-                client_rect->right - client_rect->left != old_client_rect.right - old_client_rect.left)
-                win->flags |= WIN_CHILDREN_MOVED;
-        }
-    }
-    SERVER_END_REQ;
-
-    if (ret)
-    {
-        if (needs_update) update_surface_region( surface_win );
-        if (((swp_flags & SWP_AGG_NOPOSCHANGE) != SWP_AGG_NOPOSCHANGE) ||
-            (swp_flags & (SWP_HIDEWINDOW | SWP_SHOWWINDOW | SWP_STATECHANGED | SWP_FRAMECHANGED)))
-            invalidate_dce( win, &old_window_rect );
-    }
-
-    release_win_ptr( win );
-
-    if (ret)
-    {
-        TRACE( "win %p surface %p -> %p\n", hwnd, old_surface, new_surface );
-        register_window_surface( old_surface, new_surface );
-        if (old_surface)
-        {
-            if (valid_rects)
-            {
-                move_window_bits( hwnd, old_surface, new_surface, &visible_rect,
-                                  &old_visible_rect, window_rect, valid_rects );
-                valid_rects = NULL;  /* prevent the driver from trying to also move the bits */
-            }
-            window_surface_release( old_surface );
-        }
-        else if (surface_win && surface_win != hwnd)
-        {
-            if (valid_rects)
-            {
-                RECT rects[2];
-                int x_offset = old_visible_rect.left - visible_rect.left;
-                int y_offset = old_visible_rect.top - visible_rect.top;
-
-                /* if all that happened is that the whole window moved, copy everything */
-                if (!(swp_flags & SWP_FRAMECHANGED) &&
-                    old_visible_rect.right  - visible_rect.right  == x_offset &&
-                    old_visible_rect.bottom - visible_rect.bottom == y_offset &&
-                    old_client_rect.left    - client_rect->left   == x_offset &&
-                    old_client_rect.right   - client_rect->right  == x_offset &&
-                    old_client_rect.top     - client_rect->top    == y_offset &&
-                    old_client_rect.bottom  - client_rect->bottom == y_offset &&
-                    EqualRect( &valid_rects[0], client_rect ))
-                {
-                    rects[0] = visible_rect;
-                    rects[1] = old_visible_rect;
-                    valid_rects = rects;
-                }
-                move_window_bits_parent( hwnd, surface_win, window_rect, valid_rects );
-                valid_rects = NULL;  /* prevent the driver from trying to also move the bits */
-            }
-        }
-
-        user_driver->pWindowPosChanged( hwnd, insert_after, swp_flags, window_rect,
-                                        client_rect, &visible_rect, valid_rects, new_surface );
-    }
-    else if (new_surface) window_surface_release( new_surface );
-
-    return ret;
-}
-
 /*******************************************************************
  *           NtUserGetWindowRgnEx (win32u.@)
  */
@@ -2175,7 +1902,8 @@ BOOL WINAPI NtUserUpdateLayeredWindow( HWND hwnd, HDC hdc_dst, const POINT *pts_
     TRACE( "window %p win %s client %s\n", hwnd,
            wine_dbgstr_rect(&window_rect), wine_dbgstr_rect(&client_rect) );
 
-    apply_window_pos( hwnd, 0, swp_flags, &window_rect, &client_rect, NULL );
+    if (user_callbacks)
+        user_callbacks->set_window_pos( hwnd, 0, swp_flags, &window_rect, &client_rect, NULL );
 
     info.cbSize   = sizeof(info);
     info.hdcDst   = hdc_dst;
@@ -2238,7 +1966,7 @@ static HWND *list_children_from_point( HWND hwnd, POINT pt )
  *
  * Find the window and hittest for a given point.
  */
-HWND window_from_point( HWND hwnd, POINT pt, INT *hittest )
+static HWND window_from_point( HWND hwnd, POINT pt, INT *hittest )
 {
     int i, res;
     HWND ret, *list;
@@ -2293,43 +2021,6 @@ HWND WINAPI NtUserWindowFromPoint( LONG x, LONG y )
     return window_from_point( 0, pt, &hittest );
 }
 
-/*******************************************************************
- *           NtUserChildWindowFromPointEx (win32u.@)
- */
-HWND WINAPI NtUserChildWindowFromPointEx( HWND parent, LONG x, LONG y, UINT flags )
-{
-    POINT pt = { .x = x, .y = y }; /* in the client coordinates */
-    HWND *list;
-    int i;
-    RECT rect;
-    HWND ret;
-
-    get_client_rect( parent, &rect );
-    if (!PtInRect( &rect, pt )) return 0;
-    if (!(list = list_window_children( 0, parent, NULL, 0 ))) return parent;
-
-    for (i = 0; list[i]; i++)
-    {
-        if (!get_window_rects( list[i], COORDS_PARENT, &rect, NULL, get_thread_dpi() )) continue;
-        if (!PtInRect( &rect, pt )) continue;
-        if (flags & (CWP_SKIPINVISIBLE|CWP_SKIPDISABLED))
-        {
-            LONG style = get_window_long( list[i], GWL_STYLE );
-            if ((flags & CWP_SKIPINVISIBLE) && !(style & WS_VISIBLE)) continue;
-            if ((flags & CWP_SKIPDISABLED) && (style & WS_DISABLED)) continue;
-        }
-        if (flags & CWP_SKIPTRANSPARENT)
-        {
-            if (get_window_long( list[i], GWL_EXSTYLE ) & WS_EX_TRANSPARENT) continue;
-        }
-        break;
-    }
-    ret = list[i];
-    free( list );
-    if (!ret) ret = parent;
-    return ret;
-}
-
 /*******************************************************************
  *           get_work_rect
  *
@@ -2400,10 +2091,8 @@ static BOOL empty_point( POINT pt )
     return pt.x == -1 && pt.y == -1;
 }
 
-/***********************************************************************
- *           NtUserGetWindowPlacement (win32u.@)
- */
-BOOL WINAPI NtUserGetWindowPlacement( HWND hwnd, WINDOWPLACEMENT *placement )
+/* see GetWindowPlacement */
+BOOL get_window_placement( HWND hwnd, WINDOWPLACEMENT *placement )
 {
     RECT work_rect = get_maximized_work_rect( hwnd );
     WND *win = get_win_ptr( hwnd );
@@ -2490,121 +2179,6 @@ BOOL WINAPI NtUserGetWindowPlacement( HWND hwnd, WINDOWPLACEMENT *placement )
     return TRUE;
 }
 
-/* make sure the specified rect is visible on screen */
-static void make_rect_onscreen( RECT *rect )
-{
-    MONITORINFO info;
-    HMONITOR monitor = monitor_from_rect( rect, MONITOR_DEFAULTTONEAREST, get_thread_dpi() );
-
-    info.cbSize = sizeof(info);
-    if (!monitor || !get_monitor_info( monitor, &info )) return;
-    /* FIXME: map coordinates from rcWork to rcMonitor */
-    if (rect->right <= info.rcWork.left)
-    {
-        rect->right += info.rcWork.left - rect->left;
-        rect->left = info.rcWork.left;
-    }
-    else if (rect->left >= info.rcWork.right)
-    {
-        rect->left += info.rcWork.right - rect->right;
-        rect->right = info.rcWork.right;
-    }
-    if (rect->bottom <= info.rcWork.top)
-    {
-        rect->bottom += info.rcWork.top - rect->top;
-        rect->top = info.rcWork.top;
-    }
-    else if (rect->top >= info.rcWork.bottom)
-    {
-        rect->top += info.rcWork.bottom - rect->bottom;
-        rect->bottom = info.rcWork.bottom;
-    }
-}
-
-/* make sure the specified point is visible on screen */
-static void make_point_onscreen( POINT *pt )
-{
-    RECT rect;
-
-    SetRect( &rect, pt->x, pt->y, pt->x + 1, pt->y + 1 );
-    make_rect_onscreen( &rect );
-    pt->x = rect.left;
-    pt->y = rect.top;
-}
-
-static BOOL set_window_placement( HWND hwnd, const WINDOWPLACEMENT *wndpl, UINT flags )
-{
-    RECT work_rect = get_maximized_work_rect( hwnd );
-    WND *win = get_win_ptr( hwnd );
-    WINDOWPLACEMENT wp = *wndpl;
-    DWORD style;
-
-    if (flags & PLACE_MIN) make_point_onscreen( &wp.ptMinPosition );
-    if (flags & PLACE_MAX) make_point_onscreen( &wp.ptMaxPosition );
-    if (flags & PLACE_RECT) make_rect_onscreen( &wp.rcNormalPosition );
-
-    TRACE( "%p: setting min %d,%d max %d,%d normal %s flags %x adjusted to min %d,%d max %d,%d normal %s\n",
-           hwnd, wndpl->ptMinPosition.x, wndpl->ptMinPosition.y,
-           wndpl->ptMaxPosition.x, wndpl->ptMaxPosition.y,
-           wine_dbgstr_rect(&wndpl->rcNormalPosition), flags,
-           wp.ptMinPosition.x, wp.ptMinPosition.y, wp.ptMaxPosition.x, wp.ptMaxPosition.y,
-           wine_dbgstr_rect(&wp.rcNormalPosition) );
-
-    if (!win || win == WND_OTHER_PROCESS || win == WND_DESKTOP) return FALSE;
-
-    if (flags & PLACE_MIN) win->min_pos = point_thread_to_win_dpi( hwnd, wp.ptMinPosition );
-    if (flags & PLACE_MAX)
-    {
-        win->max_pos = point_thread_to_win_dpi( hwnd, wp.ptMaxPosition );
-        update_maximized_pos( win, &work_rect );
-    }
-    if (flags & PLACE_RECT) win->normal_rect = rect_thread_to_win_dpi( hwnd, wp.rcNormalPosition );
-
-    style = win->dwStyle;
-
-    release_win_ptr( win );
-
-    if (style & WS_MINIMIZE)
-    {
-        if (flags & PLACE_MIN)
-        {
-            NtUserSetWindowPos( hwnd, 0, wp.ptMinPosition.x, wp.ptMinPosition.y, 0, 0,
-                                SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
-        }
-    }
-    else if (style & WS_MAXIMIZE)
-    {
-        if (flags & PLACE_MAX)
-            NtUserSetWindowPos( hwnd, 0, wp.ptMaxPosition.x, wp.ptMaxPosition.y, 0, 0,
-                                SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
-    }
-    else if (flags & PLACE_RECT)
-        NtUserSetWindowPos( hwnd, 0, wp.rcNormalPosition.left, wp.rcNormalPosition.top,
-                            wp.rcNormalPosition.right - wp.rcNormalPosition.left,
-                            wp.rcNormalPosition.bottom - wp.rcNormalPosition.top,
-                            SWP_NOZORDER | SWP_NOACTIVATE );
-
-    NtUserShowWindow( hwnd, wndpl->showCmd );
-
-    if (is_iconic( hwnd ))
-    {
-        if (wndpl->flags & WPF_RESTORETOMAXIMIZED)
-            win_set_flags( hwnd, WIN_RESTORE_MAX, 0 );
-    }
-    return TRUE;
-}
-
-/***********************************************************************
- *           NtUserSetWindowPlacement (win32u.@)
- */
-BOOL WINAPI NtUserSetWindowPlacement( HWND hwnd, const WINDOWPLACEMENT *wpl )
-{
-    UINT flags = PLACE_MAX | PLACE_RECT;
-    if (!wpl) return FALSE;
-    if (wpl->flags & WPF_SETMINPOSITION) flags |= PLACE_MIN;
-    return set_window_placement( hwnd, wpl, flags );
-}
-
 /*****************************************************************************
  *           NtUserBuildHwndList (win32u.@)
  */
@@ -2634,55 +2208,6 @@ NTSTATUS WINAPI NtUserBuildHwndList( HDESK desktop, ULONG unk2, ULONG unk3, ULON
     return STATUS_SUCCESS;
 }
 
-/***********************************************************************
- *           NtUserFindWindowEx (USER32.@)
- */
-HWND WINAPI NtUserFindWindowEx( HWND parent, HWND child, UNICODE_STRING *class, UNICODE_STRING *title,
-                                ULONG unk )
-{
-    HWND *list;
-    HWND retvalue = 0;
-    int i = 0, len = 0, title_len;
-    WCHAR *buffer = NULL;
-
-    if (!parent && child) parent = get_desktop_window();
-    else if (parent == HWND_MESSAGE) parent = get_hwnd_message_parent();
-
-    if (title)
-    {
-        len = title->Length / sizeof(WCHAR) + 1;  /* one extra char to check for chars beyond the end */
-        if (!(buffer = malloc( (len + 1) * sizeof(WCHAR) ))) return 0;
-    }
-
-    if (!(list = list_window_children( 0, parent, class, 0 ))) goto done;
-
-    if (child)
-    {
-        child = get_full_window_handle( child );
-        while (list[i] && list[i] != child) i++;
-        if (!list[i]) goto done;
-        i++;  /* start from next window */
-    }
-
-    if (title)
-    {
-        while (list[i])
-        {
-            title_len = NtUserInternalGetWindowText( list[i], buffer, len + 1 );
-            if (title_len * sizeof(WCHAR) == title->Length &&
-                (!title_len || !wcsnicmp( buffer, title->Buffer, title_len )))
-                break;
-            i++;
-        }
-    }
-    retvalue = list[i];
-
- done:
-    free( list );
-    free( buffer );
-    return retvalue;
-}
-
 /* Retrieve the window text from the server. */
 static data_size_t get_server_window_text( HWND hwnd, WCHAR *text, data_size_t count )
 {
@@ -2839,27 +2364,8 @@ other_process:  /* one of the parents may belong to another process, do it the h
     return ret;
 }
 
-/* see ClientToScreen */
-static BOOL client_to_screen( HWND hwnd, POINT *pt )
-{
-    POINT offset;
-    BOOL mirrored;
-
-    if (!hwnd)
-    {
-        SetLastError( ERROR_INVALID_WINDOW_HANDLE );
-        return FALSE;
-    }
-
-    if (!get_windows_offset( hwnd, 0, get_thread_dpi(), &mirrored, &offset )) return FALSE;
-    pt->x += offset.x;
-    pt->y += offset.y;
-    if (mirrored) pt->x = -pt->x;
-    return TRUE;
-}
-
 /* see ScreenToClient */
-BOOL screen_to_client( HWND hwnd, POINT *pt )
+static BOOL screen_to_client( HWND hwnd, POINT *pt )
 {
     POINT offset;
     BOOL mirrored;
@@ -3035,7 +2541,7 @@ static BOOL calc_winpos( WINDOWPOS *winpos, RECT *old_window_rect, RECT *old_cli
         new_window_rect->right  += winpos->x - old_window_rect->left;
         new_window_rect->bottom += winpos->y - old_window_rect->top;
 
-        OffsetRect( new_client_rect, winpos->x - old_window_rect->left,
+        offset_rect( new_client_rect, winpos->x - old_window_rect->left,
                      winpos->y - old_window_rect->top );
     }
     winpos->flags |= SWP_NOCLIENTMOVE | SWP_NOCLIENTSIZE;
@@ -3424,14 +2930,17 @@ BOOL set_window_pos( WINDOWPOS *winpos, int parent_x, int parent_y )
     calc_ncsize( winpos, &old_window_rect, &old_client_rect,
                  &new_window_rect, &new_client_rect, valid_rects, parent_x, parent_y );
 
-    if (!apply_window_pos( winpos->hwnd, winpos->hwndInsertAfter, winpos->flags,
-                           &new_window_rect, &new_client_rect, valid_rects ))
+    if (!user_callbacks || !user_callbacks->set_window_pos( winpos->hwnd, winpos->hwndInsertAfter, winpos->flags,
+                                                            &new_window_rect, &new_client_rect, valid_rects ))
         goto done;
 
-    if (winpos->flags & SWP_HIDEWINDOW)
-        NtUserHideCaret( winpos->hwnd );
-    else if (winpos->flags & SWP_SHOWWINDOW)
-        NtUserShowCaret( winpos->hwnd );
+    if (user_callbacks)
+    {
+        if (winpos->flags & SWP_HIDEWINDOW)
+            user_callbacks->pHideCaret( winpos->hwnd );
+        else if (winpos->flags & SWP_SHOWWINDOW)
+            user_callbacks->pShowCaret( winpos->hwnd );
+    }
 
     if (!(winpos->flags & (SWP_NOACTIVATE|SWP_HIDEWINDOW)))
     {
@@ -3515,7 +3024,7 @@ BOOL WINAPI NtUserSetWindowPos( HWND hwnd, HWND after, INT x, INT y, INT cx, INT
 
     if (flags & SWP_ASYNCWINDOWPOS)
         return NtUserMessageCall( winpos.hwnd, WM_WINE_SETWINDOWPOS, 0, (LPARAM)&winpos,
-                                  0, NtUserSendNotifyMessage, FALSE );
+                                  0, FNID_SENDNOTIFYMESSAGE, FALSE );
     else
         return send_message( winpos.hwnd, WM_WINE_SETWINDOWPOS, 0, (LPARAM)&winpos );
 }
@@ -3680,32 +3189,6 @@ BOOL WINAPI NtUserEndDeferWindowPosEx( HDWP hdwp, BOOL async )
     return TRUE;
 }
 
-/***********************************************************************
- *           NtUserSetInternalWindowPos (win32u.@)
- */
-void WINAPI NtUserSetInternalWindowPos( HWND hwnd, UINT cmd, RECT *rect, POINT *pt )
-{
-    WINDOWPLACEMENT wndpl;
-    UINT flags;
-
-    wndpl.length  = sizeof(wndpl);
-    wndpl.showCmd = cmd;
-    wndpl.flags = flags = 0;
-
-    if (pt)
-    {
-        flags |= PLACE_MIN;
-        wndpl.flags |= WPF_SETMINPOSITION;
-        wndpl.ptMinPosition = *pt;
-    }
-    if( rect )
-    {
-        flags |= PLACE_RECT;
-        wndpl.rcNormalPosition = *rect;
-    }
-    set_window_placement( hwnd, &wndpl, flags );
-}
-
 /***********************************************************************
  *           win_set_flags
  *
@@ -3804,7 +3287,7 @@ static void send_parent_notify( HWND hwnd, UINT msg )
  *
  * Get the minimized and maximized information for a window.
  */
-MINMAXINFO get_min_max_info( HWND hwnd )
+static MINMAXINFO get_min_max_info( HWND hwnd )
 {
     LONG style = get_window_long( hwnd, GWL_STYLE );
     LONG exstyle = get_window_long( hwnd, GWL_EXSTYLE );
@@ -3830,7 +3313,9 @@ MINMAXINFO get_min_max_info( HWND hwnd )
         adjusted_style = style;
 
     get_client_rect( NtUserGetAncestor( hwnd, GA_PARENT ), &rc );
-    AdjustWindowRectEx( &rc, adjusted_style, (style & WS_POPUP) && get_menu( hwnd ), exstyle );
+    if (user_callbacks)
+        user_callbacks->pAdjustWindowRectEx( &rc, adjusted_style,
+                                             (style & WS_POPUP) && get_menu( hwnd ), exstyle);
 
     xinc = -rc.left;
     yinc = -rc.top;
@@ -4014,7 +3499,7 @@ static POINT get_minimized_pos( HWND hwnd, POINT pt )
     pt = get_first_minimized_child_pos( &parent_rect, &metrics, width, height );
     for (;;)
     {
-        SetRect( &rect, pt.x, pt.y, pt.x + width, pt.y + height );
+        set_rect( &rect, pt.x, pt.y, pt.x + width, pt.y + height );
         if (!NtGdiRectInRegion( hrgn, &rect ))
             break;
 
@@ -4038,7 +3523,7 @@ static UINT window_min_maximize( HWND hwnd, UINT cmd, RECT *rect )
     TRACE( "%p %u\n", hwnd, cmd );
 
     wpl.length = sizeof(wpl);
-    NtUserGetWindowPlacement( hwnd, &wpl );
+    get_window_placement( hwnd, &wpl );
 
     if (call_hooks( WH_CBT, HCBT_MINMAX, (WPARAM)hwnd, cmd, TRUE ))
         return SWP_NOSIZE | SWP_NOMOVE;
@@ -4053,9 +3538,9 @@ static UINT window_min_maximize( HWND hwnd, UINT cmd, RECT *rect )
         case SW_MINIMIZE:
             wpl.ptMinPosition = get_minimized_pos( hwnd, wpl.ptMinPosition );
 
-            SetRect( rect, wpl.ptMinPosition.x, wpl.ptMinPosition.y,
-                     wpl.ptMinPosition.x + get_system_metrics( SM_CXMINIMIZED ),
-                     wpl.ptMinPosition.y + get_system_metrics( SM_CYMINIMIZED ));
+            set_rect( rect, wpl.ptMinPosition.x, wpl.ptMinPosition.y,
+                      wpl.ptMinPosition.x + get_system_metrics( SM_CXMINIMIZED ),
+                      wpl.ptMinPosition.y + get_system_metrics( SM_CYMINIMIZED ));
             return SWP_NOSIZE | SWP_NOMOVE;
         }
         if (!send_message( hwnd, WM_QUERYOPEN, 0, 0 )) return SWP_NOSIZE | SWP_NOMOVE;
@@ -4084,9 +3569,9 @@ static UINT window_min_maximize( HWND hwnd, UINT cmd, RECT *rect )
         wpl.ptMinPosition = get_minimized_pos( hwnd, wpl.ptMinPosition );
 
         if (!(old_style & WS_MINIMIZE)) swp_flags |= SWP_STATECHANGED;
-        SetRect( rect, wpl.ptMinPosition.x, wpl.ptMinPosition.y,
-                 wpl.ptMinPosition.x + get_system_metrics(SM_CXMINIMIZED),
-                 wpl.ptMinPosition.y + get_system_metrics(SM_CYMINIMIZED) );
+        set_rect( rect, wpl.ptMinPosition.x, wpl.ptMinPosition.y,
+                  wpl.ptMinPosition.x + get_system_metrics(SM_CXMINIMIZED),
+                  wpl.ptMinPosition.y + get_system_metrics(SM_CYMINIMIZED) );
         swp_flags |= SWP_NOCOPYBITS;
         break;
 
@@ -4101,9 +3586,9 @@ static UINT window_min_maximize( HWND hwnd, UINT cmd, RECT *rect )
             win_set_flags( hwnd, WIN_RESTORE_MAX, 0 );
 
         if (!(old_style & WS_MAXIMIZE)) swp_flags |= SWP_STATECHANGED;
-        SetRect( rect, minmax.ptMaxPosition.x, minmax.ptMaxPosition.y,
-                 minmax.ptMaxPosition.x + minmax.ptMaxSize.x,
-                 minmax.ptMaxPosition.y + minmax.ptMaxSize.y );
+        set_rect( rect, minmax.ptMaxPosition.x, minmax.ptMaxPosition.y,
+                  minmax.ptMaxPosition.x + minmax.ptMaxSize.x,
+                  minmax.ptMaxPosition.y + minmax.ptMaxSize.y );
         break;
 
     case SW_SHOWNOACTIVATE:
@@ -4121,9 +3606,9 @@ static UINT window_min_maximize( HWND hwnd, UINT cmd, RECT *rect )
                 minmax = get_min_max_info( hwnd );
                 set_window_style( hwnd, WS_MAXIMIZE, 0 );
                 swp_flags |= SWP_STATECHANGED;
-                SetRect( rect, minmax.ptMaxPosition.x, minmax.ptMaxPosition.y,
-                         minmax.ptMaxPosition.x + minmax.ptMaxSize.x,
-                         minmax.ptMaxPosition.y + minmax.ptMaxSize.y );
+                set_rect( rect, minmax.ptMaxPosition.x, minmax.ptMaxPosition.y,
+                          minmax.ptMaxPosition.x + minmax.ptMaxSize.x,
+                          minmax.ptMaxPosition.y + minmax.ptMaxSize.y );
                 break;
             }
         }
@@ -4140,48 +3625,6 @@ static UINT window_min_maximize( HWND hwnd, UINT cmd, RECT *rect )
     return swp_flags;
 }
 
-/* see ArrangeIconicWindows */
-static UINT arrange_iconic_windows( HWND parent )
-{
-    int width, height, count = 0;
-    MINIMIZEDMETRICS metrics;
-    RECT parent_rect;
-    HWND child;
-    POINT pt;
-
-    metrics.cbSize = sizeof(metrics);
-    NtUserSystemParametersInfo( SPI_GETMINIMIZEDMETRICS, sizeof(metrics), &metrics, 0 );
-    width  = get_system_metrics( SM_CXMINIMIZED );
-    height = get_system_metrics( SM_CYMINIMIZED );
-
-    if (parent == get_desktop_window())
-    {
-        MONITORINFO mon_info;
-        HMONITOR monitor = monitor_from_window( 0, MONITOR_DEFAULTTOPRIMARY, get_thread_dpi() );
-
-        mon_info.cbSize = sizeof( mon_info );
-        get_monitor_info( monitor, &mon_info );
-        parent_rect = mon_info.rcWork;
-    }
-    else get_client_rect( parent, &parent_rect );
-
-    pt = get_first_minimized_child_pos( &parent_rect, &metrics, width, height );
-
-    child = get_window_relative( parent, GW_CHILD );
-    while (child)
-    {
-        if (is_iconic( child ))
-        {
-            NtUserSetWindowPos( child, 0, pt.x, pt.y, 0, 0,
-                                SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );
-            get_next_minimized_child_pos( &parent_rect, &metrics, width, height, &pt );
-            count++;
-        }
-        child = get_window_relative( child, GW_HWNDNEXT );
-    }
-    return count;
-}
-
 /*******************************************************************
  *           update_window_state
  *
@@ -4194,16 +3637,17 @@ void update_window_state( HWND hwnd )
 
     if (!is_current_thread_window( hwnd ))
     {
-        NtUserPostMessage( hwnd, WM_WINE_UPDATEWINDOWSTATE, 0, 0 );
+        post_message( hwnd, WM_WINE_UPDATEWINDOWSTATE, 0, 0 );
         return;
     }
 
     context = set_thread_dpi_awareness_context( get_window_dpi_awareness_context( hwnd ));
     get_window_rects( hwnd, COORDS_PARENT, &window_rect, &client_rect, get_thread_dpi() );
     valid_rects[0] = valid_rects[1] = client_rect;
-    apply_window_pos( hwnd, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE |
-                      SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW,
-                      &window_rect, &client_rect, valid_rects );
+    if (user_callbacks)
+        user_callbacks->set_window_pos( hwnd, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE |
+                                        SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW,
+                                        &window_rect, &client_rect, valid_rects );
     set_thread_dpi_awareness_context( context );
 }
 
@@ -4302,7 +3746,7 @@ static BOOL show_window( HWND hwnd, INT cmd )
         if (get_window_long( hwnd, GWL_STYLE ) & WS_CHILD) new_swp = swp;
         else if (is_iconic( hwnd ) && (newPos.left != -32000 || newPos.top != -32000))
         {
-            OffsetRect( &newPos, -32000 - newPos.left, -32000 - newPos.top );
+            offset_rect( &newPos, -32000 - newPos.left, -32000 - newPos.top );
             new_swp = swp & ~(SWP_NOMOVE | SWP_NOCLIENTMOVE);
         }
         else new_swp = swp;
@@ -4401,7 +3845,7 @@ BOOL WINAPI NtUserShowWindowAsync( HWND hwnd, INT cmd )
         return show_window( full_handle, cmd );
 
     return NtUserMessageCall( hwnd, WM_WINE_SHOWWINDOW, cmd, 0, 0,
-                              NtUserSendNotifyMessage, FALSE );
+                              FNID_SENDNOTIFYMESSAGE, FALSE );
 }
 
 /***********************************************************************
@@ -4428,42 +3872,6 @@ BOOL WINAPI NtUserShowWindow( HWND hwnd, INT cmd )
     return send_message( hwnd, WM_WINE_SHOWWINDOW, cmd, 0 );
 }
 
-/* see ShowOwnedPopups */
-BOOL show_owned_popups( HWND owner, BOOL show )
-{
-    int count = 0;
-    HWND *win_array = list_window_children( 0, get_desktop_window(), NULL, 0 );
-
-    if (!win_array) return TRUE;
-
-    while (win_array[count]) count++;
-    while (--count >= 0)
-    {
-        if (get_window_relative( win_array[count], GW_OWNER ) != owner) continue;
-        if (show)
-        {
-            if (win_get_flags( win_array[count] ) & WIN_NEEDS_SHOW_OWNEDPOPUP)
-                /* In Windows, ShowOwnedPopups(TRUE) generates
-                 * WM_SHOWWINDOW messages with SW_PARENTOPENING,
-                 * regardless of the state of the owner
-                 */
-                send_message( win_array[count], WM_SHOWWINDOW, SW_SHOWNORMAL, SW_PARENTOPENING );
-        }
-        else
-        {
-            if (get_window_long( win_array[count], GWL_STYLE ) & WS_VISIBLE)
-                /* In Windows, ShowOwnedPopups(FALSE) generates
-                 * WM_SHOWWINDOW messages with SW_PARENTCLOSING,
-                 * regardless of the state of the owner
-                 */
-                send_message( win_array[count], WM_SHOWWINDOW, SW_HIDE, SW_PARENTCLOSING );
-        }
-    }
-
-    free( win_array );
-    return TRUE;
-}
-
 /*******************************************************************
  *           NtUserFlashWindowEx (win32u.@)
  */
@@ -4549,7 +3957,7 @@ static void send_destroy_message( HWND hwnd )
     info.cbSize = sizeof(info);
     if (NtUserGetGUIThreadInfo( GetCurrentThreadId(), &info ))
     {
-        if (hwnd == info.hwndCaret) destroy_caret();
+        if (hwnd == info.hwndCaret && user_callbacks) user_callbacks->pDestroyCaret();
         if (hwnd == info.hwndActive) activate_other_window( hwnd );
     }
 
@@ -4600,8 +4008,6 @@ static void free_window_handle( HWND hwnd )
         SERVER_END_REQ;
         user_unlock();
         if (user_callbacks) user_callbacks->free_win_ptr( win );
-        free( win->text );
-        free( win );
     }
 }
 
@@ -4634,7 +4040,7 @@ LRESULT destroy_window( HWND hwnd )
                 destroy_window( children[i] );
             else
                 NtUserMessageCall( children[i], WM_WINE_DESTROYWINDOW, 0, 0,
-                                   0, NtUserSendNotifyMessage, FALSE );
+                                   0, FNID_SENDNOTIFYMESSAGE, FALSE );
         }
         free( children );
     }
@@ -4804,499 +4210,7 @@ void destroy_thread_windows(void)
             window_surface_release( win->surface );
         }
         if (user_callbacks) user_callbacks->free_win_ptr( win );
-        free( win->text );
-        free( win );
-    }
-}
-
-/***********************************************************************
- *           create_window_handle
- *
- * Create a window handle with the server.
- */
-static WND *create_window_handle( HWND parent, HWND owner, UNICODE_STRING *name,
-                                  HINSTANCE instance, BOOL ansi,
-                                  DWORD style, DWORD ex_style )
-{
-    DPI_AWARENESS awareness = get_thread_dpi_awareness();
-    HWND handle = 0, full_parent = 0, full_owner = 0;
-    struct tagCLASS *class = NULL;
-    int extra_bytes = 0;
-    UINT dpi = 0;
-    WND *win;
-
-    SERVER_START_REQ( create_window )
-    {
-        req->parent    = wine_server_user_handle( parent );
-        req->owner     = wine_server_user_handle( owner );
-        req->instance  = wine_server_client_ptr( instance );
-        req->dpi       = get_system_dpi();
-        req->awareness = awareness;
-        req->style     = style;
-        req->ex_style  = ex_style;
-        if (!(req->atom = get_int_atom_value( name )) && name->Length)
-            wine_server_add_data( req, name->Buffer, name->Length );
-        if (!wine_server_call_err( req ))
-        {
-            handle      = wine_server_ptr_handle( reply->handle );
-            full_parent = wine_server_ptr_handle( reply->parent );
-            full_owner  = wine_server_ptr_handle( reply->owner );
-            extra_bytes = reply->extra;
-            dpi         = reply->dpi;
-            awareness   = reply->awareness;
-            class       = wine_server_get_ptr( reply->class_ptr );
-        }
-    }
-    SERVER_END_REQ;
-
-    if (!handle)
-    {
-        WARN( "error %d creating window\n", GetLastError() );
-        return NULL;
-    }
-
-    if (!(win = calloc( 1, FIELD_OFFSET(WND, wExtra) + extra_bytes )))
-    {
-        SERVER_START_REQ( destroy_window )
-        {
-            req->handle = wine_server_user_handle( handle );
-            wine_server_call( req );
-        }
-        SERVER_END_REQ;
-        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
-        return NULL;
-    }
-
-    if (!parent)  /* if parent is 0 we don't have a desktop window yet */
-    {
-        struct ntuser_thread_info *thread_info = NtUserGetThreadInfo();
-
-        if (name->Buffer == (const WCHAR *)DESKTOP_CLASS_ATOM)
-        {
-            if (!thread_info->top_window) thread_info->top_window = full_parent ? full_parent : handle;
-            else assert( full_parent == thread_info->top_window );
-            if (full_parent && !user_driver->pCreateDesktopWindow( thread_info->top_window ))
-                ERR( "failed to create desktop window\n" );
-            register_builtin_classes();
-        }
-        else  /* HWND_MESSAGE parent */
-        {
-            if (!thread_info->msg_window && !full_parent) thread_info->msg_window = handle;
-        }
-    }
-
-    user_lock();
-
-    win->obj.handle = handle;
-    win->obj.type   = NTUSER_OBJ_WINDOW;
-    win->parent     = full_parent;
-    win->owner      = full_owner;
-    win->class      = class;
-    win->winproc    = get_class_winproc( class );
-    win->cbWndExtra = extra_bytes;
-    win->dpi        = dpi;
-    win->dpi_awareness = awareness;
-    set_user_handle_ptr( handle, &win->obj );
-    if (is_winproc_unicode( win->winproc, !ansi )) win->flags |= WIN_ISUNICODE;
-    return win;
-}
-
-static BOOL is_default_coord( int x )
-{
-    return x == CW_USEDEFAULT || x == 0x8000;
-}
-
-/***********************************************************************
- *           fix_cs_coordinates
- *
- * Fix the coordinates and return default show mode in sw.
- */
-static void fix_cs_coordinates( CREATESTRUCTW *cs, INT *sw )
-{
-    if (cs->style & (WS_CHILD | WS_POPUP))
-    {
-        if (is_default_coord(cs->x)) cs->x = cs->y = 0;
-        if (is_default_coord(cs->cx)) cs->cx = cs->cy = 0;
-    }
-    else  /* overlapped window */
-    {
-        RTL_USER_PROCESS_PARAMETERS *params = NtCurrentTeb()->Peb->ProcessParameters;
-        HMONITOR monitor;
-        MONITORINFO mon_info;
-
-        if (!is_default_coord( cs->x ) && !is_default_coord( cs->cx ) && !is_default_coord( cs->cy ))
-            return;
-
-        monitor = monitor_from_window( cs->hwndParent, MONITOR_DEFAULTTOPRIMARY, get_thread_dpi() );
-        mon_info.cbSize = sizeof(mon_info);
-        get_monitor_info( monitor, &mon_info );
-
-        if (is_default_coord( cs->x ))
-        {
-            if (!is_default_coord( cs->y )) *sw = cs->y;
-            cs->x = (params->dwFlags & STARTF_USEPOSITION) ? params->dwX : mon_info.rcWork.left;
-            cs->y = (params->dwFlags & STARTF_USEPOSITION) ? params->dwY : mon_info.rcWork.top;
-        }
-
-        if (is_default_coord( cs->cx ))
-        {
-            if (params->dwFlags & STARTF_USESIZE)
-            {
-                cs->cx = params->dwXSize;
-                cs->cy = params->dwYSize;
-            }
-            else
-            {
-                cs->cx = (mon_info.rcWork.right - mon_info.rcWork.left) * 3 / 4 - cs->x;
-                cs->cy = (mon_info.rcWork.bottom - mon_info.rcWork.top) * 3 / 4 - cs->y;
-            }
-        }
-        /* neither x nor cx are default. Check the y values.
-         * In the trace we see Outlook and Outlook Express using
-         * cy set to CW_USEDEFAULT when opening the address book.
-         */
-        else if (is_default_coord( cs->cy ))
-        {
-            FIXME( "Strange use of CW_USEDEFAULT in cy\n" );
-            cs->cy = (mon_info.rcWork.bottom - mon_info.rcWork.top) * 3 / 4 - cs->y;
-        }
-    }
-}
-
-/***********************************************************************
- *           map_dpi_create_struct
- */
-static void map_dpi_create_struct( CREATESTRUCTW *cs, UINT dpi_from, UINT dpi_to )
-{
-    if (!dpi_from && !dpi_to) return;
-    if (!dpi_from || !dpi_to)
-    {
-        POINT pt = { cs->x, cs->y };
-        UINT mon_dpi = get_monitor_dpi( monitor_from_point( pt, MONITOR_DEFAULTTONEAREST, dpi_from ));
-        if (!dpi_from) dpi_from = mon_dpi;
-        else dpi_to = mon_dpi;
     }
-    if (dpi_from == dpi_to) return;
-    cs->x = muldiv( cs->x, dpi_to, dpi_from );
-    cs->y = muldiv( cs->y, dpi_to, dpi_from );
-    cs->cx = muldiv( cs->cx, dpi_to, dpi_from );
-    cs->cy = muldiv( cs->cy, dpi_to, dpi_from );
-}
-
-/***********************************************************************
- *           NtUserCreateWindowEx (win32u.@)
- */
-HWND WINAPI NtUserCreateWindowEx( DWORD ex_style, UNICODE_STRING *class_name,
-                                  UNICODE_STRING *version, UNICODE_STRING *window_name,
-                                  DWORD style, INT x, INT y, INT cx, INT cy,
-                                  HWND parent, HMENU menu, HINSTANCE instance, void *params,
-                                  DWORD flags, CBT_CREATEWNDW *cbtc, DWORD unk, BOOL ansi )
-{
-    CREATESTRUCTW cs, *client_cs, cs_buf;
-    UINT win_dpi, thread_dpi = get_thread_dpi();
-    DPI_AWARENESS_CONTEXT context;
-    CBT_CREATEWNDW cbtc_buf;
-    HWND hwnd, owner = 0;
-    INT sw = SW_SHOW;
-    RECT rect;
-    WND *win;
-
-    static const WCHAR messageW[] = {'M','e','s','s','a','g','e'};
-
-    /* FIXME: We should pass a packed struct to client instead of using client_cs */
-    if (cbtc)
-    {
-        client_cs = cbtc->lpcs;
-        cs.lpszName  = client_cs->lpszName;
-        cs.lpszClass = client_cs->lpszClass;
-        cs.hInstance = client_cs->hInstance; /* may be different than instance for win16 */
-    }
-    else
-    {
-        cbtc = &cbtc_buf;
-        client_cs = cbtc->lpcs = &cs_buf;
-        cs.lpszName = window_name ? window_name->Buffer : NULL;
-        cs.lpszClass = class_name->Buffer;
-        cs.hInstance = instance;
-    }
-
-    cs.lpCreateParams = params;
-    cs.hMenu      = menu;
-    cs.hwndParent = parent;
-    cs.style      = style;
-    cs.dwExStyle  = ex_style;
-    cs.x  = x;
-    cs.y  = y;
-    cs.cx = cx;
-    cs.cy = cy;
-
-    /* Find the parent window */
-    if (parent == HWND_MESSAGE)
-    {
-        cs.hwndParent = parent = get_hwnd_message_parent();
-    }
-    else if (parent)
-    {
-        if ((cs.style & (WS_CHILD|WS_POPUP)) != WS_CHILD)
-        {
-            owner = parent;
-            parent = get_desktop_window();
-        }
-        else
-        {
-            DWORD parent_style = get_window_long( parent, GWL_EXSTYLE );
-            if ((parent_style & WS_EX_LAYOUTRTL) && !(parent_style & WS_EX_NOINHERITLAYOUT))
-                cs.dwExStyle |= WS_EX_LAYOUTRTL;
-        }
-    }
-    else
-    {
-        if ((cs.style & (WS_CHILD|WS_POPUP)) == WS_CHILD)
-        {
-            WARN( "No parent for child window\n" );
-            SetLastError( ERROR_TLW_WITH_WSCHILD );
-            return 0;  /* WS_CHILD needs a parent, but WS_POPUP doesn't */
-        }
-
-        /* are we creating the desktop or HWND_MESSAGE parent itself? */
-        if (class_name->Buffer != (LPCWSTR)DESKTOP_CLASS_ATOM &&
-            (class_name->Length != sizeof(messageW) ||
-             wcsnicmp( class_name->Buffer, messageW, ARRAYSIZE(messageW) )))
-        {
-            parent = get_desktop_window();
-        }
-    }
-
-    fix_cs_coordinates( &cs, &sw );
-    cs.dwExStyle = fix_exstyle( cs.style, cs.dwExStyle );
-
-    /* Create the window structure */
-
-    style = cs.style & ~WS_VISIBLE;
-    ex_style = cs.dwExStyle & ~WS_EX_LAYERED;
-    if (!(win = create_window_handle( parent, owner, class_name, instance, ansi, style, ex_style )))
-        return 0;
-    hwnd = win->obj.handle;
-
-    /* Fill the window structure */
-
-    win->tid         = GetCurrentThreadId();
-    win->hInstance   = cs.hInstance;
-    win->text        = NULL;
-    win->dwStyle     = style;
-    win->dwExStyle   = ex_style;
-    win->wIDmenu     = 0;
-    win->helpContext = 0;
-    win->pScroll     = NULL;
-    win->userdata    = 0;
-    win->hIcon       = 0;
-    win->hIconSmall  = 0;
-    win->hIconSmall2 = 0;
-    win->hSysMenu    = 0;
-
-    win->min_pos.x = win->min_pos.y = -1;
-    win->max_pos.x = win->max_pos.y = -1;
-    SetRect( &win->normal_rect, cs.x, cs.y, cs.x + cs.cx, cs.y + cs.cy );
-
-    if (win->dwStyle & WS_SYSMENU) NtUserSetSystemMenu( hwnd, 0 );
-
-    /* call the WH_CBT hook */
-
-    release_win_ptr( win );
-    *client_cs = cs;
-    cbtc->hwndInsertAfter = HWND_TOP;
-    if (call_hooks( WH_CBT, HCBT_CREATEWND, (WPARAM)hwnd, (LPARAM)cbtc, !ansi ))
-    {
-        free_window_handle( hwnd );
-        return 0;
-    }
-    if (!(win = get_win_ptr( hwnd ))) return 0;
-
-    /*
-     * Correct the window styles.
-     *
-     * It affects only the style loaded into the WND structure.
-     */
-
-    if ((win->dwStyle & (WS_CHILD | WS_POPUP)) != WS_CHILD)
-    {
-        win->dwStyle |= WS_CLIPSIBLINGS;
-        if (!(win->dwStyle & WS_POPUP)) win->dwStyle |= WS_CAPTION;
-    }
-
-    win->dwExStyle = cs.dwExStyle;
-    /* WS_EX_WINDOWEDGE depends on some other styles */
-    if ((win->dwStyle & (WS_DLGFRAME | WS_THICKFRAME)) &&
-            !(win->dwStyle & (WS_CHILD | WS_POPUP)))
-        win->dwExStyle |= WS_EX_WINDOWEDGE;
-
-    if (!(win->dwStyle & (WS_CHILD | WS_POPUP))) win->flags |= WIN_NEED_SIZE;
-
-    SERVER_START_REQ( set_window_info )
-    {
-        req->handle     = wine_server_user_handle( hwnd );
-        req->flags      = SET_WIN_STYLE | SET_WIN_EXSTYLE | SET_WIN_INSTANCE | SET_WIN_UNICODE;
-        req->style      = win->dwStyle;
-        req->ex_style   = win->dwExStyle;
-        req->instance   = wine_server_client_ptr( win->hInstance );
-        req->is_unicode = (win->flags & WIN_ISUNICODE) != 0;
-        req->extra_offset = -1;
-        wine_server_call( req );
-    }
-    SERVER_END_REQ;
-
-    /* Set the window menu */
-
-    if ((win->dwStyle & (WS_CHILD | WS_POPUP)) != WS_CHILD)
-    {
-        if (cs.hMenu && !set_window_menu( hwnd, cs.hMenu ))
-        {
-            release_win_ptr( win );
-            free_window_handle( hwnd );
-            return 0;
-        }
-    }
-    else NtUserSetWindowLongPtr( hwnd, GWLP_ID, (ULONG_PTR)cs.hMenu, FALSE );
-
-    win_dpi = win->dpi;
-    release_win_ptr( win );
-
-    if (parent) map_dpi_create_struct( &cs, thread_dpi, win_dpi );
-
-    context = set_thread_dpi_awareness_context( get_window_dpi_awareness_context( hwnd ));
-
-    /* send the WM_GETMINMAXINFO message and fix the size if needed */
-
-    cx = cs.cx;
-    cy = cs.cy;
-    if ((cs.style & WS_THICKFRAME) || !(cs.style & (WS_POPUP | WS_CHILD)))
-    {
-        MINMAXINFO info = get_min_max_info( hwnd );
-        cx = max( min( cx, info.ptMaxTrackSize.x ), info.ptMinTrackSize.x );
-        cy = max( min( cy, info.ptMaxTrackSize.y ), info.ptMinTrackSize.y );
-    }
-
-    if (cx < 0) cx = 0;
-    if (cy < 0) cy = 0;
-    SetRect( &rect, cs.x, cs.y, cs.x + cx, cs.y + cy );
-    /* check for wraparound */
-    if (cs.x > 0x7fffffff - cx) rect.right = 0x7fffffff;
-    if (cs.y > 0x7fffffff - cy) rect.bottom = 0x7fffffff;
-    if (!apply_window_pos( hwnd, 0, SWP_NOZORDER | SWP_NOACTIVATE, &rect, &rect, NULL )) goto failed;
-
-    /* send WM_NCCREATE */
-
-    TRACE( "hwnd %p cs %d,%d %dx%d %s\n", hwnd, cs.x, cs.y, cs.cx, cs.cy, wine_dbgstr_rect(&rect) );
-    *client_cs = cs;
-    if (!NtUserMessageCall( hwnd, WM_NCCREATE, 0, (LPARAM)client_cs, NULL, NtUserSendMessage, ansi ))
-    {
-        WARN( "%p: aborted by WM_NCCREATE\n", hwnd );
-        goto failed;
-    }
-
-    /* create default IME window */
-
-    if (!is_desktop_window( hwnd ) && parent != get_hwnd_message_parent() &&
-        user_callbacks && user_callbacks->register_imm( hwnd ))
-    {
-        TRACE( "register IME window for %p\n", hwnd );
-        win_set_flags( hwnd, WIN_HAS_IME_WIN, 0 );
-    }
-
-    /* send WM_NCCALCSIZE */
-
-    if (get_window_rects( hwnd, COORDS_PARENT, &rect, NULL, win_dpi ))
-    {
-        /* yes, even if the CBT hook was called with HWND_TOP */
-        HWND insert_after = (get_window_long( hwnd, GWL_STYLE ) & WS_CHILD) ? HWND_BOTTOM : HWND_TOP;
-        RECT client_rect = rect;
-
-        /* the rectangle is in screen coords for WM_NCCALCSIZE when wparam is FALSE */
-        map_window_points( parent, 0, (POINT *)&client_rect, 2, win_dpi );
-        send_message( hwnd, WM_NCCALCSIZE, FALSE, (LPARAM)&client_rect );
-        map_window_points( 0, parent, (POINT *)&client_rect, 2, win_dpi );
-        apply_window_pos( hwnd, insert_after, SWP_NOACTIVATE, &rect, &client_rect, NULL );
-    }
-    else goto failed;
-
-    /* send WM_CREATE */
-    if (NtUserMessageCall( hwnd, WM_CREATE, 0, (LPARAM)client_cs, 0, NtUserSendMessage, ansi ) == -1)
-        goto failed;
-    cs = *client_cs;
-
-    /* call the driver */
-
-    if (!user_driver->pCreateWindow( hwnd )) goto failed;
-
-    NtUserNotifyWinEvent( EVENT_OBJECT_CREATE, hwnd, OBJID_WINDOW, 0 );
-
-    /* send the size messages */
-
-    if (!(win_get_flags( hwnd ) & WIN_NEED_SIZE))
-    {
-        get_window_rects( hwnd, COORDS_PARENT, NULL, &rect, win_dpi );
-        send_message( hwnd, WM_SIZE, SIZE_RESTORED,
-                      MAKELONG(rect.right-rect.left, rect.bottom-rect.top));
-        send_message( hwnd, WM_MOVE, 0, MAKELONG( rect.left, rect.top ) );
-    }
-
-    /* Show the window, maximizing or minimizing if needed */
-
-    style = set_window_style( hwnd, 0, WS_MAXIMIZE | WS_MINIMIZE );
-    if (style & (WS_MINIMIZE | WS_MAXIMIZE))
-    {
-        RECT new_pos;
-        UINT sw_flags = (style & WS_MINIMIZE) ? SW_MINIMIZE : SW_MAXIMIZE;
-
-        sw_flags = window_min_maximize( hwnd, sw_flags, &new_pos );
-        sw_flags |= SWP_FRAMECHANGED; /* Frame always gets changed */
-        if (!(style & WS_VISIBLE) || (style & WS_CHILD) || get_active_window())
-            sw_flags |= SWP_NOACTIVATE;
-        NtUserSetWindowPos( hwnd, 0, new_pos.left, new_pos.top, new_pos.right - new_pos.left,
-                            new_pos.bottom - new_pos.top, sw_flags );
-    }
-
-    /* Notify the parent window only */
-
-    send_parent_notify( hwnd, WM_CREATE );
-    if (!is_window( hwnd ))
-    {
-        set_thread_dpi_awareness_context( context );
-        return 0;
-    }
-
-    if (parent == get_desktop_window())
-        NtUserPostMessage( parent, WM_PARENTNOTIFY, WM_CREATE, (LPARAM)hwnd );
-
-    if (cs.style & WS_VISIBLE)
-    {
-        if (cs.style & WS_MAXIMIZE)
-            sw = SW_SHOW;
-        else if (cs.style & WS_MINIMIZE)
-            sw = SW_SHOWMINIMIZED;
-
-        NtUserShowWindow( hwnd, sw );
-        if (cs.dwExStyle & WS_EX_MDICHILD)
-        {
-            send_message( cs.hwndParent, WM_MDIREFRESHMENU, 0, 0 );
-            /* ShowWindow won't activate child windows */
-            NtUserSetWindowPos( hwnd, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE );
-        }
-    }
-
-    /* Call WH_SHELL hook */
-
-    if (!(get_window_long( hwnd, GWL_STYLE ) & WS_CHILD) && !get_window_relative( hwnd, GW_OWNER ))
-        call_hooks( WH_SHELL, HSHELL_WINDOWCREATED, (WPARAM)hwnd, 0, TRUE );
-
-    TRACE( "created window %p\n", hwnd );
-    set_thread_dpi_awareness_context( context );
-    return hwnd;
-
-failed:
-    destroy_window( hwnd );
-    set_thread_dpi_awareness_context( context );
-    return 0;
 }
 
 /*****************************************************************************
@@ -5306,39 +4220,29 @@ ULONG_PTR WINAPI NtUserCallHwnd( HWND hwnd, DWORD code )
 {
     switch (code)
     {
-    case NtUserCallHwnd_ArrangeIconicWindows:
-        return arrange_iconic_windows( hwnd );
-
-    case NtUserCallHwnd_DrawMenuBar:
-        return draw_menu_bar( hwnd );
-
-    case NtUserCallHwnd_GetDpiForWindow:
+    case NtUserGetDpiForWindow:
         return get_dpi_for_window( hwnd );
-
-    case NtUserCallHwnd_GetParent:
+    case NtUserGetParent:
         return HandleToUlong( get_parent( hwnd ));
-
-    case NtUserCallHwnd_GetWindowContextHelpId:
+    case NtUserGetWindowContextHelpId:
         return get_window_context_help_id( hwnd );
-
-    case NtUserCallHwnd_GetWindowDpiAwarenessContext:
+    case NtUserGetWindowDpiAwarenessContext:
         return (ULONG_PTR)get_window_dpi_awareness_context( hwnd );
-
-    case NtUserCallHwnd_GetWindowTextLength:
+    case NtUserGetWindowTextLength:
         return get_server_window_text( hwnd, NULL, 0 );
-
-    case NtUserCallHwnd_IsWindow:
+    case NtUserIsWindow:
         return is_window( hwnd );
-
-    case NtUserCallHwnd_IsWindowEnabled:
-        return is_window_enabled( hwnd );
-
-    case NtUserCallHwnd_IsWindowUnicode:
+    case NtUserIsWindowUnicode:
         return is_window_unicode( hwnd );
-
-    case NtUserCallHwnd_IsWindowVisible:
+    case NtUserIsWindowVisible:
         return is_window_visible( hwnd );
-
+    /* temporary exports */
+    case NtUserCreateDesktopWindow:
+        return user_driver->pCreateDesktopWindow( hwnd );
+    case NtUserDestroyWindowHandle:
+        return destroy_window( hwnd );
+    case NtUserGetDummySurface:
+        return (UINT_PTR)&dummy_surface;
     default:
         FIXME( "invalid code %u\n", code );
         return 0;
@@ -5352,108 +4256,63 @@ ULONG_PTR WINAPI NtUserCallHwndParam( HWND hwnd, DWORD_PTR param, DWORD code )
 {
     switch (code)
     {
-    case NtUserCallHwndParam_ClientToScreen:
-        return client_to_screen( hwnd, (POINT *)param );
-
-    case NtUserCallHwndParam_EnableWindow:
-        return enable_window( hwnd, param );
-
-    case NtUserCallHwndParam_GetClassLongA:
+    case NtUserGetClassLongA:
         return get_class_long( hwnd, param, TRUE );
-
-    case NtUserCallHwndParam_GetClassLongW:
+    case NtUserGetClassLongW:
         return get_class_long( hwnd, param, FALSE );
-
-    case NtUserCallHwndParam_GetClassLongPtrA:
+    case NtUserGetClassLongPtrA:
         return get_class_long_ptr( hwnd, param, TRUE );
-
-    case NtUserCallHwndParam_GetClassLongPtrW:
+    case NtUserGetClassLongPtrW:
         return get_class_long_ptr( hwnd, param, FALSE );
-
-    case NtUserCallHwndParam_GetClassWord:
+    case NtUserGetClassWord:
         return get_class_word( hwnd, param );
-
-    case NtUserCallHwndParam_GetClientRect:
+    case NtUserGetClientRect:
         return get_client_rect( hwnd, (RECT *)param );
-
-    case NtUserCallHwndParam_GetMinMaxInfo:
+    case NtUserGetMinMaxInfo:
         *(MINMAXINFO *)param = get_min_max_info( hwnd );
         return 0;
-
-    case NtUserCallHwndParam_GetWindowInfo:
+    case NtUserGetWindowInfo:
         return get_window_info( hwnd, (WINDOWINFO *)param );
-
-    case NtUserCallHwndParam_GetWindowLongA:
+    case NtUserGetWindowLongA:
         return get_window_long_size( hwnd, param, sizeof(LONG), TRUE );
-
-    case NtUserCallHwndParam_GetWindowLongW:
+    case NtUserGetWindowLongW:
         return get_window_long( hwnd, param );
-
-    case NtUserCallHwndParam_GetWindowLongPtrA:
+    case NtUserGetWindowLongPtrA:
         return get_window_long_ptr( hwnd, param, TRUE );
-
-    case NtUserCallHwndParam_GetWindowLongPtrW:
+    case NtUserGetWindowLongPtrW:
         return get_window_long_ptr( hwnd, param, FALSE );
-
-    case NtUserCallHwndParam_GetWindowRect:
+    case NtUserGetWindowPlacement:
+        return get_window_placement( hwnd, (WINDOWPLACEMENT *)param );
+    case NtUserGetWindowRect:
         return get_window_rect( hwnd, (RECT *)param, get_thread_dpi() );
-
-    case NtUserCallHwndParam_GetWindowRelative:
+    case NtUserGetWindowRelative:
         return HandleToUlong( get_window_relative( hwnd, param ));
-
-    case NtUserCallHwndParam_GetWindowThread:
+    case NtUserGetWindowThread:
         return get_window_thread( hwnd, (DWORD *)param );
-
-    case NtUserCallHwndParam_GetWindowWord:
+    case NtUserGetWindowWord:
         return get_window_word( hwnd, param );
-
-    case NtUserCallHwndParam_IsChild:
+    case NtUserIsChild:
         return is_child( hwnd, UlongToHandle(param) );
-
-    case NtUserCallHwndParam_KillSystemTimer:
+    case NtUserKillSystemTimer:
         return kill_system_timer( hwnd, param );
-
-    case NtUserCallHwndParam_MapWindowPoints:
-        {
-            struct map_window_points_params *params = (void *)param;
-            return map_window_points( hwnd, params->hwnd_to, params->points, params->count,
-                                      get_thread_dpi() );
-        }
-
-    case NtUserCallHwndParam_MirrorRgn:
-        return mirror_window_region( hwnd, UlongToHandle(param) );
-
-    case NtUserCallHwndParam_MonitorFromWindow:
-        return HandleToUlong( monitor_from_window( hwnd, param, get_thread_dpi() ));
-
-    case NtUserCallHwndParam_ScreenToClient:
+    case NtUserMonitorFromWindow:
+        return HandleToUlong( monitor_from_window( hwnd, param, NtUserMonitorFromWindow ));
+    case NtUserScreenToClient:
         return screen_to_client( hwnd, (POINT *)param );
-
-    case NtUserCallHwndParam_SetForegroundWindow:
+    case NtUserSetCaptureWindow:
+        return set_capture_window( hwnd, param, NULL );
+    case NtUserSetForegroundWindow:
         return set_foreground_window( hwnd, param );
-
-    case NtUserCallHwndParam_SetWindowPixelFormat:
+    case NtUserSetWindowPixelFormat:
         return set_window_pixel_format( hwnd, param );
-
-    case NtUserCallHwndParam_ShowOwnedPopups:
-        return show_owned_popups( hwnd, param );
-
     /* temporary exports */
     case NtUserIsWindowDrawable:
         return is_window_drawable( hwnd, param );
-
-    case NtUserSetCaptureWindow:
-        return set_capture_window( hwnd, param, NULL );
-
     case NtUserSetWindowStyle:
         {
             STYLESTRUCT *style = (void *)param;
             return set_window_style( hwnd, style->styleNew, style->styleOld );
         }
-
-    case NtUserSpyGetMsgName:
-        return (UINT_PTR)debugstr_msg_name( param, hwnd );
-
     default:
         FIXME( "invalid code %u\n", code );
         return 0;
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 0f6fb66a2b2..a25edfc9771 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -239,8 +239,8 @@ BOOL WINAPI NtUserSetThreadDesktop( HDESK handle )
     {
         struct user_thread_info *thread_info = get_user_thread_info();
         struct user_key_state_info *key_state_info = thread_info->key_state;
-        thread_info->client_info.top_window = 0;
-        thread_info->client_info.msg_window = 0;
+        thread_info->top_window = 0;
+        thread_info->msg_window = 0;
         if (key_state_info) key_state_info->time = 0;
     }
     return ret;
@@ -397,7 +397,7 @@ static inline TEB64 *NtCurrentTeb64(void) { return (TEB64 *)NtCurrentTeb()->GdiB
 
 HWND get_desktop_window(void)
 {
-    struct ntuser_thread_info *thread_info = NtUserGetThreadInfo();
+    struct user_thread_info *thread_info = get_user_thread_info();
 
     if (thread_info->top_window) return thread_info->top_window;
 
@@ -450,11 +450,11 @@ HWND get_desktop_window(void)
         params.Environment     = peb->ProcessParameters->Environment;
         params.EnvironmentSize = peb->ProcessParameters->EnvironmentSize;
         params.hStdError       = peb->ProcessParameters->hStdError;
-        RtlInitUnicodeString( &params.CurrentDirectory.DosPath, system_dir );
-        RtlInitUnicodeString( &params.ImagePathName, appnameW + 4 );
-        RtlInitUnicodeString( &params.CommandLine, cmdlineW );
-        RtlInitUnicodeString( &params.WindowTitle, appnameW + 4 );
-        RtlInitUnicodeString( &params.Desktop, desktop );
+        init_unicode_string( &params.CurrentDirectory.DosPath, system_dir );
+        init_unicode_string( &params.ImagePathName, appnameW + 4 );
+        init_unicode_string( &params.CommandLine, cmdlineW );
+        init_unicode_string( &params.WindowTitle, appnameW + 4 );
+        init_unicode_string( &params.Desktop, desktop );
 
         ps_attr.TotalLength = sizeof(ps_attr);
         ps_attr.Attributes[0].Attribute    = PS_ATTRIBUTE_IMAGE_NAME;
@@ -499,7 +499,7 @@ HWND get_desktop_window(void)
     if (!thread_info->top_window || !user_driver->pCreateDesktopWindow( thread_info->top_window ))
         ERR_(win)( "failed to create desktop window\n" );
 
-    register_builtin_classes();
+    if (user_callbacks) user_callbacks->register_builtin_classes();
     return thread_info->top_window;
 }
 
diff --git a/dlls/win32u/wrappers.c b/dlls/win32u/wrappers.c
index 13b4b7164ab..6cb3a6896b5 100644
--- a/dlls/win32u/wrappers.c
+++ b/dlls/win32u/wrappers.c
@@ -671,12 +671,6 @@ NTSTATUS WINAPI NtGdiDdDDICheckVidPnExclusiveOwnership( const D3DKMT_CHECKVIDPNE
     return unix_funcs->pNtGdiDdDDICheckVidPnExclusiveOwnership( desc );
 }
 
-NTSTATUS WINAPI NtGdiDdDDICloseAdapter( const D3DKMT_CLOSEADAPTER *desc )
-{
-    if (!unix_funcs) return STATUS_NOT_SUPPORTED;
-    return unix_funcs->pNtGdiDdDDICloseAdapter( desc );
-}
-
 NTSTATUS WINAPI NtGdiDdDDICreateDCFromMemory( D3DKMT_CREATEDCFROMMEMORY *desc )
 {
     if (!unix_funcs) return STATUS_NOT_SUPPORTED;
@@ -701,24 +695,6 @@ NTSTATUS WINAPI NtGdiDdDDIEscape( const D3DKMT_ESCAPE *desc )
     return unix_funcs->pNtGdiDdDDIEscape( desc );
 }
 
-NTSTATUS WINAPI NtGdiDdDDIOpenAdapterFromDeviceName( D3DKMT_OPENADAPTERFROMDEVICENAME *desc )
-{
-    if (!unix_funcs) return STATUS_NOT_SUPPORTED;
-    return unix_funcs->pNtGdiDdDDIOpenAdapterFromDeviceName( desc );
-}
-
-NTSTATUS WINAPI NtGdiDdDDIOpenAdapterFromLuid( D3DKMT_OPENADAPTERFROMLUID *desc )
-{
-    if (!unix_funcs) return STATUS_NOT_SUPPORTED;
-    return unix_funcs->pNtGdiDdDDIOpenAdapterFromLuid( desc );
-}
-
-NTSTATUS WINAPI NtGdiDdDDIQueryVideoMemoryInfo( D3DKMT_QUERYVIDEOMEMORYINFO *desc )
-{
-    if (!unix_funcs) return STATUS_NOT_SUPPORTED;
-    return unix_funcs->pNtGdiDdDDIQueryVideoMemoryInfo( desc );
-}
-
 NTSTATUS WINAPI NtGdiDdDDISetVidPnSourceOwner( const D3DKMT_SETVIDPNSOURCEOWNER *desc )
 {
     if (!unix_funcs) return STATUS_NOT_SUPPORTED;
@@ -773,18 +749,6 @@ ULONG_PTR WINAPI NtUserCallHwndParam( HWND hwnd, DWORD_PTR param, DWORD code )
     return unix_funcs->pNtUserCallHwndParam( hwnd, param, code );
 }
 
-BOOL WINAPI NtUserCloseClipboard(void)
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserCloseClipboard();
-}
-
-BOOL WINAPI NtUserChangeClipboardChain( HWND hwnd, HWND next )
-{
-    if (!unix_funcs) return DISP_CHANGE_FAILED;
-    return unix_funcs->pNtUserChangeClipboardChain( hwnd, next );
-}
-
 LONG WINAPI NtUserChangeDisplaySettings( UNICODE_STRING *devname, DEVMODEW *devmode, HWND hwnd,
                                          DWORD flags, void *lparam )
 {
@@ -804,24 +768,6 @@ INT WINAPI NtUserCountClipboardFormats(void)
     return unix_funcs->pNtUserCountClipboardFormats();
 }
 
-BOOL WINAPI NtUserCreateCaret( HWND hwnd, HBITMAP bitmap, int width, int height )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserCreateCaret( hwnd, bitmap, width, height );
-}
-
-HWND WINAPI NtUserCreateWindowEx( DWORD ex_style, UNICODE_STRING *class_name,
-                                  UNICODE_STRING *version, UNICODE_STRING *window_name,
-                                  DWORD style, INT x, INT y, INT width, INT height,
-                                  HWND parent, HMENU menu, HINSTANCE instance, void *params,
-                                  DWORD flags, CBT_CREATEWNDW *cbtc, DWORD unk, BOOL ansi )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserCreateWindowEx( ex_style, class_name, version, window_name,
-                                              style, x, y, width, height, parent, menu,
-                                              instance, params, flags, cbtc, unk, ansi );
-}
-
 HDWP WINAPI NtUserDeferWindowPosAndBand( HDWP hdwp, HWND hwnd, HWND after,
                                          INT x, INT y, INT cx, INT cy,
                                          UINT flags, UINT unk1, UINT unk2 )
@@ -837,24 +783,12 @@ BOOL WINAPI NtUserDestroyCursor( HCURSOR cursor, ULONG arg )
     return unix_funcs->pNtUserDestroyCursor( cursor, arg );
 }
 
-BOOL WINAPI NtUserDestroyMenu( HMENU handle )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserDestroyMenu( handle );
-}
-
 BOOL WINAPI NtUserDestroyWindow( HWND hwnd )
 {
     if (!unix_funcs) return FALSE;
     return unix_funcs->pNtUserDestroyWindow( hwnd );
 }
 
-LRESULT WINAPI NtUserDispatchMessage( const MSG *msg )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserDispatchMessage( msg );
-}
-
 BOOL WINAPI NtUserDrawIconEx( HDC hdc, INT x0, INT y0, HICON icon, INT width,
                               INT height, UINT istep, HBRUSH hbr, UINT flags )
 {
@@ -862,24 +796,12 @@ BOOL WINAPI NtUserDrawIconEx( HDC hdc, INT x0, INT y0, HICON icon, INT width,
     return unix_funcs->pNtUserDrawIconEx( hdc, x0, y0, icon, width, height, istep, hbr, flags );
 }
 
-BOOL WINAPI NtUserEnableMenuItem( HMENU handle, UINT id, UINT flags )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserEnableMenuItem( handle, id, flags );
-}
-
 BOOL WINAPI NtUserEndDeferWindowPosEx( HDWP hdwp, BOOL async )
 {
     if (!unix_funcs) return FALSE;
     return unix_funcs->pNtUserEndDeferWindowPosEx( hdwp, async );
 }
 
-BOOL WINAPI NtUserEmptyClipboard(void)
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserEmptyClipboard();
-}
-
 NTSTATUS WINAPI NtUserEnumDisplayDevices( UNICODE_STRING *device, DWORD index,
                                           DISPLAY_DEVICEW *info, DWORD flags )
 {
@@ -900,12 +822,6 @@ BOOL WINAPI NtUserEnumDisplaySettings( UNICODE_STRING *device, DWORD mode,
     return unix_funcs->pNtUserEnumDisplaySettings( device, mode, dev_mode, flags );
 }
 
-INT WINAPI NtUserExcludeUpdateRgn( HDC hdc, HWND hwnd )
-{
-    if (!unix_funcs) return ERROR;
-    return unix_funcs->pNtUserExcludeUpdateRgn( hdc, hwnd );
-}
-
 BOOL WINAPI NtUserFlashWindowEx( FLASHWINFO *info )
 {
     if (!unix_funcs) return FALSE;
@@ -925,12 +841,6 @@ ATOM WINAPI NtUserGetClassInfoEx( HINSTANCE instance, UNICODE_STRING *name, WNDC
     return unix_funcs->pNtUserGetClassInfoEx( instance, name, wc, menu_name, ansi );
 }
 
-HANDLE WINAPI NtUserGetClipboardData( UINT format, struct get_clipboard_params *params )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserGetClipboardData( format, params );
-}
-
 BOOL WINAPI NtUserGetCursorInfo( CURSORINFO *info )
 {
     if (!unix_funcs) return FALSE;
@@ -969,18 +879,6 @@ INT WINAPI NtUserGetKeyNameText( LONG lparam, WCHAR *buffer, INT size )
     return unix_funcs->pNtUserGetKeyNameText( lparam, buffer, size );
 }
 
-BOOL WINAPI NtUserGetMessage( MSG *msg, HWND hwnd, UINT first, UINT last )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserGetMessage( msg, hwnd, first, last );
-}
-
-HMENU WINAPI NtUserGetSystemMenu( HWND hwnd, BOOL revert )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserGetSystemMenu( hwnd, revert );
-}
-
 BOOL WINAPI NtUserGetUpdateRect( HWND hwnd, RECT *rect, BOOL erase )
 {
     if (!unix_funcs) return FALSE;
@@ -993,12 +891,6 @@ INT WINAPI NtUserGetUpdateRgn( HWND hwnd, HRGN hrgn, BOOL erase )
     return unix_funcs->pNtUserGetUpdateRgn( hwnd, hrgn, erase );
 }
 
-BOOL WINAPI NtUserHideCaret( HWND hwnd )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserHideCaret( hwnd );
-}
-
 BOOL WINAPI NtUserMoveWindow( HWND hwnd, INT x, INT y, INT cx, INT cy, BOOL repaint )
 {
     if (!unix_funcs) return 0;
@@ -1023,12 +915,6 @@ BOOL WINAPI NtUserGetUpdatedClipboardFormats( UINT *formats, UINT size, UINT *ou
     return unix_funcs->pNtUserGetUpdatedClipboardFormats( formats, size, out_size );
 }
 
-BOOL WINAPI NtUserGetWindowPlacement( HWND hwnd, WINDOWPLACEMENT *placement )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserGetWindowPlacement( hwnd, placement );
-}
-
 BOOL WINAPI NtUserIsClipboardFormatAvailable( UINT format )
 {
     if (!unix_funcs) return FALSE;
@@ -1041,44 +927,6 @@ UINT WINAPI NtUserMapVirtualKeyEx( UINT code, UINT type, HKL layout )
     return unix_funcs->pNtUserMapVirtualKeyEx( code, type, layout );
 }
 
-LRESULT WINAPI NtUserMessageCall( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                  void *result_info, DWORD type, BOOL ansi )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserMessageCall( hwnd, msg, wparam, lparam, result_info, type, ansi );
-}
-
-DWORD WINAPI NtUserMsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                                DWORD timeout, DWORD mask, DWORD flags )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserMsgWaitForMultipleObjectsEx( count, handles, timeout, mask, flags );
-}
-
-BOOL WINAPI NtUserOpenClipboard( HWND hwnd, ULONG unk )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserOpenClipboard( hwnd, unk );
-}
-
-BOOL WINAPI NtUserPeekMessage( MSG *msg_out, HWND hwnd, UINT first, UINT last, UINT flags )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserPeekMessage( msg_out, hwnd, first, last, flags );
-}
-
-BOOL WINAPI NtUserPostMessage( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserPostMessage( hwnd, msg, wparam, lparam );
-}
-
-BOOL WINAPI NtUserPostThreadMessage( DWORD thread, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserPostThreadMessage( thread, msg, wparam, lparam );
-}
-
 BOOL WINAPI NtUserRedrawWindow( HWND hwnd, const RECT *rect, HRGN hrgn, UINT flags )
 {
     if (!unix_funcs) return FALSE;
@@ -1118,12 +966,6 @@ HPALETTE WINAPI NtUserSelectPalette( HDC hdc, HPALETTE hpal, WORD bkg )
     return unix_funcs->pNtUserSelectPalette( hdc, hpal, bkg );
 }
 
-UINT WINAPI NtUserSendInput( UINT count, INPUT *inputs, int size )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserSendInput( count, inputs, size );
-}
-
 HWND WINAPI NtUserSetActiveWindow( HWND hwnd )
 {
     if (!unix_funcs) return 0;
@@ -1136,12 +978,6 @@ HWND WINAPI NtUserSetCapture( HWND hwnd )
     return unix_funcs->pNtUserSetCapture( hwnd );
 }
 
-NTSTATUS WINAPI NtUserSetClipboardData( UINT format, HANDLE handle, struct set_clipboard_params *params )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserSetClipboardData( format, handle, params );
-}
-
 HCURSOR WINAPI NtUserSetCursor( HCURSOR cursor )
 {
     if (!unix_funcs) return 0;
@@ -1166,12 +1002,6 @@ WORD WINAPI NtUserSetClassWord( HWND hwnd, INT offset, WORD newval )
     return unix_funcs->pNtUserSetClassWord( hwnd, offset, newval );
 }
 
-HWND WINAPI NtUserSetClipboardViewer( HWND hwnd )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserSetClipboardViewer( hwnd );
-}
-
 BOOL WINAPI NtUserSetCursorIconData( HCURSOR cursor, UNICODE_STRING *module, UNICODE_STRING *res_name,
                                      struct cursoricon_desc *desc )
 {
@@ -1191,24 +1021,12 @@ HWND WINAPI NtUserSetFocus( HWND hwnd )
     return unix_funcs->pNtUserSetFocus( hwnd );
 }
 
-void WINAPI NtUserSetInternalWindowPos( HWND hwnd, UINT cmd, RECT *rect, POINT *pt )
-{
-    if (!unix_funcs) return;
-    return unix_funcs->pNtUserSetInternalWindowPos( hwnd, cmd, rect, pt );
-}
-
 BOOL WINAPI NtUserSetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags )
 {
     if (!unix_funcs) return FALSE;
     return unix_funcs->pNtUserSetLayeredWindowAttributes( hwnd, key, alpha, flags );
 }
 
-BOOL WINAPI NtUserSetMenu( HWND hwnd, HMENU menu )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserSetMenu( hwnd, menu );
-}
-
 HWND WINAPI NtUserSetParent( HWND hwnd, HWND parent )
 {
     if (!unix_funcs) return 0;
@@ -1221,12 +1039,6 @@ BOOL WINAPI NtUserSetSysColors( INT count, const INT *colors, const COLORREF *va
     return unix_funcs->pNtUserSetSysColors( count, colors, values );
 }
 
-BOOL WINAPI NtUserSetSystemMenu( HWND hwnd, HMENU menu )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserSetSystemMenu( hwnd, menu );
-}
-
 LONG WINAPI NtUserSetWindowLong( HWND hwnd, INT offset, LONG newval, BOOL ansi )
 {
     if (!unix_funcs) return 0;
@@ -1239,12 +1051,6 @@ LONG_PTR WINAPI NtUserSetWindowLongPtr( HWND hwnd, INT offset, LONG_PTR newval,
     return unix_funcs->pNtUserSetWindowLongPtr( hwnd, offset, newval, ansi );
 }
 
-BOOL WINAPI NtUserSetWindowPlacement( HWND hwnd, const WINDOWPLACEMENT *wpl )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserSetWindowPlacement( hwnd, wpl );
-}
-
 BOOL WINAPI NtUserSetWindowPos( HWND hwnd, HWND after, INT x, INT y, INT cx, INT cy, UINT flags )
 {
     if (!unix_funcs) return 0;
@@ -1263,12 +1069,6 @@ WORD WINAPI NtUserSetWindowWord( HWND hwnd, INT offset, WORD newval )
     return unix_funcs->pNtUserSetWindowWord( hwnd, offset, newval );
 }
 
-BOOL WINAPI NtUserShowCaret( HWND hwnd )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserShowCaret( hwnd );
-}
-
 INT WINAPI NtUserShowCursor( BOOL show )
 {
     if (!unix_funcs) return 0;
@@ -1306,24 +1106,6 @@ INT WINAPI NtUserToUnicodeEx( UINT virt, UINT scan, const BYTE *state,
     return unix_funcs->pNtUserToUnicodeEx( virt, scan, state, str, size, flags, layout );
 }
 
-BOOL WINAPI NtUserTrackMouseEvent( TRACKMOUSEEVENT *info )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->pNtUserTrackMouseEvent( info );
-}
-
-INT WINAPI NtUserTranslateAccelerator( HWND hwnd, HACCEL accel, MSG *msg )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserTranslateAccelerator( hwnd, accel, msg );
-}
-
-BOOL WINAPI NtUserTranslateMessage( const MSG *msg, UINT flags )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserTranslateMessage( msg, flags );
-}
-
 BOOL WINAPI NtUserUnregisterClass( UNICODE_STRING *name, HINSTANCE instance,
                                    struct client_menu_name *client_menu_name )
 {
@@ -1352,12 +1134,6 @@ WORD WINAPI NtUserVkKeyScanEx( WCHAR chr, HKL layout )
     return unix_funcs->pNtUserVkKeyScanEx( chr, layout );
 }
 
-DWORD WINAPI NtUserWaitForInputIdle( HANDLE process, DWORD timeout, BOOL wow )
-{
-    if (!unix_funcs) return 0;
-    return unix_funcs->pNtUserWaitForInputIdle( process, timeout, wow );
-}
-
 HWND WINAPI NtUserWindowFromPoint( LONG x, LONG y )
 {
     if (!unix_funcs) return 0;
@@ -1378,6 +1154,13 @@ BOOL CDECL __wine_get_icm_profile( HDC hdc, BOOL allow_default, DWORD *size, WCH
     return unix_funcs->get_icm_profile( hdc, allow_default, size, filename );
 }
 
+void CDECL __wine_set_visible_region( HDC hdc, HRGN hrgn, const RECT *vis_rect, const RECT *device_rect,
+                                      struct window_surface *surface )
+{
+    if (!unix_funcs) return;
+    unix_funcs->set_visible_region( hdc, hrgn, vis_rect, device_rect, surface );
+}
+
 BOOL CDECL __wine_get_brush_bitmap_info( HBRUSH handle, BITMAPINFO *info, void *bits, UINT *usage )
 {
     if (!unix_funcs) return FALSE;
@@ -1402,19 +1185,13 @@ struct opengl_funcs * CDECL __wine_get_wgl_driver( HDC hdc, UINT version )
     return unix_funcs->get_wgl_driver( hdc, version );
 }
 
-BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput )
-{
-    if (!unix_funcs) return FALSE;
-    return unix_funcs->wine_send_input( hwnd, input, rawinput );
-}
-
 /***********************************************************************
- *           __wine_set_user_driver    (win32u.@)
+ *           __wine_set_display_driver    (win32u.@)
  */
-void CDECL __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT version )
+void CDECL __wine_set_display_driver( struct user_driver_funcs *funcs, UINT version )
 {
     if (!unix_funcs) return;
-    return unix_funcs->set_user_driver( funcs, version );
+    return unix_funcs->set_display_driver( funcs, version );
 }
 
 extern void wrappers_init( unixlib_handle_t handle )
diff --git a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
index 925b2df0401..d677322c1b3 100644
--- a/dlls/wined3d/directx.c
+++ b/dlls/wined3d/directx.c
@@ -23,7 +23,6 @@
 
 #include "wined3d_private.h"
 #include "winternl.h"
-#include "wine/list.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
@@ -39,19 +38,6 @@ enum wined3d_driver_model
     DRIVER_MODEL_NT6X
 };
 
-struct wined3d_adapter_budget_change_notification
-{
-    const struct wined3d_adapter *adapter;
-    HANDLE event;
-    DWORD cookie;
-    UINT64 last_local_budget;
-    UINT64 last_non_local_budget;
-    struct list entry;
-};
-
-static struct list adapter_budget_change_notifications = LIST_INIT( adapter_budget_change_notifications );
-static HANDLE notification_thread, notification_thread_stop_event;
-
 /* The d3d device ID */
 static const GUID IID_D3DDEVICE_D3DUID = { 0xaeb2cdd4, 0x6e41, 0x43ea, { 0x94,0x1c,0x83,0x61,0xcc,0x76,0x07,0x81 } };
 
@@ -117,11 +103,14 @@ HRESULT CDECL wined3d_output_take_ownership(const struct wined3d_output *output,
 static void wined3d_output_cleanup(const struct wined3d_output *output)
 {
     D3DKMT_DESTROYDEVICE destroy_device_desc;
+    D3DKMT_CLOSEADAPTER close_adapter_desc;
 
     TRACE("output %p.\n", output);
 
     destroy_device_desc.hDevice = output->kmt_device;
     D3DKMTDestroyDevice(&destroy_device_desc);
+    close_adapter_desc.hAdapter = output->kmt_adapter;
+    D3DKMTCloseAdapter(&close_adapter_desc);
 }
 
 static HRESULT wined3d_output_init(struct wined3d_output *output, unsigned int ordinal,
@@ -136,17 +125,20 @@ static HRESULT wined3d_output_init(struct wined3d_output *output, unsigned int o
     lstrcpyW(open_adapter_desc.DeviceName, device_name);
     if (D3DKMTOpenAdapterFromGdiDisplayName(&open_adapter_desc))
         return E_INVALIDARG;
-    close_adapter_desc.hAdapter = open_adapter_desc.hAdapter;
-    D3DKMTCloseAdapter(&close_adapter_desc);
 
-    create_device_desc.u.hAdapter = adapter->kmt_adapter;
+    create_device_desc.u.hAdapter = open_adapter_desc.hAdapter;
     if (D3DKMTCreateDevice(&create_device_desc))
+    {
+        close_adapter_desc.hAdapter = open_adapter_desc.hAdapter;
+        D3DKMTCloseAdapter(&close_adapter_desc);
         return E_FAIL;
+    }
 
     output->ordinal = ordinal;
     lstrcpyW(output->device_name, device_name);
     output->adapter = adapter;
     output->screen_format = WINED3DFMT_UNKNOWN;
+    output->kmt_adapter = open_adapter_desc.hAdapter;
     output->kmt_device = create_device_desc.hDevice;
     output->vidpn_source_id = open_adapter_desc.VidPnSourceId;
 
@@ -174,15 +166,12 @@ ssize_t adapter_adjust_mapped_memory(struct wined3d_adapter *adapter, ssize_t si
 
 void wined3d_adapter_cleanup(struct wined3d_adapter *adapter)
 {
-    D3DKMT_CLOSEADAPTER close_adapter_desc;
     unsigned int output_idx;
 
     for (output_idx = 0; output_idx < adapter->output_count; ++output_idx)
         wined3d_output_cleanup(&adapter->outputs[output_idx]);
     heap_free(adapter->outputs);
     heap_free(adapter->formats);
-    close_adapter_desc.hAdapter = adapter->kmt_adapter;
-    D3DKMTCloseAdapter(&close_adapter_desc);
 }
 
 ULONG CDECL wined3d_incref(struct wined3d *wined3d)
@@ -1001,190 +990,6 @@ unsigned int CDECL wined3d_adapter_get_output_count(const struct wined3d_adapter
     return adapter->output_count;
 }
 
-HRESULT CDECL wined3d_adapter_get_video_memory_info(const struct wined3d_adapter *adapter,
-        unsigned int node_idx, enum wined3d_memory_segment_group group,
-        struct wined3d_video_memory_info *info)
-{
-    static unsigned int once;
-    D3DKMT_QUERYVIDEOMEMORYINFO query_memory_info;
-    struct wined3d_adapter_identifier adapter_id;
-    NTSTATUS status;
-    HRESULT hr;
-
-    TRACE("adapter %p, node_idx %u, group %d, info %p.\n", adapter, node_idx, group, info);
-
-    if (group > WINED3D_MEMORY_SEGMENT_GROUP_NON_LOCAL)
-    {
-        WARN("Invalid memory segment group %#x.\n", group);
-        return E_INVALIDARG;
-    }
-
-    query_memory_info.hProcess = NULL;
-    query_memory_info.hAdapter = adapter->kmt_adapter;
-    query_memory_info.PhysicalAdapterIndex = node_idx;
-    query_memory_info.MemorySegmentGroup = (D3DKMT_MEMORY_SEGMENT_GROUP)group;
-    status = D3DKMTQueryVideoMemoryInfo(&query_memory_info);
-    if (status == STATUS_SUCCESS)
-    {
-        info->budget = query_memory_info.Budget;
-        info->current_usage = query_memory_info.CurrentUsage;
-        info->current_reservation = query_memory_info.CurrentReservation;
-        info->available_reservation = query_memory_info.AvailableForReservation;
-        return WINED3D_OK;
-    }
-
-    /* D3DKMTQueryVideoMemoryInfo() failed, fallback to fake memory info */
-    if (!once++)
-        FIXME("Returning fake video memory info.\n");
-
-    if (node_idx)
-        FIXME("Ignoring node index %u.\n", node_idx);
-
-    adapter_id.driver_size = 0;
-    adapter_id.description_size = 0;
-    if (FAILED(hr = wined3d_adapter_get_identifier(adapter, 0, &adapter_id)))
-        return hr;
-
-    switch (group)
-    {
-        case WINED3D_MEMORY_SEGMENT_GROUP_LOCAL:
-            info->budget = adapter_id.video_memory;
-            info->current_usage = adapter->vram_bytes_used;
-            info->available_reservation = adapter_id.video_memory / 2;
-            info->current_reservation = 0;
-            break;
-        case WINED3D_MEMORY_SEGMENT_GROUP_NON_LOCAL:
-            memset(info, 0, sizeof(*info));
-            break;
-    }
-    return WINED3D_OK;
-}
-
-static DWORD CALLBACK notification_thread_func(void *stop_event)
-{
-    struct wined3d_adapter_budget_change_notification *notification;
-    struct wined3d_video_memory_info info;
-    HRESULT hr;
-
-    while (TRUE)
-    {
-        wined3d_mutex_lock();
-        LIST_FOR_EACH_ENTRY(notification, &adapter_budget_change_notifications,
-                struct wined3d_adapter_budget_change_notification, entry)
-        {
-            hr = wined3d_adapter_get_video_memory_info(notification->adapter, 0,
-                    WINED3D_MEMORY_SEGMENT_GROUP_LOCAL, &info);
-            if (SUCCEEDED(hr) && info.budget != notification->last_local_budget)
-            {
-                notification->last_local_budget = info.budget;
-                SetEvent(notification->event);
-                continue;
-            }
-
-            hr = wined3d_adapter_get_video_memory_info(notification->adapter, 0,
-                    WINED3D_MEMORY_SEGMENT_GROUP_NON_LOCAL, &info);
-            if (SUCCEEDED(hr) && info.budget != notification->last_non_local_budget)
-            {
-                notification->last_non_local_budget = info.budget;
-                SetEvent(notification->event);
-            }
-        }
-        wined3d_mutex_unlock();
-
-        if (WaitForSingleObject(stop_event, 1000) == WAIT_OBJECT_0)
-            break;
-    }
-
-    return TRUE;
-}
-
-HRESULT CDECL wined3d_adapter_register_budget_change_notification(const struct wined3d_adapter *adapter,
-        HANDLE event, DWORD *cookie)
-{
-    static DWORD cookie_counter;
-    static BOOL wrapped;
-    struct wined3d_adapter_budget_change_notification *notification, *new_notification;
-    BOOL found = FALSE;
-
-    new_notification = heap_alloc_zero(sizeof(*new_notification));
-    if (!new_notification)
-        return E_OUTOFMEMORY;
-
-    wined3d_mutex_lock();
-    new_notification->adapter = adapter;
-    new_notification->event = event;
-    new_notification->cookie = cookie_counter++;
-    if (cookie_counter < new_notification->cookie)
-        wrapped = TRUE;
-    if (wrapped)
-    {
-        while (TRUE)
-        {
-            LIST_FOR_EACH_ENTRY(notification, &adapter_budget_change_notifications,
-                    struct wined3d_adapter_budget_change_notification, entry)
-            {
-                if (notification->cookie == new_notification->cookie)
-                {
-                    found = TRUE;
-                    break;
-                }
-            }
-
-            if (!found)
-                break;
-
-            new_notification->cookie = cookie_counter++;
-        }
-    }
-
-    *cookie = new_notification->cookie;
-    list_add_head(&adapter_budget_change_notifications, &new_notification->entry);
-
-    if (!notification_thread)
-    {
-        notification_thread_stop_event = CreateEventW(0, FALSE, FALSE, NULL);
-        notification_thread = CreateThread(NULL, 0, notification_thread_func,
-                notification_thread_stop_event, 0, NULL);
-    }
-    wined3d_mutex_unlock();
-    return WINED3D_OK;
-}
-
-HRESULT CDECL wined3d_adapter_unregister_budget_change_notification(DWORD cookie)
-{
-    struct wined3d_adapter_budget_change_notification *notification;
-    HANDLE thread, thread_stop_event;
-
-    wined3d_mutex_lock();
-    LIST_FOR_EACH_ENTRY(notification, &adapter_budget_change_notifications,
-            struct wined3d_adapter_budget_change_notification, entry)
-    {
-        if (notification->cookie == cookie)
-        {
-            list_remove(&notification->entry);
-            heap_free(notification);
-            break;
-        }
-    }
-
-    if (!list_empty(&adapter_budget_change_notifications))
-    {
-        wined3d_mutex_unlock();
-        return WINED3D_OK;
-    }
-
-    thread = notification_thread;
-    thread_stop_event = notification_thread_stop_event;
-    notification_thread = NULL;
-    notification_thread_stop_event = NULL;
-    wined3d_mutex_unlock();
-    SetEvent(thread_stop_event);
-    WaitForSingleObject(thread, INFINITE);
-    CloseHandle(thread);
-    CloseHandle(thread_stop_event);
-    return WINED3D_OK;
-}
-
 HRESULT CDECL wined3d_register_software_device(struct wined3d *wined3d, void *init_function)
 {
     FIXME("wined3d %p, init_function %p stub!\n", wined3d, init_function);
@@ -3425,9 +3230,7 @@ static BOOL wined3d_adapter_create_output(struct wined3d_adapter *adapter, const
 BOOL wined3d_adapter_init(struct wined3d_adapter *adapter, unsigned int ordinal, const LUID *luid,
         const struct wined3d_adapter_ops *adapter_ops)
 {
-    D3DKMT_OPENADAPTERFROMLUID open_adapter_desc;
     unsigned int output_idx = 0, primary_idx = 0;
-    D3DKMT_CLOSEADAPTER close_adapter_desc;
     DISPLAY_DEVICEW display_device;
     BOOL ret = FALSE;
 
@@ -3450,11 +3253,6 @@ BOOL wined3d_adapter_init(struct wined3d_adapter *adapter, unsigned int ordinal,
     }
     TRACE("adapter %p LUID %08x:%08x.\n", adapter, adapter->luid.HighPart, adapter->luid.LowPart);
 
-    open_adapter_desc.AdapterLuid = adapter->luid;
-    if (D3DKMTOpenAdapterFromLuid(&open_adapter_desc))
-        return FALSE;
-    adapter->kmt_adapter = open_adapter_desc.hAdapter;
-
     display_device.cb = sizeof(display_device);
     while (EnumDisplayDevicesW(NULL, output_idx++, &display_device, 0))
     {
@@ -3492,8 +3290,6 @@ done:
         for (output_idx = 0; output_idx < adapter->output_count; ++output_idx)
             wined3d_output_cleanup(&adapter->outputs[output_idx]);
         heap_free(adapter->outputs);
-        close_adapter_desc.hAdapter = adapter->kmt_adapter;
-        D3DKMTCloseAdapter(&close_adapter_desc);
     }
     return ret;
 }
diff --git a/dlls/wined3d/wined3d.spec b/dlls/wined3d/wined3d.spec
index 63220e1222c..1b1c82f90bb 100644
--- a/dlls/wined3d/wined3d.spec
+++ b/dlls/wined3d/wined3d.spec
@@ -21,9 +21,6 @@
 @ cdecl wined3d_adapter_get_identifier(ptr long ptr)
 @ cdecl wined3d_adapter_get_output(ptr long)
 @ cdecl wined3d_adapter_get_output_count(ptr)
-@ cdecl wined3d_adapter_get_video_memory_info(ptr long long ptr)
-@ cdecl wined3d_adapter_register_budget_change_notification(ptr ptr ptr)
-@ cdecl wined3d_adapter_unregister_budget_change_notification(long)
 
 @ cdecl wined3d_blend_state_create(ptr ptr ptr ptr ptr)
 @ cdecl wined3d_blend_state_decref(ptr)
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 918c1b911fe..3bdacaec233 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -3499,6 +3499,7 @@ struct wined3d_output
     struct wined3d_adapter *adapter;
     enum wined3d_format_id screen_format;
 
+    D3DKMT_HANDLE kmt_adapter;
     D3DKMT_HANDLE kmt_device;
     D3DDDI_VIDEO_PRESENT_SOURCE_ID vidpn_source_id;
 };
@@ -3521,7 +3522,6 @@ struct wined3d_adapter
     struct wined3d_driver_info driver_info;
     struct wined3d_output *outputs;
     unsigned int output_count;
-    D3DKMT_HANDLE kmt_adapter;
     UINT64 vram_bytes_used;
     GUID driver_uuid;
     GUID device_uuid;
diff --git a/dlls/winemac.drv/Makefile.in b/dlls/winemac.drv/Makefile.in
index 19f3e834cec..e345249aac7 100644
--- a/dlls/winemac.drv/Makefile.in
+++ b/dlls/winemac.drv/Makefile.in
@@ -1,6 +1,5 @@
 C_SRCS = \
 	clipboard.c \
 	display.c \
-	dllmain.c \
 	dragdrop.c \
 	event.c \
 	gdi.c \
diff --git a/dlls/winemac.drv/clipboard.c b/dlls/winemac.drv/clipboard.c
index af8d99b59a3..235c4cc1bd6 100644
--- a/dlls/winemac.drv/clipboard.c
+++ b/dlls/winemac.drv/clipboard.c
@@ -22,10 +22,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include "ntstatus.h"
@@ -36,6 +32,7 @@
 #include "shlobj.h"
 #include "wine/list.h"
 #include "wine/server.h"
+#include "wine/unicode.h"
 
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
@@ -90,9 +87,6 @@ static CFDataRef export_unicodetext_to_utf16(void *data, size_t size);
  *              Static Variables
  **************************************************************************/
 
-static const WCHAR clipboard_classname[] =
-    {'_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d','_','m','a','n','a','g','e','r',0};
-
 /* Clipboard formats */
 static struct list format_list = LIST_INIT(format_list);
 
@@ -196,10 +190,11 @@ static DWORD clipboard_thread_id;
 static HWND clipboard_hwnd;
 static BOOL is_clipboard_owner;
 static macdrv_window clipboard_cocoa_window;
-static ULONG last_clipboard_update;
+static ULONG64 last_clipboard_update;
 static DWORD last_get_seqno;
 static WINE_CLIPFORMAT **current_mac_formats;
 static unsigned int nb_current_mac_formats;
+static WCHAR clipboard_pipe_name[256];
 
 
 /**************************************************************************
@@ -213,7 +208,7 @@ static unsigned int nb_current_mac_formats;
 /**************************************************************************
  *              debugstr_format
  */
-static const char *debugstr_format(UINT id)
+const char *debugstr_format(UINT id)
 {
     WCHAR buffer[256];
 
@@ -251,12 +246,6 @@ static const char *debugstr_format(UINT id)
 }
 
 
-static CFTypeRef pasteboard_from_handle(UINT64 handle)
-{
-    return (CFTypeRef)(UINT_PTR)handle;
-}
-
-
 /**************************************************************************
  *              insert_clipboard_format
  */
@@ -578,21 +567,6 @@ static void *import_html(CFDataRef data, size_t *ret_size)
 }
 
 
-static CPTABLEINFO *get_ansi_cp(void)
-{
-    USHORT utf8_hdr[2] = { 0, CP_UTF8 };
-    static CPTABLEINFO cp;
-    if (!cp.CodePage)
-    {
-        if (NtCurrentTeb()->Peb->AnsiCodePageData)
-            RtlInitCodePageTable(NtCurrentTeb()->Peb->AnsiCodePageData, &cp);
-        else
-            RtlInitCodePageTable(utf8_hdr, &cp);
-    }
-    return &cp;
-}
-
-
 /* based on wine_get_dos_file_name */
 static WCHAR *get_dos_file_name(const char *path)
 {
@@ -765,7 +739,7 @@ static void *import_nsfilenames_to_hdrop(CFDataRef data, size_t *ret_size)
 
     len = 1; /* for the terminating null */
     for (i = 0; i < count; i++)
-        len += wcslen(paths[i]) + 1;
+        len += strlenW(paths[i]) + 1;
 
     *ret_size = sizeof(*dropfiles) + len * sizeof(WCHAR);
     if (!(dropfiles = malloc(*ret_size)))
@@ -783,8 +757,8 @@ static void *import_nsfilenames_to_hdrop(CFDataRef data, size_t *ret_size)
     p = (WCHAR*)(dropfiles + 1);
     for (i = 0; i < count; i++)
     {
-        wcscpy(p, paths[i]);
-        p += wcslen(p) + 1;
+        strcpyW(p, paths[i]);
+        p += strlenW(p) + 1;
     }
     *p = 0;
 
@@ -834,11 +808,7 @@ static void *import_utf8_to_unicodetext(CFDataRef data, size_t *ret_size)
         dst[j++] = 0;
 
         if ((ret = malloc(j * sizeof(WCHAR))))
-        {
-            DWORD dst_size;
-            RtlUTF8ToUnicodeN(ret, j * sizeof(WCHAR), &dst_size, dst, j);
-            *ret_size = dst_size;
-        }
+            *ret_size = MultiByteToWideChar(CP_UTF8, 0, dst, j, ret, j) * sizeof(WCHAR);
 
         free(dst);
     }
@@ -968,22 +938,21 @@ static CFDataRef export_hdrop_to_filenames(void *data, size_t size)
             unixname = get_unix_file_name(p);
         else
         {
-            CPTABLEINFO *cp = get_ansi_cp();
-            DWORD len = strlen(p) + 1;
-
-            if (len * 3 > buffer_len)
+            int len = MultiByteToWideChar(CP_ACP, 0, p, -1, NULL, 0);
+            if (len)
             {
-                free(buffer);
-                buffer_len = len * 3;
-                buffer = malloc(buffer_len * sizeof(*buffer));
-            }
+                if (len > buffer_len)
+                {
+                    free(buffer);
+                    buffer_len = len * 2;
+                    buffer = malloc(buffer_len * sizeof(*buffer));
+                }
 
-            if (cp->CodePage == CP_UTF8)
-                RtlUTF8ToUnicodeN(buffer, buffer_len * sizeof(WCHAR), &len, p, len);
+                MultiByteToWideChar(CP_ACP, 0, p, -1, buffer, buffer_len);
+                unixname = get_unix_file_name(buffer);
+            }
             else
-                RtlCustomCPToUnicodeN(cp, buffer, buffer_len * sizeof(WCHAR), &len, p, len);
-
-            unixname = get_unix_file_name(buffer);
+                unixname = NULL;
         }
         if (!unixname)
         {
@@ -993,7 +962,7 @@ static CFDataRef export_hdrop_to_filenames(void *data, size_t size)
         }
 
         if (dropfiles->fWide)
-            p = (WCHAR*)p + wcslen(p) + 1;
+            p = (WCHAR*)p + strlenW(p) + 1;
         else
             p = (char*)p + strlen(p) + 1;
 
@@ -1062,12 +1031,10 @@ static CFDataRef export_html(void *data, size_t size)
 static CFDataRef export_unicodetext_to_utf8(void *data, size_t size)
 {
     CFMutableDataRef ret;
-    WCHAR *src = data;
-    DWORD dst_len = 0;
+    INT dst_len;
 
-    /* Leave off null terminator. */
-    if (size >= sizeof(WCHAR) && !src[size / sizeof(WCHAR) - 1]) size -= sizeof(WCHAR);
-    RtlUnicodeToUTF8N(NULL, 0, &dst_len, src, size);
+    dst_len = WideCharToMultiByte(CP_UTF8, 0, data, -1, NULL, 0, NULL, NULL);
+    if (dst_len) dst_len--; /* Leave off null terminator. */
     ret = CFDataCreateMutable(NULL, dst_len);
     if (ret)
     {
@@ -1076,7 +1043,7 @@ static CFDataRef export_unicodetext_to_utf8(void *data, size_t size)
 
         CFDataSetLength(ret, dst_len);
         dst = (LPSTR)CFDataGetMutableBytePtr(ret);
-        RtlUnicodeToUTF8N(dst, dst_len, &dst_len, src, size);
+        WideCharToMultiByte(CP_UTF8, 0, data, -1, dst, dst_len, NULL, NULL);
 
         /* Remove carriage returns */
         for (i = 0, j = 0; i < dst_len; i++)
@@ -1131,26 +1098,24 @@ static CFDataRef export_unicodetext_to_utf16(void *data, size_t size)
 
 
 /**************************************************************************
- *              macdrv_dnd_get_data
+ *              macdrv_get_pasteboard_data
  */
-NTSTATUS macdrv_dnd_get_data(void *arg)
+HANDLE macdrv_get_pasteboard_data(CFTypeRef pasteboard, UINT desired_format)
 {
-    struct dnd_get_data_params *params = arg;
-    CFTypeRef pasteboard = pasteboard_from_handle(params->handle);
     CFArrayRef types;
     CFIndex count;
     CFIndex i;
     CFStringRef type, best_type;
     WINE_CLIPFORMAT* best_format = NULL;
-    NTSTATUS status = STATUS_SUCCESS;
+    HANDLE data = NULL;
 
-    TRACE("pasteboard %p, desired_format %s\n", pasteboard, debugstr_format(params->format));
+    TRACE("pasteboard %p, desired_format %s\n", pasteboard, debugstr_format(desired_format));
 
     types = macdrv_copy_pasteboard_types(pasteboard);
     if (!types)
     {
         WARN("Failed to copy pasteboard types\n");
-        return STATUS_NO_MEMORY;
+        return NULL;
     }
 
     count = CFArrayGetCount(types);
@@ -1166,7 +1131,7 @@ NTSTATUS macdrv_dnd_get_data(void *arg)
         {
             TRACE("for type %s got format %p/%s\n", debugstr_cf(type), format, debugstr_format(format->format_id));
 
-            if (format->format_id == params->format)
+            if (format->format_id == desired_format)
             {
                 /* The best format is the matching one which is not synthesized.  Failing that,
                    the best format is the first matching synthesized format. */
@@ -1188,12 +1153,15 @@ NTSTATUS macdrv_dnd_get_data(void *arg)
         if (pasteboard_data)
         {
             size_t size;
-            void *import = best_format->import_func(pasteboard_data, &size);
+            void *import = best_format->import_func(pasteboard_data, &size), *ptr;
             if (import)
             {
-                if (size > params->size) status = STATUS_BUFFER_OVERFLOW;
-                else memcpy(params->data, import, size);
-                params->size = size;
+                data = GlobalAlloc(GMEM_FIXED, size);
+                if (data && (ptr = GlobalLock(data)))
+                {
+                    memcpy(ptr, import, size);
+                    GlobalUnlock(data);
+                }
                 free(import);
             }
             CFRelease(pasteboard_data);
@@ -1201,24 +1169,22 @@ NTSTATUS macdrv_dnd_get_data(void *arg)
     }
 
     CFRelease(types);
-    TRACE(" -> %#x\n", status);
-    return status;
+    TRACE(" -> %p\n", data);
+    return data;
 }
 
 
 /**************************************************************************
  *              macdrv_pasteboard_has_format
  */
-NTSTATUS macdrv_dnd_have_format(void *arg)
+BOOL macdrv_pasteboard_has_format(CFTypeRef pasteboard, UINT desired_format)
 {
-    struct dnd_have_format_params *params = arg;
-    CFTypeRef pasteboard = pasteboard_from_handle(params->handle);
     CFArrayRef types;
     int count;
     UINT i;
     BOOL found = FALSE;
 
-    TRACE("pasteboard %p, desired_format %s\n", pasteboard, debugstr_format(params->format));
+    TRACE("pasteboard %p, desired_format %s\n", pasteboard, debugstr_format(desired_format));
 
     types = macdrv_copy_pasteboard_types(pasteboard);
     if (!types)
@@ -1239,7 +1205,7 @@ NTSTATUS macdrv_dnd_have_format(void *arg)
         {
             TRACE("for type %s got format %s\n", debugstr_cf(type), debugstr_format(format->format_id));
 
-            if (format->format_id == params->format)
+            if (format->format_id == desired_format)
             {
                 found = TRUE;
                 break;
@@ -1375,24 +1341,33 @@ static WINE_CLIPFORMAT** get_formats_for_pasteboard(CFTypeRef pasteboard, UINT *
 
 
 /**************************************************************************
- *              macdrv_dnd_get_formats
+ *              macdrv_get_pasteboard_formats
  */
-NTSTATUS macdrv_dnd_get_formats(void *arg)
+UINT* macdrv_get_pasteboard_formats(CFTypeRef pasteboard, UINT* num_formats)
 {
-    struct dnd_get_formats_params *params = arg;
-    CFTypeRef pasteboard = pasteboard_from_handle(params->handle);
     WINE_CLIPFORMAT** formats;
     UINT count, i;
+    UINT* format_ids;
 
     formats = get_formats_for_pasteboard(pasteboard, &count);
     if (!formats)
-        return 0;
-    count = min(count, ARRAYSIZE(params->formats));
+        return NULL;
+
+    format_ids = malloc(count);
+    if (!format_ids)
+    {
+        WARN("Failed to allocate formats IDs array\n");
+        free(formats);
+        return NULL;
+    }
 
     for (i = 0; i < count; i++)
-        params->formats[i] = formats[i]->format_id;
+        format_ids[i] = formats[i]->format_id;
 
-    return count;
+    free(formats);
+
+    *num_formats = count;
+    return format_ids;
 }
 
 
@@ -1426,7 +1401,7 @@ static UINT *get_clipboard_formats(UINT *size)
     for (;;)
     {
         if (!(ids = malloc(*size * sizeof(*ids)))) return NULL;
-        if (NtUserGetUpdatedClipboardFormats(ids, *size, size)) break;
+        if (GetUpdatedClipboardFormats(ids, *size, size)) break;
         free(ids);
         if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) return NULL;
     }
@@ -1476,9 +1451,8 @@ static void set_win32_clipboard_formats_from_mac_pasteboard(CFArrayRef types)
 
     for (i = 0; i < count; i++)
     {
-        struct set_clipboard_params params = { 0 };
         TRACE("adding format %s\n", debugstr_format(formats[i]->format_id));
-        NtUserSetClipboardData(formats[i]->format_id, 0, &params);
+        SetClipboardData(formats[i]->format_id, 0);
     }
 
     free(current_mac_formats);
@@ -1545,7 +1519,7 @@ static void grab_win32_clipboard(void)
     if (!NtUserOpenClipboard(clipboard_hwnd, 0)) return;
     NtUserEmptyClipboard();
     is_clipboard_owner = TRUE;
-    last_clipboard_update = NtGetTickCount();
+    last_clipboard_update = GetTickCount64();
     set_win32_clipboard_formats_from_mac_pasteboard(types);
     NtUserCloseClipboard();
     NtUserSetTimer(clipboard_hwnd, 1, CLIPBOARD_UPDATE_DELAY, NULL, TIMERV_DEFAULT_COALESCING);
@@ -1562,15 +1536,15 @@ static void update_clipboard(void)
 {
     static BOOL updating;
 
-    TRACE("is_clipboard_owner %d last_clipboard_update %u now %u\n",
-          is_clipboard_owner, last_clipboard_update, NtGetTickCount());
+    TRACE("is_clipboard_owner %d last_clipboard_update %llu now %llu\n",
+          is_clipboard_owner, (unsigned long long)last_clipboard_update, (unsigned long long)GetTickCount64());
 
     if (updating) return;
     updating = TRUE;
 
     if (is_clipboard_owner)
     {
-        if (NtGetTickCount() - last_clipboard_update > CLIPBOARD_UPDATE_DELAY)
+        if (GetTickCount64() - last_clipboard_update > CLIPBOARD_UPDATE_DELAY)
             grab_win32_clipboard();
     }
     else if (!macdrv_is_pasteboard_owner(clipboard_cocoa_window))
@@ -1580,44 +1554,20 @@ static void update_clipboard(void)
 }
 
 
-static BOOL init_clipboard(HWND hwnd)
-{
-    struct macdrv_window_features wf;
-
-    memset(&wf, 0, sizeof(wf));
-    clipboard_cocoa_window = macdrv_create_cocoa_window(&wf, CGRectMake(100, 100, 100, 100), hwnd,
-                                                        macdrv_init_thread_data()->queue);
-    if (!clipboard_cocoa_window)
-    {
-        ERR("failed to create clipboard Cocoa window\n");
-        return FALSE;
-    }
-
-    clipboard_hwnd = hwnd;
-    clipboard_thread_id = GetCurrentThreadId();
-    NtUserAddClipboardFormatListener(clipboard_hwnd);
-    register_builtin_formats();
-    grab_win32_clipboard();
-
-    TRACE("clipboard thread %04x running\n", GetCurrentThreadId());
-    return TRUE;
-}
-
-
 /**************************************************************************
- *              macdrv_ClipboardWindowProc
+ *              clipboard_wndproc
  *
  * Window procedure for the clipboard manager.
  */
-LRESULT macdrv_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+static LRESULT CALLBACK clipboard_wndproc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 {
     switch (msg)
     {
         case WM_NCCREATE:
-            return init_clipboard(hwnd);
+            return TRUE;
         case WM_CLIPBOARDUPDATE:
             if (is_clipboard_owner) break;  /* ignore our own changes */
-            if ((LONG)(NtUserGetClipboardSequenceNumber() - last_get_seqno) <= 0) break;
+            if ((LONG)(GetClipboardSequenceNumber() - last_get_seqno) <= 0) break;
             set_mac_pasteboard_types_from_win32_clipboard();
             break;
         case WM_RENDERFORMAT:
@@ -1630,13 +1580,222 @@ LRESULT macdrv_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
         case WM_DESTROYCLIPBOARD:
             TRACE("WM_DESTROYCLIPBOARD: lost ownership\n");
             is_clipboard_owner = FALSE;
-            NtUserKillTimer(hwnd, 1);
-            break;
-        case WM_USER:
-            update_clipboard();
+            KillTimer(hwnd, 1);
             break;
     }
-    return NtUserMessageCall(hwnd, msg, wp, lp, NULL, NtUserDefWindowProc, FALSE);
+    return DefWindowProcW(hwnd, msg, wp, lp);
+}
+
+
+/**************************************************************************
+ *              wait_clipboard_mutex
+ *
+ * Make sure that there's only one clipboard thread per window station.
+ */
+static BOOL wait_clipboard_mutex(void)
+{
+    static const WCHAR prefix[] = {'_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d','_'};
+    WCHAR buffer[MAX_PATH + ARRAY_SIZE(prefix)];
+    HANDLE mutex;
+
+    memcpy(buffer, prefix, sizeof(prefix));
+    if (!GetUserObjectInformationW(GetProcessWindowStation(), UOI_NAME,
+                                   buffer + ARRAY_SIZE(prefix),
+                                   sizeof(buffer) - sizeof(prefix), NULL))
+    {
+        ERR("failed to get winstation name\n");
+        return FALSE;
+    }
+    mutex = CreateMutexW(NULL, TRUE, buffer);
+    if (GetLastError() == ERROR_ALREADY_EXISTS)
+    {
+        TRACE("waiting for mutex %s\n", debugstr_w(buffer));
+        WaitForSingleObject(mutex, INFINITE);
+    }
+    return TRUE;
+}
+
+
+/**************************************************************************
+ *              init_pipe_name
+ *
+ * Init-once helper for get_pipe_name.
+ */
+static BOOL CALLBACK init_pipe_name(INIT_ONCE* once, void* param, void** context)
+{
+    static const WCHAR prefix[] = {'\\','\\','.','\\','p','i','p','e','\\','_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d','_'};
+
+    memcpy(clipboard_pipe_name, prefix, sizeof(prefix));
+    if (!GetUserObjectInformationW(GetProcessWindowStation(), UOI_NAME,
+                                   clipboard_pipe_name + ARRAY_SIZE(prefix),
+                                   sizeof(clipboard_pipe_name) - sizeof(prefix), NULL))
+    {
+        ERR("failed to get winstation name\n");
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+
+/**************************************************************************
+ *              get_pipe_name
+ *
+ * Get the name of the pipe used to communicate with the per-window-station
+ * clipboard manager thread.
+ */
+static const WCHAR* get_pipe_name(void)
+{
+    static INIT_ONCE once = INIT_ONCE_STATIC_INIT;
+    InitOnceExecuteOnce(&once, init_pipe_name, NULL, NULL);
+    return clipboard_pipe_name[0] ? clipboard_pipe_name : NULL;
+}
+
+
+/**************************************************************************
+ *              clipboard_thread
+ *
+ * Thread running inside the desktop process to manage the clipboard
+ */
+static DWORD WINAPI clipboard_thread(void *arg)
+{
+    static const WCHAR clipboard_classname[] = {'_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d','_','m','a','n','a','g','e','r',0};
+    WNDCLASSW class;
+    struct macdrv_window_features wf;
+    const WCHAR* pipe_name;
+    HANDLE pipe = NULL;
+    HANDLE event = NULL;
+    OVERLAPPED overlapped;
+    BOOL need_connect = TRUE, pending = FALSE;
+    MSG msg;
+
+    if (!wait_clipboard_mutex()) return 0;
+
+    memset(&class, 0, sizeof(class));
+    class.lpfnWndProc   = clipboard_wndproc;
+    class.lpszClassName = clipboard_classname;
+
+    if (!RegisterClassW(&class) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR("could not register clipboard window class err %u\n", GetLastError());
+        return 0;
+    }
+    if (!(clipboard_hwnd = CreateWindowW(clipboard_classname, NULL, 0, 0, 0, 0, 0,
+                                         HWND_MESSAGE, 0, 0, NULL)))
+    {
+        ERR("failed to create clipboard window err %u\n", GetLastError());
+        return 0;
+    }
+
+    memset(&wf, 0, sizeof(wf));
+    clipboard_cocoa_window = macdrv_create_cocoa_window(&wf, CGRectMake(100, 100, 100, 100), clipboard_hwnd,
+                                                        macdrv_init_thread_data()->queue);
+    if (!clipboard_cocoa_window)
+    {
+        ERR("failed to create clipboard Cocoa window\n");
+        goto done;
+    }
+
+    pipe_name = get_pipe_name();
+    if (!pipe_name)
+    {
+        ERR("failed to get pipe name\n");
+        goto done;
+    }
+
+    pipe = CreateNamedPipeW(pipe_name, PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED,
+                            PIPE_TYPE_BYTE, PIPE_UNLIMITED_INSTANCES, 1, 1, 0, NULL);
+    if (!pipe)
+    {
+        ERR("failed to create named pipe: %u\n", GetLastError());
+        goto done;
+    }
+
+    event = CreateEventW(NULL, TRUE, FALSE, NULL);
+    if (!event)
+    {
+        ERR("failed to create event: %d\n", GetLastError());
+        goto done;
+    }
+
+    clipboard_thread_id = GetCurrentThreadId();
+    NtUserAddClipboardFormatListener(clipboard_hwnd);
+    register_builtin_formats();
+    grab_win32_clipboard();
+
+    TRACE("clipboard thread %04x running\n", GetCurrentThreadId());
+    while (1)
+    {
+        DWORD result;
+
+        if (need_connect)
+        {
+            pending = FALSE;
+            memset(&overlapped, 0, sizeof(overlapped));
+            overlapped.hEvent = event;
+            if (ConnectNamedPipe(pipe, &overlapped))
+            {
+                ERR("asynchronous ConnectNamedPipe unexpectedly returned true: %d\n", GetLastError());
+                ResetEvent(event);
+            }
+            else
+            {
+                result = GetLastError();
+                switch (result)
+                {
+                    case ERROR_PIPE_CONNECTED:
+                    case ERROR_NO_DATA:
+                        SetEvent(event);
+                        need_connect = FALSE;
+                        break;
+                    case ERROR_IO_PENDING:
+                        need_connect = FALSE;
+                        pending = TRUE;
+                        break;
+                    default:
+                        ERR("failed to initiate pipe connection: %d\n", result);
+                        break;
+                }
+            }
+        }
+
+        result = MsgWaitForMultipleObjectsEx(1, &event, INFINITE, QS_ALLINPUT, MWMO_ALERTABLE | MWMO_INPUTAVAILABLE);
+        switch (result)
+        {
+            case WAIT_OBJECT_0:
+            {
+                DWORD written;
+
+                if (pending && !GetOverlappedResult(pipe, &overlapped, &written, FALSE))
+                    ERR("failed to connect pipe: %d\n", GetLastError());
+
+                update_clipboard();
+                DisconnectNamedPipe(pipe);
+                need_connect = TRUE;
+                break;
+            }
+            case WAIT_OBJECT_0 + 1:
+                while (PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE))
+                {
+                    if (msg.message == WM_QUIT)
+                        goto done;
+                    DispatchMessageW(&msg);
+                }
+                break;
+            case WAIT_IO_COMPLETION:
+                break;
+            default:
+                ERR("failed to wait for connection or input: %d\n", GetLastError());
+                break;
+        }
+    }
+
+done:
+    if (event) CloseHandle(event);
+    if (pipe) CloseHandle(pipe);
+    macdrv_destroy_cocoa_window(clipboard_cocoa_window);
+    DestroyWindow(clipboard_hwnd);
+    return 0;
 }
 
 
@@ -1648,35 +1807,127 @@ LRESULT macdrv_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 /**************************************************************************
  *              macdrv_UpdateClipboard
  */
-void macdrv_UpdateClipboard(void)
+void CDECL macdrv_UpdateClipboard(void)
 {
     static ULONG last_update;
-    static HWND clipboard_manager;
-    ULONG now;
-    DWORD_PTR ret;
+    ULONG now, end;
+    const WCHAR* pipe_name;
+    HANDLE pipe;
+    BYTE dummy;
+    DWORD count;
+    OVERLAPPED overlapped = { 0 };
+    BOOL canceled = FALSE;
 
     if (GetCurrentThreadId() == clipboard_thread_id) return;
 
     TRACE("\n");
 
-    now = NtGetTickCount();
-    if (last_update && (int)(now - last_update) <= CLIPBOARD_UPDATE_DELAY) return;
+    now = GetTickCount();
+    if ((int)(now - last_update) <= CLIPBOARD_UPDATE_DELAY) return;
+    last_update = now;
+
+    if (!(pipe_name = get_pipe_name())) return;
+    pipe = CreateFileW(pipe_name, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,
+                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
+    if (pipe == INVALID_HANDLE_VALUE)
+    {
+        WARN("failed to open pipe to clipboard manager: %d\n", GetLastError());
+        return;
+    }
 
-    if (!NtUserIsWindow(clipboard_manager))
+    overlapped.hEvent = CreateEventW(NULL, TRUE, FALSE, NULL);
+    if (!overlapped.hEvent)
+    {
+        ERR("failed to create event: %d\n", GetLastError());
+        goto done;
+    }
+
+    /* We expect the read to fail because the server just closes our connection.  This
+       is just waiting for that close to happen. */
+    if (ReadFile(pipe, &dummy, sizeof(dummy), NULL, &overlapped))
+    {
+        WARN("asynchronous ReadFile unexpectedly returned true: %d\n", GetLastError());
+        goto done;
+    }
+    else
     {
-        UNICODE_STRING str;
-        RtlInitUnicodeString(&str, clipboard_classname);
-        clipboard_manager = NtUserFindWindowEx(NULL, NULL, &str, NULL, 0);
-        if (!clipboard_manager)
+        DWORD error = GetLastError();
+        if (error == ERROR_PIPE_NOT_CONNECTED || error == ERROR_BROKEN_PIPE)
         {
-            ERR("clipboard manager not found\n");
-            return;
+            /* The server accepted, handled, and closed our connection before we
+               attempted the read, which is fine. */
+            goto done;
+        }
+        else if (error != ERROR_IO_PENDING)
+        {
+            ERR("failed to initiate read from pipe: %d\n", error);
+            goto done;
         }
     }
 
-    send_message_timeout(clipboard_manager, WM_USER, 0, 0,
-                         SMTO_ABORTIFHUNG, 5000, &ret);
-    last_update = now;
+    end = now + 500;
+    while (1)
+    {
+        DWORD result, timeout;
+
+        if (canceled)
+            timeout = INFINITE;
+        else
+        {
+            now = GetTickCount();
+            timeout = end - now;
+            if ((int)timeout < 0)
+                timeout = 0;
+        }
+
+        result = MsgWaitForMultipleObjectsEx(1, &overlapped.hEvent, timeout, QS_SENDMESSAGE, MWMO_ALERTABLE);
+        switch (result)
+        {
+            case WAIT_OBJECT_0:
+            {
+                if (GetOverlappedResult(pipe, &overlapped, &count, FALSE))
+                    WARN("unexpectedly succeeded in reading from pipe\n");
+                else
+                {
+                    result = GetLastError();
+                    if (result != ERROR_BROKEN_PIPE && result != ERROR_OPERATION_ABORTED &&
+                        result != ERROR_HANDLES_CLOSED)
+                        WARN("failed to read from pipe: %d\n", result);
+                }
+
+                goto done;
+            }
+            case WAIT_OBJECT_0 + 1:
+            {
+                MSG msg;
+                while (PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE | PM_QS_SENDMESSAGE))
+                    DispatchMessageW(&msg);
+                break;
+            }
+            case WAIT_IO_COMPLETION:
+                break;
+            case WAIT_TIMEOUT:
+                WARN("timed out waiting for read\n");
+                CancelIoEx(pipe, &overlapped);
+                canceled = TRUE;
+                break;
+            default:
+                if (canceled)
+                {
+                    ERR("failed to wait for cancel: %d\n", GetLastError());
+                    goto done;
+                }
+
+                ERR("failed to wait for read: %d\n", GetLastError());
+                CancelIoEx(pipe, &overlapped);
+                canceled = TRUE;
+                break;
+        }
+    }
+
+done:
+    if (overlapped.hEvent) CloseHandle(overlapped.hEvent);
+    CloseHandle(pipe);
 }
 
 
@@ -1750,22 +2001,13 @@ void macdrv_lost_pasteboard_ownership(HWND hwnd)
 
 
 /**************************************************************************
- *              macdrv_dnd_release
+ *              macdrv_init_clipboard
  */
-NTSTATUS macdrv_dnd_release(void *arg)
+void macdrv_init_clipboard(void)
 {
-    UINT64 handle = *(UINT64 *)arg;
-    CFRelease(pasteboard_from_handle(handle));
-    return 0;
-}
-
+    DWORD id;
+    HANDLE handle = CreateThread(NULL, 0, clipboard_thread, NULL, 0, &id);
 
-/**************************************************************************
- *              macdrv_dnd_retain
- */
-NTSTATUS macdrv_dnd_retain(void *arg)
-{
-    UINT64 handle = *(UINT64 *)arg;
-    CFRetain(pasteboard_from_handle(handle));
-    return 0;
+    if (handle) CloseHandle(handle);
+    else ERR("failed to create clipboard thread\n");
 }
diff --git a/dlls/winemac.drv/cocoa_app.m b/dlls/winemac.drv/cocoa_app.m
index b13bc678c6d..b5a3059382e 100644
--- a/dlls/winemac.drv/cocoa_app.m
+++ b/dlls/winemac.drv/cocoa_app.m
@@ -1188,7 +1188,7 @@ - (BOOL) setCursorPosition:(CGPoint)pos
             [eventQueuesLock lock];
             for (queue in eventQueues)
             {
-                [queue discardEventsMatchingMask:event_mask_for_type(MOUSE_MOVED_RELATIVE) |
+                [queue discardEventsMatchingMask:event_mask_for_type(MOUSE_MOVED) |
                                                  event_mask_for_type(MOUSE_MOVED_ABSOLUTE)
                                        forWindow:nil];
                 [queue resetMouseEventPositions:pos];
@@ -1444,7 +1444,7 @@ - (void) handleMouseMove:(NSEvent*)anEvent
                 mouseMoveDeltaX += [anEvent deltaX];
                 mouseMoveDeltaY += [anEvent deltaY];
 
-                event = macdrv_create_event(MOUSE_MOVED_RELATIVE, targetWindow);
+                event = macdrv_create_event(MOUSE_MOVED, targetWindow);
                 event->mouse_moved.x = mouseMoveDeltaX * scale;
                 event->mouse_moved.y = mouseMoveDeltaY * scale;
 
diff --git a/dlls/winemac.drv/cocoa_event.m b/dlls/winemac.drv/cocoa_event.m
index 24f69b17a0a..868ce5a7813 100644
--- a/dlls/winemac.drv/cocoa_event.m
+++ b/dlls/winemac.drv/cocoa_event.m
@@ -204,17 +204,17 @@ - (void) postEventObject:(MacDrvEvent*)event
         }];
         [events removeObjectsAtIndexes:indexes];
 
-        if ((event->event->type == MOUSE_MOVED_RELATIVE ||
+        if ((event->event->type == MOUSE_MOVED ||
              event->event->type == MOUSE_MOVED_ABSOLUTE) &&
             event->event->deliver == INT_MAX &&
             (lastEvent = [events lastObject]) &&
-            (lastEvent->event->type == MOUSE_MOVED_RELATIVE ||
+            (lastEvent->event->type == MOUSE_MOVED ||
              lastEvent->event->type == MOUSE_MOVED_ABSOLUTE) &&
             lastEvent->event->deliver == INT_MAX &&
             lastEvent->event->window == event->event->window &&
             lastEvent->event->mouse_moved.drag == event->event->mouse_moved.drag)
         {
-            if (event->event->type == MOUSE_MOVED_RELATIVE)
+            if (event->event->type == MOUSE_MOVED)
             {
                 lastEvent->event->mouse_moved.x += event->event->mouse_moved.x;
                 lastEvent->event->mouse_moved.y += event->event->mouse_moved.y;
diff --git a/dlls/winemac.drv/display.c b/dlls/winemac.drv/display.c
index 19b9a9cdd9d..f20761f642e 100644
--- a/dlls/winemac.drv/display.c
+++ b/dlls/winemac.drv/display.c
@@ -19,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include "macdrv.h"
@@ -31,6 +27,7 @@
 #include "ddrawi.h"
 #define WIN32_NO_STATUS
 #include "winternl.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(display);
 
@@ -47,7 +44,7 @@ struct display_mode_descriptor
 };
 
 
-BOOL macdrv_EnumDisplaySettingsEx(LPCWSTR devname, DWORD mode, LPDEVMODEW devmode, DWORD flags);
+BOOL CDECL macdrv_EnumDisplaySettingsEx(LPCWSTR devname, DWORD mode, LPDEVMODEW devmode, DWORD flags);
 
 static const WCHAR initial_mode_keyW[] = {'I','n','i','t','i','a','l',' ','D','i','s','p','l','a','y',
     ' ','M','o','d','e'};
@@ -809,7 +806,7 @@ static BOOL get_primary_adapter(WCHAR *name)
     DWORD i;
 
     dd.cb = sizeof(dd);
-    for (i = 0; !NtUserEnumDisplayDevices(NULL, i, &dd, 0); ++i)
+    for (i = 0; EnumDisplayDevicesW(NULL, i, &dd, 0); ++i)
     {
         if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
         {
@@ -834,8 +831,8 @@ static BOOL is_detached_mode(const DEVMODEW *mode)
  *              ChangeDisplaySettingsEx  (MACDRV.@)
  *
  */
-LONG macdrv_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
-                                    HWND hwnd, DWORD flags, LPVOID lpvoid)
+LONG CDECL macdrv_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
+                                          HWND hwnd, DWORD flags, LPVOID lpvoid)
 {
     WCHAR primary_adapter[CCHDEVICENAME];
     LONG ret = DISP_CHANGE_BADMODE;
@@ -859,11 +856,9 @@ LONG macdrv_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
 
     if (!devname && !devmode)
     {
-        UNICODE_STRING str;
         memset(&default_mode, 0, sizeof(default_mode));
         default_mode.dmSize = sizeof(default_mode);
-        RtlInitUnicodeString(&str, primary_adapter);
-        if (!NtUserEnumDisplaySettings(&str, ENUM_REGISTRY_SETTINGS, &default_mode, 0))
+        if (!EnumDisplaySettingsExW(primary_adapter, ENUM_REGISTRY_SETTINGS, &default_mode, 0))
         {
             ERR("Default mode not found for %s!\n", wine_dbgstr_w(primary_adapter));
             return DISP_CHANGE_BADMODE;
@@ -995,7 +990,7 @@ better:
         }
         else if (flags & (CDS_TEST | CDS_NORESET))
             ret = DISP_CHANGE_SUCCESSFUL;
-        else if (wcsicmp(primary_adapter, devname))
+        else if (lstrcmpiW(primary_adapter, devname))
         {
             FIXME("Changing non-primary adapter settings is currently unsupported.\n");
             ret = DISP_CHANGE_SUCCESSFUL;
@@ -1014,7 +1009,7 @@ better:
                 height *= 2;
             }
 
-            send_message(NtUserGetDesktopWindow(), WM_MACDRV_UPDATE_DESKTOP_RECT, mode_bpp,
+            SendMessageW(GetDesktopWindow(), WM_MACDRV_UPDATE_DESKTOP_RECT, mode_bpp,
                          MAKELPARAM(width, height));
             ret = DISP_CHANGE_SUCCESSFUL;
         }
@@ -1042,7 +1037,8 @@ better:
  *              EnumDisplaySettingsEx  (MACDRV.@)
  *
  */
-BOOL macdrv_EnumDisplaySettingsEx(LPCWSTR devname, DWORD mode, DEVMODEW *devmode, DWORD flags)
+BOOL CDECL macdrv_EnumDisplaySettingsEx(LPCWSTR devname, DWORD mode,
+                                        LPDEVMODEW devmode, DWORD flags)
 {
     static const WCHAR dev_name[CCHDEVICENAME] =
         { 'W','i','n','e',' ','M','a','c',' ','d','r','i','v','e','r',0 };
@@ -1243,7 +1239,7 @@ failed:
 /***********************************************************************
  *              GetDeviceGammaRamp (MACDRV.@)
  */
-BOOL macdrv_GetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp)
+BOOL CDECL macdrv_GetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp)
 {
     BOOL ret = FALSE;
     DDGAMMARAMP *r = ramp;
@@ -1327,7 +1323,7 @@ done:
 /***********************************************************************
  *              SetDeviceGammaRamp (MACDRV.@)
  */
-BOOL macdrv_SetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp)
+BOOL CDECL macdrv_SetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp)
 {
     DDGAMMARAMP *r = ramp;
     struct macdrv_display *displays;
@@ -1383,19 +1379,16 @@ static void init_registry_display_settings(void)
 {
     DEVMODEW dm = {.dmSize = sizeof(dm)};
     DISPLAY_DEVICEW dd = {sizeof(dd)};
-    UNICODE_STRING str;
     DWORD i = 0;
     LONG ret;
 
-    while (!NtUserEnumDisplayDevices(NULL, i++, &dd, 0))
+    while (EnumDisplayDevicesW(NULL, i++, &dd, 0))
     {
-        RtlInitUnicodeString(&str, dd.DeviceName);
-
         /* Skip if the device already has registry display settings */
-        if (NtUserEnumDisplaySettings(&str, ENUM_REGISTRY_SETTINGS, &dm, 0))
+        if (EnumDisplaySettingsExW(dd.DeviceName, ENUM_REGISTRY_SETTINGS, &dm, 0))
             continue;
 
-        if (!NtUserEnumDisplaySettings(&str, ENUM_CURRENT_SETTINGS, &dm, 0))
+        if (!EnumDisplaySettingsExW(dd.DeviceName, ENUM_CURRENT_SETTINGS, &dm, 0))
         {
             ERR("Failed to query current display settings for %s.\n", wine_dbgstr_w(dd.DeviceName));
             continue;
@@ -1405,8 +1398,8 @@ static void init_registry_display_settings(void)
               wine_dbgstr_w(dd.DeviceName), dm.dmPelsWidth, dm.dmPelsHeight, dm.dmBitsPerPel,
               dm.dmDisplayFrequency, dm.dmPosition.x, dm.dmPosition.y);
 
-        ret = NtUserChangeDisplaySettings(&str, &dm, NULL,
-                                          CDS_GLOBAL | CDS_NORESET | CDS_UPDATEREGISTRY, NULL);
+        ret = ChangeDisplaySettingsExW(dd.DeviceName, &dm, NULL,
+                                       CDS_GLOBAL | CDS_NORESET | CDS_UPDATEREGISTRY, NULL);
         if (ret != DISP_CHANGE_SUCCESSFUL)
             ERR("Failed to save registry display settings for %s, returned %d.\n",
                 wine_dbgstr_w(dd.DeviceName), ret);
@@ -1420,7 +1413,7 @@ static void init_registry_display_settings(void)
  */
 void macdrv_displays_changed(const macdrv_event *event)
 {
-    HWND hwnd = NtUserGetDesktopWindow();
+    HWND hwnd = GetDesktopWindow();
 
     /* A system display change will get delivered to all GUI-attached threads,
        so the desktop-window-owning thread will get it and all others should
@@ -1428,7 +1421,7 @@ void macdrv_displays_changed(const macdrv_event *event)
        will only get delivered to the activated process.  So, it needs to
        process it (by sending it to the desktop window). */
     if (event->displays_changed.activating ||
-        NtUserGetWindowThread(hwnd, NULL) == GetCurrentThreadId())
+        GetWindowThreadProcessId(hwnd, NULL) == GetCurrentThreadId())
     {
         CGDirectDisplayID mainDisplay = CGMainDisplayID();
         CGDisplayModeRef mode = CGDisplayCopyDisplayMode(mainDisplay);
@@ -1450,15 +1443,15 @@ void macdrv_displays_changed(const macdrv_event *event)
             height *= 2;
         }
 
-        send_message(hwnd, WM_MACDRV_UPDATE_DESKTOP_RECT, mode_bpp,
+        SendMessageW(hwnd, WM_MACDRV_UPDATE_DESKTOP_RECT, mode_bpp,
                      MAKELPARAM(width, height));
     }
 }
 
 static BOOL force_display_devices_refresh;
 
-void macdrv_UpdateDisplayDevices( const struct gdi_device_manager *device_manager,
-                                  BOOL force, void *param )
+void CDECL macdrv_UpdateDisplayDevices( const struct gdi_device_manager *device_manager,
+                                        BOOL force, void *param )
 {
     struct macdrv_adapter *adapters, *adapter;
     struct macdrv_monitor *monitors, *monitor;
diff --git a/dlls/winemac.drv/dllmain.c b/dlls/winemac.drv/dllmain.c
deleted file mode 100644
index 0618ec83228..00000000000
--- a/dlls/winemac.drv/dllmain.c
+++ /dev/null
@@ -1,440 +0,0 @@
-/*
- * winemac.drv entry points
- *
- * Copyright 2022 Jacek Caban for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include "macdrv_dll.h"
-#include "macdrv_res.h"
-#include "shellapi.h"
-#include "wine/debug.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(macdrv);
-
-
-HMODULE macdrv_module = 0;
-static unixlib_handle_t macdrv_handle;
-NTSTATUS (CDECL *macdrv_unix_call)(enum macdrv_funcs code, void *params);
-
-struct quit_info {
-    HWND               *wins;
-    UINT                capacity;
-    UINT                count;
-    UINT                done;
-    DWORD               flags;
-    BOOL                result;
-    BOOL                replied;
-};
-
-
-static BOOL CALLBACK get_process_windows(HWND hwnd, LPARAM lp)
-{
-    struct quit_info *qi = (struct quit_info*)lp;
-    DWORD pid;
-
-    NtUserGetWindowThread(hwnd, &pid);
-    if (pid == GetCurrentProcessId())
-    {
-        if (qi->count >= qi->capacity)
-        {
-            UINT new_cap = qi->capacity * 2;
-            HWND *new_wins = HeapReAlloc(GetProcessHeap(), 0, qi->wins, new_cap * sizeof(*qi->wins));
-            if (!new_wins) return FALSE;
-            qi->wins = new_wins;
-            qi->capacity = new_cap;
-        }
-
-        qi->wins[qi->count++] = hwnd;
-    }
-
-    return TRUE;
-}
-
-#include "pshpack1.h"
-
-typedef struct
-{
-    BYTE bWidth;
-    BYTE bHeight;
-    BYTE bColorCount;
-    BYTE bReserved;
-    WORD wPlanes;
-    WORD wBitCount;
-    DWORD dwBytesInRes;
-    WORD nID;
-} GRPICONDIRENTRY;
-
-typedef struct
-{
-    WORD idReserved;
-    WORD idType;
-    WORD idCount;
-    GRPICONDIRENTRY idEntries[1];
-} GRPICONDIR;
-
-#include "poppack.h"
-
-static void quit_reply(int reply)
-{
-    struct quit_result_params params = { .result = reply };
-    MACDRV_CALL(quit_result, &params);
-}
-
-
-static void CALLBACK quit_callback(HWND hwnd, UINT msg, ULONG_PTR data, LRESULT result)
-{
-    struct quit_info *qi = (struct quit_info*)data;
-
-    qi->done++;
-
-    if (msg == WM_QUERYENDSESSION)
-    {
-        TRACE("got WM_QUERYENDSESSION result %ld from win %p (%u of %u done)\n", result,
-              hwnd, qi->done, qi->count);
-
-        if (!result && !IsWindow(hwnd))
-        {
-            TRACE("win %p no longer exists; ignoring apparent refusal\n", hwnd);
-            result = TRUE;
-        }
-
-        if (!result && qi->result)
-        {
-            qi->result = FALSE;
-
-            /* On the first FALSE from WM_QUERYENDSESSION, we already know the
-               ultimate reply.  Might as well tell Cocoa now. */
-            if (!qi->replied)
-            {
-                qi->replied = TRUE;
-                TRACE("giving quit reply %d\n", qi->result);
-                quit_reply(qi->result);
-            }
-        }
-
-        if (qi->done >= qi->count)
-        {
-            UINT i;
-
-            qi->done = 0;
-            for (i = 0; i < qi->count; i++)
-            {
-                TRACE("sending WM_ENDSESSION to win %p result %d flags 0x%08x\n", qi->wins[i],
-                      qi->result, qi->flags);
-                if (!SendMessageCallbackW(qi->wins[i], WM_ENDSESSION, qi->result, qi->flags,
-                                          quit_callback, (ULONG_PTR)qi))
-                {
-                    WARN("failed to send WM_ENDSESSION to win %p; error 0x%08x\n",
-                         qi->wins[i], GetLastError());
-                    quit_callback(qi->wins[i], WM_ENDSESSION, (ULONG_PTR)qi, 0);
-                }
-            }
-        }
-    }
-    else /* WM_ENDSESSION */
-    {
-        TRACE("finished WM_ENDSESSION for win %p (%u of %u done)\n", hwnd, qi->done, qi->count);
-
-        if (qi->done >= qi->count)
-        {
-            if (!qi->replied)
-            {
-                TRACE("giving quit reply %d\n", qi->result);
-                quit_reply(qi->result);
-            }
-
-            TRACE("%sterminating process\n", qi->result ? "" : "not ");
-            if (qi->result)
-                TerminateProcess(GetCurrentProcess(), 0);
-
-            HeapFree(GetProcessHeap(), 0, qi->wins);
-            HeapFree(GetProcessHeap(), 0, qi);
-        }
-    }
-}
-
-
-/***********************************************************************
- *              macdrv_app_quit_request
- */
-NTSTATUS WINAPI macdrv_app_quit_request(void *arg, ULONG size)
-{
-    struct app_quit_request_params *params = arg;
-    struct quit_info *qi;
-    UINT i;
-
-    qi = HeapAlloc(GetProcessHeap(), 0, sizeof(*qi));
-    if (!qi)
-        goto fail;
-
-    qi->capacity = 32;
-    qi->wins = HeapAlloc(GetProcessHeap(), 0, qi->capacity * sizeof(*qi->wins));
-    qi->count = qi->done = 0;
-
-    if (!qi->wins || !EnumWindows(get_process_windows, (LPARAM)qi))
-        goto fail;
-
-    qi->flags = params->flags;
-    qi->result = TRUE;
-    qi->replied = FALSE;
-
-    for (i = 0; i < qi->count; i++)
-    {
-        TRACE("sending WM_QUERYENDSESSION to win %p\n", qi->wins[i]);
-        if (!SendMessageCallbackW(qi->wins[i], WM_QUERYENDSESSION, 0, qi->flags,
-                                  quit_callback, (ULONG_PTR)qi))
-        {
-            DWORD error = GetLastError();
-            BOOL invalid = (error == ERROR_INVALID_WINDOW_HANDLE);
-            if (invalid)
-                TRACE("failed to send WM_QUERYENDSESSION to win %p because it's invalid; assuming success\n",
-                     qi->wins[i]);
-            else
-                WARN("failed to send WM_QUERYENDSESSION to win %p; error 0x%08x; assuming refusal\n",
-                     qi->wins[i], error);
-            quit_callback(qi->wins[i], WM_QUERYENDSESSION, (ULONG_PTR)qi, invalid);
-        }
-    }
-
-    /* quit_callback() will clean up qi */
-    return 0;
-
-fail:
-    WARN("failed to allocate window list\n");
-    if (qi)
-    {
-        HeapFree(GetProcessHeap(), 0, qi->wins);
-        HeapFree(GetProcessHeap(), 0, qi);
-    }
-    quit_reply(FALSE);
-    return 0;
-}
-
-/***********************************************************************
- *              get_first_resource
- *
- * Helper for create_app_icon_images().  Enum proc for EnumResourceNamesW()
- * which just gets the handle for the first resource and stops further
- * enumeration.
- */
-static BOOL CALLBACK get_first_resource(HMODULE module, LPCWSTR type, LPWSTR name, LONG_PTR lparam)
-{
-    HRSRC *res_info = (HRSRC*)lparam;
-
-    *res_info = FindResourceW(module, name, (LPCWSTR)RT_GROUP_ICON);
-    return FALSE;
-}
-
-
-/***********************************************************************
- *              macdrv_app_icon
- */
-static NTSTATUS WINAPI macdrv_app_icon(void *arg, ULONG size)
-{
-    struct app_icon_params *params = arg;
-    struct app_icon_result *result = params->result;
-    HRSRC res_info;
-    HGLOBAL res_data;
-    GRPICONDIR *icon_dir;
-    int i;
-
-    TRACE("()\n");
-
-    result->count = 0;
-
-    res_info = NULL;
-    EnumResourceNamesW(NULL, (LPCWSTR)RT_GROUP_ICON, get_first_resource, (LONG_PTR)&res_info);
-    if (!res_info)
-    {
-        WARN("found no RT_GROUP_ICON resource\n");
-        return 0;
-    }
-
-    if (!(res_data = LoadResource(NULL, res_info)))
-    {
-        WARN("failed to load RT_GROUP_ICON resource\n");
-        return 0;
-    }
-
-    if (!(icon_dir = LockResource(res_data)))
-    {
-        WARN("failed to lock RT_GROUP_ICON resource\n");
-        goto cleanup;
-    }
-
-    for (i = 0; i < icon_dir->idCount && result->count < ARRAYSIZE(result->entries); i++)
-    {
-        struct app_icon_entry *entry = &result->entries[result->count];
-        int width = icon_dir->idEntries[i].bWidth;
-        int height = icon_dir->idEntries[i].bHeight;
-        BOOL found_better_bpp = FALSE;
-        int j;
-        LPCWSTR name;
-        HGLOBAL icon_res_data;
-        BYTE *icon_bits;
-
-        if (!width) width = 256;
-        if (!height) height = 256;
-
-        /* If there's another icon at the same size but with better
-           color depth, skip this one.  We end up making CGImages that
-           are all 32 bits per pixel, so Cocoa doesn't get the original
-           color depth info to pick the best representation itself. */
-        for (j = 0; j < icon_dir->idCount; j++)
-        {
-            int jwidth = icon_dir->idEntries[j].bWidth;
-            int jheight = icon_dir->idEntries[j].bHeight;
-
-            if (!jwidth) jwidth = 256;
-            if (!jheight) jheight = 256;
-
-            if (j != i && jwidth == width && jheight == height &&
-                icon_dir->idEntries[j].wBitCount > icon_dir->idEntries[i].wBitCount)
-            {
-                found_better_bpp = TRUE;
-                break;
-            }
-        }
-
-        if (found_better_bpp) continue;
-
-        name = MAKEINTRESOURCEW(icon_dir->idEntries[i].nID);
-        res_info = FindResourceW(NULL, name, (LPCWSTR)RT_ICON);
-        if (!res_info)
-        {
-            WARN("failed to find RT_ICON resource %d with ID %hd\n", i, icon_dir->idEntries[i].nID);
-            continue;
-        }
-
-        icon_res_data = LoadResource(NULL, res_info);
-        if (!icon_res_data)
-        {
-            WARN("failed to load icon %d with ID %hd\n", i, icon_dir->idEntries[i].nID);
-            continue;
-        }
-
-        icon_bits = LockResource(icon_res_data);
-        if (icon_bits)
-        {
-            static const BYTE png_magic[] = { 0x89, 0x50, 0x4e, 0x47 };
-
-            entry->width = width;
-            entry->height = height;
-            entry->size = icon_dir->idEntries[i].dwBytesInRes;
-
-            if (!memcmp(icon_bits, png_magic, sizeof(png_magic)))
-            {
-                entry->png = icon_bits;
-                entry->icon = 0;
-                result->count++;
-            }
-            else
-            {
-                entry->icon = CreateIconFromResourceEx(icon_bits, icon_dir->idEntries[i].dwBytesInRes,
-                                                       TRUE, 0x00030000, width, height, 0);
-                if (entry->icon)
-                {
-                    entry->png = NULL;
-                    result->count++;
-                }
-                else
-                    WARN("failed to create icon %d from resource with ID %hd\n", i, icon_dir->idEntries[i].nID);
-            }
-        }
-        else
-            WARN("failed to lock RT_ICON resource %d with ID %hd\n", i, icon_dir->idEntries[i].nID);
-
-        FreeResource(icon_res_data);
-    }
-
-cleanup:
-    FreeResource(res_data);
-
-    return 0;
-}
-
-typedef NTSTATUS (WINAPI *kernel_callback)(void *params, ULONG size);
-static const kernel_callback kernel_callbacks[] =
-{
-    macdrv_app_icon,
-    macdrv_app_quit_request,
-    macdrv_dnd_query_drag,
-    macdrv_dnd_query_drop,
-    macdrv_dnd_query_exited,
-    macdrv_ime_query_char_rect,
-    macdrv_ime_set_text,
-};
-
-C_ASSERT(NtUserDriverCallbackFirst + ARRAYSIZE(kernel_callbacks) == client_func_last);
-
-
-static BOOL process_attach(void)
-{
-    struct init_params params;
-    void **callback_table;
-
-    struct localized_string *str;
-    struct localized_string strings[] = {
-        { .id = STRING_MENU_WINE },
-        { .id = STRING_MENU_ITEM_HIDE_APPNAME },
-        { .id = STRING_MENU_ITEM_HIDE },
-        { .id = STRING_MENU_ITEM_HIDE_OTHERS },
-        { .id = STRING_MENU_ITEM_SHOW_ALL },
-        { .id = STRING_MENU_ITEM_QUIT_APPNAME },
-        { .id = STRING_MENU_ITEM_QUIT },
-
-        { .id = STRING_MENU_WINDOW },
-        { .id = STRING_MENU_ITEM_MINIMIZE },
-        { .id = STRING_MENU_ITEM_ZOOM },
-        { .id = STRING_MENU_ITEM_ENTER_FULL_SCREEN },
-        { .id = STRING_MENU_ITEM_BRING_ALL_TO_FRONT },
-
-        { .id = 0 }
-    };
-
-    if (NtQueryVirtualMemory(GetCurrentProcess(), macdrv_module, MemoryWineUnixFuncs,
-                             &macdrv_handle, sizeof(macdrv_handle), NULL))
-        return FALSE;
-
-    for (str = strings; str->id; str++)
-        str->len = LoadStringW(macdrv_module, str->id, (WCHAR *)&str->str, 0);
-    params.strings = strings;
-
-    params.pNtWaitForMultipleObjects = NtWaitForMultipleObjects;
-    if (__wine_unix_call(macdrv_handle, unix_init, &params)) return FALSE;
-
-    callback_table = NtCurrentTeb()->Peb->KernelCallbackTable;
-    memcpy( callback_table + NtUserDriverCallbackFirst, kernel_callbacks, sizeof(kernel_callbacks) );
-
-    macdrv_unix_call = params.unix_call;
-    return TRUE;
-}
-
-BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, void *reserved)
-{
-    if (reason != DLL_PROCESS_ATTACH) return TRUE;
-
-    DisableThreadLibraryCalls(instance);
-    macdrv_module = instance;
-    return process_attach();
-}
-
-int CDECL wine_notify_icon(DWORD msg, NOTIFYICONDATAW *data)
-{
-    struct notify_icon_params params = { .msg = msg, .data = data };
-    return MACDRV_CALL(notify_icon, &params);
-}
diff --git a/dlls/winemac.drv/dragdrop.c b/dlls/winemac.drv/dragdrop.c
index afd4fb0a6d2..a07b66ac14a 100644
--- a/dlls/winemac.drv/dragdrop.c
+++ b/dlls/winemac.drv/dragdrop.c
@@ -20,17 +20,16 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
 #define NONAMELESSUNION
 
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "macdrv_dll.h"
+#include "macdrv.h"
 
 #define COBJMACROS
 #include "objidl.h"
 #include "shellapi.h"
 #include "shlobj.h"
-#include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dragdrop);
 
@@ -43,74 +42,16 @@ typedef struct
 {
     IDataObject IDataObject_iface;
     LONG        ref;
-    UINT64      pasteboard;
+    CFTypeRef   pasteboard;
 } DragDropDataObject;
 
 
-/**************************************************************************
- *              debugstr_format
- */
-static const char *debugstr_format(UINT id)
-{
-    WCHAR buffer[256];
-
-    if (GetClipboardFormatNameW(id, buffer, 256))
-        return wine_dbg_sprintf("0x%04x %s", id, debugstr_w(buffer));
-
-    switch (id)
-    {
-#define BUILTIN(id) case id: return #id;
-    BUILTIN(CF_TEXT)
-    BUILTIN(CF_BITMAP)
-    BUILTIN(CF_METAFILEPICT)
-    BUILTIN(CF_SYLK)
-    BUILTIN(CF_DIF)
-    BUILTIN(CF_TIFF)
-    BUILTIN(CF_OEMTEXT)
-    BUILTIN(CF_DIB)
-    BUILTIN(CF_PALETTE)
-    BUILTIN(CF_PENDATA)
-    BUILTIN(CF_RIFF)
-    BUILTIN(CF_WAVE)
-    BUILTIN(CF_UNICODETEXT)
-    BUILTIN(CF_ENHMETAFILE)
-    BUILTIN(CF_HDROP)
-    BUILTIN(CF_LOCALE)
-    BUILTIN(CF_DIBV5)
-    BUILTIN(CF_OWNERDISPLAY)
-    BUILTIN(CF_DSPTEXT)
-    BUILTIN(CF_DSPBITMAP)
-    BUILTIN(CF_DSPMETAFILEPICT)
-    BUILTIN(CF_DSPENHMETAFILE)
-#undef BUILTIN
-    default: return wine_dbg_sprintf("0x%04x", id);
-    }
-}
-
 static inline DragDropDataObject *impl_from_IDataObject(IDataObject *iface)
 {
     return CONTAINING_RECORD(iface, DragDropDataObject, IDataObject_iface);
 }
 
 
-static HANDLE get_pasteboard_data(UINT64 pasteboard, UINT desired_format)
-{
-    struct dnd_get_data_params params = { .handle = pasteboard, .format = desired_format, .size = 2048 };
-    HANDLE handle;
-    NTSTATUS status;
-
-    for (;;)
-    {
-        if (!(handle = GlobalAlloc(GMEM_FIXED, params.size))) return 0;
-        params.data = GlobalLock(handle);
-        status = MACDRV_CALL(dnd_get_data, &params);
-        GlobalUnlock(handle);
-        if (!status) return GlobalReAlloc(handle, params.size, 0);
-        GlobalFree(handle);
-        if (status != STATUS_BUFFER_OVERFLOW) return 0;
-    }
-}
-
 static HRESULT WINAPI dddo_QueryInterface(IDataObject* iface, REFIID riid, LPVOID *ppvObj)
 {
     DragDropDataObject *This = impl_from_IDataObject(iface);
@@ -150,7 +91,7 @@ static ULONG WINAPI dddo_Release(IDataObject* iface)
         return refCount;
 
     TRACE("-- destroying DragDropDataObject (%p)\n", This);
-    MACDRV_CALL(dnd_release, &This->pasteboard);
+    CFRelease(This->pasteboard);
     HeapFree(GetProcessHeap(), 0, This);
     return 0;
 }
@@ -167,7 +108,7 @@ static HRESULT WINAPI dddo_GetData(IDataObject* iface, FORMATETC* formatEtc, STG
     if (SUCCEEDED(hr))
     {
         medium->tymed = TYMED_HGLOBAL;
-        medium->u.hGlobal = get_pasteboard_data(This->pasteboard, formatEtc->cfFormat);
+        medium->u.hGlobal = macdrv_get_pasteboard_data(This->pasteboard, formatEtc->cfFormat);
         medium->pUnkForRelease = NULL;
         hr = medium->u.hGlobal ? S_OK : E_OUTOFMEMORY;
     }
@@ -187,7 +128,6 @@ static HRESULT WINAPI dddo_GetDataHere(IDataObject* iface, FORMATETC* formatEtc,
 static HRESULT WINAPI dddo_QueryGetData(IDataObject* iface, FORMATETC* formatEtc)
 {
     DragDropDataObject *This = impl_from_IDataObject(iface);
-    struct dnd_have_format_params params;
     HRESULT hr = DV_E_FORMATETC;
 
     TRACE("This %p formatEtc %p={.tymed=0x%x, .dwAspect=%d, .cfFormat=%s}\n",
@@ -205,9 +145,7 @@ static HRESULT WINAPI dddo_QueryGetData(IDataObject* iface, FORMATETC* formatEtc
         return E_NOTIMPL;
     }
 
-    params.handle = This->pasteboard;
-    params.format = formatEtc->cfFormat;
-    if (MACDRV_CALL(dnd_have_format, &params))
+    if (macdrv_pasteboard_has_format(This->pasteboard, formatEtc->cfFormat))
         hr = S_OK;
 
     TRACE(" -> 0x%x\n", hr);
@@ -247,8 +185,7 @@ static HRESULT WINAPI dddo_EnumFormatEtc(IDataObject* iface, DWORD direction,
                                          IEnumFORMATETC** enumFormatEtc)
 {
     DragDropDataObject *This = impl_from_IDataObject(iface);
-    struct dnd_get_formats_params params;
-    UINT count;
+    UINT *formats, count;
     HRESULT hr;
 
     TRACE("This %p direction %u enumFormatEtc %p\n", This, direction, enumFormatEtc);
@@ -259,9 +196,8 @@ static HRESULT WINAPI dddo_EnumFormatEtc(IDataObject* iface, DWORD direction,
         return E_NOTIMPL;
     }
 
-    params.handle = This->pasteboard;
-    count = MACDRV_CALL(dnd_get_formats, &params);
-    if (count)
+    formats = macdrv_get_pasteboard_formats(This->pasteboard, &count);
+    if (formats)
     {
         FORMATETC *formatEtcs = HeapAlloc(GetProcessHeap(), 0, count * sizeof(FORMATETC));
         if (formatEtcs)
@@ -270,7 +206,7 @@ static HRESULT WINAPI dddo_EnumFormatEtc(IDataObject* iface, DWORD direction,
 
             for (i = 0; i < count; i++)
             {
-                formatEtcs[i].cfFormat = params.formats[i];
+                formatEtcs[i].cfFormat = formats[i];
                 formatEtcs[i].ptd = NULL;
                 formatEtcs[i].dwAspect = DVASPECT_CONTENT;
                 formatEtcs[i].lindex = -1;
@@ -282,6 +218,8 @@ static HRESULT WINAPI dddo_EnumFormatEtc(IDataObject* iface, DWORD direction,
         }
         else
             hr = E_OUTOFMEMORY;
+
+        HeapFree(GetProcessHeap(), 0, formats);
     }
     else
         hr = SHCreateStdEnumFmtEtc(0, NULL, enumFormatEtc);
@@ -331,7 +269,7 @@ static const IDataObjectVtbl dovt =
 };
 
 
-static IDataObject *create_data_object_for_pasteboard(UINT64 pasteboard)
+static IDataObject *create_data_object_for_pasteboard(CFTypeRef pasteboard)
 {
     DragDropDataObject *dddo;
 
@@ -341,13 +279,43 @@ static IDataObject *create_data_object_for_pasteboard(UINT64 pasteboard)
 
     dddo->ref = 1;
     dddo->IDataObject_iface.lpVtbl = &dovt;
-    dddo->pasteboard = pasteboard;
-    MACDRV_CALL(dnd_retain, &dddo->pasteboard);
+    dddo->pasteboard = CFRetain(pasteboard);
 
     return &dddo->IDataObject_iface;
 }
 
 
+/**************************************************************************
+ *              drag_operations_to_dropeffects
+ */
+static DWORD drag_operations_to_dropeffects(uint32_t ops)
+{
+    DWORD effects = DROPEFFECT_NONE;
+    if (ops & (DRAG_OP_COPY | DRAG_OP_GENERIC))
+        effects |= DROPEFFECT_COPY;
+    if (ops & DRAG_OP_MOVE)
+        effects |= DROPEFFECT_MOVE;
+    if (ops & (DRAG_OP_LINK | DRAG_OP_GENERIC))
+        effects |= DROPEFFECT_LINK;
+    return effects;
+}
+
+
+/**************************************************************************
+ *              dropeffect_to_drag_operation
+ */
+static uint32_t dropeffect_to_drag_operation(DWORD effect, uint32_t ops)
+{
+    if (effect & DROPEFFECT_LINK && ops & DRAG_OP_LINK) return DRAG_OP_LINK;
+    if (effect & DROPEFFECT_COPY && ops & DRAG_OP_COPY) return DRAG_OP_COPY;
+    if (effect & DROPEFFECT_MOVE && ops & DRAG_OP_MOVE) return DRAG_OP_MOVE;
+    if (effect & DROPEFFECT_LINK && ops & DRAG_OP_GENERIC) return DRAG_OP_GENERIC;
+    if (effect & DROPEFFECT_COPY && ops & DRAG_OP_GENERIC) return DRAG_OP_GENERIC;
+
+    return DRAG_OP_NONE;
+}
+
+
 /* Based on functions in dlls/ole32/ole2.c */
 static HANDLE get_droptarget_local_handle(HWND hwnd)
 {
@@ -419,32 +387,40 @@ static IDropTarget* get_droptarget_pointer(HWND hwnd)
 
 
 /**************************************************************************
- *              macdrv_dnd_query_drop
+ *              query_drag_drop
  */
-NTSTATUS WINAPI macdrv_dnd_query_drop(void *arg, ULONG size)
+BOOL query_drag_drop(macdrv_query* query)
 {
-    struct dnd_query_drop_params *params = arg;
-    IDropTarget *droptarget;
     BOOL ret = FALSE;
+    HWND hwnd = macdrv_get_window_hwnd(query->window);
+    struct macdrv_win_data *data = get_win_data(hwnd);
     POINT pt;
+    IDropTarget *droptarget;
 
-    TRACE("win %p x,y %d,%d effect %x pasteboard %s\n", params->hwnd, params->x, params->y,
-          params->effect, wine_dbgstr_longlong(params->handle));
+    TRACE("win %p/%p x,y %d,%d op 0x%08x pasteboard %p\n", hwnd, query->window,
+          query->drag_drop.x, query->drag_drop.y, query->drag_drop.op, query->drag_drop.pasteboard);
 
-    pt.x = params->x;
-    pt.y = params->y;
+    if (!data)
+    {
+        WARN("no win_data for win %p/%p\n", hwnd, query->window);
+        return FALSE;
+    }
+
+    pt.x = query->drag_drop.x + data->whole_rect.left;
+    pt.y = query->drag_drop.y + data->whole_rect.top;
+    release_win_data(data);
 
     droptarget = get_droptarget_pointer(last_droptarget_hwnd);
     if (droptarget)
     {
         HRESULT hr;
         POINTL pointl;
-        DWORD effect = params->effect;
+        DWORD effect = drag_operations_to_dropeffects(query->drag_drop.op);
 
         if (!active_data_object)
         {
             WARN("shouldn't happen: no active IDataObject\n");
-            active_data_object = create_data_object_for_pasteboard(params->handle);
+            active_data_object = create_data_object_for_pasteboard(query->drag_drop.pasteboard);
         }
 
         pointl.x = pt.x;
@@ -468,12 +444,12 @@ NTSTATUS WINAPI macdrv_dnd_query_drop(void *arg, ULONG size)
     }
     else
     {
-        HWND hwnd = WindowFromPoint(pt);
+        hwnd = WindowFromPoint(pt);
         while (hwnd && !(GetWindowLongW(hwnd, GWL_EXSTYLE) & WS_EX_ACCEPTFILES))
             hwnd = GetParent(hwnd);
         if (hwnd)
         {
-            HDROP hdrop = get_pasteboard_data(params->handle, CF_HDROP);
+            HDROP hdrop = macdrv_get_pasteboard_data(query->drag_drop.pasteboard, CF_HDROP);
             DROPFILES *dropfiles = GlobalLock(hdrop);
             if (dropfiles)
             {
@@ -506,15 +482,14 @@ NTSTATUS WINAPI macdrv_dnd_query_drop(void *arg, ULONG size)
 
 
 /**************************************************************************
- *              macdrv_dnd_query_exited
+ *              query_drag_exited
  */
-NTSTATUS WINAPI macdrv_dnd_query_exited(void *arg, ULONG size)
+BOOL query_drag_exited(macdrv_query* query)
 {
-    struct dnd_query_exited_params *params = arg;
-    HWND hwnd = params->hwnd;
+    HWND hwnd = macdrv_get_window_hwnd(query->window);
     IDropTarget *droptarget;
 
-    TRACE("win %p\n", hwnd);
+    TRACE("win %p/%p\n", hwnd, query->window);
 
     droptarget = get_droptarget_pointer(last_droptarget_hwnd);
     if (droptarget)
@@ -539,22 +514,31 @@ NTSTATUS WINAPI macdrv_dnd_query_exited(void *arg, ULONG size)
 /**************************************************************************
  *              query_drag_operation
  */
-NTSTATUS WINAPI macdrv_dnd_query_drag(void *arg, ULONG size)
+BOOL query_drag_operation(macdrv_query* query)
 {
-    struct dnd_query_drag_params *params = arg;
-    HWND hwnd = params->hwnd;
     BOOL ret = FALSE;
+    HWND hwnd = macdrv_get_window_hwnd(query->window);
+    struct macdrv_win_data *data = get_win_data(hwnd);
     POINT pt;
     DWORD effect;
     IDropTarget *droptarget;
     HRESULT hr;
 
-    TRACE("win %p x,y %d,%d effect %x pasteboard %s\n", hwnd, params->x, params->y,
-          params->effect, wine_dbgstr_longlong(params->handle));
+    TRACE("win %p/%p x,y %d,%d offered_ops 0x%x pasteboard %p\n", hwnd, query->window,
+          query->drag_operation.x, query->drag_operation.y, query->drag_operation.offered_ops,
+          query->drag_operation.pasteboard);
 
-    pt.x = params->x;
-    pt.y = params->y;
-    effect = params->effect;
+    if (!data)
+    {
+        WARN("no win_data for win %p/%p\n", hwnd, query->window);
+        return FALSE;
+    }
+
+    pt.x = query->drag_operation.x + data->whole_rect.left;
+    pt.y = query->drag_operation.y + data->whole_rect.top;
+    release_win_data(data);
+
+    effect = drag_operations_to_dropeffects(query->drag_operation.offered_ops);
 
     /* Instead of the top-level window we got in the query, start with the deepest
        child under the cursor.  Travel up the hierarchy looking for a window that
@@ -587,14 +571,16 @@ NTSTATUS WINAPI macdrv_dnd_query_drag(void *arg, ULONG size)
             POINTL pointl = { pt.x, pt.y };
 
             if (!active_data_object)
-                active_data_object = create_data_object_for_pasteboard(params->handle);
+                active_data_object = create_data_object_for_pasteboard(query->drag_operation.pasteboard);
 
             TRACE("DragEnter hwnd %p droptarget %p\n", hwnd, droptarget);
             hr = IDropTarget_DragEnter(droptarget, active_data_object, MK_LBUTTON,
                                        pointl, &effect);
             if (SUCCEEDED(hr))
             {
-                TRACE("    effect %d\n", effect);
+                query->drag_operation.accepted_op = dropeffect_to_drag_operation(effect,
+                                                        query->drag_operation.offered_ops);
+                TRACE("    effect %d accepted op %d\n", effect, query->drag_operation.accepted_op);
                 ret = TRUE;
             }
             else
@@ -610,7 +596,9 @@ NTSTATUS WINAPI macdrv_dnd_query_drag(void *arg, ULONG size)
         hr = IDropTarget_DragOver(droptarget, MK_LBUTTON, pointl, &effect);
         if (SUCCEEDED(hr))
         {
-            TRACE("    effect %d\n", effect);
+            query->drag_operation.accepted_op = dropeffect_to_drag_operation(effect,
+                                                    query->drag_operation.offered_ops);
+            TRACE("    effect %d accepted op %d\n", effect, query->drag_operation.accepted_op);
             ret = TRUE;
         }
         else
@@ -628,7 +616,7 @@ NTSTATUS WINAPI macdrv_dnd_query_drag(void *arg, ULONG size)
             FORMATETC formatEtc;
 
             if (!active_data_object)
-                active_data_object = create_data_object_for_pasteboard(params->handle);
+                active_data_object = create_data_object_for_pasteboard(query->drag_operation.pasteboard);
 
             formatEtc.cfFormat = CF_HDROP;
             formatEtc.ptd = NULL;
@@ -638,12 +626,12 @@ NTSTATUS WINAPI macdrv_dnd_query_drag(void *arg, ULONG size)
             if (SUCCEEDED(IDataObject_QueryGetData(active_data_object, &formatEtc)))
             {
                 TRACE("WS_EX_ACCEPTFILES hwnd %p\n", hwnd);
-                effect = DROPEFFECT_COPY | DROPEFFECT_LINK;
+                query->drag_operation.accepted_op = DRAG_OP_GENERIC;
                 ret = TRUE;
             }
         }
     }
 
     TRACE(" -> %s\n", ret ? "TRUE" : "FALSE");
-    return ret ? effect : 0;
+    return ret;
 }
diff --git a/dlls/winemac.drv/event.c b/dlls/winemac.drv/event.c
index d76c6ee8edb..f197af0808e 100644
--- a/dlls/winemac.drv/event.c
+++ b/dlls/winemac.drv/event.c
@@ -20,17 +20,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include "macdrv.h"
-#include "oleidl.h"
+#include "winuser.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(event);
-WINE_DECLARE_DEBUG_CHANNEL(imm);
 
 
 /* return the name of an Mac event */
@@ -48,7 +43,7 @@ static const char *dbgstr_event(int type)
         "KEYBOARD_CHANGED",
         "LOST_PASTEBOARD_OWNERSHIP",
         "MOUSE_BUTTON",
-        "MOUSE_MOVED_RELATIVE",
+        "MOUSE_MOVED",
         "MOUSE_MOVED_ABSOLUTE",
         "MOUSE_SCROLL",
         "QUERY_EVENT",
@@ -104,7 +99,7 @@ static macdrv_event_mask get_event_mask(DWORD mask)
 
     if (mask & QS_MOUSEMOVE)
     {
-        event_mask |= event_mask_for_type(MOUSE_MOVED_RELATIVE);
+        event_mask |= event_mask_for_type(MOUSE_MOVED);
         event_mask |= event_mask_for_type(MOUSE_MOVED_ABSOLUTE);
     }
 
@@ -145,174 +140,6 @@ static macdrv_event_mask get_event_mask(DWORD mask)
 }
 
 
-/***********************************************************************
- *              macdrv_im_set_text
- */
-static void macdrv_im_set_text(const macdrv_event *event)
-{
-    HWND hwnd = macdrv_get_window_hwnd(event->window);
-    struct ime_set_text_params *params;
-    CFIndex length = 0, size;
-
-    TRACE_(imm)("win %p/%p himc %p text %s complete %u\n", hwnd, event->window, event->im_set_text.data,
-                debugstr_cf(event->im_set_text.text), event->im_set_text.complete);
-
-    if (event->im_set_text.text)
-        length = CFStringGetLength(event->im_set_text.text);
-
-    size = offsetof(struct ime_set_text_params, text[length]);
-    if (!(params = malloc(size))) return;
-    params->hwnd = hwnd;
-    params->data = event->im_set_text.data;
-    params->cursor_pos = event->im_set_text.cursor_pos;
-    params->complete = event->im_set_text.complete;
-
-    if (length)
-        CFStringGetCharacters(event->im_set_text.text, CFRangeMake(0, length), params->text);
-
-    macdrv_client_func(client_func_ime_set_text, params, size);
-}
-
-/***********************************************************************
- *              macdrv_sent_text_input
- */
-static void macdrv_sent_text_input(const macdrv_event *event)
-{
-    TRACE_(imm)("handled: %s\n", event->sent_text_input.handled ? "TRUE" : "FALSE");
-    *event->sent_text_input.done = event->sent_text_input.handled ? 1 : -1;
-}
-
-
-/**************************************************************************
- *              drag_operations_to_dropeffects
- */
-static DWORD drag_operations_to_dropeffects(uint32_t ops)
-{
-    DWORD effects = 0;
-    if (ops & (DRAG_OP_COPY | DRAG_OP_GENERIC))
-        effects |= DROPEFFECT_COPY;
-    if (ops & DRAG_OP_MOVE)
-        effects |= DROPEFFECT_MOVE;
-    if (ops & (DRAG_OP_LINK | DRAG_OP_GENERIC))
-        effects |= DROPEFFECT_LINK;
-    return effects;
-}
-
-
-/**************************************************************************
- *              dropeffect_to_drag_operation
- */
-static uint32_t dropeffect_to_drag_operation(DWORD effect, uint32_t ops)
-{
-    if (effect & DROPEFFECT_LINK && ops & DRAG_OP_LINK) return DRAG_OP_LINK;
-    if (effect & DROPEFFECT_COPY && ops & DRAG_OP_COPY) return DRAG_OP_COPY;
-    if (effect & DROPEFFECT_MOVE && ops & DRAG_OP_MOVE) return DRAG_OP_MOVE;
-    if (effect & DROPEFFECT_LINK && ops & DRAG_OP_GENERIC) return DRAG_OP_GENERIC;
-    if (effect & DROPEFFECT_COPY && ops & DRAG_OP_GENERIC) return DRAG_OP_GENERIC;
-
-    return DRAG_OP_NONE;
-}
-
-
-/**************************************************************************
- *              query_drag_drop
- */
-static BOOL query_drag_drop(macdrv_query *query)
-{
-    HWND hwnd = macdrv_get_window_hwnd(query->window);
-    struct macdrv_win_data *data = get_win_data(hwnd);
-    struct dnd_query_drop_params params;
-
-    if (!data)
-    {
-        WARN("no win_data for win %p/%p\n", hwnd, query->window);
-        return FALSE;
-    }
-
-    params.hwnd = hwnd;
-    params.effect = drag_operations_to_dropeffects(query->drag_drop.op);
-    params.x = query->drag_drop.x + data->whole_rect.left;
-    params.y = query->drag_drop.y + data->whole_rect.top;
-    params.handle = (UINT_PTR)query->drag_drop.pasteboard;
-    release_win_data(data);
-    return macdrv_client_func(client_func_dnd_query_drop, &params, sizeof(params));
-}
-
-/**************************************************************************
- *              query_drag_exited
- */
-static BOOL query_drag_exited(macdrv_query *query)
-{
-    struct dnd_query_exited_params params;
-    params.hwnd = macdrv_get_window_hwnd(query->window);
-    return macdrv_client_func(client_func_dnd_query_exited, &params, sizeof(params));
-}
-
-
-/**************************************************************************
- *              query_drag_operation
- */
-static BOOL query_drag_operation(macdrv_query *query)
-{
-    struct dnd_query_drag_params params;
-    HWND hwnd = macdrv_get_window_hwnd(query->window);
-    struct macdrv_win_data *data = get_win_data(hwnd);
-    DWORD effect;
-
-    if (!data)
-    {
-        WARN("no win_data for win %p/%p\n", hwnd, query->window);
-        return FALSE;
-    }
-
-    params.hwnd = hwnd;
-    params.effect = drag_operations_to_dropeffects(query->drag_operation.offered_ops);
-    params.x = query->drag_operation.x + data->whole_rect.left;
-    params.y = query->drag_operation.y + data->whole_rect.top;
-    params.handle = (UINT_PTR)query->drag_operation.pasteboard;
-    release_win_data(data);
-
-    effect = macdrv_client_func(client_func_dnd_query_drag, &params, sizeof(params));
-    if (!effect) return FALSE;
-
-    query->drag_operation.accepted_op = dropeffect_to_drag_operation(effect,
-                                                                     query->drag_operation.offered_ops);
-    return TRUE;
-}
-
-
-/**************************************************************************
- *              query_ime_char_rect
- */
-BOOL query_ime_char_rect(macdrv_query* query)
-{
-    HWND hwnd = macdrv_get_window_hwnd(query->window);
-    void *himc = query->ime_char_rect.data;
-    CFRange *range = &query->ime_char_rect.range;
-    CGRect *rect = &query->ime_char_rect.rect;
-    struct ime_query_char_rect_result result = {0};
-    struct ime_query_char_rect_params params;
-    BOOL ret;
-
-    TRACE_(imm)("win %p/%p himc %p range %ld-%ld\n", hwnd, query->window, himc, range->location,
-                range->length);
-
-    params.hwnd = hwnd;
-    params.data = himc;
-    params.result = &result;
-    params.location = range->location;
-    params.length = range->length;
-    ret = macdrv_client_func(client_func_ime_query_char_rect, &params, sizeof(params));
-    *range = CFRangeMake(result.location, result.length);
-    *rect = cgrect_from_rect(result.rect);
-
-    TRACE_(imm)(" -> %s range %ld-%ld rect %s\n", ret ? "TRUE" : "FALSE", range->location,
-                range->length, wine_dbgstr_cgrect(*rect));
-
-    return ret;
-}
-
-
 /***********************************************************************
  *              macdrv_query_event
  *
@@ -416,7 +243,7 @@ void macdrv_handle_event(const macdrv_event *event)
     case MOUSE_BUTTON:
         macdrv_mouse_button(hwnd, event);
         break;
-    case MOUSE_MOVED_RELATIVE:
+    case MOUSE_MOVED:
     case MOUSE_MOVED_ABSOLUTE:
         macdrv_mouse_moved(hwnd, event);
         break;
@@ -512,21 +339,21 @@ static int process_events(macdrv_event_queue queue, macdrv_event_mask mask)
 /***********************************************************************
  *              MsgWaitForMultipleObjectsEx   (MACDRV.@)
  */
-NTSTATUS macdrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
-                                            const LARGE_INTEGER *timeout, DWORD mask, DWORD flags)
+DWORD CDECL macdrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
+                                               DWORD timeout, DWORD mask, DWORD flags)
 {
     DWORD ret;
     struct macdrv_thread_data *data = macdrv_thread_data();
     macdrv_event_mask event_mask = get_event_mask(mask);
 
-    TRACE("count %d, handles %p, timeout %p, mask %x, flags %x\n", count,
+    TRACE("count %d, handles %p, timeout %u, mask %x, flags %x\n", count,
           handles, timeout, mask, flags);
 
     if (!data)
     {
-        if (!count && timeout && !timeout->QuadPart) return WAIT_TIMEOUT;
-        return pNtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                          !!(flags & MWMO_ALERTABLE), timeout );
+        if (!count && !timeout) return WAIT_TIMEOUT;
+        return WaitForMultipleObjectsEx(count, handles, flags & MWMO_WAITALL,
+                                        timeout, flags & MWMO_ALERTABLE);
     }
 
     if (data->current_event && data->current_event->type != QUERY_EVENT &&
@@ -536,10 +363,10 @@ NTSTATUS macdrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
         event_mask = 0;  /* don't process nested events */
 
     if (process_events(data->queue, event_mask)) ret = count - 1;
-    else if (count || !timeout || timeout->QuadPart)
+    else if (count || timeout)
     {
-        ret = pNtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                         !!(flags & MWMO_ALERTABLE), timeout );
+        ret = WaitForMultipleObjectsEx(count, handles, flags & MWMO_WAITALL,
+                                       timeout, flags & MWMO_ALERTABLE);
         if (ret == count - 1) process_events(data->queue, event_mask);
     }
     else ret = WAIT_TIMEOUT;
diff --git a/dlls/winemac.drv/gdi.c b/dlls/winemac.drv/gdi.c
index 7114835677b..9796838a980 100644
--- a/dlls/winemac.drv/gdi.c
+++ b/dlls/winemac.drv/gdi.c
@@ -19,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include "macdrv.h"
@@ -270,9 +266,8 @@ static const struct user_driver_funcs macdrv_funcs =
     .pBeep = macdrv_Beep,
     .pChangeDisplaySettingsEx = macdrv_ChangeDisplaySettingsEx,
     .pClipCursor = macdrv_ClipCursor,
-    .pClipboardWindowProc = macdrv_ClipboardWindowProc,
     .pCreateDesktopWindow = macdrv_CreateDesktopWindow,
-    .pDesktopWindowProc = macdrv_DesktopWindowProc,
+    .pCreateWindow = macdrv_CreateWindow,
     .pDestroyCursorIcon = macdrv_DestroyCursorIcon,
     .pDestroyWindow = macdrv_DestroyWindow,
     .pEnumDisplaySettingsEx = macdrv_EnumDisplaySettingsEx,
diff --git a/dlls/winemac.drv/image.c b/dlls/winemac.drv/image.c
index a0ee8b04aa9..e5f3a4c0fa6 100644
--- a/dlls/winemac.drv/image.c
+++ b/dlls/winemac.drv/image.c
@@ -18,10 +18,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include "macdrv.h"
@@ -29,6 +25,30 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(image);
 
+#include "pshpack1.h"
+
+typedef struct
+{
+    BYTE bWidth;
+    BYTE bHeight;
+    BYTE bColorCount;
+    BYTE bReserved;
+    WORD wPlanes;
+    WORD wBitCount;
+    DWORD dwBytesInRes;
+    WORD nID;
+} GRPICONDIRENTRY;
+
+typedef struct
+{
+    WORD idReserved;
+    WORD idType;
+    WORD idCount;
+    GRPICONDIRENTRY idEntries[1];
+} GRPICONDIR;
+
+#include "poppack.h"
+
 
 /***********************************************************************
  *              create_cgimage_from_icon_bitmaps
@@ -49,8 +69,8 @@ CGImageRef create_cgimage_from_icon_bitmaps(HDC hdc, HANDLE icon, HBITMAP hbmCol
 
     /* draw the cursor frame to a temporary buffer then create a CGImage from that */
     memset(color_bits, 0x00, color_size);
-    NtGdiSelectBitmap(hdc, hbmColor);
-    if (!NtUserDrawIconEx(hdc, 0, 0, icon, width, height, istep, NULL, DI_NORMAL))
+    SelectObject(hdc, hbmColor);
+    if (!DrawIconEx(hdc, 0, 0, icon, width, height, istep, NULL, DI_NORMAL))
     {
         WARN("Could not draw frame %d (walk past end of frames).\n", istep);
         return NULL;
@@ -108,8 +128,8 @@ CGImageRef create_cgimage_from_icon_bitmaps(HDC hdc, HANDLE icon, HBITMAP hbmCol
 
         /* draw the cursor mask to a temporary buffer */
         memset(mask_bits, 0xFF, mask_size);
-        NtGdiSelectBitmap(hdc, hbmMask);
-        if (!NtUserDrawIconEx(hdc, 0, 0, icon, width, height, istep, NULL, DI_MASK))
+        SelectObject(hdc, hbmMask);
+        if (!DrawIconEx(hdc, 0, 0, icon, width, height, istep, NULL, DI_MASK))
         {
             WARN("Failed to draw frame mask %d.\n", istep);
             CGImageRelease(cgimage);
@@ -179,20 +199,20 @@ CGImageRef create_cgimage_from_icon(HANDLE icon, int width, int height)
         ICONINFO info;
         BITMAP bm;
 
-        if (!NtUserGetIconInfo(icon, &info, NULL, NULL, NULL, 0))
+        if (!GetIconInfo(icon, &info))
             return NULL;
 
-        NtGdiExtGetObjectW(info.hbmMask, sizeof(bm), &bm);
+        GetObjectW(info.hbmMask, sizeof(bm), &bm);
         if (!info.hbmColor) bm.bmHeight = max(1, bm.bmHeight / 2);
         width = bm.bmWidth;
         height = bm.bmHeight;
         TRACE("new width %d height %d\n", width, height);
 
-        NtGdiDeleteObjectApp(info.hbmColor);
-        NtGdiDeleteObjectApp(info.hbmMask);
+        DeleteObject(info.hbmColor);
+        DeleteObject(info.hbmMask);
     }
 
-    hdc = NtGdiCreateCompatibleDC(0);
+    hdc = CreateCompatibleDC(0);
 
     bitmapinfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     bitmapinfo->bmiHeader.biWidth = width;
@@ -206,8 +226,7 @@ CGImageRef create_cgimage_from_icon(HANDLE icon, int width, int height)
     bitmapinfo->bmiHeader.biBitCount = 32;
     color_size = width * height * 4;
     bitmapinfo->bmiHeader.biSizeImage = color_size;
-    hbmColor = NtGdiCreateDIBSection(hdc, NULL, 0, bitmapinfo, DIB_RGB_COLORS,
-                                     0, 0, 0, (void **)&color_bits);
+    hbmColor = CreateDIBSection(hdc, bitmapinfo, DIB_RGB_COLORS, (VOID **) &color_bits, NULL, 0);
     if (!hbmColor)
     {
         WARN("failed to create DIB section for cursor color data\n");
@@ -225,8 +244,7 @@ CGImageRef create_cgimage_from_icon(HANDLE icon, int width, int height)
     bitmapinfo->bmiColors[1].rgbReserved = 0;
     mask_size = ((width + 31) / 32 * 4) * height;
     bitmapinfo->bmiHeader.biSizeImage = mask_size;
-    hbmMask = NtGdiCreateDIBSection(hdc, NULL, 0, bitmapinfo, DIB_RGB_COLORS,
-                                    0, 0, 0, (void **)&mask_bits);
+    hbmMask = CreateDIBSection(hdc, bitmapinfo, DIB_RGB_COLORS, (VOID **) &mask_bits, NULL, 0);
     if (!hbmMask)
     {
         WARN("failed to create DIB section for cursor mask data\n");
@@ -237,74 +255,174 @@ CGImageRef create_cgimage_from_icon(HANDLE icon, int width, int height)
                                            mask_bits, mask_size, width, height, 0);
 
 cleanup:
-    if (hbmColor) NtGdiDeleteObjectApp(hbmColor);
-    if (hbmMask) NtGdiDeleteObjectApp(hbmMask);
-    NtGdiDeleteObjectApp(hdc);
+    if (hbmColor) DeleteObject(hbmColor);
+    if (hbmMask) DeleteObject(hbmMask);
+    DeleteDC(hdc);
     return ret;
 }
 
 
+/***********************************************************************
+ *              get_first_resource
+ *
+ * Helper for create_app_icon_images().  Enum proc for EnumResourceNamesW()
+ * which just gets the handle for the first resource and stops further
+ * enumeration.
+ */
+static BOOL CALLBACK get_first_resource(HMODULE module, LPCWSTR type, LPWSTR name, LONG_PTR lparam)
+{
+    HRSRC *res_info = (HRSRC*)lparam;
+
+    *res_info = FindResourceW(module, name, (LPCWSTR)RT_GROUP_ICON);
+    return FALSE;
+}
+
+
 /***********************************************************************
  *              create_app_icon_images
  */
 CFArrayRef create_app_icon_images(void)
 {
-    struct app_icon_result icons;
-    struct app_icon_params params = { .result = &icons };
+    HRSRC res_info;
+    HGLOBAL res_data;
+    GRPICONDIR *icon_dir;
     CFMutableArrayRef images = NULL;
     int i;
 
     TRACE("()\n");
 
-    macdrv_client_func(client_func_app_icon, &params, sizeof(params));
+    res_info = NULL;
+    EnumResourceNamesW(NULL, (LPCWSTR)RT_GROUP_ICON, get_first_resource, (LONG_PTR)&res_info);
+    if (!res_info)
+    {
+        WARN("found no RT_GROUP_ICON resource\n");
+        return NULL;
+    }
 
-    if (!icons.count) return NULL;
+    if (!(res_data = LoadResource(NULL, res_info)))
+    {
+        WARN("failed to load RT_GROUP_ICON resource\n");
+        return NULL;
+    }
 
-    images = CFArrayCreateMutable(NULL, icons.count, &kCFTypeArrayCallBacks);
+    if (!(icon_dir = LockResource(res_data)))
+    {
+        WARN("failed to lock RT_GROUP_ICON resource\n");
+        goto cleanup;
+    }
+
+    images = CFArrayCreateMutable(NULL, icon_dir->idCount, &kCFTypeArrayCallBacks);
     if (!images)
     {
         WARN("failed to create images array\n");
-        return NULL;
+        goto cleanup;
     }
 
-    for (i = 0; i < icons.count; i++)
+    for (i = 0; i < icon_dir->idCount; i++)
     {
-        struct app_icon_entry *icon = &icons.entries[i];
-        CGImageRef cgimage = NULL;
-
-        if (icon->png)
+        int width = icon_dir->idEntries[i].bWidth;
+        int height = icon_dir->idEntries[i].bHeight;
+        BOOL found_better_bpp = FALSE;
+        int j;
+        LPCWSTR name;
+        HGLOBAL icon_res_data;
+        BYTE *icon_bits;
+
+        if (!width) width = 256;
+        if (!height) height = 256;
+
+        /* If there's another icon at the same size but with better
+           color depth, skip this one.  We end up making CGImages that
+           are all 32 bits per pixel, so Cocoa doesn't get the original
+           color depth info to pick the best representation itself. */
+        for (j = 0; j < icon_dir->idCount; j++)
         {
-            CFDataRef data = CFDataCreate(NULL, icon->png, icon->size);
-            if (data)
+            int jwidth = icon_dir->idEntries[j].bWidth;
+            int jheight = icon_dir->idEntries[j].bHeight;
+
+            if (!jwidth) jwidth = 256;
+            if (!jheight) jheight = 256;
+
+            if (j != i && jwidth == width && jheight == height &&
+                icon_dir->idEntries[j].wBitCount > icon_dir->idEntries[i].wBitCount)
             {
-                CGDataProviderRef provider = CGDataProviderCreateWithCFData(data);
-                CFRelease(data);
-                if (provider)
-                {
-                    cgimage = CGImageCreateWithPNGDataProvider(provider, NULL, FALSE,
-                                                               kCGRenderingIntentDefault);
-                    CGDataProviderRelease(provider);
-                }
+                found_better_bpp = TRUE;
+                break;
             }
         }
-        else
+
+        if (found_better_bpp) continue;
+
+        name = MAKEINTRESOURCEW(icon_dir->idEntries[i].nID);
+        res_info = FindResourceW(NULL, name, (LPCWSTR)RT_ICON);
+        if (!res_info)
         {
-            cgimage = create_cgimage_from_icon(icon->icon, icon->width, icon->height);
-            NtUserDestroyCursor(icon->icon, 0);
+            WARN("failed to find RT_ICON resource %d with ID %hd\n", i, icon_dir->idEntries[i].nID);
+            continue;
         }
 
-        if (cgimage)
+        icon_res_data = LoadResource(NULL, res_info);
+        if (!icon_res_data)
         {
-            CFArrayAppendValue(images, cgimage);
-            CGImageRelease(cgimage);
+            WARN("failed to load icon %d with ID %hd\n", i, icon_dir->idEntries[i].nID);
+            continue;
         }
+
+        icon_bits = LockResource(icon_res_data);
+        if (icon_bits)
+        {
+            static const BYTE png_magic[] = { 0x89, 0x50, 0x4e, 0x47 };
+            CGImageRef cgimage = NULL;
+
+            if (!memcmp(icon_bits, png_magic, sizeof(png_magic)))
+            {
+                CFDataRef data = CFDataCreate(NULL, (UInt8*)icon_bits, icon_dir->idEntries[i].dwBytesInRes);
+                if (data)
+                {
+                    CGDataProviderRef provider = CGDataProviderCreateWithCFData(data);
+                    CFRelease(data);
+                    if (provider)
+                    {
+                        cgimage = CGImageCreateWithPNGDataProvider(provider, NULL, FALSE,
+                                                                   kCGRenderingIntentDefault);
+                        CGDataProviderRelease(provider);
+                    }
+                }
+            }
+
+            if (!cgimage)
+            {
+                HICON icon;
+                icon = CreateIconFromResourceEx(icon_bits, icon_dir->idEntries[i].dwBytesInRes,
+                                                TRUE, 0x00030000, width, height, 0);
+                if (icon)
+                {
+                    cgimage = create_cgimage_from_icon(icon, width, height);
+                    DestroyIcon(icon);
+                }
+                else
+                    WARN("failed to create icon %d from resource with ID %hd\n", i, icon_dir->idEntries[i].nID);
+            }
+
+            if (cgimage)
+            {
+                CFArrayAppendValue(images, cgimage);
+                CGImageRelease(cgimage);
+            }
+        }
+        else
+            WARN("failed to lock RT_ICON resource %d with ID %hd\n", i, icon_dir->idEntries[i].nID);
+
+        FreeResource(icon_res_data);
     }
 
+cleanup:
     if (images && !CFArrayGetCount(images))
     {
         CFRelease(images);
         images = NULL;
     }
+    FreeResource(res_data);
 
     return images;
 }
diff --git a/dlls/winemac.drv/ime.c b/dlls/winemac.drv/ime.c
index fd94591a2b8..8b89c0089fc 100644
--- a/dlls/winemac.drv/ime.c
+++ b/dlls/winemac.drv/ime.c
@@ -34,10 +34,14 @@
  *    here the IMM level deals with if the application is IME aware or not.
  */
 
-#include "macdrv_dll.h"
+#include "config.h"
+
+#include <stdarg.h>
+
+#include "macdrv.h"
+#include "winuser.h"
 #include "imm.h"
 #include "ddk/imm.h"
-#include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(imm);
 
@@ -573,7 +577,7 @@ BOOL WINAPI ImeProcessKey(HIMC hIMC, UINT vKey, LPARAM lKeyData, const LPBYTE lp
         return FALSE;
     }
 
-    inIME = MACDRV_CALL(ime_using_input_method, NULL);
+    inIME = macdrv_using_input_method();
     lpIMC = LockRealIMC(hIMC);
     if (lpIMC)
     {
@@ -654,7 +658,6 @@ BOOL WINAPI ImeSetActiveContext(HIMC hIMC, BOOL fFlag)
 UINT WINAPI ImeToAsciiEx(UINT uVKey, UINT uScanCode, const LPBYTE lpbKeyState,
                          LPDWORD lpdwTransKey, UINT fuState, HIMC hIMC)
 {
-    struct process_text_input_params params;
     UINT vkey;
     LPINPUTCONTEXT lpIMC;
     LPIMEPRIVATE myPrivate;
@@ -687,13 +690,7 @@ UINT WINAPI ImeToAsciiEx(UINT uVKey, UINT uScanCode, const LPBYTE lpbKeyState,
     UnlockRealIMC(hIMC);
 
     TRACE("Processing Mac 0x%04x\n", vkey);
-    params.vkey = uVKey;
-    params.scan = uScanCode;
-    params.repeat = repeat;
-    params.key_state = lpbKeyState;
-    params.himc = hIMC;
-    params.done = &done;
-    MACDRV_CALL(ime_process_text_input, &params);
+    macdrv_process_text_input(uVKey, uScanCode, repeat, lpbKeyState, hIMC, &done);
 
     while (!done)
         MsgWaitForMultipleObjectsEx(0, NULL, INFINITE, QS_POSTMESSAGE | QS_SENDMESSAGE, 0);
@@ -849,7 +846,7 @@ BOOL WINAPI NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
 
                     TRACE("NI_COMPOSITIONSTR: CPS_CANCEL\n");
 
-                    MACDRV_CALL(ime_clear, NULL);
+                    macdrv_clear_ime_text();
                     if (lpIMC->hCompStr)
                         ImmDestroyIMCC(lpIMC->hCompStr);
 
@@ -1391,25 +1388,38 @@ BOOL WINAPI ImeInquire(LPIMEINFO lpIMEInfo, LPWSTR lpszUIClass, LPCWSTR lpszOpti
 /* Interfaces to other parts of the Mac driver */
 
 /***********************************************************************
- *              macdrv_ime_set_text
+ *              macdrv_im_set_text
  */
-NTSTATUS WINAPI macdrv_ime_set_text(void *arg, ULONG size)
+void macdrv_im_set_text(const macdrv_event *event)
 {
-    struct ime_set_text_params *params = arg;
-    ULONG length = (size - offsetof(struct ime_set_text_params, text)) / sizeof(WCHAR);
-    void *himc = params->data;
+    HWND hwnd = macdrv_get_window_hwnd(event->window);
+    void *himc = event->im_set_text.data;
+
+    TRACE("win %p/%p himc %p text %s complete %u\n", hwnd, event->window, himc,
+          debugstr_cf(event->im_set_text.text), event->im_set_text.complete);
 
     if (!himc) himc = RealIMC(FROM_MACDRV);
 
-    if (length)
+    if (event->im_set_text.text)
     {
+        CFIndex length = CFStringGetLength(event->im_set_text.text);
+        const UniChar *chars = CFStringGetCharactersPtr(event->im_set_text.text);
+        UniChar *buffer = NULL;
+
+        if (!chars)
+        {
+            buffer = HeapAlloc(GetProcessHeap(), 0, length * sizeof(*buffer));
+            CFStringGetCharacters(event->im_set_text.text, CFRangeMake(0, length), buffer);
+            chars = buffer;
+        }
+
         if (himc)
-            IME_SetCompositionString(himc, SCS_SETSTR, params->text, length * sizeof(WCHAR),
-                                     params->cursor_pos, !params->complete);
+            IME_SetCompositionString(himc, SCS_SETSTR, chars, length * sizeof(*chars),
+                event->im_set_text.cursor_pos, !event->im_set_text.complete);
         else
         {
             INPUT input;
-            unsigned int i;
+            CFIndex i;
 
             input.type              = INPUT_KEYBOARD;
             input.ki.wVk            = 0;
@@ -1418,58 +1428,70 @@ NTSTATUS WINAPI macdrv_ime_set_text(void *arg, ULONG size)
 
             for (i = 0; i < length; i++)
             {
-                input.ki.wScan      = params->text[i];
+                input.ki.wScan      = chars[i];
                 input.ki.dwFlags    = KEYEVENTF_UNICODE;
-                __wine_send_input(params->hwnd, &input, NULL);
+                __wine_send_input(hwnd, &input, NULL);
 
                 input.ki.dwFlags    = KEYEVENTF_UNICODE | KEYEVENTF_KEYUP;
-                __wine_send_input(params->hwnd, &input, NULL);
+                __wine_send_input(hwnd, &input, NULL);
             }
         }
+
+        HeapFree(GetProcessHeap(), 0, buffer);
     }
 
-    if (params->complete)
+    if (event->im_set_text.complete)
         IME_NotifyComplete(himc);
-    return 0;
 }
 
+/***********************************************************************
+ *              macdrv_sent_text_input
+ */
+void macdrv_sent_text_input(const macdrv_event *event)
+{
+    TRACE("handled: %s\n", event->sent_text_input.handled ? "TRUE" : "FALSE");
+    *event->sent_text_input.done = event->sent_text_input.handled ? 1 : -1;
+}
+
+
 /**************************************************************************
- *              macdrv_ime_query_char_rect
+ *              query_ime_char_rect
  */
-NTSTATUS WINAPI macdrv_ime_query_char_rect(void *arg, ULONG size)
+BOOL query_ime_char_rect(macdrv_query* query)
 {
-    struct ime_query_char_rect_params *params = arg;
-    struct ime_query_char_rect_result *result = params->result;
-    void *himc = params->data;
+    HWND hwnd = macdrv_get_window_hwnd(query->window);
+    void *himc = query->ime_char_rect.data;
+    CFRange* range = &query->ime_char_rect.range;
+    CGRect* rect = &query->ime_char_rect.rect;
     IMECHARPOSITION charpos;
     BOOL ret = FALSE;
 
-    result->location = params->location;
-    result->length = params->length;
+    TRACE("win %p/%p himc %p range %ld-%ld\n", hwnd, query->window, himc, range->location,
+          range->length);
 
     if (!himc) himc = RealIMC(FROM_MACDRV);
 
     charpos.dwSize = sizeof(charpos);
-    charpos.dwCharPos = params->location;
+    charpos.dwCharPos = range->location;
     if (ImmRequestMessageW(himc, IMR_QUERYCHARPOSITION, (ULONG_PTR)&charpos))
     {
         int i;
 
-        SetRect(&result->rect, charpos.pt.x, charpos.pt.y, 0, charpos.pt.y + charpos.cLineHeight);
+        *rect = CGRectMake(charpos.pt.x, charpos.pt.y, 0, charpos.cLineHeight);
 
         /* iterate over rest of length to extend rect */
-        for (i = 1; i < params->length; i++)
+        for (i = 1; i < range->length; i++)
         {
             charpos.dwSize = sizeof(charpos);
-            charpos.dwCharPos = params->location + i;
+            charpos.dwCharPos = range->location + i;
             if (!ImmRequestMessageW(himc, IMR_QUERYCHARPOSITION, (ULONG_PTR)&charpos) ||
-                charpos.pt.y != result->rect.top)
+                charpos.pt.y != rect->origin.y)
             {
-                result->length = i;
+                range->length = i;
                 break;
             }
 
-            result->rect.right = charpos.pt.x;
+            rect->size.width = charpos.pt.x - rect->origin.x;
         }
 
         ret = TRUE;
@@ -1496,15 +1518,15 @@ NTSTATUS WINAPI macdrv_ime_query_char_rect(void *arg, ULONG size)
                 if (private->textfont)
                     oldfont = SelectObject(dc, private->textfont);
 
-                if (result->location > compstr->dwCompStrLen)
-                    result->location = compstr->dwCompStrLen;
-                if (result->location + result->length > compstr->dwCompStrLen)
-                    result->length = compstr->dwCompStrLen - result->location;
+                if (range->location > compstr->dwCompStrLen)
+                    range->location = compstr->dwCompStrLen;
+                if (range->location + range->length > compstr->dwCompStrLen)
+                    range->length = compstr->dwCompStrLen - range->location;
 
-                GetTextExtentPoint32W(dc, str, result->location, &size);
+                GetTextExtentPoint32W(dc, str, range->location, &size);
                 charpos.rcDocument.left = size.cx;
                 charpos.rcDocument.top = 0;
-                GetTextExtentPoint32W(dc, str, result->location + result->length, &size);
+                GetTextExtentPoint32W(dc, str, range->location + range->length, &size);
                 charpos.rcDocument.right = size.cx;
                 charpos.rcDocument.bottom = size.cy;
 
@@ -1513,7 +1535,7 @@ NTSTATUS WINAPI macdrv_ime_query_char_rect(void *arg, ULONG size)
 
                 LPtoDP(dc, (POINT*)&charpos.rcDocument, 2);
                 MapWindowPoints(private->hwndDefault, 0, (POINT*)&charpos.rcDocument, 2);
-                result->rect = charpos.rcDocument;
+                *rect = cgrect_from_rect(charpos.rcDocument);
                 ret = TRUE;
 
                 if (oldfont)
@@ -1535,13 +1557,16 @@ NTSTATUS WINAPI macdrv_ime_query_char_rect(void *arg, ULONG size)
         if (GetGUIThreadInfo(0, &gti))
         {
             MapWindowPoints(gti.hwndCaret, 0, (POINT*)&gti.rcCaret, 2);
-            result->rect = gti.rcCaret;
+            *rect = cgrect_from_rect(gti.rcCaret);
             ret = TRUE;
         }
     }
 
-    if (ret && result->length && result->rect.left == result->rect.right)
-        result->rect.right++;
+    if (ret && range->length && !rect->size.width)
+        rect->size.width = 1;
+
+    TRACE(" -> %s range %ld-%ld rect %s\n", ret ? "TRUE" : "FALSE", range->location,
+          range->length, wine_dbgstr_cgrect(*rect));
 
     return ret;
 }
diff --git a/dlls/winemac.drv/keyboard.c b/dlls/winemac.drv/keyboard.c
index 824addad78b..aa52860cb51 100644
--- a/dlls/winemac.drv/keyboard.c
+++ b/dlls/winemac.drv/keyboard.c
@@ -24,14 +24,11 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include "macdrv.h"
 #include "winuser.h"
+#include "wine/unicode.h"
 #include "wine/server.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
@@ -402,7 +399,7 @@ static BOOL char_matches_string(WCHAR wchar, UniChar *string, BOOL ignore_diacri
 {
     BOOL ret;
     CFStringRef s1 = CFStringCreateWithCharactersNoCopy(NULL, (UniChar*)&wchar, 1, kCFAllocatorNull);
-    CFStringRef s2 = CFStringCreateWithCharactersNoCopy(NULL, string, wcslen(string), kCFAllocatorNull);
+    CFStringRef s2 = CFStringCreateWithCharactersNoCopy(NULL, string, strlenW(string), kCFAllocatorNull);
     CFStringCompareFlags flags = kCFCompareCaseInsensitive | kCFCompareNonliteral | kCFCompareWidthInsensitive;
     if (ignore_diacritics)
         flags |= kCFCompareDiacriticInsensitive;
@@ -444,94 +441,16 @@ static pthread_mutex_t layout_list_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 int macdrv_layout_list_needs_update = TRUE;
 
-static const NLS_LOCALE_HEADER *locale_table;
-
-static int compare_locale_names(const WCHAR *n1, const WCHAR *n2)
-{
-    for (;;)
-    {
-        WCHAR ch1 = *n1++;
-        WCHAR ch2 = *n2++;
-        if (ch1 >= 'a' && ch1 <= 'z') ch1 -= 'a' - 'A';
-        else if (ch1 == '_') ch1 = '-';
-        if (ch2 >= 'a' && ch2 <= 'z') ch2 -= 'a' - 'A';
-        else if (ch2 == '_') ch2 = '-';
-        if (!ch1 || ch1 != ch2) return ch1 - ch2;
-    }
-}
-
-
-static const NLS_LOCALE_LCNAME_INDEX *find_lcname_entry(const WCHAR *name)
-{
-    const NLS_LOCALE_LCNAME_INDEX *lcnames_index;
-    const WCHAR *locale_strings;
-    int min = 0, max = locale_table->nb_lcnames - 1;
-
-    locale_strings = (const WCHAR *)((char *)locale_table + locale_table->strings_offset);
-    lcnames_index = (const NLS_LOCALE_LCNAME_INDEX *)((char *)locale_table + locale_table->lcnames_offset);
-
-    while (min <= max)
-    {
-        int res, pos = (min + max) / 2;
-        const WCHAR *str = locale_strings + lcnames_index[pos].name;
-        res = compare_locale_names(name, str + 1);
-        if (res < 0) max = pos - 1;
-        else if (res > 0) min = pos + 1;
-        else return &lcnames_index[pos];
-    }
-    return NULL;
-}
-
-
 static DWORD get_lcid(CFStringRef lang)
 {
-    const NLS_LOCALE_LCNAME_INDEX *entry;
-    const NLS_LOCALE_DATA *locale;
     CFRange range;
     WCHAR str[10];
-    ULONG offset;
-
-    if (!locale_table)
-    {
-        struct
-        {
-            UINT ctypes;
-            UINT unknown1;
-            UINT unknown2;
-            UINT unknown3;
-            UINT locales;
-            UINT charmaps;
-            UINT geoids;
-            UINT scripts;
-        } *header;
-        LCID system_lcid;
-        LARGE_INTEGER size;
-
-        if (NtInitializeNlsFiles((void **)&header, &system_lcid, &size))
-        {
-            ERR("NtInitializeNlsFiles failed\n");
-            return 0;
-        }
-
-        if (InterlockedCompareExchangePointer((void **)&locale_table,
-                                              (char *)header + header->locales, NULL))
-            NtUnmapViewOfSection(GetCurrentProcess(), header);
-    }
 
     range.location = 0;
     range.length = min(CFStringGetLength(lang), ARRAY_SIZE(str) - 1);
     CFStringGetCharacters(lang, range, str);
     str[range.length] = 0;
-
-    if (!(entry = find_lcname_entry(str)))
-    {
-        ERR("%s not found\n", debugstr_w(str));
-        return 0;
-    }
-
-    offset = locale_table->locales_offset + entry->idx * locale_table->locale_size;
-    locale = (const NLS_LOCALE_DATA *)((const char *)locale_table + offset);
-    return locale->inotneutral ? entry->id : locale->idefaultlanguage;
+    return LocaleNameToLCID(str, 0);
 }
 
 static HKL get_hkl(CFStringRef lang, CFStringRef type)
@@ -1126,9 +1045,9 @@ void macdrv_keyboard_changed(const macdrv_event *event)
 
     macdrv_compute_keyboard_layout(thread_data);
 
-    NtUserActivateKeyboardLayout(thread_data->active_keyboard_layout, 0);
+    ActivateKeyboardLayout(thread_data->active_keyboard_layout, 0);
 
-    send_message(get_active_window(), WM_CANCELMODE, 0, 0);
+    SendMessageW(GetActiveWindow(), WM_CANCELMODE, 0, 0);
 }
 
 
@@ -1190,16 +1109,13 @@ void macdrv_hotkey_press(const macdrv_event *event)
 /***********************************************************************
  *              macdrv_process_text_input
  */
-NTSTATUS macdrv_ime_process_text_input(void *arg)
+void macdrv_process_text_input(UINT vkey, UINT scan, UINT repeat, const BYTE *key_state, void *himc, int* done)
 {
-    struct process_text_input_params *params = arg;
     struct macdrv_thread_data *thread_data = macdrv_thread_data();
-    const BYTE *key_state = params->key_state;
     unsigned int flags;
     int keyc;
 
-    TRACE("vkey 0x%04x scan 0x%04x repeat %u himc %p\n", params->vkey, params->scan,
-          params->repeat, params->himc);
+    TRACE("vkey 0x%04x scan 0x%04x repeat %u himc %p\n", vkey, scan, repeat, himc);
 
     flags = thread_data->last_modifiers;
     if (key_state[VK_SHIFT] & 0x80)
@@ -1221,26 +1137,24 @@ NTSTATUS macdrv_ime_process_text_input(void *arg)
 
     /* Find the Mac keycode corresponding to the scan code */
     for (keyc = 0; keyc < ARRAY_SIZE(thread_data->keyc2vkey); keyc++)
-        if (thread_data->keyc2vkey[keyc] == params->vkey) break;
+        if (thread_data->keyc2vkey[keyc] == vkey) break;
 
     if (keyc >= ARRAY_SIZE(thread_data->keyc2vkey))
     {
-        *params->done = -1;
-        return 0;
+        *done = -1;
+        return;
     }
 
     TRACE("flags 0x%08x keyc 0x%04x\n", flags, keyc);
 
-    macdrv_send_text_input_event(((params->scan & 0x8000) == 0), flags, params->repeat, keyc,
-                                 params->himc, params->done);
-    return 0;
+    macdrv_send_text_input_event(((scan & 0x8000) == 0), flags, repeat, keyc, himc, done);
 }
 
 
 /***********************************************************************
  *              ActivateKeyboardLayout (MACDRV.@)
  */
-BOOL macdrv_ActivateKeyboardLayout(HKL hkl, UINT flags)
+BOOL CDECL macdrv_ActivateKeyboardLayout(HKL hkl, UINT flags)
 {
     BOOL ret = FALSE;
     struct macdrv_thread_data *thread_data = macdrv_init_thread_data();
@@ -1283,7 +1197,7 @@ BOOL macdrv_ActivateKeyboardLayout(HKL hkl, UINT flags)
 /***********************************************************************
  *              Beep (MACDRV.@)
  */
-void macdrv_Beep(void)
+void CDECL macdrv_Beep(void)
 {
     macdrv_beep();
 }
@@ -1292,7 +1206,7 @@ void macdrv_Beep(void)
 /***********************************************************************
  *              GetKeyNameText (MACDRV.@)
  */
-INT macdrv_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
+INT CDECL macdrv_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
 {
     struct macdrv_thread_data *thread_data = macdrv_init_thread_data();
     int scan, keyc;
@@ -1352,11 +1266,9 @@ INT macdrv_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
 
             if (!len)
             {
-                char name[16];
-                len = sprintf(name, "Key 0x%02x", vkey);
-                len = min(len + 1, size);
-                ascii_to_unicode(buffer, name, len);
-                if (len) buffer[--len] = 0;
+                static const WCHAR format[] = {'K','e','y',' ','0','x','%','0','2','x',0};
+                snprintfW(buffer, size, format, vkey);
+                len = strlenW(buffer);
             }
 
             if (!len)
@@ -1365,7 +1277,7 @@ INT macdrv_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
             if (status == noErr && deadKeyState)
             {
                 lstrcpynW(buffer + len, dead, size - len);
-                len = wcslen(buffer);
+                len = strlenW(buffer);
             }
 
             TRACE("lparam 0x%08x -> %s\n", lparam, debugstr_w(buffer));
@@ -1381,7 +1293,7 @@ INT macdrv_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size)
 /***********************************************************************
  *     GetKeyboardLayoutList (MACDRV.@)
  */
-UINT macdrv_GetKeyboardLayoutList(INT size, HKL *list)
+UINT CDECL macdrv_GetKeyboardLayoutList(INT size, HKL *list)
 {
     int count = 0;
     struct layout *layout;
@@ -1413,7 +1325,7 @@ UINT macdrv_GetKeyboardLayoutList(INT size, HKL *list)
 /***********************************************************************
  *              MapVirtualKeyEx (MACDRV.@)
  */
-UINT macdrv_MapVirtualKeyEx(UINT wCode, UINT wMapType, HKL hkl)
+UINT CDECL macdrv_MapVirtualKeyEx(UINT wCode, UINT wMapType, HKL hkl)
 {
     struct macdrv_thread_data *thread_data = macdrv_init_thread_data();
     UINT ret = 0;
@@ -1525,7 +1437,7 @@ UINT macdrv_MapVirtualKeyEx(UINT wCode, UINT wMapType, HKL hkl)
             }
 
             if (status == noErr && len)
-                ret = RtlUpcaseUnicodeChar(s[0]) | (deadKey ? 0x80000000 : 0);
+                ret = toupperW(s[0]) | (deadKey ? 0x80000000 : 0);
 
             break;
         }
@@ -1542,7 +1454,7 @@ UINT macdrv_MapVirtualKeyEx(UINT wCode, UINT wMapType, HKL hkl)
 /***********************************************************************
  *              RegisterHotKey (MACDRV.@)
  */
-BOOL macdrv_RegisterHotKey(HWND hwnd, UINT mod_flags, UINT vkey)
+BOOL CDECL macdrv_RegisterHotKey(HWND hwnd, UINT mod_flags, UINT vkey)
 {
     struct macdrv_thread_data *thread_data = macdrv_init_thread_data();
     unsigned int keyc, modifiers = 0;
@@ -1601,8 +1513,8 @@ BOOL macdrv_RegisterHotKey(HWND hwnd, UINT mod_flags, UINT vkey)
  *              virtual key to form a single character.
  *
  */
-INT macdrv_ToUnicodeEx(UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
-                       LPWSTR bufW, int bufW_size, UINT flags, HKL hkl)
+INT CDECL macdrv_ToUnicodeEx(UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
+                             LPWSTR bufW, int bufW_size, UINT flags, HKL hkl)
 {
     struct macdrv_thread_data *thread_data = macdrv_init_thread_data();
     INT ret = 0;
@@ -1786,7 +1698,7 @@ done:
 /***********************************************************************
  *              UnregisterHotKey (MACDRV.@)
  */
-void macdrv_UnregisterHotKey(HWND hwnd, UINT modifiers, UINT vkey)
+void CDECL macdrv_UnregisterHotKey(HWND hwnd, UINT modifiers, UINT vkey)
 {
     struct macdrv_thread_data *thread_data = macdrv_thread_data();
 
@@ -1802,7 +1714,7 @@ void macdrv_UnregisterHotKey(HWND hwnd, UINT modifiers, UINT vkey)
  *
  * Note: Windows ignores HKL parameter and uses current active layout instead
  */
-SHORT macdrv_VkKeyScanEx(WCHAR wChar, HKL hkl)
+SHORT CDECL macdrv_VkKeyScanEx(WCHAR wChar, HKL hkl)
 {
     struct macdrv_thread_data *thread_data = macdrv_init_thread_data();
     SHORT ret = -1;
diff --git a/dlls/winemac.drv/macdrv.h b/dlls/winemac.drv/macdrv.h
index 7c0f7127883..c9c49d84f87 100644
--- a/dlls/winemac.drv/macdrv.h
+++ b/dlls/winemac.drv/macdrv.h
@@ -30,10 +30,9 @@
 #include "macdrv_cocoa.h"
 #include "windef.h"
 #include "winbase.h"
-#include "ntgdi.h"
+#include "wingdi.h"
 #include "wine/debug.h"
 #include "wine/gdi_driver.h"
-#include "unixlib.h"
 
 
 extern BOOL skip_single_buffer_flushes DECLSPEC_HIDDEN;
@@ -41,9 +40,8 @@
 extern BOOL allow_set_gamma DECLSPEC_HIDDEN;
 extern BOOL allow_software_rendering DECLSPEC_HIDDEN;
 extern BOOL disable_window_decorations DECLSPEC_HIDDEN;
+extern HMODULE macdrv_module DECLSPEC_HIDDEN;
 
-extern NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,
-                                                    BOOLEAN,const LARGE_INTEGER*) DECLSPEC_HIDDEN;
 
 extern const char* debugstr_cf(CFTypeRef t) DECLSPEC_HIDDEN;
 
@@ -116,68 +114,68 @@ static inline RECT rect_from_cgrect(CGRect cgrect)
     WORD                        keyc2scan[128];
 };
 
+extern DWORD thread_data_tls_index DECLSPEC_HIDDEN;
+
 extern struct macdrv_thread_data *macdrv_init_thread_data(void) DECLSPEC_HIDDEN;
 
 static inline struct macdrv_thread_data *macdrv_thread_data(void)
 {
-    return NtUserGetThreadInfo()->driver_data;
+    return TlsGetValue(thread_data_tls_index);
 }
 
 
-extern BOOL macdrv_ActivateKeyboardLayout(HKL hkl, UINT flags) DECLSPEC_HIDDEN;
-extern void macdrv_Beep(void) DECLSPEC_HIDDEN;
-extern LONG macdrv_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
-                                           HWND hwnd, DWORD flags, LPVOID lpvoid) DECLSPEC_HIDDEN;
-extern BOOL macdrv_EnumDisplaySettingsEx(LPCWSTR devname, DWORD mode,
-                                         LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
-extern LRESULT macdrv_ClipboardWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
-extern void macdrv_UpdateDisplayDevices( const struct gdi_device_manager *device_manager,
-                                         BOOL force, void *param ) DECLSPEC_HIDDEN;
-extern BOOL macdrv_GetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp) DECLSPEC_HIDDEN;
-extern BOOL macdrv_SetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp) DECLSPEC_HIDDEN;
-extern BOOL macdrv_ClipCursor(LPCRECT clip) DECLSPEC_HIDDEN;
-extern BOOL macdrv_CreateDesktopWindow(HWND hwnd) DECLSPEC_HIDDEN;
-extern LRESULT macdrv_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
-extern void macdrv_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
-extern void macdrv_SetFocus(HWND hwnd) DECLSPEC_HIDDEN;
-extern void macdrv_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha,
-                                              DWORD flags) DECLSPEC_HIDDEN;
-extern void macdrv_SetParent(HWND hwnd, HWND parent, HWND old_parent) DECLSPEC_HIDDEN;
-extern void macdrv_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
-extern void macdrv_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
-extern void macdrv_SetWindowText(HWND hwnd, LPCWSTR text) DECLSPEC_HIDDEN;
-extern UINT macdrv_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
-extern LRESULT macdrv_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
-extern BOOL macdrv_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
-                                       const RECT *window_rect) DECLSPEC_HIDDEN;
-extern LRESULT macdrv_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
-extern BOOL macdrv_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
-                                     const RECT *window_rect, const RECT *client_rect,
-                                     RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
-extern void macdrv_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
-                                    const RECT *window_rect, const RECT *client_rect,
-                                    const RECT *visible_rect, const RECT *valid_rects,
-                                    struct window_surface *surface) DECLSPEC_HIDDEN;
-extern void macdrv_DestroyCursorIcon(HCURSOR cursor) DECLSPEC_HIDDEN;
-extern BOOL macdrv_ClipCursor(LPCRECT clip) DECLSPEC_HIDDEN;
-extern BOOL macdrv_GetCursorPos(LPPOINT pos) DECLSPEC_HIDDEN;
-extern void macdrv_SetCapture(HWND hwnd, UINT flags) DECLSPEC_HIDDEN;
-extern void macdrv_SetCursor(HCURSOR cursor) DECLSPEC_HIDDEN;
-extern BOOL macdrv_SetCursorPos(INT x, INT y) DECLSPEC_HIDDEN;
-extern BOOL macdrv_RegisterHotKey(HWND hwnd, UINT mod_flags, UINT vkey) DECLSPEC_HIDDEN;
-extern void macdrv_UnregisterHotKey(HWND hwnd, UINT modifiers, UINT vkey) DECLSPEC_HIDDEN;
-extern SHORT macdrv_VkKeyScanEx(WCHAR wChar, HKL hkl) DECLSPEC_HIDDEN;
-extern UINT macdrv_MapVirtualKeyEx(UINT wCode, UINT wMapType, HKL hkl) DECLSPEC_HIDDEN;
-extern INT macdrv_ToUnicodeEx(UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
-                              LPWSTR bufW, int bufW_size, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
-extern UINT macdrv_GetKeyboardLayoutList(INT size, HKL *list) DECLSPEC_HIDDEN;
-extern INT macdrv_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) DECLSPEC_HIDDEN;
-extern BOOL macdrv_SystemParametersInfo(UINT action, UINT int_param, void *ptr_param,
-                                        UINT flags) DECLSPEC_HIDDEN;
-extern NTSTATUS macdrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
-                                                   const LARGE_INTEGER *timeout, DWORD mask,
-                                                   DWORD flags) DECLSPEC_HIDDEN;
-extern void macdrv_ThreadDetach(void) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_ActivateKeyboardLayout(HKL hkl, UINT flags) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_Beep(void) DECLSPEC_HIDDEN;
+extern LONG CDECL macdrv_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
+                                                 HWND hwnd, DWORD flags, LPVOID lpvoid) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_EnumDisplaySettingsEx(LPCWSTR devname, DWORD mode,
+                                               LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_UpdateDisplayDevices( const struct gdi_device_manager *device_manager,
+                                               BOOL force, void *param ) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_GetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_SetDeviceGammaRamp(PHYSDEV dev, LPVOID ramp) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_ClipCursor(LPCRECT clip) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_CreateDesktopWindow(HWND hwnd) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_SetFocus(HWND hwnd) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha,
+                                                    DWORD flags) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_SetParent(HWND hwnd, HWND parent, HWND old_parent) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_SetWindowText(HWND hwnd, LPCWSTR text) DECLSPEC_HIDDEN;
+extern UINT CDECL macdrv_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
+extern LRESULT CDECL macdrv_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                             const RECT *window_rect) DECLSPEC_HIDDEN;
+extern LRESULT CDECL macdrv_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                           const RECT *window_rect, const RECT *client_rect,
+                                           RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                          const RECT *window_rect, const RECT *client_rect,
+                                          const RECT *visible_rect, const RECT *valid_rects,
+                                          struct window_surface *surface) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_DestroyCursorIcon(HCURSOR cursor) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_ClipCursor(LPCRECT clip) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_GetCursorPos(LPPOINT pos) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_SetCapture(HWND hwnd, UINT flags) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_SetCursor(HCURSOR cursor) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_SetCursorPos(INT x, INT y) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_RegisterHotKey(HWND hwnd, UINT mod_flags, UINT vkey) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_UnregisterHotKey(HWND hwnd, UINT modifiers, UINT vkey) DECLSPEC_HIDDEN;
+extern SHORT CDECL macdrv_VkKeyScanEx(WCHAR wChar, HKL hkl) DECLSPEC_HIDDEN;
+extern UINT CDECL macdrv_MapVirtualKeyEx(UINT wCode, UINT wMapType, HKL hkl) DECLSPEC_HIDDEN;
+extern INT CDECL macdrv_ToUnicodeEx(UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
+                                    LPWSTR bufW, int bufW_size, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
+extern UINT CDECL macdrv_GetKeyboardLayoutList(INT size, HKL *list) DECLSPEC_HIDDEN;
+extern INT CDECL macdrv_GetKeyNameText(LONG lparam, LPWSTR buffer, INT size) DECLSPEC_HIDDEN;
+extern BOOL CDECL macdrv_SystemParametersInfo(UINT action, UINT int_param, void *ptr_param,
+                                              UINT flags) DECLSPEC_HIDDEN;
+extern DWORD CDECL macdrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
+                                                      DWORD timeout, DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_ThreadDetach(void) DECLSPEC_HIDDEN;
 
 
 /* macdrv private window data */
@@ -243,7 +241,7 @@ extern NTSTATUS macdrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *ha
 extern void macdrv_mouse_moved(HWND hwnd, const macdrv_event *event) DECLSPEC_HIDDEN;
 extern void macdrv_mouse_scroll(HWND hwnd, const macdrv_event *event) DECLSPEC_HIDDEN;
 extern void macdrv_release_capture(HWND hwnd, const macdrv_event *event) DECLSPEC_HIDDEN;
-extern void macdrv_SetCapture(HWND hwnd, UINT flags) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_SetCapture(HWND hwnd, UINT flags) DECLSPEC_HIDDEN;
 
 extern void macdrv_compute_keyboard_layout(struct macdrv_thread_data *thread_data) DECLSPEC_HIDDEN;
 extern void macdrv_keyboard_changed(const macdrv_event *event) DECLSPEC_HIDDEN;
@@ -253,12 +251,21 @@ extern NTSTATUS macdrv_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *ha
 
 extern void macdrv_displays_changed(const macdrv_event *event) DECLSPEC_HIDDEN;
 
-extern void macdrv_UpdateClipboard(void) DECLSPEC_HIDDEN;
+extern void CDECL macdrv_UpdateClipboard(void) DECLSPEC_HIDDEN;
+extern void macdrv_init_clipboard(void) DECLSPEC_HIDDEN;
 extern BOOL query_pasteboard_data(HWND hwnd, CFStringRef type) DECLSPEC_HIDDEN;
 extern void macdrv_lost_pasteboard_ownership(HWND hwnd) DECLSPEC_HIDDEN;
+extern const char *debugstr_format(UINT id) DECLSPEC_HIDDEN;
+extern HANDLE macdrv_get_pasteboard_data(CFTypeRef pasteboard, UINT desired_format) DECLSPEC_HIDDEN;
+extern BOOL macdrv_pasteboard_has_format(CFTypeRef pasteboard, UINT desired_format) DECLSPEC_HIDDEN;
+extern UINT* macdrv_get_pasteboard_formats(CFTypeRef pasteboard, UINT* num_formats) DECLSPEC_HIDDEN;
+
+extern BOOL query_drag_operation(macdrv_query* query) DECLSPEC_HIDDEN;
+extern BOOL query_drag_exited(macdrv_query* query) DECLSPEC_HIDDEN;
+extern BOOL query_drag_drop(macdrv_query* query) DECLSPEC_HIDDEN;
 
-extern struct opengl_funcs *macdrv_wine_get_wgl_driver(UINT version) DECLSPEC_HIDDEN;
-extern const struct vulkan_funcs *macdrv_wine_get_vulkan_driver(UINT version) DECLSPEC_HIDDEN;
+extern struct opengl_funcs * CDECL macdrv_wine_get_wgl_driver(UINT version) DECLSPEC_HIDDEN;
+extern const struct vulkan_funcs * CDECL macdrv_wine_get_vulkan_driver(UINT version) DECLSPEC_HIDDEN;
 extern void sync_gl_view(struct macdrv_win_data* data, const RECT* old_whole_rect, const RECT* old_client_rect) DECLSPEC_HIDDEN;
 
 extern CGImageRef create_cgimage_from_icon_bitmaps(HDC hdc, HANDLE icon, HBITMAP hbmColor,
@@ -275,65 +282,16 @@ extern CGImageRef create_cgimage_from_icon_bitmaps(HDC hdc, HANDLE icon, HBITMAP
 extern void macdrv_init_display_devices(BOOL force) DECLSPEC_HIDDEN;
 extern void init_user_driver(void) DECLSPEC_HIDDEN;
 
-/* unixlib interface */
-
-extern NTSTATUS macdrv_dnd_get_data(void *arg) DECLSPEC_HIDDEN;
-extern NTSTATUS macdrv_dnd_get_formats(void *arg) DECLSPEC_HIDDEN;
-extern NTSTATUS macdrv_dnd_have_format(void *arg) DECLSPEC_HIDDEN;
-extern NTSTATUS macdrv_dnd_release(void *arg) DECLSPEC_HIDDEN;
-extern NTSTATUS macdrv_dnd_retain(void *arg) DECLSPEC_HIDDEN;
-extern NTSTATUS macdrv_ime_process_text_input(void *arg) DECLSPEC_HIDDEN;
-extern NTSTATUS macdrv_notify_icon(void *arg) DECLSPEC_HIDDEN;
-
-extern NTSTATUS macdrv_client_func(enum macdrv_client_funcs func, const void *params,
-                                   ULONG size) DECLSPEC_HIDDEN;
-
-/* user helpers */
-
-static inline LRESULT send_message(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
-{
-    return NtUserMessageCall(hwnd, msg, wparam, lparam, NULL, NtUserSendMessage, FALSE);
-}
-
-static inline LRESULT send_message_timeout(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                           UINT flags, UINT timeout, PDWORD_PTR res_ptr)
-{
-    struct send_message_timeout_params params = { .flags = flags, .timeout = timeout };
-    LRESULT res = NtUserMessageCall(hwnd, msg, wparam, lparam, &params,
-                                    NtUserSendMessageTimeout, FALSE);
-    if (res_ptr) *res_ptr = params.result;
-    return res;
-}
-
-static inline HWND get_active_window(void)
-{
-    GUITHREADINFO info;
-    info.cbSize = sizeof(info);
-    return NtUserGetGUIThreadInfo(GetCurrentThreadId(), &info) ? info.hwndActive : 0;
-}
-
-static inline HWND get_capture(void)
-{
-    GUITHREADINFO info;
-    info.cbSize = sizeof(info);
-    return NtUserGetGUIThreadInfo(GetCurrentThreadId(), &info) ? info.hwndCapture : 0;
-}
+/**************************************************************************
+ * Mac IME driver
+ */
 
-static inline HWND get_focus(void)
-{
-    GUITHREADINFO info;
-    info.cbSize = sizeof(info);
-    return NtUserGetGUIThreadInfo(GetCurrentThreadId(), &info) ? info.hwndFocus : 0;
-}
+extern void macdrv_process_text_input(UINT vkey, UINT scan, UINT repeat, const BYTE *key_state,
+                                      void *himc, int* done) DECLSPEC_HIDDEN;
 
-static inline BOOL intersect_rect( RECT *dst, const RECT *src1, const RECT *src2 )
-{
-    dst->left   = max(src1->left, src2->left);
-    dst->top    = max(src1->top, src2->top);
-    dst->right  = min(src1->right, src2->right);
-    dst->bottom = min(src1->bottom, src2->bottom);
-    return !IsRectEmpty( dst );
-}
+extern void macdrv_im_set_text(const macdrv_event *event) DECLSPEC_HIDDEN;
+extern void macdrv_sent_text_input(const macdrv_event *event) DECLSPEC_HIDDEN;
+extern BOOL query_ime_char_rect(macdrv_query* query) DECLSPEC_HIDDEN;
 
 /* registry helpers */
 
@@ -361,4 +319,9 @@ static inline UINT asciiz_to_unicode(WCHAR *dst, const char *src)
     return (p - dst) * sizeof(WCHAR);
 }
 
+/* FIXME: remove once we use unixlib */
+#define wcsnicmp strncmpiW
+#define wcsrchr strrchrW
+#define wcstol strtolW
+
 #endif  /* __WINE_MACDRV_H */
diff --git a/dlls/winemac.drv/macdrv_cocoa.h b/dlls/winemac.drv/macdrv_cocoa.h
index 27b130ca32e..94f9fbcfa17 100644
--- a/dlls/winemac.drv/macdrv_cocoa.h
+++ b/dlls/winemac.drv/macdrv_cocoa.h
@@ -328,7 +328,7 @@ extern int macdrv_set_display_mode(const struct macdrv_display* display,
     KEYBOARD_CHANGED,
     LOST_PASTEBOARD_OWNERSHIP,
     MOUSE_BUTTON,
-    MOUSE_MOVED_RELATIVE,
+    MOUSE_MOVED,
     MOUSE_MOVED_ABSOLUTE,
     MOUSE_SCROLL,
     QUERY_EVENT,
diff --git a/dlls/winemac.drv/macdrv_dll.h b/dlls/winemac.drv/macdrv_dll.h
deleted file mode 100644
index 3a11528eabc..00000000000
--- a/dlls/winemac.drv/macdrv_dll.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * MAC driver definitions
- *
- * Copyright 2022 Jacek Caban for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#ifndef __WINE_MACDRV_DLL_H
-#define __WINE_MACDRV_DLL_H
-
-#include <stdarg.h>
-#include "windef.h"
-#include "winbase.h"
-#include "ntgdi.h"
-#include "unixlib.h"
-
-extern NTSTATUS WINAPI macdrv_dnd_query_drag(void *arg, ULONG size) DECLSPEC_HIDDEN;
-extern NTSTATUS WINAPI macdrv_dnd_query_drop(void *arg, ULONG size) DECLSPEC_HIDDEN;
-extern NTSTATUS WINAPI macdrv_dnd_query_exited(void *arg, ULONG size) DECLSPEC_HIDDEN;
-
-extern NTSTATUS WINAPI macdrv_ime_set_text(void *params, ULONG size) DECLSPEC_HIDDEN;
-extern NTSTATUS WINAPI macdrv_ime_query_char_rect(void *params, ULONG size) DECLSPEC_HIDDEN;
-
-extern HMODULE macdrv_module DECLSPEC_HIDDEN;
-
-#endif /* __WINE_MACDRV_DLL_H */
diff --git a/dlls/winemac.drv/macdrv_main.c b/dlls/winemac.drv/macdrv_main.c
index e1fd7b2d331..b53ec56ae16 100644
--- a/dlls/winemac.drv/macdrv_main.c
+++ b/dlls/winemac.drv/macdrv_main.c
@@ -19,11 +19,6 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <Security/AuthSession.h>
@@ -32,7 +27,10 @@
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "macdrv.h"
+#include "winuser.h"
+#include "winreg.h"
 #include "wine/server.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(macdrv);
 
@@ -48,6 +46,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(macdrv);
 
 C_ASSERT(NUM_EVENT_TYPES <= sizeof(macdrv_event_mask) * 8);
 
+DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
+
 int topmost_float_inactive = TOPMOST_FLOAT_INACTIVE_NONFULLSCREEN;
 int capture_displays_for_fullscreen = 0;
 BOOL skip_single_buffer_flushes = FALSE;
@@ -65,12 +65,11 @@ int cursor_clipping_locks_windows = TRUE;
 int use_precise_scrolling = TRUE;
 int gl_surface_mode = GL_SURFACE_IN_FRONT_OPAQUE;
 int retina_enabled = FALSE;
+HMODULE macdrv_module = 0;
 int enable_app_nap = FALSE;
 
 CFDictionaryRef localized_strings;
 
-NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,
-                                             BOOLEAN,const LARGE_INTEGER*);
 
 /**************************************************************************
  *              debugstr_cf
@@ -317,9 +316,9 @@ static void setup_options(void)
     {
         static const WCHAR noneW[] = {'n','o','n','e',0};
         static const WCHAR allW[] = {'a','l','l',0};
-        if (!wcscmp(buffer, noneW))
+        if (!lstrcmpW(buffer, noneW))
             topmost_float_inactive = TOPMOST_FLOAT_INACTIVE_NONE;
-        else if (!wcscmp(buffer, allW))
+        else if (!lstrcmpW(buffer, allW))
             topmost_float_inactive = TOPMOST_FLOAT_INACTIVE_ALL;
         else
             topmost_float_inactive = TOPMOST_FLOAT_INACTIVE_NONFULLSCREEN;
@@ -375,9 +374,9 @@ static void setup_options(void)
     {
         static const WCHAR transparentW[] = {'t','r','a','n','s','p','a','r','e','n','t',0};
         static const WCHAR behindW[] = {'b','e','h','i','n','d',0};
-        if (!wcscmp(buffer, transparentW))
+        if (!lstrcmpW(buffer, transparentW))
             gl_surface_mode = GL_SURFACE_IN_FRONT_TRANSPARENT;
-        else if (!wcscmp(buffer, behindW))
+        else if (!lstrcmpW(buffer, behindW))
             gl_surface_mode = GL_SURFACE_BEHIND;
         else
             gl_surface_mode = GL_SURFACE_IN_FRONT_OPAQUE;
@@ -399,9 +398,25 @@ static void setup_options(void)
 /***********************************************************************
  *              load_strings
  */
-static void load_strings(struct localized_string *str)
+static void load_strings(HINSTANCE instance)
 {
+    static const unsigned int ids[] = {
+        STRING_MENU_WINE,
+        STRING_MENU_ITEM_HIDE_APPNAME,
+        STRING_MENU_ITEM_HIDE,
+        STRING_MENU_ITEM_HIDE_OTHERS,
+        STRING_MENU_ITEM_SHOW_ALL,
+        STRING_MENU_ITEM_QUIT_APPNAME,
+        STRING_MENU_ITEM_QUIT,
+
+        STRING_MENU_WINDOW,
+        STRING_MENU_ITEM_MINIMIZE,
+        STRING_MENU_ITEM_ZOOM,
+        STRING_MENU_ITEM_ENTER_FULL_SCREEN,
+        STRING_MENU_ITEM_BRING_ALL_TO_FRONT,
+    };
     CFMutableDictionaryRef dict;
+    int i;
 
     dict = CFDictionaryCreateMutable(NULL, 0, &kCFTypeDictionaryKeyCallBacks,
                                      &kCFTypeDictionaryValueCallBacks);
@@ -411,66 +426,63 @@ static void load_strings(struct localized_string *str)
         return;
     }
 
-    while (str->id)
+    for (i = 0; i < ARRAY_SIZE(ids); i++)
     {
-        if (str->str && str->len)
+        LPCWSTR str;
+        int len = LoadStringW(instance, ids[i], (LPWSTR)&str, 0);
+        if (str && len)
         {
-            CFNumberRef key = CFNumberCreate(NULL, kCFNumberIntType, &str->id);
-            CFStringRef value = CFStringCreateWithCharacters(NULL, (UniChar*)str->str, str->len);
+            CFNumberRef key = CFNumberCreate(NULL, kCFNumberIntType, &ids[i]);
+            CFStringRef value = CFStringCreateWithCharacters(NULL, (UniChar*)str, len);
             if (key && value)
                 CFDictionarySetValue(dict, key, value);
             else
-                ERR("Failed to add string ID 0x%04x %s\n", str->id, debugstr_wn(str->str, str->len));
+                ERR("Failed to add string ID 0x%04x %s\n", ids[i], debugstr_wn(str, len));
         }
         else
-            ERR("Failed to load string ID 0x%04x\n", str->id);
-        str++;
+            ERR("Failed to load string ID 0x%04x\n", ids[i]);
     }
 
     localized_strings = dict;
 }
 
 
-static NTSTATUS CDECL unix_call( enum macdrv_funcs code, void *params );
-
-
 /***********************************************************************
- *              macdrv_init
+ *              process_attach
  */
-static NTSTATUS macdrv_init(void *arg)
+static BOOL process_attach(void)
 {
-    struct init_params *params = arg;
     SessionAttributeBits attributes;
     OSStatus status;
 
     status = SessionGetInfo(callerSecuritySession, NULL, &attributes);
     if (status != noErr || !(attributes & sessionHasGraphicAccess))
-        return STATUS_UNSUCCESSFUL;
+        return FALSE;
 
     init_win_context();
     setup_options();
-    load_strings(params->strings);
+    load_strings(macdrv_module);
+
+    if ((thread_data_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) return FALSE;
 
     macdrv_err_on = ERR_ON(macdrv);
-    if (macdrv_start_cocoa_app(NtGetTickCount()))
+    if (macdrv_start_cocoa_app(GetTickCount64()))
     {
         ERR("Failed to start Cocoa app main loop\n");
-        return STATUS_UNSUCCESSFUL;
+        return FALSE;
     }
 
     init_user_driver();
     macdrv_init_display_devices(FALSE);
 
-    pNtWaitForMultipleObjects = params->pNtWaitForMultipleObjects;
-    params->unix_call = unix_call;
-    return STATUS_SUCCESS;
+    return TRUE;
 }
 
 
 /***********************************************************************
  *              ThreadDetach   (MACDRV.@)
  */
-void macdrv_ThreadDetach(void)
+void CDECL macdrv_ThreadDetach(void)
 {
     struct macdrv_thread_data *data = macdrv_thread_data();
 
@@ -481,7 +493,7 @@ void macdrv_ThreadDetach(void)
             CFRelease(data->keyboard_layout_uchr);
         free(data);
         /* clear data in case we get re-entered from user32 before the thread is truly dead */
-        NtUserGetThreadInfo()->driver_data = 0;
+        TlsSetValue(thread_data_tls_index, NULL);
     }
 }
 
@@ -499,7 +511,7 @@ static void set_queue_display_fd(int fd)
     if (wine_server_fd_to_handle(fd, GENERIC_READ | SYNCHRONIZE, 0, &handle))
     {
         MESSAGE("macdrv: Can't allocate handle for event queue fd\n");
-        NtTerminateProcess(0, 1);
+        ExitProcess(1);
     }
     SERVER_START_REQ(set_queue_fd)
     {
@@ -510,9 +522,9 @@ static void set_queue_display_fd(int fd)
     if (ret)
     {
         MESSAGE("macdrv: Can't store handle for event queue fd\n");
-        NtTerminateProcess(0, 1);
+        ExitProcess(1);
     }
-    NtClose(handle);
+    CloseHandle(handle);
 }
 
 
@@ -529,13 +541,13 @@ struct macdrv_thread_data *macdrv_init_thread_data(void)
     if (!(data = calloc(1, sizeof(*data))))
     {
         ERR("could not create data\n");
-        NtTerminateProcess(0, 1);
+        ExitProcess(1);
     }
 
     if (!(data->queue = macdrv_create_event_queue(macdrv_handle_event)))
     {
         ERR("macdrv: Can't create event queue.\n");
-        NtTerminateProcess(0, 1);
+        ExitProcess(1);
     }
 
     macdrv_get_input_source_info(&data->keyboard_layout_uchr, &data->keyboard_type, &data->iso_keyboard, &input_source);
@@ -544,17 +556,35 @@ struct macdrv_thread_data *macdrv_init_thread_data(void)
     macdrv_compute_keyboard_layout(data);
 
     set_queue_display_fd(macdrv_get_event_queue_fd(data->queue));
-    NtUserGetThreadInfo()->driver_data = data;
+    TlsSetValue(thread_data_tls_index, data);
 
-    NtUserActivateKeyboardLayout(data->active_keyboard_layout, 0);
+    ActivateKeyboardLayout(data->active_keyboard_layout, 0);
     return data;
 }
 
 
+/***********************************************************************
+ *              DllMain
+ */
+BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, LPVOID reserved)
+{
+    BOOL ret = TRUE;
+
+    switch(reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls( hinst );
+        macdrv_module = hinst;
+        ret = process_attach();
+        break;
+    }
+    return ret;
+}
+
 /***********************************************************************
  *              SystemParametersInfo (MACDRV.@)
  */
-BOOL macdrv_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param, UINT flags )
+BOOL CDECL macdrv_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param, UINT flags )
 {
     switch (action)
     {
@@ -614,57 +644,3 @@ BOOL macdrv_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param,
     }
     return FALSE;
 }
-
-
-NTSTATUS macdrv_client_func(enum macdrv_client_funcs id, const void *params, ULONG size)
-{
-    void *ret_ptr;
-    ULONG ret_len;
-    return KeUserModeCallback(id, params, size, &ret_ptr, &ret_len);
-}
-
-
-static NTSTATUS macdrv_ime_clear(void *arg)
-{
-    macdrv_clear_ime_text();
-    return 0;
-}
-
-
-static NTSTATUS macdrv_ime_using_input_method(void *arg)
-{
-    return macdrv_using_input_method();
-}
-
-
-static NTSTATUS macdrv_quit_result(void *arg)
-{
-    struct quit_result_params *params = arg;
-    macdrv_quit_reply(params->result);
-    return 0;
-}
-
-
-const unixlib_entry_t __wine_unix_call_funcs[] =
-{
-    macdrv_dnd_get_data,
-    macdrv_dnd_get_formats,
-    macdrv_dnd_have_format,
-    macdrv_dnd_release,
-    macdrv_dnd_retain,
-    macdrv_ime_clear,
-    macdrv_ime_process_text_input,
-    macdrv_ime_using_input_method,
-    macdrv_init,
-    macdrv_notify_icon,
-    macdrv_quit_result,
-};
-
-C_ASSERT( ARRAYSIZE(__wine_unix_call_funcs) == unix_funcs_count );
-
-
-/* FIXME: Use __wine_unix_call instead */
-static NTSTATUS CDECL unix_call(enum macdrv_funcs code, void *params)
-{
-    return __wine_unix_call_funcs[code]( params );
-}
diff --git a/dlls/winemac.drv/mouse.c b/dlls/winemac.drv/mouse.c
index 3f79dda2073..5c854a6e26d 100644
--- a/dlls/winemac.drv/mouse.c
+++ b/dlls/winemac.drv/mouse.c
@@ -20,15 +20,14 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #define OEMRESOURCE
 #include "macdrv.h"
+#include "winuser.h"
+#include "winreg.h"
 #include "wine/server.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(cursor);
 
@@ -132,7 +131,7 @@ static void send_mouse_input(HWND hwnd, macdrv_window cocoa_window, UINT flags,
     INPUT input;
     HWND top_level_hwnd;
 
-    top_level_hwnd = NtUserGetAncestor(hwnd, GA_ROOT);
+    top_level_hwnd = GetAncestor(hwnd, GA_ROOT);
 
     if ((flags & MOUSEEVENTF_MOVE) && (flags & MOUSEEVENTF_ABSOLUTE) && !drag &&
         cocoa_window != macdrv_thread_data()->capture_window)
@@ -167,10 +166,11 @@ static void send_mouse_input(HWND hwnd, macdrv_window cocoa_window, UINT flags,
  */
 CFStringRef copy_system_cursor_name(ICONINFOEXW *info)
 {
+    static const WCHAR idW[] = {'%','h','u',0};
     const struct system_cursors *cursors;
     unsigned int i;
     CFStringRef cursor_name = NULL;
-    const WCHAR *module;
+    HMODULE module;
     HKEY key;
     WCHAR *p, name[MAX_PATH * 2];
 
@@ -179,17 +179,12 @@ CFStringRef copy_system_cursor_name(ICONINFOEXW *info)
 
     if (!info->szModName[0]) return NULL;
 
-    p = wcsrchr(info->szModName, '\\');
-    wcscpy(name, p ? p + 1 : info->szModName);
-    p = name + wcslen(name);
+    p = strrchrW(info->szModName, '\\');
+    strcpyW(name, p ? p + 1 : info->szModName);
+    p = name + strlenW(name);
     *p++ = ',';
-    if (info->szResName[0]) wcscpy(p, info->szResName);
-    else
-    {
-        char buf[16];
-        sprintf(buf, "%hu", info->wResID);
-        asciiz_to_unicode(p, buf);
-    }
+    if (info->szResName[0]) strcpyW(p, info->szResName);
+    else sprintfW(p, idW, info->wResID);
 
     /* @@ Wine registry key: HKCU\Software\Wine\Mac Driver\Cursors */
     if (!(key = open_hkcu_key("Software\\Wine\\Mac Driver\\Cursors")))
@@ -209,7 +204,7 @@ CFStringRef copy_system_cursor_name(ICONINFOEXW *info)
                 return NULL; /* force standard cursor */
             }
 
-            cursor_name = CFStringCreateWithCharacters(NULL, value, wcslen(value));
+            cursor_name = CFStringCreateWithCharacters(NULL, value, strlenW(value));
             if (!cursor_name)
             {
                 WARN("CFStringCreateWithCharacters failed for %s\n", debugstr_w(value));
@@ -228,11 +223,10 @@ CFStringRef copy_system_cursor_name(ICONINFOEXW *info)
     }
 
     if (info->szResName[0]) goto done;  /* only integer resources are supported here */
+    if (!(module = GetModuleHandleW(info->szModName))) goto done;
 
-    if ((module = wcsrchr(info->szModName, '\\'))) module++;
-    else module = info->szModName;
-    for (i = 0; i < ARRAY_SIZE( module_cursors ); i++)
-        if (!wcsicmp(module, module_cursors[i].name)) break;
+    for (i = 0; i < ARRAY_SIZE(module_cursors); i++)
+        if (GetModuleHandleW(module_cursors[i].name) == module) break;
     if (i == ARRAY_SIZE(module_cursors)) goto done;
 
     cursors = module_cursors[i].cursors;
@@ -506,7 +500,7 @@ static CFDictionaryRef create_cursor_frame(HDC hdc, const ICONINFOEXW *iinfo, HA
     CFDictionarySetValue(frame, CFSTR("hotSpot"), hot_spot_dict);
     CFRelease(hot_spot_dict);
 
-    if (NtUserGetCursorFrameInfo(icon, istep, &delay_jiffies, &num_steps) != 0)
+    if (GetCursorFrameInfo(icon, 0x0 /* unknown parameter */, istep, &delay_jiffies, &num_steps) != 0)
         duration = delay_jiffies / 60.0; /* convert jiffies (1/60s) to seconds */
     else
     {
@@ -560,7 +554,7 @@ static CFArrayRef create_color_cursor(HDC hdc, const ICONINFOEXW *iinfo, HANDLE
     TRACE("hdc %p iinfo %p icon %p width %d height %d\n", hdc, iinfo, icon, width, height);
 
     /* Retrieve the number of frames to render */
-    if (!NtUserGetCursorFrameInfo(icon, 0, &delay_jiffies, &nFrames))
+    if (!GetCursorFrameInfo(icon, 0x0 /* unknown parameter */, 0, &delay_jiffies, &nFrames))
     {
         WARN("GetCursorFrameInfo failed\n");
         return NULL;
@@ -643,7 +637,7 @@ cleanup:
 /***********************************************************************
  *              DestroyCursorIcon (MACDRV.@)
  */
-void macdrv_DestroyCursorIcon(HCURSOR cursor)
+void CDECL macdrv_DestroyCursorIcon(HCURSOR cursor)
 {
     TRACE("cursor %p\n", cursor);
 
@@ -659,7 +653,7 @@ void macdrv_DestroyCursorIcon(HCURSOR cursor)
  *
  * Set the cursor clipping rectangle.
  */
-BOOL macdrv_ClipCursor(LPCRECT clip)
+BOOL CDECL macdrv_ClipCursor(LPCRECT clip)
 {
     CGRect rect;
 
@@ -683,7 +677,7 @@ BOOL macdrv_ClipCursor(LPCRECT clip)
 /***********************************************************************
  *              GetCursorPos (MACDRV.@)
  */
-BOOL macdrv_GetCursorPos(LPPOINT pos)
+BOOL CDECL macdrv_GetCursorPos(LPPOINT pos)
 {
     CGPoint pt;
     BOOL ret;
@@ -702,10 +696,10 @@ BOOL macdrv_GetCursorPos(LPPOINT pos)
 /***********************************************************************
  *              SetCapture (MACDRV.@)
  */
- void macdrv_SetCapture(HWND hwnd, UINT flags)
+ void CDECL macdrv_SetCapture(HWND hwnd, UINT flags)
 {
     struct macdrv_thread_data *thread_data = macdrv_thread_data();
-    HWND top = NtUserGetAncestor(hwnd, GA_ROOT);
+    HWND top = GetAncestor(hwnd, GA_ROOT);
     macdrv_window cocoa_window = macdrv_get_cocoa_window(top, FALSE);
 
     TRACE("hwnd %p top %p/%p flags 0x%08x\n", hwnd, top, cocoa_window, flags);
@@ -717,32 +711,10 @@ BOOL macdrv_GetCursorPos(LPPOINT pos)
 }
 
 
-static BOOL get_icon_info(HICON handle, ICONINFOEXW *ret)
-{
-    UNICODE_STRING module, res_name;
-    ICONINFO info;
-
-    module.Buffer = ret->szModName;
-    module.MaximumLength = sizeof(ret->szModName) - sizeof(WCHAR);
-    res_name.Buffer = ret->szResName;
-    res_name.MaximumLength = sizeof(ret->szResName) - sizeof(WCHAR);
-    if (!NtUserGetIconInfo(handle, &info, &module, &res_name, NULL, 0)) return FALSE;
-    ret->fIcon    = info.fIcon;
-    ret->xHotspot = info.xHotspot;
-    ret->yHotspot = info.yHotspot;
-    ret->hbmColor = info.hbmColor;
-    ret->hbmMask  = info.hbmMask;
-    ret->wResID   = res_name.Length ? 0 : LOWORD(res_name.Buffer);
-    ret->szModName[module.Length] = 0;
-    ret->szResName[res_name.Length] = 0;
-    return TRUE;
-}
-
-
 /***********************************************************************
  *              SetCursor (MACDRV.@)
  */
-void macdrv_SetCursor(HCURSOR cursor)
+void CDECL macdrv_SetCursor(HCURSOR cursor)
 {
     CFStringRef cursor_name = NULL;
     CFArrayRef cursor_frames = NULL;
@@ -770,7 +742,7 @@ void macdrv_SetCursor(HCURSOR cursor)
             goto done;
 
         info.cbSize = sizeof(info);
-        if (!get_icon_info(cursor, &info))
+        if (!GetIconInfoExW(cursor, &info))
         {
             WARN("GetIconInfoExW failed\n");
             return;
@@ -835,7 +807,7 @@ done:
 /***********************************************************************
  *              SetCursorPos (MACDRV.@)
  */
-BOOL macdrv_SetCursorPos(INT x, INT y)
+BOOL CDECL macdrv_SetCursorPos(INT x, INT y)
 {
     BOOL ret = macdrv_set_cursor_position(CGPointMake(x, y));
     if (ret)
@@ -859,7 +831,7 @@ void macdrv_mouse_button(HWND hwnd, const macdrv_event *event)
     TRACE("win %p button %d %s at (%d,%d) time %lu (%lu ticks ago)\n", hwnd, event->mouse_button.button,
           (event->mouse_button.pressed ? "pressed" : "released"),
           event->mouse_button.x, event->mouse_button.y,
-          event->mouse_button.time_ms, (NtGetTickCount() - event->mouse_button.time_ms));
+          event->mouse_button.time_ms, (GetTickCount() - event->mouse_button.time_ms));
 
     if (event->mouse_button.pressed)
     {
@@ -897,16 +869,16 @@ void macdrv_mouse_button(HWND hwnd, const macdrv_event *event)
 /***********************************************************************
  *              macdrv_mouse_moved
  *
- * Handler for MOUSE_MOVED_RELATIVE and MOUSE_MOVED_ABSOLUTE events.
+ * Handler for MOUSE_MOVED and MOUSE_MOVED_ABSOLUTE events.
  */
 void macdrv_mouse_moved(HWND hwnd, const macdrv_event *event)
 {
     UINT flags = MOUSEEVENTF_MOVE;
 
     TRACE("win %p/%p %s (%d,%d) drag %d time %lu (%lu ticks ago)\n", hwnd, event->window,
-          (event->type == MOUSE_MOVED_RELATIVE) ? "relative" : "absolute",
+          (event->type == MOUSE_MOVED) ? "relative" : "absolute",
           event->mouse_moved.x, event->mouse_moved.y, event->mouse_moved.drag,
-          event->mouse_moved.time_ms, (NtGetTickCount() - event->mouse_moved.time_ms));
+          event->mouse_moved.time_ms, (GetTickCount() - event->mouse_moved.time_ms));
 
     if (event->type == MOUSE_MOVED_ABSOLUTE)
         flags |= MOUSEEVENTF_ABSOLUTE;
@@ -926,7 +898,7 @@ void macdrv_mouse_scroll(HWND hwnd, const macdrv_event *event)
     TRACE("win %p/%p scroll (%d,%d) at (%d,%d) time %lu (%lu ticks ago)\n", hwnd,
           event->window, event->mouse_scroll.x_scroll, event->mouse_scroll.y_scroll,
           event->mouse_scroll.x, event->mouse_scroll.y,
-          event->mouse_scroll.time_ms, (NtGetTickCount() - event->mouse_scroll.time_ms));
+          event->mouse_scroll.time_ms, (GetTickCount() - event->mouse_scroll.time_ms));
 
     if (event->mouse_scroll.y_scroll)
         send_mouse_input(hwnd, event->window, MOUSEEVENTF_WHEEL | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE,
@@ -947,16 +919,16 @@ void macdrv_mouse_scroll(HWND hwnd, const macdrv_event *event)
 void macdrv_release_capture(HWND hwnd, const macdrv_event *event)
 {
     struct macdrv_thread_data *thread_data = macdrv_thread_data();
-    HWND capture = get_capture();
-    HWND capture_top = NtUserGetAncestor(capture, GA_ROOT);
+    HWND capture = GetCapture();
+    HWND capture_top = GetAncestor(capture, GA_ROOT);
 
     TRACE("win %p/%p thread_data->capture_window %p GetCapture() %p in %p\n", hwnd,
           event->window, thread_data->capture_window, capture, capture_top);
 
     if (event->window == thread_data->capture_window && hwnd == capture_top)
     {
-        NtUserReleaseCapture();
-        if (!NtUserPostMessage(capture, WM_CANCELMODE, 0, 0))
+        ReleaseCapture();
+        if (!PostMessageW(capture, WM_CANCELMODE, 0, 0))
             WARN("failed to post WM_CANCELMODE; error 0x%08x\n", GetLastError());
     }
 }
diff --git a/dlls/winemac.drv/opengl.c b/dlls/winemac.drv/opengl.c
index 63b24ee991d..1a06be16c8a 100644
--- a/dlls/winemac.drv/opengl.c
+++ b/dlls/winemac.drv/opengl.c
@@ -19,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include "macdrv.h"
@@ -1588,7 +1584,7 @@ static BOOL set_pixel_format(HDC hdc, int fmt, BOOL allow_reset)
 
 done:
     release_win_data(data);
-    if (ret && gl_surface_mode == GL_SURFACE_BEHIND) NtUserSetWindowPixelFormat(hwnd, fmt);
+    if (ret && gl_surface_mode == GL_SURFACE_BEHIND) __wine_set_pixel_format(hwnd, fmt);
     return ret;
 }
 
@@ -2222,7 +2218,7 @@ static void macdrv_glFlush(void)
     if (skip_single_buffer_flushes)
     {
         const pixel_format *pf = &pixel_formats[context->format - 1];
-        DWORD now = NtGetTickCount();
+        DWORD now = GetTickCount();
 
         TRACE("double buffer %d last flush time %d now %d\n", (int)pf->double_buffer,
               context->last_flush_time, now);
@@ -4616,7 +4612,7 @@ static struct opengl_funcs opengl_funcs =
 /**********************************************************************
  *              macdrv_wine_get_wgl_driver
  */
-struct opengl_funcs *macdrv_wine_get_wgl_driver(UINT version)
+struct opengl_funcs * CDECL macdrv_wine_get_wgl_driver(UINT version)
 {
     static pthread_once_t init_once = PTHREAD_ONCE_INIT;
 
diff --git a/dlls/winemac.drv/surface.c b/dlls/winemac.drv/surface.c
index 5306e3b619f..cf65e4b328f 100644
--- a/dlls/winemac.drv/surface.c
+++ b/dlls/winemac.drv/surface.c
@@ -20,10 +20,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include "macdrv.h"
@@ -90,7 +86,7 @@ static void update_blit_data(struct macdrv_window_surface *surface)
 
         if (NtGdiCombineRgn(blit, surface->drawn, 0, RGN_COPY) > NULLREGION &&
             (!surface->region || NtGdiCombineRgn(blit, blit, surface->region, RGN_AND) > NULLREGION) &&
-            NtGdiOffsetRgn(blit, surface->header.rect.left, surface->header.rect.top) > NULLREGION)
+            OffsetRgn(blit, surface->header.rect.left, surface->header.rect.top) > NULLREGION)
             surface->blit_data = get_region_data(blit, 0);
 
         NtGdiDeleteObjectApp(blit);
@@ -100,7 +96,7 @@ static void update_blit_data(struct macdrv_window_surface *surface)
 /***********************************************************************
  *              macdrv_surface_lock
  */
-static void macdrv_surface_lock(struct window_surface *window_surface)
+static void CDECL macdrv_surface_lock(struct window_surface *window_surface)
 {
     struct macdrv_window_surface *surface = get_mac_surface(window_surface);
 
@@ -110,7 +106,7 @@ static void macdrv_surface_lock(struct window_surface *window_surface)
 /***********************************************************************
  *              macdrv_surface_unlock
  */
-static void macdrv_surface_unlock(struct window_surface *window_surface)
+static void CDECL macdrv_surface_unlock(struct window_surface *window_surface)
 {
     struct macdrv_window_surface *surface = get_mac_surface(window_surface);
 
@@ -120,7 +116,7 @@ static void macdrv_surface_unlock(struct window_surface *window_surface)
 /***********************************************************************
  *              macdrv_surface_get_bitmap_info
  */
-static void *macdrv_surface_get_bitmap_info(struct window_surface *window_surface,
+static void *CDECL macdrv_surface_get_bitmap_info(struct window_surface *window_surface,
                                                   BITMAPINFO *info)
 {
     struct macdrv_window_surface *surface = get_mac_surface(window_surface);
@@ -132,7 +128,7 @@ static void *macdrv_surface_get_bitmap_info(struct window_surface *window_surfac
 /***********************************************************************
  *              macdrv_surface_get_bounds
  */
-static RECT *macdrv_surface_get_bounds(struct window_surface *window_surface)
+static RECT *CDECL macdrv_surface_get_bounds(struct window_surface *window_surface)
 {
     struct macdrv_window_surface *surface = get_mac_surface(window_surface);
 
@@ -142,7 +138,7 @@ static RECT *macdrv_surface_get_bounds(struct window_surface *window_surface)
 /***********************************************************************
  *              macdrv_surface_set_region
  */
-static void macdrv_surface_set_region(struct window_surface *window_surface, HRGN region)
+static void CDECL macdrv_surface_set_region(struct window_surface *window_surface, HRGN region)
 {
     struct macdrv_window_surface *surface = get_mac_surface(window_surface);
 
@@ -168,7 +164,7 @@ static void macdrv_surface_set_region(struct window_surface *window_surface, HRG
 /***********************************************************************
  *              macdrv_surface_flush
  */
-static void macdrv_surface_flush(struct window_surface *window_surface)
+static void CDECL macdrv_surface_flush(struct window_surface *window_surface)
 {
     struct macdrv_window_surface *surface = get_mac_surface(window_surface);
     CGRect rect;
@@ -206,7 +202,7 @@ static void macdrv_surface_flush(struct window_surface *window_surface)
 /***********************************************************************
  *              macdrv_surface_destroy
  */
-static void macdrv_surface_destroy(struct window_surface *window_surface)
+static void CDECL macdrv_surface_destroy(struct window_surface *window_surface)
 {
     struct macdrv_window_surface *surface = get_mac_surface(window_surface);
 
@@ -289,7 +285,7 @@ struct window_surface *create_surface(macdrv_window window, const RECT *rect,
     if (old_mac_surface && old_mac_surface->drawn)
     {
         surface->drawn = NtGdiCreateRectRgn(rect->left, rect->top, rect->right, rect->bottom);
-        NtGdiOffsetRgn(surface->drawn, -rect->left, -rect->top);
+        OffsetRgn(surface->drawn, -rect->left, -rect->top);
         if (NtGdiCombineRgn(surface->drawn, surface->drawn, old_mac_surface->drawn, RGN_AND) <= NULLREGION)
         {
             NtGdiDeleteObjectApp(surface->drawn);
diff --git a/dlls/winemac.drv/systray.c b/dlls/winemac.drv/systray.c
index 9d660d0287e..dbddbddff9a 100644
--- a/dlls/winemac.drv/systray.c
+++ b/dlls/winemac.drv/systray.c
@@ -21,10 +21,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include "macdrv.h"
@@ -139,8 +135,8 @@ static BOOL modify_icon(struct tray_icon *icon, NOTIFYICONDATAW *nid)
 
     if (nid->uFlags & NIF_ICON)
     {
-        if (icon->image) NtUserDestroyCursor(icon->image, 0);
-        icon->image = CopyImage(nid->hIcon, IMAGE_ICON, 0, 0, 0);
+        if (icon->image) DestroyIcon(icon->image);
+        icon->image = CopyIcon(nid->hIcon);
         if (icon->status_item)
             update_image = TRUE;
     }
@@ -199,7 +195,7 @@ static BOOL add_icon(NOTIFYICONDATAW *nid)
         return FALSE;
     }
 
-    if (!(icon = calloc(1, sizeof(*icon))))
+    if (!(icon = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*icon))))
     {
         ERR("out of memory\n");
         return FALSE;
@@ -238,8 +234,8 @@ static BOOL delete_icon(struct tray_icon *icon)
         macdrv_destroy_status_item(icon->status_item);
     }
     list_remove(&icon->entry);
-    NtUserDestroyCursor(icon->image, 0);
-    free(icon);
+    DestroyIcon(icon->image);
+    HeapFree(GetProcessHeap(), 0, icon);
     return TRUE;
 }
 
@@ -249,14 +245,12 @@ static BOOL delete_icon(struct tray_icon *icon)
  *
  * Driver-side implementation of Shell_NotifyIcon.
  */
-NTSTATUS macdrv_notify_icon(void *arg)
+int CDECL wine_notify_icon(DWORD msg, NOTIFYICONDATAW *data)
 {
-    struct notify_icon_params *params = arg;
-    NOTIFYICONDATAW *data = params->data;
     BOOL ret = FALSE;
     struct tray_icon *icon;
 
-    switch (params->msg)
+    switch (msg)
     {
     case NIM_ADD:
         ret = add_icon(data);
@@ -278,7 +272,7 @@ NTSTATUS macdrv_notify_icon(void *arg)
         }
         break;
     default:
-        FIXME("unhandled tray message: %u\n", params->msg);
+        FIXME("unhandled tray message: %u\n", msg);
         break;
     }
     return ret;
@@ -296,8 +290,7 @@ static BOOL notify_owner(struct tray_icon *icon, UINT msg, int x, int y)
     }
 
     TRACE("posting msg 0x%04x to hwnd %p id 0x%x\n", msg, icon->owner, icon->id);
-    if (!NtUserMessageCall(icon->owner, icon->callback_message, wp, lp,
-                           0, NtUserSendNotifyMessage, FALSE) &&
+    if (!SendNotifyMessageW(icon->owner, icon->callback_message, wp, lp) &&
         (GetLastError() == ERROR_INVALID_WINDOW_HANDLE))
     {
         WARN("window %p was destroyed, removing icon 0x%x\n", icon->owner, icon->id);
@@ -342,7 +335,7 @@ void macdrv_status_item_mouse_button(const macdrv_event *event)
             else if (event->status_item_mouse_button.count % 2 == 0)
                 msg += WM_LBUTTONDBLCLK - WM_LBUTTONDOWN;
 
-            if (!send_message(icon->owner, WM_MACDRV_ACTIVATE_ON_FOLLOWING_FOCUS, 0, 0) &&
+            if (!SendMessageW(icon->owner, WM_MACDRV_ACTIVATE_ON_FOLLOWING_FOCUS, 0, 0) &&
                 GetLastError() == ERROR_INVALID_WINDOW_HANDLE)
             {
                 WARN("window %p was destroyed, removing icon 0x%x\n", icon->owner, icon->id);
diff --git a/dlls/winemac.drv/unixlib.h b/dlls/winemac.drv/unixlib.h
deleted file mode 100644
index 284a3e26db9..00000000000
--- a/dlls/winemac.drv/unixlib.h
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Copyright 2022 Jacek Caban for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include "ntuser.h"
-#include "wine/unixlib.h"
-
-enum macdrv_funcs
-{
-    unix_dnd_get_data,
-    unix_dnd_get_formats,
-    unix_dnd_have_format,
-    unix_dnd_release,
-    unix_dnd_retain,
-    unix_ime_clear,
-    unix_ime_process_text_input,
-    unix_ime_using_input_method,
-    unix_init,
-    unix_notify_icon,
-    unix_quit_result,
-    unix_funcs_count
-};
-
-/* FIXME: Use __wine_unix_call when the rest of the stack is ready */
-extern NTSTATUS (CDECL *macdrv_unix_call)(enum macdrv_funcs code, void *params) DECLSPEC_HIDDEN;
-#define MACDRV_CALL(func, params) macdrv_unix_call(unix_ ## func, params)
-
-/* macdrv_dnd_get_data params */
-struct dnd_get_data_params
-{
-    UINT64 handle;
-    UINT format;
-    size_t size;
-    void *data;
-};
-
-/* macdrv_dnd_get_formats params */
-struct dnd_get_formats_params
-{
-    UINT64 handle;
-    UINT formats[64];
-};
-
-/* macdrv_dnd_have_format params */
-struct dnd_have_format_params
-{
-    UINT64 handle;
-    UINT format;
-};
-
-/* macdrv_ime_process_text_input params */
-struct process_text_input_params
-{
-    UINT vkey;
-    UINT scan;
-    UINT repeat;
-    const BYTE *key_state;
-    void *himc;
-    int *done;
-};
-
-/* macdrv_init params */
-struct localized_string
-{
-    UINT id;
-    UINT len;
-    const WCHAR *str;
-};
-
-struct init_params
-{
-    NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,BOOLEAN,const LARGE_INTEGER*);
-    struct localized_string *strings;
-    NTSTATUS (CDECL *unix_call)(enum macdrv_funcs code, void *params);
-};
-
-/* macdrv_notify_icon params */
-struct notify_icon_params
-{
-    DWORD msg;
-    struct _NOTIFYICONDATAW *data;
-};
-
-/* macdrv_quit_result params */
-struct quit_result_params
-{
-    int result;
-};
-
-/* driver client callbacks exposed with KernelCallbackTable interface */
-enum macdrv_client_funcs
-{
-    client_func_app_icon = NtUserDriverCallbackFirst,
-    client_func_app_quit_request,
-    client_func_dnd_query_drag,
-    client_func_dnd_query_drop,
-    client_func_dnd_query_exited,
-    client_func_ime_query_char_rect,
-    client_func_ime_set_text,
-    client_func_last
-};
-
-/* macdrv_app_icon result */
-struct app_icon_entry
-{
-    UINT32 width;
-    UINT32 height;
-    UINT32 size;
-    void *png;
-    HICON icon;
-};
-
-struct app_icon_result
-{
-    UINT32 count;
-    struct app_icon_entry entries[64];
-};
-
-/* macdrv_app_icon params */
-struct app_icon_params
-{
-    struct app_icon_result *result; /* FIXME: Use NtCallbackReturn instead */
-};
-
-/* macdrv_app_quit_request params */
-struct app_quit_request_params
-{
-    UINT flags;
-};
-
-/* macdrv_dnd_query_drag params */
-struct dnd_query_drag_params
-{
-    HWND hwnd;
-    UINT32 effect;
-    INT32 x;
-    INT32 y;
-    UINT64 handle;
-};
-
-/* macdrv_dnd_query_drop params */
-struct dnd_query_drop_params
-{
-    HWND hwnd;
-    UINT32 effect;
-    INT32 x;
-    INT32 y;
-    UINT64 handle;
-};
-
-/* macdrv_dnd_query_exited params */
-struct dnd_query_exited_params
-{
-    HWND hwnd;
-};
-
-/* macdrv_ime_query_char_rect result */
-struct ime_query_char_rect_result
-{
-    RECT rect;
-    UINT32 location;
-    UINT32 length;
-};
-
-/* macdrv_ime_query_char_rect params */
-struct ime_query_char_rect_params
-{
-    HWND hwnd;
-    void *data;
-    UINT32 location;
-    UINT32 length;
-    struct ime_query_char_rect_result *result; /* FIXME: Use NtCallbackReturn instead */
-};
-
-/* macdrv_ime_set_text params */
-struct ime_set_text_params
-{
-    HWND hwnd;
-    void *data;
-    UINT32 cursor_pos;
-    UINT32 complete;
-    WCHAR text[1];
-};
-
-C_ASSERT(client_func_last <= NtUserDriverCallbackLast + 1);
diff --git a/dlls/winemac.drv/vulkan.c b/dlls/winemac.drv/vulkan.c
index 00f5e8465ab..0c48fae2bf4 100644
--- a/dlls/winemac.drv/vulkan.c
+++ b/dlls/winemac.drv/vulkan.c
@@ -21,10 +21,6 @@
 /* NOTE: If making changes here, consider whether they should be reflected in
  * the other drivers. */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <stdarg.h>
@@ -562,7 +558,7 @@ static VkResult macdrv_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *
         static long prev_time, start_time;
         DWORD time;
 
-        time = NtGetTickCount();
+        time = GetTickCount();
         frames++;
         frames_total++;
         if (time - prev_time > 1500)
@@ -652,7 +648,7 @@ static const struct vulkan_funcs *get_vulkan_driver(UINT version)
 
 #endif /* SONAME_LIBMOLTENVK */
 
-const struct vulkan_funcs *macdrv_wine_get_vulkan_driver(UINT version)
+const struct vulkan_funcs * CDECL macdrv_wine_get_vulkan_driver(UINT version)
 {
     return get_vulkan_driver( version );
 }
diff --git a/dlls/winemac.drv/window.c b/dlls/winemac.drv/window.c
index 9d778f427b0..afb5830f618 100644
--- a/dlls/winemac.drv/window.c
+++ b/dlls/winemac.drv/window.c
@@ -21,10 +21,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <IOKit/pwr_mgt/IOPMLib.h>
@@ -35,6 +31,8 @@
 #undef LoadResource
 
 #include "macdrv.h"
+#include "winuser.h"
+#include "wine/unicode.h"
 #include "wine/server.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(macdrv);
@@ -93,11 +91,11 @@ static void get_cocoa_window_features(struct macdrv_win_data *data,
  */
 static inline BOOL can_window_become_foreground(HWND hwnd)
 {
-    LONG style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    LONG style = GetWindowLongW(hwnd, GWL_STYLE);
 
     if (!(style & WS_VISIBLE)) return FALSE;
     if ((style & (WS_POPUP|WS_CHILD)) == WS_CHILD) return FALSE;
-    if (hwnd == NtUserGetDesktopWindow()) return FALSE;
+    if (hwnd == GetDesktopWindow()) return FALSE;
     return !(style & WS_DISABLED);
 }
 
@@ -115,7 +113,7 @@ static void get_cocoa_window_state(struct macdrv_win_data *data,
     state->floating = (ex_style & WS_EX_TOPMOST) != 0;
     state->excluded_by_expose = state->excluded_by_cycle =
         (!(ex_style & WS_EX_APPWINDOW) &&
-         (NtUserGetWindowRelative(data->hwnd, GW_OWNER) || (ex_style & (WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE))));
+         (GetWindow(data->hwnd, GW_OWNER) || (ex_style & (WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE))));
     if (IsRectEmpty(&data->window_rect))
         state->excluded_by_expose = TRUE;
     state->minimized = (style & WS_MINIMIZE) != 0;
@@ -136,7 +134,7 @@ static void get_mac_rect_offset(struct macdrv_win_data *data, DWORD style, RECT
 
     rect->top = rect->bottom = rect->left = rect->right = 0;
 
-    ex_style = NtUserGetWindowLongW(data->hwnd, GWL_EXSTYLE);
+    ex_style = GetWindowLongW(data->hwnd, GWL_EXSTYLE);
 
     if (!data->shaped)
     {
@@ -194,7 +192,7 @@ static void macdrv_window_to_mac_rect(struct macdrv_win_data *data, DWORD style,
 static void macdrv_mac_to_window_rect(struct macdrv_win_data *data, RECT *rect)
 {
     RECT rc;
-    DWORD style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+    DWORD style = GetWindowLongW(data->hwnd, GWL_STYLE);
 
     if ((style & (WS_POPUP|WS_CHILD)) == WS_CHILD) return;
     if (IsRectEmpty(rect)) return;
@@ -343,12 +341,12 @@ static void set_cocoa_window_properties(struct macdrv_win_data *data)
     struct macdrv_window_features wf;
     struct macdrv_window_state state;
 
-    style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
-    ex_style = NtUserGetWindowLongW(data->hwnd, GWL_EXSTYLE);
+    style = GetWindowLongW(data->hwnd, GWL_STYLE);
+    ex_style = GetWindowLongW(data->hwnd, GWL_EXSTYLE);
 
-    owner = NtUserGetWindowRelative(data->hwnd, GW_OWNER);
+    owner = GetWindow(data->hwnd, GW_OWNER);
     if (owner)
-        owner = NtUserGetAncestor(owner, GA_ROOT);
+        owner = GetAncestor(owner, GA_ROOT);
     owner_win = macdrv_get_cocoa_window(owner, TRUE);
     macdrv_set_cocoa_parent_window(data->cocoa_window, owner_win);
 
@@ -387,19 +385,19 @@ static void sync_window_region(struct macdrv_win_data *data, HRGN win_region)
     if (hrgn == (HRGN)1)  /* hack: win_region == 1 means retrieve region from server */
     {
         if (!(hrgn = NtGdiCreateRectRgn(0, 0, 0, 0))) return;
-        if (NtUserGetWindowRgnEx(data->hwnd, hrgn, 0) == ERROR)
+        if (GetWindowRgn(data->hwnd, hrgn) == ERROR)
         {
             NtGdiDeleteObjectApp(hrgn);
             hrgn = 0;
         }
     }
 
-    if (hrgn && NtUserGetWindowLongW(data->hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
+    if (hrgn && GetWindowLongW(data->hwnd, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
         NtUserMirrorRgn(data->hwnd, hrgn);
     if (hrgn)
     {
-        NtGdiOffsetRgn(hrgn, data->window_rect.left - data->whole_rect.left,
-                       data->window_rect.top - data->whole_rect.top);
+        OffsetRgn(hrgn, data->window_rect.left - data->whole_rect.left,
+                  data->window_rect.top - data->whole_rect.top);
     }
     region_data = get_region_data(hrgn, 0);
     if (region_data)
@@ -516,8 +514,8 @@ static void sync_window_opacity(struct macdrv_win_data *data, COLORREF key, BYTE
  */
 static void sync_window_min_max_info(HWND hwnd)
 {
-    LONG style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
-    LONG exstyle = NtUserGetWindowLongW(hwnd, GWL_EXSTYLE);
+    LONG style = GetWindowLongW(hwnd, GWL_STYLE);
+    LONG exstyle = GetWindowLongW(hwnd, GWL_EXSTYLE);
     RECT win_rect, primary_monitor_rect;
     MINMAXINFO minmax;
     LONG adjustedStyle;
@@ -530,7 +528,7 @@ static void sync_window_min_max_info(HWND hwnd)
 
     if (!macdrv_get_cocoa_window(hwnd, FALSE)) return;
 
-    NtUserGetWindowRect(hwnd, &win_rect);
+    GetWindowRect(hwnd, &win_rect);
     minmax.ptReserved.x = win_rect.left;
     minmax.ptReserved.y = win_rect.top;
 
@@ -540,10 +538,9 @@ static void sync_window_min_max_info(HWND hwnd)
         adjustedStyle = style;
 
     primary_monitor_rect.left = primary_monitor_rect.top = 0;
-    primary_monitor_rect.right = NtUserGetSystemMetrics(SM_CXSCREEN);
-    primary_monitor_rect.bottom = NtUserGetSystemMetrics(SM_CYSCREEN);
-    AdjustWindowRectEx(&primary_monitor_rect, adjustedStyle,
-                       ((style & WS_POPUP) && NtUserGetWindowLongPtrW(hwnd, GWLP_ID)), exstyle);
+    primary_monitor_rect.right = GetSystemMetrics(SM_CXSCREEN);
+    primary_monitor_rect.bottom = GetSystemMetrics(SM_CYSCREEN);
+    AdjustWindowRectEx(&primary_monitor_rect, adjustedStyle, ((style & WS_POPUP) && GetMenu(hwnd)), exstyle);
 
     xinc = -primary_monitor_rect.left;
     yinc = -primary_monitor_rect.top;
@@ -554,19 +551,19 @@ static void sync_window_min_max_info(HWND hwnd)
     minmax.ptMaxPosition.y = -yinc;
     if (style & (WS_DLGFRAME | WS_BORDER))
     {
-        minmax.ptMinTrackSize.x = NtUserGetSystemMetrics(SM_CXMINTRACK);
-        minmax.ptMinTrackSize.y = NtUserGetSystemMetrics(SM_CYMINTRACK);
+        minmax.ptMinTrackSize.x = GetSystemMetrics(SM_CXMINTRACK);
+        minmax.ptMinTrackSize.y = GetSystemMetrics(SM_CYMINTRACK);
     }
     else
     {
         minmax.ptMinTrackSize.x = 2 * xinc;
         minmax.ptMinTrackSize.y = 2 * yinc;
     }
-    minmax.ptMaxTrackSize.x = NtUserGetSystemMetrics(SM_CXMAXTRACK);
-    minmax.ptMaxTrackSize.y = NtUserGetSystemMetrics(SM_CYMAXTRACK);
+    minmax.ptMaxTrackSize.x = GetSystemMetrics(SM_CXMAXTRACK);
+    minmax.ptMaxTrackSize.y = GetSystemMetrics(SM_CYMAXTRACK);
 
     wpl.length = sizeof(wpl);
-    if (NtUserGetWindowPlacement(hwnd, &wpl) && (wpl.ptMaxPosition.x != -1 || wpl.ptMaxPosition.y != -1))
+    if (GetWindowPlacement(hwnd, &wpl) && (wpl.ptMaxPosition.x != -1 || wpl.ptMaxPosition.y != -1))
     {
         minmax.ptMaxPosition = wpl.ptMaxPosition;
 
@@ -578,19 +575,19 @@ static void sync_window_min_max_info(HWND hwnd)
     TRACE("initial ptMaxSize %s ptMaxPosition %s ptMinTrackSize %s ptMaxTrackSize %s\n", wine_dbgstr_point(&minmax.ptMaxSize),
           wine_dbgstr_point(&minmax.ptMaxPosition), wine_dbgstr_point(&minmax.ptMinTrackSize), wine_dbgstr_point(&minmax.ptMaxTrackSize));
 
-    send_message(hwnd, WM_GETMINMAXINFO, 0, (LPARAM)&minmax);
+    SendMessageW(hwnd, WM_GETMINMAXINFO, 0, (LPARAM)&minmax);
 
     TRACE("app's ptMaxSize %s ptMaxPosition %s ptMinTrackSize %s ptMaxTrackSize %s\n", wine_dbgstr_point(&minmax.ptMaxSize),
           wine_dbgstr_point(&minmax.ptMaxPosition), wine_dbgstr_point(&minmax.ptMinTrackSize), wine_dbgstr_point(&minmax.ptMaxTrackSize));
 
     /* if the app didn't change the values, adapt them for the window's monitor */
-    if ((monitor = NtUserMonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY)))
+    if ((monitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY)))
     {
         MONITORINFO mon_info;
         RECT monitor_rect;
 
         mon_info.cbSize = sizeof(mon_info);
-        NtUserGetMonitorInfo(monitor, &mon_info);
+        GetMonitorInfoW(monitor, &mon_info);
 
         if ((style & WS_MAXIMIZEBOX) && ((style & WS_CAPTION) == WS_CAPTION || !(style & WS_POPUP)))
             monitor_rect = mon_info.rcWork;
@@ -625,8 +622,8 @@ static void sync_window_min_max_info(HWND hwnd)
         macdrv_window_to_mac_rect(data, style, &min_rect, &data->window_rect, &data->client_rect);
         min_size = CGSizeMake(min_rect.right - min_rect.left, min_rect.bottom - min_rect.top);
 
-        if (minmax.ptMaxTrackSize.x == NtUserGetSystemMetrics(SM_CXMAXTRACK) &&
-            minmax.ptMaxTrackSize.y == NtUserGetSystemMetrics(SM_CYMAXTRACK))
+        if (minmax.ptMaxTrackSize.x == GetSystemMetrics(SM_CXMAXTRACK) &&
+            minmax.ptMaxTrackSize.y == GetSystemMetrics(SM_CYMAXTRACK))
             max_size = CGSizeMake(CGFLOAT_MAX, CGFLOAT_MAX);
         else
         {
@@ -682,15 +679,15 @@ static void create_cocoa_window(struct macdrv_win_data *data)
     DWORD layered_flags;
 
     if ((win_rgn = NtGdiCreateRectRgn(0, 0, 0, 0)) &&
-        NtUserGetWindowRgnEx(data->hwnd, win_rgn, 0) == ERROR)
+        GetWindowRgn(data->hwnd, win_rgn) == ERROR)
     {
         NtGdiDeleteObjectApp(win_rgn);
         win_rgn = 0;
     }
     data->shaped = (win_rgn != 0);
 
-    style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
-    ex_style = NtUserGetWindowLongW(data->hwnd, GWL_EXSTYLE);
+    style = GetWindowLongW(data->hwnd, GWL_STYLE);
+    ex_style = GetWindowLongW(data->hwnd, GWL_EXSTYLE);
 
     data->whole_rect = data->window_rect;
     macdrv_window_to_mac_rect(data, style, &data->whole_rect, &data->window_rect, &data->client_rect);
@@ -712,14 +709,14 @@ static void create_cocoa_window(struct macdrv_win_data *data)
     set_cocoa_window_properties(data);
 
     /* set the window text */
-    if (!NtUserInternalGetWindowText(data->hwnd, text, ARRAY_SIZE(text))) text[0] = 0;
-    macdrv_set_cocoa_window_title(data->cocoa_window, text, wcslen(text));
+    if (!InternalGetWindowText(data->hwnd, text, ARRAY_SIZE(text))) text[0] = 0;
+    macdrv_set_cocoa_window_title(data->cocoa_window, text, strlenW(text));
 
     /* set the window region */
     if (win_rgn || IsRectEmpty(&data->window_rect)) sync_window_region(data, win_rgn);
 
     /* set the window opacity */
-    if (!NtUserGetLayeredWindowAttributes(data->hwnd, &key, &alpha, &layered_flags)) layered_flags = 0;
+    if (!GetLayeredWindowAttributes(data->hwnd, &key, &alpha, &layered_flags)) layered_flags = 0;
     sync_window_opacity(data, key, alpha, FALSE, layered_flags);
 
 done:
@@ -825,23 +822,23 @@ static struct macdrv_win_data *macdrv_create_win_data(HWND hwnd, const RECT *win
     struct macdrv_win_data *data;
     HWND parent;
 
-    if (NtUserGetWindowThread(hwnd, NULL) != GetCurrentThreadId()) return NULL;
+    if (GetWindowThreadProcessId(hwnd, NULL) != GetCurrentThreadId()) return NULL;
 
-    if (!(parent = NtUserGetAncestor(hwnd, GA_PARENT)))  /* desktop */
+    if (!(parent = GetAncestor(hwnd, GA_PARENT)))  /* desktop */
     {
         macdrv_init_thread_data();
         return NULL;
     }
 
     /* don't create win data for HWND_MESSAGE windows */
-    if (parent != NtUserGetDesktopWindow() && !NtUserGetAncestor(parent, GA_PARENT)) return NULL;
+    if (parent != GetDesktopWindow() && !GetAncestor(parent, GA_PARENT)) return NULL;
 
     if (!(data = alloc_win_data(hwnd))) return NULL;
 
     data->whole_rect = data->window_rect = *window_rect;
     data->client_rect = *client_rect;
 
-    if (parent == NtUserGetDesktopWindow())
+    if (parent == GetDesktopWindow())
     {
         create_cocoa_window(data);
         TRACE("win %p/%p window %s whole %s client %s\n",
@@ -869,9 +866,9 @@ static BOOL is_owned_by(HWND hwnd, HWND maybe_owner)
 {
     while (1)
     {
-        HWND hwnd2 = NtUserGetWindowRelative(hwnd, GW_OWNER);
+        HWND hwnd2 = GetWindow(hwnd, GW_OWNER);
         if (!hwnd2)
-            hwnd2 = NtUserGetAncestor(hwnd, GA_ROOT);
+            hwnd2 = GetAncestor(hwnd, GA_ROOT);
         if (!hwnd2 || hwnd2 == hwnd)
             break;
         if (hwnd2 == maybe_owner)
@@ -888,12 +885,12 @@ static BOOL is_owned_by(HWND hwnd, HWND maybe_owner)
  */
 static BOOL is_all_the_way_front(HWND hwnd)
 {
-    BOOL topmost = (NtUserGetWindowLongW(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST) != 0;
+    BOOL topmost = (GetWindowLongW(hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST) != 0;
     HWND prev = hwnd;
 
-    while ((prev = NtUserGetWindowRelative(prev, GW_HWNDPREV)))
+    while ((prev = GetWindow(prev, GW_HWNDPREV)))
     {
-        if (!topmost && (NtUserGetWindowLongW(prev, GWL_EXSTYLE) & WS_EX_TOPMOST) != 0)
+        if (!topmost && (GetWindowLongW(prev, GWL_EXSTYLE) & WS_EX_TOPMOST) != 0)
             return TRUE;
         if (!is_owned_by(prev, hwnd))
             return FALSE;
@@ -910,18 +907,16 @@ static void set_focus(HWND hwnd, BOOL raise)
 {
     struct macdrv_win_data *data;
 
-    if (!(hwnd = NtUserGetAncestor(hwnd, GA_ROOT))) return;
+    if (!(hwnd = GetAncestor(hwnd, GA_ROOT))) return;
 
-    if (raise && hwnd == NtUserGetForegroundWindow() && hwnd != NtUserGetDesktopWindow() &&
-        !is_all_the_way_front(hwnd))
-        NtUserSetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0,
-                           SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
+    if (raise && hwnd == GetForegroundWindow() && hwnd != GetDesktopWindow() && !is_all_the_way_front(hwnd))
+        SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOOWNERZORDER);
 
     if (!(data = get_win_data(hwnd))) return;
 
     if (data->cocoa_window && data->on_screen)
     {
-        BOOL activate = activate_on_focus_time && (NtGetTickCount() - activate_on_focus_time < 2000);
+        BOOL activate = activate_on_focus_time && (GetTickCount() - activate_on_focus_time < 2000);
         /* Set Mac focus */
         macdrv_give_cocoa_window_focus(data->cocoa_window, activate);
         activate_on_focus_time = 0;
@@ -945,30 +940,30 @@ static void show_window(struct macdrv_win_data *data)
         GUITHREADINFO info;
 
         /* find window that this one must be after */
-        prev = NtUserGetWindowRelative(data->hwnd, GW_HWNDPREV);
-        while (prev && !((NtUserGetWindowLongW(prev, GWL_STYLE) & (WS_VISIBLE | WS_MINIMIZE)) == WS_VISIBLE &&
+        prev = GetWindow(data->hwnd, GW_HWNDPREV);
+        while (prev && !((GetWindowLongW(prev, GWL_STYLE) & (WS_VISIBLE | WS_MINIMIZE)) == WS_VISIBLE &&
                          (prev_window = macdrv_get_cocoa_window(prev, TRUE))))
-            prev = NtUserGetWindowRelative(prev, GW_HWNDPREV);
+            prev = GetWindow(prev, GW_HWNDPREV);
         if (!prev_window)
         {
             /* find window that this one must be before */
-            next = NtUserGetWindowRelative(data->hwnd, GW_HWNDNEXT);
-            while (next && !((NtUserGetWindowLongW(next, GWL_STYLE) & (WS_VISIBLE | WS_MINIMIZE)) == WS_VISIBLE &&
+            next = GetWindow(data->hwnd, GW_HWNDNEXT);
+            while (next && !((GetWindowLongW(next, GWL_STYLE) & (WS_VISIBLE | WS_MINIMIZE)) == WS_VISIBLE &&
                              (next_window = macdrv_get_cocoa_window(next, TRUE))))
-                next = NtUserGetWindowRelative(next, GW_HWNDNEXT);
+                next = GetWindow(next, GW_HWNDNEXT);
         }
 
         TRACE("win %p/%p below %p/%p above %p/%p\n",
               data->hwnd, data->cocoa_window, prev, prev_window, next, next_window);
 
         if (!prev_window)
-            activate = activate_on_focus_time && (NtGetTickCount() - activate_on_focus_time < 2000);
+            activate = activate_on_focus_time && (GetTickCount() - activate_on_focus_time < 2000);
         macdrv_order_cocoa_window(data->cocoa_window, prev_window, next_window, activate);
         data->on_screen = TRUE;
 
         info.cbSize = sizeof(info);
-        if (NtUserGetGUIThreadInfo(NtUserGetWindowThread(data->hwnd, NULL), &info) && info.hwndFocus &&
-            (data->hwnd == info.hwndFocus || NtUserIsChild(data->hwnd, info.hwndFocus)))
+        if (GetGUIThreadInfo(GetWindowThreadProcessId(data->hwnd, NULL), &info) && info.hwndFocus &&
+            (data->hwnd == info.hwndFocus || IsChild(data->hwnd, info.hwndFocus)))
             set_focus(info.hwndFocus, FALSE);
         if (activate)
             activate_on_focus_time = 0;
@@ -1005,7 +1000,7 @@ static void sync_window_z_order(struct macdrv_win_data *data)
 {
     if (data->cocoa_view)
     {
-        HWND parent = NtUserGetAncestor(data->hwnd, GA_PARENT);
+        HWND parent = GetAncestor(data->hwnd, GA_PARENT);
         macdrv_view superview = macdrv_get_client_cocoa_view(parent);
         macdrv_window window = NULL;
         HWND prev;
@@ -1021,15 +1016,15 @@ static void sync_window_z_order(struct macdrv_win_data *data)
         }
 
         /* find window that this one must be after */
-        prev = NtUserGetWindowRelative(data->hwnd, GW_HWNDPREV);
+        prev = GetWindow(data->hwnd, GW_HWNDPREV);
         while (prev && !(prev_view = macdrv_get_cocoa_view(prev)))
-            prev = NtUserGetWindowRelative(prev, GW_HWNDPREV);
+            prev = GetWindow(prev, GW_HWNDPREV);
         if (!prev_view)
         {
             /* find window that this one must be before */
-            next = NtUserGetWindowRelative(data->hwnd, GW_HWNDNEXT);
+            next = GetWindow(data->hwnd, GW_HWNDNEXT);
             while (next && !(next_view = macdrv_get_cocoa_view(next)))
-                next = NtUserGetWindowRelative(next, GW_HWNDNEXT);
+                next = GetWindow(next, GW_HWNDNEXT);
         }
 
         TRACE("win %p/%p below %p/%p above %p/%p\n",
@@ -1205,9 +1200,9 @@ static void move_window_bits(HWND hwnd, macdrv_window window, const RECT *old_re
     if (!window)
     {
         OffsetRect(&dst_rect, -new_window_rect->left, -new_window_rect->top);
-        parent = NtUserGetAncestor(hwnd, GA_PARENT);
-        hdc_src = NtUserGetDCEx(parent, 0, DCX_CACHE);
-        hdc_dst = NtUserGetDCEx(hwnd, 0, DCX_CACHE | DCX_WINDOW);
+        parent = GetAncestor(hwnd, GA_PARENT);
+        hdc_src = GetDCEx(parent, 0, DCX_CACHE);
+        hdc_dst = GetDCEx(hwnd, 0, DCX_CACHE | DCX_WINDOW);
     }
     else
     {
@@ -1215,13 +1210,13 @@ static void move_window_bits(HWND hwnd, macdrv_window window, const RECT *old_re
         /* make src rect relative to the old position of the window */
         OffsetRect(&src_rect, -old_client_rect->left, -old_client_rect->top);
         if (dst_rect.left == src_rect.left && dst_rect.top == src_rect.top) return;
-        hdc_src = hdc_dst = NtUserGetDCEx(hwnd, 0, DCX_CACHE);
+        hdc_src = hdc_dst = GetDCEx(hwnd, 0, DCX_CACHE);
     }
 
     rgn = NtGdiCreateRectRgn(dst_rect.left, dst_rect.top, dst_rect.right, dst_rect.bottom);
     NtGdiExtSelectClipRgn(hdc_dst, rgn, RGN_COPY);
     NtGdiDeleteObjectApp(rgn);
-    NtUserExcludeUpdateRgn(hdc_dst, hwnd);
+    ExcludeUpdateRgn(hdc_dst, hwnd);
 
     TRACE("copying bits for win %p/%p %s -> %s\n", hwnd, window,
           wine_dbgstr_rect(&src_rect), wine_dbgstr_rect(&dst_rect));
@@ -1229,8 +1224,8 @@ static void move_window_bits(HWND hwnd, macdrv_window window, const RECT *old_re
                 dst_rect.right - dst_rect.left, dst_rect.bottom - dst_rect.top,
                 hdc_src, src_rect.left, src_rect.top, SRCCOPY, 0, 0);
 
-    NtUserReleaseDC(hwnd, hdc_dst);
-    if (hdc_src != hdc_dst) NtUserReleaseDC(parent, hdc_src);
+    ReleaseDC(hwnd, hdc_dst);
+    if (hdc_src != hdc_dst) ReleaseDC(parent, hdc_src);
 }
 
 
@@ -1239,7 +1234,7 @@ static void move_window_bits(HWND hwnd, macdrv_window window, const RECT *old_re
  */
 void activate_on_following_focus(void)
 {
-    activate_on_focus_time = NtGetTickCount();
+    activate_on_focus_time = GetTickCount();
     if (!activate_on_focus_time) activate_on_focus_time = 1;
 }
 
@@ -1283,21 +1278,12 @@ static BOOL set_capture_window_for_move(HWND hwnd)
         macdrv_SetCapture(hwnd, GUI_INMOVESIZE);
 
         if (previous && previous != hwnd)
-            send_message(previous, WM_CAPTURECHANGED, 0, (LPARAM)hwnd);
+            SendMessageW(previous, WM_CAPTURECHANGED, 0, (LPARAM)hwnd);
     }
     return ret;
 }
 
 
-static HMONITOR monitor_from_point(POINT pt, UINT flags)
-{
-    RECT rect;
-
-    SetRect(&rect, pt.x, pt.y, pt.x + 1, pt.y + 1);
-    return NtUserMonitorFromRect(&rect, flags);
-}
-
-
 /***********************************************************************
  *              move_window
  *
@@ -1311,9 +1297,9 @@ static LRESULT move_window(HWND hwnd, WPARAM wparam)
     RECT origRect, movedRect, desktopRect;
     LONG hittest = (LONG)(wparam & 0x0f);
     POINT capturePoint;
-    LONG style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    LONG style = GetWindowLongW(hwnd, GWL_STYLE);
     BOOL moved = FALSE;
-    DWORD dwPoint = NtUserGetThreadInfo()->message_pos;
+    DWORD dwPoint = GetMessagePos();
     INT captionHeight;
     HMONITOR mon = 0;
     MONITORINFO info;
@@ -1323,17 +1309,17 @@ static LRESULT move_window(HWND hwnd, WPARAM wparam)
 
     capturePoint.x = (short)LOWORD(dwPoint);
     capturePoint.y = (short)HIWORD(dwPoint);
-    NtUserClipCursor(NULL);
+    ClipCursor(NULL);
 
     TRACE("hwnd %p hittest %d, pos %d,%d\n", hwnd, hittest, capturePoint.x, capturePoint.y);
 
     origRect.left = origRect.right = origRect.top = origRect.bottom = 0;
-    if (AdjustWindowRectEx(&origRect, style, FALSE, NtUserGetWindowLongW(hwnd, GWL_EXSTYLE)))
+    if (AdjustWindowRectEx(&origRect, style, FALSE, GetWindowLongW(hwnd, GWL_EXSTYLE)))
         captionHeight = -origRect.top;
     else
         captionHeight = 0;
 
-    NtUserGetWindowRect(hwnd, &origRect);
+    GetWindowRect(hwnd, &origRect);
     movedRect = origRect;
 
     if (!hittest)
@@ -1344,30 +1330,30 @@ static LRESULT move_window(HWND hwnd, WPARAM wparam)
         /* Note: to be exactly centered we should take the different types
          * of border into account, but it shouldn't make more than a few pixels
          * of difference so let's not bother with that */
-        rect.top += NtUserGetSystemMetrics(SM_CYBORDER);
+        rect.top += GetSystemMetrics(SM_CYBORDER);
         if (style & WS_SYSMENU)
-            rect.left += NtUserGetSystemMetrics(SM_CXSIZE) + 1;
+            rect.left += GetSystemMetrics(SM_CXSIZE) + 1;
         if (style & WS_MINIMIZEBOX)
-            rect.right -= NtUserGetSystemMetrics(SM_CXSIZE) + 1;
+            rect.right -= GetSystemMetrics(SM_CXSIZE) + 1;
         if (style & WS_MAXIMIZEBOX)
-            rect.right -= NtUserGetSystemMetrics(SM_CXSIZE) + 1;
+            rect.right -= GetSystemMetrics(SM_CXSIZE) + 1;
         capturePoint.x = (rect.right + rect.left) / 2;
-        capturePoint.y = rect.top + NtUserGetSystemMetrics(SM_CYSIZE)/2;
+        capturePoint.y = rect.top + GetSystemMetrics(SM_CYSIZE)/2;
 
-        NtUserSetCursorPos(capturePoint.x, capturePoint.y);
-        send_message(hwnd, WM_SETCURSOR, (WPARAM)hwnd, MAKELONG(HTCAPTION, WM_MOUSEMOVE));
+        SetCursorPos(capturePoint.x, capturePoint.y);
+        SendMessageW(hwnd, WM_SETCURSOR, (WPARAM)hwnd, MAKELONG(HTCAPTION, WM_MOUSEMOVE));
     }
 
     desktopRect = rect_from_cgrect(macdrv_get_desktop_rect());
-    mon = monitor_from_point(capturePoint, MONITOR_DEFAULTTONEAREST);
+    mon = MonitorFromPoint(capturePoint, MONITOR_DEFAULTTONEAREST);
     info.cbSize = sizeof(info);
-    if (mon && !NtUserGetMonitorInfo(mon, &info))
+    if (mon && !GetMonitorInfoW(mon, &info))
         mon = 0;
 
     /* repaint the window before moving it around */
-    NtUserRedrawWindow(hwnd, NULL, 0, RDW_UPDATENOW | RDW_ALLCHILDREN);
+    RedrawWindow(hwnd, NULL, 0, RDW_UPDATENOW | RDW_ALLCHILDREN);
 
-    send_message(hwnd, WM_ENTERSIZEMOVE, 0, 0);
+    SendMessageW(hwnd, WM_ENTERSIZEMOVE, 0, 0);
     set_capture_window_for_move(hwnd);
 
     while(1)
@@ -1376,8 +1362,8 @@ static LRESULT move_window(HWND hwnd, WPARAM wparam)
         int dx = 0, dy = 0;
         HMONITOR newmon;
 
-        if (!NtUserGetMessage(&msg, 0, 0, 0)) break;
-        if (NtUserCallMsgFilter(&msg, MSGF_SIZE)) continue;
+        if (!GetMessageW(&msg, 0, 0, 0)) break;
+        if (CallMsgFilterW(&msg, MSGF_SIZE)) continue;
 
         /* Exit on button-up, Return, or Esc */
         if (msg.message == WM_LBUTTONUP ||
@@ -1386,8 +1372,8 @@ static LRESULT move_window(HWND hwnd, WPARAM wparam)
 
         if (msg.message != WM_KEYDOWN && msg.message != WM_MOUSEMOVE)
         {
-            NtUserTranslateMessage(&msg, 0);
-            NtUserDispatchMessage(&msg);
+            TranslateMessage(&msg);
+            DispatchMessageW(&msg);
             continue;  /* We are not interested in other messages */
         }
 
@@ -1406,9 +1392,9 @@ static LRESULT move_window(HWND hwnd, WPARAM wparam)
         pt.y = max(pt.y, desktopRect.top);
         pt.y = min(pt.y, desktopRect.bottom - 1);
 
-        if ((newmon = monitor_from_point(pt, MONITOR_DEFAULTTONULL)) && newmon != mon)
+        if ((newmon = MonitorFromPoint(pt, MONITOR_DEFAULTTONULL)) && newmon != mon)
         {
-            if (NtUserGetMonitorInfo(newmon, &info))
+            if (GetMonitorInfoW(newmon, &info))
                 mon = newmon;
             else
                 mon = 0;
@@ -1454,29 +1440,29 @@ static LRESULT move_window(HWND hwnd, WPARAM wparam)
         {
             moved = TRUE;
 
-            if (msg.message == WM_KEYDOWN) NtUserSetCursorPos(pt.x, pt.y);
+            if (msg.message == WM_KEYDOWN) SetCursorPos(pt.x, pt.y);
             else
             {
                 OffsetRect(&movedRect, dx, dy);
                 capturePoint = pt;
 
-                send_message(hwnd, WM_MOVING, 0, (LPARAM)&movedRect);
-                NtUserSetWindowPos(hwnd, 0, movedRect.left, movedRect.top, 0, 0,
-                                   SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
+                SendMessageW(hwnd, WM_MOVING, 0, (LPARAM)&movedRect);
+                SetWindowPos(hwnd, 0, movedRect.left, movedRect.top, 0, 0,
+                             SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
             }
         }
     }
 
     set_capture_window_for_move(0);
 
-    send_message(hwnd, WM_EXITSIZEMOVE, 0, 0);
-    send_message(hwnd, WM_SETVISIBLE, TRUE, 0L);
+    SendMessageW(hwnd, WM_EXITSIZEMOVE, 0, 0);
+    SendMessageW(hwnd, WM_SETVISIBLE, TRUE, 0L);
 
     /* if the move is canceled, restore the previous position */
     if (moved && msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
     {
-        NtUserSetWindowPos(hwnd, 0, origRect.left, origRect.top, 0, 0,
-                           SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
+        SetWindowPos(hwnd, 0, origRect.left, origRect.top, 0, 0,
+                     SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
     }
 
     return 0;
@@ -1493,16 +1479,16 @@ static void perform_window_command(HWND hwnd, DWORD style_any, DWORD style_none,
     TRACE("win %p style_any 0x%08x style_none 0x%08x command 0x%04x hittest 0x%04x\n",
           hwnd, style_any, style_none, command, hittest);
 
-    style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    style = GetWindowLongW(hwnd, GWL_STYLE);
     if ((style_any && !(style & style_any)) || (style & (WS_DISABLED | style_none)))
     {
         TRACE("not changing win %p style 0x%08x\n", hwnd, style);
         return;
     }
 
-    if (get_active_window() != hwnd)
+    if (GetActiveWindow() != hwnd)
     {
-        LRESULT ma = send_message(hwnd, WM_MOUSEACTIVATE, (WPARAM)NtUserGetAncestor(hwnd, GA_ROOT),
+        LRESULT ma = SendMessageW(hwnd, WM_MOUSEACTIVATE, (WPARAM)GetAncestor(hwnd, GA_ROOT),
                                   MAKELPARAM(hittest, WM_NCLBUTTONDOWN));
         switch (ma)
         {
@@ -1514,7 +1500,7 @@ static void perform_window_command(HWND hwnd, DWORD style_any, DWORD style_none,
                 break;
             case MA_ACTIVATE:
             case 0:
-                NtUserSetActiveWindow(hwnd);
+                SetActiveWindow(hwnd);
                 break;
             default:
                 WARN("unknown WM_MOUSEACTIVATE code %ld\n", ma);
@@ -1523,14 +1509,14 @@ static void perform_window_command(HWND hwnd, DWORD style_any, DWORD style_none,
     }
 
     TRACE("changing win %p\n", hwnd);
-    NtUserPostMessage(hwnd, WM_SYSCOMMAND, command, 0);
+    PostMessageW(hwnd, WM_SYSCOMMAND, command, 0);
 }
 
 
 /**********************************************************************
  *              CreateDesktopWindow   (MACDRV.@)
  */
-BOOL macdrv_CreateDesktopWindow(HWND hwnd)
+BOOL CDECL macdrv_CreateDesktopWindow(HWND hwnd)
 {
     unsigned int width, height;
 
@@ -1571,9 +1557,11 @@ BOOL macdrv_CreateDesktopWindow(HWND hwnd)
 }
 
 
+static WNDPROC desktop_orig_wndproc;
+
 #define WM_WINE_NOTIFY_ACTIVITY WM_USER
 
-LRESULT macdrv_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+static LRESULT CALLBACK desktop_wndproc_wrapper( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
 {
     switch (msg)
     {
@@ -1592,13 +1580,29 @@ LRESULT macdrv_DesktopWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
         break;
     }
     }
-    return NtUserMessageCall(hwnd, msg, wp, lp, 0, NtUserDefWindowProc, FALSE);
+    return desktop_orig_wndproc( hwnd, msg, wp, lp );
 }
 
+/**********************************************************************
+ *              CreateWindow   (MACDRV.@)
+ */
+BOOL CDECL macdrv_CreateWindow(HWND hwnd)
+{
+    if (hwnd == GetDesktopWindow())
+    {
+        desktop_orig_wndproc = (WNDPROC)SetWindowLongPtrW( GetDesktopWindow(),
+            GWLP_WNDPROC, (LONG_PTR)desktop_wndproc_wrapper );
+
+        macdrv_init_clipboard();
+    }
+    return TRUE;
+}
+
+
 /***********************************************************************
  *              DestroyWindow   (MACDRV.@)
  */
-void macdrv_DestroyWindow(HWND hwnd)
+void CDECL macdrv_DestroyWindow(HWND hwnd)
 {
     struct macdrv_win_data *data;
 
@@ -1606,8 +1610,8 @@ void macdrv_DestroyWindow(HWND hwnd)
 
     if (!(data = get_win_data(hwnd))) return;
 
-    if (hwnd == get_capture()) macdrv_SetCapture(0, 0);
-    if (data->drag_event) NtSetEvent(data->drag_event, NULL);
+    if (hwnd == GetCapture()) macdrv_SetCapture(0, 0);
+    if (data->drag_event) SetEvent(data->drag_event);
 
     destroy_cocoa_window(data);
     destroy_cocoa_view(data);
@@ -1624,7 +1628,7 @@ void macdrv_DestroyWindow(HWND hwnd)
  *
  * Set the Mac focus.
  */
-void macdrv_SetFocus(HWND hwnd)
+void CDECL macdrv_SetFocus(HWND hwnd)
 {
     struct macdrv_thread_data *thread_data = macdrv_thread_data();
 
@@ -1641,7 +1645,7 @@ void macdrv_SetFocus(HWND hwnd)
  *
  * Set transparency attributes for a layered window.
  */
-void macdrv_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags)
+void CDECL macdrv_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWORD flags)
 {
     struct macdrv_win_data *data = get_win_data(hwnd);
 
@@ -1656,7 +1660,7 @@ void macdrv_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWOR
         {
             sync_window_opacity(data, key, alpha, FALSE, flags);
             /* since layered attributes are now set, can now show the window */
-            if ((NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_VISIBLE) && !data->on_screen)
+            if ((GetWindowLongW(hwnd, GWL_STYLE) & WS_VISIBLE) && !data->on_screen)
                 show_window(data);
         }
         release_win_data(data);
@@ -1669,7 +1673,7 @@ void macdrv_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWOR
 /*****************************************************************
  *              SetParent   (MACDRV.@)
  */
-void macdrv_SetParent(HWND hwnd, HWND parent, HWND old_parent)
+void CDECL macdrv_SetParent(HWND hwnd, HWND parent, HWND old_parent)
 {
     struct macdrv_win_data *data;
 
@@ -1678,9 +1682,9 @@ void macdrv_SetParent(HWND hwnd, HWND parent, HWND old_parent)
     if (parent == old_parent) return;
     if (!(data = get_win_data(hwnd))) return;
 
-    if (parent != NtUserGetDesktopWindow()) /* a child window */
+    if (parent != GetDesktopWindow()) /* a child window */
     {
-        if (old_parent == NtUserGetDesktopWindow())
+        if (old_parent == GetDesktopWindow())
         {
             /* destroy the old Mac window */
             destroy_cocoa_window(data);
@@ -1703,7 +1707,7 @@ void macdrv_SetParent(HWND hwnd, HWND parent, HWND old_parent)
  *
  * Assign specified region to window (for non-rectangular windows)
  */
-void macdrv_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
+void CDECL macdrv_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
 {
     struct macdrv_win_data *data;
 
@@ -1718,9 +1722,9 @@ void macdrv_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
     {
         DWORD procid;
 
-        NtUserGetWindowThread(hwnd, &procid);
+        GetWindowThreadProcessId(hwnd, &procid);
         if (procid != GetCurrentProcessId())
-            send_message(hwnd, WM_MACDRV_SET_WIN_REGION, 0, 0);
+            SendMessageW(hwnd, WM_MACDRV_SET_WIN_REGION, 0, 0);
     }
 }
 
@@ -1730,13 +1734,13 @@ void macdrv_SetWindowRgn(HWND hwnd, HRGN hrgn, BOOL redraw)
  *
  * Update the state of the Cocoa window to reflect a style change
  */
-void macdrv_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
+void CDECL macdrv_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
 {
     struct macdrv_win_data *data;
 
     TRACE("hwnd %p offset %d styleOld 0x%08x styleNew 0x%08x\n", hwnd, offset, style->styleOld, style->styleNew);
 
-    if (hwnd == NtUserGetDesktopWindow()) return;
+    if (hwnd == GetDesktopWindow()) return;
     if (!(data = get_win_data(hwnd))) return;
 
     if (data->cocoa_window)
@@ -1764,21 +1768,21 @@ void macdrv_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
 /*****************************************************************
  *              SetWindowText   (MACDRV.@)
  */
-void macdrv_SetWindowText(HWND hwnd, LPCWSTR text)
+void CDECL macdrv_SetWindowText(HWND hwnd, LPCWSTR text)
 {
     macdrv_window win;
 
     TRACE("%p, %s\n", hwnd, debugstr_w(text));
 
     if ((win = macdrv_get_cocoa_window(hwnd, FALSE)))
-        macdrv_set_cocoa_window_title(win, text, wcslen(text));
+        macdrv_set_cocoa_window_title(win, text, strlenW(text));
 }
 
 
 /***********************************************************************
  *              ShowWindow   (MACDRV.@)
  */
-UINT macdrv_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
+UINT CDECL macdrv_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
 {
     struct macdrv_thread_data *thread_data = macdrv_thread_data();
     struct macdrv_win_data *data = get_win_data(hwnd);
@@ -1788,7 +1792,7 @@ UINT macdrv_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
           hwnd, data ? data->cocoa_window : NULL, cmd, wine_dbgstr_rect(rect), swp);
 
     if (!data || !data->cocoa_window) goto done;
-    if (NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE)
+    if (GetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE)
     {
         if (rect->left != -32000 || rect->top != -32000)
         {
@@ -1825,7 +1829,7 @@ done:
  *
  * Perform WM_SYSCOMMAND handling.
  */
-LRESULT macdrv_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
+LRESULT CDECL macdrv_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
 {
     struct macdrv_win_data *data;
     LRESULT ret = -1;
@@ -1838,9 +1842,8 @@ LRESULT macdrv_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
 
     /* prevent a simple ALT press+release from activating the system menu,
        as that can get confusing */
-    if (command == SC_KEYMENU && !(WCHAR)lparam &&
-        !NtUserGetWindowLongPtrW(hwnd, GWLP_ID) &&
-        (NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_SYSMENU))
+    if (command == SC_KEYMENU && !(WCHAR)lparam && !GetMenu(hwnd) &&
+        (GetWindowLongW(hwnd, GWL_STYLE) & WS_SYSMENU))
     {
         TRACE("ignoring SC_KEYMENU wp %lx lp %lx\n", wparam, lparam);
         ret = 0;
@@ -1861,8 +1864,8 @@ done:
 /***********************************************************************
  *              UpdateLayeredWindow   (MACDRV.@)
  */
-BOOL macdrv_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
-                                const RECT *window_rect)
+BOOL CDECL macdrv_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                      const RECT *window_rect)
 {
     struct window_surface *surface;
     struct macdrv_win_data *data;
@@ -1928,7 +1931,7 @@ BOOL macdrv_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
     NtGdiSelectBitmap(hdc, dib);
     if (info->prcDirty)
     {
-        intersect_rect(&rect, &rect, info->prcDirty);
+        IntersectRect(&rect, &rect, info->prcDirty);
         surface->funcs->lock(surface);
         memcpy(src_bits, dst_bits, bmi->bmiHeader.biSizeImage);
         surface->funcs->unlock(surface);
@@ -1972,7 +1975,7 @@ done:
 /**********************************************************************
  *              WindowMessage   (MACDRV.@)
  */
-LRESULT macdrv_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
+LRESULT CDECL macdrv_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
 {
     struct macdrv_win_data *data;
 
@@ -1988,23 +1991,23 @@ LRESULT macdrv_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
         }
         return 0;
     case WM_MACDRV_UPDATE_DESKTOP_RECT:
-        if (hwnd == NtUserGetDesktopWindow())
+        if (hwnd == GetDesktopWindow())
         {
             CGRect new_desktop_rect;
             RECT current_desktop_rect;
 
             macdrv_reset_device_metrics();
             new_desktop_rect = macdrv_get_desktop_rect();
-            if (!NtUserGetWindowRect(hwnd, &current_desktop_rect) ||
+            if (!GetWindowRect(hwnd, &current_desktop_rect) ||
                 !CGRectEqualToRect(cgrect_from_rect(current_desktop_rect), new_desktop_rect))
             {
-                send_message_timeout(HWND_BROADCAST, WM_MACDRV_RESET_DEVICE_METRICS, 0, 0,
-                                     SMTO_ABORTIFHUNG, 2000, NULL);
-                NtUserSetWindowPos(hwnd, 0, CGRectGetMinX(new_desktop_rect), CGRectGetMinY(new_desktop_rect),
-                                   CGRectGetWidth(new_desktop_rect), CGRectGetHeight(new_desktop_rect),
-                                   SWP_NOZORDER | SWP_NOACTIVATE | SWP_DEFERERASE);
-                send_message_timeout(HWND_BROADCAST, WM_MACDRV_DISPLAYCHANGE, wp, lp,
-                                     SMTO_ABORTIFHUNG, 2000, NULL);
+                SendMessageTimeoutW(HWND_BROADCAST, WM_MACDRV_RESET_DEVICE_METRICS, 0, 0,
+                                    SMTO_ABORTIFHUNG, 2000, NULL);
+                SetWindowPos(hwnd, 0, CGRectGetMinX(new_desktop_rect), CGRectGetMinY(new_desktop_rect),
+                             CGRectGetWidth(new_desktop_rect), CGRectGetHeight(new_desktop_rect),
+                             SWP_NOZORDER | SWP_NOACTIVATE | SWP_DEFERERASE);
+                SendMessageTimeoutW(HWND_BROADCAST, WM_MACDRV_DISPLAYCHANGE, wp, lp,
+                                    SMTO_ABORTIFHUNG, 2000, NULL);
             }
         }
         return 0;
@@ -2013,7 +2016,7 @@ LRESULT macdrv_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
         return 0;
     case WM_MACDRV_DISPLAYCHANGE:
         macdrv_reassert_window_position(hwnd);
-        send_message(hwnd, WM_DISPLAYCHANGE, wp, lp);
+        SendMessageW(hwnd, WM_DISPLAYCHANGE, wp, lp);
         return 0;
     case WM_MACDRV_ACTIVATE_ON_FOLLOWING_FOCUS:
         activate_on_following_focus();
@@ -2031,7 +2034,7 @@ static inline RECT get_surface_rect(const RECT *visible_rect)
     RECT rect;
     RECT desktop_rect = rect_from_cgrect(macdrv_get_desktop_rect());
 
-    intersect_rect(&rect, visible_rect, &desktop_rect);
+    IntersectRect(&rect, visible_rect, &desktop_rect);
     OffsetRect(&rect, -visible_rect->left, -visible_rect->top);
     rect.left &= ~127;
     rect.top  &= ~127;
@@ -2044,12 +2047,12 @@ static inline RECT get_surface_rect(const RECT *visible_rect)
 /***********************************************************************
  *              WindowPosChanging   (MACDRV.@)
  */
-BOOL macdrv_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
-                              const RECT *window_rect, const RECT *client_rect,
-                              RECT *visible_rect, struct window_surface **surface)
+BOOL CDECL macdrv_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                    const RECT *window_rect, const RECT *client_rect,
+                                    RECT *visible_rect, struct window_surface **surface)
 {
     struct macdrv_win_data *data = get_win_data(hwnd);
-    DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    DWORD style = GetWindowLongW(hwnd, GWL_STYLE);
     RECT surface_rect;
 
     TRACE("%p after %p swp %04x window %s client %s visible %s surface %p\n", hwnd, insert_after,
@@ -2096,14 +2099,14 @@ done:
 /***********************************************************************
  *              WindowPosChanged   (MACDRV.@)
  */
-void macdrv_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
-                             const RECT *window_rect, const RECT *client_rect,
-                             const RECT *visible_rect, const RECT *valid_rects,
-                             struct window_surface *surface)
+void CDECL macdrv_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                                   const RECT *window_rect, const RECT *client_rect,
+                                   const RECT *visible_rect, const RECT *valid_rects,
+                                   struct window_surface *surface)
 {
     struct macdrv_thread_data *thread_data;
     struct macdrv_win_data *data;
-    DWORD new_style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    DWORD new_style = GetWindowLongW(hwnd, GWL_STYLE);
     RECT old_window_rect, old_whole_rect, old_client_rect;
 
     if (!(data = get_win_data(hwnd))) return;
@@ -2214,7 +2217,7 @@ void macdrv_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
 
             /* layered windows are not shown until their attributes are set */
             if (!data->on_screen &&
-                (data->layered || !(NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED)))
+                (data->layered || !(GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED)))
                 show_window(data);
         }
         else if (!data->on_screen)
@@ -2235,17 +2238,16 @@ void macdrv_window_close_requested(HWND hwnd)
 {
     HMENU sysmenu;
 
-    if (NtUserGetClassLongW(hwnd, GCL_STYLE) & CS_NOCLOSE)
+    if (GetClassLongW(hwnd, GCL_STYLE) & CS_NOCLOSE)
     {
         TRACE("not closing win %p class style CS_NOCLOSE\n", hwnd);
         return;
     }
 
-    sysmenu = NtUserGetSystemMenu(hwnd, FALSE);
+    sysmenu = GetSystemMenu(hwnd, FALSE);
     if (sysmenu)
     {
-        UINT state = NtUserThunkedMenuItemInfo(sysmenu, SC_CLOSE, MF_BYCOMMAND,
-                                               NtUserGetMenuState, NULL, NULL);
+        UINT state = GetMenuState(sysmenu, SC_CLOSE, MF_BYCOMMAND);
         if (state == 0xFFFFFFFF || (state & (MF_DISABLED | MF_GRAYED)))
         {
             TRACE("not closing win %p menu state 0x%08x\n", hwnd, state);
@@ -2281,7 +2283,7 @@ void macdrv_window_frame_changed(HWND hwnd, const macdrv_event *event)
 
     /* Get geometry */
 
-    parent = NtUserGetAncestor(hwnd, GA_PARENT);
+    parent = GetAncestor(hwnd, GA_PARENT);
 
     TRACE("win %p/%p new Cocoa frame %s fullscreen %d in_resize %d\n", hwnd, data->cocoa_window,
           wine_dbgstr_cgrect(event->window_frame_changed.frame),
@@ -2289,7 +2291,7 @@ void macdrv_window_frame_changed(HWND hwnd, const macdrv_event *event)
 
     rect = rect_from_cgrect(event->window_frame_changed.frame);
     macdrv_mac_to_window_rect(data, &rect);
-    NtUserMapWindowPoints(0, parent, (POINT *)&rect, 2);
+    MapWindowPoints(0, parent, (POINT *)&rect, 2);
 
     width = rect.right - rect.left;
     height = rect.bottom - rect.top;
@@ -2317,10 +2319,10 @@ void macdrv_window_frame_changed(HWND hwnd, const macdrv_event *event)
     {
         int send_sizemove = !event->window_frame_changed.in_resize && !being_dragged && !event->window_frame_changed.skip_size_move_loop;
         if (send_sizemove)
-            send_message(hwnd, WM_ENTERSIZEMOVE, 0, 0);
-        NtUserSetWindowPos(hwnd, 0, rect.left, rect.top, width, height, flags);
+            SendMessageW(hwnd, WM_ENTERSIZEMOVE, 0, 0);
+        SetWindowPos(hwnd, 0, rect.left, rect.top, width, height, flags);
         if (send_sizemove)
-            send_message(hwnd, WM_EXITSIZEMOVE, 0, 0);
+            SendMessageW(hwnd, WM_EXITSIZEMOVE, 0, 0);
     }
 }
 
@@ -2332,25 +2334,25 @@ void macdrv_window_frame_changed(HWND hwnd, const macdrv_event *event)
  */
 void macdrv_window_got_focus(HWND hwnd, const macdrv_event *event)
 {
-    LONG style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    LONG style = GetWindowLongW(hwnd, GWL_STYLE);
 
     if (!hwnd) return;
 
     TRACE("win %p/%p serial %lu enabled %d visible %d style %08x focus %p active %p fg %p\n",
-          hwnd, event->window, event->window_got_focus.serial, NtUserIsWindowEnabled(hwnd),
-          NtUserIsWindowVisible(hwnd), style, get_focus(), get_active_window(), NtUserGetForegroundWindow());
+          hwnd, event->window, event->window_got_focus.serial, IsWindowEnabled(hwnd),
+          IsWindowVisible(hwnd), style, GetFocus(), GetActiveWindow(), GetForegroundWindow());
 
     if (can_window_become_foreground(hwnd) && !(style & WS_MINIMIZE))
     {
         /* simulate a mouse click on the menu to find out
          * whether the window wants to be activated */
-        LRESULT ma = send_message(hwnd, WM_MOUSEACTIVATE,
-                                  (WPARAM)NtUserGetAncestor(hwnd, GA_ROOT),
+        LRESULT ma = SendMessageW(hwnd, WM_MOUSEACTIVATE,
+                                  (WPARAM)GetAncestor(hwnd, GA_ROOT),
                                   MAKELONG(HTMENU, WM_LBUTTONDOWN));
         if (ma != MA_NOACTIVATEANDEAT && ma != MA_NOACTIVATE)
         {
             TRACE("setting foreground window to %p\n", hwnd);
-            NtUserSetForegroundWindow(hwnd, FALSE);
+            SetForegroundWindow(hwnd);
             return;
         }
     }
@@ -2369,13 +2371,13 @@ void macdrv_window_lost_focus(HWND hwnd, const macdrv_event *event)
 {
     if (!hwnd) return;
 
-    TRACE("win %p/%p fg %p\n", hwnd, event->window, NtUserGetForegroundWindow());
+    TRACE("win %p/%p fg %p\n", hwnd, event->window, GetForegroundWindow());
 
-    if (hwnd == NtUserGetForegroundWindow())
+    if (hwnd == GetForegroundWindow())
     {
-        send_message(hwnd, WM_CANCELMODE, 0, 0);
-        if (hwnd == NtUserGetForegroundWindow())
-            NtUserSetForegroundWindow(NtUserGetDesktopWindow(), FALSE);
+        SendMessageW(hwnd, WM_CANCELMODE, 0, 0);
+        if (hwnd == GetForegroundWindow())
+            SetForegroundWindow(GetDesktopWindow());
     }
 }
 
@@ -2399,12 +2401,12 @@ void macdrv_app_activated(void)
  */
 void macdrv_app_deactivated(void)
 {
-    NtUserClipCursor(NULL);
+    ClipCursor(NULL);
 
-    if (get_active_window() == NtUserGetForegroundWindow())
+    if (GetActiveWindow() == GetForegroundWindow())
     {
         TRACE("setting fg to desktop\n");
-        NtUserSetForegroundWindow(NtUserGetDesktopWindow(), FALSE);
+        SetForegroundWindow(GetDesktopWindow());
     }
 }
 
@@ -2442,7 +2444,7 @@ void macdrv_window_did_minimize(HWND hwnd)
 
     /* If all our windows are minimized, disable cursor clipping. */
     if (!macdrv_is_any_wine_window_visible())
-        NtUserClipCursor(NULL);
+        ClipCursor(NULL);
 }
 
 
@@ -2461,15 +2463,15 @@ void macdrv_window_did_unminimize(HWND hwnd)
     if (!(data = get_win_data(hwnd))) return;
     if (!data->minimized) goto done;
 
-    style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    style = GetWindowLongW(hwnd, GWL_STYLE);
 
     data->minimized = FALSE;
     if ((style & (WS_MINIMIZE | WS_VISIBLE)) == (WS_MINIMIZE | WS_VISIBLE))
     {
         TRACE("restoring win %p/%p\n", hwnd, data->cocoa_window);
         release_win_data(data);
-        NtUserSetActiveWindow(hwnd);
-        send_message(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
+        SetActiveWindow(hwnd);
+        SendMessageW(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
         return;
     }
 
@@ -2488,7 +2490,7 @@ done:
 void macdrv_window_brought_forward(HWND hwnd)
 {
     TRACE("win %p\n", hwnd);
-    NtUserSetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
+    SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
 }
 
 
@@ -2500,7 +2502,7 @@ void macdrv_window_brought_forward(HWND hwnd)
 void macdrv_window_resize_ended(HWND hwnd)
 {
     TRACE("hwnd %p\n", hwnd);
-    send_message(hwnd, WM_EXITSIZEMOVE, 0, 0);
+    SendMessageW(hwnd, WM_EXITSIZEMOVE, 0, 0);
 }
 
 
@@ -2514,21 +2516,21 @@ void macdrv_window_restore_requested(HWND hwnd, const macdrv_event *event)
 {
     if (event->window_restore_requested.keep_frame && hwnd)
     {
-        DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+        DWORD style = GetWindowLongW(hwnd, GWL_STYLE);
         struct macdrv_win_data *data;
 
         if ((style & WS_MAXIMIZE) && (style & WS_VISIBLE) && (data = get_win_data(hwnd)))
         {
             RECT rect;
-            HWND parent = NtUserGetAncestor(hwnd, GA_PARENT);
+            HWND parent = GetAncestor(hwnd, GA_PARENT);
 
             rect = rect_from_cgrect(event->window_restore_requested.frame);
             macdrv_mac_to_window_rect(data, &rect);
-            NtUserMapWindowPoints(0, parent, (POINT *)&rect, 2);
+            MapWindowPoints(0, parent, (POINT *)&rect, 2);
 
             release_win_data(data);
 
-            NtUserSetInternalWindowPos(hwnd, SW_SHOW, &rect, NULL);
+            SetInternalWindowPos(hwnd, SW_SHOW, &rect, NULL);
         }
     }
 
@@ -2543,10 +2545,9 @@ void macdrv_window_restore_requested(HWND hwnd, const macdrv_event *event)
  */
 void macdrv_window_drag_begin(HWND hwnd, const macdrv_event *event)
 {
-    DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    DWORD style = GetWindowLongW(hwnd, GWL_STYLE);
     struct macdrv_win_data *data;
     HANDLE drag_event = NULL;
-    OBJECT_ATTRIBUTES attr;
     BOOL loop = TRUE;
     MSG msg;
 
@@ -2558,35 +2559,33 @@ void macdrv_window_drag_begin(HWND hwnd, const macdrv_event *event)
     if (!(data = get_win_data(hwnd))) return;
     if (data->drag_event) goto done;
 
-    InitializeObjectAttributes(&attr, NULL, OBJ_OPENIF, NULL, NULL);
-    if (NtCreateEvent(&drag_event, EVENT_ALL_ACCESS, &attr, NotificationEvent, FALSE)) goto done;
+    drag_event = CreateEventW(NULL, TRUE, FALSE, NULL);
+    if (!drag_event) goto done;
 
     data->drag_event = drag_event;
     release_win_data(data);
 
-    if (!event->window_drag_begin.no_activate && can_window_become_foreground(hwnd) &&
-        NtUserGetForegroundWindow() != hwnd)
+    if (!event->window_drag_begin.no_activate && can_window_become_foreground(hwnd) && GetForegroundWindow() != hwnd)
     {
         /* ask whether the window wants to be activated */
-        LRESULT ma = send_message(hwnd, WM_MOUSEACTIVATE, (WPARAM)NtUserGetAncestor(hwnd, GA_ROOT),
+        LRESULT ma = SendMessageW(hwnd, WM_MOUSEACTIVATE, (WPARAM)GetAncestor(hwnd, GA_ROOT),
                                   MAKELONG(HTCAPTION, WM_LBUTTONDOWN));
         if (ma != MA_NOACTIVATEANDEAT && ma != MA_NOACTIVATE)
         {
             TRACE("setting foreground window to %p\n", hwnd);
-            NtUserSetForegroundWindow(hwnd, FALSE);
+            SetForegroundWindow(hwnd);
         }
     }
 
-    NtUserClipCursor(NULL);
-    send_message(hwnd, WM_ENTERSIZEMOVE, 0, 0);
-    NtUserReleaseCapture();
+    ClipCursor(NULL);
+    SendMessageW(hwnd, WM_ENTERSIZEMOVE, 0, 0);
+    ReleaseCapture();
 
     while (loop)
     {
-        while (!NtUserPeekMessage(&msg, 0, 0, 0, PM_REMOVE))
+        while (!PeekMessageW(&msg, 0, 0, 0, PM_REMOVE))
         {
-            DWORD result = NtUserMsgWaitForMultipleObjectsEx(1, &drag_event, INFINITE, QS_ALLINPUT,
-                                                             MWMO_INPUTAVAILABLE);
+            DWORD result = MsgWaitForMultipleObjectsEx(1, &drag_event, INFINITE, QS_ALLINPUT, MWMO_INPUTAVAILABLE);
             if (result == WAIT_OBJECT_0)
             {
                 loop = FALSE;
@@ -2599,15 +2598,15 @@ void macdrv_window_drag_begin(HWND hwnd, const macdrv_event *event)
         if (msg.message == WM_QUIT)
             break;
 
-        if (!NtUserCallMsgFilter(&msg, MSGF_SIZE) && msg.message != WM_KEYDOWN &&
+        if (!CallMsgFilterW(&msg, MSGF_SIZE) && msg.message != WM_KEYDOWN &&
             msg.message != WM_MOUSEMOVE && msg.message != WM_LBUTTONDOWN && msg.message != WM_LBUTTONUP)
         {
-            NtUserTranslateMessage(&msg, 0);
-            NtUserDispatchMessage(&msg);
+            TranslateMessage(&msg);
+            DispatchMessageW(&msg);
         }
     }
 
-    send_message(hwnd, WM_EXITSIZEMOVE, 0, 0);
+    SendMessageW(hwnd, WM_EXITSIZEMOVE, 0, 0);
 
     TRACE("done\n");
 
@@ -2616,7 +2615,7 @@ void macdrv_window_drag_begin(HWND hwnd, const macdrv_event *event)
 
 done:
     release_win_data(data);
-    if (drag_event) NtClose(drag_event);
+    if (drag_event) CloseHandle(drag_event);
 }
 
 
@@ -2633,7 +2632,7 @@ void macdrv_window_drag_end(HWND hwnd)
 
     if (!(data = get_win_data(hwnd))) return;
     if (data->drag_event)
-        NtSetEvent(data->drag_event, NULL);
+        SetEvent(data->drag_event);
     release_win_data(data);
 }
 
@@ -2655,6 +2654,114 @@ void macdrv_reassert_window_position(HWND hwnd)
 }
 
 
+struct quit_info {
+    HWND               *wins;
+    UINT                capacity;
+    UINT                count;
+    UINT                done;
+    DWORD               flags;
+    BOOL                result;
+    BOOL                replied;
+};
+
+
+static BOOL CALLBACK get_process_windows(HWND hwnd, LPARAM lp)
+{
+    struct quit_info *qi = (struct quit_info*)lp;
+    DWORD pid;
+
+    GetWindowThreadProcessId(hwnd, &pid);
+    if (pid == GetCurrentProcessId())
+    {
+        if (qi->count >= qi->capacity)
+        {
+            UINT new_cap = qi->capacity * 2;
+            HWND *new_wins = realloc(qi->wins, new_cap * sizeof(*qi->wins));
+            if (!new_wins) return FALSE;
+            qi->wins = new_wins;
+            qi->capacity = new_cap;
+        }
+
+        qi->wins[qi->count++] = hwnd;
+    }
+
+    return TRUE;
+}
+
+
+static void CALLBACK quit_callback(HWND hwnd, UINT msg, ULONG_PTR data, LRESULT result)
+{
+    struct quit_info *qi = (struct quit_info*)data;
+
+    qi->done++;
+
+    if (msg == WM_QUERYENDSESSION)
+    {
+        TRACE("got WM_QUERYENDSESSION result %ld from win %p (%u of %u done)\n", result,
+              hwnd, qi->done, qi->count);
+
+        if (!result && !IsWindow(hwnd))
+        {
+            TRACE("win %p no longer exists; ignoring apparent refusal\n", hwnd);
+            result = TRUE;
+        }
+
+        if (!result && qi->result)
+        {
+            qi->result = FALSE;
+
+            /* On the first FALSE from WM_QUERYENDSESSION, we already know the
+               ultimate reply.  Might as well tell Cocoa now. */
+            if (!qi->replied)
+            {
+                qi->replied = TRUE;
+                TRACE("giving quit reply %d\n", qi->result);
+                macdrv_quit_reply(qi->result);
+            }
+        }
+
+        if (qi->done >= qi->count)
+        {
+            UINT i;
+
+            qi->done = 0;
+            for (i = 0; i < qi->count; i++)
+            {
+                TRACE("sending WM_ENDSESSION to win %p result %d flags 0x%08x\n", qi->wins[i],
+                      qi->result, qi->flags);
+                if (!SendMessageCallbackW(qi->wins[i], WM_ENDSESSION, qi->result, qi->flags,
+                                          quit_callback, (ULONG_PTR)qi))
+                {
+                    WARN("failed to send WM_ENDSESSION to win %p; error 0x%08x\n",
+                         qi->wins[i], GetLastError());
+                    quit_callback(qi->wins[i], WM_ENDSESSION, (ULONG_PTR)qi, 0);
+                }
+            }
+        }
+    }
+    else /* WM_ENDSESSION */
+    {
+        TRACE("finished WM_ENDSESSION for win %p (%u of %u done)\n", hwnd, qi->done, qi->count);
+
+        if (qi->done >= qi->count)
+        {
+            if (!qi->replied)
+            {
+                TRACE("giving quit reply %d\n", qi->result);
+                macdrv_quit_reply(qi->result);
+            }
+
+            TRACE("%sterminating process\n", qi->result ? "" : "not ");
+            if (qi->result)
+                TerminateProcess(GetCurrentProcess(), 0);
+
+            free(qi->wins);
+            free(qi);
+        }
+    }
+}
+
+
 /***********************************************************************
  *              macdrv_app_quit_requested
  *
@@ -2662,14 +2769,66 @@ void macdrv_reassert_window_position(HWND hwnd)
  */
 void macdrv_app_quit_requested(const macdrv_event *event)
 {
-    struct app_quit_request_params params = { .flags = 0 };
+    struct quit_info *qi;
+    UINT i;
 
     TRACE("reason %d\n", event->app_quit_requested.reason);
 
-    if (event->app_quit_requested.reason == QUIT_REASON_LOGOUT)
-        params.flags = ENDSESSION_LOGOFF;
+    qi = malloc(sizeof(*qi));
+    if (!qi)
+        goto fail;
+
+    qi->capacity = 32;
+    qi->wins = malloc(qi->capacity * sizeof(*qi->wins));
+    qi->count = qi->done = 0;
+
+    if (!qi->wins || !EnumWindows(get_process_windows, (LPARAM)qi))
+        goto fail;
+
+    switch (event->app_quit_requested.reason)
+    {
+        case QUIT_REASON_LOGOUT:
+        default:
+            qi->flags = ENDSESSION_LOGOFF;
+            break;
+        case QUIT_REASON_RESTART:
+        case QUIT_REASON_SHUTDOWN:
+            qi->flags = 0;
+            break;
+    }
+
+    qi->result = TRUE;
+    qi->replied = FALSE;
+
+    for (i = 0; i < qi->count; i++)
+    {
+        TRACE("sending WM_QUERYENDSESSION to win %p\n", qi->wins[i]);
+        if (!SendMessageCallbackW(qi->wins[i], WM_QUERYENDSESSION, 0, qi->flags,
+                                  quit_callback, (ULONG_PTR)qi))
+        {
+            DWORD error = GetLastError();
+            BOOL invalid = (error == ERROR_INVALID_WINDOW_HANDLE);
+            if (invalid)
+                TRACE("failed to send WM_QUERYENDSESSION to win %p because it's invalid; assuming success\n",
+                     qi->wins[i]);
+            else
+                WARN("failed to send WM_QUERYENDSESSION to win %p; error 0x%08x; assuming refusal\n",
+                     qi->wins[i], error);
+            quit_callback(qi->wins[i], WM_QUERYENDSESSION, (ULONG_PTR)qi, invalid);
+        }
+    }
+
+    /* quit_callback() will clean up qi */
+    return;
 
-    macdrv_client_func(client_func_app_quit_request, &params, sizeof(params));
+fail:
+    WARN("failed to allocate window list\n");
+    if (qi)
+    {
+        free(qi->wins);
+        free(qi);
+    }
+    macdrv_quit_reply(FALSE);
 }
 
 
@@ -2701,9 +2860,9 @@ BOOL query_resize_size(HWND hwnd, macdrv_query *query)
     else
         corner = WMSZ_BOTTOMRIGHT;
 
-    if (send_message(hwnd, WM_SIZING, corner, (LPARAM)&rect))
+    if (SendMessageW(hwnd, WM_SIZING, corner, (LPARAM)&rect))
     {
-        macdrv_window_to_mac_rect(data, NtUserGetWindowLongW(hwnd, GWL_STYLE), &rect,
+        macdrv_window_to_mac_rect(data, GetWindowLongW(hwnd, GWL_STYLE), &rect,
                                   &data->window_rect, &data->client_rect);
         query->resize_size.rect = cgrect_from_rect(rect);
         ret = TRUE;
@@ -2723,10 +2882,10 @@ BOOL query_resize_start(HWND hwnd)
 {
     TRACE("hwnd %p\n", hwnd);
 
-    NtUserClipCursor(NULL);
+    ClipCursor(NULL);
 
     sync_window_min_max_info(hwnd);
-    send_message(hwnd, WM_ENTERSIZEMOVE, 0, 0);
+    SendMessageW(hwnd, WM_ENTERSIZEMOVE, 0, 0);
 
     return TRUE;
 }
diff --git a/dlls/wineps.drv/init.c b/dlls/wineps.drv/init.c
index 0d4467b6964..04b00e82709 100644
--- a/dlls/wineps.drv/init.c
+++ b/dlls/wineps.drv/init.c
@@ -857,9 +857,6 @@ static const struct gdi_dc_funcs psdrv_funcs =
     PSDRV_StrokePath,                   /* pStrokePath */
     NULL,                               /* pUnrealizePalette */
     NULL,                               /* pD3DKMTCheckVidPnExclusiveOwnership */
-    NULL,                               /* pD3DKMTCloseAdapter */
-    NULL,                               /* pD3DKMTOpenAdapterFromLuid */
-    NULL,                               /* pD3DKMTQueryVideoMemoryInfo */
     NULL,                               /* pD3DKMTSetVidPnSourceOwner */
     GDI_PRIORITY_GRAPHICS_DRV           /* priority */
 };
diff --git a/dlls/winex11.drv/Makefile.in b/dlls/winex11.drv/Makefile.in
index 3c653902ef2..93a975d7f63 100644
--- a/dlls/winex11.drv/Makefile.in
+++ b/dlls/winex11.drv/Makefile.in
@@ -1,10 +1,11 @@
 EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE    = winex11.drv
-UNIXLIB   = winex11.so
-IMPORTS   = uuid user32 gdi32 win32u
+IMPORTS   = uuid user32 gdi32 advapi32 win32u
 DELAYIMPORTS = comctl32 ole32 shell32 imm32
 UNIX_CFLAGS  = $(X_CFLAGS)
-UNIX_LIBS    = -lwin32u $(X_LIBS) $(X_EXTRA_LIBS) $(PTHREAD_LIBS) -lm
+UNIX_LIBS    = $(X_LIBS) $(X_EXTRA_LIBS)
+
+EXTRADLLFLAGS = -mcygwin
 
 C_SRCS = \
 	bitblt.c \
@@ -12,7 +13,6 @@ C_SRCS = \
 	clipboard.c \
 	desktop.c \
 	display.c \
-	dllmain.c \
 	event.c \
 	graphics.c \
 	ime.c \
diff --git a/dlls/winex11.drv/bitblt.c b/dlls/winex11.drv/bitblt.c
index 10388a1cc8f..fad183b0b01 100644
--- a/dlls/winex11.drv/bitblt.c
+++ b/dlls/winex11.drv/bitblt.c
@@ -19,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <assert.h>
@@ -46,6 +42,10 @@
 # endif
 #endif
 
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
 #include "x11drv.h"
 #include "winternl.h"
 #include "wine/debug.h"
@@ -849,14 +849,8 @@ BOOL CDECL X11DRV_StretchBlt( PHYSDEV dst_dev, struct bitblt_coords *dst,
         }
         if (physDevSrc->depth == 1)
         {
-            DWORD text_color, bk_color;
-            int text_pixel, bkgnd_pixel;
-
-            NtGdiGetDCDword( physDevDst->dev.hdc, NtGdiGetTextColor, &text_color );
-            text_pixel = X11DRV_PALETTE_ToPhysical( physDevDst, text_color );
-
-            NtGdiGetDCDword( physDevDst->dev.hdc, NtGdiGetBkColor, &bk_color );
-            bkgnd_pixel = X11DRV_PALETTE_ToPhysical( physDevDst, bk_color );
+            int text_pixel = X11DRV_PALETTE_ToPhysical( physDevDst, GetTextColor(physDevDst->dev.hdc) );
+            int bkgnd_pixel = X11DRV_PALETTE_ToPhysical( physDevDst, GetBkColor(physDevDst->dev.hdc) );
 
             XSetBackground( gdi_display, physDevDst->gc, text_pixel );
             XSetForeground( gdi_display, physDevDst->gc, bkgnd_pixel );
@@ -886,14 +880,8 @@ BOOL CDECL X11DRV_StretchBlt( PHYSDEV dst_dev, struct bitblt_coords *dst,
            to color or vice versa, the foreground and background color of
            the device context are used.  In fact, it also applies to the
            case when it is converted from mono to mono. */
-        DWORD text_color, bk_color;
-        int text_pixel, bkgnd_pixel;
-
-        NtGdiGetDCDword( physDevDst->dev.hdc, NtGdiGetTextColor, &text_color );
-        text_pixel = X11DRV_PALETTE_ToPhysical( physDevDst, text_color );
-
-        NtGdiGetDCDword( physDevDst->dev.hdc, NtGdiGetBkColor, &bk_color );
-        bkgnd_pixel = X11DRV_PALETTE_ToPhysical( physDevDst, bk_color );
+        int text_pixel = X11DRV_PALETTE_ToPhysical( physDevDst, GetTextColor(physDevDst->dev.hdc) );
+        int bkgnd_pixel = X11DRV_PALETTE_ToPhysical( physDevDst, GetBkColor(physDevDst->dev.hdc) );
 
         if (X11DRV_PALETTE_XPixelToPalette && physDevDst->depth != 1)
         {
@@ -928,7 +916,7 @@ BOOL CDECL X11DRV_StretchBlt( PHYSDEV dst_dev, struct bitblt_coords *dst,
 
 static void CDECL free_heap_bits( struct gdi_image_bits *bits )
 {
-    free( bits->ptr );
+    HeapFree( GetProcessHeap(), 0, bits->ptr );
 }
 
 static void CDECL free_ximage_bits( struct gdi_image_bits *bits )
@@ -1190,7 +1178,7 @@ DWORD copy_image_bits( BITMAPINFO *info, BOOL is_r8g8b8, XImage *image,
     {
         width_bytes = (width_bytes + 3) & ~3;
         info->bmiHeader.biSizeImage = height * width_bytes;
-        if (!(dst_bits->ptr = malloc( info->bmiHeader.biSizeImage )))
+        if (!(dst_bits->ptr = HeapAlloc( GetProcessHeap(), 0, info->bmiHeader.biSizeImage )))
             return ERROR_OUTOFMEMORY;
         dst_bits->is_copy = TRUE;
         dst_bits->free = free_heap_bits;
@@ -1492,7 +1480,7 @@ Pixmap create_pixmap_from_image( HDC hdc, const XVisualInfo *vis, const BITMAPIN
     {
         if (dst_info->bmiHeader.biBitCount == 1)  /* set a default color table for 1-bpp */
             memcpy( dst_info->bmiColors, default_colortable, sizeof(default_colortable) );
-        dib = NtGdiCreateDIBSection( hdc, 0, 0, dst_info, coloruse, 0, 0, 0, &dst_bits.ptr );
+        dib = CreateDIBSection( hdc, dst_info, coloruse, &dst_bits.ptr, 0, 0 );
         if (dib)
         {
             if (src_info->bmiHeader.biBitCount == 1 && !src_info->bmiHeader.biClrUsed)
@@ -1501,7 +1489,7 @@ Pixmap create_pixmap_from_image( HDC hdc, const XVisualInfo *vis, const BITMAPIN
             dst_bits.free = NULL;
             dst_bits.is_copy = TRUE;
             err = put_pixmap_image( pixmap, vis, dst_info, &dst_bits );
-            NtGdiDeleteObjectApp( dib );
+            DeleteObject( dib );
         }
         else err = ERROR_OUTOFMEMORY;
     }
@@ -1585,7 +1573,7 @@ struct x11drv_window_surface
 #ifdef HAVE_LIBXXSHM
     XShmSegmentInfo       shminfo;
 #endif
-    pthread_mutex_t       mutex;
+    CRITICAL_SECTION      crit;
     BITMAPINFO            info;   /* variable size, must be last */
 };
 
@@ -1604,9 +1592,9 @@ static inline UINT get_color_component( UINT color, UINT mask )
 #ifdef HAVE_LIBXSHAPE
 static inline void flush_rgn_data( HRGN rgn, RGNDATA *data )
 {
-    HRGN tmp = NtGdiExtCreateRegion( NULL, data->rdh.dwSize + data->rdh.nRgnSize, data );
-    NtGdiCombineRgn( rgn, rgn, tmp, RGN_OR );
-    NtGdiDeleteObjectApp( tmp );
+    HRGN tmp = ExtCreateRegion( NULL, data->rdh.dwSize + data->rdh.nRgnSize, data );
+    CombineRgn( rgn, rgn, tmp, RGN_OR );
+    DeleteObject( tmp );
     data->rdh.nCount = 0;
 }
 
@@ -1651,7 +1639,7 @@ static void update_surface_region( struct x11drv_window_surface *surface )
     data->rdh.nCount = 0;
     data->rdh.nRgnSize = sizeof(buffer) - sizeof(data->rdh);
 
-    rgn = NtGdiCreateRectRgn( 0, 0, 0, 0 );
+    rgn = CreateRectRgn( 0, 0, 0, 0 );
     width = surface->header.rect.right - surface->header.rect.left;
 
     switch (info->bmiHeader.biBitCount)
@@ -1750,10 +1738,10 @@ static void update_surface_region( struct x11drv_window_surface *surface )
     {
         XShapeCombineRectangles( gdi_display, surface->window, ShapeBounding, 0, 0,
                                  (XRectangle *)data->Buffer, data->rdh.nCount, ShapeSet, YXBanded );
-        free( data );
+        HeapFree( GetProcessHeap(), 0, data );
     }
 
-    NtGdiDeleteObjectApp( rgn );
+    DeleteObject( rgn );
 #endif
 }
 
@@ -1829,27 +1817,27 @@ failed:
 /***********************************************************************
  *           x11drv_surface_lock
  */
-static void x11drv_surface_lock( struct window_surface *window_surface )
+static void CDECL x11drv_surface_lock( struct window_surface *window_surface )
 {
     struct x11drv_window_surface *surface = get_x11_surface( window_surface );
 
-    pthread_mutex_lock( &surface->mutex );
+    EnterCriticalSection( &surface->crit );
 }
 
 /***********************************************************************
  *           x11drv_surface_unlock
  */
-static void x11drv_surface_unlock( struct window_surface *window_surface )
+static void CDECL x11drv_surface_unlock( struct window_surface *window_surface )
 {
     struct x11drv_window_surface *surface = get_x11_surface( window_surface );
 
-    pthread_mutex_unlock( &surface->mutex );
+    LeaveCriticalSection( &surface->crit );
 }
 
 /***********************************************************************
  *           x11drv_surface_get_bitmap_info
  */
-static void *x11drv_surface_get_bitmap_info( struct window_surface *window_surface, BITMAPINFO *info )
+static void *CDECL x11drv_surface_get_bitmap_info( struct window_surface *window_surface, BITMAPINFO *info )
 {
     struct x11drv_window_surface *surface = get_x11_surface( window_surface );
 
@@ -1860,7 +1848,7 @@ static void *x11drv_surface_get_bitmap_info( struct window_surface *window_surfa
 /***********************************************************************
  *           x11drv_surface_get_bounds
  */
-static RECT *x11drv_surface_get_bounds( struct window_surface *window_surface )
+static RECT *CDECL x11drv_surface_get_bounds( struct window_surface *window_surface )
 {
     struct x11drv_window_surface *surface = get_x11_surface( window_surface );
 
@@ -1870,7 +1858,7 @@ static RECT *x11drv_surface_get_bounds( struct window_surface *window_surface )
 /***********************************************************************
  *           x11drv_surface_set_region
  */
-static void x11drv_surface_set_region( struct window_surface *window_surface, HRGN region )
+static void CDECL x11drv_surface_set_region( struct window_surface *window_surface, HRGN region )
 {
     RGNDATA *data;
     struct x11drv_window_surface *surface = get_x11_surface( window_surface );
@@ -1880,19 +1868,19 @@ static void x11drv_surface_set_region( struct window_surface *window_surface, HR
     window_surface->funcs->lock( window_surface );
     if (!region)
     {
-        if (surface->region) NtGdiDeleteObjectApp( surface->region );
+        if (surface->region) DeleteObject( surface->region );
         surface->region = 0;
         XSetClipMask( gdi_display, surface->gc, None );
     }
     else
     {
-        if (!surface->region) surface->region = NtGdiCreateRectRgn( 0, 0, 0, 0 );
-        NtGdiCombineRgn( surface->region, region, 0, RGN_COPY );
+        if (!surface->region) surface->region = CreateRectRgn( 0, 0, 0, 0 );
+        CombineRgn( surface->region, region, 0, RGN_COPY );
         if ((data = X11DRV_GetRegionData( surface->region, 0 )))
         {
             XSetClipRectangles( gdi_display, surface->gc, 0, 0,
                                 (XRectangle *)data->Buffer, data->rdh.nCount, YXBanded );
-            free( data );
+            HeapFree( GetProcessHeap(), 0, data );
         }
     }
     window_surface->funcs->unlock( window_surface );
@@ -1901,7 +1889,7 @@ static void x11drv_surface_set_region( struct window_surface *window_surface, HR
 /***********************************************************************
  *           x11drv_surface_flush
  */
-static void x11drv_surface_flush( struct window_surface *window_surface )
+static void CDECL x11drv_surface_flush( struct window_surface *window_surface )
 {
     struct x11drv_window_surface *surface = get_x11_surface( window_surface );
     unsigned char *src = surface->bits;
@@ -1914,7 +1902,7 @@ static void x11drv_surface_flush( struct window_surface *window_surface )
     coords.width  = surface->header.rect.right - surface->header.rect.left;
     coords.height = surface->header.rect.bottom - surface->header.rect.top;
     SetRect( &coords.visrect, 0, 0, coords.width, coords.height );
-    if (intersect_rect( &coords.visrect, &coords.visrect, &surface->bounds ))
+    if (IntersectRect( &coords.visrect, &coords.visrect, &surface->bounds ))
     {
         TRACE( "flushing %p %dx%d bounds %s bits %p\n",
                surface, coords.width, coords.height,
@@ -1968,7 +1956,7 @@ static void x11drv_surface_flush( struct window_surface *window_surface )
 /***********************************************************************
  *           x11drv_surface_destroy
  */
-static void x11drv_surface_destroy( struct window_surface *window_surface )
+static void CDECL x11drv_surface_destroy( struct window_surface *window_surface )
 {
     struct x11drv_window_surface *surface = get_x11_surface( window_surface );
 
@@ -1976,7 +1964,7 @@ static void x11drv_surface_destroy( struct window_surface *window_surface )
     if (surface->gc) XFreeGC( gdi_display, surface->gc );
     if (surface->image)
     {
-        if (surface->image->data != surface->bits) free( surface->bits );
+        if (surface->image->data != surface->bits) HeapFree( GetProcessHeap(), 0, surface->bits );
 #ifdef HAVE_LIBXXSHM
         if (surface->shminfo.shmid != -1)
         {
@@ -1985,12 +1973,14 @@ static void x11drv_surface_destroy( struct window_surface *window_surface )
         }
         else
 #endif
-        free( surface->image->data );
+        HeapFree( GetProcessHeap(), 0, surface->image->data );
         surface->image->data = NULL;
         XDestroyImage( surface->image );
     }
-    if (surface->region) NtGdiDeleteObjectApp( surface->region );
-    free( surface );
+    surface->crit.DebugInfo->Spare[0] = 0;
+    DeleteCriticalSection( &surface->crit );
+    if (surface->region) DeleteObject( surface->region );
+    HeapFree( GetProcessHeap(), 0, surface );
 }
 
 static const struct window_surface_funcs x11drv_surface_funcs =
@@ -2015,7 +2005,8 @@ struct window_surface *create_surface( Window window, const XVisualInfo *vis, co
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
     int colors = format->bits_per_pixel <= 8 ? 1 << format->bits_per_pixel : 3;
 
-    surface = calloc( 1, FIELD_OFFSET( struct x11drv_window_surface, info.bmiColors[colors] ));
+    surface = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY,
+                         FIELD_OFFSET( struct x11drv_window_surface, info.bmiColors[colors] ));
     if (!surface) return NULL;
     surface->info.bmiHeader.biSize        = sizeof(surface->info.bmiHeader);
     surface->info.bmiHeader.biWidth       = width;
@@ -2025,7 +2016,8 @@ struct window_surface *create_surface( Window window, const XVisualInfo *vis, co
     surface->info.bmiHeader.biSizeImage   = get_dib_image_size( &surface->info );
     if (format->bits_per_pixel > 8) set_color_info( vis, &surface->info, use_alpha );
 
-    init_recursive_mutex( &surface->mutex );
+    InitializeCriticalSection( &surface->crit );
+    surface->crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": surface");
 
     surface->header.funcs = &x11drv_surface_funcs;
     surface->header.rect  = *rect;
@@ -2043,7 +2035,7 @@ struct window_surface *create_surface( Window window, const XVisualInfo *vis, co
         surface->image = XCreateImage( gdi_display, vis->visual, vis->depth, ZPixmap, 0, NULL,
                                        width, height, 32, 0 );
         if (!surface->image) goto failed;
-        surface->image->data = malloc( surface->info.bmiHeader.biSizeImage );
+        surface->image->data = HeapAlloc( GetProcessHeap(), 0, surface->info.bmiHeader.biSizeImage );
         if (!surface->image->data) goto failed;
     }
 
@@ -2057,7 +2049,8 @@ struct window_surface *create_surface( Window window, const XVisualInfo *vis, co
     if (surface->byteswap || format->bits_per_pixel == 4 || format->bits_per_pixel == 8)
     {
         /* allocate separate surface bits if byte swapping or palette mapping is required */
-        if (!(surface->bits  = calloc( 1, surface->info.bmiHeader.biSizeImage )))
+        if (!(surface->bits  = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY,
+                                          surface->info.bmiHeader.biSizeImage )))
             goto failed;
     }
     else surface->bits = surface->image->data;
@@ -2106,10 +2099,10 @@ HRGN expose_surface( struct window_surface *window_surface, const RECT *rect )
     add_bounds_rect( &surface->bounds, &rc );
     if (surface->region)
     {
-        region = NtGdiCreateRectRgn( rect->left, rect->top, rect->right, rect->bottom );
-        if (NtGdiCombineRgn( region, region, surface->region, RGN_DIFF ) <= NULLREGION)
+        region = CreateRectRgnIndirect( rect );
+        if (CombineRgn( region, region, surface->region, RGN_DIFF ) <= NULLREGION)
         {
-            NtGdiDeleteObjectApp( region );
+            DeleteObject( region );
             region = 0;
         }
     }
diff --git a/dlls/winex11.drv/brush.c b/dlls/winex11.drv/brush.c
index 2a2e8ef4e98..0630e5725ba 100644
--- a/dlls/winex11.drv/brush.c
+++ b/dlls/winex11.drv/brush.c
@@ -18,10 +18,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <stdlib.h>
@@ -126,7 +122,8 @@ static Pixmap BRUSH_DitherColor( COLORREF color, int depth)
             XUnlockDisplay( gdi_display );
             return 0;
         }
-        ditherImage->data = malloc( ditherImage->height * ditherImage->bytes_per_line );
+        ditherImage->data = HeapAlloc( GetProcessHeap(), 0,
+                                       ditherImage->height * ditherImage->bytes_per_line );
     }
 
     if (color != prevColor)
@@ -249,7 +246,7 @@ HBRUSH CDECL X11DRV_SelectBrush( PHYSDEV dev, HBRUSH hbrush, const struct brush_
         return hbrush;
     }
 
-    if (!NtGdiExtGetObjectW( hbrush, sizeof(logbrush), &logbrush )) return 0;
+    if (!GetObjectA( hbrush, sizeof(logbrush), &logbrush )) return 0;
 
     TRACE("hdc=%p hbrush=%p\n", dev->hdc, hbrush);
 
@@ -260,7 +257,7 @@ HBRUSH CDECL X11DRV_SelectBrush( PHYSDEV dev, HBRUSH hbrush, const struct brush_
     }
     physDev->brush.style = logbrush.lbStyle;
     if (hbrush == GetStockObject( DC_BRUSH ))
-        NtGdiGetDCDword( dev->hdc, NtGdiGetDCBrushColor, &logbrush.lbColor );
+        logbrush.lbColor = GetDCBrushColor( dev->hdc );
 
     switch(logbrush.lbStyle)
     {
@@ -292,7 +289,7 @@ COLORREF CDECL X11DRV_SetDCBrushColor( PHYSDEV dev, COLORREF crColor )
 {
     X11DRV_PDEVICE *physDev = get_x11drv_dev( dev );
 
-    if (NtGdiGetDCObject( dev->hdc, NTGDI_OBJ_BRUSH ) == GetStockObject( DC_BRUSH ))
+    if (GetCurrentObject(dev->hdc, OBJ_BRUSH) == GetStockObject( DC_BRUSH ))
         BRUSH_SelectSolidBrush( physDev, crColor );
 
     return crColor;
diff --git a/dlls/winex11.drv/clipboard.c b/dlls/winex11.drv/clipboard.c
index da451fad57c..a13d0a55b76 100644
--- a/dlls/winex11.drv/clipboard.c
+++ b/dlls/winex11.drv/clipboard.c
@@ -63,10 +63,6 @@
  * FIXME: global format list needs a critical section
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <string.h>
@@ -80,8 +76,6 @@
 #include <time.h>
 #include <assert.h>
 
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
 #include "x11drv.h"
 
 #ifdef HAVE_X11_EXTENSIONS_XFIXES_H
@@ -93,6 +87,7 @@
 #include "shlwapi.h"
 #include "wine/list.h"
 #include "wine/debug.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
@@ -102,8 +97,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(clipboard);
 
 #define SELECTION_UPDATE_DELAY 2000   /* delay between checks of the X11 selection */
 
-typedef BOOL (*EXPORTFUNC)( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-typedef void *(*IMPORTFUNC)( Atom type, const void *data, size_t size, size_t *ret_size );
+typedef BOOL (*EXPORTFUNC)( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+typedef HANDLE (*IMPORTFUNC)( Atom type, const void *data, size_t size );
 
 struct clipboard_format
 {
@@ -114,32 +109,34 @@ struct clipboard_format
     EXPORTFUNC  export;
 };
 
-static void *import_data( Atom type, const void *data, size_t size, size_t *ret_size );
-static void *import_pixmap( Atom type, const void *data, size_t size, size_t *ret_size );
-static void *import_image_bmp( Atom type, const void *data, size_t size, size_t *ret_size );
-static void *import_string( Atom type, const void *data, size_t size, size_t *ret_size );
-static void *import_utf8_string( Atom type, const void *data, size_t size, size_t *ret_size );
-static void *import_compound_text( Atom type, const void *data, size_t size, size_t *ret_size );
-static void *import_text( Atom type, const void *data, size_t size, size_t *ret_size );
-static void *import_text_html( Atom type, const void *data, size_t size, size_t *ret_size );
-static void *import_text_uri_list( Atom type, const void *data, size_t size, size_t *ret_size );
-static void *import_targets( Atom type, const void *data, size_t size, size_t *ret_size );
-
-static BOOL export_data( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_string( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_utf8_string( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_text( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_compound_text( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_pixmap( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_image_bmp( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_text_html( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_hdrop( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_targets( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_multiple( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
-static BOOL export_timestamp( Display *display, Window win, Atom prop, Atom target, void *data, size_t size );
+static HANDLE import_data( Atom type, const void *data, size_t size );
+static HANDLE import_enhmetafile( Atom type, const void *data, size_t size );
+static HANDLE import_pixmap( Atom type, const void *data, size_t size );
+static HANDLE import_image_bmp( Atom type, const void *data, size_t size );
+static HANDLE import_string( Atom type, const void *data, size_t size );
+static HANDLE import_utf8_string( Atom type, const void *data, size_t size );
+static HANDLE import_compound_text( Atom type, const void *data, size_t size );
+static HANDLE import_text( Atom type, const void *data, size_t size );
+static HANDLE import_text_html( Atom type, const void *data, size_t size );
+static HANDLE import_text_uri_list( Atom type, const void *data, size_t size );
+static HANDLE import_targets( Atom type, const void *data, size_t size );
+
+static BOOL export_data( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_string( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_utf8_string( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_text( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_compound_text( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_pixmap( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_image_bmp( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_enhmetafile( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_text_html( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_hdrop( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_targets( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_multiple( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
+static BOOL export_timestamp( Display *display, Window win, Atom prop, Atom target, HANDLE handle );
 
 static BOOL read_property( Display *display, Window w, Atom prop,
-                           Atom *type, unsigned char **data, size_t *datasize );
+                           Atom *type, unsigned char **data, unsigned long *datasize );
 
 /* Clipboard formats */
 
@@ -170,7 +167,7 @@ static const struct
     { 0, CF_PENDATA,         XATOM_WCF_PENDATA,         import_data,          export_data },
     { 0, CF_RIFF,            XATOM_WCF_RIFF,            import_data,          export_data },
     { 0, CF_WAVE,            XATOM_WCF_WAVE,            import_data,          export_data },
-    { 0, CF_ENHMETAFILE,     XATOM_WCF_ENHMETAFILE,     import_data,          export_data },
+    { 0, CF_ENHMETAFILE,     XATOM_WCF_ENHMETAFILE,     import_enhmetafile,   export_enhmetafile },
     { 0, CF_HDROP,           XATOM_text_uri_list,       import_text_uri_list, export_hdrop },
     { 0, CF_DIB,             XATOM_image_bmp,           import_image_bmp,     export_image_bmp },
     { RichTextFormatW, 0,    XATOM_text_rtf,            import_data,          export_data },
@@ -196,7 +193,7 @@ static Window selection_window;
 static Window import_window;
 static Atom current_selection;
 static UINT rendered_formats;
-static ULONG last_clipboard_update;
+static ULONG64 last_clipboard_update;
 static struct clipboard_format **current_x11_formats;
 static unsigned int nb_current_x11_formats;
 static BOOL use_xfixes;
@@ -207,7 +204,7 @@ static const char *debugstr_format( UINT id )
 {
     WCHAR buffer[256];
 
-    if (NtUserGetClipboardFormatName( id, buffer, ARRAYSIZE(buffer) ))
+    if (GetClipboardFormatNameW( id, buffer, 256 ))
         return wine_dbg_sprintf( "%04x %s", id, debugstr_w(buffer) );
 
     switch (id)
@@ -286,14 +283,6 @@ static struct clipboard_format *find_x11_format( Atom atom )
 }
 
 
-static ATOM register_clipboard_format( const WCHAR *name )
-{
-    ATOM atom;
-    if (NtAddAtom( name, lstrlenW( name ) * sizeof(WCHAR), &atom )) return 0;
-    return atom;
-}
-
-
 /**************************************************************************
  *		register_builtin_formats
  */
@@ -302,12 +291,12 @@ static void register_builtin_formats(void)
     struct clipboard_format *formats;
     unsigned int i;
 
-    if (!(formats = malloc( ARRAY_SIZE(builtin_formats) * sizeof(*formats)))) return;
+    if (!(formats = HeapAlloc( GetProcessHeap(), 0, ARRAY_SIZE(builtin_formats) * sizeof(*formats)))) return;
 
     for (i = 0; i < ARRAY_SIZE(builtin_formats); i++)
     {
         if (builtin_formats[i].name)
-            formats[i].id = register_clipboard_format( builtin_formats[i].name );
+            formats[i].id = RegisterClipboardFormatW( builtin_formats[i].name );
         else
             formats[i].id = builtin_formats[i].id;
 
@@ -327,7 +316,7 @@ static void register_formats( const UINT *ids, const Atom *atoms, unsigned int c
     struct clipboard_format *formats;
     unsigned int i;
 
-    if (!(formats = malloc( count * sizeof(*formats)))) return;
+    if (!(formats = HeapAlloc( GetProcessHeap(), 0, count * sizeof(*formats)))) return;
 
     for (i = 0; i < count; i++)
     {
@@ -361,18 +350,17 @@ static void register_win32_formats( const UINT *ids, UINT size )
         for (count = 0; count < 256 && size; ids++, size--)
         {
             if (find_win32_format( *ids )) continue;  /* it already exists */
-            if (!NtUserGetClipboardFormatName( *ids, buffer, ARRAYSIZE(buffer) ))
-                continue;  /* not a named format */
-            len = lstrlenW( buffer );
-            if (!(names[count] = malloc( len * 3 + 1 ))) continue;
-            ntdll_wcstoumbs( buffer, len + 1, names[count], len * 3 + 1, FALSE );
+            if (!GetClipboardFormatNameW( *ids, buffer, 256 )) continue;  /* not a named format */
+            if (!(len = WideCharToMultiByte( CP_UNIXCP, 0, buffer, -1, NULL, 0, NULL, NULL ))) continue;
+            if (!(names[count] = HeapAlloc( GetProcessHeap(), 0, len ))) continue;
+            WideCharToMultiByte( CP_UNIXCP, 0, buffer, -1, names[count], len, NULL, NULL );
             new_ids[count++] = *ids;
         }
         if (!count) return;
 
         XInternAtoms( thread_display(), names, count, False, atoms );
         register_formats( new_ids, atoms, count );
-        while (count) free( names[--count] );
+        while (count) HeapFree( GetProcessHeap(), 0, names[--count] );
     }
 }
 
@@ -410,8 +398,8 @@ static void register_x11_formats( const Atom *atoms, UINT size )
 
         for (i = pos = 0; i < count; i++)
         {
-            if (ntdll_umbstowcs( names[i], strlen( names[i] ) + 1, buffer, ARRAYSIZE(buffer) ) &&
-                (ids[pos] = register_clipboard_format( buffer )))
+            if (MultiByteToWideChar( CP_UNIXCP, 0, names[i], -1, buffer, 256 ) &&
+                (ids[pos] = RegisterClipboardFormatW( buffer )))
                 new_atoms[pos++] = new_atoms[i];
             XFree( names[i] );
         }
@@ -447,19 +435,12 @@ static void put_property( Display *display, Window win, Atom prop, Atom type, in
 }
 
 
-static void selection_sleep(void)
-{
-    LARGE_INTEGER timeout;
-    timeout.QuadPart = (ULONGLONG)SELECTION_WAIT * -10000;
-    NtDelayExecution( FALSE, &timeout );
-}
-
 /**************************************************************************
  *		convert_selection
  */
 static BOOL convert_selection( Display *display, Window win, Atom selection,
                                struct clipboard_format *format, Atom *type,
-                               unsigned char **data, size_t *size )
+                               unsigned char **data, unsigned long *size )
 {
     int i;
     XEvent event;
@@ -475,7 +456,7 @@ static BOOL convert_selection( Display *display, Window win, Atom selection,
         Bool res = XCheckTypedWindowEvent( display, win, SelectionNotify, &event );
         if (res && event.xselection.selection == selection && event.xselection.target == format->atom)
             return read_property( display, win, event.xselection.property, type, data, size );
-        selection_sleep();
+        Sleep( SELECTION_WAIT );
     }
     ERR( "Timed out waiting for SelectionNotify event\n" );
     return FALSE;
@@ -515,16 +496,17 @@ static int bitmap_info_size( const BITMAPINFO * info, WORD coloruse )
  *
  *  Allocates a packed DIB and copies the bitmap data into it.
  */
-static void *create_dib_from_bitmap( HBITMAP hBmp, size_t *size )
+static HGLOBAL create_dib_from_bitmap(HBITMAP hBmp)
 {
     BITMAP bmp;
     HDC hdc;
+    HGLOBAL hPackedDIB;
+    LPBYTE pPackedDIB;
     LPBITMAPINFOHEADER pbmiHeader;
-    unsigned int cDataSize, OffsetBits;
+    unsigned int cDataSize, cPackedSize, OffsetBits;
     int nLinesCopied;
-    char *ret;
 
-    if (!NtGdiExtGetObjectW( hBmp, sizeof(bmp), &bmp )) return 0;
+    if (!GetObjectW( hBmp, sizeof(bmp), &bmp )) return 0;
 
     /*
      * A packed DIB contains a BITMAPINFO structure followed immediately by
@@ -533,22 +515,24 @@ static void *create_dib_from_bitmap( HBITMAP hBmp, size_t *size )
 
     /* Calculate the size of the packed DIB */
     cDataSize = abs( bmp.bmHeight ) * (((bmp.bmWidth * bmp.bmBitsPixel + 31) / 8) & ~3);
-    *size = sizeof(BITMAPINFOHEADER)
+    cPackedSize = sizeof(BITMAPINFOHEADER)
                   + ( (bmp.bmBitsPixel <= 8) ? (sizeof(RGBQUAD) * (1 << bmp.bmBitsPixel)) : 0 )
                   + cDataSize;
     /* Get the offset to the bits */
-    OffsetBits = *size - cDataSize;
+    OffsetBits = cPackedSize - cDataSize;
 
     /* Allocate the packed DIB */
-    TRACE( "\tAllocating packed DIB\n" );
-    if (!(ret = malloc( *size )))
+    TRACE("\tAllocating packed DIB of size %d\n", cPackedSize);
+    hPackedDIB = GlobalAlloc( GMEM_FIXED, cPackedSize );
+    if ( !hPackedDIB )
     {
-        WARN( "Could not allocate packed DIB!\n" );
+        WARN("Could not allocate packed DIB!\n");
         return 0;
     }
 
     /* A packed DIB starts with a BITMAPINFOHEADER */
-    pbmiHeader = (LPBITMAPINFOHEADER)ret;
+    pPackedDIB = GlobalLock(hPackedDIB);
+    pbmiHeader = (LPBITMAPINFOHEADER)pPackedDIB;
 
     /* Init the BITMAPINFOHEADER */
     pbmiHeader->biSize = sizeof(BITMAPINFOHEADER);
@@ -564,143 +548,25 @@ static void *create_dib_from_bitmap( HBITMAP hBmp, size_t *size )
 
     /* Retrieve the DIB bits from the bitmap and fill in the
      * DIB color table if present */
-    hdc = NtUserGetDCEx( 0, 0, DCX_CACHE | DCX_WINDOW );
-    nLinesCopied = NtGdiGetDIBitsInternal( hdc, hBmp, 0, bmp.bmHeight,  ret + OffsetBits,
-                                           (LPBITMAPINFO) pbmiHeader, 0, 0, 0 );
-    NtUserReleaseDC( 0, hdc );
+    hdc = GetDC( 0 );
+    nLinesCopied = GetDIBits(hdc,                       /* Handle to device context */
+                             hBmp,                      /* Handle to bitmap */
+                             0,                         /* First scan line to set in dest bitmap */
+                             bmp.bmHeight,              /* Number of scan lines to copy */
+                             pPackedDIB + OffsetBits,   /* [out] Address of array for bitmap bits */
+                             (LPBITMAPINFO) pbmiHeader, /* [out] Address of BITMAPINFO structure */
+                             0);                        /* RGB or palette index */
+    GlobalUnlock(hPackedDIB);
+    ReleaseDC( 0, hdc );
 
     /* Cleanup if GetDIBits failed */
     if (nLinesCopied != bmp.bmHeight)
     {
         TRACE("\tGetDIBits returned %d. Actual lines=%d\n", nLinesCopied, bmp.bmHeight);
-        free( ret );
-        ret = NULL;
-    }
-    return ret;
-}
-
-
-/* based on wine_get_dos_file_name */
-static WCHAR *get_dos_file_name( const char *path )
-{
-    ULONG len = strlen( path ) + 9; /* \??\unix prefix */
-    WCHAR *ret;
-
-    if (!(ret = malloc( len * sizeof(WCHAR) ))) return NULL;
-    if (wine_unix_to_nt_file_name( path, ret, &len ))
-    {
-        free( ret );
-        return NULL;
-    }
-
-    if (ret[5] == ':')
-    {
-        /* get rid of the \??\ prefix */
-        memmove( ret, ret + 4, (len - 4) * sizeof(WCHAR) );
-    }
-    else ret[1] = '\\';
-    return ret;
-}
-
-
-/***********************************************************************
- *           get_nt_pathname
- *
- * Simplified version of RtlDosPathNameToNtPathName_U.
- */
-static BOOL get_nt_pathname( const WCHAR *name, UNICODE_STRING *nt_name )
-{
-    static const WCHAR ntprefixW[] = {'\\','?','?','\\'};
-    static const WCHAR uncprefixW[] = {'U','N','C','\\'};
-    size_t len = lstrlenW( name );
-    WCHAR *ptr;
-
-    nt_name->MaximumLength = (len + 8) * sizeof(WCHAR);
-    if (!(ptr = malloc( nt_name->MaximumLength ))) return FALSE;
-    nt_name->Buffer = ptr;
-
-    memcpy( ptr, ntprefixW, sizeof(ntprefixW) );
-    ptr += ARRAYSIZE(ntprefixW);
-    if (name[0] == '\\' && name[1] == '\\')
-    {
-        if ((name[2] == '.' || name[2] == '?') && name[3] == '\\')
-        {
-            name += 4;
-            len -= 4;
-        }
-        else
-        {
-            memcpy( ptr, uncprefixW, sizeof(uncprefixW) );
-            ptr += ARRAYSIZE(uncprefixW);
-            name += 2;
-            len -= 2;
-        }
+        GlobalFree(hPackedDIB);
+        hPackedDIB = 0;
     }
-    memcpy( ptr, name, (len + 1) * sizeof(WCHAR) );
-    ptr += len;
-    nt_name->Length = (ptr - nt_name->Buffer) * sizeof(WCHAR);
-    return TRUE;
-}
-
-
-/* based on wine_get_unix_file_name */
-char *get_unix_file_name( const WCHAR *dosW )
-{
-    UNICODE_STRING nt_name;
-    OBJECT_ATTRIBUTES attr;
-    NTSTATUS status;
-    ULONG size = 256;
-    char *buffer;
-
-    if (!get_nt_pathname( dosW, &nt_name )) return NULL;
-    InitializeObjectAttributes( &attr, &nt_name, 0, 0, NULL );
-    for (;;)
-    {
-        if (!(buffer = malloc( size )))
-        {
-            free( nt_name.Buffer );
-            return NULL;
-        }
-        status = wine_nt_to_unix_file_name( &attr, buffer, &size, FILE_OPEN_IF );
-        if (status != STATUS_BUFFER_TOO_SMALL) break;
-        free( buffer );
-    }
-    free( nt_name.Buffer );
-    if (status)
-    {
-        free( buffer );
-        return NULL;
-    }
-    return buffer;
-}
-
-
-static CPTABLEINFO *get_xstring_cp(void)
-{
-    static CPTABLEINFO cp;
-    if (!cp.CodePage)
-    {
-        USHORT *ptr;
-        SIZE_T nls_size;
-        if (NtGetNlsSectionPtr( 11, 28591, NULL, (void **)&ptr, &nls_size )) return NULL;
-        RtlInitCodePageTable( ptr, &cp );
-    }
-    return &cp;
-}
-
-
-static CPTABLEINFO *get_ansi_cp(void)
-{
-    USHORT utf8_hdr[2] = { 0, CP_UTF8 };
-    static CPTABLEINFO cp;
-    if (!cp.CodePage)
-    {
-        if (NtCurrentTeb()->Peb->AnsiCodePageData)
-            RtlInitCodePageTable( NtCurrentTeb()->Peb->AnsiCodePageData, &cp );
-        else
-            RtlInitCodePageTable( utf8_hdr, &cp );
-    }
-    return &cp;
+    return hPackedDIB;
 }
 
 
@@ -714,7 +580,7 @@ static WCHAR* uri_to_dos(char *encodedURI)
     WCHAR *ret = NULL;
     int i;
     int j = 0;
-    char *uri = calloc( 1, strlen(encodedURI) + 1 );
+    char *uri = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, strlen(encodedURI) + 1);
     if (uri == NULL)
         return NULL;
     for (i = 0; encodedURI[i]; ++i)
@@ -735,7 +601,7 @@ static WCHAR* uri_to_dos(char *encodedURI)
             else
             {
                 WARN("invalid URI encoding in %s\n", debugstr_a(encodedURI));
-                free( uri );
+                HeapFree(GetProcessHeap(), 0, uri);
                 return NULL;
             }
         }
@@ -751,7 +617,7 @@ static WCHAR* uri_to_dos(char *encodedURI)
             if (uri[7] == '/')
             {
                 /* file:///path/to/file (nautilus, thunar) */
-                ret = get_dos_file_name( &uri[7] );
+                ret = wine_get_dos_file_name(&uri[7]);
             }
             else if (uri[7])
             {
@@ -764,14 +630,14 @@ static WCHAR* uri_to_dos(char *encodedURI)
                     if (strcmp(&uri[7], "localhost") == 0)
                     {
                         *path = '/';
-                        ret = get_dos_file_name( path );
+                        ret = wine_get_dos_file_name(path);
                     }
                     else if (gethostname(hostname, sizeof(hostname)) == 0)
                     {
                         if (strcmp(hostname, &uri[7]) == 0)
                         {
                             *path = '/';
-                            ret = get_dos_file_name( path );
+                            ret = wine_get_dos_file_name(path);
                         }
                     }
                 }
@@ -780,10 +646,10 @@ static WCHAR* uri_to_dos(char *encodedURI)
         else if (uri[6])
         {
             /* file:/path/to/file (konqueror) */
-            ret = get_dos_file_name( &uri[5] );
+            ret = wine_get_dos_file_name(&uri[5]);
         }
     }
-    free( uri );
+    HeapFree(GetProcessHeap(), 0, uri);
     return ret;
 }
 
@@ -793,19 +659,25 @@ static WCHAR* uri_to_dos(char *encodedURI)
  *
  * Convert a string in the specified encoding to CF_UNICODETEXT format.
  */
-static void *unicode_text_from_string( WCHAR *ret, const WCHAR *string, DWORD count, size_t *size )
+static HANDLE unicode_text_from_string( UINT codepage, const void *data, size_t size )
 {
-    DWORD i, j;
+    DWORD i, j, count;
+    WCHAR *strW;
+
+    count = MultiByteToWideChar( codepage, 0, data, size, NULL, 0);
 
+    if (!(strW = GlobalAlloc( GMEM_FIXED, (count * 2 + 1) * sizeof(WCHAR) ))) return 0;
+
+    MultiByteToWideChar( codepage, 0, data, size, strW + count, count );
     for (i = j = 0; i < count; i++)
     {
-        if (string[i] == '\n' && (!i || string[i - 1] != '\r')) ret[j++] = '\r';
-        ret[j++] = string[i];
+        if (strW[i + count] == '\n' && (!i || strW[i + count - 1] != '\r')) strW[j++] = '\r';
+        strW[j++] = strW[i + count];
     }
-    ret[j++] = 0;
-    *size = j * sizeof(WCHAR);
-    TRACE( "returning %s\n", debugstr_wn( ret, j - 1 ));
-    return ret;
+    strW[j++] = 0;
+    GlobalReAlloc( strW, j * sizeof(WCHAR), GMEM_FIXED );  /* release unused space */
+    TRACE( "returning %s\n", debugstr_wn( strW, j - 1 ));
+    return strW;
 }
 
 
@@ -814,14 +686,9 @@ static void *unicode_text_from_string( WCHAR *ret, const WCHAR *string, DWORD co
  *
  * Import XA_STRING, converting the string to CF_UNICODETEXT.
  */
-static void *import_string( Atom type, const void *data, size_t size, size_t *ret_size )
+static HANDLE import_string( Atom type, const void *data, size_t size )
 {
-    DWORD str_size;
-    WCHAR *ret;
-
-    if (!(ret = malloc( (size * 2 + 1) * sizeof(WCHAR) ))) return NULL;
-    RtlCustomCPToUnicodeN( get_xstring_cp(), ret + size, size * sizeof(WCHAR), &str_size, data, size );
-    return unicode_text_from_string( ret, ret + size, str_size / sizeof(WCHAR), ret_size );
+    return unicode_text_from_string( 28591, data, size );
 }
 
 
@@ -830,16 +697,9 @@ static void *import_string( Atom type, const void *data, size_t size, size_t *re
  *
  * Import XA_UTF8_STRING, converting the string to CF_UNICODETEXT.
  */
-static void *import_utf8_string( Atom type, const void *data, size_t size, size_t *ret_size )
+static HANDLE import_utf8_string( Atom type, const void *data, size_t size )
 {
-    DWORD str_size;
-    WCHAR *ret;
-
-    RtlUTF8ToUnicodeN( NULL, 0, &str_size, data, size );
-    if (!(ret = malloc( str_size * 2 + sizeof(WCHAR) ))) return NULL;
-    RtlUTF8ToUnicodeN( ret + str_size / sizeof(WCHAR), str_size, &str_size, data, size );
-    return unicode_text_from_string( ret, ret + str_size / sizeof(WCHAR),
-                                     str_size / sizeof(WCHAR), ret_size );
+    return unicode_text_from_string( CP_UTF8, data, size );
 }
 
 
@@ -848,13 +708,12 @@ static void *import_utf8_string( Atom type, const void *data, size_t size, size_
  *
  * Import COMPOUND_TEXT to CF_UNICODETEXT.
  */
-static void *import_compound_text( Atom type, const void *data, size_t size, size_t *ret_size )
+static HANDLE import_compound_text( Atom type, const void *data, size_t size )
 {
     char** srcstr;
     int count;
+    HANDLE ret;
     XTextProperty txtprop;
-    DWORD len;
-    WCHAR *ret;
 
     txtprop.value = (BYTE *)data;
     txtprop.nitems = size;
@@ -863,12 +722,7 @@ static void *import_compound_text( Atom type, const void *data, size_t size, siz
     if (XmbTextPropertyToTextList( thread_display(), &txtprop, &srcstr, &count ) != Success) return 0;
     if (!count) return 0;
 
-    len = strlen(srcstr[0]) + 1;
-    if (!(ret = malloc( (len * 2 + 1) * sizeof(WCHAR) ))) return NULL;
-
-    count = ntdll_umbstowcs( srcstr[0], len, ret + len, len );
-    ret = unicode_text_from_string( ret, ret + len, count, ret_size );
-
+    ret = unicode_text_from_string( CP_UNIXCP, srcstr[0], strlen(srcstr[0]) + 1 );
     XFreeStringList(srcstr);
     return ret;
 }
@@ -879,11 +733,11 @@ static void *import_compound_text( Atom type, const void *data, size_t size, siz
  *
  * Import XA_TEXT, converting the string to CF_UNICODETEXT.
  */
-static void *import_text( Atom type, const void *data, size_t size, size_t *ret_size )
+static HANDLE import_text( Atom type, const void *data, size_t size )
 {
-    if (type == XA_STRING) return import_string( type, data, size, ret_size );
-    if (type == x11drv_atom(UTF8_STRING)) return import_utf8_string( type, data, size, ret_size );
-    if (type == x11drv_atom(COMPOUND_TEXT)) return import_compound_text( type, data, size, ret_size );
+    if (type == XA_STRING) return import_string( type, data, size );
+    if (type == x11drv_atom(UTF8_STRING)) return import_utf8_string( type, data, size );
+    if (type == x11drv_atom(COMPOUND_TEXT)) return import_compound_text( type, data, size );
     FIXME( "unsupported TEXT type %s\n", debugstr_xatom( type ));
     return 0;
 }
@@ -894,7 +748,7 @@ static void *import_text( Atom type, const void *data, size_t size, size_t *ret_
  *
  *  Import XA_PIXMAP, converting the image to CF_DIB.
  */
-static void *import_pixmap( Atom type, const void *data, size_t size, size_t *ret_size )
+static HANDLE import_pixmap( Atom type, const void *data, size_t size )
 {
     const Pixmap *pPixmap = (const Pixmap *)data;
     BYTE *ptr = NULL;
@@ -939,12 +793,11 @@ static void *import_pixmap( Atom type, const void *data, size_t size, size_t *re
     {
         DWORD info_size = bitmap_info_size( info, DIB_RGB_COLORS );
 
-        ptr = malloc( info_size + info->bmiHeader.biSizeImage );
+        ptr = GlobalAlloc( GMEM_FIXED, info_size + info->bmiHeader.biSizeImage );
         if (ptr)
         {
             memcpy( ptr, info, info_size );
             memcpy( ptr + info_size, bits.ptr, info->bmiHeader.biSizeImage );
-            *ret_size = info_size + info->bmiHeader.biSizeImage;
         }
         if (bits.free) bits.free( &bits );
     }
@@ -957,54 +810,43 @@ static void *import_pixmap( Atom type, const void *data, size_t size, size_t *re
  *
  *  Import image/bmp, converting the image to CF_DIB.
  */
-static void *import_image_bmp( Atom type, const void *data, size_t size, size_t *ret_size )
+static HANDLE import_image_bmp( Atom type, const void *data, size_t size )
 {
+    HANDLE hClipData = 0;
     const BITMAPFILEHEADER *bfh = data;
-    void *ret = NULL;
 
     if (size >= sizeof(BITMAPFILEHEADER)+sizeof(BITMAPCOREHEADER) &&
         bfh->bfType == 0x4d42 /* "BM" */)
     {
         const BITMAPINFO *bmi = (const BITMAPINFO *)(bfh + 1);
-        int width, height;
         HBITMAP hbmp;
-        HDC hdc;
+        HDC hdc = GetDC(0);
 
-        if (bmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER))
-        {
-            const BITMAPCOREHEADER *core = (const BITMAPCOREHEADER *)bmi;
-            width  = core->bcWidth;
-            height = core->bcHeight;
-        }
-        else if (bmi->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER))
+        if ((hbmp = CreateDIBitmap( hdc, &bmi->bmiHeader, CBM_INIT,
+                                    (const BYTE *)data + bfh->bfOffBits, bmi, DIB_RGB_COLORS )))
         {
-            const BITMAPINFOHEADER *header = &bmi->bmiHeader;
-            if (header->biCompression == BI_JPEG || header->biCompression == BI_PNG) return 0;
-            width  = header->biWidth;
-            height = header->biHeight;
+            hClipData = create_dib_from_bitmap( hbmp );
+            DeleteObject(hbmp);
         }
-        else return NULL;
-        if (!width || !height) return NULL;
+        ReleaseDC(0, hdc);
+    }
+    return hClipData;
+}
 
-        hdc = NtUserGetDCEx( 0, 0, DCX_CACHE | DCX_WINDOW );
 
-        if ((hbmp = NtGdiCreateDIBitmapInternal( hdc, width, height, CBM_INIT,
-                                                 (const BYTE *)data + bfh->bfOffBits, bmi,
-                                                 DIB_RGB_COLORS, 0, 0, 0, 0 )))
-        {
-            ret = create_dib_from_bitmap( hbmp, ret_size );
-            NtGdiDeleteObjectApp( hbmp );
-        }
-        NtUserReleaseDC(0, hdc);
-    }
-    return ret;
+/**************************************************************************
+ *		import_enhmetafile
+ */
+static HANDLE import_enhmetafile( Atom type, const void *data, size_t size )
+{
+    return SetEnhMetaFileBits( size, data );
 }
 
 
 /**************************************************************************
  *              import_text_html
  */
-static void *import_text_html( Atom type, const void *data, size_t size, size_t *ret_size )
+static HANDLE import_text_html( Atom type, const void *data, size_t size )
 {
     static const char header[] =
         "Version:0.9\n"
@@ -1021,86 +863,36 @@ static void *import_text_html( Atom type, const void *data, size_t size, size_t
     /* Firefox uses UTF-16LE with byte order mark. Convert to UTF-8 without the BOM. */
     if (size >= sizeof(WCHAR) && ((const WCHAR *)data)[0] == 0xfeff)
     {
-        DWORD str_len;
-        RtlUnicodeToUTF8N( NULL, 0, &str_len, (const WCHAR *)data + 1, size - sizeof(WCHAR) );
-        if (!(text = malloc( str_len ))) return NULL;
-        RtlUnicodeToUTF8N( text, str_len, &str_len, (const WCHAR *)data + 1, size - sizeof(WCHAR) );
-        size = str_len;
+        len = WideCharToMultiByte( CP_UTF8, 0, (const WCHAR *)data + 1, size / sizeof(WCHAR) - 1,
+                                   NULL, 0, NULL, NULL );
+        if (!(text = HeapAlloc( GetProcessHeap(), 0, len ))) return 0;
+        WideCharToMultiByte( CP_UTF8, 0, (const WCHAR *)data + 1, size / sizeof(WCHAR) - 1,
+                             text, len, NULL, NULL );
+        size = len;
         data = text;
     }
 
     len = strlen( header ) + 12;  /* 3 * 4 extra chars for %010lu */
     total = len + size + sizeof(trailer);
-    if ((ret = malloc( total )))
+    if ((ret = GlobalAlloc( GMEM_FIXED, total )))
     {
         char *p = ret;
         p += sprintf( p, header, total - 1, len, len + size + 1 /* include the final \n in the data */ );
         memcpy( p, data, size );
         strcpy( p + size, trailer );
-        *ret_size = total;
         TRACE( "returning %s\n", debugstr_a( ret ));
     }
-    free( text );
+    HeapFree( GetProcessHeap(), 0, text );
     return ret;
 }
 
 
 /**************************************************************************
- *      file_list_to_drop_files
- */
-void *file_list_to_drop_files( const void *data, size_t size, size_t *ret_size )
-{
-    size_t buf_size = 4096, path_size;
-    DROPFILES *drop = NULL;
-    const char *ptr;
-    WCHAR *path;
-
-    for (ptr = data; ptr < (const char *)data + size; ptr += strlen( ptr ) + 1)
-    {
-        path = get_dos_file_name( ptr );
-
-        TRACE( "converted URI %s to DOS path %s\n", debugstr_a(ptr), debugstr_w(path) );
-
-        if (!path) continue;
-
-        if (!drop)
-        {
-            if (!(drop = malloc( buf_size ))) return NULL;
-            drop->pFiles = sizeof(*drop);
-            drop->pt.x = drop->pt.y = 0;
-            drop->fNC = FALSE;
-            drop->fWide = TRUE;
-            *ret_size = sizeof(*drop);
-        }
-
-        path_size = (lstrlenW( path ) + 1) * sizeof(WCHAR);
-        if (*ret_size + path_size > buf_size - sizeof(WCHAR))
-        {
-            void *new_buf;
-            if (!(new_buf = realloc( drop, buf_size * 2 + path_size )))
-            {
-                free( path );
-                continue;
-            }
-            buf_size = buf_size * 2 + path_size;
-            drop = new_buf;
-        }
-
-        memcpy( (char *)drop + *ret_size, path, path_size );
-        *ret_size += path_size;
-    }
-
-    if (!drop) return NULL;
-    *(WCHAR *)((char *)drop + *ret_size) = 0;
-    *ret_size += sizeof(WCHAR);
-    return drop;
-}
-
-
-/**************************************************************************
- *      uri_list_to_drop_files
+ *      import_text_uri_list
+ *
+ *  Import text/uri-list.
  */
-void *uri_list_to_drop_files( const void *data, size_t size, size_t *ret_size )
+static HANDLE import_text_uri_list( Atom type, const void *data, size_t size )
 {
     const char *uriList = data;
     char *uri;
@@ -1112,7 +904,7 @@ void *uri_list_to_drop_files( const void *data, size_t size, size_t *ret_size )
     int end = 0;
     DROPFILES *dropFiles = NULL;
 
-    if (!(out = malloc( capacity * sizeof(WCHAR) ))) return 0;
+    if (!(out = HeapAlloc(GetProcessHeap(), 0, capacity * sizeof(WCHAR)))) return 0;
 
     while (end < size)
     {
@@ -1124,30 +916,28 @@ void *uri_list_to_drop_files( const void *data, size_t size, size_t *ret_size )
             break;
         }
 
-        uri = malloc( end - start + 1 );
+        uri = HeapAlloc(GetProcessHeap(), 0, end - start + 1);
         if (uri == NULL)
             break;
         lstrcpynA(uri, &uriList[start], end - start + 1);
         path = uri_to_dos(uri);
         TRACE("converted URI %s to DOS path %s\n", debugstr_a(uri), debugstr_w(path));
-        free( uri );
+        HeapFree(GetProcessHeap(), 0, uri);
 
         if (path)
         {
-            int pathSize = wcslen( path ) + 1;
+            int pathSize = strlenW(path) + 1;
             if (pathSize > capacity - total)
             {
-                WCHAR *new_out;
                 capacity = 2*capacity + pathSize;
-                new_out = realloc( out, (capacity + 1) * sizeof(WCHAR) );
-                if (!new_out)
+                out = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, out, (capacity + 1)*sizeof(WCHAR));
+                if (out == NULL)
                     goto done;
-                out = new_out;
             }
             memcpy(&out[total], path, pathSize * sizeof(WCHAR));
             total += pathSize;
         done:
-            free( path );
+            HeapFree(GetProcessHeap(), 0, path);
             if (out == NULL)
                 break;
         }
@@ -1157,8 +947,7 @@ void *uri_list_to_drop_files( const void *data, size_t size, size_t *ret_size )
     }
     if (out && end >= size)
     {
-        *ret_size = sizeof(DROPFILES) + (total + 1) * sizeof(WCHAR);
-        if ((dropFiles = malloc( *ret_size )))
+        if ((dropFiles = GlobalAlloc( GMEM_FIXED, sizeof(DROPFILES) + (total + 1) * sizeof(WCHAR) )))
         {
             dropFiles->pFiles = sizeof(DROPFILES);
             dropFiles->pt.x = 0;
@@ -1169,28 +958,17 @@ void *uri_list_to_drop_files( const void *data, size_t size, size_t *ret_size )
             memcpy( (char*)dropFiles + dropFiles->pFiles, out, (total + 1) * sizeof(WCHAR) );
         }
     }
-    free( out );
+    HeapFree(GetProcessHeap(), 0, out);
     return dropFiles;
 }
 
 
-/**************************************************************************
- *      import_text_uri_list
- *
- *  Import text/uri-list.
- */
-static void *import_text_uri_list( Atom type, const void *data, size_t size, size_t *ret_size )
-{
-    return uri_list_to_drop_files( data, size, ret_size );
-}
-
-
 /**************************************************************************
  *		import_targets
  *
  *  Import TARGETS and mark the corresponding clipboard formats as available.
  */
-static void *import_targets( Atom type, const void *data, size_t size, size_t *ret_size )
+static HANDLE import_targets( Atom type, const void *data, size_t size )
 {
     UINT i, pos, count = size / sizeof(Atom);
     const Atom *properties = data;
@@ -1201,7 +979,7 @@ static void *import_targets( Atom type, const void *data, size_t size, size_t *r
     register_x11_formats( properties, count );
 
     /* the builtin formats contain duplicates, so allocate some extra space */
-    if (!(formats = malloc( (count + ARRAY_SIZE(builtin_formats)) * sizeof(*formats ))))
+    if (!(formats = HeapAlloc( GetProcessHeap(), 0, (count + ARRAY_SIZE(builtin_formats)) * sizeof(*formats ))))
         return 0;
 
     pos = 0;
@@ -1211,22 +989,18 @@ static void *import_targets( Atom type, const void *data, size_t size, size_t *r
         if (i == count) continue;
         if (format->import && format->id)
         {
-            struct set_clipboard_params params = { .data = NULL };
-
             TRACE( "property %s -> format %s\n",
                    debugstr_xatom( properties[i] ), debugstr_format( format->id ));
-
-            NtUserSetClipboardData( format->id, 0, &params );
+            SetClipboardData( format->id, 0 );
             formats[pos++] = format;
         }
         else TRACE( "property %s (ignoring)\n", debugstr_xatom( properties[i] ));
     }
 
-    free( current_x11_formats );
+    HeapFree( GetProcessHeap(), 0, current_x11_formats );
     current_x11_formats = formats;
     nb_current_x11_formats = pos;
-    *ret_size = 0;
-    return (void *)1;
+    return (HANDLE)1;
 }
 
 
@@ -1235,14 +1009,11 @@ static void *import_targets( Atom type, const void *data, size_t size, size_t *r
  *
  *  Generic import clipboard data routine.
  */
-static void *import_data( Atom type, const void *data, size_t size, size_t *ret_size )
+static HANDLE import_data( Atom type, const void *data, size_t size )
 {
-    void *ret = malloc( size );
-    if (ret)
-    {
-        memcpy( ret, data, size );
-        *ret_size = size;
-    }
+    void *ret = GlobalAlloc( GMEM_FIXED, size );
+
+    if (ret) memcpy( ret, data, size );
     return ret;
 }
 
@@ -1252,11 +1023,11 @@ static void *import_data( Atom type, const void *data, size_t size, size_t *ret_
  *
  * Import the specified format from the selection and return a global handle to the data.
  */
-static void *import_selection( Display *display, Window win, Atom selection,
-                               struct clipboard_format *format, size_t *ret_size )
+static HANDLE import_selection( Display *display, Window win, Atom selection,
+                                struct clipboard_format *format )
 {
     unsigned char *data;
-    size_t size;
+    unsigned long size;
     Atom type;
     HANDLE ret;
 
@@ -1267,85 +1038,57 @@ static void *import_selection( Display *display, Window win, Atom selection,
         TRACE( "failed to convert selection\n" );
         return 0;
     }
-    ret = format->import( type, data, size, ret_size );
-    free( data );
+    ret = format->import( type, data, size );
+    HeapFree( GetProcessHeap(), 0, data );
     return ret;
 }
 
 
 /**************************************************************************
- *      import_xdnd_selection
+ *      X11DRV_CLIPBOARD_ImportSelection
  *
  *  Import the X selection into the clipboard format registered for the given X target.
  */
-struct format_entry *import_xdnd_selection( Display *display, Window win, Atom selection,
-                                            Atom *targets, UINT count, size_t *ret_size )
+void X11DRV_CLIPBOARD_ImportSelection( Display *display, Window win, Atom selection,
+                                       Atom *targets, UINT count,
+                                       void (*callback)( Atom, UINT, HANDLE ))
 {
-    size_t size, buf_size = 0, entry_size;
     UINT i;
-    void *data;
+    HANDLE handle;
     struct clipboard_format *format;
-    struct format_entry *ret = NULL, *entry;
-    BOOL have_hdrop = FALSE;
 
     register_x11_formats( targets, count );
-    *ret_size = 0;
-
-    for (i = 0; i < count; i++)
-    {
-        if (!(format = find_x11_format( targets[i] ))) continue;
-        if (format->id != CF_HDROP) continue;
-        have_hdrop = TRUE;
-        break;
-    }
 
     for (i = 0; i < count; i++)
     {
         if (!(format = find_x11_format( targets[i] ))) continue;
         if (!format->id) continue;
-        if (have_hdrop && format->id != CF_HDROP && format->id < CF_MAX) continue;
-
-        if (!(data = import_selection( display, win, selection, format, &size ))) continue;
-
-        entry_size = (FIELD_OFFSET( struct format_entry, data[size] ) + 7) & ~7;
-        if (buf_size < size + entry_size)
-        {
-            if (!(ret = realloc( ret, *ret_size + entry_size + 1024 ))) continue;
-            buf_size = *ret_size + entry_size + 1024; /* extra space for following entries */
-        }
-        entry = (struct format_entry *)((char *)ret + *ret_size);
-        entry->format = format->id;
-        entry->size = size;
-        if (size) memcpy( entry->data, data, size );
-        *ret_size += entry_size;
-        free( data );
+        if (!(handle = import_selection( display, win, selection, format ))) continue;
+        callback( targets[i], format->id, handle );
     }
-
-    return ret;
 }
 
 
 /**************************************************************************
  *		render_format
  */
-static BOOL render_format( UINT id )
+static HANDLE render_format( UINT id )
 {
     Display *display = thread_display();
     unsigned int i;
+    HANDLE handle = 0;
 
     if (!current_selection) return 0;
 
     for (i = 0; i < nb_current_x11_formats; i++)
     {
-        struct set_clipboard_params params = { 0 };
         if (current_x11_formats[i]->id != id) continue;
-        if (!(params.data = import_selection( display, import_window, current_selection,
-                                              current_x11_formats[i], &params.size ))) continue;
-        NtUserSetClipboardData( id, 0, &params );
-        if (params.size) free( params.data );
-        return TRUE;
+        if (!(handle = import_selection( display, import_window,
+                                         current_selection, current_x11_formats[i] ))) continue;
+        SetClipboardData( id, handle );
+        break;
     }
-    return FALSE;
+    return handle;
 }
 
 
@@ -1354,9 +1097,13 @@ static BOOL render_format( UINT id )
  *
  *  Generic export clipboard data routine.
  */
-static BOOL export_data( Display *display, Window win, Atom prop, Atom target, void *data, size_t size )
+static BOOL export_data( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
-    put_property( display, win, prop, target, 8, data, size );
+    void *ptr = GlobalLock( handle );
+
+    if (!ptr) return FALSE;
+    put_property( display, win, prop, target, 8, ptr, GlobalSize( handle ));
+    GlobalUnlock( handle );
     return TRUE;
 }
 
@@ -1366,19 +1113,31 @@ static BOOL export_data( Display *display, Window win, Atom prop, Atom target, v
  *
  * Convert CF_UNICODETEXT data to a string in the specified codepage.
  */
-static void string_from_unicode_text( char *str, size_t len, DWORD *size )
+static char *string_from_unicode_text( UINT codepage, HANDLE handle, UINT *size )
 {
-    DWORD i, j;
+    UINT i, j;
+    char *str;
+    WCHAR *strW = GlobalLock( handle );
+    UINT lenW = GlobalSize( handle ) / sizeof(WCHAR);
+    DWORD len = WideCharToMultiByte( codepage, 0, strW, lenW, NULL, 0, NULL, NULL );
 
-    /* remove carriage returns */
-    for (i = j = 0; i < len; i++)
+    if ((str = HeapAlloc( GetProcessHeap(), 0, len )))
     {
-        if (str[i] == '\r' && (i == len - 1 || str[i + 1] == '\n')) continue;
-        str[j++] = str[i];
+        WideCharToMultiByte( codepage, 0, strW, lenW, str, len, NULL, NULL);
+        GlobalUnlock( handle );
+
+        /* remove carriage returns */
+        for (i = j = 0; i < len; i++)
+        {
+            if (str[i] == '\r' && (i == len - 1 || str[i + 1] == '\n')) continue;
+            str[j++] = str[i];
+        }
+        while (j && !str[j - 1]) j--;  /* remove trailing nulls */
+        *size = j;
+        TRACE( "returning %s\n", debugstr_an( str, j ));
     }
-    while (j && !str[j - 1]) j--;  /* remove trailing nulls */
-    TRACE( "returning %s\n", debugstr_an( str, j ));
-    *size = j;
+    GlobalUnlock( handle );
+    return str;
 }
 
 
@@ -1387,17 +1146,15 @@ static void string_from_unicode_text( char *str, size_t len, DWORD *size )
  *
  * Export CF_UNICODETEXT converting the string to XA_STRING.
  */
-static BOOL export_string( Display *display, Window win, Atom prop, Atom target, void *data, size_t size )
+static BOOL export_string( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
-    DWORD len;
-    char *text;
+    UINT size;
+    char *text = string_from_unicode_text( 28591, handle, &size );
 
-    if (!(text = malloc( size ))) return FALSE;
-    RtlUnicodeToCustomCPN( get_xstring_cp(), text, size, &len, data, size );
-    string_from_unicode_text( text, len, &len );
-
-    put_property( display, win, prop, target, 8, text, len );
-    free( text );
+    if (!text) return FALSE;
+    put_property( display, win, prop, target, 8, text, size );
+    HeapFree( GetProcessHeap(), 0, text );
+    GlobalUnlock( handle );
     return TRUE;
 }
 
@@ -1407,18 +1164,15 @@ static BOOL export_string( Display *display, Window win, Atom prop, Atom target,
  *
  *  Export CF_UNICODE converting the string to UTF8.
  */
-static BOOL export_utf8_string( Display *display, Window win, Atom prop, Atom target,
-                                void *data, size_t size )
+static BOOL export_utf8_string( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
-    DWORD len;
-    char *text;
-
-    if (!(text = malloc( size / sizeof(WCHAR) * 3 ))) return FALSE;
-    RtlUnicodeToUTF8N( text, size / sizeof(WCHAR) * 3, &len, data, size );
-    string_from_unicode_text( text, len, &len );
+    UINT size;
+    char *text = string_from_unicode_text( CP_UTF8, handle, &size );
 
-    put_property( display, win, prop, target, 8, text, len );
-    free( text );
+    if (!text) return FALSE;
+    put_property( display, win, prop, target, 8, text, size );
+    HeapFree( GetProcessHeap(), 0, text );
+    GlobalUnlock( handle );
     return TRUE;
 }
 
@@ -1428,9 +1182,9 @@ static BOOL export_utf8_string( Display *display, Window win, Atom prop, Atom ta
  *
  *  Export CF_UNICODE to the polymorphic TEXT type, using UTF8.
  */
-static BOOL export_text( Display *display, Window win, Atom prop, Atom target, void *data, size_t size )
+static BOOL export_text( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
-    return export_utf8_string( display, win, prop, x11drv_atom(UTF8_STRING), data, size );
+    return export_utf8_string( display, win, prop, x11drv_atom(UTF8_STRING), handle );
 }
 
 
@@ -1439,19 +1193,14 @@ static BOOL export_text( Display *display, Window win, Atom prop, Atom target, v
  *
  *  Export CF_UNICODE to COMPOUND_TEXT
  */
-static BOOL export_compound_text( Display *display, Window win, Atom prop, Atom target,
-                                  void *data, size_t size )
+static BOOL export_compound_text( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
     XTextProperty textprop;
     XICCEncodingStyle style;
-    DWORD len;
-    char *text;
-
-
-    if (!(text = malloc( size / sizeof(WCHAR) * 3 ))) return FALSE;
-    len = ntdll_wcstoumbs( data, size / sizeof(WCHAR), text, size / sizeof(WCHAR) * 3, FALSE );
-    string_from_unicode_text( text, len, &len );
+    UINT size;
+    char *text = string_from_unicode_text( CP_UNIXCP, handle, &size );
 
+    if (!text) return FALSE;
     if (target == x11drv_atom(COMPOUND_TEXT))
         style = XCompoundTextStyle;
     else
@@ -1464,7 +1213,7 @@ static BOOL export_compound_text( Display *display, Window win, Atom prop, Atom
         XFree( textprop.value );
     }
 
-    free( text );
+    HeapFree( GetProcessHeap(), 0, text );
     return TRUE;
 }
 
@@ -1474,16 +1223,18 @@ static BOOL export_compound_text( Display *display, Window win, Atom prop, Atom
  *
  *  Export CF_DIB to XA_PIXMAP.
  */
-static BOOL export_pixmap( Display *display, Window win, Atom prop, Atom target, void *data, size_t size )
+static BOOL export_pixmap( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
     Pixmap pixmap;
-    BITMAPINFO *pbmi = data;
+    BITMAPINFO *pbmi;
     struct gdi_image_bits bits;
 
+    pbmi = GlobalLock( handle );
     bits.ptr = (LPBYTE)pbmi + bitmap_info_size( pbmi, DIB_RGB_COLORS );
     bits.free = NULL;
     bits.is_copy = FALSE;
     pixmap = create_pixmap_from_image( 0, &default_visual, pbmi, &bits, DIB_RGB_COLORS );
+    GlobalUnlock( handle );
 
     put_property( display, win, prop, target, 32, &pixmap, 1 );
     /* FIXME: free the pixmap when the property is deleted */
@@ -1496,14 +1247,14 @@ static BOOL export_pixmap( Display *display, Window win, Atom prop, Atom target,
  *
  *  Export CF_DIB to image/bmp.
  */
-static BOOL export_image_bmp( Display *display, Window win, Atom prop, Atom target, void *data, size_t size )
+static BOOL export_image_bmp( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
-    LPBYTE dibdata = data;
+    LPBYTE dibdata = GlobalLock( handle );
     UINT bmpsize;
     BITMAPFILEHEADER *bfh;
 
-    bmpsize = sizeof(BITMAPFILEHEADER) + size;
-    bfh = malloc( bmpsize );
+    bmpsize = sizeof(BITMAPFILEHEADER) + GlobalSize( handle );
+    bfh = HeapAlloc( GetProcessHeap(), 0, bmpsize );
     if (bfh)
     {
         /* bitmap file header */
@@ -1516,8 +1267,29 @@ static BOOL export_image_bmp( Display *display, Window win, Atom prop, Atom targ
         /* rest of bitmap is the same as the packed dib */
         memcpy(bfh+1, dibdata, bmpsize-sizeof(BITMAPFILEHEADER));
     }
+    GlobalUnlock( handle );
     put_property( display, win, prop, target, 8, bfh, bmpsize );
-    free( bfh );
+    HeapFree( GetProcessHeap(), 0, bfh );
+    return TRUE;
+}
+
+
+/**************************************************************************
+ *		export_enhmetafile
+ *
+ *  Export EnhMetaFile.
+ */
+static BOOL export_enhmetafile( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
+{
+    unsigned int size;
+    void *ptr;
+
+    if (!(size = GetEnhMetaFileBits( handle, 0, NULL ))) return FALSE;
+    if (!(ptr = HeapAlloc( GetProcessHeap(), 0, size ))) return FALSE;
+
+    GetEnhMetaFileBits( handle, size, ptr );
+    put_property( display, win, prop, target, 8, ptr, size );
+    HeapFree( GetProcessHeap(), 0, ptr );
     return TRUE;
 }
 
@@ -1529,12 +1301,14 @@ static BOOL export_image_bmp( Display *display, Window win, Atom prop, Atom targ
  *
  * FIXME: We should attempt to add an <a base> tag and convert windows paths.
  */
-static BOOL export_text_html( Display *display, Window win, Atom prop, Atom target, void *data, size_t size )
+static BOOL export_text_html( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
-    const char *p;
+    const char *p, *data;
     UINT start = 0, end = 0;
     BOOL ret = TRUE;
 
+    if (!(data = GlobalLock( handle ))) return FALSE;
+
     p = data;
     while (*p && *p != '<')
     {
@@ -1543,11 +1317,12 @@ static BOOL export_text_html( Display *display, Window win, Atom prop, Atom targ
         if (!(p = strpbrk( p, "\r\n" ))) break;
         while (*p == '\r' || *p == '\n') p++;
     }
-    if (start && start < end && end <= size)
-        put_property( display, win, prop, target, 8, (char *)data + start, end - start );
+    if (start && start < end && end <= GlobalSize( handle ))
+        put_property( display, win, prop, target, 8, data + start, end - start );
     else
         ret = FALSE;
 
+    GlobalUnlock( handle );
     return ret;
 }
 
@@ -1557,52 +1332,39 @@ static BOOL export_text_html( Display *display, Window win, Atom prop, Atom targ
  *
  *  Export CF_HDROP format to text/uri-list.
  */
-static BOOL export_hdrop( Display *display, Window win, Atom prop, Atom target, void *data, size_t size )
+static BOOL export_hdrop( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
-    char *textUriList = NULL;
+    UINT i;
+    UINT numFiles;
+    char *textUriList;
     UINT textUriListSize = 32;
     UINT next = 0;
-    const WCHAR *ptr;
-    WCHAR *unicode_data = NULL;
-    DROPFILES *drop_files = data;
-
-    if (!drop_files->fWide)
-    {
-        char *files = (char *)data + drop_files->pFiles;
-        CPTABLEINFO *cp = get_ansi_cp();
-        DWORD len = 0;
-
-        while (files[len]) len += strlen( files + len ) + 1;
-        len++;
-
-        if (!(ptr = unicode_data = malloc( len * sizeof(WCHAR) ))) goto failed;
-
-        if (cp->CodePage == CP_UTF8)
-            RtlUTF8ToUnicodeN( unicode_data, len * sizeof(WCHAR), &len, files, len );
-        else
-            RtlCustomCPToUnicodeN( cp, unicode_data, len * sizeof(WCHAR), &len, files, len );
-    }
-    else ptr = (const WCHAR *)((char *)data + drop_files->pFiles);
-
-    if (!(textUriList = malloc( textUriListSize ))) goto failed;
 
-    while (*ptr)
+    textUriList = HeapAlloc( GetProcessHeap(), 0, textUriListSize );
+    if (!textUriList) return FALSE;
+    numFiles = DragQueryFileW( handle, 0xFFFFFFFF, NULL, 0 );
+    for (i = 0; i < numFiles; i++)
     {
+        UINT dosFilenameSize;
+        WCHAR *dosFilename = NULL;
         char *unixFilename = NULL;
         UINT uriSize;
         UINT u;
 
-        unixFilename = get_unix_file_name( ptr );
+        dosFilenameSize = 1 + DragQueryFileW( handle, i, NULL, 0 );
+        dosFilename = HeapAlloc(GetProcessHeap(), 0, dosFilenameSize*sizeof(WCHAR));
+        if (dosFilename == NULL) goto failed;
+        DragQueryFileW( handle, i, dosFilename, dosFilenameSize );
+        unixFilename = wine_get_unix_file_name(dosFilename);
+        HeapFree(GetProcessHeap(), 0, dosFilename);
         if (unixFilename == NULL) goto failed;
-        ptr += lstrlenW( ptr ) + 1;
-
         uriSize = 8 + /* file:/// */
                 3 * (lstrlenA(unixFilename) - 1) + /* "%xy" per char except first '/' */
                 2; /* \r\n */
         if ((next + uriSize) > textUriListSize)
         {
             UINT biggerSize = max( 2 * textUriListSize, next + uriSize );
-            void *bigger = realloc( textUriList, biggerSize );
+            void *bigger = HeapReAlloc( GetProcessHeap(), 0, textUriList, biggerSize );
             if (bigger)
             {
                 textUriList = bigger;
@@ -1610,7 +1372,7 @@ static BOOL export_hdrop( Display *display, Window win, Atom prop, Atom target,
             }
             else
             {
-                free( unixFilename );
+                HeapFree(GetProcessHeap(), 0, unixFilename);
                 goto failed;
             }
         }
@@ -1626,15 +1388,14 @@ static BOOL export_hdrop( Display *display, Window win, Atom prop, Atom target,
         }
         textUriList[next++] = '\r';
         textUriList[next++] = '\n';
-        free( unixFilename );
+        HeapFree(GetProcessHeap(), 0, unixFilename);
     }
     put_property( display, win, prop, target, 8, textUriList, next );
-    free( textUriList );
+    HeapFree( GetProcessHeap(), 0, textUriList );
     return TRUE;
 
 failed:
-    free( unicode_data );
-    free( textUriList );
+    HeapFree( GetProcessHeap(), 0, textUriList );
     return FALSE;
 }
 
@@ -1652,9 +1413,9 @@ static UINT *get_clipboard_formats( UINT *size )
     *size = 256;
     for (;;)
     {
-        if (!(ids = malloc( *size * sizeof(*ids) ))) return NULL;
-        if (NtUserGetUpdatedClipboardFormats( ids, *size, size )) break;
-        free( ids );
+        if (!(ids = HeapAlloc( GetProcessHeap(), 0, *size * sizeof(*ids) ))) return NULL;
+        if (GetUpdatedClipboardFormats( ids, *size, size )) break;
+        HeapFree( GetProcessHeap(), 0, ids );
         if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) return NULL;
     }
     register_win32_formats( ids, *size );
@@ -1680,7 +1441,7 @@ static BOOL is_format_available( UINT format, const UINT *ids, unsigned int coun
  *
  *  Service a TARGETS selection request event
  */
-static BOOL export_targets( Display *display, Window win, Atom prop, Atom target, void *data, size_t size )
+static BOOL export_targets( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
     struct clipboard_format *format;
     UINT pos, count, *formats;
@@ -1689,9 +1450,10 @@ static BOOL export_targets( Display *display, Window win, Atom prop, Atom target
     if (!(formats = get_clipboard_formats( &count ))) return FALSE;
 
     /* the builtin formats contain duplicates, so allocate some extra space */
-    if (!(targets = malloc( (count + ARRAY_SIZE(builtin_formats)) * sizeof(*targets) )))
+    if (!(targets = HeapAlloc( GetProcessHeap(), 0,
+                               (count + ARRAY_SIZE(builtin_formats)) * sizeof(*targets) )))
     {
-        free( formats );
+        HeapFree( GetProcessHeap(), 0, formats );
         return FALSE;
     }
 
@@ -1706,8 +1468,8 @@ static BOOL export_targets( Display *display, Window win, Atom prop, Atom target
     }
 
     put_property( display, win, prop, XA_ATOM, 32, targets, pos );
-    free( targets );
-    free( formats );
+    HeapFree( GetProcessHeap(), 0, targets );
+    HeapFree( GetProcessHeap(), 0, formats );
     return TRUE;
 }
 
@@ -1719,10 +1481,9 @@ static BOOL export_targets( Display *display, Window win, Atom prop, Atom target
  */
 static BOOL export_selection( Display *display, Window win, Atom prop, Atom target )
 {
-    struct get_clipboard_params params = { .data_only = TRUE };
     struct clipboard_format *format;
+    HANDLE handle = 0;
     BOOL open = FALSE, ret = FALSE;
-    size_t buffer_size = 0;
 
     LIST_FOR_EACH_ENTRY( format, &format_list, struct clipboard_format, entry )
     {
@@ -1731,44 +1492,26 @@ static BOOL export_selection( Display *display, Window win, Atom prop, Atom targ
         if (!format->id)
         {
             TRACE( "win %lx prop %s target %s\n", win, debugstr_xatom( prop ), debugstr_xatom( target ));
-            ret = format->export( display, win, prop, target, NULL, 0 );
+            ret = format->export( display, win, prop, target, 0 );
             break;
         }
-        if (!open && !(open = NtUserOpenClipboard( clipboard_hwnd, 0 )))
+        if (!open && !(open = OpenClipboard( clipboard_hwnd )))
         {
             ERR( "failed to open clipboard for %s\n", debugstr_xatom( target ));
             return FALSE;
         }
-
-        if (!buffer_size)
+        if ((handle = GetClipboardData( format->id )))
         {
-            buffer_size = 1024;
-            if (!(params.data = malloc( buffer_size ))) break;
-        }
-
-        for (;;)
-        {
-            params.size = buffer_size;
-            if (NtUserGetClipboardData( format->id, &params ))
-            {
-                TRACE( "win %lx prop %s target %s exporting %s\n",
-                       win, debugstr_xatom( prop ), debugstr_xatom( target ),
-                       debugstr_format( format->id ) );
+            TRACE( "win %lx prop %s target %s exporting %s %p\n",
+                   win, debugstr_xatom( prop ), debugstr_xatom( target ),
+                   debugstr_format( format->id ), handle );
 
-                ret = format->export( display, win, prop, target, params.data, params.size );
-                goto done;
-            }
-            if (!params.data_size) break;
-            free( params.data );
-            if (!(params.data = malloc( params.data_size ))) goto done;
-            buffer_size = params.data_size;
-            params.data_size = 0;
+            ret = format->export( display, win, prop, target, handle );
+            break;
         }
         /* keep looking for another Win32 format mapping to the same target */
     }
-done:
-    free( params.data );
-    if (open) NtUserCloseClipboard();
+    if (open) CloseClipboard();
     return ret;
 }
 
@@ -1786,7 +1529,7 @@ done:
  *  2. If we fail to convert the target named by an atom in the MULTIPLE property,
  *  we replace the atom in the property by None.
  */
-static BOOL export_multiple( Display *display, Window win, Atom prop, Atom target, void *data, size_t size )
+static BOOL export_multiple( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
     Atom atype;
     int aformat;
@@ -1832,7 +1575,7 @@ static BOOL export_multiple( Display *display, Window win, Atom prop, Atom targe
  *
  * Export the timestamp that was used to acquire the selection
  */
-static BOOL export_timestamp( Display *display, Window win, Atom prop, Atom target, void *data, size_t size )
+static BOOL export_timestamp( Display *display, Window win, Atom prop, Atom target, HANDLE handle )
 {
     Time time = CurrentTime;  /* FIXME */
     put_property( display, win, prop, XA_INTEGER, 32, &time, 1 );
@@ -1845,7 +1588,7 @@ static BOOL export_timestamp( Display *display, Window win, Atom prop, Atom targ
  *  Gets type, data and size.
  */
 static BOOL X11DRV_CLIPBOARD_GetProperty(Display *display, Window w, Atom prop,
-    Atom *atype, unsigned char **data, size_t *datasize)
+    Atom *atype, unsigned char** data, unsigned long* datasize)
 {
     int aformat;
     unsigned long pos = 0, nitems, remain, count;
@@ -1857,17 +1600,18 @@ static BOOL X11DRV_CLIPBOARD_GetProperty(Display *display, Window w, Atom prop,
                                AnyPropertyType, atype, &aformat, &nitems, &remain, &buffer))
         {
             WARN("Failed to read property\n");
-            free( val );
+            HeapFree( GetProcessHeap(), 0, val );
             return FALSE;
         }
 
         count = get_property_size( aformat, nitems );
-        *data = realloc( val, pos * sizeof(int) + count + 1 );
+        if (!val) *data = HeapAlloc( GetProcessHeap(), 0, pos * sizeof(int) + count + 1 );
+        else *data = HeapReAlloc( GetProcessHeap(), 0, val, pos * sizeof(int) + count + 1 );
 
         if (!*data)
         {
             XFree( buffer );
-            free( val );
+            HeapFree( GetProcessHeap(), 0, val );
             return FALSE;
         }
         val = *data;
@@ -1882,7 +1626,7 @@ static BOOL X11DRV_CLIPBOARD_GetProperty(Display *display, Window w, Atom prop,
         pos += count / sizeof(int);
     }
 
-    TRACE( "got property %s type %s format %u len %zu from window %lx\n",
+    TRACE( "got property %s type %s format %u len %lu from window %lx\n",
            debugstr_xatom( prop ), debugstr_xatom( *atype ), aformat, *datasize, w );
 
     /* Delete the property on the window now that we are done
@@ -1904,7 +1648,7 @@ struct clipboard_data_packet {
  *  Reads the contents of the X selection property.
  */
 static BOOL read_property( Display *display, Window w, Atom prop,
-                           Atom *type, unsigned char **data, size_t *datasize )
+                           Atom *type, unsigned char **data, unsigned long *datasize )
 {
     XEvent xe;
 
@@ -1925,7 +1669,7 @@ static BOOL read_property( Display *display, Window w, Atom prop,
         struct clipboard_data_packet *packet, *packet2;
         BOOL res;
 
-        free( *data );
+        HeapFree(GetProcessHeap(), 0, *data);
         *data = NULL;
 
         list_init(&packets);
@@ -1934,7 +1678,7 @@ static BOOL read_property( Display *display, Window w, Atom prop,
         {
             int i;
             unsigned char *prop_data;
-            size_t prop_size;
+            unsigned long prop_size;
 
             /* Wait until PropertyNotify is received */
             for (i = 0; i < SELECTION_RETRIES; i++)
@@ -1945,7 +1689,7 @@ static BOOL read_property( Display *display, Window w, Atom prop,
                 if (res && xe.xproperty.atom == prop &&
                     xe.xproperty.state == PropertyNewValue)
                     break;
-                selection_sleep();
+                Sleep(SELECTION_WAIT);
             }
 
             if (i >= SELECTION_RETRIES ||
@@ -1958,15 +1702,15 @@ static BOOL read_property( Display *display, Window w, Atom prop,
             /* Retrieved entire data. */
             if (prop_size == 0)
             {
-                free( prop_data );
+                HeapFree(GetProcessHeap(), 0, prop_data);
                 res = TRUE;
                 break;
             }
 
-            packet = malloc( sizeof(*packet) );
+            packet = HeapAlloc(GetProcessHeap(), 0, sizeof(*packet));
             if (!packet)
             {
-                free( prop_data );
+                HeapFree(GetProcessHeap(), 0, prop_data);
                 res = FALSE;
                 break;
             }
@@ -1979,7 +1723,7 @@ static BOOL read_property( Display *display, Window w, Atom prop,
 
         if (res)
         {
-            buf = malloc( bufsize + 1 );
+            buf = HeapAlloc(GetProcessHeap(), 0, bufsize + 1);
             if (buf)
             {
                 unsigned long bytes_copied = 0;
@@ -1998,8 +1742,8 @@ static BOOL read_property( Display *display, Window w, Atom prop,
 
         LIST_FOR_EACH_ENTRY_SAFE( packet, packet2, &packets, struct clipboard_data_packet, entry)
         {
-            free( packet->data );
-            free( packet );
+            HeapFree(GetProcessHeap(), 0, packet->data);
+            HeapFree(GetProcessHeap(), 0, packet);
         }
 
         return res;
@@ -2060,7 +1804,7 @@ static BOOL request_selection_contents( Display *display, BOOL changed )
     struct clipboard_format *format = NULL;
     Window owner = 0;
     unsigned char *data = NULL;
-    size_t import_size, size = 0;
+    unsigned long size = 0;
     Atom type = 0;
 
     static Atom last_selection;
@@ -2102,30 +1846,30 @@ static BOOL request_selection_contents( Display *display, BOOL changed )
                last_size != size ||
                memcmp( last_data, data, size ));
 
-    if (!changed || !NtUserOpenClipboard( clipboard_hwnd, 0 ))
+    if (!changed || !OpenClipboard( clipboard_hwnd ))
     {
-        free( data );
+        HeapFree( GetProcessHeap(), 0, data );
         return FALSE;
     }
 
     TRACE( "selection changed, importing\n" );
-    NtUserEmptyClipboard();
+    EmptyClipboard();
     is_clipboard_owner = TRUE;
     rendered_formats = 0;
 
-    if (format) format->import( type, data, size, &import_size );
+    if (format) format->import( type, data, size );
 
-    free( last_data );
+    HeapFree( GetProcessHeap(), 0, last_data );
     last_selection = current_selection;
     last_owner = owner;
     last_format = format;
     last_type = type;
     last_data = data;
     last_size = size;
-    last_clipboard_update = NtGetTickCount();
-    NtUserCloseClipboard();
+    last_clipboard_update = GetTickCount64();
+    CloseClipboard();
     if (!use_xfixes)
-        NtUserSetTimer( clipboard_hwnd, 1, SELECTION_UPDATE_DELAY, NULL, TIMERV_DEFAULT_COALESCING );
+        SetTimer( clipboard_hwnd, 1, SELECTION_UPDATE_DELAY, NULL );
     return TRUE;
 }
 
@@ -2140,11 +1884,72 @@ BOOL update_clipboard( HWND hwnd )
     if (use_xfixes) return TRUE;
     if (hwnd != clipboard_hwnd) return TRUE;
     if (!is_clipboard_owner) return TRUE;
-    if (NtGetTickCount() - last_clipboard_update <= SELECTION_UPDATE_DELAY) return TRUE;
+    if (GetTickCount64() - last_clipboard_update <= SELECTION_UPDATE_DELAY) return TRUE;
     return request_selection_contents( thread_display(), FALSE );
 }
 
 
+/**************************************************************************
+ *		clipboard_wndproc
+ *
+ * Window procedure for the clipboard manager.
+ */
+static LRESULT CALLBACK clipboard_wndproc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
+{
+    switch (msg)
+    {
+    case WM_NCCREATE:
+        return TRUE;
+    case WM_CLIPBOARDUPDATE:
+        if (is_clipboard_owner) break;  /* ignore our own changes */
+        acquire_selection( thread_init_display() );
+        break;
+    case WM_RENDERFORMAT:
+        if (render_format( wp )) rendered_formats++;
+        break;
+    case WM_TIMER:
+        if (!is_clipboard_owner) break;
+        request_selection_contents( thread_display(), FALSE );
+        break;
+    case WM_DESTROYCLIPBOARD:
+        TRACE( "WM_DESTROYCLIPBOARD: lost ownership\n" );
+        is_clipboard_owner = FALSE;
+        KillTimer( hwnd, 1 );
+        break;
+    }
+    return DefWindowProcW( hwnd, msg, wp, lp );
+}
+
+
+/**************************************************************************
+ *		wait_clipboard_mutex
+ *
+ * Make sure that there's only one clipboard thread per window station.
+ */
+static BOOL wait_clipboard_mutex(void)
+{
+    static const WCHAR prefix[] = {'_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d','_'};
+    WCHAR buffer[MAX_PATH + ARRAY_SIZE( prefix )];
+    HANDLE mutex;
+
+    memcpy( buffer, prefix, sizeof(prefix) );
+    if (!GetUserObjectInformationW( GetProcessWindowStation(), UOI_NAME,
+                                    buffer + ARRAY_SIZE( prefix ),
+                                    sizeof(buffer) - sizeof(prefix), NULL ))
+    {
+        ERR( "failed to get winstation name\n" );
+        return FALSE;
+    }
+    mutex = CreateMutexW( NULL, TRUE, buffer );
+    if (GetLastError() == ERROR_ALREADY_EXISTS)
+    {
+        TRACE( "waiting for mutex %s\n", debugstr_w( buffer ));
+        WaitForSingleObject( mutex, INFINITE );
+    }
+    return TRUE;
+}
+
+
 /**************************************************************************
  *              selection_notify_event
  *
@@ -2215,15 +2020,19 @@ static void xfixes_init(void)
 
 
 /**************************************************************************
- *		clipboard_init
+ *		clipboard_thread
  *
  * Thread running inside the desktop process to manage the clipboard
  */
-static BOOL clipboard_init( HWND hwnd )
+static DWORD WINAPI clipboard_thread( void *arg )
 {
+    static const WCHAR clipboard_classname[] = {'_','_','w','i','n','e','_','c','l','i','p','b','o','a','r','d','_','m','a','n','a','g','e','r',0};
     XSetWindowAttributes attr;
+    WNDCLASSW class;
+    MSG msg;
+
+    if (!wait_clipboard_mutex()) return 0;
 
-    clipboard_hwnd = hwnd;
     clipboard_display = thread_init_display();
     attr.event_mask = PropertyChangeMask;
     import_window = XCreateWindow( clipboard_display, root_window, 0, 0, 1, 1, 0, CopyFromParent,
@@ -2231,57 +2040,41 @@ static BOOL clipboard_init( HWND hwnd )
     if (!import_window)
     {
         ERR( "failed to create import window\n" );
-        return FALSE;
+        return 0;
+    }
+
+    memset( &class, 0, sizeof(class) );
+    class.lpfnWndProc   = clipboard_wndproc;
+    class.lpszClassName = clipboard_classname;
+
+    if (!RegisterClassW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+    {
+        ERR( "could not register clipboard window class err %u\n", GetLastError() );
+        return 0;
+    }
+    if (!(clipboard_hwnd = CreateWindowW( clipboard_classname, NULL, 0, 0, 0, 0, 0,
+                                          HWND_MESSAGE, 0, 0, NULL )))
+    {
+        ERR( "failed to create clipboard window err %u\n", GetLastError() );
+        return 0;
     }
 
     clipboard_thread_id = GetCurrentThreadId();
-    NtUserAddClipboardFormatListener( hwnd );
+    AddClipboardFormatListener( clipboard_hwnd );
     register_builtin_formats();
     xfixes_init();
     request_selection_contents( clipboard_display, TRUE );
 
     TRACE( "clipboard thread %04x running\n", GetCurrentThreadId() );
-    return TRUE;
-}
-
-
-
-
-/**************************************************************************
- *           x11drv_clipboard_message
- */
-LRESULT X11DRV_ClipboardWindowProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    switch (msg)
-    {
-    case WM_NCCREATE:
-        return clipboard_init( hwnd );
-    case WM_CLIPBOARDUPDATE:
-        if (is_clipboard_owner) break;  /* ignore our own changes */
-        acquire_selection( thread_init_display() );
-        break;
-    case WM_RENDERFORMAT:
-        if (render_format( wparam )) rendered_formats++;
-        break;
-    case WM_TIMER:
-        if (!is_clipboard_owner) break;
-        request_selection_contents( thread_display(), FALSE );
-        break;
-    case WM_DESTROYCLIPBOARD:
-        TRACE( "WM_DESTROYCLIPBOARD: lost ownership\n" );
-        is_clipboard_owner = FALSE;
-        NtUserKillTimer( hwnd, 1 );
-        break;
-    }
-
-    return NtUserMessageCall( hwnd, msg, wparam, lparam, NULL, NtUserDefWindowProc, FALSE );
+    while (GetMessageW( &msg, 0, 0, 0 )) DispatchMessageW( &msg );
+    return 0;
 }
 
 
 /**************************************************************************
  *		X11DRV_UpdateClipboard
  */
-void X11DRV_UpdateClipboard(void)
+void CDECL X11DRV_UpdateClipboard(void)
 {
     static ULONG last_update;
     ULONG now;
@@ -2289,10 +2082,10 @@ void X11DRV_UpdateClipboard(void)
 
     if (use_xfixes) return;
     if (GetCurrentThreadId() == clipboard_thread_id) return;
-    now = NtGetTickCount();
+    now = GetTickCount();
     if ((int)(now - last_update) <= SELECTION_UPDATE_DELAY) return;
-    if (send_message_timeout( NtUserGetClipboardOwner(), WM_X11DRV_UPDATE_CLIPBOARD, 0, 0,
-                              SMTO_ABORTIFHUNG, 5000, &ret ) && ret)
+    if (SendMessageTimeoutW( GetClipboardOwner(), WM_X11DRV_UPDATE_CLIPBOARD, 0, 0,
+                             SMTO_ABORTIFHUNG, 5000, &ret ) && ret)
         last_update = now;
 }
 
@@ -2353,3 +2146,16 @@ BOOL X11DRV_SelectionClear( HWND hwnd, XEvent *xev )
     request_selection_contents( event->display, TRUE );
     return FALSE;
 }
+
+
+/**************************************************************************
+ *		X11DRV_InitClipboard
+ */
+void X11DRV_InitClipboard(void)
+{
+    DWORD id;
+    HANDLE handle = CreateThread( NULL, 0, clipboard_thread, NULL, 0, &id );
+
+    if (handle) CloseHandle( handle );
+    else ERR( "failed to create clipboard thread\n" );
+}
diff --git a/dlls/winex11.drv/desktop.c b/dlls/winex11.drv/desktop.c
index bc2ba60397b..0ac538d06ed 100644
--- a/dlls/winex11.drv/desktop.c
+++ b/dlls/winex11.drv/desktop.c
@@ -19,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 #include <X11/cursorfont.h>
 #include <X11/Xlib.h>
@@ -35,6 +31,7 @@
 /* avoid conflict with field names in included win32 headers */
 #undef Status
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
 
@@ -94,7 +91,7 @@ static BOOL X11DRV_desktop_get_id( const WCHAR *device_name, ULONG_PTR *id )
 {
     WCHAR primary_adapter[CCHDEVICENAME];
 
-    if (!get_primary_adapter( primary_adapter ) || wcsicmp( primary_adapter, device_name ))
+    if (!get_primary_adapter( primary_adapter ) || lstrcmpiW( primary_adapter, device_name ))
         return FALSE;
 
     *id = 0;
@@ -121,12 +118,12 @@ static BOOL X11DRV_desktop_get_modes( ULONG_PTR id, DWORD flags, DEVMODEW **new_
     RECT primary_rect;
     DEVMODEW *modes;
 
-    primary_rect = NtUserGetPrimaryMonitorRect();
+    primary_rect = get_primary_monitor_rect();
     screen_width = primary_rect.right - primary_rect.left;
     screen_height = primary_rect.bottom - primary_rect.top;
 
     /* Allocate memory for modes in different color depths */
-    if (!(modes = calloc( (ARRAY_SIZE(screen_sizes) + 2) * DEPTH_COUNT, sizeof(*modes))) )
+    if (!(modes = heap_calloc( (ARRAY_SIZE(screen_sizes) + 2) * DEPTH_COUNT, sizeof(*modes))) )
     {
         SetLastError( ERROR_NOT_ENOUGH_MEMORY );
         return FALSE;
@@ -164,12 +161,12 @@ static BOOL X11DRV_desktop_get_modes( ULONG_PTR id, DWORD flags, DEVMODEW **new_
 
 static void X11DRV_desktop_free_modes( DEVMODEW *modes )
 {
-    free( modes );
+    heap_free( modes );
 }
 
 static BOOL X11DRV_desktop_get_current_mode( ULONG_PTR id, DEVMODEW *mode )
 {
-    RECT primary_rect = NtUserGetPrimaryMonitorRect();
+    RECT primary_rect = get_primary_monitor_rect();
 
     mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
                      DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY | DM_POSITION;
@@ -196,13 +193,12 @@ static LONG X11DRV_desktop_set_current_mode( ULONG_PTR id, DEVMODEW *mode )
 
 static void query_desktop_work_area( RECT *rc_work )
 {
-    static const WCHAR trayW[] = {'S','h','e','l','l','_','T','r','a','y','W','n','d'};
-    UNICODE_STRING str = { sizeof(trayW), sizeof(trayW), (WCHAR *)trayW };
+    static const WCHAR trayW[] = {'S','h','e','l','l','_','T','r','a','y','W','n','d',0};
     RECT rect;
-    HWND hwnd = NtUserFindWindowEx( 0, 0, &str, NULL, 0 );
+    HWND hwnd = FindWindowW( trayW, NULL );
 
-    if (!hwnd || !NtUserIsWindowVisible( hwnd )) return;
-    if (!NtUserGetWindowRect( hwnd, &rect )) return;
+    if (!hwnd || !IsWindowVisible( hwnd )) return;
+    if (!GetWindowRect( hwnd, &rect )) return;
     if (rect.top) rc_work->bottom = rect.top;
     else rc_work->top = rect.bottom;
     TRACE( "found tray %p %s work area %s\n", hwnd, wine_dbgstr_rect( &rect ), wine_dbgstr_rect( rc_work ) );
@@ -213,7 +209,7 @@ static BOOL X11DRV_desktop_get_gpus( struct gdi_gpu **new_gpus, int *count )
     static const WCHAR wine_adapterW[] = {'W','i','n','e',' ','A','d','a','p','t','e','r',0};
     struct gdi_gpu *gpu;
 
-    gpu = calloc( 1, sizeof(*gpu) );
+    gpu = heap_calloc( 1, sizeof(*gpu) );
     if (!gpu) return FALSE;
 
     if (!get_host_primary_gpu( gpu ))
@@ -229,7 +225,7 @@ static BOOL X11DRV_desktop_get_gpus( struct gdi_gpu **new_gpus, int *count )
 
 static void X11DRV_desktop_free_gpus( struct gdi_gpu *gpus )
 {
-    free( gpus );
+    heap_free( gpus );
 }
 
 /* TODO: Support multi-head virtual desktop */
@@ -237,7 +233,7 @@ static BOOL X11DRV_desktop_get_adapters( ULONG_PTR gpu_id, struct gdi_adapter **
 {
     struct gdi_adapter *adapter;
 
-    adapter = calloc( 1, sizeof(*adapter) );
+    adapter = heap_calloc( 1, sizeof(*adapter) );
     if (!adapter) return FALSE;
 
     adapter->state_flags = DISPLAY_DEVICE_PRIMARY_DEVICE;
@@ -251,7 +247,7 @@ static BOOL X11DRV_desktop_get_adapters( ULONG_PTR gpu_id, struct gdi_adapter **
 
 static void X11DRV_desktop_free_adapters( struct gdi_adapter *adapters )
 {
-    free( adapters );
+    heap_free( adapters );
 }
 
 static BOOL X11DRV_desktop_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **new_monitors, int *count )
@@ -261,7 +257,7 @@ static BOOL X11DRV_desktop_get_monitors( ULONG_PTR adapter_id, struct gdi_monito
         'N','o','n','-','P','n','P',' ','M','o','n','i','t','o','r',0};
     struct gdi_monitor *monitor;
 
-    monitor = calloc( 1, sizeof(*monitor) );
+    monitor = heap_calloc( 1, sizeof(*monitor) );
     if (!monitor) return FALSE;
 
     lstrcpyW( monitor->name, generic_nonpnp_monitorW );
@@ -281,7 +277,7 @@ static BOOL X11DRV_desktop_get_monitors( ULONG_PTR adapter_id, struct gdi_monito
 
 static void X11DRV_desktop_free_monitors( struct gdi_monitor *monitors, int count )
 {
-    free( monitors );
+    heap_free( monitors );
 }
 
 /***********************************************************************
@@ -326,27 +322,26 @@ void X11DRV_init_desktop( Window win, unsigned int width, unsigned int height )
 
 
 /***********************************************************************
- *           x11drv_create_desktop
+ *		X11DRV_create_desktop
  *
  * Create the X11 desktop window for the desktop mode.
  */
-NTSTATUS x11drv_create_desktop( void *arg )
+BOOL CDECL X11DRV_create_desktop( UINT width, UINT height )
 {
     static const WCHAR rootW[] = {'r','o','o','t',0};
-    const struct create_desktop_params *params = arg;
     XSetWindowAttributes win_attr;
     Window win;
     Display *display = thread_init_display();
     WCHAR name[MAX_PATH];
 
-    if (!NtUserGetObjectInformation( NtUserGetThreadDesktop( GetCurrentThreadId() ),
-                                     UOI_NAME, name, sizeof(name), NULL ))
+    if (!GetUserObjectInformationW( GetThreadDesktop( GetCurrentThreadId() ),
+                                    UOI_NAME, name, sizeof(name), NULL ))
         name[0] = 0;
 
-    TRACE( "%s %ux%u\n", debugstr_w(name), params->width, params->height );
+    TRACE( "%s %ux%u\n", debugstr_w(name), width, height );
 
     /* magic: desktop "root" means use the root window */
-    if (!wcsicmp( name, rootW )) return FALSE;
+    if (!lstrcmpiW( name, rootW )) return FALSE;
 
     /* Create window */
     win_attr.event_mask = ExposureMask | KeyPressMask | KeyReleaseMask | EnterWindowMask |
@@ -360,12 +355,12 @@ NTSTATUS x11drv_create_desktop( void *arg )
         win_attr.colormap = None;
 
     win = XCreateWindow( display, DefaultRootWindow(display),
-                         0, 0, params->width, params->height, 0, default_visual.depth, InputOutput,
-                         default_visual.visual, CWEventMask | CWCursor | CWColormap, &win_attr );
+                         0, 0, width, height, 0, default_visual.depth, InputOutput, default_visual.visual,
+                         CWEventMask | CWCursor | CWColormap, &win_attr );
     if (!win) return FALSE;
     if (!create_desktop_win_data( win )) return FALSE;
 
-    X11DRV_init_desktop( win, params->width, params->height );
+    X11DRV_init_desktop( win, width, height );
     if (is_desktop_fullscreen())
     {
         TRACE("setting desktop to fullscreen\n");
@@ -379,7 +374,7 @@ NTSTATUS x11drv_create_desktop( void *arg )
 
 BOOL is_desktop_fullscreen(void)
 {
-    RECT primary_rect = NtUserGetPrimaryMonitorRect();
+    RECT primary_rect = get_primary_monitor_rect();
     return (primary_rect.right - primary_rect.left == max_width &&
             primary_rect.bottom - primary_rect.top == max_height);
 }
@@ -423,31 +418,31 @@ static void update_desktop_fullscreen( unsigned int width, unsigned int height)
 void X11DRV_resize_desktop( BOOL send_display_change )
 {
     RECT primary_rect, virtual_rect;
-    HWND hwnd = NtUserGetDesktopWindow();
+    HWND hwnd = GetDesktopWindow();
     INT width, height;
 
-    virtual_rect = NtUserGetVirtualScreenRect();
-    primary_rect = NtUserGetPrimaryMonitorRect();
+    virtual_rect = get_virtual_screen_rect();
+    primary_rect = get_primary_monitor_rect();
     width = primary_rect.right;
     height = primary_rect.bottom;
 
-    if (NtUserGetWindowThread( hwnd, NULL ) != GetCurrentThreadId())
+    if (GetWindowThreadProcessId( hwnd, NULL ) != GetCurrentThreadId())
     {
-        send_message( hwnd, WM_X11DRV_RESIZE_DESKTOP, 0, (LPARAM)send_display_change );
+        SendMessageW( hwnd, WM_X11DRV_RESIZE_DESKTOP, 0, (LPARAM)send_display_change );
     }
     else
     {
         TRACE( "desktop %p change to (%dx%d)\n", hwnd, width, height );
         update_desktop_fullscreen( width, height );
-        NtUserSetWindowPos( hwnd, 0, virtual_rect.left, virtual_rect.top,
-                            virtual_rect.right - virtual_rect.left, virtual_rect.bottom - virtual_rect.top,
-                            SWP_NOZORDER | SWP_NOACTIVATE | SWP_DEFERERASE );
+        SetWindowPos( hwnd, 0, virtual_rect.left, virtual_rect.top,
+                      virtual_rect.right - virtual_rect.left, virtual_rect.bottom - virtual_rect.top,
+                      SWP_NOZORDER | SWP_NOACTIVATE | SWP_DEFERERASE );
         ungrab_clipping_window();
 
         if (send_display_change)
         {
-            send_message_timeout( HWND_BROADCAST, WM_DISPLAYCHANGE, screen_bpp, MAKELPARAM( width, height ),
-                                  SMTO_ABORTIFHUNG, 2000, NULL );
+            SendMessageTimeoutW( HWND_BROADCAST, WM_DISPLAYCHANGE, screen_bpp, MAKELPARAM( width, height ),
+                                 SMTO_ABORTIFHUNG, 2000, NULL );
         }
     }
 }
diff --git a/dlls/winex11.drv/display.c b/dlls/winex11.drv/display.c
index 510cb9dcee6..ab5dcdac23f 100644
--- a/dlls/winex11.drv/display.c
+++ b/dlls/winex11.drv/display.c
@@ -18,10 +18,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 #include "x11drv.h"
 #include "wine/debug.h"
@@ -33,26 +29,22 @@ struct x11drv_display_device_handler desktop_handler;
 
 HANDLE get_display_device_init_mutex(void)
 {
-    static const WCHAR init_mutexW[] = {'d','i','s','p','l','a','y','_','d','e','v','i','c','e','_','i','n','i','t'};
-    UNICODE_STRING name = { sizeof(init_mutexW), sizeof(init_mutexW), (WCHAR *)init_mutexW };
-    OBJECT_ATTRIBUTES attr;
-    HANDLE mutex = 0;
-
-    InitializeObjectAttributes( &attr, &name, OBJ_OPENIF, NULL, NULL );
-    NtCreateMutant( &mutex, MUTEX_ALL_ACCESS, &attr, FALSE );
-    if (mutex) NtWaitForSingleObject( mutex, FALSE, NULL );
+    static const WCHAR init_mutexW[] = {'d','i','s','p','l','a','y','_','d','e','v','i','c','e','_','i','n','i','t',0};
+    HANDLE mutex = CreateMutexW(NULL, FALSE, init_mutexW);
+
+    WaitForSingleObject(mutex, INFINITE);
     return mutex;
 }
 
 void release_display_device_init_mutex(HANDLE mutex)
 {
-    NtReleaseMutant( mutex, NULL );
-    NtClose( mutex );
+    ReleaseMutex(mutex);
+    CloseHandle(mutex);
 }
 
 POINT virtual_screen_to_root(INT x, INT y)
 {
-    RECT virtual = NtUserGetVirtualScreenRect();
+    RECT virtual = get_virtual_screen_rect();
     POINT pt;
 
     pt.x = x - virtual.left;
@@ -62,7 +54,7 @@ POINT virtual_screen_to_root(INT x, INT y)
 
 POINT root_to_virtual_screen(INT x, INT y)
 {
-    RECT virtual = NtUserGetVirtualScreenRect();
+    RECT virtual = get_virtual_screen_rect();
     POINT pt;
 
     pt.x = x + virtual.left;
@@ -70,6 +62,20 @@ POINT root_to_virtual_screen(INT x, INT y)
     return pt;
 }
 
+RECT get_virtual_screen_rect(void)
+{
+    RECT virtual;
+    NtUserCallOneParam( (UINT_PTR)&virtual, NtUserGetVirtualScreenRect );
+    return virtual;
+}
+
+RECT get_primary_monitor_rect(void)
+{
+    RECT primary;
+    NtUserCallOneParam( (UINT_PTR)&primary, NtUserGetPrimaryMonitorRect );
+    return primary;
+}
+
 /* Get the primary monitor rect from the host system */
 RECT get_host_primary_monitor_rect(void)
 {
@@ -128,7 +134,7 @@ RECT get_work_area(const RECT *monitor_rect)
                 work_rect.right = work_rect.left + work_area[i * 4 + 2];
                 work_rect.bottom = work_rect.top + work_area[i * 4 + 3];
 
-                if (intersect_rect( &work_rect, &work_rect, monitor_rect ))
+                if (IntersectRect(&work_rect, &work_rect, monitor_rect))
                 {
                     TRACE("work_rect:%s.\n", wine_dbgstr_rect(&work_rect));
                     XFree(work_area);
@@ -150,7 +156,7 @@ RECT get_work_area(const RECT *monitor_rect)
             SetRect(&work_rect, work_area[0], work_area[1], work_area[0] + work_area[2],
                     work_area[1] + work_area[3]);
 
-            if (intersect_rect( &work_rect, &work_rect, monitor_rect ))
+            if (IntersectRect(&work_rect, &work_rect, monitor_rect))
             {
                 TRACE("work_rect:%s.\n", wine_dbgstr_rect(&work_rect));
                 XFree(work_area);
@@ -182,17 +188,39 @@ void X11DRV_DisplayDevices_RegisterEventHandlers(void)
         handler->register_event_handlers();
 }
 
+static BOOL CALLBACK update_windows_on_display_change(HWND hwnd, LPARAM lparam)
+{
+    struct x11drv_win_data *data;
+    UINT mask = (UINT)lparam;
+
+    if (!(data = get_win_data(hwnd)))
+        return TRUE;
+
+    /* update the full screen state */
+    update_net_wm_states(data);
+
+    if (mask && data->whole_window)
+    {
+        POINT pos = virtual_screen_to_root(data->whole_rect.left, data->whole_rect.top);
+        XWindowChanges changes;
+        changes.x = pos.x;
+        changes.y = pos.y;
+        XReconfigureWMWindow(data->display, data->whole_window, data->vis.screen, mask, &changes);
+    }
+    release_win_data(data);
+    return TRUE;
+}
+
 void X11DRV_DisplayDevices_Update(BOOL send_display_change)
 {
     RECT old_virtual_rect, new_virtual_rect;
     DWORD tid, pid;
     HWND foreground;
-    UINT mask = 0, i;
-    HWND *list;
+    UINT mask = 0;
 
-    old_virtual_rect = NtUserGetVirtualScreenRect();
+    old_virtual_rect = get_virtual_screen_rect();
     X11DRV_DisplayDevices_Init(TRUE);
-    new_virtual_rect = NtUserGetVirtualScreenRect();
+    new_virtual_rect = get_virtual_screen_rect();
 
     /* Calculate XReconfigureWMWindow() mask */
     if (old_virtual_rect.left != new_virtual_rect.left)
@@ -201,43 +229,20 @@ void X11DRV_DisplayDevices_Update(BOOL send_display_change)
         mask |= CWY;
 
     X11DRV_resize_desktop(send_display_change);
-
-    list = build_hwnd_list();
-    for (i = 0; list && list[i] != HWND_BOTTOM; i++)
-    {
-        struct x11drv_win_data *data;
-
-        if (!(data = get_win_data( list[i] ))) continue;
-
-        /* update the full screen state */
-        update_net_wm_states(data);
-
-        if (mask && data->whole_window)
-        {
-            POINT pos = virtual_screen_to_root(data->whole_rect.left, data->whole_rect.top);
-            XWindowChanges changes;
-            changes.x = pos.x;
-            changes.y = pos.y;
-            XReconfigureWMWindow(data->display, data->whole_window, data->vis.screen, mask, &changes);
-        }
-        release_win_data(data);
-    }
-
-    free( list );
+    EnumWindows(update_windows_on_display_change, (LPARAM)mask);
 
     /* forward clip_fullscreen_window request to the foreground window */
-    if ((foreground = NtUserGetForegroundWindow()) &&
-        (tid = NtUserGetWindowThread( foreground, &pid )) && pid == GetCurrentProcessId())
+    if ((foreground = GetForegroundWindow()) && (tid = GetWindowThreadProcessId( foreground, &pid )) && pid == GetCurrentProcessId())
     {
         if (tid == GetCurrentThreadId()) clip_fullscreen_window( foreground, TRUE );
-        else send_notify_message( foreground, WM_X11DRV_CLIP_CURSOR_REQUEST, TRUE, TRUE );
+        else SendNotifyMessageW( foreground, WM_X11DRV_CLIP_CURSOR_REQUEST, TRUE, TRUE );
     }
 }
 
 static BOOL force_display_devices_refresh;
 
-void X11DRV_UpdateDisplayDevices( const struct gdi_device_manager *device_manager,
-                                  BOOL force, void *param )
+void CDECL X11DRV_UpdateDisplayDevices( const struct gdi_device_manager *device_manager,
+                                        BOOL force, void *param )
 {
     struct x11drv_display_device_handler *handler;
     struct gdi_adapter *adapters;
diff --git a/dlls/winex11.drv/dllmain.c b/dlls/winex11.drv/dllmain.c
deleted file mode 100644
index e2cbd51351d..00000000000
--- a/dlls/winex11.drv/dllmain.c
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * winex11.drv entry points
- *
- * Copyright 2022 Jacek Caban for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include "x11drv_dll.h"
-#include "wine/debug.h"
-
-
-HMODULE x11drv_module = 0;
-static unixlib_handle_t x11drv_handle;
-NTSTATUS (CDECL *x11drv_unix_call)( enum x11drv_funcs code, void *params );
-
-
-static NTSTATUS x11drv_load_icon( UINT id )
-{
-    return HandleToUlong( LoadIconW( NULL, UlongToPtr( id )));
-}
-
-
-typedef NTSTATUS (*callback_func)( UINT arg );
-static const callback_func callback_funcs[] =
-{
-    x11drv_dnd_drop_event,
-    x11drv_dnd_leave_event,
-    x11drv_ime_get_cursor_pos,
-    x11drv_ime_set_composition_status,
-    x11drv_ime_set_cursor_pos,
-    x11drv_ime_set_open_status,
-    x11drv_ime_update_association,
-    x11drv_load_icon,
-};
-
-C_ASSERT( ARRAYSIZE(callback_funcs) == client_funcs_count );
-
-static NTSTATUS WINAPI x11drv_callback( void *arg, ULONG size )
-{
-    struct client_callback_params *params = arg;
-    return callback_funcs[params->id]( params->arg );
-}
-
-typedef NTSTATUS (WINAPI *kernel_callback)( void *params, ULONG size );
-static const kernel_callback kernel_callbacks[] =
-{
-    x11drv_callback,
-    x11drv_dnd_enter_event,
-    x11drv_dnd_position_event,
-    x11drv_dnd_post_drop,
-    x11drv_ime_set_composition_string,
-    x11drv_ime_set_result,
-    x11drv_systray_change_owner,
-};
-
-C_ASSERT( NtUserDriverCallbackFirst + ARRAYSIZE(kernel_callbacks) == client_func_last );
-
-
-BOOL WINAPI DllMain( HINSTANCE instance, DWORD reason, void *reserved )
-{
-    void **callback_table;
-    struct init_params params =
-    {
-        NtWaitForMultipleObjects,
-        foreign_window_proc,
-    };
-
-    if (reason != DLL_PROCESS_ATTACH) return TRUE;
-
-    DisableThreadLibraryCalls( instance );
-    x11drv_module = instance;
-    if (NtQueryVirtualMemory( GetCurrentProcess(), instance, MemoryWineUnixFuncs,
-                              &x11drv_handle, sizeof(x11drv_handle), NULL ))
-        return FALSE;
-
-    if (__wine_unix_call( x11drv_handle, unix_init, &params )) return FALSE;
-
-    callback_table = NtCurrentTeb()->Peb->KernelCallbackTable;
-    memcpy( callback_table + NtUserDriverCallbackFirst, kernel_callbacks, sizeof(kernel_callbacks) );
-
-    show_systray = params.show_systray;
-    x11drv_unix_call = params.unix_call;
-    return TRUE;
-}
-
-
-/***********************************************************************
- *           wine_create_desktop (winex11.@)
- */
-BOOL CDECL wine_create_desktop( UINT width, UINT height )
-{
-    struct create_desktop_params params = { .width = width, .height = height };
-    return X11DRV_CALL( create_desktop, &params );
-}
-
-/***********************************************************************
- *           AttachEventQueueToTablet (winex11.@)
- */
-int CDECL X11DRV_AttachEventQueueToTablet( HWND owner )
-{
-    return X11DRV_CALL( tablet_attach_queue, owner );
-}
-
-/***********************************************************************
- *           GetCurrentPacket (winex11.@)
- */
-int CDECL X11DRV_GetCurrentPacket( void *packet )
-{
-    return X11DRV_CALL( tablet_get_packet, packet );
-}
-
-/***********************************************************************
- *           LoadTabletInfo (winex11.@)
- */
-BOOL CDECL X11DRV_LoadTabletInfo( HWND hwnd )
-{
-    return X11DRV_CALL( tablet_load_info, hwnd );
-}
-
-/***********************************************************************
- *          WTInfoW (winex11.@)
- */
-UINT CDECL X11DRV_WTInfoW( UINT category, UINT index, void *output )
-{
-    struct tablet_info_params params;
-    params.category = category;
-    params.index = index;
-    params.output = output;
-    return X11DRV_CALL( tablet_info, &params );
-}
diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index f81d2338faf..170111e9c28 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -19,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <poll.h>
@@ -39,7 +35,13 @@
 #include <stdarg.h>
 #include <string.h>
 
+#include "windef.h"
+#include "winbase.h"
+
 #include "x11drv.h"
+
+/* avoid conflict with field names in included win32 headers */
+#undef Status
 #include "shlobj.h"  /* DROPFILES */
 #include "shellapi.h"
 
@@ -47,7 +49,6 @@
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(event);
-WINE_DECLARE_DEBUG_CHANNEL(xdnd);
 
 extern BOOL ximInComposeMode;
 
@@ -387,7 +388,7 @@ static inline BOOL call_event_handler( Display *display, XEvent *event )
 #endif
     if (XFindContext( display, event->xany.window, winContext, (char **)&hwnd ) != 0)
         hwnd = 0;  /* not for a registered window */
-    if (!hwnd && event->xany.window == root_window) hwnd = NtUserGetDesktopWindow();
+    if (!hwnd && event->xany.window == root_window) hwnd = GetDesktopWindow();
 
     TRACE( "%lu %s for hwnd/window %p/%lx\n",
            event->xany.serial, dbgstr_event( event->type ), hwnd, event->xany.window );
@@ -474,26 +475,26 @@ static BOOL process_events( Display *display, Bool (*filter)(Display*, XEvent*,X
 /***********************************************************************
  *           MsgWaitForMultipleObjectsEx   (X11DRV.@)
  */
-NTSTATUS X11DRV_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                             const LARGE_INTEGER *timeout, DWORD mask, DWORD flags )
+DWORD CDECL X11DRV_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
+                                                DWORD timeout, DWORD mask, DWORD flags )
 {
-    struct x11drv_thread_data *data = x11drv_thread_data();
-    NTSTATUS ret;
+    DWORD ret;
+    struct x11drv_thread_data *data = TlsGetValue( thread_data_tls_index );
 
     if (!data)
     {
-        if (!count && timeout && !timeout->QuadPart) return WAIT_TIMEOUT;
-        return pNtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                          !!(flags & MWMO_ALERTABLE), timeout );
+        if (!count && !timeout) return WAIT_TIMEOUT;
+        return WaitForMultipleObjectsEx( count, handles, flags & MWMO_WAITALL,
+                                         timeout, flags & MWMO_ALERTABLE );
     }
 
     if (data->current_event) mask = 0;  /* don't process nested events */
 
     if (process_events( data->display, filter_event, mask )) ret = count - 1;
-    else if (count || !timeout || timeout->QuadPart)
+    else if (count || timeout)
     {
-        ret = pNtWaitForMultipleObjects( count, handles, !(flags & MWMO_WAITALL),
-                                         !!(flags & MWMO_ALERTABLE), timeout );
+        ret = WaitForMultipleObjectsEx( count, handles, flags & MWMO_WAITALL,
+                                        timeout, flags & MWMO_ALERTABLE );
         if (ret == count - 1) process_events( data->display, filter_event, mask );
     }
     else ret = WAIT_TIMEOUT;
@@ -510,7 +511,7 @@ NTSTATUS X11DRV_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
 DWORD EVENT_x11_time_to_win32_time(Time time)
 {
   static DWORD adjust = 0;
-  DWORD now = NtGetTickCount();
+  DWORD now = GetTickCount();
   DWORD ret;
 
   if (! adjust && time != 0)
@@ -543,15 +544,15 @@ DWORD EVENT_x11_time_to_win32_time(Time time)
  */
 static inline BOOL can_activate_window( HWND hwnd )
 {
-    LONG style = NtUserGetWindowLongW( hwnd, GWL_STYLE );
+    LONG style = GetWindowLongW( hwnd, GWL_STYLE );
     RECT rect;
 
     if (!(style & WS_VISIBLE)) return FALSE;
     if ((style & (WS_POPUP|WS_CHILD)) == WS_CHILD) return FALSE;
     if (style & WS_MINIMIZE) return FALSE;
-    if (NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_NOACTIVATE) return FALSE;
-    if (hwnd == NtUserGetDesktopWindow()) return FALSE;
-    if (NtUserGetWindowRect( hwnd, &rect ) && IsRectEmpty( &rect )) return FALSE;
+    if (GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_NOACTIVATE) return FALSE;
+    if (hwnd == GetDesktopWindow()) return FALSE;
+    if (GetWindowRect( hwnd, &rect ) && IsRectEmpty( &rect )) return FALSE;
     return !(style & WS_DISABLED);
 }
 
@@ -571,7 +572,7 @@ static void set_input_focus( struct x11drv_win_data *data )
     if (EVENT_x11_time_to_win32_time(0))
         /* ICCCM says don't use CurrentTime, so try to use last message time if possible */
         /* FIXME: this is not entirely correct */
-        timestamp = NtUserGetThreadInfo()->message_time - EVENT_x11_time_to_win32_time(0);
+        timestamp = GetMessageTime() - EVENT_x11_time_to_win32_time(0);
     else
         timestamp = CurrentTime;
 
@@ -596,13 +597,13 @@ static void set_focus( Display *display, HWND hwnd, Time time )
     GUITHREADINFO threadinfo;
 
     TRACE( "setting foreground window to %p\n", hwnd );
-    NtUserSetForegroundWindow( hwnd, FALSE );
+    SetForegroundWindow( hwnd );
 
     threadinfo.cbSize = sizeof(threadinfo);
-    NtUserGetGUIThreadInfo( 0, &threadinfo );
+    GetGUIThreadInfo(0, &threadinfo);
     focus = threadinfo.hwndFocus;
     if (!focus) focus = threadinfo.hwndActive;
-    if (focus) focus = NtUserGetAncestor( focus, GA_ROOT );
+    if (focus) focus = GetAncestor( focus, GA_ROOT );
     win = X11DRV_get_whole_window(focus);
 
     if (win)
@@ -618,17 +619,9 @@ static void set_focus( Display *display, HWND hwnd, Time time )
  */
 static void handle_manager_message( HWND hwnd, XClientMessageEvent *event )
 {
-    if (hwnd != NtUserGetDesktopWindow()) return;
-
+    if (hwnd != GetDesktopWindow()) return;
     if (systray_atom && event->data.l[1] == systray_atom)
-    {
-        struct systray_change_owner_params params;
-
-        TRACE( "new owner %lx\n", event->data.l[2] );
-
-        params.event_handle = (UINT_PTR)event;
-        x11drv_client_func( client_func_systray_change_owner, &params, sizeof(params) );
-    }
+        change_systray_owner( event->display, event->data.l[2] );
 }
 
 
@@ -646,11 +639,11 @@ static void handle_wm_protocols( HWND hwnd, XClientMessageEvent *event )
     {
         update_user_time( event_time );
 
-        if (hwnd == NtUserGetDesktopWindow())
+        if (hwnd == GetDesktopWindow())
         {
             /* The desktop window does not have a close button that we can
              * pretend to click. Therefore, we simply send it a close command. */
-            send_message( hwnd, WM_SYSCOMMAND, SC_CLOSE, 0 );
+            SendMessageW(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0);
             return;
         }
 
@@ -658,23 +651,22 @@ static void handle_wm_protocols( HWND hwnd, XClientMessageEvent *event )
          * and we are in managed mode. This is to disallow applications from
          * being closed by the window manager while in a modal state.
          */
-        if (NtUserIsWindowEnabled( hwnd ))
+        if (IsWindowEnabled(hwnd))
         {
             HMENU hSysMenu;
 
-            if (NtUserGetClassLongW( hwnd, GCL_STYLE ) & CS_NOCLOSE) return;
-            hSysMenu = NtUserGetSystemMenu( hwnd, FALSE );
+            if (GetClassLongW(hwnd, GCL_STYLE) & CS_NOCLOSE) return;
+            hSysMenu = GetSystemMenu(hwnd, FALSE);
             if (hSysMenu)
             {
-                UINT state = NtUserThunkedMenuItemInfo( hSysMenu, SC_CLOSE, MF_BYCOMMAND,
-                                                        NtUserGetMenuState, NULL, NULL );
+                UINT state = GetMenuState(hSysMenu, SC_CLOSE, MF_BYCOMMAND);
                 if (state == 0xFFFFFFFF || (state & (MF_DISABLED | MF_GRAYED)))
                     return;
             }
-            if (get_active_window() != hwnd)
+            if (GetActiveWindow() != hwnd)
             {
-                LRESULT ma = send_message( hwnd, WM_MOUSEACTIVATE,
-                                           (WPARAM)NtUserGetAncestor( hwnd, GA_ROOT ),
+                LRESULT ma = SendMessageW( hwnd, WM_MOUSEACTIVATE,
+                                           (WPARAM)GetAncestor( hwnd, GA_ROOT ),
                                            MAKELPARAM( HTCLOSE, WM_NCLBUTTONDOWN ) );
                 switch(ma)
                 {
@@ -685,7 +677,7 @@ static void handle_wm_protocols( HWND hwnd, XClientMessageEvent *event )
                         break;
                     case MA_ACTIVATE:
                     case 0:
-                        NtUserSetActiveWindow( hwnd );
+                        SetActiveWindow(hwnd);
                         break;
                     default:
                         WARN( "unknown WM_MOUSEACTIVATE code %d\n", (int) ma );
@@ -693,7 +685,7 @@ static void handle_wm_protocols( HWND hwnd, XClientMessageEvent *event )
                 }
             }
 
-            NtUserPostMessage( hwnd, WM_SYSCOMMAND, SC_CLOSE, 0 );
+            PostMessageW( hwnd, WM_SYSCOMMAND, SC_CLOSE, 0 );
         }
     }
     else if (protocol == x11drv_atom(WM_TAKE_FOCUS))
@@ -701,15 +693,15 @@ static void handle_wm_protocols( HWND hwnd, XClientMessageEvent *event )
         HWND last_focus = x11drv_thread_data()->last_focus;
 
         TRACE( "got take focus msg for %p, enabled=%d, visible=%d (style %08x), focus=%p, active=%p, fg=%p, last=%p\n",
-               hwnd, NtUserIsWindowEnabled(hwnd), NtUserIsWindowVisible(hwnd), NtUserGetWindowLongW(hwnd, GWL_STYLE),
-               get_focus(), get_active_window(), NtUserGetForegroundWindow(), last_focus );
+               hwnd, IsWindowEnabled(hwnd), IsWindowVisible(hwnd), GetWindowLongW(hwnd, GWL_STYLE),
+               GetFocus(), GetActiveWindow(), GetForegroundWindow(), last_focus );
 
         if (can_activate_window(hwnd))
         {
             /* simulate a mouse click on the menu to find out
              * whether the window wants to be activated */
-            LRESULT ma = send_message( hwnd, WM_MOUSEACTIVATE,
-                                       (WPARAM)NtUserGetAncestor( hwnd, GA_ROOT ),
+            LRESULT ma = SendMessageW( hwnd, WM_MOUSEACTIVATE,
+                                       (WPARAM)GetAncestor( hwnd, GA_ROOT ),
                                        MAKELONG( HTMENU, WM_LBUTTONDOWN ) );
             if (ma != MA_NOACTIVATEANDEAT && ma != MA_NOACTIVATE)
             {
@@ -717,18 +709,18 @@ static void handle_wm_protocols( HWND hwnd, XClientMessageEvent *event )
                 return;
             }
         }
-        else if (hwnd == NtUserGetDesktopWindow())
+        else if (hwnd == GetDesktopWindow())
         {
-            hwnd = NtUserGetForegroundWindow();
+            hwnd = GetForegroundWindow();
             if (!hwnd) hwnd = last_focus;
-            if (!hwnd) hwnd = NtUserGetDesktopWindow();
+            if (!hwnd) hwnd = GetDesktopWindow();
             set_focus( event->display, hwnd, event_time );
             return;
         }
         /* try to find some other window to give the focus to */
-        hwnd = get_focus();
-        if (hwnd) hwnd = NtUserGetAncestor( hwnd, GA_ROOT );
-        if (!hwnd) hwnd = get_active_window();
+        hwnd = GetFocus();
+        if (hwnd) hwnd = GetAncestor( hwnd, GA_ROOT );
+        if (!hwnd) hwnd = GetActiveWindow();
         if (!hwnd) hwnd = last_focus;
         if (hwnd && can_activate_window(hwnd)) set_focus( event->display, hwnd, event_time );
     }
@@ -777,7 +769,7 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
     TRACE( "win %p xwin %lx detail=%s mode=%s\n", hwnd, event->window, focus_details[event->detail], focus_modes[event->mode] );
 
     if (event->detail == NotifyPointer) return FALSE;
-    if (hwnd == NtUserGetDesktopWindow()) return FALSE;
+    if (hwnd == GetDesktopWindow()) return FALSE;
 
     switch (event->mode)
     {
@@ -800,19 +792,19 @@ static BOOL X11DRV_FocusIn( HWND hwnd, XEvent *xev )
     if ((xic = X11DRV_get_ic( hwnd ))) XSetICFocus( xic );
     if (use_take_focus)
     {
-        if (hwnd == NtUserGetForegroundWindow()) clip_fullscreen_window( hwnd, FALSE );
+        if (hwnd == GetForegroundWindow()) clip_fullscreen_window( hwnd, FALSE );
         return TRUE;
     }
 
     if (!can_activate_window(hwnd))
     {
-        HWND hwnd = get_focus();
-        if (hwnd) hwnd = NtUserGetAncestor( hwnd, GA_ROOT );
-        if (!hwnd) hwnd = get_active_window();
+        HWND hwnd = GetFocus();
+        if (hwnd) hwnd = GetAncestor( hwnd, GA_ROOT );
+        if (!hwnd) hwnd = GetActiveWindow();
         if (!hwnd) hwnd = x11drv_thread_data()->last_focus;
         if (hwnd && can_activate_window(hwnd)) set_focus( event->display, hwnd, CurrentTime );
     }
-    else NtUserSetForegroundWindow( hwnd, FALSE );
+    else SetForegroundWindow( hwnd );
     return TRUE;
 }
 
@@ -833,11 +825,11 @@ static void focus_out( Display *display , HWND hwnd )
 
     if (is_virtual_desktop())
     {
-        if (hwnd == NtUserGetDesktopWindow()) reset_clipping_window();
+        if (hwnd == GetDesktopWindow()) reset_clipping_window();
         return;
     }
-    if (hwnd != NtUserGetForegroundWindow()) return;
-    send_message( hwnd, WM_CANCELMODE, 0, 0 );
+    if (hwnd != GetForegroundWindow()) return;
+    SendMessageW( hwnd, WM_CANCELMODE, 0, 0 );
 
     /* don't reset the foreground window, if the window which is
        getting the focus is a Wine window */
@@ -855,10 +847,10 @@ static void focus_out( Display *display , HWND hwnd )
            Foreground window, because in most cases the messages sent
            above must have already changed the foreground window, in which
            case we don't have to change the foreground window to 0 */
-        if (hwnd == NtUserGetForegroundWindow())
+        if (hwnd == GetForegroundWindow())
         {
             TRACE( "lost focus, setting fg to desktop\n" );
-            NtUserSetForegroundWindow( NtUserGetDesktopWindow(), FALSE );
+            SetForegroundWindow( GetDesktopWindow() );
         }
     }
  }
@@ -945,8 +937,8 @@ static BOOL X11DRV_Expose( HWND hwnd, XEvent *xev )
         {
             surface_region = expose_surface( data->surface, &rect );
             if (!surface_region) flags = 0;
-            else NtGdiOffsetRgn( surface_region, data->whole_rect.left - data->client_rect.left,
-                                 data->whole_rect.top - data->client_rect.top );
+            else OffsetRgn( surface_region, data->whole_rect.left - data->client_rect.left,
+                            data->whole_rect.top - data->client_rect.top );
 
             if (data->vis.visualid != default_visual.visualid)
                 data->surface->funcs->flush( data->surface );
@@ -957,10 +949,10 @@ static BOOL X11DRV_Expose( HWND hwnd, XEvent *xev )
 
     if (event->window != root_window)
     {
-        if (NtUserGetWindowLongW( data->hwnd, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL)
+        if (GetWindowLongW( data->hwnd, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL)
             mirror_rect( &data->client_rect, &rect );
         abs_rect = rect;
-        NtUserMapWindowPoints( hwnd, 0, (POINT *)&abs_rect, 2 );
+        MapWindowPoints( hwnd, 0, (POINT *)&abs_rect, 2 );
 
         SERVER_START_REQ( update_window_zorder )
         {
@@ -977,8 +969,8 @@ static BOOL X11DRV_Expose( HWND hwnd, XEvent *xev )
 
     release_win_data( data );
 
-    if (flags) NtUserRedrawWindow( hwnd, &rect, surface_region, flags );
-    if (surface_region) NtGdiDeleteObjectApp( surface_region );
+    if (flags) RedrawWindow( hwnd, &rect, surface_region, flags );
+    if (surface_region) DeleteObject( surface_region );
     return TRUE;
 }
 
@@ -996,8 +988,8 @@ static BOOL X11DRV_MapNotify( HWND hwnd, XEvent *event )
 
     if (!data->managed && !data->embedded && data->mapped)
     {
-        HWND hwndFocus = get_focus();
-        if (hwndFocus && NtUserIsChild( hwnd, hwndFocus ))
+        HWND hwndFocus = GetFocus();
+        if (hwndFocus && IsChild( hwnd, hwndFocus ))
             set_input_focus( data );
     }
     release_win_data( data );
@@ -1022,10 +1014,10 @@ static void reparent_notify( Display *display, HWND hwnd, Window xparent, int x,
     HWND parent, old_parent;
     DWORD style;
 
-    style = NtUserGetWindowLongW( hwnd, GWL_STYLE );
+    style = GetWindowLongW( hwnd, GWL_STYLE );
     if (xparent == root_window)
     {
-        parent = NtUserGetDesktopWindow();
+        parent = GetDesktopWindow();
         style = (style & ~WS_CHILD) | WS_POPUP;
     }
     else
@@ -1034,15 +1026,15 @@ static void reparent_notify( Display *display, HWND hwnd, Window xparent, int x,
         style = (style & ~WS_POPUP) | WS_CHILD;
     }
 
-    NtUserShowWindow( hwnd, SW_HIDE );
-    old_parent = NtUserSetParent( hwnd, parent );
-    NtUserSetWindowLong( hwnd, GWL_STYLE, style, FALSE );
-    NtUserSetWindowPos( hwnd, HWND_TOP, x, y, 0, 0,
-                        SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOCOPYBITS |
-                        ((style & WS_VISIBLE) ? SWP_SHOWWINDOW : 0) );
+    ShowWindow( hwnd, SW_HIDE );
+    old_parent = SetParent( hwnd, parent );
+    SetWindowLongW( hwnd, GWL_STYLE, style );
+    SetWindowPos( hwnd, HWND_TOP, x, y, 0, 0,
+                  SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOCOPYBITS |
+                  ((style & WS_VISIBLE) ? SWP_SHOWWINDOW : 0) );
 
     /* make old parent destroy itself if it no longer has children */
-    if (old_parent != NtUserGetDesktopWindow()) NtUserPostMessage( old_parent, WM_CLOSE, 0, 0 );
+    if (old_parent != GetDesktopWindow()) PostMessageW( old_parent, WM_CLOSE, 0, 0 );
 }
 
 
@@ -1069,7 +1061,7 @@ static BOOL X11DRV_ReparentNotify( HWND hwnd, XEvent *xev )
             TRACE( "%p/%lx reparented to root\n", hwnd, data->whole_window );
             data->embedder = 0;
             release_win_data( data );
-            send_message( hwnd, WM_CLOSE, 0, 0 );
+            SendMessageW( hwnd, WM_CLOSE, 0, 0 );
             return TRUE;
         }
         data->embedder = event->parent;
@@ -1114,10 +1106,10 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )
 
     /* Get geometry */
 
-    parent = NtUserGetAncestor( hwnd, GA_PARENT );
+    parent = GetAncestor( hwnd, GA_PARENT );
     root_coords = event->send_event;  /* synthetic events are always in root coords */
 
-    if (!root_coords && parent == NtUserGetDesktopWindow()) /* normal event, map coordinates to the root */
+    if (!root_coords && parent == GetDesktopWindow()) /* normal event, map coordinates to the root */
     {
         Window child;
         XTranslateCoordinates( event->display, event->window, root_window,
@@ -1133,7 +1125,7 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )
     else pos = root_to_virtual_screen( x, y );
 
     X11DRV_X_to_window_rect( data, &rect, pos.x, pos.y, event->width, event->height );
-    if (root_coords) NtUserMapWindowPoints( 0, parent, (POINT *)&rect, 2 );
+    if (root_coords) MapWindowPoints( 0, parent, (POINT *)&rect, 2 );
 
     TRACE( "win %p/%lx new X rect %d,%d,%dx%d (event %d,%d,%dx%d)\n",
            hwnd, data->whole_window, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top,
@@ -1163,8 +1155,8 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )
                hwnd, data->window_rect.right - data->window_rect.left,
                data->window_rect.bottom - data->window_rect.top, cx, cy );
 
-    style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE );
-    if ((style & WS_CAPTION) == WS_CAPTION || !NtUserIsWindowRectFullScreen( &data->whole_rect ))
+    style = GetWindowLongW( data->hwnd, GWL_STYLE );
+    if ((style & WS_CAPTION) == WS_CAPTION || !is_window_rect_full_screen( &data->whole_rect ))
     {
         read_net_wm_states( event->display, data );
         if ((data->net_wm_state & (1 << NET_WM_STATE_MAXIMIZED)))
@@ -1173,7 +1165,7 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )
             {
                 TRACE( "win %p/%lx is maximized\n", data->hwnd, data->whole_window );
                 release_win_data( data );
-                send_message( data->hwnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0 );
+                SendMessageW( data->hwnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0 );
                 return TRUE;
             }
         }
@@ -1181,7 +1173,7 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )
         {
             TRACE( "window %p/%lx is no longer maximized\n", data->hwnd, data->whole_window );
             release_win_data( data );
-            send_message( data->hwnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
+            SendMessageW( data->hwnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
             return TRUE;
         }
     }
@@ -1189,7 +1181,7 @@ static BOOL X11DRV_ConfigureNotify( HWND hwnd, XEvent *xev )
     if ((flags & (SWP_NOSIZE | SWP_NOMOVE)) != (SWP_NOSIZE | SWP_NOMOVE))
     {
         release_win_data( data );
-        NtUserSetWindowPos( hwnd, 0, x, y, cx, cy, flags );
+        SetWindowPos( hwnd, 0, x, y, cx, cy, flags );
         return TRUE;
     }
 
@@ -1227,7 +1219,7 @@ static BOOL X11DRV_GravityNotify( HWND hwnd, XEvent *xev )
     release_win_data( data );
 
     if (window_rect.left != x || window_rect.top != y)
-        NtUserSetWindowPos( hwnd, 0, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS );
+        SetWindowPos( hwnd, 0, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS );
 
     return TRUE;
 }
@@ -1296,7 +1288,7 @@ static void handle_wm_state_notify( HWND hwnd, XPropertyEvent *event, BOOL updat
 
     if (!update_window || !data->managed || !data->mapped) goto done;
 
-    style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE );
+    style = GetWindowLongW( data->hwnd, GWL_STYLE );
 
     if (data->iconic && data->wm_state == NormalState)  /* restore window */
     {
@@ -1308,7 +1300,7 @@ static void handle_wm_state_notify( HWND hwnd, XPropertyEvent *event, BOOL updat
             {
                 TRACE( "restoring to max %p/%lx\n", data->hwnd, data->whole_window );
                 release_win_data( data );
-                send_message( hwnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0 );
+                SendMessageW( hwnd, WM_SYSCOMMAND, SC_MAXIMIZE, 0 );
                 return;
             }
             TRACE( "not restoring to max win %p/%lx style %08x\n", data->hwnd, data->whole_window, style );
@@ -1320,8 +1312,8 @@ static void handle_wm_state_notify( HWND hwnd, XPropertyEvent *event, BOOL updat
                 TRACE( "restoring win %p/%lx\n", data->hwnd, data->whole_window );
                 release_win_data( data );
                 if ((style & (WS_MINIMIZE | WS_VISIBLE)) == (WS_MINIMIZE | WS_VISIBLE))
-                    NtUserSetActiveWindow( hwnd );
-                send_message( hwnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
+                    SetActiveWindow( hwnd );
+                SendMessageW( hwnd, WM_SYSCOMMAND, SC_RESTORE, 0 );
                 return;
             }
             TRACE( "not restoring win %p/%lx style %08x\n", data->hwnd, data->whole_window, style );
@@ -1334,7 +1326,7 @@ static void handle_wm_state_notify( HWND hwnd, XPropertyEvent *event, BOOL updat
         {
             TRACE( "minimizing win %p/%lx\n", data->hwnd, data->whole_window );
             release_win_data( data );
-            send_message( hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0 );
+            SendMessageW( hwnd, WM_SYSCOMMAND, SC_MINIMIZE, 0 );
             return;
         }
         TRACE( "not minimizing win %p/%lx style %08x\n", data->hwnd, data->whole_window, style );
@@ -1372,7 +1364,7 @@ void wait_for_withdrawn_state( HWND hwnd, BOOL set )
 {
     Display *display = thread_display();
     struct x11drv_win_data *data;
-    DWORD end = NtGetTickCount() + 2000;
+    DWORD end = GetTickCount() + 2000;
 
     TRACE( "waiting for window %p to become %swithdrawn\n", hwnd, set ? "" : "not " );
 
@@ -1408,7 +1400,7 @@ void wait_for_withdrawn_state( HWND hwnd, BOOL set )
         if (!count)
         {
             struct pollfd pfd;
-            int timeout = end - NtGetTickCount();
+            int timeout = end - GetTickCount();
 
             pfd.fd = ConnectionNumber(display);
             pfd.events = POLLIN;
@@ -1428,7 +1420,7 @@ void wait_for_withdrawn_state( HWND hwnd, BOOL set )
  *
  * Set the X focus.
  */
-void X11DRV_SetFocus( HWND hwnd )
+void CDECL X11DRV_SetFocus( HWND hwnd )
 {
     struct x11drv_win_data *data;
 
@@ -1438,8 +1430,8 @@ void X11DRV_SetFocus( HWND hwnd )
     {
         if (!(data = get_win_data( hwnd ))) return;
         if (data->embedded) break;
-        parent = NtUserGetAncestor( hwnd, GA_PARENT );
-        if (!parent || parent == NtUserGetDesktopWindow()) break;
+        parent = GetAncestor( hwnd, GA_PARENT );
+        if (!parent || parent == GetDesktopWindow()) break;
         release_win_data( data );
         hwnd = parent;
     }
@@ -1452,22 +1444,21 @@ static HWND find_drop_window( HWND hQueryWnd, LPPOINT lpPt )
 {
     RECT tempRect;
 
-    if (!NtUserIsWindowEnabled(hQueryWnd)) return 0;
+    if (!IsWindowEnabled(hQueryWnd)) return 0;
     
-    NtUserGetWindowRect(hQueryWnd, &tempRect);
+    GetWindowRect(hQueryWnd, &tempRect);
 
     if(!PtInRect(&tempRect, *lpPt)) return 0;
 
-    if (!(NtUserGetWindowLongW( hQueryWnd, GWL_STYLE ) & WS_MINIMIZE))
+    if (!IsIconic( hQueryWnd ))
     {
         POINT pt = *lpPt;
-        NtUserScreenToClient( hQueryWnd, &pt );
-        NtUserGetClientRect( hQueryWnd, &tempRect );
+        ScreenToClient( hQueryWnd, &pt );
+        GetClientRect( hQueryWnd, &tempRect );
 
         if (PtInRect( &tempRect, pt))
         {
-            HWND ret = NtUserChildWindowFromPointEx( hQueryWnd, pt.x, pt.y,
-                                                     CWP_SKIPINVISIBLE|CWP_SKIPDISABLED );
+            HWND ret = ChildWindowFromPointEx( hQueryWnd, pt, CWP_SKIPINVISIBLE|CWP_SKIPDISABLED );
             if (ret && ret != hQueryWnd)
             {
                 ret = find_drop_window( ret, lpPt );
@@ -1476,19 +1467,13 @@ static HWND find_drop_window( HWND hQueryWnd, LPPOINT lpPt )
         }
     }
 
-    if(!(NtUserGetWindowLongW( hQueryWnd, GWL_EXSTYLE ) & WS_EX_ACCEPTFILES)) return 0;
+    if(!(GetWindowLongA( hQueryWnd, GWL_EXSTYLE ) & WS_EX_ACCEPTFILES)) return 0;
     
-    NtUserScreenToClient( hQueryWnd, lpPt );
+    ScreenToClient(hQueryWnd, lpPt);
 
     return hQueryWnd;
 }
 
-static void post_drop( HWND hwnd, DROPFILES *drop, ULONG size )
-{
-    drop->fWide = HandleToUlong( hwnd ); /* abuse fWide to pass window handle */
-    x11drv_client_func( client_func_dnd_post_drop, drop, size );
-}
-
 /**********************************************************************
  *           EVENT_DropFromOffix
  *
@@ -1502,7 +1487,7 @@ static void EVENT_DropFromOffiX( HWND hWnd, XClientMessageEvent *event )
     unsigned long	aux_long;
     unsigned char*	p_data = NULL;
     Atom atom_aux;
-    int x, y, cx, cy, dummy, format;
+    int			x, y, cx, cy, dummy;
     Window		win, w_aux_root, w_aux_child;
 
     if (!(data = get_win_data( hWnd ))) return;
@@ -1518,7 +1503,7 @@ static void EVENT_DropFromOffiX( HWND hWnd, XClientMessageEvent *event )
     /* find out drop point and drop window */
     if (pt.x < 0 || pt.y < 0 || pt.x > cx || pt.y > cy)
     {
-	if (!(NtUserGetWindowLongW( hWnd, GWL_EXSTYLE ) & WS_EX_ACCEPTFILES)) return;
+	if (!(GetWindowLongW( hWnd, GWL_EXSTYLE ) & WS_EX_ACCEPTFILES)) return;
 	pt.x = pt.y = 0;
     }
     else
@@ -1528,23 +1513,50 @@ static void EVENT_DropFromOffiX( HWND hWnd, XClientMessageEvent *event )
 
     XGetWindowProperty( event->display, DefaultRootWindow(event->display),
                         x11drv_atom(DndSelection), 0, 65535, FALSE,
-                        AnyPropertyType, &atom_aux, &format,
+                        AnyPropertyType, &atom_aux, &dummy,
                         &data_length, &aux_long, &p_data);
 
-    if (!aux_long && p_data)  /* don't bother if > 64K */
+    if( !aux_long && p_data)  /* don't bother if > 64K */
     {
-        DROPFILES *drop;
-        size_t drop_size;
+        char *p = (char *)p_data;
+        char *p_drop;
 
-        drop = file_list_to_drop_files( p_data, get_property_size( format, data_length ), &drop_size );
-        if (drop)
+        aux_long = 0;
+        while( *p )  /* calculate buffer size */
         {
-            post_drop( hWnd, drop, drop_size );
-            free( drop );
+            INT len = GetShortPathNameA( p, NULL, 0 );
+            if (len) aux_long += len + 1;
+            p += strlen(p) + 1;
         }
-    }
+        if( aux_long && aux_long < 65535 )
+        {
+            HDROP                 hDrop;
+            DROPFILES *lpDrop;
+
+            aux_long += sizeof(DROPFILES) + 1;
+            hDrop = GlobalAlloc( GMEM_SHARE, aux_long );
+            lpDrop = GlobalLock( hDrop );
 
-    if (p_data) XFree(p_data);
+            if( lpDrop )
+            {
+                lpDrop->pFiles = sizeof(DROPFILES);
+                lpDrop->pt = pt;
+                lpDrop->fNC = FALSE;
+                lpDrop->fWide = FALSE;
+                p_drop = (char *)(lpDrop + 1);
+                p = (char *)p_data;
+                while(*p)
+                {
+                    if (GetShortPathNameA( p, p_drop, aux_long - (p_drop - (char *)lpDrop) ))
+                        p_drop += strlen( p_drop ) + 1;
+                    p += strlen(p) + 1;
+                }
+                *p_drop = '\0';
+                PostMessageA( hWnd, WM_DROPFILES, (WPARAM)hDrop, 0L );
+            }
+        }
+    }
+    if( p_data ) XFree(p_data);
 }
 
 /**********************************************************************
@@ -1559,11 +1571,14 @@ static void EVENT_DropURLs( HWND hWnd, XClientMessageEvent *event )
 {
   struct x11drv_win_data *win_data;
   unsigned long	data_length;
-  unsigned long	aux_long;
+  unsigned long	aux_long, drop_len = 0;
   unsigned char	*p_data = NULL; /* property data */
+  char		*p_drop = NULL;
+  char          *p, *next;
   int		x, y;
-  DROPFILES *drop;
-  int format;
+  POINT pos;
+  DROPFILES *lpDrop;
+  HDROP hDrop;
   union {
     Atom	atom_aux;
     int         i;
@@ -1571,42 +1586,91 @@ static void EVENT_DropURLs( HWND hWnd, XClientMessageEvent *event )
     unsigned int u;
   }		u; /* unused */
 
-  if (!(NtUserGetWindowLongW( hWnd, GWL_EXSTYLE ) & WS_EX_ACCEPTFILES)) return;
+  if (!(GetWindowLongW( hWnd, GWL_EXSTYLE ) & WS_EX_ACCEPTFILES)) return;
 
   XGetWindowProperty( event->display, DefaultRootWindow(event->display),
                       x11drv_atom(DndSelection), 0, 65535, FALSE,
-                      AnyPropertyType, &u.atom_aux, &format,
+                      AnyPropertyType, &u.atom_aux, &u.i,
                       &data_length, &aux_long, &p_data);
   if (aux_long)
     WARN("property too large, truncated!\n");
   TRACE("urls=%s\n", p_data);
 
-  if (!aux_long && p_data) /* don't bother if > 64K */
-  {
-      size_t drop_size;
-      drop = uri_list_to_drop_files( p_data, get_property_size( format, data_length ), &drop_size );
+  if( !aux_long && p_data) {	/* don't bother if > 64K */
+    /* calculate length */
+    p = (char*) p_data;
+    next = strchr(p, '\n');
+    while (p) {
+      if (next) *next=0;
+      if (strncmp(p,"file:",5) == 0 ) {
+	INT len = GetShortPathNameA( p+5, NULL, 0 );
+	if (len) drop_len += len + 1;
+      }
+      if (next) {
+	*next = '\n';
+	p = next + 1;
+	next = strchr(p, '\n');
+      } else {
+	p = NULL;
+      }
+    }
 
-      if (drop)
+    if( drop_len && drop_len < 65535 ) {
+      XQueryPointer( event->display, root_window, &u.w_aux, &u.w_aux,
+                     &x, &y, &u.i, &u.i, &u.u);
+      pos = root_to_virtual_screen( x, y );
+
+      drop_len += sizeof(DROPFILES) + 1;
+      hDrop = GlobalAlloc( GMEM_SHARE, drop_len );
+      lpDrop = GlobalLock( hDrop );
+
+      if( lpDrop && (win_data = get_win_data( hWnd )))
       {
-          XQueryPointer( event->display, root_window, &u.w_aux, &u.w_aux,
-                         &x, &y, &u.i, &u.i, &u.u);
-          drop->pt = root_to_virtual_screen( x, y );
-
-          if ((win_data = get_win_data( hWnd )))
-          {
-              drop->fNC =
-                  (drop->pt.x < (win_data->client_rect.left - win_data->whole_rect.left)  ||
-                   drop->pt.y < (win_data->client_rect.top - win_data->whole_rect.top)    ||
-                   drop->pt.x > (win_data->client_rect.right - win_data->whole_rect.left) ||
-                   drop->pt.y > (win_data->client_rect.bottom - win_data->whole_rect.top) );
-              release_win_data( win_data );
-          }
-
-          post_drop( hWnd, drop, drop_size );
-          free( drop );
+	  lpDrop->pFiles = sizeof(DROPFILES);
+	  lpDrop->pt = pos;
+	  lpDrop->fNC =
+	    (pos.x < (win_data->client_rect.left - win_data->whole_rect.left)  ||
+	     pos.y < (win_data->client_rect.top - win_data->whole_rect.top)    ||
+	     pos.x > (win_data->client_rect.right - win_data->whole_rect.left) ||
+	     pos.y > (win_data->client_rect.bottom - win_data->whole_rect.top) );
+	  lpDrop->fWide = FALSE;
+	  p_drop = (char*)(lpDrop + 1);
+          release_win_data( win_data );
       }
+
+      /* create message content */
+      if (p_drop) {
+	p = (char*) p_data;
+	next = strchr(p, '\n');
+	while (p) {
+	  if (next) *next=0;
+	  if (strncmp(p,"file:",5) == 0 ) {
+	    INT len = GetShortPathNameA( p+5, p_drop, 65535 );
+	    if (len) {
+	      TRACE("drop file %s as %s\n", p+5, p_drop);
+	      p_drop += len+1;
+	    } else {
+	      WARN("can't convert file %s to dos name\n", p+5);
+	    }
+	  } else {
+	    WARN("unknown mime type %s\n", p);
+	  }
+	  if (next) {
+	    *next = '\n';
+	    p = next + 1;
+	    next = strchr(p, '\n');
+	  } else {
+	    p = NULL;
+	  }
+	  *p_drop = '\0';
+	}
+
+        GlobalUnlock(hDrop);
+        PostMessageA( hWnd, WM_DROPFILES, (WPARAM)hDrop, 0L );
+      }
+    }
   }
-  if (p_data) XFree( p_data );
+  if( p_data ) XFree(p_data);
 }
 
 
@@ -1640,22 +1704,22 @@ static void handle_xembed_protocol( HWND hwnd, XClientMessageEvent *event )
 
     case XEMBED_WINDOW_DEACTIVATE:
         TRACE( "win %p/%lx XEMBED_WINDOW_DEACTIVATE message\n", hwnd, event->window );
-        focus_out( event->display, NtUserGetAncestor( hwnd, GA_ROOT ) );
+        focus_out( event->display, GetAncestor( hwnd, GA_ROOT ) );
         break;
 
     case XEMBED_FOCUS_OUT:
         TRACE( "win %p/%lx XEMBED_FOCUS_OUT message\n", hwnd, event->window );
-        focus_out( event->display, NtUserGetAncestor( hwnd, GA_ROOT ) );
+        focus_out( event->display, GetAncestor( hwnd, GA_ROOT ) );
         break;
 
     case XEMBED_MODALITY_ON:
         TRACE( "win %p/%lx XEMBED_MODALITY_ON message\n", hwnd, event->window );
-        NtUserEnableWindow( hwnd, FALSE );
+        EnableWindow( hwnd, FALSE );
         break;
 
     case XEMBED_MODALITY_OFF:
         TRACE( "win %p/%lx XEMBED_MODALITY_OFF message\n", hwnd, event->window );
-        NtUserEnableWindow( hwnd, TRUE );
+        EnableWindow( hwnd, TRUE );
         break;
 
     default:
@@ -1687,175 +1751,6 @@ static void handle_dnd_protocol( HWND hwnd, XClientMessageEvent *event )
 }
 
 
-/**************************************************************************
- *           handle_xdnd_enter_event
- *
- * Handle an XdndEnter event.
- */
-static void handle_xdnd_enter_event( HWND hWnd, XClientMessageEvent *event )
-{
-    struct format_entry *data;
-    unsigned long count = 0;
-    Atom *xdndtypes;
-    size_t size;
-    int version;
-
-    version = (event->data.l[1] & 0xFF000000) >> 24;
-
-    TRACE( "ver(%d) check-XdndTypeList(%ld) data=%ld,%ld,%ld,%ld,%ld\n",
-           version, (event->data.l[1] & 1),
-           event->data.l[0], event->data.l[1], event->data.l[2],
-           event->data.l[3], event->data.l[4] );
-
-    if (version > WINE_XDND_VERSION)
-    {
-        ERR("ignoring unsupported XDND version %d\n", version);
-        return;
-    }
-
-    /* If the source supports more than 3 data types we retrieve
-     * the entire list. */
-    if (event->data.l[1] & 1)
-    {
-        Atom acttype;
-        int actfmt;
-        unsigned long bytesret;
-
-        /* Request supported formats from source window */
-        XGetWindowProperty( event->display, event->data.l[0], x11drv_atom(XdndTypeList),
-                            0, 65535, FALSE, AnyPropertyType, &acttype, &actfmt, &count,
-                            &bytesret, (unsigned char **)&xdndtypes );
-    }
-    else
-    {
-        count = 3;
-        xdndtypes = (Atom *)&event->data.l[2];
-    }
-
-    if (TRACE_ON(xdnd))
-    {
-        unsigned int i;
-
-        for (i = 0; i < count; i++)
-        {
-            if (xdndtypes[i] != 0)
-            {
-                char * pn = XGetAtomName( event->display, xdndtypes[i] );
-                TRACE( "XDNDEnterAtom %ld: %s\n", xdndtypes[i], pn );
-                XFree( pn );
-            }
-        }
-    }
-
-    data = import_xdnd_selection( event->display, event->window, x11drv_atom(XdndSelection),
-                                  xdndtypes, count, &size );
-    if (data)
-    {
-        x11drv_client_func( client_func_dnd_enter_event, data, size );
-        free( data );
-    }
-
-    if (event->data.l[1] & 1)
-        XFree(xdndtypes);
-}
-
-
-static DWORD xdnd_action_to_drop_effect( long action )
-{
-    /* In Windows, nothing but the given effects is allowed.
-     * In X the given action is just a hint, and you can always
-     * XdndActionCopy and XdndActionPrivate, so be more permissive. */
-    if (action == x11drv_atom(XdndActionCopy))
-        return DROPEFFECT_COPY;
-    else if (action == x11drv_atom(XdndActionMove))
-        return DROPEFFECT_MOVE | DROPEFFECT_COPY;
-    else if (action == x11drv_atom(XdndActionLink))
-        return DROPEFFECT_LINK | DROPEFFECT_COPY;
-    else if (action == x11drv_atom(XdndActionAsk))
-        /* FIXME: should we somehow ask the user what to do here? */
-        return DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK;
-
-    FIXME( "unknown action %ld, assuming DROPEFFECT_COPY\n", action );
-    return DROPEFFECT_COPY;
-}
-
-
-static long drop_effect_to_xdnd_action( DWORD effect )
-{
-    if (effect == DROPEFFECT_COPY)
-        return x11drv_atom(XdndActionCopy);
-    else if (effect == DROPEFFECT_MOVE)
-        return x11drv_atom(XdndActionMove);
-    else if (effect == DROPEFFECT_LINK)
-        return x11drv_atom(XdndActionLink);
-    else if (effect == DROPEFFECT_NONE)
-        return None;
-
-    FIXME( "unknown drop effect %u, assuming XdndActionCopy\n", effect );
-    return x11drv_atom(XdndActionCopy);
-}
-
-
-static void handle_xdnd_position_event( HWND hwnd, XClientMessageEvent *event )
-{
-    struct dnd_position_event_params params;
-    XClientMessageEvent e;
-    DWORD effect;
-
-    params.hwnd = hwnd;
-    params.point = root_to_virtual_screen( event->data.l[2] >> 16, event->data.l[2] & 0xFFFF );
-    params.effect = effect = xdnd_action_to_drop_effect( event->data.l[4] );
-
-    effect = x11drv_client_func( client_func_dnd_position_event, &params, sizeof(params) );
-
-    TRACE( "actionRequested(%ld) chosen(0x%x) at x(%d),y(%d)\n",
-           event->data.l[4], effect, params.point.x, params.point.y );
-
-    /*
-     * Let source know if we're accepting the drop by
-     * sending a status message.
-     */
-    e.type = ClientMessage;
-    e.display = event->display;
-    e.window = event->data.l[0];
-    e.message_type = x11drv_atom(XdndStatus);
-    e.format = 32;
-    e.data.l[0] = event->window;
-    e.data.l[1] = !!effect;
-    e.data.l[2] = 0; /* Empty Rect */
-    e.data.l[3] = 0; /* Empty Rect */
-    e.data.l[4] = drop_effect_to_xdnd_action( effect );
-    XSendEvent( event->display, event->data.l[0], False, NoEventMask, (XEvent *)&e );
-}
-
-
-static void handle_xdnd_drop_event( HWND hwnd, XClientMessageEvent *event )
-{
-    XClientMessageEvent e;
-    DWORD effect;
-
-    effect = x11drv_client_call( client_dnd_drop_event, HandleToUlong( hwnd ));
-
-    /* Tell the target we are finished. */
-    memset( &e, 0, sizeof(e) );
-    e.type = ClientMessage;
-    e.display = event->display;
-    e.window = event->data.l[0];
-    e.message_type = x11drv_atom(XdndFinished);
-    e.format = 32;
-    e.data.l[0] = event->window;
-    e.data.l[1] = !!effect;
-    e.data.l[2] = drop_effect_to_xdnd_action( effect );
-    XSendEvent( event->display, event->data.l[0], False, NoEventMask, (XEvent *)&e );
-}
-
-
-static void handle_xdnd_leave_event( HWND hwnd, XClientMessageEvent *event )
-{
-    x11drv_client_call( client_dnd_leave_event, 0 );
-}
-
-
 struct client_message_handler
 {
     int    atom;                                  /* protocol atom */
@@ -1868,10 +1763,10 @@ static const struct client_message_handler client_messages[] =
     { XATOM_WM_PROTOCOLS, handle_wm_protocols },
     { XATOM__XEMBED,      handle_xembed_protocol },
     { XATOM_DndProtocol,  handle_dnd_protocol },
-    { XATOM_XdndEnter,    handle_xdnd_enter_event },
-    { XATOM_XdndPosition, handle_xdnd_position_event },
-    { XATOM_XdndDrop,     handle_xdnd_drop_event },
-    { XATOM_XdndLeave,    handle_xdnd_leave_event }
+    { XATOM_XdndEnter,    X11DRV_XDND_EnterEvent },
+    { XATOM_XdndPosition, X11DRV_XDND_PositionEvent },
+    { XATOM_XdndDrop,     X11DRV_XDND_DropEvent },
+    { XATOM_XdndLeave,    X11DRV_XDND_LeaveEvent }
 };
 
 
diff --git a/dlls/winex11.drv/graphics.c b/dlls/winex11.drv/graphics.c
index b833fe0c629..b3df3cafcb1 100644
--- a/dlls/winex11.drv/graphics.c
+++ b/dlls/winex11.drv/graphics.c
@@ -24,10 +24,6 @@
  * graphics mode
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <stdarg.h>
@@ -48,6 +44,7 @@
 
 #include "x11drv.h"
 #include "wine/debug.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(graphics);
 
@@ -78,23 +75,20 @@ static const int X11DRV_XROPfunction[16] =
 /* get the rectangle in device coordinates, with optional mirroring */
 static RECT get_device_rect( HDC hdc, int left, int top, int right, int bottom )
 {
-    DWORD layout;
     RECT rect;
 
-    NtGdiGetDCDword( hdc, NtGdiGetLayout, &layout );
-
     rect.left   = left;
     rect.top    = top;
     rect.right  = right;
     rect.bottom = bottom;
-    if (layout & LAYOUT_RTL)
+    if (GetLayout( hdc ) & LAYOUT_RTL)
     {
         /* shift the rectangle so that the right border is included after mirroring */
         /* it would be more correct to do this after LPtoDP but that's not what Windows does */
         rect.left--;
         rect.right--;
     }
-    lp_to_dp( hdc, (POINT *)&rect, 2 );
+    LPtoDP( hdc, (POINT *)&rect, 2 );
     if (rect.left > rect.right)
     {
         int tmp = rect.left;
@@ -151,7 +145,8 @@ static void add_pen_device_bounds( X11DRV_PDEVICE *dev, const POINT *points, int
  *           X11DRV_GetRegionData
  *
  * Calls GetRegionData on the given region and converts the rectangle
- * array to XRectangle format. The returned buffer must be freed by caller.
+ * array to XRectangle format. The returned buffer must be freed by
+ * caller using HeapFree(GetProcessHeap(),...).
  * If hdc_lptodp is not 0, the rectangles are converted through LPtoDP.
  */
 RGNDATA *X11DRV_GetRegionData( HRGN hrgn, HDC hdc_lptodp )
@@ -162,17 +157,17 @@ RGNDATA *X11DRV_GetRegionData( HRGN hrgn, HDC hdc_lptodp )
     RECT *rect, tmp;
     XRectangle *xrect;
 
-    if (!(size = NtGdiGetRegionData( hrgn, 0, NULL ))) return NULL;
+    if (!(size = GetRegionData( hrgn, 0, NULL ))) return NULL;
     if (sizeof(XRectangle) > sizeof(RECT))
     {
         /* add extra size for XRectangle array */
         int count = (size - sizeof(RGNDATAHEADER)) / sizeof(RECT);
         size += count * (sizeof(XRectangle) - sizeof(RECT));
     }
-    if (!(data = malloc( size ))) return NULL;
-    if (!NtGdiGetRegionData( hrgn, size, data ))
+    if (!(data = HeapAlloc( GetProcessHeap(), 0, size ))) return NULL;
+    if (!GetRegionData( hrgn, size, data ))
     {
-        free( data );
+        HeapFree( GetProcessHeap(), 0, data );
         return NULL;
     }
 
@@ -180,7 +175,7 @@ RGNDATA *X11DRV_GetRegionData( HRGN hrgn, HDC hdc_lptodp )
     xrect = (XRectangle *)data->Buffer;
     if (hdc_lptodp)  /* map to device coordinates */
     {
-        lp_to_dp( hdc_lptodp, (POINT *)rect, data->rdh.nCount * 2 );
+        LPtoDP( hdc_lptodp, (POINT *)rect, data->rdh.nCount * 2 );
         for (i = 0; i < data->rdh.nCount; i++)
         {
             if (rect[i].right < rect[i].left)
@@ -258,7 +253,7 @@ static void update_x11_clipping( X11DRV_PDEVICE *physDev, HRGN rgn )
     {
         XSetClipRectangles( gdi_display, physDev->gc, physDev->dc_rect.left, physDev->dc_rect.top,
                             (XRectangle *)data->Buffer, data->rdh.nCount, YXBanded );
-        free( data );
+        HeapFree( GetProcessHeap(), 0, data );
     }
 }
 
@@ -276,10 +271,10 @@ BOOL add_extra_clipping_region( X11DRV_PDEVICE *dev, HRGN rgn )
     if (!rgn) return FALSE;
     if (dev->region)
     {
-        if (!(clip = NtGdiCreateRectRgn( 0, 0, 0, 0 ))) return FALSE;
-        NtGdiCombineRgn( clip, dev->region, rgn, RGN_AND );
+        if (!(clip = CreateRectRgn( 0, 0, 0, 0 ))) return FALSE;
+        CombineRgn( clip, dev->region, rgn, RGN_AND );
         update_x11_clipping( dev, clip );
-        NtGdiDeleteObjectApp( clip );
+        DeleteObject( clip );
     }
     else update_x11_clipping( dev, rgn );
     return TRUE;
@@ -316,31 +311,25 @@ void CDECL X11DRV_SetDeviceClipping( PHYSDEV dev, HRGN rgn )
  */
 BOOL X11DRV_SetupGCForPatBlt( X11DRV_PDEVICE *physDev, GC gc, BOOL fMapColors )
 {
-    DWORD bk_color, text_color, rop_mode, bk_mode, poly_fill_mode;
     XGCValues val;
     unsigned long mask;
     Pixmap pixmap = 0;
     POINT pt;
 
     if (physDev->brush.style == BS_NULL) return FALSE;
-
-    NtGdiGetDCDword( physDev->dev.hdc, NtGdiGetBkColor, &bk_color );
-    NtGdiGetDCDword( physDev->dev.hdc, NtGdiGetROP2, &rop_mode );
-
     if (physDev->brush.pixel == -1)
     {
 	/* Special case used for monochrome pattern brushes.
 	 * We need to swap foreground and background because
 	 * Windows does it the wrong way...
 	 */
-        NtGdiGetDCDword( physDev->dev.hdc, NtGdiGetTextColor, &text_color );
-        val.foreground = X11DRV_PALETTE_ToPhysical( physDev, bk_color );
-        val.background = X11DRV_PALETTE_ToPhysical( physDev, text_color );
+	val.foreground = X11DRV_PALETTE_ToPhysical( physDev, GetBkColor(physDev->dev.hdc) );
+	val.background = X11DRV_PALETTE_ToPhysical( physDev, GetTextColor(physDev->dev.hdc) );
     }
     else
     {
 	val.foreground = physDev->brush.pixel;
-	val.background = X11DRV_PALETTE_ToPhysical( physDev, bk_color );
+	val.background = X11DRV_PALETTE_ToPhysical( physDev, GetBkColor(physDev->dev.hdc) );
     }
     if (fMapColors && X11DRV_PALETTE_XPixelToPalette)
     {
@@ -348,7 +337,7 @@ BOOL X11DRV_SetupGCForPatBlt( X11DRV_PDEVICE *physDev, GC gc, BOOL fMapColors )
         val.background = X11DRV_PALETTE_XPixelToPalette[val.background];
     }
 
-    val.function = X11DRV_XROPfunction[rop_mode - 1];
+    val.function = X11DRV_XROPfunction[GetROP2(physDev->dev.hdc)-1];
     /*
     ** Let's replace GXinvert by GXxor with (black xor white)
     ** This solves the selection color and leak problems in excel
@@ -365,8 +354,7 @@ BOOL X11DRV_SetupGCForPatBlt( X11DRV_PDEVICE *physDev, GC gc, BOOL fMapColors )
     {
     case FillStippled:
     case FillOpaqueStippled:
-        NtGdiGetDCDword( physDev->dev.hdc, NtGdiGetBkMode, &bk_mode );
-        if (bk_mode == OPAQUE) val.fill_style = FillOpaqueStippled;
+	if (GetBkMode(physDev->dev.hdc)==OPAQUE) val.fill_style = FillOpaqueStippled;
 	val.stipple = physDev->brush.pixmap;
 	mask = GCStipple;
         break;
@@ -395,13 +383,10 @@ BOOL X11DRV_SetupGCForPatBlt( X11DRV_PDEVICE *physDev, GC gc, BOOL fMapColors )
         mask = 0;
         break;
     }
-
-    NtGdiGetDCPoint( physDev->dev.hdc, NtGdiGetBrushOrgEx, &pt );
-    NtGdiGetDCDword( physDev->dev.hdc, NtGdiGetPolyFillMode, &poly_fill_mode );
-
+    GetBrushOrgEx( physDev->dev.hdc, &pt );
     val.ts_x_origin = physDev->dc_rect.left + pt.x;
     val.ts_y_origin = physDev->dc_rect.top + pt.y;
-    val.fill_rule = poly_fill_mode == WINDING ? WindingRule : EvenOddRule;
+    val.fill_rule = (GetPolyFillMode(physDev->dev.hdc) == WINDING) ? WindingRule : EvenOddRule;
     XChangeGC( gdi_display, gc,
 	       GCFunction | GCForeground | GCBackground | GCFillStyle |
 	       GCFillRule | GCTileStipXOrigin | GCTileStipYOrigin | mask,
@@ -431,10 +416,8 @@ BOOL X11DRV_SetupGCForBrush( X11DRV_PDEVICE *physDev )
  */
 static BOOL X11DRV_SetupGCForPen( X11DRV_PDEVICE *physDev )
 {
-    DWORD rop2, bk_color, bk_mode;
     XGCValues val;
-
-    NtGdiGetDCDword( physDev->dev.hdc, NtGdiGetROP2, &rop2 );
+    UINT rop2 = GetROP2(physDev->dev.hdc);
 
     if (physDev->pen.style == PS_NULL) return FALSE;
 
@@ -461,8 +444,7 @@ static BOOL X11DRV_SetupGCForPen( X11DRV_PDEVICE *physDev )
 	val.foreground = physDev->pen.pixel;
 	val.function   = X11DRV_XROPfunction[rop2-1];
     }
-    NtGdiGetDCDword( physDev->dev.hdc, NtGdiGetBkColor, &bk_color );
-    val.background = X11DRV_PALETTE_ToPhysical( physDev, bk_color );
+    val.background = X11DRV_PALETTE_ToPhysical( physDev, GetBkColor(physDev->dev.hdc) );
     val.fill_style = FillSolid;
     val.line_width = physDev->pen.width;
     if (val.line_width <= 1) {
@@ -495,8 +477,7 @@ static BOOL X11DRV_SetupGCForPen( X11DRV_PDEVICE *physDev )
     }
 
     if (physDev->pen.dash_len)
-        val.line_style = (NtGdiGetDCDword( physDev->dev.hdc, NtGdiGetBkMode, &bk_mode) &&
-                          bk_mode == OPAQUE && !physDev->pen.ext)
+        val.line_style = ((GetBkMode(physDev->dev.hdc) == OPAQUE) && (!physDev->pen.ext))
                          ? LineDoubleDash : LineOnOffDash;
     else
         val.line_style = LineSolid;
@@ -523,7 +504,7 @@ INT X11DRV_XWStoDS( HDC hdc, INT width )
     pt[0].y = 0;
     pt[1].x = width;
     pt[1].y = 0;
-    lp_to_dp( hdc, pt, 2 );
+    LPtoDP( hdc, pt, 2 );
     return pt[1].x - pt[0].x;
 }
 
@@ -540,7 +521,7 @@ INT X11DRV_YWStoDS( HDC hdc, INT height )
     pt[0].y = 0;
     pt[1].x = 0;
     pt[1].y = height;
-    lp_to_dp( hdc, pt, 2 );
+    LPtoDP( hdc, pt, 2 );
     return pt[1].y - pt[0].y;
 }
 
@@ -552,10 +533,10 @@ BOOL CDECL X11DRV_LineTo( PHYSDEV dev, INT x, INT y )
     X11DRV_PDEVICE *physDev = get_x11drv_dev( dev );
     POINT pt[2];
 
-    NtGdiGetDCPoint( dev->hdc, NtGdiGetCurrentPosition, &pt[0] );
+    GetCurrentPositionEx( dev->hdc, &pt[0] );
     pt[1].x = x;
     pt[1].y = y;
-    lp_to_dp( dev->hdc, pt, 2 );
+    LPtoDP( dev->hdc, pt, 2 );
     add_pen_device_bounds( physDev, pt, 2 );
 
     if (X11DRV_SetupGCForPen( physDev ))
@@ -580,7 +561,6 @@ static BOOL X11DRV_DrawArc( PHYSDEV dev, INT left, INT top, INT right, INT botto
     X11DRV_PDEVICE *physDev = get_x11drv_dev( dev );
     INT xcenter, ycenter, istart_angle, idiff_angle;
     INT width, oldwidth;
-    DWORD arc_dir;
     double start_angle, end_angle;
     XPoint points[4];
     POINT start, end;
@@ -590,13 +570,13 @@ static BOOL X11DRV_DrawArc( PHYSDEV dev, INT left, INT top, INT right, INT botto
     start.y = ystart;
     end.x = xend;
     end.y = yend;
-    lp_to_dp(dev->hdc, &start, 1);
-    lp_to_dp(dev->hdc, &end, 1);
+    LPtoDP(dev->hdc, &start, 1);
+    LPtoDP(dev->hdc, &end, 1);
 
     if ((rc.left == rc.right) || (rc.top == rc.bottom)
             ||(lines && ((rc.right-rc.left==1)||(rc.bottom-rc.top==1)))) return TRUE;
 
-    if (NtGdiGetDCDword( dev->hdc, NtGdiGetArcDirection, &arc_dir ) && arc_dir == AD_CLOCKWISE)
+    if (GetArcDirection( dev->hdc ) == AD_CLOCKWISE)
       { POINT tmp = start; start = end; end = tmp; }
 
     oldwidth = width = physDev->pen.width;
@@ -863,7 +843,7 @@ BOOL CDECL X11DRV_RoundRect( PHYSDEV dev, INT left, INT top, INT right, INT bott
     pts[0].x = pts[0].y = 0;
     pts[1].x = ell_width;
     pts[1].y = ell_height;
-    lp_to_dp(dev->hdc, pts, 2);
+    LPtoDP(dev->hdc, pts, 2);
     ell_width  = max(abs( pts[1].x - pts[0].x ), 1);
     ell_height = max(abs( pts[1].y - pts[0].y ), 1);
 
@@ -1044,7 +1024,7 @@ COLORREF CDECL X11DRV_SetPixel( PHYSDEV dev, INT x, INT y, COLORREF color )
 
     pt.x = x;
     pt.y = y;
-    lp_to_dp( dev->hdc, &pt, 1 );
+    LPtoDP( dev->hdc, &pt, 1 );
     pixel = X11DRV_PALETTE_ToPhysical( physDev, color );
 
     XSetForeground( gdi_display, physDev->gc, pixel );
@@ -1081,11 +1061,11 @@ BOOL CDECL X11DRV_PaintRgn( PHYSDEV dev, HRGN hrgn )
         }
 
         XFillRectangles( gdi_display, physDev->drawable, physDev->gc, rect, data->rdh.nCount );
-        free( data );
+        HeapFree( GetProcessHeap(), 0, data );
     }
-    if (NtGdiGetRgnBox( hrgn, &rc ))
+    if (GetRgnBox( hrgn, &rc ))
     {
-        lp_to_dp( dev->hdc, (POINT *)&rc, 2 );
+        LPtoDP( dev->hdc, (POINT *)&rc, 2 );
         add_device_bounds( physDev, &rc );
     }
     return TRUE;
@@ -1101,15 +1081,15 @@ static BOOL X11DRV_Polygon( PHYSDEV dev, const POINT* pt, INT count )
     POINT *points;
     XPoint *xpoints;
 
-    points = malloc( count * sizeof(*pt) );
+    points = HeapAlloc( GetProcessHeap(), 0, count * sizeof(*pt) );
     if (!points) return FALSE;
     memcpy( points, pt, count * sizeof(*pt) );
-    lp_to_dp( dev->hdc, points, count );
+    LPtoDP( dev->hdc, points, count );
     add_pen_device_bounds( physDev, points, count );
 
-    if (!(xpoints = malloc( sizeof(XPoint) * (count+1) )))
+    if (!(xpoints = HeapAlloc( GetProcessHeap(), 0, sizeof(XPoint) * (count+1) )))
     {
-        free( points );
+        HeapFree( GetProcessHeap(), 0, points );
         return FALSE;
     }
     for (i = 0; i < count; i++)
@@ -1127,8 +1107,8 @@ static BOOL X11DRV_Polygon( PHYSDEV dev, const POINT* pt, INT count )
         XDrawLines( gdi_display, physDev->drawable, physDev->gc,
                     xpoints, count+1, CoordModeOrigin );
 
-    free( xpoints );
-    free( points );
+    HeapFree( GetProcessHeap(), 0, xpoints );
+    HeapFree( GetProcessHeap(), 0, points );
     return TRUE;
 }
 
@@ -1152,25 +1132,19 @@ BOOL CDECL X11DRV_PolyPolygon( PHYSDEV dev, const POINT* pt, const INT* counts,
         total += counts[i];
     }
 
-    points = malloc( total * sizeof(*pt) );
+    points = HeapAlloc( GetProcessHeap(), 0, total * sizeof(*pt) );
     if (!points) return FALSE;
     memcpy( points, pt, total * sizeof(*pt) );
-    lp_to_dp( dev->hdc, points, total );
+    LPtoDP( dev->hdc, points, total );
     add_pen_device_bounds( physDev, points, total );
 
     if (X11DRV_SetupGCForBrush( physDev ))
     {
-        DWORD poly_fill_mode;
         XRectangle *rect;
-        HRGN hrgn;
-        RGNDATA *data;
-
-        NtGdiGetDCDword( dev->hdc, NtGdiGetPolyFillMode, &poly_fill_mode );
-        hrgn = UlongToHandle( NtGdiPolyPolyDraw( UlongToHandle(poly_fill_mode), points,
-                                                 (const ULONG *)counts, polygons,
-                                                 NtGdiPolyPolygonRgn ));
-        data = X11DRV_GetRegionData( hrgn, 0 );
-        NtGdiDeleteObjectApp( hrgn );
+        HRGN hrgn = CreatePolyPolygonRgn( points, counts, polygons, GetPolyFillMode( dev->hdc ) );
+        RGNDATA *data = X11DRV_GetRegionData( hrgn, 0 );
+
+        DeleteObject( hrgn );
         if (!data) goto done;
         rect = (XRectangle *)data->Buffer;
         for (i = 0; i < data->rdh.nCount; i++)
@@ -1180,7 +1154,7 @@ BOOL CDECL X11DRV_PolyPolygon( PHYSDEV dev, const POINT* pt, const INT* counts,
         }
 
         XFillRectangles( gdi_display, physDev->drawable, physDev->gc, rect, data->rdh.nCount );
-        free( data );
+        HeapFree( GetProcessHeap(), 0, data );
     }
 
     if (X11DRV_SetupGCForPen ( physDev ))
@@ -1188,7 +1162,7 @@ BOOL CDECL X11DRV_PolyPolygon( PHYSDEV dev, const POINT* pt, const INT* counts,
         XPoint *xpoints;
         int j;
 
-        if (!(xpoints = malloc( sizeof(XPoint) * (max + 1) ))) goto done;
+        if (!(xpoints = HeapAlloc( GetProcessHeap(), 0, sizeof(XPoint) * (max + 1) ))) goto done;
         for (i = pos = 0; i < polygons; pos += counts[i++])
         {
             for (j = 0; j < counts[i]; j++)
@@ -1199,12 +1173,12 @@ BOOL CDECL X11DRV_PolyPolygon( PHYSDEV dev, const POINT* pt, const INT* counts,
 	    xpoints[j] = xpoints[0];
             XDrawLines( gdi_display, physDev->drawable, physDev->gc, xpoints, j + 1, CoordModeOrigin );
         }
-        free( xpoints );
+        HeapFree( GetProcessHeap(), 0, xpoints );
     }
     ret = TRUE;
 
 done:
-    free( points );
+    HeapFree( GetProcessHeap(), 0, points );
     return ret;
 }
 
@@ -1225,19 +1199,19 @@ BOOL CDECL X11DRV_PolyPolyline( PHYSDEV dev, const POINT* pt, const DWORD* count
         total += counts[i];
     }
 
-    points = malloc( total * sizeof(*pt) );
+    points = HeapAlloc( GetProcessHeap(), 0, total * sizeof(*pt) );
     if (!points) return FALSE;
     memcpy( points, pt, total * sizeof(*pt) );
-    lp_to_dp( dev->hdc, points, total );
+    LPtoDP( dev->hdc, points, total );
     add_pen_device_bounds( physDev, points, total );
 
     if (X11DRV_SetupGCForPen ( physDev ))
     {
         XPoint *xpoints;
 
-        if (!(xpoints = malloc( sizeof(XPoint) * max )))
+        if (!(xpoints = HeapAlloc( GetProcessHeap(), 0, sizeof(XPoint) * max )))
         {
-            free( points );
+            HeapFree( GetProcessHeap(), 0, points );
             return FALSE;
         }
         for (i = pos = 0; i < polylines; pos += counts[i++])
@@ -1249,9 +1223,9 @@ BOOL CDECL X11DRV_PolyPolyline( PHYSDEV dev, const POINT* pt, const DWORD* count
             }
             XDrawLines( gdi_display, physDev->drawable, physDev->gc, xpoints, j, CoordModeOrigin );
         }
-        free( xpoints );
+        HeapFree( GetProcessHeap(), 0, xpoints );
     }
-    free( points );
+    HeapFree( GetProcessHeap(), 0, points );
     return TRUE;
 }
 
@@ -1265,27 +1239,27 @@ static BOOL x11drv_stroke_and_fill_path( PHYSDEV dev, BOOL stroke, BOOL fill )
     XPoint *xpoints;
     int i, j, size;
 
-    NtGdiFlattenPath( dev->hdc );
-    if ((size = NtGdiGetPath( dev->hdc, NULL, NULL, 0 )) == -1) return FALSE;
+    FlattenPath( dev->hdc );
+    if ((size = GetPath( dev->hdc, NULL, NULL, 0 )) == -1) return FALSE;
     if (!size)
     {
-        NtGdiAbortPath( dev->hdc );
+        AbortPath( dev->hdc );
         return TRUE;
     }
-    xpoints = malloc( (size + 1) * sizeof(*xpoints) );
-    points = malloc( size * sizeof(*points) );
-    flags = malloc( size * sizeof(*flags) );
+    xpoints = HeapAlloc( GetProcessHeap(), 0, (size + 1) * sizeof(*xpoints) );
+    points = HeapAlloc( GetProcessHeap(), 0, size * sizeof(*points) );
+    flags = HeapAlloc( GetProcessHeap(), 0, size * sizeof(*flags) );
     if (!points || !flags || !xpoints) goto done;
-    if (NtGdiGetPath( dev->hdc, points, flags, size ) == -1) goto done;
-    lp_to_dp( dev->hdc, points, size );
+    if (GetPath( dev->hdc, points, flags, size ) == -1) goto done;
+    LPtoDP( dev->hdc, points, size );
 
     if (fill && X11DRV_SetupGCForBrush( physDev ))
     {
         XRectangle *rect;
-        HRGN hrgn = NtGdiPathToRegion( dev->hdc );
+        HRGN hrgn = PathToRegion( dev->hdc );
         RGNDATA *data = X11DRV_GetRegionData( hrgn, 0 );
 
-        NtGdiDeleteObjectApp( hrgn );
+        DeleteObject( hrgn );
         if (!data) goto done;
         rect = (XRectangle *)data->Buffer;
         for (i = 0; i < data->rdh.nCount; i++)
@@ -1295,7 +1269,7 @@ static BOOL x11drv_stroke_and_fill_path( PHYSDEV dev, BOOL stroke, BOOL fill )
         }
 
         XFillRectangles( gdi_display, physDev->drawable, physDev->gc, rect, data->rdh.nCount );
-        free( data );
+        HeapFree( GetProcessHeap(), 0, data );
     }
 
     if (stroke && X11DRV_SetupGCForPen ( physDev ))
@@ -1322,13 +1296,13 @@ static BOOL x11drv_stroke_and_fill_path( PHYSDEV dev, BOOL stroke, BOOL fill )
     }
 
     add_pen_device_bounds( physDev, points, size );
-    NtGdiAbortPath( dev->hdc );
+    AbortPath( dev->hdc );
     ret = TRUE;
 
 done:
-    free( xpoints );
-    free( points );
-    free( flags );
+    HeapFree( GetProcessHeap(), 0, xpoints );
+    HeapFree( GetProcessHeap(), 0, points );
+    HeapFree( GetProcessHeap(), 0, flags );
     return ret;
 }
 
@@ -1449,7 +1423,7 @@ BOOL CDECL X11DRV_ExtFloodFill( PHYSDEV dev, INT x, INT y, COLORREF color, UINT
 
     pt.x = x;
     pt.y = y;
-    lp_to_dp( dev->hdc, &pt, 1 );
+    LPtoDP( dev->hdc, &pt, 1 );
 
     if (!physDev->region)
     {
@@ -1460,8 +1434,8 @@ BOOL CDECL X11DRV_ExtFloodFill( PHYSDEV dev, INT x, INT y, COLORREF color, UINT
     }
     else
     {
-        if (!NtGdiPtInRegion( physDev->region, pt.x, pt.y )) return FALSE;
-        NtGdiGetRgnBox( physDev->region, &rect );
+        if (!PtInRegion( physDev->region, pt.x, pt.y )) return FALSE;
+        GetRgnBox( physDev->region, &rect );
         rect.left   = max( rect.left, 0 );
         rect.top    = max( rect.top, 0 );
         rect.right  = min( rect.right, physDev->dc_rect.right - physDev->dc_rect.left );
@@ -1537,7 +1511,7 @@ BOOL CDECL X11DRV_GradientFill( PHYSDEV dev, TRIVERTEX *vert_array, ULONG nvert,
             pt[0].y = v[0].y;
             pt[1].x = v[1].x;
             pt[1].y = v[1].y;
-            lp_to_dp( dev->hdc, pt, 2 );
+            LPtoDP( dev->hdc, pt, 2 );
             dx = pt[1].x - pt[0].x;
             if (!dx) continue;
             if (dx < 0)  /* swap the colors */
@@ -1587,7 +1561,7 @@ BOOL CDECL X11DRV_GradientFill( PHYSDEV dev, TRIVERTEX *vert_array, ULONG nvert,
             pt[0].y = v[0].y;
             pt[1].x = v[1].x;
             pt[1].y = v[1].y;
-            lp_to_dp( dev->hdc, pt, 2 );
+            LPtoDP( dev->hdc, pt, 2 );
             dy = pt[1].y - pt[0].y;
             if (!dy) continue;
             if (dy < 0)  /* swap the colors */
@@ -1623,13 +1597,12 @@ fallback:
     return dev->funcs->pGradientFill( dev, vert_array, nvert, grad_array, ngrad, mode );
 }
 
-static char *get_icm_profile( unsigned long *size )
+static unsigned char *get_icm_profile( unsigned long *size )
 {
     Atom type;
     int format;
     unsigned long count, remaining;
-    unsigned char *profile;
-    char *ret = NULL;
+    unsigned char *profile, *ret = NULL;
 
     XGetWindowProperty( gdi_display, DefaultRootWindow(gdi_display),
                         x11drv_atom(_ICC_PROFILE), 0, ~0UL, False, AnyPropertyType,
@@ -1637,7 +1610,7 @@ static char *get_icm_profile( unsigned long *size )
     *size = get_property_size( format, count );
     if (format && count)
     {
-        if ((ret = malloc( *size ))) memcpy( ret, profile, *size );
+        if ((ret = HeapAlloc( GetProcessHeap(), 0, *size ))) memcpy( ret, profile, *size );
         XFree( profile );
     }
     return ret;
@@ -1656,14 +1629,12 @@ extern void WINAPI A_SHAUpdate( sha_ctx *, const unsigned char *, unsigned int )
 extern void WINAPI A_SHAFinal( sha_ctx *, unsigned char * );
 
 static const WCHAR mntr_key[] =
-    {'\\','R','e','g','i','s','t','r','y','\\','M','a','c','h','i','n','e','\\',
-     'S','o','f','t','w','a','r','e','\\','M','i','c','r','o','s','o','f','t','\\',
+    {'S','o','f','t','w','a','r','e','\\','M','i','c','r','o','s','o','f','t','\\',
      'W','i','n','d','o','w','s',' ','N','T','\\','C','u','r','r','e','n','t',
-     'V','e','r','s','i','o','n','\\','I','C','M','\\','m','n','t','r'};
+     'V','e','r','s','i','o','n','\\','I','C','M','\\','m','n','t','r',0};
 
 static const WCHAR color_path[] =
-    {'\\','?','?','\\','c',':','\\','w','i','n','d','o','w','s','\\','s','y','s','t','e','m','3','2',
-     '\\','s','p','o','o','l','\\','d','r','i','v','e','r','s','\\','c','o','l','o','r','\\'};
+    {'\\','s','p','o','o','l','\\','d','r','i','v','e','r','s','\\','c','o','l','o','r','\\',0};
 
 /***********************************************************************
  *              GetICMProfile (X11DRV.@)
@@ -1674,65 +1645,56 @@ BOOL CDECL X11DRV_GetICMProfile( PHYSDEV dev, BOOL allow_default, LPDWORD size,
         {'s','R','G','B',' ','C','o','l','o','r',' ','S','p','a','c','e',' ',
          'P','r','o','f','i','l','e','.','i','c','m',0};
     HKEY hkey;
-    DWORD required;
-    char buf[4096];
-    KEY_VALUE_FULL_INFORMATION *info = (void *)buf;
-    char *buffer;
-    unsigned long buflen, i;
-    ULONG full_size;
-    WCHAR fullname[MAX_PATH + ARRAY_SIZE( color_path )], *p;
-    UNICODE_STRING name;
-    OBJECT_ATTRIBUTES attr;
+    DWORD required, len;
+    WCHAR profile[MAX_PATH], fullname[2*MAX_PATH + ARRAY_SIZE( color_path )];
+    unsigned char *buffer;
+    unsigned long buflen;
 
     if (!size) return FALSE;
 
-    memcpy( fullname, color_path, sizeof(color_path) );
-    p = fullname + ARRAYSIZE(color_path);
+    GetSystemDirectoryW( fullname, MAX_PATH );
+    strcatW( fullname, color_path );
 
-    hkey = reg_open_key( NULL, mntr_key, sizeof(mntr_key) );
-
-    if (hkey && !NtEnumerateValueKey( hkey, 0, KeyValueFullInformation,
-                                      info, sizeof(buf), &full_size ))
+    len = ARRAY_SIZE( profile );
+    if (!RegCreateKeyExW( HKEY_LOCAL_MACHINE, mntr_key, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &hkey, NULL ) &&
+        !RegEnumValueW( hkey, 0, profile, &len, NULL, NULL, NULL, NULL )) /* FIXME handle multiple values */
     {
-        /* FIXME handle multiple values */
-        memcpy( p, info->Name, info->NameLength );
-        p[info->NameLength / sizeof(WCHAR)] = 0;
+        strcatW( fullname, profile );
+        RegCloseKey( hkey );
     }
     else if ((buffer = get_icm_profile( &buflen )))
     {
+        static const WCHAR fmt[] = {'%','0','2','x',0};
         static const WCHAR icm[] = {'.','i','c','m',0};
-        IO_STATUS_BLOCK io;
-        UINT64 hash = 0;
+
+        unsigned char sha1sum[20];
+        unsigned int i;
+        sha_ctx ctx;
         HANDLE file;
-        NTSTATUS status;
 
-        for (i = 0; i < buflen; i++) hash = (hash << 16) - hash + buffer[i];
-        for (i = 0; i < sizeof(hash) * 2; i++)
-        {
-            int digit = hash & 0xf;
-            p[i] = digit < 10 ? '0' + digit : 'a' - 10 + digit;
-            hash >>= 4;
-        }
+        A_SHAInit( &ctx );
+        A_SHAUpdate( &ctx, buffer, buflen );
+        A_SHAFinal( &ctx, sha1sum );
 
-        memcpy( p + i, icm, sizeof(icm) );
+        for (i = 0; i < sizeof(sha1sum); i++) sprintfW( &profile[i * 2], fmt, sha1sum[i] );
+        memcpy( &profile[i * 2], icm, sizeof(icm) );
 
-        RtlInitUnicodeString( &name, fullname );
-        InitializeObjectAttributes( &attr, &name, OBJ_CASE_INSENSITIVE, NULL, NULL );
-        status = NtCreateFile( &file, GENERIC_WRITE, &attr, &io, NULL, 0, 0, FILE_CREATE,
-                               FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE, NULL, 0 );
-        if (!status)
+        strcatW( fullname, profile );
+        file = CreateFileW( fullname, GENERIC_WRITE, 0, NULL, CREATE_NEW, 0, 0 );
+        if (file != INVALID_HANDLE_VALUE)
         {
-            status = NtWriteFile( file, NULL, NULL, NULL, &io, buffer, buflen, NULL, NULL );
-            if (status) ERR( "Unable to write color profile: %x\n", status );
-            NtClose( file );
+            DWORD written;
+
+            if (!WriteFile( file, buffer, buflen, &written, NULL ) || written != buflen)
+                ERR( "Unable to write color profile\n" );
+            CloseHandle( file );
         }
-        free( buffer );
+        HeapFree( GetProcessHeap(), 0, buffer );
     }
     else if (!allow_default) return FALSE;
-    else lstrcpyW( p, srgb );
+    else strcatW( fullname, srgb );
 
-    NtClose( hkey );
-    required = wcslen( fullname ) + 1 - 4 /* skip NT prefix */;
+    required = strlenW( fullname ) + 1;
     if (*size < required)
     {
         *size = required;
@@ -1741,12 +1703,9 @@ BOOL CDECL X11DRV_GetICMProfile( PHYSDEV dev, BOOL allow_default, LPDWORD size,
     }
     if (filename)
     {
-        FILE_BASIC_INFORMATION info;
-        wcscpy( filename, fullname + 4 );
-        RtlInitUnicodeString( &name, fullname );
-        InitializeObjectAttributes( &attr, &name, OBJ_CASE_INSENSITIVE, NULL, NULL );
-        if (NtQueryAttributesFile( &attr, &info ))
-            WARN( "color profile not found in %s\n", debugstr_w(fullname) );
+        strcpyW( filename, fullname );
+        if (GetFileAttributesW( filename ) == INVALID_FILE_ATTRIBUTES)
+            WARN( "color profile not found\n" );
     }
     *size = required;
     return TRUE;
diff --git a/dlls/winex11.drv/ime.c b/dlls/winex11.drv/ime.c
index 5f8bdd8c68b..c1584930861 100644
--- a/dlls/winex11.drv/ime.c
+++ b/dlls/winex11.drv/ime.c
@@ -40,10 +40,19 @@
  *  generate the messages that we want the IMM layer to send to the application.
  */
 
-#include "x11drv_dll.h"
+#include "config.h"
+
+#include <stdarg.h>
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+#include "winerror.h"
 #include "wine/debug.h"
 #include "imm.h"
 #include "ddk/imm.h"
+#include "winnls.h"
+#include "x11drv.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(imm);
 
@@ -628,7 +637,6 @@ UINT WINAPI ImeToAsciiEx (UINT uVKey, UINT uScanCode, const LPBYTE lpbKeyState,
 
 BOOL WINAPI NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
 {
-    struct xim_preedit_state_params preedit_params;
     BOOL bRet = FALSE;
     LPINPUTCONTEXT lpIMC;
 
@@ -672,9 +680,7 @@ BOOL WINAPI NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
                     TRACE("IMC_SETOPENSTATUS\n");
 
                     bRet = TRUE;
-                    preedit_params.hwnd = lpIMC->hWnd;
-                    preedit_params.open = lpIMC->fOpen;
-                    X11DRV_CALL( xim_preedit_state, &preedit_params );
+                    X11DRV_SetPreeditState(lpIMC->hWnd, lpIMC->fOpen);
                     if (!lpIMC->fOpen)
                     {
                         LPIMEPRIVATE myPrivate;
@@ -682,7 +688,7 @@ BOOL WINAPI NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
                         myPrivate = ImmLockIMCC(lpIMC->hPrivate);
                         if (myPrivate->bInComposition)
                         {
-                            X11DRV_CALL( xim_reset, lpIMC->hWnd );
+                            X11DRV_ForceXIMReset(lpIMC->hWnd);
                             GenerateIMEMessage(hIMC, WM_IME_ENDCOMPOSITION, 0, 0);
                             myPrivate->bInComposition = FALSE;
                         }
@@ -758,7 +764,7 @@ BOOL WINAPI NotifyIME(HIMC hIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue)
 
                     TRACE("CPS_CANCEL\n");
 
-                    X11DRV_CALL( xim_reset, lpIMC->hWnd );
+                    X11DRV_ForceXIMReset(lpIMC->hWnd);
 
                     if (lpIMC->hCompStr)
                         ImmDestroyIMCC(lpIMC->hCompStr);
@@ -907,16 +913,15 @@ DWORD WINAPI ImeGetImeMenuItems(HIMC hIMC,  DWORD dwFlags,  DWORD dwType,
 
 /* Interfaces to XIM and other parts of winex11drv */
 
-NTSTATUS x11drv_ime_set_open_status( UINT open )
+void IME_SetOpenStatus(BOOL fOpen)
 {
     HIMC imc;
 
     imc = RealIMC(FROM_X11);
-    ImmSetOpenStatus(imc, open);
-    return 0;
+    ImmSetOpenStatus(imc, fOpen);
 }
 
-NTSTATUS x11drv_ime_set_composition_status( UINT open )
+void IME_SetCompositionStatus(BOOL fOpen)
 {
     HIMC imc;
     LPINPUTCONTEXT lpIMC;
@@ -925,29 +930,28 @@ NTSTATUS x11drv_ime_set_composition_status( UINT open )
     imc = RealIMC(FROM_X11);
     lpIMC = ImmLockIMC(imc);
     if (lpIMC == NULL)
-        return 0;
+        return;
 
     myPrivate = ImmLockIMCC(lpIMC->hPrivate);
 
-    if (open && !myPrivate->bInComposition)
+    if (fOpen && !myPrivate->bInComposition)
     {
         GenerateIMEMessage(imc, WM_IME_STARTCOMPOSITION, 0, 0);
     }
-    else if (!open && myPrivate->bInComposition)
+    else if (!fOpen && myPrivate->bInComposition)
     {
         ShowWindow(myPrivate->hwndDefault, SW_HIDE);
         ImmDestroyIMCC(lpIMC->hCompStr);
         lpIMC->hCompStr = ImeCreateBlankCompStr();
         GenerateIMEMessage(imc, WM_IME_ENDCOMPOSITION, 0, 0);
     }
-    myPrivate->bInComposition = open;
+    myPrivate->bInComposition = fOpen;
 
     ImmUnlockIMCC(lpIMC->hPrivate);
     ImmUnlockIMC(imc);
-    return 0;
 }
 
-NTSTATUS x11drv_ime_get_cursor_pos( UINT arg )
+INT IME_GetCursorPos(void)
 {
     LPINPUTCONTEXT lpIMC;
     INT rc = 0;
@@ -967,73 +971,68 @@ NTSTATUS x11drv_ime_get_cursor_pos( UINT arg )
     return rc;
 }
 
-NTSTATUS x11drv_ime_set_cursor_pos( UINT pos )
+void IME_SetCursorPos(DWORD pos)
 {
     LPINPUTCONTEXT lpIMC;
     LPCOMPOSITIONSTRING compstr;
 
     if (!hSelectedFrom)
-        return 0;
+        return;
 
     lpIMC = LockRealIMC(FROM_X11);
     if (!lpIMC)
-        return 0;
+        return;
 
     compstr = ImmLockIMCC(lpIMC->hCompStr);
     if (!compstr)
     {
         UnlockRealIMC(FROM_X11);
-        return 0;
+        return;
     }
 
     compstr->dwCursorPos = pos;
     ImmUnlockIMCC(lpIMC->hCompStr);
     UnlockRealIMC(FROM_X11);
     GenerateIMEMessage(FROM_X11, WM_IME_COMPOSITION, pos, GCS_CURSORPOS);
-    return 0;
+    return;
 }
 
-NTSTATUS x11drv_ime_update_association( UINT arg )
+void IME_UpdateAssociation(HWND focus)
 {
-    HWND focus = UlongToHandle( arg );
-
     ImmGetContext(focus);
 
-    if (focus && hSelectedFrom)
-        ImmAssociateContext(focus,RealIMC(FROM_X11));
-    return 0;
+    if (!focus || !hSelectedFrom)
+        return;
+
+    ImmAssociateContext(focus,RealIMC(FROM_X11));
 }
 
 
-NTSTATUS WINAPI x11drv_ime_set_composition_string( void *param, ULONG size )
+BOOL IME_SetCompositionString(DWORD dwIndex, LPCVOID lpComp, DWORD dwCompLen,
+                              LPCVOID lpRead, DWORD dwReadLen)
 {
-    return ImeSetCompositionString(FROM_X11, SCS_SETSTR, param, size, NULL, 0);
+    return ImeSetCompositionString(FROM_X11, dwIndex, lpComp, dwCompLen,
+                                    lpRead, dwReadLen);
 }
 
-NTSTATUS WINAPI x11drv_ime_set_result( void *params, ULONG len )
+void IME_SetResultString(LPWSTR lpResult, DWORD dwResultLen)
 {
-    WCHAR *lpResult = params;
     HIMC imc;
     LPINPUTCONTEXT lpIMC;
     HIMCC newCompStr;
     LPIMEPRIVATE myPrivate;
     BOOL inComp;
-    HWND focus;
-
-    len /= sizeof(WCHAR);
-    if ((focus = GetFocus()))
-        x11drv_ime_update_association( HandleToUlong( focus ));
 
     imc = RealIMC(FROM_X11);
     lpIMC = ImmLockIMC(imc);
     if (lpIMC == NULL)
-        return 0;
+        return;
 
     newCompStr = updateCompStr(lpIMC->hCompStr, NULL, 0);
     ImmDestroyIMCC(lpIMC->hCompStr);
     lpIMC->hCompStr = newCompStr;
 
-    newCompStr = updateResultStr(lpIMC->hCompStr, lpResult, len);
+    newCompStr = updateResultStr(lpIMC->hCompStr, lpResult, dwResultLen);
     ImmDestroyIMCC(lpIMC->hCompStr);
     lpIMC->hCompStr = newCompStr;
 
@@ -1055,7 +1054,6 @@ NTSTATUS WINAPI x11drv_ime_set_result( void *params, ULONG len )
         ImmSetOpenStatus(imc, FALSE);
 
     ImmUnlockIMC(imc);
-    return 0;
 }
 
 /*****
diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 7c5a1acd7b6..fe2c50bffa7 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -18,10 +18,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <stdarg.h>
@@ -41,29 +37,17 @@ static int palette_size;
 
 static Pixmap stock_bitmap_pixmap;  /* phys bitmap for the default stock bitmap */
 
-static pthread_once_t init_once = PTHREAD_ONCE_INIT;
+static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
 
 static const struct user_driver_funcs x11drv_funcs;
 static const struct gdi_dc_funcs *xrender_funcs;
 
-
-void init_recursive_mutex( pthread_mutex_t *mutex )
-{
-    pthread_mutexattr_t attr;
-
-    pthread_mutexattr_init( &attr );
-    pthread_mutexattr_settype( &attr, PTHREAD_MUTEX_RECURSIVE );
-    pthread_mutex_init( mutex, &attr );
-    pthread_mutexattr_destroy( &attr );
-}
-
-
 /**********************************************************************
  *	     device_init
  *
  * Perform initializations needed upon creation of the first device.
  */
-static void device_init(void)
+static BOOL WINAPI device_init( INIT_ONCE *once, void *param, void **context )
 {
     /* Initialize XRender */
     xrender_funcs = X11DRV_XRender_Init();
@@ -74,6 +58,8 @@ static void device_init(void)
     palette_size = X11DRV_PALETTE_Init();
 
     stock_bitmap_pixmap = XCreatePixmap( gdi_display, root_window, 1, 1, 1 );
+
+    return TRUE;
 }
 
 
@@ -81,9 +67,9 @@ static X11DRV_PDEVICE *create_x11_physdev( Drawable drawable )
 {
     X11DRV_PDEVICE *physDev;
 
-    pthread_once( &init_once, device_init );
+    InitOnceExecuteOnce( &init_once, device_init, NULL, NULL );
 
-    if (!(physDev = calloc( 1, sizeof(*physDev) ))) return NULL;
+    if (!(physDev = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*physDev) ))) return NULL;
 
     physDev->drawable = drawable;
     physDev->gc = XCreateGC( gdi_display, drawable, 0, NULL );
@@ -105,7 +91,7 @@ static BOOL CDECL X11DRV_CreateDC( PHYSDEV *pdev, LPCWSTR device, LPCWSTR output
 
     physDev->depth         = default_visual.depth;
     physDev->color_shifts  = &X11DRV_PALETTE_default_shifts;
-    physDev->dc_rect       = NtUserGetVirtualScreenRect();
+    physDev->dc_rect       = get_virtual_screen_rect();
     OffsetRect( &physDev->dc_rect, -physDev->dc_rect.left, -physDev->dc_rect.top );
     push_dc_driver( pdev, &physDev->dev, &x11drv_funcs.dc_funcs );
     if (xrender_funcs && !xrender_funcs->pCreateDC( pdev, device, output, initData )) return FALSE;
@@ -139,7 +125,7 @@ static BOOL CDECL X11DRV_DeleteDC( PHYSDEV dev )
     X11DRV_PDEVICE *physDev = get_x11drv_dev( dev );
 
     XFreeGC( gdi_display, physDev->gc );
-    free( physDev );
+    HeapFree( GetProcessHeap(), 0, physDev );
     return TRUE;
 }
 
@@ -149,9 +135,9 @@ void add_device_bounds( X11DRV_PDEVICE *dev, const RECT *rect )
     RECT rc;
 
     if (!dev->bounds) return;
-    if (dev->region && NtGdiGetRgnBox( dev->region, &rc ))
+    if (dev->region && GetRgnBox( dev->region, &rc ))
     {
-        if (intersect_rect( &rc, &rc, rect )) add_bounds_rect( dev->bounds, &rc );
+        if (IntersectRect( &rc, &rc, rect )) add_bounds_rect( dev->bounds, &rc );
     }
     else add_bounds_rect( dev->bounds, rect );
 }
@@ -280,24 +266,21 @@ static INT CDECL X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOI
                             if (event.type == NoExpose) break;
                             if (event.type == GraphicsExpose)
                             {
-                                DWORD layout;
                                 RECT rect;
 
                                 rect.left   = event.xgraphicsexpose.x - physDev->dc_rect.left;
                                 rect.top    = event.xgraphicsexpose.y - physDev->dc_rect.top;
                                 rect.right  = rect.left + event.xgraphicsexpose.width;
                                 rect.bottom = rect.top + event.xgraphicsexpose.height;
-                                if (NtGdiGetDCDword( dev->hdc, NtGdiGetLayout, &layout ) &&
-                                    (layout & LAYOUT_RTL))
+                                if (GetLayout( dev->hdc ) & LAYOUT_RTL)
                                     mirror_rect( &physDev->dc_rect, &rect );
 
                                 TRACE( "got %s count %d\n", wine_dbgstr_rect(&rect),
                                        event.xgraphicsexpose.count );
 
-                                if (!tmp) tmp = NtGdiCreateRectRgn( rect.left, rect.top,
-                                                                    rect.right, rect.bottom );
-                                else NtGdiSetRectRgn( tmp, rect.left, rect.top, rect.right, rect.bottom );
-                                if (hrgn) NtGdiCombineRgn( hrgn, hrgn, tmp, RGN_OR );
+                                if (!tmp) tmp = CreateRectRgnIndirect( &rect );
+                                else SetRectRgn( tmp, rect.left, rect.top, rect.right, rect.bottom );
+                                if (hrgn) CombineRgn( hrgn, hrgn, tmp, RGN_OR );
                                 else
                                 {
                                     hrgn = tmp;
@@ -311,7 +294,7 @@ static INT CDECL X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOI
                                 break;
                             }
                         }
-                        if (tmp) NtGdiDeleteObjectApp( tmp );
+                        if (tmp) DeleteObject( tmp );
                     }
                     *(HRGN *)out_data = hrgn;
                     return TRUE;
@@ -329,7 +312,7 @@ static INT CDECL X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOI
 /**********************************************************************
  *           X11DRV_wine_get_wgl_driver
  */
-static struct opengl_funcs *X11DRV_wine_get_wgl_driver( UINT version )
+static struct opengl_funcs * CDECL X11DRV_wine_get_wgl_driver( UINT version )
 {
     return get_glx_driver( version );
 }
@@ -337,7 +320,7 @@ static struct opengl_funcs *X11DRV_wine_get_wgl_driver( UINT version )
 /**********************************************************************
  *           X11DRV_wine_get_vulkan_driver
  */
-static const struct vulkan_funcs *X11DRV_wine_get_vulkan_driver( UINT version )
+static const struct vulkan_funcs * CDECL X11DRV_wine_get_vulkan_driver( UINT version )
 {
     return get_vulkan_driver( version );
 }
@@ -386,9 +369,6 @@ static const struct user_driver_funcs x11drv_funcs =
     .dc_funcs.pStrokePath = X11DRV_StrokePath,
     .dc_funcs.pUnrealizePalette = X11DRV_UnrealizePalette,
     .dc_funcs.pD3DKMTCheckVidPnExclusiveOwnership = X11DRV_D3DKMTCheckVidPnExclusiveOwnership,
-    .dc_funcs.pD3DKMTCloseAdapter = X11DRV_D3DKMTCloseAdapter,
-    .dc_funcs.pD3DKMTOpenAdapterFromLuid = X11DRV_D3DKMTOpenAdapterFromLuid,
-    .dc_funcs.pD3DKMTQueryVideoMemoryInfo = X11DRV_D3DKMTQueryVideoMemoryInfo,
     .dc_funcs.pD3DKMTSetVidPnSourceOwner = X11DRV_D3DKMTSetVidPnSourceOwner,
     .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
 
@@ -408,7 +388,6 @@ static const struct user_driver_funcs x11drv_funcs =
     .pUpdateDisplayDevices = X11DRV_UpdateDisplayDevices,
     .pCreateDesktopWindow = X11DRV_CreateDesktopWindow,
     .pCreateWindow = X11DRV_CreateWindow,
-    .pDesktopWindowProc = X11DRV_DesktopWindowProc,
     .pDestroyWindow = X11DRV_DestroyWindow,
     .pFlashWindowEx = X11DRV_FlashWindowEx,
     .pGetDC = X11DRV_GetDC,
@@ -425,7 +404,6 @@ static const struct user_driver_funcs x11drv_funcs =
     .pSetWindowText = X11DRV_SetWindowText,
     .pShowWindow = X11DRV_ShowWindow,
     .pSysCommand = X11DRV_SysCommand,
-    .pClipboardWindowProc = X11DRV_ClipboardWindowProc,
     .pUpdateClipboard = X11DRV_UpdateClipboard,
     .pUpdateLayeredWindow = X11DRV_UpdateLayeredWindow,
     .pWindowMessage = X11DRV_WindowMessage,
diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index 7b4ad9acd8d..c15f245e34d 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -23,10 +23,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <X11/Xatom.h>
@@ -44,14 +40,16 @@
 
 #define NONAMELESSUNION
 
-#include "x11drv.h"
-
+#include "windef.h"
+#include "winbase.h"
 #include "wingdi.h"
 #include "winuser.h"
 #include "winreg.h"
 #include "winnls.h"
 #include "ime.h"
+#include "x11drv.h"
 #include "wine/server.h"
+#include "wine/unicode.h"
 #include "wine/debug.h"
 
 /* log format (add 0-padding as appropriate):
@@ -63,15 +61,20 @@
 WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
 WINE_DECLARE_DEBUG_CHANNEL(key);
 
-static const unsigned int ControlMask = 1 << 2;
-
 static int min_keycode, max_keycode, keysyms_per_keycode;
 static KeySym *key_mapping;
 static WORD keyc2vkey[256], keyc2scan[256];
 
 static int NumLockMask, ScrollLockMask, AltGrMask; /* mask in the XKeyEvent state */
 
-static pthread_mutex_t kbd_mutex = PTHREAD_MUTEX_INITIALIZER;
+static CRITICAL_SECTION kbd_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &kbd_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": kbd_section") }
+};
+static CRITICAL_SECTION kbd_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static char KEYBOARD_MapDeadKeysym(KeySym keysym);
 
@@ -1215,7 +1218,7 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
 
     memset(keys, 0, sizeof(keys));
 
-    pthread_mutex_lock( &kbd_mutex );
+    EnterCriticalSection( &kbd_section );
 
     /* the minimum keycode is always greater or equal to 8, so we can
      * skip the first 8 values, hence start at 1
@@ -1245,7 +1248,7 @@ BOOL X11DRV_KeymapNotify( HWND hwnd, XEvent *event )
         }
     }
 
-    pthread_mutex_unlock( &kbd_mutex );
+    LeaveCriticalSection( &kbd_section );
     if (!changed) return FALSE;
 
     update_key_state( keystate, VK_CONTROL, (keystate[VK_LCONTROL] | keystate[VK_RCONTROL]) & 0x80 );
@@ -1342,7 +1345,7 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
         TRACE_(key)("XmbLookupString needs %i byte(s)\n", ascii_chars);
         if (status == XBufferOverflow)
         {
-            Str = malloc( ascii_chars );
+            Str = HeapAlloc(GetProcessHeap(), 0, ascii_chars);
             if (Str == NULL)
             {
                 ERR_(key)("Failed to allocate memory!\n");
@@ -1360,11 +1363,11 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
     {
         X11DRV_XIMLookupChars( Str, ascii_chars );
         if (buf != Str)
-            free( Str );
+            HeapFree(GetProcessHeap(), 0, Str);
         return TRUE;
     }
 
-    pthread_mutex_lock( &kbd_mutex );
+    EnterCriticalSection( &kbd_section );
 
     /* If XKB extensions are used, the state mask for AltGr will use the group
        index instead of the modifier mask. The group index is set in bits
@@ -1389,7 +1392,7 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
                     keysym, ksname, ascii_chars, debugstr_an(Str, ascii_chars));
     }
     if (buf != Str)
-        free( Str );
+        HeapFree(GetProcessHeap(), 0, Str);
 
     vkey = EVENT_event_to_vkey(xic,event);
     /* X returns keycode 0 for composed characters */
@@ -1399,7 +1402,7 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
     TRACE_(key)("keycode %u converted to vkey 0x%X scan %02x\n",
                 event->keycode, vkey, bScan);
 
-    pthread_mutex_unlock( &kbd_mutex );
+    LeaveCriticalSection( &kbd_section );
 
     if (!vkey) return FALSE;
 
@@ -1529,7 +1532,7 @@ X11DRV_KEYBOARD_DetectLayout( Display *display )
 
 static HKL get_locale_kbd_layout(void)
 {
-    LCID layout;
+    ULONG_PTR layout;
     LANGID langid;
 
     /* FIXME:
@@ -1543,7 +1546,7 @@ static HKL get_locale_kbd_layout(void)
      * locale id we return the US one.
      */
 
-    NtQueryDefaultLocale( TRUE, &layout );
+    layout = GetUserDefaultLCID();
 
     /*
      * Microsoft Office expects this value to be something specific
@@ -1557,7 +1560,7 @@ static HKL get_locale_kbd_layout(void)
     else
         layout |= layout << 16;
 
-    return (HKL)(UINT_PTR)layout;
+    return (HKL)layout;
 }
 
 
@@ -1595,7 +1598,7 @@ void X11DRV_InitKeyboard( Display *display )
     };
     int vkey_range;
 
-    pthread_mutex_lock( &kbd_mutex );
+    EnterCriticalSection( &kbd_section );
     XDisplayKeycodes(display, &min_keycode, &max_keycode);
     if (key_mapping) XFree( key_mapping );
     key_mapping = XGetKeyboardMapping(display, min_keycode,
@@ -1832,7 +1835,7 @@ void X11DRV_InitKeyboard( Display *display )
 	keyc2scan[keyc]=scan++;
       }
 
-    pthread_mutex_unlock( &kbd_mutex );
+    LeaveCriticalSection( &kbd_section );
 }
 
 static BOOL match_x11_keyboard_layout(HKL hkl)
@@ -1851,7 +1854,7 @@ static BOOL match_x11_keyboard_layout(HKL hkl)
 /***********************************************************************
  *		ActivateKeyboardLayout (X11DRV.@)
  */
-BOOL X11DRV_ActivateKeyboardLayout(HKL hkl, UINT flags)
+BOOL CDECL X11DRV_ActivateKeyboardLayout(HKL hkl, UINT flags)
 {
     FIXME("%p, %04x: semi-stub!\n", hkl, flags);
 
@@ -1883,10 +1886,10 @@ BOOL X11DRV_MappingNotify( HWND dummy, XEvent *event )
     XRefreshKeyboardMapping(&event->xmapping);
     X11DRV_InitKeyboard( event->xmapping.display );
 
-    hwnd = get_focus();
-    if (!hwnd) hwnd = get_active_window();
-    NtUserPostMessage( hwnd, WM_INPUTLANGCHANGEREQUEST,
-                       0 /*FIXME*/, (LPARAM)NtUserGetKeyboardLayout(0) );
+    hwnd = GetFocus();
+    if (!hwnd) hwnd = GetActiveWindow();
+    PostMessageW(hwnd, WM_INPUTLANGCHANGEREQUEST,
+                 0 /*FIXME*/, (LPARAM)GetKeyboardLayout(0));
     return TRUE;
 }
 
@@ -1896,7 +1899,7 @@ BOOL X11DRV_MappingNotify( HWND dummy, XEvent *event )
  *
  * Note: Windows ignores HKL parameter and uses current active layout instead
  */
-SHORT X11DRV_VkKeyScanEx( WCHAR wChar, HKL hkl )
+SHORT CDECL X11DRV_VkKeyScanEx(WCHAR wChar, HKL hkl)
 {
     Display *display = thread_init_display();
     KeyCode keycode;
@@ -1908,7 +1911,7 @@ SHORT X11DRV_VkKeyScanEx( WCHAR wChar, HKL hkl )
     /* FIXME: what happens if wChar is not a Latin1 character and CP_UNIXCP
      * is UTF-8 (multibyte encoding)?
      */
-    if (!ntdll_wcstoumbs( &wChar, 1, &cChar, 1, FALSE ))
+    if (!WideCharToMultiByte(CP_UNIXCP, 0, &wChar, 1, &cChar, 1, NULL, NULL))
     {
         WARN("no translation from unicode to CP_UNIXCP for 0x%02x\n", wChar);
         return -1;
@@ -1937,13 +1940,13 @@ SHORT X11DRV_VkKeyScanEx( WCHAR wChar, HKL hkl )
     TRACE("'%c'(%lx): got keycode %u\n", cChar, keysym, keycode);
     if (!keycode) return -1;
 
-    pthread_mutex_lock( &kbd_mutex );
+    EnterCriticalSection( &kbd_section );
 
     /* keycode -> (keyc2vkey) vkey */
     ret = keyc2vkey[keycode];
     if (!ret)
     {
-        pthread_mutex_unlock( &kbd_mutex );
+        LeaveCriticalSection( &kbd_section );
         TRACE("keycode for '%c' not found, returning -1\n", cChar);
         return -1;
     }
@@ -1951,7 +1954,7 @@ SHORT X11DRV_VkKeyScanEx( WCHAR wChar, HKL hkl )
     for (index = 0; index < 4; index++) /* find shift state */
         if (keycode_to_keysym(display, keycode, index) == keysym) break;
 
-    pthread_mutex_unlock( &kbd_mutex );
+    LeaveCriticalSection( &kbd_section );
 
     switch (index)
     {
@@ -1978,7 +1981,7 @@ SHORT X11DRV_VkKeyScanEx( WCHAR wChar, HKL hkl )
 /***********************************************************************
  *		MapVirtualKeyEx (X11DRV.@)
  */
-UINT X11DRV_MapVirtualKeyEx( UINT wCode, UINT wMapType, HKL hkl )
+UINT CDECL X11DRV_MapVirtualKeyEx(UINT wCode, UINT wMapType, HKL hkl)
 {
     UINT ret = 0;
     int keyc;
@@ -1988,7 +1991,7 @@ UINT X11DRV_MapVirtualKeyEx( UINT wCode, UINT wMapType, HKL hkl )
     if (!match_x11_keyboard_layout(hkl))
         FIXME("keyboard layout %p is not supported\n", hkl);
 
-    pthread_mutex_lock( &kbd_mutex );
+    EnterCriticalSection( &kbd_section );
 
     switch(wMapType)
     {
@@ -2104,7 +2107,7 @@ UINT X11DRV_MapVirtualKeyEx( UINT wCode, UINT wMapType, HKL hkl )
             if (len)
             {
                 WCHAR wch;
-                if (ntdll_umbstowcs( s, len, &wch, 1 )) ret = RtlUpcaseUnicodeChar( wch );
+                if (MultiByteToWideChar(CP_UNIXCP, 0, s, len, &wch, 1)) ret = toupperW(wch);
             }
             break;
         }
@@ -2114,7 +2117,7 @@ UINT X11DRV_MapVirtualKeyEx( UINT wCode, UINT wMapType, HKL hkl )
             break;
     }
 
-    pthread_mutex_unlock( &kbd_mutex );
+    LeaveCriticalSection( &kbd_section );
     TRACE( "returning 0x%x.\n", ret );
     return ret;
 }
@@ -2122,7 +2125,7 @@ UINT X11DRV_MapVirtualKeyEx( UINT wCode, UINT wMapType, HKL hkl )
 /***********************************************************************
  *		GetKeyNameText (X11DRV.@)
  */
-INT X11DRV_GetKeyNameText( LONG lParam, LPWSTR lpBuffer, INT nSize )
+INT CDECL X11DRV_GetKeyNameText(LONG lParam, LPWSTR lpBuffer, INT nSize)
 {
   Display *display = thread_init_display();
   int vkey, ansi, scanCode;
@@ -2134,7 +2137,7 @@ INT X11DRV_GetKeyNameText( LONG lParam, LPWSTR lpBuffer, INT nSize )
   scanCode = lParam >> 16;
   scanCode &= 0x1ff;  /* keep "extended-key" flag with code */
 
-  vkey = X11DRV_MapVirtualKeyEx( scanCode, MAPVK_VSC_TO_VK_EX, NtUserGetKeyboardLayout(0) );
+  vkey = X11DRV_MapVirtualKeyEx(scanCode, MAPVK_VSC_TO_VK_EX, GetKeyboardLayout(0));
 
   /*  handle "don't care" bit (0x02000000) */
   if (!(lParam & 0x02000000)) {
@@ -2157,7 +2160,7 @@ INT X11DRV_GetKeyNameText( LONG lParam, LPWSTR lpBuffer, INT nSize )
     }
   }
 
-  ansi = X11DRV_MapVirtualKeyEx( vkey, MAPVK_VK_TO_CHAR, NtUserGetKeyboardLayout(0) );
+  ansi = X11DRV_MapVirtualKeyEx(vkey, MAPVK_VK_TO_CHAR, GetKeyboardLayout(0));
   TRACE("scan 0x%04x, vkey 0x%04X, ANSI 0x%04x\n", scanCode, vkey, ansi);
 
   /* first get the name of the "regular" keys which is the Upper case
@@ -2171,7 +2174,7 @@ INT X11DRV_GetKeyNameText( LONG lParam, LPWSTR lpBuffer, INT nSize )
       {
         if (nSize >= 2)
 	{
-          *lpBuffer = RtlUpcaseUnicodeChar( ansi );
+          *lpBuffer = toupperW((WCHAR)ansi);
           *(lpBuffer+1) = 0;
           return 1;
         }
@@ -2191,7 +2194,7 @@ INT X11DRV_GetKeyNameText( LONG lParam, LPWSTR lpBuffer, INT nSize )
 
   /* let's do scancode -> keycode -> keysym -> String */
 
-  pthread_mutex_lock( &kbd_mutex );
+  EnterCriticalSection( &kbd_section );
 
   for (keyi=min_keycode; keyi<=max_keycode; keyi++)
       if ((keyc2scan[keyi]) == scanCode)
@@ -2207,12 +2210,12 @@ INT X11DRV_GetKeyNameText( LONG lParam, LPWSTR lpBuffer, INT nSize )
       if (name && (vkey == VK_SHIFT || vkey == VK_CONTROL || vkey == VK_MENU))
       {
           char* idx = strrchr(name, '_');
-          if (idx && (idx[1] == 'r' || idx[1] == 'R' || idx[1] == 'l' || idx[1] == 'L') && !idx[2])
+          if (idx && (_strnicmp(idx, "_r", -1) == 0 || _strnicmp(idx, "_l", -1) == 0))
           {
-              pthread_mutex_unlock( &kbd_mutex );
+              LeaveCriticalSection( &kbd_section );
               TRACE("found scan=%04x keyc=%u keysym=%lx modified_string=%s\n",
                     scanCode, keyc, keys, debugstr_an(name,idx-name));
-              rc = ntdll_umbstowcs( name, idx - name + 1, lpBuffer, nSize );
+              rc = MultiByteToWideChar(CP_UNIXCP, 0, name, idx-name+1, lpBuffer, nSize);
               if (!rc) rc = nSize;
               lpBuffer[--rc] = 0;
               return rc;
@@ -2221,10 +2224,10 @@ INT X11DRV_GetKeyNameText( LONG lParam, LPWSTR lpBuffer, INT nSize )
 
       if (name)
       {
-          pthread_mutex_unlock( &kbd_mutex );
+          LeaveCriticalSection( &kbd_section );
           TRACE("found scan=%04x keyc=%u keysym=%04x vkey=%04x string=%s\n",
                 scanCode, keyc, (int)keys, vkey, debugstr_a(name));
-          rc = ntdll_umbstowcs( name, strlen(name) + 1, lpBuffer, nSize );
+          rc = MultiByteToWideChar(CP_UNIXCP, 0, name, -1, lpBuffer, nSize);
           if (!rc) rc = nSize;
           lpBuffer[--rc] = 0;
           return rc;
@@ -2233,7 +2236,7 @@ INT X11DRV_GetKeyNameText( LONG lParam, LPWSTR lpBuffer, INT nSize )
 
   /* Finally issue WARN for unknown keys   */
 
-  pthread_mutex_unlock( &kbd_mutex );
+  LeaveCriticalSection( &kbd_section );
   WARN("(%08x,%p,%d): unsupported key, vkey=%04X, ansi=%04x\n",lParam,lpBuffer,nSize,vkey,ansi);
   *lpBuffer = 0;
   return 0;
@@ -2335,8 +2338,8 @@ static char KEYBOARD_MapDeadKeysym(KeySym keysym)
  * FIXME : should do the above (return 2 for non matching deadchar+char combinations)
  *
  */
-INT X11DRV_ToUnicodeEx( UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
-                        LPWSTR bufW, int bufW_size, UINT flags, HKL hkl )
+INT CDECL X11DRV_ToUnicodeEx(UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
+                             LPWSTR bufW, int bufW_size, UINT flags, HKL hkl)
 {
     Display *display = thread_init_display();
     XKeyEvent e;
@@ -2372,14 +2375,14 @@ INT X11DRV_ToUnicodeEx( UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
     focus = x11drv_thread_data()->last_xic_hwnd;
     if (!focus)
     {
-        focus = get_focus();
-        if (focus) focus = NtUserGetAncestor( focus, GA_ROOT );
-        if (!focus) focus = get_active_window();
+        focus = GetFocus();
+        if (focus) focus = GetAncestor( focus, GA_ROOT );
+        if (!focus) focus = GetActiveWindow();
     }
     e.window = X11DRV_get_whole_window( focus );
     xic = X11DRV_get_ic( focus );
 
-    pthread_mutex_lock( &kbd_mutex );
+    EnterCriticalSection( &kbd_section );
 
     if (lpKeyState[VK_SHIFT] & 0x80)
     {
@@ -2450,7 +2453,7 @@ INT X11DRV_ToUnicodeEx( UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
     if (!e.keycode && virtKey != VK_NONAME)
       {
 	WARN_(key)("Unknown virtual key %X !!!\n", virtKey);
-        pthread_mutex_unlock( &kbd_mutex );
+        LeaveCriticalSection( &kbd_section );
 	return 0;
       }
     else TRACE_(key)("Found keycode %u\n",e.keycode);
@@ -2467,11 +2470,11 @@ INT X11DRV_ToUnicodeEx( UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
         TRACE_(key)("XmbLookupString needs %d byte(s)\n", ret);
         if (status == XBufferOverflow)
         {
-            lpChar = malloc( ret );
+            lpChar = HeapAlloc(GetProcessHeap(), 0, ret);
             if (lpChar == NULL)
             {
                 ERR_(key)("Failed to allocate memory!\n");
-                pthread_mutex_unlock( &kbd_mutex );
+                LeaveCriticalSection( &kbd_section );
                 return 0;
             }
             ret = XmbLookupString(xic, &e, lpChar, ret, &keysym, &status);
@@ -2519,7 +2522,7 @@ INT X11DRV_ToUnicodeEx( UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
 	dead_char = KEYBOARD_MapDeadKeysym(keysym);
 	if (dead_char)
         {
-	    ntdll_umbstowcs( &dead_char, 1, bufW, bufW_size );
+	    MultiByteToWideChar(CP_UNIXCP, 0, &dead_char, 1, bufW, bufW_size);
 	    ret = -1;
             goto found;
         }
@@ -2615,15 +2618,15 @@ INT X11DRV_ToUnicodeEx( UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
 	if(ret)
 	{
 	    TRACE_(key)("Translating char 0x%02x to unicode\n", *(BYTE *)lpChar);
-            ret = ntdll_umbstowcs( lpChar, ret, bufW, bufW_size );
+	    ret = MultiByteToWideChar(CP_UNIXCP, 0, lpChar, ret, bufW, bufW_size);
 	}
     }
 
 found:
     if (buf != lpChar)
-        free( lpChar );
+        HeapFree(GetProcessHeap(), 0, lpChar);
 
-    pthread_mutex_unlock( &kbd_mutex );
+    LeaveCriticalSection( &kbd_section );
 
     /* Null-terminate the buffer, if there's room.  MSDN clearly states that the
        caller must not assume this is done, but some programs (e.g. Audiosurf) do. */
@@ -2637,7 +2640,7 @@ found:
 /***********************************************************************
  *		Beep (X11DRV.@)
  */
-void X11DRV_Beep(void)
+void CDECL X11DRV_Beep(void)
 {
     XBell(gdi_display, 0);
 }
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 9e005881170..51a6828f10c 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -19,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <math.h>
@@ -50,10 +46,13 @@ MAKE_FUNCPTR(XcursorLibraryLoadCursor);
 
 #define NONAMELESSUNION
 #define OEMRESOURCE
+#include "windef.h"
+#include "winbase.h"
+#include "winreg.h"
 
 #include "x11drv.h"
-#include "winreg.h"
 #include "wine/server.h"
+#include "wine/unicode.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(cursor);
@@ -374,28 +373,25 @@ static BOOL grab_clipping_window( const RECT *clip )
 #if HAVE_X11_EXTENSIONS_XINPUT2_H
     static const WCHAR messageW[] = {'M','e','s','s','a','g','e',0};
     struct x11drv_thread_data *data = x11drv_thread_data();
-    UNICODE_STRING class_name;
     Window clip_window;
     HWND msg_hwnd = 0;
     POINT pos;
 
-    if (NtUserGetWindowThread( NtUserGetDesktopWindow(), NULL ) == GetCurrentThreadId())
+    if (GetWindowThreadProcessId( GetDesktopWindow(), NULL ) == GetCurrentThreadId())
         return TRUE;  /* don't clip in the desktop process */
 
     if (!data) return FALSE;
     if (!(clip_window = init_clip_window())) return TRUE;
 
-    RtlInitUnicodeString( &class_name, messageW );
-    if (!(msg_hwnd = NtUserCreateWindowEx( 0, &class_name, &class_name, NULL, 0, 0, 0, 0, 0,
-                                           HWND_MESSAGE, 0, NtCurrentTeb()->Peb->ImageBaseAddress,
-                                           NULL, 0, NULL, 0, FALSE )))
+    if (!(msg_hwnd = CreateWindowW( messageW, NULL, 0, 0, 0, 0, 0, HWND_MESSAGE, 0,
+                                    GetModuleHandleW(0), NULL )))
         return TRUE;
 
     if (keyboard_grabbed)
     {
         WARN( "refusing to clip to %s\n", wine_dbgstr_rect(clip) );
         last_clip_refused = TRUE;
-        last_clip_foreground_window = NtUserGetForegroundWindow();
+        last_clip_foreground_window = GetForegroundWindow();
         last_clip_rect = *clip;
         return FALSE;
     }
@@ -410,8 +406,8 @@ static BOOL grab_clipping_window( const RECT *clip )
     if (data->xi2_state != xi_enabled)
     {
         WARN( "XInput2 not supported, refusing to clip to %s\n", wine_dbgstr_rect(clip) );
-        NtUserDestroyWindow( msg_hwnd );
-        NtUserClipCursor( NULL );
+        DestroyWindow( msg_hwnd );
+        ClipCursor( NULL );
         return TRUE;
     }
 
@@ -436,14 +432,14 @@ static BOOL grab_clipping_window( const RECT *clip )
     if (!clipping_cursor)
     {
         disable_xinput2();
-        NtUserDestroyWindow( msg_hwnd );
+        DestroyWindow( msg_hwnd );
         return FALSE;
     }
     clip_rect = *clip;
     if (!data->clip_hwnd) sync_window_cursor( clip_window );
     InterlockedExchangePointer( (void **)&cursor_window, msg_hwnd );
     data->clip_hwnd = msg_hwnd;
-    send_notify_message( NtUserGetDesktopWindow(), WM_X11DRV_CLIP_CURSOR_NOTIFY, 0, (LPARAM)msg_hwnd );
+    SendNotifyMessageW( GetDesktopWindow(), WM_X11DRV_CLIP_CURSOR_NOTIFY, 0, (LPARAM)msg_hwnd );
     return TRUE;
 #else
     WARN( "XInput2 was not available at compile time\n" );
@@ -467,7 +463,7 @@ void ungrab_clipping_window(void)
     XUnmapWindow( display, clip_window );
     if (clipping_cursor) XUngrabPointer( display, CurrentTime );
     clipping_cursor = FALSE;
-    send_notify_message( NtUserGetDesktopWindow(), WM_X11DRV_CLIP_CURSOR_NOTIFY, 0, 0 );
+    SendNotifyMessageW( GetDesktopWindow(), WM_X11DRV_CLIP_CURSOR_NOTIFY, 0, 0 );
 }
 
 /***********************************************************************
@@ -478,7 +474,7 @@ void ungrab_clipping_window(void)
 void reset_clipping_window(void)
 {
     ungrab_clipping_window();
-    NtUserClipCursor( NULL );  /* make sure the clip rectangle is reset too */
+    ClipCursor( NULL );  /* make sure the clip rectangle is reset too */
 }
 
 /***********************************************************************
@@ -490,9 +486,9 @@ void reset_clipping_window(void)
 void retry_grab_clipping_window(void)
 {
     if (clipping_cursor)
-        NtUserClipCursor( &clip_rect );
-    else if (last_clip_refused && NtUserGetForegroundWindow() == last_clip_foreground_window)
-        NtUserClipCursor( &last_clip_rect );
+        ClipCursor( &clip_rect );
+    else if (last_clip_refused && GetForegroundWindow() == last_clip_foreground_window)
+        ClipCursor( &last_clip_rect );
 }
 
 /***********************************************************************
@@ -504,22 +500,22 @@ LRESULT clip_cursor_notify( HWND hwnd, HWND prev_clip_hwnd, HWND new_clip_hwnd )
 {
     struct x11drv_thread_data *data = x11drv_init_thread_data();
 
-    if (hwnd == NtUserGetDesktopWindow())  /* change the clip window stored in the desktop process */
+    if (hwnd == GetDesktopWindow())  /* change the clip window stored in the desktop process */
     {
         static HWND clip_hwnd;
 
         HWND prev = clip_hwnd;
         clip_hwnd = new_clip_hwnd;
         if (prev || new_clip_hwnd) TRACE( "clip hwnd changed from %p to %p\n", prev, new_clip_hwnd );
-        if (prev) send_notify_message( prev, WM_X11DRV_CLIP_CURSOR_NOTIFY, (WPARAM)prev, 0 );
+        if (prev) SendNotifyMessageW( prev, WM_X11DRV_CLIP_CURSOR_NOTIFY, (WPARAM)prev, 0 );
     }
     else if (hwnd == data->clip_hwnd)  /* this is a notification that clipping has been reset */
     {
         TRACE( "clip hwnd reset from %p\n", hwnd );
         data->clip_hwnd = 0;
-        data->clip_reset = NtGetTickCount();
+        data->clip_reset = GetTickCount();
         disable_xinput2();
-        NtUserDestroyWindow( hwnd );
+        DestroyWindow( hwnd );
     }
     else if (prev_clip_hwnd)
     {
@@ -527,7 +523,7 @@ LRESULT clip_cursor_notify( HWND hwnd, HWND prev_clip_hwnd, HWND new_clip_hwnd )
          * dangling clip window.
          */
         TRACE( "destroying old clip hwnd %p\n", prev_clip_hwnd );
-        NtUserDestroyWindow( prev_clip_hwnd );
+        DestroyWindow( prev_clip_hwnd );
     }
     return 0;
 }
@@ -546,27 +542,27 @@ BOOL clip_fullscreen_window( HWND hwnd, BOOL reset )
     DWORD style;
     BOOL fullscreen;
 
-    if (hwnd == NtUserGetDesktopWindow()) return FALSE;
-    style = NtUserGetWindowLongW( hwnd, GWL_STYLE );
+    if (hwnd == GetDesktopWindow()) return FALSE;
+    style = GetWindowLongW( hwnd, GWL_STYLE );
     if (!(style & WS_VISIBLE)) return FALSE;
     if ((style & (WS_POPUP | WS_CHILD)) == WS_CHILD) return FALSE;
     /* maximized windows don't count as full screen */
     if ((style & WS_MAXIMIZE) && (style & WS_CAPTION) == WS_CAPTION) return FALSE;
     if (!(data = get_win_data( hwnd ))) return FALSE;
-    fullscreen = NtUserIsWindowRectFullScreen( &data->whole_rect );
+    fullscreen = is_window_rect_full_screen( &data->whole_rect );
     release_win_data( data );
     if (!fullscreen) return FALSE;
     if (!(thread_data = x11drv_thread_data())) return FALSE;
-    if (NtGetTickCount() - thread_data->clip_reset < 1000) return FALSE;
+    if (GetTickCount() - thread_data->clip_reset < 1000) return FALSE;
     if (!reset && clipping_cursor && thread_data->clip_hwnd) return FALSE;  /* already clipping */
 
-    monitor = NtUserMonitorFromWindow( hwnd, MONITOR_DEFAULTTONEAREST );
+    monitor = MonitorFromWindow( hwnd, MONITOR_DEFAULTTONEAREST );
     if (!monitor) return FALSE;
     monitor_info.cbSize = sizeof(monitor_info);
-    if (!NtUserGetMonitorInfo( monitor, &monitor_info )) return FALSE;
+    if (!GetMonitorInfoW( monitor, &monitor_info )) return FALSE;
     if (!grab_fullscreen)
     {
-        RECT virtual_rect = NtUserGetVirtualScreenRect();
+        RECT virtual_rect = get_virtual_screen_rect();
         if (!EqualRect( &monitor_info.rcMonitor, &virtual_rect )) return FALSE;
         if (is_virtual_desktop()) return FALSE;
     }
@@ -623,9 +619,9 @@ static void map_event_coords( HWND hwnd, Window window, Window event_root, int x
                 pt.y += data->whole_rect.top - data->client_rect.top;
             }
 
-            if (NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL)
+            if (GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL)
                 pt.x = data->client_rect.right - data->client_rect.left - 1 - pt.x;
-            NtUserMapWindowPoints( hwnd, 0, &pt, 1 );
+            MapWindowPoints( hwnd, 0, &pt, 1 );
         }
         release_win_data( data );
     }
@@ -673,10 +669,10 @@ static void send_mouse_input( HWND hwnd, Window window, unsigned int state, INPU
     }
     release_win_data( data );
 
-    if (hwnd != NtUserGetDesktopWindow())
+    if (hwnd != GetDesktopWindow())
     {
-        hwnd = NtUserGetAncestor( hwnd, GA_ROOT );
-        if ((input->u.mi.dwFlags & (MOUSEEVENTF_LEFTDOWN|MOUSEEVENTF_RIGHTDOWN)) && hwnd == NtUserGetForegroundWindow())
+        hwnd = GetAncestor( hwnd, GA_ROOT );
+        if ((input->u.mi.dwFlags & (MOUSEEVENTF_LEFTDOWN|MOUSEEVENTF_RIGHTDOWN)) && hwnd == GetForegroundWindow())
             clip_fullscreen_window( hwnd, FALSE );
     }
 
@@ -732,15 +728,15 @@ static XcursorImage *create_xcursor_frame( HDC hdc, const ICONINFOEXW *iinfo, HA
     image->yhot = iinfo->yHotspot;
 
     image->delay = 100; /* fallback delay, 100 ms */
-    if (NtUserGetCursorFrameInfo(icon, istep, &delay_jiffies, &num_steps) != 0)
+    if (GetCursorFrameInfo(icon, 0x0 /* unknown parameter */, istep, &delay_jiffies, &num_steps) != 0)
         image->delay = (100 * delay_jiffies) / 6; /* convert jiffies (1/60s) to milliseconds */
     else
         WARN("Failed to retrieve animated cursor frame-rate for frame %d.\n", istep);
 
     /* draw the cursor frame to a temporary buffer then copy it into the XcursorImage */
     memset( color_bits, 0x00, color_size );
-    NtGdiSelectBitmap( hdc, hbmColor );
-    if (!NtUserDrawIconEx( hdc, 0, 0, icon, width, height, istep, NULL, DI_NORMAL ))
+    SelectObject( hdc, hbmColor );
+    if (!DrawIconEx( hdc, 0, 0, icon, width, height, istep, NULL, DI_NORMAL ))
     {
         TRACE("Could not draw frame %d (walk past end of frames).\n", istep);
         goto cleanup;
@@ -758,8 +754,8 @@ static XcursorImage *create_xcursor_frame( HDC hdc, const ICONINFOEXW *iinfo, HA
 
         /* draw the cursor mask to a temporary buffer */
         memset( mask_bits, 0xFF, mask_size );
-        NtGdiSelectBitmap( hdc, hbmMask );
-        if (!NtUserDrawIconEx( hdc, 0, 0, icon, width, height, istep, NULL, DI_MASK ))
+        SelectObject( hdc, hbmMask );
+        if (!DrawIconEx( hdc, 0, 0, icon, width, height, istep, NULL, DI_MASK ))
         {
             ERR("Failed to draw frame mask %d.\n", istep);
             goto cleanup;
@@ -794,11 +790,11 @@ static Cursor create_xcursor_cursor( HDC hdc, const ICONINFOEXW *iinfo, HANDLE i
     Cursor cursor = 0;
 
     /* Retrieve the number of frames to render */
-    if (!NtUserGetCursorFrameInfo(icon, 0, &delay_jiffies, &nFrames)) return 0;
-    if (!(imgs = calloc( 1, sizeof(XcursorImage*) * nFrames ))) return 0;
+    if (!GetCursorFrameInfo(icon, 0x0 /* unknown parameter */, 0, &delay_jiffies, &nFrames)) return 0;
+    if (!(imgs = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(XcursorImage*)*nFrames ))) return 0;
 
     /* Allocate all of the resources necessary to obtain a cursor frame */
-    if (!(info = malloc( FIELD_OFFSET( BITMAPINFO, bmiColors[256] )))) goto cleanup;
+    if (!(info = HeapAlloc( GetProcessHeap(), 0, FIELD_OFFSET( BITMAPINFO, bmiColors[256] )))) goto cleanup;
     info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     info->bmiHeader.biWidth = width;
     info->bmiHeader.biHeight = -height;
@@ -811,7 +807,7 @@ static Cursor create_xcursor_cursor( HDC hdc, const ICONINFOEXW *iinfo, HANDLE i
     info->bmiHeader.biBitCount = 32;
     color_size = width * height * 4;
     info->bmiHeader.biSizeImage = color_size;
-    hbmColor = NtGdiCreateDIBSection( hdc, NULL, 0, info, DIB_RGB_COLORS, 0, 0, 0, (void **)&color_bits );
+    hbmColor = CreateDIBSection( hdc, info, DIB_RGB_COLORS, (VOID **) &color_bits, NULL, 0);
     if (!hbmColor)
     {
         ERR("Failed to create DIB section for cursor color data!\n");
@@ -829,7 +825,7 @@ static Cursor create_xcursor_cursor( HDC hdc, const ICONINFOEXW *iinfo, HANDLE i
 
     mask_size = ((width + 31) / 32 * 4) * height; /* width_bytes * height */
     info->bmiHeader.biSizeImage = mask_size;
-    hbmMask = NtGdiCreateDIBSection( hdc, NULL, 0, info, DIB_RGB_COLORS, 0, 0, 0, (void **)&mask_bits );
+    hbmMask = CreateDIBSection( hdc, info, DIB_RGB_COLORS, (VOID **) &mask_bits, NULL, 0);
     if (!hbmMask)
     {
         ERR("Failed to create DIB section for cursor mask data!\n");
@@ -852,7 +848,7 @@ static Cursor create_xcursor_cursor( HDC hdc, const ICONINFOEXW *iinfo, HANDLE i
         images->images[images->nimage] = imgs[images->nimage];
     cursor = pXcursorImagesLoadCursor( gdi_display, images );
     pXcursorImagesDestroy( images ); /* Note: this frees each individual frame (calls XcursorImageDestroy) */
-    free( imgs );
+    HeapFree( GetProcessHeap(), 0, imgs );
     imgs = NULL;
 
 cleanup:
@@ -861,12 +857,12 @@ cleanup:
         /* Failed to produce a cursor, free previously allocated frames */
         for (i=0; i<nFrames && imgs[i]; i++)
             pXcursorImageDestroy( imgs[i] );
-        free( imgs );
+        HeapFree( GetProcessHeap(), 0, imgs );
     }
     /* Cleanup all of the resources used to obtain the frame data */
-    if (hbmColor) NtGdiDeleteObjectApp( hbmColor );
-    if (hbmMask) NtGdiDeleteObjectApp( hbmMask );
-    free( info );
+    if (hbmColor) DeleteObject( hbmColor );
+    if (hbmMask) DeleteObject( hbmMask );
+    HeapFree( GetProcessHeap(), 0, info );
     return cursor;
 }
 
@@ -1057,53 +1053,47 @@ static int find_fallback_shape( const char *name )
  */
 static Cursor create_xcursor_system_cursor( const ICONINFOEXW *info )
 {
+    static const WCHAR idW[] = {'%','h','u',0};
     const struct system_cursors *cursors;
-    const WCHAR *module;
     unsigned int i;
     Cursor cursor = 0;
+    HMODULE module;
     HKEY key;
     const char * const *names = NULL;
-    WCHAR *p, name[MAX_PATH * 2];
+    WCHAR *p, name[MAX_PATH * 2], valueW[64];
     char valueA[64];
+    DWORD ret;
 
     if (!info->szModName[0]) return 0;
 
-    p = wcsrchr( info->szModName, '\\' );
-    wcscpy( name, p ? p + 1 : info->szModName );
-    p = name + lstrlenW( name );
+    p = strrchrW( info->szModName, '\\' );
+    strcpyW( name, p ? p + 1 : info->szModName );
+    p = name + strlenW( name );
     *p++ = ',';
-    if (info->szResName[0]) wcscpy( p, info->szResName );
-    else
-    {
-        char buf[16];
-        sprintf( buf, "%hu", info->wResID );
-        asciiz_to_unicode( p, buf );
-    }
+    if (info->szResName[0]) strcpyW( p, info->szResName );
+    else sprintfW( p, idW, info->wResID );
     valueA[0] = 0;
 
     /* @@ Wine registry key: HKCU\Software\Wine\X11 Driver\Cursors */
-    if ((key = open_hkcu_key( "Software\\Wine\\X11 Driver\\Cursors" )))
+    if (!RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\X11 Driver\\Cursors", &key ))
     {
-        char buffer[4096];
-        KEY_VALUE_PARTIAL_INFORMATION *value = (void *)buffer;
-        DWORD size = query_reg_value( key, NULL, value, sizeof(buffer) );
-        NtClose( key );
-        if (size && value->Type == REG_SZ)
+        DWORD size = sizeof(valueW);
+        ret = RegQueryValueExW( key, name, NULL, NULL, (BYTE *)valueW, &size );
+        RegCloseKey( key );
+        if (!ret)
         {
-            const WCHAR *valueW = (const WCHAR *)value->Data;
             if (!valueW[0]) return 0; /* force standard cursor */
-            if (!ntdll_wcstoumbs( valueW, lstrlenW(valueW) + 1, valueA, sizeof(valueA), FALSE ))
+            if (!WideCharToMultiByte( CP_UNIXCP, 0, valueW, -1, valueA, sizeof(valueA), NULL, NULL ))
                 valueA[0] = 0;
             goto done;
         }
     }
 
     if (info->szResName[0]) goto done;  /* only integer resources are supported here */
+    if (!(module = GetModuleHandleW( info->szModName ))) goto done;
 
-    if ((module = wcsrchr( info->szModName, '\\' ))) module++;
-    else module = info->szModName;
     for (i = 0; i < ARRAY_SIZE( module_cursors ); i++)
-        if (!wcsicmp( module, module_cursors[i].name )) break;
+        if (GetModuleHandleW( module_cursors[i].name ) == module) break;
     if (i == ARRAY_SIZE( module_cursors )) goto done;
 
     cursors = module_cursors[i].cursors;
@@ -1172,9 +1162,8 @@ static Cursor create_xlib_monochrome_cursor( HDC hdc, const ICONINFOEXW *icon, i
     info->bmiHeader.biClrUsed = 0;
     info->bmiHeader.biClrImportant = 0;
 
-    if (!(mask_bits = malloc( info->bmiHeader.biSizeImage ))) goto done;
-    if (!NtGdiGetDIBitsInternal( hdc, icon->hbmMask, 0, height * 2, mask_bits, info,
-                                 DIB_RGB_COLORS, 0, 0 )) goto done;
+    if (!(mask_bits = HeapAlloc( GetProcessHeap(), 0, info->bmiHeader.biSizeImage ))) goto done;
+    if (!GetDIBits( hdc, icon->hbmMask, 0, height * 2, mask_bits, info, DIB_RGB_COLORS )) goto done;
 
     vis.depth = 1;
     bits.ptr = mask_bits;
@@ -1229,31 +1218,10 @@ static Cursor create_xlib_monochrome_cursor( HDC hdc, const ICONINFOEXW *icon, i
     XFreePixmap( gdi_display, mask_pixmap );
 
 done:
-    free( mask_bits );
+    HeapFree( GetProcessHeap(), 0, mask_bits );
     return cursor;
 }
 
-static BOOL get_icon_info( HICON handle, ICONINFOEXW *ret )
-{
-    UNICODE_STRING module, res_name;
-    ICONINFO info;
-
-    module.Buffer = ret->szModName;
-    module.MaximumLength = sizeof(ret->szModName) - sizeof(WCHAR);
-    res_name.Buffer = ret->szResName;
-    res_name.MaximumLength = sizeof(ret->szResName) - sizeof(WCHAR);
-    if (!NtUserGetIconInfo( handle, &info, &module, &res_name, NULL, 0 )) return FALSE;
-    ret->fIcon    = info.fIcon;
-    ret->xHotspot = info.xHotspot;
-    ret->yHotspot = info.yHotspot;
-    ret->hbmColor = info.hbmColor;
-    ret->hbmMask  = info.hbmMask;
-    ret->wResID   = res_name.Length ? 0 : LOWORD( res_name.Buffer );
-    ret->szModName[module.Length] = 0;
-    ret->szResName[res_name.Length] = 0;
-    return TRUE;
-}
-
 /***********************************************************************
  *		create_xlib_load_mono_cursor
  *
@@ -1269,11 +1237,12 @@ static Cursor create_xlib_load_mono_cursor( HDC hdc, HANDLE handle, int width, i
     if (!(mono = CopyImage( handle, IMAGE_CURSOR, width, height, LR_MONOCHROME | LR_COPYFROMRESOURCE )))
         return None;
 
-    if (get_icon_info( mono, &info ))
+    info.cbSize = sizeof(info);
+    if (GetIconInfoExW( mono, &info ))
     {
         if (!info.hbmColor)
         {
-            NtGdiExtGetObjectW( info.hbmMask, sizeof(bm), &bm );
+            GetObjectW( info.hbmMask, sizeof(bm), &bm );
             bm.bmHeight = max( 1, bm.bmHeight / 2 );
             /* make sure hotspot is valid */
             if (info.xHotspot >= bm.bmWidth || info.yHotspot >= bm.bmHeight)
@@ -1283,10 +1252,10 @@ static Cursor create_xlib_load_mono_cursor( HDC hdc, HANDLE handle, int width, i
             }
             cursor = create_xlib_monochrome_cursor( hdc, &info, bm.bmWidth, bm.bmHeight );
         }
-        else NtGdiDeleteObjectApp( info.hbmColor );
-        NtGdiDeleteObjectApp( info.hbmMask );
+        else DeleteObject( info.hbmColor );
+        DeleteObject( info.hbmMask );
     }
-    NtUserDestroyCursor( mono, 0 );
+    DestroyCursor( mono );
     return cursor;
 }
 
@@ -1323,15 +1292,14 @@ static Cursor create_xlib_color_cursor( HDC hdc, const ICONINFOEXW *icon, int wi
     info->bmiHeader.biClrUsed = 0;
     info->bmiHeader.biClrImportant = 0;
 
-    if (!(mask_bits = malloc( info->bmiHeader.biSizeImage ))) goto done;
-    if (!NtGdiGetDIBitsInternal( hdc, icon->hbmMask, 0, height, mask_bits, info,
-                                 DIB_RGB_COLORS, 0, 0 )) goto done;
+    if (!(mask_bits = HeapAlloc( GetProcessHeap(), 0, info->bmiHeader.biSizeImage ))) goto done;
+    if (!GetDIBits( hdc, icon->hbmMask, 0, height, mask_bits, info, DIB_RGB_COLORS )) goto done;
 
     info->bmiHeader.biBitCount = 32;
     info->bmiHeader.biSizeImage = width * height * 4;
-    if (!(color_bits = malloc( info->bmiHeader.biSizeImage ))) goto done;
-    if (!(xor_bits = calloc( 1, width_bytes * height ))) goto done;
-    NtGdiGetDIBitsInternal( hdc, icon->hbmColor, 0, height, color_bits, info, DIB_RGB_COLORS, 0, 0 );
+    if (!(color_bits = HeapAlloc( GetProcessHeap(), 0, info->bmiHeader.biSizeImage ))) goto done;
+    if (!(xor_bits = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, width_bytes * height ))) goto done;
+    GetDIBits( hdc, icon->hbmColor, 0, height, color_bits, info, DIB_RGB_COLORS );
 
     /* compute fg/bg color and xor bitmap based on average of the color values */
 
@@ -1418,9 +1386,9 @@ static Cursor create_xlib_color_cursor( HDC hdc, const ICONINFOEXW *icon, int wi
     XFreePixmap( gdi_display, xor_pixmap );
 
 done:
-    free( color_bits );
-    free( xor_bits );
-    free( mask_bits );
+    HeapFree( GetProcessHeap(), 0, color_bits );
+    HeapFree( GetProcessHeap(), 0, xor_bits );
+    HeapFree( GetProcessHeap(), 0, mask_bits );
     return cursor;
 }
 
@@ -1438,16 +1406,17 @@ static Cursor create_cursor( HANDLE handle )
 
     if (!handle) return get_empty_cursor();
 
-    if (!get_icon_info( handle, &info )) return 0;
+    info.cbSize = sizeof(info);
+    if (!GetIconInfoExW( handle, &info )) return 0;
 
     if (use_system_cursors && (cursor = create_xcursor_system_cursor( &info )))
     {
-        NtGdiDeleteObjectApp( info.hbmColor );
-        NtGdiDeleteObjectApp( info.hbmMask );
+        DeleteObject( info.hbmColor );
+        DeleteObject( info.hbmMask );
         return cursor;
     }
 
-    NtGdiExtGetObjectW( info.hbmMask, sizeof(bm), &bm );
+    GetObjectW( info.hbmMask, sizeof(bm), &bm );
     if (!info.hbmColor) bm.bmHeight = max( 1, bm.bmHeight / 2 );
 
     /* make sure hotspot is valid */
@@ -1457,7 +1426,7 @@ static Cursor create_cursor( HANDLE handle )
         info.yHotspot = bm.bmHeight / 2;
     }
 
-    hdc = NtGdiCreateCompatibleDC( 0 );
+    hdc = CreateCompatibleDC( 0 );
 
     if (info.hbmColor)
     {
@@ -1467,22 +1436,22 @@ static Cursor create_cursor( HANDLE handle )
 #endif
         if (!cursor) cursor = create_xlib_load_mono_cursor( hdc, handle, bm.bmWidth, bm.bmHeight );
         if (!cursor) cursor = create_xlib_color_cursor( hdc, &info, bm.bmWidth, bm.bmHeight );
-        NtGdiDeleteObjectApp( info.hbmColor );
+        DeleteObject( info.hbmColor );
     }
     else
     {
         cursor = create_xlib_monochrome_cursor( hdc, &info, bm.bmWidth, bm.bmHeight );
     }
 
-    NtGdiDeleteObjectApp( info.hbmMask );
-    NtGdiDeleteObjectApp( hdc );
+    DeleteObject( info.hbmMask );
+    DeleteDC( hdc );
     return cursor;
 }
 
 /***********************************************************************
  *		DestroyCursorIcon (X11DRV.@)
  */
-void X11DRV_DestroyCursorIcon( HCURSOR handle )
+void CDECL X11DRV_DestroyCursorIcon( HCURSOR handle )
 {
     Cursor cursor;
 
@@ -1497,20 +1466,20 @@ void X11DRV_DestroyCursorIcon( HCURSOR handle )
 /***********************************************************************
  *		SetCursor (X11DRV.@)
  */
-void X11DRV_SetCursor( HCURSOR handle )
+void CDECL X11DRV_SetCursor( HCURSOR handle )
 {
     if (InterlockedExchangePointer( (void **)&last_cursor, handle ) != handle ||
-        NtGetTickCount() - last_cursor_change > 100)
+        GetTickCount() - last_cursor_change > 100)
     {
-        last_cursor_change = NtGetTickCount();
-        if (cursor_window) send_notify_message( cursor_window, WM_X11DRV_SET_CURSOR, 0, (LPARAM)handle );
+        last_cursor_change = GetTickCount();
+        if (cursor_window) SendNotifyMessageW( cursor_window, WM_X11DRV_SET_CURSOR, 0, (LPARAM)handle );
     }
 }
 
 /***********************************************************************
  *		SetCursorPos (X11DRV.@)
  */
-BOOL X11DRV_SetCursorPos( INT x, INT y )
+BOOL CDECL X11DRV_SetCursorPos( INT x, INT y )
 {
     struct x11drv_thread_data *data = x11drv_init_thread_data();
     POINT pos = virtual_screen_to_root( x, y );
@@ -1545,7 +1514,7 @@ BOOL X11DRV_SetCursorPos( INT x, INT y )
 /***********************************************************************
  *		GetCursorPos (X11DRV.@)
  */
-BOOL X11DRV_GetCursorPos(LPPOINT pos)
+BOOL CDECL X11DRV_GetCursorPos(LPPOINT pos)
 {
     Display *display = thread_init_display();
     Window root, child;
@@ -1566,23 +1535,23 @@ BOOL X11DRV_GetCursorPos(LPPOINT pos)
 /***********************************************************************
  *		ClipCursor (X11DRV.@)
  */
-BOOL X11DRV_ClipCursor( LPCRECT clip )
+BOOL CDECL X11DRV_ClipCursor( LPCRECT clip )
 {
-    RECT virtual_rect = NtUserGetVirtualScreenRect();
+    RECT virtual_rect = get_virtual_screen_rect();
 
     if (!clip) clip = &virtual_rect;
 
     if (grab_pointer)
     {
-        HWND foreground = NtUserGetForegroundWindow();
+        HWND foreground = GetForegroundWindow();
         DWORD tid, pid;
 
         /* forward request to the foreground window if it's in a different thread */
-        tid = NtUserGetWindowThread( foreground, &pid );
+        tid = GetWindowThreadProcessId( foreground, &pid );
         if (tid && tid != GetCurrentThreadId() && pid == GetCurrentProcessId())
         {
             TRACE( "forwarding clip request to %p\n", foreground );
-            send_notify_message( foreground, WM_X11DRV_CLIP_CURSOR_REQUEST, FALSE, FALSE );
+            SendNotifyMessageW( foreground, WM_X11DRV_CLIP_CURSOR_REQUEST, FALSE, FALSE );
             return TRUE;
         }
 
@@ -1615,15 +1584,15 @@ LRESULT clip_cursor_request( HWND hwnd, BOOL fullscreen, BOOL reset )
 {
     RECT clip;
 
-    if (hwnd == NtUserGetDesktopWindow())
+    if (hwnd == GetDesktopWindow())
         WARN( "ignoring clip cursor request on desktop window.\n" );
-    else if (hwnd != NtUserGetForegroundWindow())
+    else if (hwnd != GetForegroundWindow())
         WARN( "ignoring clip cursor request on non-foreground window.\n" );
     else if (fullscreen)
         clip_fullscreen_window( hwnd, reset );
     else
     {
-        NtUserGetClipCursor( &clip );
+        GetClipCursor( &clip );
         X11DRV_ClipCursor( &clip );
     }
 
@@ -1645,12 +1614,12 @@ void move_resize_window( HWND hwnd, int dir )
 
     if (!(win = X11DRV_get_whole_window( hwnd ))) return;
 
-    pt = NtUserGetThreadInfo()->message_pos;
+    pt = GetMessagePos();
     pos = virtual_screen_to_root( (short)LOWORD( pt ), (short)HIWORD( pt ) );
 
-    if (NtUserGetKeyState( VK_LBUTTON ) & 0x8000) button = 1;
-    else if (NtUserGetKeyState( VK_MBUTTON ) & 0x8000) button = 2;
-    else if (NtUserGetKeyState( VK_RBUTTON ) & 0x8000) button = 3;
+    if (GetKeyState( VK_LBUTTON ) & 0x8000) button = 1;
+    else if (GetKeyState( VK_MBUTTON ) & 0x8000) button = 2;
+    else if (GetKeyState( VK_RBUTTON ) & 0x8000) button = 3;
 
     TRACE( "hwnd %p/%lx, pos %s, dir %d, button %d\n", hwnd, win, wine_dbgstr_point(&pos), dir, button );
 
@@ -1676,7 +1645,7 @@ void move_resize_window( HWND hwnd, int dir )
     /* (some apps don't like it if we return before the size/move is done) */
 
     if (!button) return;
-    send_message( hwnd, WM_ENTERSIZEMOVE, 0, 0 );
+    SendMessageW( hwnd, WM_ENTERSIZEMOVE, 0, 0 );
 
     for (;;)
     {
@@ -1695,26 +1664,26 @@ void move_resize_window( HWND hwnd, int dir )
             input.u.mi.dy          = pos.y;
             input.u.mi.mouseData   = button_up_data[button - 1];
             input.u.mi.dwFlags     = button_up_flags[button - 1] | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE;
-            input.u.mi.time        = NtGetTickCount();
+            input.u.mi.time        = GetTickCount();
             input.u.mi.dwExtraInfo = 0;
             __wine_send_input( hwnd, &input, NULL );
         }
 
-        while (NtUserPeekMessage( &msg, 0, 0, 0, PM_REMOVE ))
+        while (PeekMessageW( &msg, 0, 0, 0, PM_REMOVE ))
         {
-            if (!NtUserCallMsgFilter( &msg, MSGF_SIZE ))
+            if (!CallMsgFilterW( &msg, MSGF_SIZE ))
             {
-                NtUserTranslateMessage( &msg, 0 );
-                NtUserDispatchMessage( &msg );
+                TranslateMessage( &msg );
+                DispatchMessageW( &msg );
             }
         }
 
         if (!(xstate & (Button1Mask << (button - 1)))) break;
-        NtUserMsgWaitForMultipleObjectsEx( 0, NULL, 100, QS_ALLINPUT, 0 );
+        MsgWaitForMultipleObjects( 0, NULL, FALSE, 100, QS_ALLINPUT );
     }
 
     TRACE( "hwnd %p/%lx done\n", hwnd, win );
-    send_message( hwnd, WM_EXITSIZEMOVE, 0, 0 );
+    SendMessageW( hwnd, WM_EXITSIZEMOVE, 0, 0 );
 }
 
 
@@ -1881,7 +1850,7 @@ static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input )
     }
     if (event->deviceid != thread_data->xi2_current_slave) return FALSE;
 
-    virtual_rect = NtUserGetVirtualScreenRect();
+    virtual_rect = get_virtual_screen_rect();
 
     if (x->max <= x->min) x_scale = 1;
     else x_scale = (virtual_rect.right - virtual_rect.left) / (x->max - x->min);
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 91aef7f67be..567205f742c 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -23,10 +23,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <assert.h>
@@ -41,6 +37,7 @@
 #include "x11drv.h"
 #include "xcomposite.h"
 #include "winternl.h"
+#include "wine/heap.h"
 #include "wine/debug.h"
 
 #ifdef SONAME_LIBGL
@@ -277,7 +274,14 @@ static enum glx_swap_control_method swap_control_method = GLX_SWAP_CONTROL_NONE;
 static BOOL has_swap_control_tear = FALSE;
 static BOOL has_swap_method = FALSE;
 
-static pthread_mutex_t context_mutex = PTHREAD_MUTEX_INITIALIZER;
+static CRITICAL_SECTION context_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &context_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": context_section") }
+};
+static CRITICAL_SECTION context_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static const BOOL is_win64 = sizeof(void *) > sizeof(int);
 
@@ -470,7 +474,7 @@ static BOOL X11DRV_WineGL_InitOpenglInfo(void)
     gl_renderer = (const char *)opengl_funcs.gl.p_glGetString(GL_RENDERER);
     gl_version  = (const char *)opengl_funcs.gl.p_glGetString(GL_VERSION);
     str = (const char *) opengl_funcs.gl.p_glGetString(GL_EXTENSIONS);
-    glExtensions = malloc( strlen(str) + sizeof(legacy_extensions) );
+    glExtensions = HeapAlloc(GetProcessHeap(), 0, strlen(str)+sizeof(legacy_extensions));
     strcpy(glExtensions, str);
     strcat(glExtensions, legacy_extensions);
 
@@ -537,7 +541,7 @@ done:
 
 static void *opengl_handle;
 
-static void init_opengl(void)
+static BOOL WINAPI init_opengl( INIT_ONCE *once, void *param, void **context )
 {
     int error_base, event_base;
     unsigned int i;
@@ -549,7 +553,7 @@ static void init_opengl(void)
     {
         ERR( "Failed to load libGL: %s\n", dlerror() );
         ERR( "OpenGL support is disabled.\n");
-        return;
+        return TRUE;
     }
 
     for (i = 0; i < ARRAY_SIZE( opengl_func_names ); i++)
@@ -717,18 +721,19 @@ static void init_opengl(void)
 
     X11DRV_WineGL_LoadExtensions();
     init_pixel_formats( gdi_display );
-    return;
+    return TRUE;
 
 failed:
     dlclose(opengl_handle);
     opengl_handle = NULL;
+    return TRUE;
 }
 
 static BOOL has_opengl(void)
 {
-    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
-
-    return !pthread_once( &init_once, init_opengl );
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+    InitOnceExecuteOnce(&init_once, init_opengl, NULL, NULL);
+    return opengl_handle != NULL;
 }
 
 static const char *debugstr_fbconfig( GLXFBConfig fbconfig )
@@ -1026,7 +1031,7 @@ static void init_pixel_formats( Display *display )
     }
     TRACE("Found %d bitmap capable fbconfigs\n", bmp_formats);
 
-    list = calloc( 1, (nCfgs + bmp_formats) * sizeof(*list) );
+    list = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (nCfgs + bmp_formats) * sizeof(*list));
 
     /* Fill the pixel format list. Put onscreen formats at the top and offscreen ones at the bottom.
      * Do this as GLX doesn't guarantee that the list is sorted */
@@ -1168,7 +1173,7 @@ static void release_gl_drawable( struct gl_drawable *gl )
     default:
         break;
     }
-    free( gl );
+    HeapFree( GetProcessHeap(), 0, gl );
 }
 
 /* Mark any allocated context using the glx drawable 'old' to use 'new' */
@@ -1176,7 +1181,7 @@ static void mark_drawable_dirty( struct gl_drawable *old, struct gl_drawable *ne
 {
     struct wgl_context *ctx;
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     LIST_FOR_EACH_ENTRY( ctx, &context_list, struct wgl_context, entry )
     {
         if (old == ctx->drawables[0] || old == ctx->new_drawables[0])
@@ -1190,7 +1195,7 @@ static void mark_drawable_dirty( struct gl_drawable *old, struct gl_drawable *ne
             ctx->new_drawables[1] = grab_gl_drawable( new );
         }
     }
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
 }
 
 /* Given the current context, make sure its drawable is sync'd */
@@ -1198,7 +1203,7 @@ static inline void sync_context(struct wgl_context *context)
 {
     BOOL refresh = FALSE;
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     if (context->new_drawables[0])
     {
         release_gl_drawable( context->drawables[0] );
@@ -1221,7 +1226,7 @@ static inline void sync_context(struct wgl_context *context)
         else
             pglXMakeCurrent(gdi_display, context->drawables[0]->drawable, context->ctx);
     }
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
 }
 
 static BOOL set_swap_interval(GLXDrawable drawable, int interval)
@@ -1265,14 +1270,14 @@ static struct gl_drawable *get_gl_drawable( HWND hwnd, HDC hdc )
 {
     struct gl_drawable *gl;
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     if (hwnd && !XFindContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char **)&gl ))
         gl = grab_gl_drawable( gl );
     else if (hdc && !XFindContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char **)&gl ))
         gl = grab_gl_drawable( gl );
     else
         gl = NULL;
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
     return gl;
 }
 
@@ -1307,11 +1312,11 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel
     RECT rect;
     int width, height;
 
-    NtUserGetClientRect( hwnd, &rect );
+    GetClientRect( hwnd, &rect );
     width  = min( max( 1, rect.right ), 65535 );
     height = min( max( 1, rect.bottom ), 65535 );
 
-    if (!(gl = calloc( 1, sizeof(*gl) ))) return NULL;
+    if (!(gl = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*gl) ))) return NULL;
 
     /* Default GLX and WGL swap interval is 1, but in case of glXSwapIntervalSGI
      * there is no way to query it, so we have to store it here.
@@ -1322,8 +1327,7 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel
     gl->ref = 1;
     gl->mutable_pf = mutable_pf;
 
-    if (!known_child && !NtUserGetWindowRelative( hwnd, GW_CHILD ) &&
-        NtUserGetAncestor( hwnd, GA_PARENT ) == NtUserGetDesktopWindow())  /* childless top-level window */
+    if (!known_child && !GetWindow( hwnd, GW_CHILD ) && GetAncestor( hwnd, GA_PARENT ) == GetDesktopWindow())  /* childless top-level window */
     {
         gl->type = DC_GL_WINDOW;
         gl->window = create_client_window( hwnd, visual );
@@ -1361,18 +1365,18 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel
 
     if (!gl->drawable)
     {
-        free( gl );
+        HeapFree( GetProcessHeap(), 0, gl );
         return NULL;
     }
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     if (!XFindContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char **)&prev ))
     {
         gl->swap_interval = prev->swap_interval;
         release_gl_drawable( prev );
     }
     XSaveContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char *)grab_gl_drawable(gl) );
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
     return gl;
 }
 
@@ -1394,7 +1398,7 @@ static BOOL set_win_format( HWND hwnd, const struct wgl_pixel_format *format, BO
     XFlush( gdi_display );
     release_gl_drawable( gl );
 
-    NtUserSetWindowPixelFormat( hwnd, pixel_format_index( format ));
+    __wine_set_pixel_format( hwnd, pixel_format_index( format ));
     return TRUE;
 }
 
@@ -1403,11 +1407,11 @@ static BOOL set_pixel_format(HDC hdc, int format, BOOL allow_change)
 {
     const struct wgl_pixel_format *fmt;
     int value;
-    HWND hwnd = NtUserWindowFromDC( hdc );
+    HWND hwnd = WindowFromDC( hdc );
 
     TRACE("(%p,%d)\n", hdc, format);
 
-    if (!hwnd || hwnd == NtUserGetDesktopWindow())
+    if (!hwnd || hwnd == GetDesktopWindow())
     {
         WARN( "not a valid window DC %p/%p\n", hdc, hwnd );
         return FALSE;
@@ -1489,7 +1493,7 @@ void set_gl_drawable_parent( HWND hwnd, HWND parent )
         break;
     case DC_GL_CHILD_WIN:
     case DC_GL_PIXMAP_WIN:
-        if (parent == NtUserGetDesktopWindow()) break;
+        if (parent == GetDesktopWindow()) break;
         /* fall through */
     default:
         release_gl_drawable( old );
@@ -1504,7 +1508,7 @@ void set_gl_drawable_parent( HWND hwnd, HWND parent )
     else
     {
         destroy_gl_drawable( hwnd );
-        NtUserSetWindowPixelFormat( hwnd, 0 );
+        __wine_set_pixel_format( hwnd, 0 );
     }
     release_gl_drawable( old );
 }
@@ -1517,13 +1521,13 @@ void destroy_gl_drawable( HWND hwnd )
 {
     struct gl_drawable *gl;
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     if (!XFindContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char **)&gl ))
     {
         XDeleteContext( gdi_display, (XID)hwnd, gl_hwnd_context );
         release_gl_drawable( gl );
     }
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
 }
 
 
@@ -1680,7 +1684,7 @@ static int WINAPI glxdrv_wglGetPixelFormat( HDC hdc )
     struct gl_drawable *gl;
     int ret = 0;
 
-    if ((gl = get_gl_drawable( NtUserWindowFromDC( hdc ), hdc )))
+    if ((gl = get_gl_drawable( WindowFromDC( hdc ), hdc )))
     {
         ret = pixel_format_index( gl->format );
         /* Offscreen formats can't be used with traditional WGL calls.
@@ -1721,20 +1725,20 @@ static struct wgl_context * WINAPI glxdrv_wglCreateContext( HDC hdc )
     struct wgl_context *ret;
     struct gl_drawable *gl;
 
-    if (!(gl = get_gl_drawable( NtUserWindowFromDC( hdc ), hdc )))
+    if (!(gl = get_gl_drawable( WindowFromDC( hdc ), hdc )))
     {
         SetLastError( ERROR_INVALID_PIXEL_FORMAT );
         return NULL;
     }
 
-    if ((ret = calloc( 1, sizeof(*ret) )))
+    if ((ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret))))
     {
         ret->hdc = hdc;
         ret->fmt = gl->format;
         ret->ctx = create_glxcontext(gdi_display, ret, NULL);
-        pthread_mutex_lock( &context_mutex );
+        EnterCriticalSection( &context_section );
         list_add_head( &context_list, &ret->entry );
-        pthread_mutex_unlock( &context_mutex );
+        LeaveCriticalSection( &context_section );
     }
     release_gl_drawable( gl );
     TRACE( "%p -> %p\n", hdc, ret );
@@ -1750,7 +1754,7 @@ static BOOL WINAPI glxdrv_wglDeleteContext(struct wgl_context *ctx)
 
     TRACE("(%p)\n", ctx);
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     list_remove( &ctx->entry );
     LIST_FOR_EACH_ENTRY( pb, &pbuffer_list, struct wgl_pbuffer, entry )
     {
@@ -1759,15 +1763,14 @@ static BOOL WINAPI glxdrv_wglDeleteContext(struct wgl_context *ctx)
             pb->prev_context = pb->tmp_context = NULL;
         }
     }
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
 
     if (ctx->ctx) pglXDestroyContext( gdi_display, ctx->ctx );
     release_gl_drawable( ctx->drawables[0] );
     release_gl_drawable( ctx->drawables[1] );
     release_gl_drawable( ctx->new_drawables[0] );
     release_gl_drawable( ctx->new_drawables[1] );
-    free( ctx );
-    return TRUE;
+    return HeapFree( GetProcessHeap(), 0, ctx );
 }
 
 /***********************************************************************
@@ -1812,7 +1815,7 @@ static BOOL WINAPI glxdrv_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
         return TRUE;
     }
 
-    if ((gl = get_gl_drawable( NtUserWindowFromDC( hdc ), hdc )))
+    if ((gl = get_gl_drawable( WindowFromDC( hdc ), hdc )))
     {
         if (ctx->fmt != gl->format)
         {
@@ -1824,7 +1827,7 @@ static BOOL WINAPI glxdrv_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
         TRACE("hdc %p drawable %lx fmt %p ctx %p %s\n", hdc, gl->drawable, gl->format, ctx->ctx,
               debugstr_fbconfig( gl->format->fbconfig ));
 
-        pthread_mutex_lock( &context_mutex );
+        EnterCriticalSection( &context_section );
         ret = pglXMakeCurrent(gdi_display, gl->drawable, ctx->ctx);
         if (ret)
         {
@@ -1833,10 +1836,10 @@ static BOOL WINAPI glxdrv_wglMakeCurrent(HDC hdc, struct wgl_context *ctx)
             ctx->hdc = hdc;
             set_context_drawables( ctx, gl, gl );
             ctx->refresh_drawables = FALSE;
-            pthread_mutex_unlock( &context_mutex );
+            LeaveCriticalSection( &context_section );
             goto done;
         }
-        pthread_mutex_unlock( &context_mutex );
+        LeaveCriticalSection( &context_section );
     }
     SetLastError( ERROR_INVALID_HANDLE );
 
@@ -1865,11 +1868,11 @@ static BOOL X11DRV_wglMakeContextCurrentARB( HDC draw_hdc, HDC read_hdc, struct
 
     if (!pglXMakeContextCurrent) return FALSE;
 
-    if ((draw_gl = get_gl_drawable( NtUserWindowFromDC( draw_hdc ), draw_hdc )))
+    if ((draw_gl = get_gl_drawable( WindowFromDC( draw_hdc ), draw_hdc )))
     {
-        read_gl = get_gl_drawable( NtUserWindowFromDC( read_hdc ), read_hdc );
+        read_gl = get_gl_drawable( WindowFromDC( read_hdc ), read_hdc );
 
-        pthread_mutex_lock( &context_mutex );
+        EnterCriticalSection( &context_section );
         ret = pglXMakeContextCurrent(gdi_display, draw_gl->drawable,
                                      read_gl ? read_gl->drawable : 0, ctx->ctx);
         if (ret)
@@ -1879,10 +1882,10 @@ static BOOL X11DRV_wglMakeContextCurrentARB( HDC draw_hdc, HDC read_hdc, struct
             set_context_drawables( ctx, draw_gl, read_gl );
             ctx->refresh_drawables = FALSE;
             NtCurrentTeb()->glContext = ctx;
-            pthread_mutex_unlock( &context_mutex );
+            LeaveCriticalSection( &context_section );
             goto done;
         }
-        pthread_mutex_unlock( &context_mutex );
+        LeaveCriticalSection( &context_section );
     }
     SetLastError( ERROR_INVALID_HANDLE );
 done:
@@ -1947,7 +1950,7 @@ static void wglFinish(void)
     escape.gl_drawable = 0;
     escape.flush = FALSE;
 
-    if ((gl = get_gl_drawable( NtUserWindowFromDC( ctx->hdc ), 0 )))
+    if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
         {
@@ -1960,8 +1963,7 @@ static void wglFinish(void)
     }
 
     pglFinish();
-    if (escape.gl_drawable)
-        NtGdiExtEscape( ctx->hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    if (escape.gl_drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }
 
 static void wglFlush(void)
@@ -1974,7 +1976,7 @@ static void wglFlush(void)
     escape.gl_drawable = 0;
     escape.flush = FALSE;
 
-    if ((gl = get_gl_drawable( NtUserWindowFromDC( ctx->hdc ), 0 )))
+    if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
         {
@@ -1987,8 +1989,7 @@ static void wglFlush(void)
     }
 
     pglFlush();
-    if (escape.gl_drawable)
-        NtGdiExtEscape( ctx->hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    if (escape.gl_drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }
 
 static const GLubyte *wglGetString(GLenum name)
@@ -2009,13 +2010,13 @@ static struct wgl_context *X11DRV_wglCreateContextAttribsARB( HDC hdc, struct wg
 
     TRACE("(%p %p %p)\n", hdc, hShareContext, attribList);
 
-    if (!(gl = get_gl_drawable( NtUserWindowFromDC( hdc ), hdc )))
+    if (!(gl = get_gl_drawable( WindowFromDC( hdc ), hdc )))
     {
         SetLastError( ERROR_INVALID_PIXEL_FORMAT );
         return NULL;
     }
 
-    if ((ret = calloc( 1, sizeof(*ret) )))
+    if ((ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret))))
     {
         ret->hdc = hdc;
         ret->fmt = gl->format;
@@ -2081,14 +2082,14 @@ static struct wgl_context *X11DRV_wglCreateContextAttribsARB( HDC hdc, struct wg
         {
             /* In the future we should convert the GLX error to a win32 one here if needed */
             WARN("Context creation failed (error %#x).\n", err);
-            free( ret );
+            HeapFree( GetProcessHeap(), 0, ret );
             ret = NULL;
         }
         else
         {
-            pthread_mutex_lock( &context_mutex );
+            EnterCriticalSection( &context_section );
             list_add_head( &context_list, &ret->entry );
-            pthread_mutex_unlock( &context_mutex );
+            LeaveCriticalSection( &context_section );
         }
     }
 
@@ -2131,7 +2132,7 @@ static struct wgl_pbuffer *X11DRV_wglCreatePbufferARB( HDC hdc, int iPixelFormat
         return NULL;
     }
 
-    object = calloc( 1, sizeof(*object) );
+    object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
     if (NULL == object) {
         SetLastError(ERROR_NO_SYSTEM_RESOURCES);
         return NULL;
@@ -2282,14 +2283,14 @@ static struct wgl_pbuffer *X11DRV_wglCreatePbufferARB( HDC hdc, int iPixelFormat
         SetLastError(ERROR_NO_SYSTEM_RESOURCES);
         goto create_failed; /* unexpected error */
     }
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     list_add_head( &pbuffer_list, &object->entry );
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
     TRACE("->(%p)\n", object);
     return object;
 
 create_failed:
-    free( object );
+    HeapFree(GetProcessHeap(), 0, object);
     TRACE("->(FAILED)\n");
     return NULL;
 }
@@ -2303,13 +2304,13 @@ static BOOL X11DRV_wglDestroyPbufferARB( struct wgl_pbuffer *object )
 {
     TRACE("(%p)\n", object);
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     list_remove( &object->entry );
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
     pglXDestroyPbuffer(gdi_display, object->drawable);
     if (object->tmp_context)
         pglXDestroyContext(gdi_display, object->tmp_context);
-    free( object );
+    HeapFree(GetProcessHeap(), 0, object);
     return GL_TRUE;
 }
 
@@ -2324,12 +2325,12 @@ static HDC X11DRV_wglGetPbufferDCARB( struct wgl_pbuffer *object )
     struct gl_drawable *gl, *prev;
     HDC hdc;
 
-    hdc = NtGdiOpenDCW( NULL, NULL, NULL, 0, TRUE, NULL, NULL, NULL );
+    hdc = CreateDCA( "DISPLAY", NULL, NULL, NULL );
     if (!hdc) return 0;
 
-    if (!(gl = calloc( 1, sizeof(*gl) )))
+    if (!(gl = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*gl) )))
     {
-        NtGdiDeleteObjectApp( hdc );
+        DeleteDC( hdc );
         return 0;
     }
     gl->type = DC_GL_PBUFFER;
@@ -2337,17 +2338,17 @@ static HDC X11DRV_wglGetPbufferDCARB( struct wgl_pbuffer *object )
     gl->format = object->fmt;
     gl->ref = 1;
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     if (!XFindContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char **)&prev ))
         release_gl_drawable( prev );
     XSaveContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char *)gl );
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
 
     escape.code = X11DRV_SET_DRAWABLE;
     escape.drawable = object->drawable;
     escape.mode = IncludeInferiors;
     SetRect( &escape.dc_rect, 0, 0, object->width, object->height );
-    NtGdiExtEscape( hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    ExtEscape( hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 
     TRACE( "(%p)->(%p)\n", object, hdc );
     return hdc;
@@ -2453,7 +2454,7 @@ static int X11DRV_wglReleasePbufferDCARB( struct wgl_pbuffer *object, HDC hdc )
 
     TRACE("(%p, %p)\n", object, hdc);
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
 
     if (!XFindContext( gdi_display, (XID)hdc, gl_pbuffer_context, (char **)&gl ))
     {
@@ -2462,9 +2463,9 @@ static int X11DRV_wglReleasePbufferDCARB( struct wgl_pbuffer *object, HDC hdc )
     }
     else hdc = 0;
 
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
 
-    return hdc && NtGdiDeleteObjectApp(hdc);
+    return hdc && DeleteDC(hdc);
 }
 
 /**
@@ -2593,7 +2594,7 @@ static BOOL X11DRV_wglChoosePixelFormatARB( HDC hdc, const int *piAttribIList, c
         return GL_FALSE;
     }
 
-    if (!(formats = malloc( nCfgs * sizeof(*formats) )))
+    if (!(formats = heap_alloc(nCfgs * sizeof(*formats))))
     {
         ERR("No memory.\n");
         XFree(cfgs);
@@ -2643,7 +2644,7 @@ static BOOL X11DRV_wglChoosePixelFormatARB( HDC hdc, const int *piAttribIList, c
     for (i = 0; i < *nNumFormats; ++i)
         piFormats[i] = formats[i].format;
 
-    free( formats );
+    heap_free(formats);
     XFree(cfgs);
     return GL_TRUE;
 }
@@ -2927,7 +2928,7 @@ static BOOL X11DRV_wglGetPixelFormatAttribfvARB( HDC hdc, int iPixelFormat, int
     TRACE("(%p, %d, %d, %d, %p, %p)\n", hdc, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
 
     /* Allocate a temporary array to store integer values */
-    attr = malloc( nAttributes * sizeof(int) );
+    attr = HeapAlloc(GetProcessHeap(), 0, nAttributes * sizeof(int));
     if (!attr) {
         ERR("couldn't allocate %d array\n", nAttributes);
         return GL_FALSE;
@@ -2943,7 +2944,7 @@ static BOOL X11DRV_wglGetPixelFormatAttribfvARB( HDC hdc, int iPixelFormat, int
         }
     }
 
-    free( attr );
+    HeapFree(GetProcessHeap(), 0, attr);
     return ret;
 }
 
@@ -3052,7 +3053,7 @@ static int X11DRV_wglGetSwapIntervalEXT(void)
 
     TRACE("()\n");
 
-    if (!(gl = get_gl_drawable( NtUserWindowFromDC( ctx->hdc ), ctx->hdc )))
+    if (!(gl = get_gl_drawable( WindowFromDC( ctx->hdc ), ctx->hdc )))
     {
         /* This can't happen because a current WGL context is required to get
          * here. Likely the application is buggy.
@@ -3089,13 +3090,13 @@ static BOOL X11DRV_wglSwapIntervalEXT(int interval)
         return FALSE;
     }
 
-    if (!(gl = get_gl_drawable( NtUserWindowFromDC( ctx->hdc ), ctx->hdc )))
+    if (!(gl = get_gl_drawable( WindowFromDC( ctx->hdc ), ctx->hdc )))
     {
         SetLastError(ERROR_DC_NOT_FOUND);
         return FALSE;
     }
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     ret = set_swap_interval(gl->drawable, interval);
     gl->refresh_swap_interval = FALSE;
     if (ret)
@@ -3103,7 +3104,7 @@ static BOOL X11DRV_wglSwapIntervalEXT(int interval)
     else
         SetLastError(ERROR_DC_NOT_FOUND);
 
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
     release_gl_drawable(gl);
 
     return ret;
@@ -3314,19 +3315,19 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
     escape.gl_drawable = 0;
     escape.flush = !pglXWaitForSbcOML;
 
-    if (!(gl = get_gl_drawable( NtUserWindowFromDC( hdc ), hdc )))
+    if (!(gl = get_gl_drawable( WindowFromDC( hdc ), hdc )))
     {
         SetLastError( ERROR_INVALID_HANDLE );
         return FALSE;
     }
 
-    pthread_mutex_lock( &context_mutex );
+    EnterCriticalSection( &context_section );
     if (gl->refresh_swap_interval)
     {
         set_swap_interval(gl->drawable, gl->swap_interval);
         gl->refresh_swap_interval = FALSE;
     }
-    pthread_mutex_unlock( &context_mutex );
+    LeaveCriticalSection( &context_section );
 
     switch (gl->type)
     {
@@ -3371,8 +3372,7 @@ static BOOL WINAPI glxdrv_wglSwapBuffers( HDC hdc )
 
     release_gl_drawable( gl );
 
-    if (escape.gl_drawable)
-        NtGdiExtEscape( ctx->hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    if (escape.gl_drawable) ExtEscape( ctx->hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
     return TRUE;
 }
 
diff --git a/dlls/winex11.drv/palette.c b/dlls/winex11.drv/palette.c
index 7845985dbb0..8fbd7820c95 100644
--- a/dlls/winex11.drv/palette.c
+++ b/dlls/winex11.drv/palette.c
@@ -18,10 +18,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <stdarg.h>
@@ -73,7 +69,14 @@ static unsigned char X11DRV_PALETTE_freeList[256];
 
 static XContext palette_context;  /* X context to associate a color mapping to a palette */
 
-static pthread_mutex_t palette_mutex = PTHREAD_MUTEX_INITIALIZER;
+static CRITICAL_SECTION palette_cs;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &palette_cs,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": palette_cs") }
+};
+static CRITICAL_SECTION palette_cs = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 /**********************************************************************/
 
@@ -334,9 +337,9 @@ int X11DRV_PALETTE_Init(void)
     }
     else
     {
-        get_palette_entries( GetStockObject(DEFAULT_PALETTE), 0, NB_RESERVED_COLORS, sys_pal_template );
+        GetPaletteEntries( GetStockObject(DEFAULT_PALETTE), 0, NB_RESERVED_COLORS, sys_pal_template );
 
-        if ((mapping = calloc( 1, sizeof(int) * NB_RESERVED_COLORS )))
+        if ((mapping = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(int) * NB_RESERVED_COLORS )))
             palette_set_mapping( GetStockObject(DEFAULT_PALETTE), mapping );
 
         if (X11DRV_PALETTE_PaletteFlags & X11DRV_PALETTE_PRIVATE)
@@ -368,8 +371,7 @@ static BOOL X11DRV_PALETTE_BuildPrivateMap( const PALETTEENTRY *sys_pal_template
     XColor color;
     int i;
 
-    if((COLOR_sysPal = malloc( sizeof(PALETTEENTRY) * palette_size )) == NULL)
-    {
+    if((COLOR_sysPal = HeapAlloc(GetProcessHeap(), 0, sizeof(PALETTEENTRY)*palette_size)) == NULL) {
         WARN("Unable to allocate the system palette\n");
         return FALSE;
     }
@@ -531,8 +533,7 @@ static BOOL X11DRV_PALETTE_BuildSharedMap( const PALETTEENTRY *sys_pal_template
 	 * X guidelines and does binary search...
 	 */
 
-	if (!(pixDynMapping = malloc( sizeof(*pixDynMapping) * palette_size )))
-        {
+	if((pixDynMapping = HeapAlloc(GetProcessHeap(), 0, sizeof(long)*palette_size)) == NULL) {
 	    WARN("Out of memory while building system palette.\n");
 	    return FALSE;
         }
@@ -600,10 +601,10 @@ static BOOL X11DRV_PALETTE_BuildSharedMap( const PALETTEENTRY *sys_pal_template
 		      (X11DRV_PALETTE_PaletteFlags & X11DRV_PALETTE_VIRTUAL || !(X11DRV_PALETTE_PaletteFlags & X11DRV_PALETTE_FIXED)) )
 		     ? NB_RESERVED_COLORS/2 : -1;
 
-   COLOR_sysPal = malloc( sizeof(PALETTEENTRY) * 256 );
+   COLOR_sysPal = HeapAlloc(GetProcessHeap(),0,sizeof(PALETTEENTRY)*256);
    if(COLOR_sysPal == NULL) {
        ERR("Unable to allocate the system palette!\n");
-       free( pixDynMapping );
+       HeapFree(GetProcessHeap(), 0, pixDynMapping);
        return FALSE;
    }
 
@@ -611,10 +612,10 @@ static BOOL X11DRV_PALETTE_BuildSharedMap( const PALETTEENTRY *sys_pal_template
 
    if (default_visual.depth <= 8)
    {
-       X11DRV_PALETTE_XPixelToPalette = malloc( 256 * sizeof(int) );
+       X11DRV_PALETTE_XPixelToPalette = HeapAlloc( GetProcessHeap(), 0, 256 * sizeof(int) );
        if(X11DRV_PALETTE_XPixelToPalette == NULL) {
            ERR("Out of memory: XPixelToPalette!\n");
-           free( pixDynMapping );
+           HeapFree(GetProcessHeap(), 0, pixDynMapping);
            return FALSE;
        }
        for( i = 0; i < 256; i++ )
@@ -625,10 +626,10 @@ static BOOL X11DRV_PALETTE_BuildSharedMap( const PALETTEENTRY *sys_pal_template
     * RGB->pixel calculation in X11DRV_PALETTE_ToPhysical().
     */
 
-   X11DRV_PALETTE_PaletteToXPixel = malloc( sizeof(int) * 256 );
+   X11DRV_PALETTE_PaletteToXPixel = HeapAlloc(GetProcessHeap(),0,sizeof(int)*256);
    if(X11DRV_PALETTE_PaletteToXPixel == NULL) {
        ERR("Out of memory: PaletteToXPixel!\n");
-       free( pixDynMapping );
+       HeapFree(GetProcessHeap(), 0, pixDynMapping);
        return FALSE;
    }
 
@@ -664,7 +665,7 @@ static BOOL X11DRV_PALETTE_BuildSharedMap( const PALETTEENTRY *sys_pal_template
           X11DRV_PALETTE_XPixelToPalette[X11DRV_PALETTE_PaletteToXPixel[i]] = i;
    }
 
-   free( pixDynMapping );
+   HeapFree(GetProcessHeap(), 0, pixDynMapping);
 
    return TRUE;
 }
@@ -780,7 +781,7 @@ BOOL X11DRV_IsSolidColor( COLORREF color )
 
     if (X11DRV_PALETTE_PaletteFlags & X11DRV_PALETTE_VIRTUAL) return TRUE;  /* no palette */
 
-    pthread_mutex_lock( &palette_mutex );
+    EnterCriticalSection( &palette_cs );
     for (i = 0; i < palette_size ; i++, pEntry++)
     {
         if( i < COLOR_gapStart || i > COLOR_gapEnd )
@@ -788,11 +789,11 @@ BOOL X11DRV_IsSolidColor( COLORREF color )
                 (GetGValue(color) == pEntry->peGreen) &&
                 (GetBValue(color) == pEntry->peBlue))
             {
-                pthread_mutex_unlock( &palette_mutex );
+                LeaveCriticalSection( &palette_cs );
                 return TRUE;
             }
     }
-    pthread_mutex_unlock( &palette_mutex );
+    LeaveCriticalSection( &palette_cs );
     return FALSE;
 }
 
@@ -835,9 +836,9 @@ COLORREF X11DRV_PALETTE_ToLogical(X11DRV_PDEVICE *physDev, int pixel)
     if ((default_visual.depth <= 8) && (pixel < 256) &&
         !(X11DRV_PALETTE_PaletteFlags & (X11DRV_PALETTE_VIRTUAL | X11DRV_PALETTE_FIXED)) ) {
         COLORREF ret;
-        pthread_mutex_lock( &palette_mutex );
+        EnterCriticalSection( &palette_cs );
         ret = *(COLORREF *)(COLOR_sysPal + (X11DRV_PALETTE_XPixelToPalette ? X11DRV_PALETTE_XPixelToPalette[pixel]: pixel)) & 0x00ffffff;
-        pthread_mutex_unlock( &palette_mutex );
+        LeaveCriticalSection( &palette_cs );
         return ret;
     }
 
@@ -880,20 +881,20 @@ static int X11DRV_SysPaletteLookupPixel( COLORREF col, BOOL skipReserved )
  */
 COLORREF X11DRV_PALETTE_GetColor( X11DRV_PDEVICE *physDev, COLORREF color )
 {
-    HPALETTE hPal = NtGdiGetDCObject( physDev->dev.hdc, NTGDI_OBJ_PAL );
-    PALETTEENTRY entry;
+    HPALETTE             hPal = GetCurrentObject(physDev->dev.hdc, OBJ_PAL );
+    PALETTEENTRY         entry;
 
     if (color & (1 << 24))  /* PALETTEINDEX */
     {
         unsigned int idx = LOWORD(color);
-        if (!get_palette_entries( hPal, idx, 1, &entry )) return 0;
+        if (!GetPaletteEntries( hPal, idx, 1, &entry )) return 0;
         return RGB( entry.peRed, entry.peGreen, entry.peBlue );
     }
 
     if (color >> 24 == 2)  /* PALETTERGB */
     {
-        unsigned int idx = NtGdiGetNearestPaletteIndex( hPal, color & 0xffffff );
-        if (!get_palette_entries( hPal, idx, 1, &entry )) return 0;
+        unsigned int idx = GetNearestPaletteIndex( hPal, color & 0xffffff );
+        if (!GetPaletteEntries( hPal, idx, 1, &entry )) return 0;
         return RGB( entry.peRed, entry.peGreen, entry.peBlue );
     }
 
@@ -910,8 +911,8 @@ COLORREF X11DRV_PALETTE_GetColor( X11DRV_PDEVICE *physDev, COLORREF color )
  */
 int X11DRV_PALETTE_ToPhysical( X11DRV_PDEVICE *physDev, COLORREF color )
 {
-    WORD index = 0;
-    HPALETTE hPal = NtGdiGetDCObject( physDev->dev.hdc, NTGDI_OBJ_PAL );
+    WORD 		 index = 0;
+    HPALETTE 		 hPal = GetCurrentObject(physDev->dev.hdc, OBJ_PAL );
     int *mapping = palette_get_mapping( hPal );
     PALETTEENTRY entry;
     ColorShifts *shifts = &X11DRV_PALETTE_default_shifts;
@@ -930,7 +931,7 @@ int X11DRV_PALETTE_ToPhysical( X11DRV_PDEVICE *physDev, COLORREF color )
         {
             unsigned int idx = LOWORD( color );
 
-            if (!get_palette_entries( hPal, idx, 1, &entry ))
+            if (!GetPaletteEntries( hPal, idx, 1, &entry ))
             {
                 WARN("PALETTEINDEX(%x) : idx %d is out of bounds, assuming black\n", color, idx);
                 return 0;
@@ -989,13 +990,13 @@ int X11DRV_PALETTE_ToPhysical( X11DRV_PDEVICE *physDev, COLORREF color )
         if (color & (1 << 24))  /* PALETTEINDEX */
         {
             index = LOWORD( color );
-            if (!get_palette_entries( hPal, index, 1, &entry ))
+            if (!GetPaletteEntries( hPal, index, 1, &entry ))
                 WARN("PALETTEINDEX(%x) : index %i is out of bounds\n", color, index);
             else if (mapping) index = mapping[index];
         }
         else if (color >> 24 == 2)  /* PALETTERGB */
         {
-            index = NtGdiGetNearestPaletteIndex( hPal, color );
+            index = GetNearestPaletteIndex( hPal, color );
             if (mapping) index = mapping[index];
         }
         else if (color >> 16 == 0x10ff)  /* DIBINDEX */
@@ -1008,10 +1009,10 @@ int X11DRV_PALETTE_ToPhysical( X11DRV_PDEVICE *physDev, COLORREF color )
                 return (((color >> 16) & 0xff) +
                         ((color >> 8) & 0xff) + (color & 0xff) > 255*3/2) ? 1 : 0;
 
-            pthread_mutex_lock( &palette_mutex );
+            EnterCriticalSection( &palette_cs );
             index = X11DRV_SysPaletteLookupPixel( color & 0xffffff, FALSE);
             if (X11DRV_PALETTE_PaletteToXPixel) index = X11DRV_PALETTE_PaletteToXPixel[index];
-            pthread_mutex_unlock( &palette_mutex );
+            LeaveCriticalSection( &palette_cs );
         }
     }
     return index;
@@ -1074,11 +1075,11 @@ static int X11DRV_PALETTE_LookupPixel(ColorShifts *shifts, COLORREF color )
         if (!mapping)
             WARN("Palette %p is not realized\n", hPal);
 
-        pthread_mutex_lock( &palette_mutex );
+        EnterCriticalSection( &palette_cs );
         index = X11DRV_SysPaletteLookupPixel( color, FALSE);
         if (X11DRV_PALETTE_PaletteToXPixel)
             index = X11DRV_PALETTE_PaletteToXPixel[index];
-        pthread_mutex_unlock( &palette_mutex );
+        LeaveCriticalSection( &palette_cs );
         return index;
     }
 }
@@ -1196,11 +1197,14 @@ UINT CDECL X11DRV_RealizePalette( PHYSDEV dev, HPALETTE hpal, BOOL primary )
 
     if (X11DRV_PALETTE_PaletteFlags & X11DRV_PALETTE_VIRTUAL) return 0;
 
-    if (!NtGdiExtGetObjectW( hpal, sizeof(num_entries), &num_entries )) return 0;
+    if (!GetObjectW( hpal, sizeof(num_entries), &num_entries )) return 0;
 
     /* initialize palette mapping table */
     prev_mapping = palette_get_mapping( hpal );
-    mapping = realloc( prev_mapping, sizeof(int) * num_entries );
+    if (prev_mapping)
+        mapping = HeapReAlloc( GetProcessHeap(), 0, prev_mapping, sizeof(int)*num_entries);
+    else 
+	mapping = HeapAlloc( GetProcessHeap(), 0, sizeof(int)*num_entries);
 
     if(mapping == NULL) {
         ERR("Unable to allocate new mapping -- memory exhausted!\n");
@@ -1213,11 +1217,11 @@ UINT CDECL X11DRV_RealizePalette( PHYSDEV dev, HPALETTE hpal, BOOL primary )
         FIXME( "more than 256 entries not supported\n" );
         num_entries = 256;
     }
-    if (!(num_entries = get_palette_entries( hpal, 0, num_entries, entries ))) return 0;
+    if (!(num_entries = GetPaletteEntries( hpal, 0, num_entries, entries ))) return 0;
 
     /* reset dynamic system palette entries */
 
-    pthread_mutex_lock( &palette_mutex );
+    EnterCriticalSection( &palette_cs );
     if( primary && X11DRV_PALETTE_firstFree != -1)
          X11DRV_PALETTE_FormatSystemPalette();
 
@@ -1290,7 +1294,7 @@ UINT CDECL X11DRV_RealizePalette( PHYSDEV dev, HPALETTE hpal, BOOL primary )
         TRACE("entry %i (%x) -> pixel %i\n", i, *(COLORREF*)&entries[i], index);
 
     }
-    pthread_mutex_unlock( &palette_mutex );
+    LeaveCriticalSection( &palette_cs );
     return iRemapped;
 }
 
@@ -1305,7 +1309,7 @@ BOOL CDECL X11DRV_UnrealizePalette( HPALETTE hpal )
     if (mapping)
     {
         XDeleteContext( gdi_display, (XID)hpal, palette_context );
-        free( mapping );
+        HeapFree( GetProcessHeap(), 0, mapping );
     }
     return TRUE;
 }
@@ -1327,7 +1331,7 @@ UINT CDECL X11DRV_GetSystemPaletteEntries( PHYSDEV dev, UINT start, UINT count,
     if (start >= palette_size) return 0;
     if (start + count >= palette_size) count = palette_size - start;
 
-    pthread_mutex_lock( &palette_mutex );
+    EnterCriticalSection( &palette_cs );
     for (i = 0; i < count; i++)
     {
         entries[i].peRed   = COLOR_sysPal[start + i].peRed;
@@ -1336,7 +1340,7 @@ UINT CDECL X11DRV_GetSystemPaletteEntries( PHYSDEV dev, UINT start, UINT count,
         entries[i].peFlags = 0;
         TRACE("\tidx(%02x) -> RGB(%08x)\n", start + i, *(COLORREF*)(entries + i) );
     }
-    pthread_mutex_unlock( &palette_mutex );
+    LeaveCriticalSection( &palette_cs );
     return count;
 }
 
@@ -1357,26 +1361,26 @@ COLORREF CDECL X11DRV_GetNearestColor( PHYSDEV dev, COLORREF color )
 
         UINT index;
         PALETTEENTRY entry;
-        HPALETTE hpal = NtGdiGetDCObject( dev->hdc, NTGDI_OBJ_PAL );
+        HPALETTE hpal = GetCurrentObject( dev->hdc, OBJ_PAL );
 
         if (!hpal) hpal = GetStockObject( DEFAULT_PALETTE );
 
         if (spec_type == 2) /* PALETTERGB */
-            index = NtGdiGetNearestPaletteIndex( hpal, color );
+            index = GetNearestPaletteIndex( hpal, color );
         else  /* PALETTEINDEX */
             index = LOWORD(color);
 
-        if (!get_palette_entries( hpal, index, 1, &entry ))
+        if (!GetPaletteEntries( hpal, index, 1, &entry ))
         {
             WARN("RGB(%x) : idx %d is out of bounds, assuming NULL\n", color, index );
-            if (!get_palette_entries( hpal, 0, 1, &entry )) return CLR_INVALID;
+            if (!GetPaletteEntries( hpal, 0, 1, &entry )) return CLR_INVALID;
         }
         color = RGB( entry.peRed,  entry.peGreen, entry.peBlue );
     }
     color &= 0x00ffffff;
-    pthread_mutex_lock( &palette_mutex );
+    EnterCriticalSection( &palette_cs );
     nearest = (0x00ffffff & *(COLORREF*)(COLOR_sysPal + X11DRV_SysPaletteLookupPixel(color, FALSE)));
-    pthread_mutex_unlock( &palette_mutex );
+    LeaveCriticalSection( &palette_cs );
 
     TRACE("(%06x): returning %06x\n", color, nearest );
     return nearest;
@@ -1388,17 +1392,16 @@ COLORREF CDECL X11DRV_GetNearestColor( PHYSDEV dev, COLORREF color )
  */
 UINT CDECL X11DRV_RealizeDefaultPalette( PHYSDEV dev )
 {
-    DWORD is_memdc;
     UINT ret = 0;
 
-    if (palette_size && NtGdiGetDCDword( dev->hdc, NtGdiIsMemDC, &is_memdc ) && is_memdc)
+    if (palette_size && GetObjectType(dev->hdc) != OBJ_MEMDC)
     {
         /* lookup is needed to account for SetSystemPaletteUse() stuff */
         int i, index, *mapping = palette_get_mapping( GetStockObject(DEFAULT_PALETTE) );
         PALETTEENTRY entries[NB_RESERVED_COLORS];
 
-        get_palette_entries( GetStockObject(DEFAULT_PALETTE), 0, NB_RESERVED_COLORS, entries );
-        pthread_mutex_lock( &palette_mutex );
+        GetPaletteEntries( GetStockObject(DEFAULT_PALETTE), 0, NB_RESERVED_COLORS, entries );
+        EnterCriticalSection( &palette_cs );
         for( i = 0; i < NB_RESERVED_COLORS; i++ )
         {
             index = X11DRV_PALETTE_LookupSystemXPixel( RGB(entries[i].peRed,
@@ -1411,7 +1414,7 @@ UINT CDECL X11DRV_RealizeDefaultPalette( PHYSDEV dev )
                 ret++;
             }
         }
-        pthread_mutex_unlock( &palette_mutex );
+        LeaveCriticalSection( &palette_cs );
     }
     return ret;
 }
diff --git a/dlls/winex11.drv/pen.c b/dlls/winex11.drv/pen.c
index a32bf4752e1..b1ad1026056 100644
--- a/dlls/winex11.drv/pen.c
+++ b/dlls/winex11.drv/pen.c
@@ -18,10 +18,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include "x11drv.h"
@@ -74,17 +70,17 @@ HPEN CDECL X11DRV_SelectPen( PHYSDEV dev, HPEN hpen, const struct brush_pattern
     int i;
     EXTLOGPEN *elp = NULL;
 
-    if (!NtGdiExtGetObjectW( hpen, sizeof(logpen), &logpen ))
+    if (!GetObjectW( hpen, sizeof(logpen), &logpen ))
     {
         /* must be an extended pen */
-        INT size = NtGdiExtGetObjectW( hpen, 0, NULL );
+        INT size = GetObjectW( hpen, 0, NULL );
 
         if (!size) return 0;
 
         physDev->pen.ext = 1;
-        elp = malloc( size );
+        elp = HeapAlloc( GetProcessHeap(), 0, size );
 
-        NtGdiExtGetObjectW( hpen, size, elp );
+        GetObjectW( hpen, size, elp );
         logpen.lopnStyle = elp->elpPenStyle;
         logpen.lopnWidth.x = elp->elpWidth;
         logpen.lopnWidth.y = 0;
@@ -107,7 +103,7 @@ HPEN CDECL X11DRV_SelectPen( PHYSDEV dev, HPEN hpen, const struct brush_pattern
 
     if (physDev->pen.width == 1) physDev->pen.width = 0;  /* Faster */
     if (hpen == GetStockObject( DC_PEN ))
-        NtGdiGetDCDword( dev->hdc, NtGdiGetDCPenColor, &logpen.lopnColor );
+        logpen.lopnColor = GetDCPenColor( dev->hdc );
     physDev->pen.pixel = X11DRV_PALETTE_ToPhysical( physDev, logpen.lopnColor );
     switch(logpen.lopnStyle & PS_STYLE_MASK)
     {
@@ -149,7 +145,7 @@ HPEN CDECL X11DRV_SelectPen( PHYSDEV dev, HPEN hpen, const struct brush_pattern
         for(i = 0; i < physDev->pen.dash_len; i++)
             physDev->pen.dashes[i] = min( physDev->pen.dashes[i] * physDev->pen.width, 255 );
 
-    free( elp );
+    HeapFree( GetProcessHeap(), 0, elp );
 
     return hpen;
 }
@@ -162,7 +158,7 @@ COLORREF CDECL X11DRV_SetDCPenColor( PHYSDEV dev, COLORREF crColor )
 {
     X11DRV_PDEVICE *physDev = get_x11drv_dev( dev );
 
-    if (NtGdiGetDCObject( dev->hdc, NTGDI_OBJ_PEN ) == GetStockObject( DC_PEN ))
+    if (GetCurrentObject(dev->hdc, OBJ_PEN) == GetStockObject( DC_PEN ))
         physDev->pen.pixel = X11DRV_PALETTE_ToPhysical( physDev, crColor );
 
     return crColor;
diff --git a/dlls/winex11.drv/settings.c b/dlls/winex11.drv/settings.c
index e7e353b33ad..cea7ebbc6b7 100644
--- a/dlls/winex11.drv/settings.c
+++ b/dlls/winex11.drv/settings.c
@@ -19,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 #include <stdlib.h>
 
@@ -35,6 +31,8 @@
 #include "winreg.h"
 #include "wingdi.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11settings);
 
@@ -72,7 +70,14 @@ static DWORD cached_flags;
 static DEVMODEW *cached_modes;
 static UINT cached_mode_count;
 
-static pthread_mutex_t settings_mutex = PTHREAD_MUTEX_INITIALIZER;
+static CRITICAL_SECTION modes_section;
+static CRITICAL_SECTION_DEBUG modes_critsect_debug =
+{
+    0, 0, &modes_section,
+    {&modes_critsect_debug.ProcessLocksList, &modes_critsect_debug.ProcessLocksList},
+     0, 0, {(DWORD_PTR)(__FILE__ ": modes_section")}
+};
+static CRITICAL_SECTION modes_section = {&modes_critsect_debug, -1, 0, 0, 0, 0};
 
 void X11DRV_Settings_SetHandler(const struct x11drv_settings_handler *new_handler)
 {
@@ -94,7 +99,7 @@ static BOOL nores_get_id(const WCHAR *device_name, ULONG_PTR *id)
     if (!get_primary_adapter( primary_adapter ))
         return FALSE;
 
-    *id = !wcsicmp( device_name, primary_adapter ) ? 1 : 0;
+    *id = !lstrcmpiW( device_name, primary_adapter ) ? 1 : 0;
     return TRUE;
 }
 
@@ -103,7 +108,7 @@ static BOOL nores_get_modes(ULONG_PTR id, DWORD flags, DEVMODEW **new_modes, UIN
     RECT primary = get_host_primary_monitor_rect();
     DEVMODEW *modes;
 
-    modes = calloc(1, sizeof(*modes));
+    modes = heap_calloc(1, sizeof(*modes));
     if (!modes)
     {
         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
@@ -128,7 +133,7 @@ static BOOL nores_get_modes(ULONG_PTR id, DWORD flags, DEVMODEW **new_modes, UIN
 
 static void nores_free_modes(DEVMODEW *modes)
 {
-    free(modes);
+    heap_free(modes);
 }
 
 static BOOL nores_get_current_mode(ULONG_PTR id, DEVMODEW *mode)
@@ -187,19 +192,16 @@ void init_registry_display_settings(void)
 {
     DEVMODEW dm = {.dmSize = sizeof(dm)};
     DISPLAY_DEVICEW dd = {sizeof(dd)};
-    UNICODE_STRING device_name;
     DWORD i = 0;
     LONG ret;
 
-    while (!NtUserEnumDisplayDevices( NULL, i++, &dd, 0 ))
+    while (EnumDisplayDevicesW(NULL, i++, &dd, 0))
     {
-        RtlInitUnicodeString( &device_name, dd.DeviceName );
-
         /* Skip if the device already has registry display settings */
-        if (NtUserEnumDisplaySettings( &device_name, ENUM_REGISTRY_SETTINGS, &dm, 0 ))
+        if (EnumDisplaySettingsExW(dd.DeviceName, ENUM_REGISTRY_SETTINGS, &dm, 0))
             continue;
 
-        if (!NtUserEnumDisplaySettings( &device_name, ENUM_CURRENT_SETTINGS, &dm, 0 ))
+        if (!EnumDisplaySettingsExW(dd.DeviceName, ENUM_CURRENT_SETTINGS, &dm, 0))
         {
             ERR("Failed to query current display settings for %s.\n", wine_dbgstr_w(dd.DeviceName));
             continue;
@@ -209,145 +211,140 @@ void init_registry_display_settings(void)
               wine_dbgstr_w(dd.DeviceName), dm.dmPelsWidth, dm.dmPelsHeight, dm.dmBitsPerPel,
               dm.dmDisplayFrequency, dm.u1.s2.dmPosition.x, dm.u1.s2.dmPosition.y);
 
-        ret = NtUserChangeDisplaySettings( &device_name, &dm, NULL,
-                                           CDS_GLOBAL | CDS_NORESET | CDS_UPDATEREGISTRY, NULL );
+        ret = ChangeDisplaySettingsExW(dd.DeviceName, &dm, NULL,
+                                       CDS_GLOBAL | CDS_NORESET | CDS_UPDATEREGISTRY, NULL);
         if (ret != DISP_CHANGE_SUCCESSFUL)
             ERR("Failed to save registry display settings for %s, returned %d.\n",
                 wine_dbgstr_w(dd.DeviceName), ret);
     }
 }
 
-static HKEY get_display_device_reg_key( const WCHAR *device_name )
+static BOOL get_display_device_reg_key(const WCHAR *device_name, WCHAR *key, unsigned len)
 {
     static const WCHAR display[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y'};
-    static const WCHAR video_key[] = {
-        '\\','R','e','g','i','s','t','r','y',
-        '\\','M','a','c','h','i','n','e',
-        '\\','H','A','R','D','W','A','R','E',
-        '\\','D','E','V','I','C','E','M','A','P',
-        '\\','V','I','D','E','O'};
-    static const WCHAR current_config_key[] = {
-        '\\','R','e','g','i','s','t','r','y',
-        '\\','M','a','c','h','i','n','e',
-        '\\','S','y','s','t','e','m',
-        '\\','C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t',
-        '\\','H','a','r','d','w','a','r','e',' ','P','r','o','f','i','l','e','s',
-        '\\','C','u','r','r','e','n','t'};
-    WCHAR value_name[MAX_PATH], buffer[4096], *end_ptr;
-    KEY_VALUE_PARTIAL_INFORMATION *value = (void *)buffer;
+    static const WCHAR video_value_fmt[] = {'\\','D','e','v','i','c','e','\\',
+                                            'V','i','d','e','o','%','d',0};
+    static const WCHAR video_key[] = {'H','A','R','D','W','A','R','E','\\',
+                                      'D','E','V','I','C','E','M','A','P','\\',
+                                      'V','I','D','E','O','\\',0};
+    WCHAR value_name[MAX_PATH], buffer[MAX_PATH], *end_ptr;
     DWORD adapter_index, size;
-    char adapter_name[100];
-    HKEY hkey;
 
     /* Device name has to be \\.\DISPLAY%d */
-    if (wcsnicmp( device_name, display, ARRAY_SIZE(display) ))
+    if (strncmpiW(device_name, display, ARRAY_SIZE(display)))
         return FALSE;
 
     /* Parse \\.\DISPLAY* */
-    adapter_index = wcstol( device_name + ARRAY_SIZE(display), &end_ptr, 10 ) - 1;
+    adapter_index = strtolW(device_name + ARRAY_SIZE(display), &end_ptr, 10) - 1;
     if (*end_ptr)
         return FALSE;
 
     /* Open \Device\Video* in HKLM\HARDWARE\DEVICEMAP\VIDEO\ */
-    if (!(hkey = reg_open_key( NULL, video_key, sizeof(video_key) ))) return FALSE;
-    sprintf( adapter_name, "\\Device\\Video%d", adapter_index );
-    asciiz_to_unicode( value_name, adapter_name );
-    size = query_reg_value( hkey, value_name, value, sizeof(buffer) );
-    NtClose( hkey );
-    if (!size || value->Type != REG_SZ) return FALSE;
-
-    /* Replace \Registry\Machine\ prefix with HKEY_CURRENT_CONFIG */
-    memmove( buffer + ARRAYSIZE(current_config_key), (const WCHAR *)value->Data + 17,
-             size - 17 * sizeof(WCHAR) );
-    memcpy( buffer, current_config_key, sizeof(current_config_key) );
-    TRACE( "display device %s registry settings key %s.\n", wine_dbgstr_w(device_name),
-           wine_dbgstr_w(buffer) );
-    return reg_open_key( NULL, buffer, lstrlenW(buffer) * sizeof(WCHAR) );
-}
-
-static BOOL query_display_setting( HKEY hkey, const char *name, DWORD *ret )
-{
-    char buffer[1024];
-    WCHAR nameW[128];
-    KEY_VALUE_PARTIAL_INFORMATION *value = (void *)buffer;
+    sprintfW(value_name, video_value_fmt, adapter_index);
+    size = sizeof(buffer);
+    if (RegGetValueW(HKEY_LOCAL_MACHINE, video_key, value_name, RRF_RT_REG_SZ, NULL, buffer, &size))
+        return FALSE;
 
-    asciiz_to_unicode( nameW, name );
-    if (query_reg_value( hkey, nameW, value, sizeof(buffer) ) != sizeof(DWORD) ||
-        value->Type != REG_DWORD)
+    if (len < lstrlenW(buffer + 18) + 1)
         return FALSE;
 
-    *ret = *(DWORD *)value->Data;
+    /* Skip \Registry\Machine\ prefix */
+    lstrcpyW(key, buffer + 18);
+    TRACE("display device %s registry settings key %s.\n", wine_dbgstr_w(device_name), wine_dbgstr_w(key));
     return TRUE;
 }
 
 static BOOL read_registry_settings(const WCHAR *device_name, DEVMODEW *dm)
 {
+    WCHAR wine_x11_reg_key[MAX_PATH];
     HANDLE mutex;
     HKEY hkey;
+    DWORD type, size;
     BOOL ret = TRUE;
 
     dm->dmFields = 0;
 
     mutex = get_display_device_init_mutex();
-    if (!(hkey = get_display_device_reg_key( device_name )))
+    if (!get_display_device_reg_key(device_name, wine_x11_reg_key, ARRAY_SIZE(wine_x11_reg_key)))
+    {
+        release_display_device_init_mutex(mutex);
+        return FALSE;
+    }
+
+    if (RegOpenKeyExW(HKEY_CURRENT_CONFIG, wine_x11_reg_key, 0, KEY_READ, &hkey))
     {
         release_display_device_init_mutex(mutex);
         return FALSE;
     }
 
-    ret &= query_display_setting( hkey, "DefaultSettings.BitsPerPel", &dm->dmBitsPerPel );
+#define query_value(name, data) \
+    size = sizeof(DWORD); \
+    if (RegQueryValueExA(hkey, name, 0, &type, (LPBYTE)(data), &size) || \
+        type != REG_DWORD || size != sizeof(DWORD)) \
+        ret = FALSE
+
+    query_value("DefaultSettings.BitsPerPel", &dm->dmBitsPerPel);
     dm->dmFields |= DM_BITSPERPEL;
-    ret &= query_display_setting( hkey, "DefaultSettings.XResolution", &dm->dmPelsWidth );
+    query_value("DefaultSettings.XResolution", &dm->dmPelsWidth);
     dm->dmFields |= DM_PELSWIDTH;
-    ret &= query_display_setting( hkey, "DefaultSettings.YResolution", &dm->dmPelsHeight );
+    query_value("DefaultSettings.YResolution", &dm->dmPelsHeight);
     dm->dmFields |= DM_PELSHEIGHT;
-    ret &= query_display_setting( hkey, "DefaultSettings.VRefresh", &dm->dmDisplayFrequency );
+    query_value("DefaultSettings.VRefresh", &dm->dmDisplayFrequency);
     dm->dmFields |= DM_DISPLAYFREQUENCY;
-    ret &= query_display_setting( hkey, "DefaultSettings.Flags", &dm->u2.dmDisplayFlags );
+    query_value("DefaultSettings.Flags", &dm->u2.dmDisplayFlags);
     dm->dmFields |= DM_DISPLAYFLAGS;
-    ret &= query_display_setting( hkey, "DefaultSettings.XPanning", (DWORD *)&dm->u1.s2.dmPosition.x );
-    ret &= query_display_setting( hkey, "DefaultSettings.YPanning", (DWORD *)&dm->u1.s2.dmPosition.y );
+    query_value("DefaultSettings.XPanning", &dm->u1.s2.dmPosition.x);
+    query_value("DefaultSettings.YPanning", &dm->u1.s2.dmPosition.y);
     dm->dmFields |= DM_POSITION;
-    ret &= query_display_setting( hkey, "DefaultSettings.Orientation", &dm->u1.s2.dmDisplayOrientation );
+    query_value("DefaultSettings.Orientation", &dm->u1.s2.dmDisplayOrientation);
     dm->dmFields |= DM_DISPLAYORIENTATION;
-    ret &= query_display_setting( hkey, "DefaultSettings.FixedOutput", &dm->u1.s2.dmDisplayFixedOutput );
+    query_value("DefaultSettings.FixedOutput", &dm->u1.s2.dmDisplayFixedOutput);
+
+#undef query_value
 
-    NtClose( hkey );
+    RegCloseKey(hkey);
     release_display_device_init_mutex(mutex);
     return ret;
 }
 
-static BOOL set_setting_value( HKEY hkey, const char *name, DWORD val )
-{
-    WCHAR nameW[128];
-    UNICODE_STRING str = { asciiz_to_unicode( nameW, name ) - sizeof(WCHAR), sizeof(nameW), nameW };
-    return !NtSetValueKey( hkey, &str, 0, REG_DWORD, &val, sizeof(val) );
-}
-
 static BOOL write_registry_settings(const WCHAR *device_name, const DEVMODEW *dm)
 {
+    WCHAR wine_x11_reg_key[MAX_PATH];
     HANDLE mutex;
     HKEY hkey;
     BOOL ret = TRUE;
 
     mutex = get_display_device_init_mutex();
-    if (!(hkey = get_display_device_reg_key( device_name )))
+    if (!get_display_device_reg_key(device_name, wine_x11_reg_key, ARRAY_SIZE(wine_x11_reg_key)))
     {
         release_display_device_init_mutex(mutex);
         return FALSE;
     }
 
-    ret &= set_setting_value( hkey, "DefaultSettings.BitsPerPel", dm->dmBitsPerPel );
-    ret &= set_setting_value( hkey, "DefaultSettings.XResolution", dm->dmPelsWidth );
-    ret &= set_setting_value( hkey, "DefaultSettings.YResolution", dm->dmPelsHeight );
-    ret &= set_setting_value( hkey, "DefaultSettings.VRefresh", dm->dmDisplayFrequency );
-    ret &= set_setting_value( hkey, "DefaultSettings.Flags", dm->u2.dmDisplayFlags );
-    ret &= set_setting_value( hkey, "DefaultSettings.XPanning", dm->u1.s2.dmPosition.x );
-    ret &= set_setting_value( hkey, "DefaultSettings.YPanning", dm->u1.s2.dmPosition.y );
-    ret &= set_setting_value( hkey, "DefaultSettings.Orientation", dm->u1.s2.dmDisplayOrientation );
-    ret &= set_setting_value( hkey, "DefaultSettings.FixedOutput", dm->u1.s2.dmDisplayFixedOutput );
+    if (RegCreateKeyExW(HKEY_CURRENT_CONFIG, wine_x11_reg_key, 0, NULL,
+                        REG_OPTION_VOLATILE, KEY_WRITE, NULL, &hkey, NULL))
+    {
+        release_display_device_init_mutex(mutex);
+        return FALSE;
+    }
+
+#define set_value(name, data) \
+    if (RegSetValueExA(hkey, name, 0, REG_DWORD, (const BYTE*)(data), sizeof(DWORD))) \
+        ret = FALSE
 
-    NtClose( hkey );
+    set_value("DefaultSettings.BitsPerPel", &dm->dmBitsPerPel);
+    set_value("DefaultSettings.XResolution", &dm->dmPelsWidth);
+    set_value("DefaultSettings.YResolution", &dm->dmPelsHeight);
+    set_value("DefaultSettings.VRefresh", &dm->dmDisplayFrequency);
+    set_value("DefaultSettings.Flags", &dm->u2.dmDisplayFlags);
+    set_value("DefaultSettings.XPanning", &dm->u1.s2.dmPosition.x);
+    set_value("DefaultSettings.YPanning", &dm->u1.s2.dmPosition.y);
+    set_value("DefaultSettings.Orientation", &dm->u1.s2.dmDisplayOrientation);
+    set_value("DefaultSettings.FixedOutput", &dm->u1.s2.dmDisplayFixedOutput);
+
+#undef set_value
+
+    RegCloseKey(hkey);
     release_display_device_init_mutex(mutex);
     return ret;
 }
@@ -358,7 +355,7 @@ BOOL get_primary_adapter(WCHAR *name)
     DWORD i;
 
     dd.cb = sizeof(dd);
-    for (i = 0; !NtUserEnumDisplayDevices( NULL, i, &dd, 0 ); ++i)
+    for (i = 0; EnumDisplayDevicesW(NULL, i, &dd, 0); ++i)
     {
         if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
         {
@@ -422,29 +419,29 @@ static void set_display_depth(ULONG_PTR display_id, DWORD depth)
 {
     struct x11drv_display_depth *display_depth;
 
-    pthread_mutex_lock( &settings_mutex );
+    EnterCriticalSection(&modes_section);
     LIST_FOR_EACH_ENTRY(display_depth, &x11drv_display_depth_list, struct x11drv_display_depth, entry)
     {
         if (display_depth->display_id == display_id)
         {
             display_depth->depth = depth;
-            pthread_mutex_unlock( &settings_mutex );
+            LeaveCriticalSection(&modes_section);
             return;
         }
     }
 
-    display_depth = malloc(sizeof(*display_depth));
+    display_depth = heap_alloc(sizeof(*display_depth));
     if (!display_depth)
     {
         ERR("Failed to allocate memory.\n");
-        pthread_mutex_unlock( &settings_mutex );
+        LeaveCriticalSection(&modes_section);
         return;
     }
 
     display_depth->display_id = display_id;
     display_depth->depth = depth;
     list_add_head(&x11drv_display_depth_list, &display_depth->entry);
-    pthread_mutex_unlock( &settings_mutex );
+    LeaveCriticalSection(&modes_section);
 }
 
 static DWORD get_display_depth(ULONG_PTR display_id)
@@ -452,17 +449,17 @@ static DWORD get_display_depth(ULONG_PTR display_id)
     struct x11drv_display_depth *display_depth;
     DWORD depth;
 
-    pthread_mutex_lock( &settings_mutex );
+    EnterCriticalSection(&modes_section);
     LIST_FOR_EACH_ENTRY(display_depth, &x11drv_display_depth_list, struct x11drv_display_depth, entry)
     {
         if (display_depth->display_id == display_id)
         {
             depth = display_depth->depth;
-            pthread_mutex_unlock( &settings_mutex );
+            LeaveCriticalSection(&modes_section);
             return depth;
         }
     }
-    pthread_mutex_unlock( &settings_mutex );
+    LeaveCriticalSection(&modes_section);
     return screen_bpp;
 }
 
@@ -470,7 +467,7 @@ static DWORD get_display_depth(ULONG_PTR display_id)
  *		EnumDisplaySettingsEx  (X11DRV.@)
  *
  */
-BOOL X11DRV_EnumDisplaySettingsEx( LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags)
+BOOL CDECL X11DRV_EnumDisplaySettingsEx( LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags)
 {
     static const WCHAR dev_name[CCHDEVICENAME] =
         { 'W','i','n','e',' ','X','1','1',' ','d','r','i','v','e','r',0 };
@@ -502,13 +499,13 @@ BOOL X11DRV_EnumDisplaySettingsEx( LPCWSTR name, DWORD n, LPDEVMODEW devmode, DW
         goto done;
     }
 
-    pthread_mutex_lock( &settings_mutex );
-    if (n == 0 || wcsicmp(cached_device_name, name) || cached_flags != flags)
+    EnterCriticalSection(&modes_section);
+    if (n == 0 || lstrcmpiW(cached_device_name, name) || cached_flags != flags)
     {
         if (!handler.get_id(name, &id) || !handler.get_modes(id, flags, &modes, &mode_count))
         {
             ERR("Failed to get %s supported display modes.\n", wine_dbgstr_w(name));
-            pthread_mutex_unlock( &settings_mutex );
+            LeaveCriticalSection(&modes_section);
             return FALSE;
         }
 
@@ -524,14 +521,14 @@ BOOL X11DRV_EnumDisplaySettingsEx( LPCWSTR name, DWORD n, LPDEVMODEW devmode, DW
 
     if (n >= cached_mode_count)
     {
-        pthread_mutex_unlock( &settings_mutex );
+        LeaveCriticalSection(&modes_section);
         WARN("handler:%s device:%s mode index:%#x not found.\n", handler.name, wine_dbgstr_w(name), n);
         SetLastError(ERROR_NO_MORE_FILES);
         return FALSE;
     }
 
     memcpy(devmode, (BYTE *)cached_modes + (sizeof(*cached_modes) + cached_modes[0].dmDriverExtra) * n, sizeof(*devmode));
-    pthread_mutex_unlock( &settings_mutex );
+    LeaveCriticalSection(&modes_section);
 
 done:
     /* Set generic fields */
@@ -597,7 +594,7 @@ static DEVMODEW *get_full_mode(ULONG_PTR id, DEVMODEW *dev_mode)
         return NULL;
     }
 
-    if (!(full_mode = malloc(sizeof(*found_mode) + found_mode->dmDriverExtra)))
+    if (!(full_mode = heap_alloc(sizeof(*found_mode) + found_mode->dmDriverExtra)))
     {
         handler.free_modes(modes);
         return NULL;
@@ -614,7 +611,7 @@ static DEVMODEW *get_full_mode(ULONG_PTR id, DEVMODEW *dev_mode)
 static void free_full_mode(DEVMODEW *mode)
 {
     if (!is_detached_mode(mode))
-        free(mode);
+        heap_free(mode);
 }
 
 static LONG get_display_settings(struct x11drv_display_setting **new_displays,
@@ -625,19 +622,18 @@ static LONG get_display_settings(struct x11drv_display_setting **new_displays,
     INT display_idx, display_count = 0;
     DISPLAY_DEVICEW display_device;
     LONG ret = DISP_CHANGE_FAILED;
-    UNICODE_STRING device_name;
 
     display_device.cb = sizeof(display_device);
-    for (display_idx = 0; !NtUserEnumDisplayDevices( NULL, display_idx, &display_device, 0 ); ++display_idx)
+    for (display_idx = 0; EnumDisplayDevicesW(NULL, display_idx, &display_device, 0); ++display_idx)
         ++display_count;
 
-    displays = calloc(display_count, sizeof(*displays));
+    displays = heap_calloc(display_count, sizeof(*displays));
     if (!displays)
         goto done;
 
     for (display_idx = 0; display_idx < display_count; ++display_idx)
     {
-        if (NtUserEnumDisplayDevices( NULL, display_idx, &display_device, 0 ))
+        if (!EnumDisplayDevicesW(NULL, display_idx, &display_device, 0))
             goto done;
 
         if (!handler.get_id(display_device.DeviceName, &displays[display_idx].id))
@@ -646,25 +642,23 @@ static LONG get_display_settings(struct x11drv_display_setting **new_displays,
             goto done;
         }
 
-        RtlInitUnicodeString( &device_name, display_device.DeviceName );
-
         if (!dev_mode)
         {
             memset(&registry_mode, 0, sizeof(registry_mode));
             registry_mode.dmSize = sizeof(registry_mode);
-            if (!NtUserEnumDisplaySettings( &device_name, ENUM_REGISTRY_SETTINGS, &registry_mode, 0 ))
+            if (!EnumDisplaySettingsExW(display_device.DeviceName, ENUM_REGISTRY_SETTINGS, &registry_mode, 0))
                 goto done;
 
             displays[display_idx].desired_mode = registry_mode;
         }
-        else if (!wcsicmp(dev_name, display_device.DeviceName))
+        else if (!lstrcmpiW(dev_name, display_device.DeviceName))
         {
             displays[display_idx].desired_mode = *dev_mode;
             if (!(dev_mode->dmFields & DM_POSITION))
             {
                 memset(&current_mode, 0, sizeof(current_mode));
                 current_mode.dmSize = sizeof(current_mode);
-                if (!NtUserEnumDisplaySettings( &device_name, ENUM_CURRENT_SETTINGS, &current_mode, 0 ))
+                if (!EnumDisplaySettingsExW(display_device.DeviceName, ENUM_CURRENT_SETTINGS, &current_mode, 0))
                     goto done;
 
                 displays[display_idx].desired_mode.dmFields |= DM_POSITION;
@@ -675,7 +669,7 @@ static LONG get_display_settings(struct x11drv_display_setting **new_displays,
         {
             memset(&current_mode, 0, sizeof(current_mode));
             current_mode.dmSize = sizeof(current_mode);
-            if (!NtUserEnumDisplaySettings( &device_name, ENUM_CURRENT_SETTINGS, &current_mode, 0 ))
+            if (!EnumDisplaySettingsExW(display_device.DeviceName, ENUM_CURRENT_SETTINGS, &current_mode, 0))
                 goto done;
 
             displays[display_idx].desired_mode = current_mode;
@@ -694,7 +688,7 @@ static LONG get_display_settings(struct x11drv_display_setting **new_displays,
     return DISP_CHANGE_SUCCESSFUL;
 
 done:
-    free(displays);
+    heap_free(displays);
     return ret;
 }
 
@@ -712,7 +706,7 @@ static BOOL overlap_placed_displays(const RECT *rect, const struct x11drv_displa
     for (display_idx = 0; display_idx < display_count; ++display_idx)
     {
         if (displays[display_idx].placed &&
-            intersect_rect(&intersect, &displays[display_idx].new_rect, rect))
+            IntersectRect(&intersect, &displays[display_idx].new_rect, rect))
             return TRUE;
     }
     return FALSE;
@@ -937,8 +931,8 @@ static BOOL all_detached_settings(const struct x11drv_display_setting *displays,
  *		ChangeDisplaySettingsEx  (X11DRV.@)
  *
  */
-LONG X11DRV_ChangeDisplaySettingsEx( LPCWSTR devname, LPDEVMODEW devmode,
-                                     HWND hwnd, DWORD flags, LPVOID lpvoid )
+LONG CDECL X11DRV_ChangeDisplaySettingsEx( LPCWSTR devname, LPDEVMODEW devmode,
+                                           HWND hwnd, DWORD flags, LPVOID lpvoid )
 {
     struct x11drv_display_setting *displays;
     INT display_idx, display_count;
@@ -953,12 +947,12 @@ LONG X11DRV_ChangeDisplaySettingsEx( LPCWSTR devname, LPDEVMODEW devmode,
     {
         for (display_idx = 0; display_idx < display_count; ++display_idx)
         {
-            if (!wcsicmp(displays[display_idx].desired_mode.dmDeviceName, devname))
+            if (!lstrcmpiW(displays[display_idx].desired_mode.dmDeviceName, devname))
             {
                 full_mode = get_full_mode(displays[display_idx].id, &displays[display_idx].desired_mode);
                 if (!full_mode)
                 {
-                    free(displays);
+                    heap_free(displays);
                     return DISP_CHANGE_BADMODE;
                 }
 
@@ -966,7 +960,7 @@ LONG X11DRV_ChangeDisplaySettingsEx( LPCWSTR devname, LPDEVMODEW devmode,
                 {
                     ERR("Failed to write %s display settings to registry.\n", wine_dbgstr_w(devname));
                     free_full_mode(full_mode);
-                    free(displays);
+                    heap_free(displays);
                     return DISP_CHANGE_NOTUPDATED;
                 }
 
@@ -978,14 +972,14 @@ LONG X11DRV_ChangeDisplaySettingsEx( LPCWSTR devname, LPDEVMODEW devmode,
 
     if (flags & (CDS_TEST | CDS_NORESET))
     {
-        free(displays);
+        heap_free(displays);
         return DISP_CHANGE_SUCCESSFUL;
     }
 
     if (all_detached_settings(displays, display_count))
     {
         WARN("Detaching all displays is not permitted.\n");
-        free(displays);
+        heap_free(displays);
         return DISP_CHANGE_SUCCESSFUL;
     }
 
@@ -997,6 +991,6 @@ LONG X11DRV_ChangeDisplaySettingsEx( LPCWSTR devname, LPDEVMODEW devmode,
         ret = apply_display_settings(displays, display_count, TRUE);
     if (ret == DISP_CHANGE_SUCCESSFUL)
         X11DRV_DisplayDevices_Update(TRUE);
-    free(displays);
+    heap_free(displays);
     return ret;
 }
diff --git a/dlls/winex11.drv/systray.c b/dlls/winex11.drv/systray.c
index 599240e3672..c6d12b21c28 100644
--- a/dlls/winex11.drv/systray.c
+++ b/dlls/winex11.drv/systray.c
@@ -20,18 +20,30 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
+#include <assert.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include <X11/Xlib.h>
+
 #define NONAMELESSUNION
-#include "x11drv_dll.h"
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
 #include "commctrl.h"
 #include "shellapi.h"
 
+#include "x11drv.h"
 #include "wine/list.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(systray);
 
-BOOL show_systray = TRUE;
-
 /* an individual systray icon */
 struct tray_icon
 {
@@ -63,6 +75,12 @@ static BOOL show_icon( struct tray_icon *icon );
 static BOOL hide_icon( struct tray_icon *icon );
 static BOOL delete_icon( struct tray_icon *icon );
 
+#define SYSTEM_TRAY_REQUEST_DOCK  0
+#define SYSTEM_TRAY_BEGIN_MESSAGE   1
+#define SYSTEM_TRAY_CANCEL_MESSAGE  2
+
+Atom systray_atom = 0;
+
 #define MIN_DISPLAYED 8
 #define ICON_BORDER 2
 
@@ -130,7 +148,7 @@ static void create_tooltip(struct tray_icon *icon)
     }
 }
 
-static void update_systray_balloon_position(void)
+void update_systray_balloon_position(void)
 {
     RECT rect;
     POINT pos;
@@ -304,13 +322,14 @@ static void add_to_standalone_tray( struct tray_icon *icon )
 
     icon->display = nb_displayed;
     pos = get_icon_pos( icon );
-    CreateWindowW( icon_classname, NULL, WS_CHILD | WS_VISIBLE,
-                   pos.x, pos.y, icon_cx, icon_cy, standalone_tray, NULL, NULL, icon );
+    icon->window = CreateWindowW( icon_classname, NULL, WS_CHILD | WS_VISIBLE,
+                                  pos.x, pos.y, icon_cx, icon_cy, standalone_tray, NULL, NULL, icon );
     if (!icon->window)
     {
         icon->display = -1;
         return;
     }
+    create_tooltip( icon );
 
     nb_displayed++;
     size = get_window_size();
@@ -455,11 +474,6 @@ static LRESULT WINAPI tray_icon_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPAR
 
     switch (msg)
     {
-    case WM_CREATE:
-        icon->window = hwnd;
-        create_tooltip( icon );
-        break;
-
     case WM_SIZE:
         if (icon->window && icon->layered) repaint_tray_icon( icon );
         break;
@@ -532,17 +546,47 @@ static LRESULT WINAPI tray_icon_wndproc(HWND hwnd, UINT msg, WPARAM wparam, LPAR
     return DefWindowProcW( hwnd, msg, wparam, lparam );
 }
 
+/* find the X11 window owner the system tray selection */
+static Window get_systray_selection_owner( Display *display )
+{
+    return XGetSelectionOwner( display, systray_atom );
+}
+
+static void get_systray_visual_info( Display *display, Window systray_window, XVisualInfo *info )
+{
+    XVisualInfo *list, template;
+    VisualID *visual_id;
+    Atom type;
+    int format, num;
+    unsigned long count, remaining;
+
+    *info = default_visual;
+    if (XGetWindowProperty( display, systray_window, x11drv_atom(_NET_SYSTEM_TRAY_VISUAL), 0,
+                            65536/sizeof(CARD32), False, XA_VISUALID, &type, &format, &count,
+                            &remaining, (unsigned char **)&visual_id ))
+        return;
+
+    if (type == XA_VISUALID && format == 32)
+    {
+        template.visualid = visual_id[0];
+        if ((list = XGetVisualInfo( display, VisualIDMask, &template, &num )))
+        {
+            *info = list[0];
+            TRACE( "systray window %lx got visual %lx\n", systray_window, info->visualid );
+            XFree( list );
+        }
+    }
+    XFree( visual_id );
+}
+
 static BOOL init_systray(void)
 {
     static BOOL init_done;
     WNDCLASSEXW class;
+    Display *display;
 
+    if (is_virtual_desktop()) return FALSE;
     if (init_done) return TRUE;
-    if (!X11DRV_CALL( systray_init, NULL ))
-    {
-        init_done = TRUE;
-        return FALSE;
-    }
 
     icon_cx = GetSystemMetrics( SM_CXSMICON ) + 2 * ICON_BORDER;
     icon_cy = GetSystemMetrics( SM_CYSMICON ) + 2 * ICON_BORDER;
@@ -572,41 +616,99 @@ static BOOL init_systray(void)
         return FALSE;
     }
 
+    display = thread_init_display();
+    if (DefaultScreen( display ) == 0)
+        systray_atom = x11drv_atom(_NET_SYSTEM_TRAY_S0);
+    else
+    {
+        char systray_buffer[29]; /* strlen(_NET_SYSTEM_TRAY_S4294967295)+1 */
+        sprintf( systray_buffer, "_NET_SYSTEM_TRAY_S%u", DefaultScreen( display ) );
+        systray_atom = XInternAtom( display, systray_buffer, False );
+    }
+    XSelectInput( display, root_window, StructureNotifyMask );
+
     init_done = TRUE;
     return TRUE;
 }
 
+/* dock the given icon with the NETWM system tray */
+static void dock_systray_icon( Display *display, struct tray_icon *icon, Window systray_window )
+{
+    Window window;
+    XEvent ev;
+    XSetWindowAttributes attr;
+    XVisualInfo visual;
+    struct x11drv_win_data *data;
+
+    get_systray_visual_info( display, systray_window, &visual );
+
+    icon->layered = (visual.depth == 32);
+    icon->window = CreateWindowExW( icon->layered ? WS_EX_LAYERED : 0,
+                                    icon_classname, NULL, WS_CLIPSIBLINGS | WS_POPUP,
+                                    CW_USEDEFAULT, CW_USEDEFAULT, icon_cx, icon_cy,
+                                    NULL, NULL, NULL, icon );
+
+    if (!(data = get_win_data( icon->window ))) return;
+    if (icon->layered) set_window_visual( data, &visual, TRUE );
+    make_window_embedded( data );
+    window = data->whole_window;
+    release_win_data( data );
+
+    create_tooltip( icon );
+    ShowWindow( icon->window, SW_SHOWNA );
+
+    TRACE( "icon window %p/%lx\n", icon->window, window );
+
+    /* send the docking request message */
+    ev.xclient.type = ClientMessage;
+    ev.xclient.window = systray_window;
+    ev.xclient.message_type = x11drv_atom( _NET_SYSTEM_TRAY_OPCODE );
+    ev.xclient.format = 32;
+    ev.xclient.data.l[0] = CurrentTime;
+    ev.xclient.data.l[1] = SYSTEM_TRAY_REQUEST_DOCK;
+    ev.xclient.data.l[2] = window;
+    ev.xclient.data.l[3] = 0;
+    ev.xclient.data.l[4] = 0;
+    XSendEvent( display, systray_window, False, NoEventMask, &ev );
+
+    if (!icon->layered)
+    {
+        attr.background_pixmap = ParentRelative;
+        attr.bit_gravity = ForgetGravity;
+        XChangeWindowAttributes( display, window, CWBackPixmap | CWBitGravity, &attr );
+    }
+    else repaint_tray_icon( icon );
+}
+
 /* dock systray windows again with the new owner */
-NTSTATUS WINAPI x11drv_systray_change_owner( void *arg, ULONG size )
+void change_systray_owner( Display *display, Window systray_window )
 {
-    struct systray_change_owner_params *params = arg;
-    struct systray_dock_params dock_params;
     struct tray_icon *icon;
 
+    TRACE( "new owner %lx\n", systray_window );
     LIST_FOR_EACH_ENTRY( icon, &icon_list, struct tray_icon, entry )
     {
         if (icon->display == -1) continue;
         hide_icon( icon );
-
-        dock_params.event_handle = params->event_handle;
-        dock_params.icon = icon;
-        dock_params.cx = icon_cx;
-        dock_params.cy = icon_cy;
-        dock_params.layered = &icon->layered;
-        X11DRV_CALL( systray_dock, &dock_params );
+        dock_systray_icon( display, icon, systray_window );
     }
-
-    return 0;
 }
 
 /* hide a tray icon */
 static BOOL hide_icon( struct tray_icon *icon )
 {
+    struct x11drv_win_data *data;
+
     TRACE( "id=0x%x, hwnd=%p\n", icon->id, icon->owner );
 
     if (!icon->window) return TRUE;  /* already hidden */
 
-    X11DRV_CALL( systray_hide, &icon->window );
+    /* make sure we don't try to unmap it, it confuses some systray docks */
+    if ((data = get_win_data( icon->window )))
+    {
+        if (data->embedded) data->mapped = FALSE;
+        release_win_data( data );
+    }
     DestroyWindow(icon->window);
     DestroyWindow(icon->tooltip);
     icon->window = 0;
@@ -620,19 +722,16 @@ static BOOL hide_icon( struct tray_icon *icon )
 /* make the icon visible */
 static BOOL show_icon( struct tray_icon *icon )
 {
-    struct systray_dock_params params;
-
-    if (icon->window) return TRUE;  /* already shown */
+    Window systray_window;
+    Display *display = thread_init_display();
 
     TRACE( "id=0x%x, hwnd=%p\n", icon->id, icon->owner );
 
-    params.event_handle = 0;
-    params.icon = icon;
-    params.cx = icon_cx;
-    params.cy = icon_cy;
-    params.layered = &icon->layered;
+    if (icon->window) return TRUE;  /* already shown */
 
-    if (X11DRV_CALL( systray_dock, &params ))
+    if ((systray_window = get_systray_selection_owner( display )))
+        dock_systray_icon( display, icon, systray_window );
+    else
         add_to_standalone_tray( icon );
 
     update_balloon( icon );
@@ -657,7 +756,11 @@ static BOOL modify_icon( struct tray_icon *icon, NOTIFYICONDATAW *nid )
         {
             if (icon->display != -1) InvalidateRect( icon->window, NULL, TRUE );
             else if (icon->layered) repaint_tray_icon( icon );
-            else X11DRV_CALL( systray_clear, &icon->window );
+            else
+            {
+                Window win = X11DRV_get_whole_window( icon->window );
+                if (win) XClearArea( gdi_display, win, 0, 0, 0, 0, True );
+            }
         }
     }
 
@@ -771,26 +874,3 @@ int CDECL wine_notify_icon( DWORD msg, NOTIFYICONDATAW *data )
     }
     return ret;
 }
-
-
-/* window procedure for foreign windows */
-LRESULT WINAPI foreign_window_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    switch(msg)
-    {
-    case WM_WINDOWPOSCHANGED:
-        update_systray_balloon_position();
-        break;
-    case WM_PARENTNOTIFY:
-        if (LOWORD(wparam) == WM_DESTROY)
-        {
-            TRACE( "%p: got parent notify destroy for win %lx\n", hwnd, lparam );
-            PostMessageW( hwnd, WM_CLOSE, 0, 0 );  /* so that we come back here once the child is gone */
-        }
-        return 0;
-    case WM_CLOSE:
-        if (GetWindow( hwnd, GW_CHILD )) return 0;  /* refuse to die if we still have children */
-        break;
-    }
-    return DefWindowProcW( hwnd, msg, wparam, lparam );
-}
diff --git a/dlls/winex11.drv/unixlib.h b/dlls/winex11.drv/unixlib.h
deleted file mode 100644
index 451c308f0cd..00000000000
--- a/dlls/winex11.drv/unixlib.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright 2022 Jacek Caban for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include "ntuser.h"
-#include "wine/unixlib.h"
-
-enum x11drv_funcs
-{
-    unix_create_desktop,
-    unix_init,
-    unix_systray_clear,
-    unix_systray_dock,
-    unix_systray_hide,
-    unix_systray_init,
-    unix_tablet_attach_queue,
-    unix_tablet_get_packet,
-    unix_tablet_info,
-    unix_tablet_load_info,
-    unix_xim_preedit_state,
-    unix_xim_reset,
-    unix_funcs_count,
-};
-
-/* FIXME: Use __wine_unix_call when the rest of the stack is ready */
-extern NTSTATUS (CDECL *x11drv_unix_call)( enum x11drv_funcs code, void *params ) DECLSPEC_HIDDEN;
-#define X11DRV_CALL(func, params) x11drv_unix_call( unix_ ## func, params )
-
-/* x11drv_create_desktop params */
-struct create_desktop_params
-{
-    UINT width;
-    UINT height;
-};
-
-/* x11drv_init params */
-struct init_params
-{
-    NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,BOOLEAN,const LARGE_INTEGER*);
-    WNDPROC foreign_window_proc;
-    BOOL show_systray;
-    NTSTATUS (CDECL *unix_call)( enum x11drv_funcs code, void *params );
-};
-
-struct systray_dock_params
-{
-    UINT64 event_handle;
-    void *icon;
-    int cx;
-    int cy;
-    BOOL *layered;
-};
-
-/* x11drv_tablet_info params */
-struct tablet_info_params
-{
-    UINT category;
-    UINT index;
-    void *output;
-};
-
-/* x11drv_xim_preedit_state params */
-struct xim_preedit_state_params
-{
-    HWND hwnd;
-    BOOL open;
-};
-
-/* driver client callbacks exposed with KernelCallbackTable interface */
-enum x11drv_client_funcs
-{
-    client_func_callback = NtUserDriverCallbackFirst,
-    client_func_dnd_enter_event,
-    client_func_dnd_position_event,
-    client_func_dnd_post_drop,
-    client_func_ime_set_composition_string,
-    client_func_ime_set_result,
-    client_func_systray_change_owner,
-    client_func_last
-};
-
-C_ASSERT( client_func_last <= NtUserDriverCallbackLast + 1 );
-
-/* simplified interface for client callbacks requiring only a single UINT parameter */
-enum client_callback
-{
-    client_dnd_drop_event,
-    client_dnd_leave_event,
-    client_ime_get_cursor_pos,
-    client_ime_set_composition_status,
-    client_ime_set_cursor_pos,
-    client_ime_set_open_status,
-    client_ime_update_association,
-    client_load_icon,
-    client_funcs_count
-};
-
-/* x11drv_callback params */
-struct client_callback_params
-{
-    UINT id;
-    UINT arg;
-};
-
-/* x11drv_dnd_enter_event and x11drv_dnd_post_drop params */
-struct format_entry
-{
-    UINT format;
-    UINT size;
-    char data[1];
-};
-
-/* x11drv_dnd_position_event params */
-struct dnd_position_event_params
-{
-    HWND  hwnd;
-    POINT point;
-    DWORD effect;
-};
-
-struct systray_change_owner_params
-{
-    UINT64 event_handle;
-};
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 101504a7887..619b0ecec1e 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -20,10 +20,6 @@
 /* NOTE: If making changes here, consider whether they should be reflected in
  * the other drivers. */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <stdarg.h>
@@ -34,6 +30,7 @@
 #include "winbase.h"
 
 #include "wine/debug.h"
+#include "wine/heap.h"
 #include "x11drv.h"
 
 #define VK_NO_PROTOTYPES
@@ -47,7 +44,14 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 #ifdef SONAME_LIBVULKAN
 WINE_DECLARE_DEBUG_CHANNEL(fps);
 
-static pthread_mutex_t vulkan_mutex;
+static CRITICAL_SECTION context_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &context_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": context_section") }
+};
+static CRITICAL_SECTION context_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 static XContext vulkan_hwnd_context;
 
@@ -105,14 +109,12 @@ static inline struct wine_vk_surface *surface_from_handle(VkSurfaceKHR handle)
 
 static void *vulkan_handle;
 
-static void wine_vk_init(void)
+static BOOL WINAPI wine_vk_init(INIT_ONCE *once, void *param, void **context)
 {
-    init_recursive_mutex(&vulkan_mutex);
-
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
     {
         ERR("Failed to load %s.\n", SONAME_LIBVULKAN);
-        return;
+        return TRUE;
     }
 
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
@@ -141,11 +143,13 @@ static void wine_vk_init(void)
 #undef LOAD_OPTIONAL_FUNCPTR
 
     vulkan_hwnd_context = XUniqueContext();
-    return;
+
+    return TRUE;
 
 fail:
     dlclose(vulkan_handle);
     vulkan_handle = NULL;
+    return TRUE;
 }
 
 /* Helper function for converting between win32 and X11 compatible VkInstanceCreateInfo.
@@ -168,7 +172,7 @@ static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo
 
     if (src->enabledExtensionCount > 0)
     {
-        enabled_extensions = calloc(src->enabledExtensionCount, sizeof(*src->ppEnabledExtensionNames));
+        enabled_extensions = heap_calloc(src->enabledExtensionCount, sizeof(*src->ppEnabledExtensionNames));
         if (!enabled_extensions)
         {
             ERR("Failed to allocate memory for enabled extensions\n");
@@ -209,21 +213,21 @@ static void wine_vk_surface_release(struct wine_vk_surface *surface)
 
     if (surface->entry.next)
     {
-        pthread_mutex_lock(&vulkan_mutex);
+        EnterCriticalSection(&context_section);
         list_remove(&surface->entry);
-        pthread_mutex_unlock(&vulkan_mutex);
+        LeaveCriticalSection(&context_section);
     }
 
     if (surface->window)
         XDestroyWindow(gdi_display, surface->window);
 
-    free(surface);
+    heap_free(surface);
 }
 
 void wine_vk_surface_destroy(HWND hwnd)
 {
     struct wine_vk_surface *surface;
-    pthread_mutex_lock(&vulkan_mutex);
+    EnterCriticalSection(&context_section);
     if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
     {
         surface->hwnd_thread_id = 0;
@@ -231,7 +235,7 @@ void wine_vk_surface_destroy(HWND hwnd)
         wine_vk_surface_release(surface);
     }
     XDeleteContext(gdi_display, (XID)hwnd, vulkan_hwnd_context);
-    pthread_mutex_unlock(&vulkan_mutex);
+    LeaveCriticalSection(&context_section);
 }
 
 void vulkan_thread_detach(void)
@@ -239,7 +243,7 @@ void vulkan_thread_detach(void)
     struct wine_vk_surface *surface, *next;
     DWORD thread_id = GetCurrentThreadId();
 
-    pthread_mutex_lock(&vulkan_mutex);
+    EnterCriticalSection(&context_section);
     LIST_FOR_EACH_ENTRY_SAFE(surface, next, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd_thread_id != thread_id)
@@ -250,7 +254,7 @@ void vulkan_thread_detach(void)
         XSync(gdi_display, False);
         wine_vk_surface_destroy(surface->hwnd);
     }
-    pthread_mutex_unlock(&vulkan_mutex);
+    LeaveCriticalSection(&context_section);
 }
 
 static VkResult X11DRV_vkCreateInstance(const VkInstanceCreateInfo *create_info,
@@ -276,7 +280,7 @@ static VkResult X11DRV_vkCreateInstance(const VkInstanceCreateInfo *create_info,
 
     res = pvkCreateInstance(&create_info_host, NULL /* allocator */, instance);
 
-    free((void *)create_info_host.ppEnabledExtensionNames);
+    heap_free((void *)create_info_host.ppEnabledExtensionNames);
     return res;
 }
 
@@ -314,13 +318,13 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
         FIXME("Support for allocation callbacks not implemented yet\n");
 
     /* TODO: support child window rendering. */
-    if (create_info->hwnd && NtUserGetAncestor(create_info->hwnd, GA_PARENT) != NtUserGetDesktopWindow())
+    if (create_info->hwnd && GetAncestor(create_info->hwnd, GA_PARENT) != GetDesktopWindow())
     {
         FIXME("Application requires child window rendering, which is not implemented yet!\n");
         return VK_ERROR_INCOMPATIBLE_DRIVER;
     }
 
-    x11_surface = calloc(1, sizeof(*x11_surface));
+    x11_surface = heap_alloc_zero(sizeof(*x11_surface));
     if (!x11_surface)
         return VK_ERROR_OUT_OF_HOST_MEMORY;
 
@@ -329,7 +333,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     if (x11_surface->hwnd)
     {
         x11_surface->window = create_client_window(create_info->hwnd, &default_visual);
-        x11_surface->hwnd_thread_id = NtUserGetWindowThread(x11_surface->hwnd, NULL);
+        x11_surface->hwnd_thread_id = GetWindowThreadProcessId(x11_surface->hwnd, NULL);
     }
     else
     {
@@ -358,14 +362,14 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
         goto err;
     }
 
-    pthread_mutex_lock(&vulkan_mutex);
+    EnterCriticalSection(&context_section);
     if (x11_surface->hwnd)
     {
         wine_vk_surface_destroy( x11_surface->hwnd );
         XSaveContext(gdi_display, (XID)create_info->hwnd, vulkan_hwnd_context, (char *)wine_vk_surface_grab(x11_surface));
     }
     list_add_tail(&surface_list, &x11_surface->entry);
-    pthread_mutex_unlock(&vulkan_mutex);
+    LeaveCriticalSection(&context_section);
 
     *surface = (uintptr_t)x11_surface;
 
@@ -581,7 +585,7 @@ static VkResult X11DRV_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice ph
     if (!formats)
         return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info_host.surface, count, NULL);
 
-    formats_host = calloc(*count, sizeof(*formats_host));
+    formats_host = heap_calloc(*count, sizeof(*formats_host));
     if (!formats_host) return VK_ERROR_OUT_OF_HOST_MEMORY;
     result = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info_host.surface, count, formats_host);
     if (result == VK_SUCCESS || result == VK_INCOMPLETE)
@@ -590,7 +594,7 @@ static VkResult X11DRV_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice ph
             formats[i].surfaceFormat = formats_host[i];
     }
 
-    free(formats_host);
+    heap_free(formats_host);
     return result;
 }
 
@@ -654,7 +658,7 @@ static VkResult X11DRV_vkQueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *
         static long prev_time, start_time;
         DWORD time;
 
-        time = NtGetTickCount();
+        time = GetTickCount();
         frames++;
         frames_total++;
         if (time - prev_time > 1500)
@@ -719,7 +723,7 @@ static void *X11DRV_get_vk_instance_proc_addr(VkInstance instance, const char *n
 
 const struct vulkan_funcs *get_vulkan_driver(UINT version)
 {
-    static pthread_once_t init_once = PTHREAD_ONCE_INIT;
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
 
     if (version != WINE_VULKAN_DRIVER_VERSION)
     {
@@ -727,7 +731,7 @@ const struct vulkan_funcs *get_vulkan_driver(UINT version)
         return NULL;
     }
 
-    pthread_once(&init_once, wine_vk_init);
+    InitOnceExecuteOnce(&init_once, wine_vk_init, NULL, NULL);
     if (vulkan_handle)
         return &vulkan_funcs;
 
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 5d9a93688c3..36fb41ac710 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -20,10 +20,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <stdarg.h>
@@ -43,20 +39,18 @@
 
 /* avoid conflict with field names in included win32 headers */
 #undef Status
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-
-#include "x11drv.h"
+#include "windef.h"
+#include "winbase.h"
 #include "wingdi.h"
 #include "winuser.h"
+#include "wine/unicode.h"
 
+#include "x11drv.h"
 #include "wine/debug.h"
 #include "wine/server.h"
 #include "mwm.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
-WINE_DECLARE_DEBUG_CHANNEL(systray);
 
 #define _NET_WM_MOVERESIZE_SIZE_TOPLEFT      0
 #define _NET_WM_MOVERESIZE_SIZE_TOP          1
@@ -74,10 +68,6 @@ WINE_DECLARE_DEBUG_CHANNEL(systray);
 #define _NET_WM_STATE_ADD     1
 #define _NET_WM_STATE_TOGGLE  2
 
-#define SYSTEM_TRAY_REQUEST_DOCK    0
-#define SYSTEM_TRAY_BEGIN_MESSAGE   1
-#define SYSTEM_TRAY_CANCEL_MESSAGE  2
-
 static const unsigned int net_wm_state_atoms[NB_NET_WM_STATES] =
 {
     XATOM__NET_WM_STATE_FULLSCREEN,
@@ -96,20 +86,24 @@ BOOL clipping_cursor = FALSE;
 XContext winContext = 0;
 
 /* X context to associate a struct x11drv_win_data to an hwnd */
-static XContext win_data_context = 0;
+XContext win_data_context = 0;
 
 /* time of last user event and window where it's stored */
 static Time last_user_time;
 static Window user_time_window;
 
-static const WCHAR foreign_window_prop[] =
-    {'_','_','w','i','n','e','_','x','1','1','_','f','o','r','e','i','g','n','_','w','i','n','d','o','w',0};
-static const WCHAR whole_window_prop[] =
-    {'_','_','w','i','n','e','_','x','1','1','_','w','h','o','l','e','_','w','i','n','d','o','w',0};
-static const WCHAR clip_window_prop[] =
-    {'_','_','w','i','n','e','_','x','1','1','_','c','l','i','p','_','w','i','n','d','o','w',0};
+static const char foreign_window_prop[] = "__wine_x11_foreign_window";
+static const char whole_window_prop[] = "__wine_x11_whole_window";
+static const char clip_window_prop[]  = "__wine_x11_clip_window";
 
-static pthread_mutex_t win_data_mutex = PTHREAD_MUTEX_INITIALIZER;
+static CRITICAL_SECTION win_data_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &win_data_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": win_data_section") }
+};
+static CRITICAL_SECTION win_data_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 
 /***********************************************************************
@@ -118,8 +112,8 @@ static pthread_mutex_t win_data_mutex = PTHREAD_MUTEX_INITIALIZER;
 static void remove_startup_notification(Display *display, Window window)
 {
     static LONG startup_notification_removed = 0;
+    char id[1024];
     char message[1024];
-    const char *id;
     int i;
     int pos;
     XEvent xevent;
@@ -129,7 +123,9 @@ static void remove_startup_notification(Display *display, Window window)
     if (InterlockedCompareExchange(&startup_notification_removed, 1, 0) != 0)
         return;
 
-    if (!(id = getenv( "DESKTOP_STARTUP_ID" )) || !id[0]) return;
+    if (GetEnvironmentVariableA("DESKTOP_STARTUP_ID", id, sizeof(id)) == 0)
+        return;
+    SetEnvironmentVariableA("DESKTOP_STARTUP_ID", NULL);
 
     if ((src = strstr( id, "_TIME" ))) update_user_time( atol( src + 5 ));
 
@@ -143,7 +139,6 @@ static void remove_startup_notification(Display *display, Window window)
     }
     message[pos++] = '"';
     message[pos++] = '\0';
-    unsetenv( "DESKTOP_STARTUP_ID" );
 
     xevent.xclient.type = ClientMessage;
     xevent.xclient.message_type = x11drv_atom(_NET_STARTUP_INFO_BEGIN);
@@ -170,6 +165,12 @@ static void remove_startup_notification(Display *display, Window window)
 }
 
 
+struct has_popup_result
+{
+    HWND hwnd;
+    BOOL found;
+};
+
 static BOOL is_managed( HWND hwnd )
 {
     struct x11drv_win_data *data = get_win_data( hwnd );
@@ -178,39 +179,24 @@ static BOOL is_managed( HWND hwnd )
     return ret;
 }
 
-HWND *build_hwnd_list(void)
+static BOOL CALLBACK has_managed_popup( HWND hwnd, LPARAM lparam )
 {
-    NTSTATUS status;
-    HWND *list;
-    UINT count = 128;
+    struct has_popup_result *result = (struct has_popup_result *)lparam;
 
-    for (;;)
-    {
-        if (!(list = malloc( count * sizeof(*list) ))) return NULL;
-        status = NtUserBuildHwndList( 0, 0, 0, 0, 0, count, list, &count );
-        if (!status) return list;
-        free( list );
-        if (status != STATUS_BUFFER_TOO_SMALL) return NULL;
-    }
+    if (hwnd == result->hwnd) return FALSE;  /* popups are always above owner */
+    if (GetWindow( hwnd, GW_OWNER ) != result->hwnd) return TRUE;
+    result->found = is_managed( hwnd );
+    return !result->found;
 }
 
 static BOOL has_owned_popups( HWND hwnd )
 {
-    HWND *list;
-    UINT i;
-    BOOL ret = FALSE;
-
-    if (!(list = build_hwnd_list())) return FALSE;
-
-    for (i = 0; list[i] != HWND_BOTTOM; i++)
-    {
-        if (list[i] == hwnd) break;  /* popups are always above owner */
-        if (NtUserGetWindowRelative( list[i], GW_OWNER ) != hwnd) continue;
-        if ((ret = is_managed( list[i] ))) break;
-    }
+    struct has_popup_result result;
 
-    free( list );
-    return ret;
+    result.hwnd = hwnd;
+    result.found = FALSE;
+    EnumWindows( has_managed_popup, (LPARAM)&result );
+    return result.found;
 }
 
 
@@ -221,12 +207,12 @@ static struct x11drv_win_data *alloc_win_data( Display *display, HWND hwnd )
 {
     struct x11drv_win_data *data;
 
-    if ((data = calloc( 1, sizeof(*data) )))
+    if ((data = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data))))
     {
         data->display = display;
         data->vis = default_visual;
         data->hwnd = hwnd;
-        pthread_mutex_lock( &win_data_mutex );
+        EnterCriticalSection( &win_data_section );
         XSaveContext( gdi_display, (XID)hwnd, win_data_context, (char *)data );
     }
     return data;
@@ -245,11 +231,11 @@ static BOOL is_window_managed( HWND hwnd, UINT swp_flags, const RECT *window_rec
     if (!managed_mode) return FALSE;
 
     /* child windows are not managed */
-    style = NtUserGetWindowLongW( hwnd, GWL_STYLE );
+    style = GetWindowLongW( hwnd, GWL_STYLE );
     if ((style & (WS_CHILD|WS_POPUP)) == WS_CHILD) return FALSE;
     /* activated windows are managed */
     if (!(swp_flags & (SWP_NOACTIVATE|SWP_HIDEWINDOW))) return TRUE;
-    if (hwnd == get_active_window()) return TRUE;
+    if (hwnd == GetActiveWindow()) return TRUE;
     /* windows with caption are managed */
     if ((style & WS_CAPTION) == WS_CAPTION) return TRUE;
     /* windows with thick frame are managed */
@@ -262,15 +248,15 @@ static BOOL is_window_managed( HWND hwnd, UINT swp_flags, const RECT *window_rec
         /* popup with sysmenu == caption are managed */
         if (style & WS_SYSMENU) return TRUE;
         /* full-screen popup windows are managed */
-        hmon = NtUserMonitorFromWindow( hwnd, MONITOR_DEFAULTTOPRIMARY );
+        hmon = MonitorFromWindow( hwnd, MONITOR_DEFAULTTOPRIMARY );
         mi.cbSize = sizeof( mi );
-        NtUserGetMonitorInfo( hmon, &mi );
+        GetMonitorInfoW( hmon, &mi );
         if (window_rect->left <= mi.rcWork.left && window_rect->right >= mi.rcWork.right &&
             window_rect->top <= mi.rcWork.top && window_rect->bottom >= mi.rcWork.bottom)
             return TRUE;
     }
     /* application windows are managed */
-    ex_style = NtUserGetWindowLongW( hwnd, GWL_EXSTYLE );
+    ex_style = GetWindowLongW( hwnd, GWL_EXSTYLE );
     if (ex_style & WS_EX_APPWINDOW) return TRUE;
     /* windows that own popups are managed */
     if (has_owned_popups( hwnd )) return TRUE;
@@ -288,7 +274,35 @@ static inline BOOL is_window_resizable( struct x11drv_win_data *data, DWORD styl
 {
     if (style & WS_THICKFRAME) return TRUE;
     /* Metacity needs the window to be resizable to make it fullscreen */
-    return NtUserIsWindowRectFullScreen( &data->whole_rect );
+    return is_window_rect_full_screen( &data->whole_rect );
+}
+
+struct monitor_info
+{
+    const RECT *rect;
+    BOOL full_screen;
+};
+
+static BOOL CALLBACK enum_monitor_proc( HMONITOR monitor, HDC hdc, RECT *monitor_rect, LPARAM lparam )
+{
+    struct monitor_info *info = (struct monitor_info *)lparam;
+
+    if (info->rect->left <= monitor_rect->left && info->rect->right >= monitor_rect->right &&
+        info->rect->top <= monitor_rect->top && info->rect->bottom >= monitor_rect->bottom)
+    {
+        info->full_screen = TRUE;
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+BOOL is_window_rect_full_screen( const RECT *rect )
+{
+    struct monitor_info info = {rect, FALSE};
+
+    EnumDisplayMonitors( NULL, NULL, enum_monitor_proc, (LPARAM)&info );
+    return info.full_screen;
 }
 
 /***********************************************************************
@@ -333,7 +347,7 @@ static int get_window_attributes( struct x11drv_win_data *data, XSetWindowAttrib
 {
     attr->override_redirect = !data->managed;
     attr->colormap          = data->whole_colormap ? data->whole_colormap : default_colormap;
-    attr->save_under        = ((NtUserGetClassLongW( data->hwnd, GCL_STYLE ) & CS_SAVEBITS) != 0);
+    attr->save_under        = ((GetClassLongW( data->hwnd, GCL_STYLE ) & CS_SAVEBITS) != 0);
     attr->bit_gravity       = NorthWestGravity;
     attr->backing_store     = NotUseful;
     attr->border_pixel      = 0;
@@ -388,10 +402,10 @@ static void sync_window_region( struct x11drv_win_data *data, HRGN win_region )
 
     if (hrgn == (HRGN)1)  /* hack: win_region == 1 means retrieve region from server */
     {
-        if (!(hrgn = NtGdiCreateRectRgn( 0, 0, 0, 0 ))) return;
-        if (NtUserGetWindowRgnEx( data->hwnd, hrgn, 0 ) == ERROR)
+        if (!(hrgn = CreateRectRgn( 0, 0, 0, 0 ))) return;
+        if (GetWindowRgn( data->hwnd, hrgn ) == ERROR)
         {
-            NtGdiDeleteObjectApp( hrgn );
+            DeleteObject( hrgn );
             hrgn = 0;
         }
     }
@@ -404,8 +418,7 @@ static void sync_window_region( struct x11drv_win_data *data, HRGN win_region )
     {
         RGNDATA *pRegionData;
 
-        if (NtUserGetWindowLongW( data->hwnd, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL)
-            NtUserMirrorRgn( data->hwnd, hrgn );
+        if (GetWindowLongW( data->hwnd, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL) MirrorRgn( data->hwnd, hrgn );
         if ((pRegionData = X11DRV_GetRegionData( hrgn, 0 )))
         {
             XShapeCombineRectangles( data->display, data->whole_window, ShapeBounding,
@@ -413,11 +426,11 @@ static void sync_window_region( struct x11drv_win_data *data, HRGN win_region )
                                      data->window_rect.top - data->whole_rect.top,
                                      (XRectangle *)pRegionData->Buffer,
                                      pRegionData->rdh.nCount, ShapeSet, YXBanded );
-            free( pRegionData );
+            HeapFree(GetProcessHeap(), 0, pRegionData);
             data->shaped = TRUE;
         }
     }
-    if (hrgn && hrgn != win_region) NtGdiDeleteObjectApp( hrgn );
+    if (hrgn && hrgn != win_region) DeleteObject( hrgn );
 #endif  /* HAVE_LIBXSHAPE */
 }
 
@@ -445,23 +458,22 @@ static void sync_window_opacity( Display *display, Window win,
  */
 static void sync_window_text( Display *display, Window win, const WCHAR *text )
 {
-    DWORD count, len;
+    UINT count;
     char *buffer, *utf8_buffer;
     XTextProperty prop;
 
     /* allocate new buffer for window text */
-    len = lstrlenW( text );
-    count = len * 3 + 1;
-    if (!(buffer = malloc( count ))) return;
-    ntdll_wcstoumbs( text, len + 1, buffer, count, FALSE );
+    count = WideCharToMultiByte(CP_UNIXCP, 0, text, -1, NULL, 0, NULL, NULL);
+    if (!(buffer = HeapAlloc( GetProcessHeap(), 0, count ))) return;
+    WideCharToMultiByte(CP_UNIXCP, 0, text, -1, buffer, count, NULL, NULL);
 
-    RtlUnicodeToUTF8N( NULL, 0, &count, text, len * sizeof(WCHAR) );
-    if (!(utf8_buffer = malloc( count )))
+    count = WideCharToMultiByte(CP_UTF8, 0, text, strlenW(text), NULL, 0, NULL, NULL);
+    if (!(utf8_buffer = HeapAlloc( GetProcessHeap(), 0, count )))
     {
-        free( buffer );
+        HeapFree( GetProcessHeap(), 0, buffer );
         return;
     }
-    RtlUnicodeToUTF8N( utf8_buffer, count, &count, text, len * sizeof(WCHAR) );
+    WideCharToMultiByte(CP_UTF8, 0, text, strlenW(text), utf8_buffer, count, NULL, NULL);
 
     if (XmbTextListToTextProperty( display, &buffer, 1, XStdICCTextStyle, &prop ) == Success)
     {
@@ -477,8 +489,8 @@ static void sync_window_text( Display *display, Window win, const WCHAR *text )
     XChangeProperty( display, win, x11drv_atom(_NET_WM_NAME), x11drv_atom(UTF8_STRING),
                      8, PropModeReplace, (unsigned char *) utf8_buffer, count);
 
-    free( utf8_buffer );
-    free( buffer );
+    HeapFree( GetProcessHeap(), 0, utf8_buffer );
+    HeapFree( GetProcessHeap(), 0, buffer );
 }
 
 
@@ -497,7 +509,7 @@ static unsigned long *get_bitmap_argb( HDC hdc, HBITMAP color, HBITMAP mask, uns
     int i, j;
     BOOL has_alpha = FALSE;
 
-    if (!NtGdiExtGetObjectW( color, sizeof(bm), &bm )) return NULL;
+    if (!GetObjectW( color, sizeof(bm), &bm )) return NULL;
     info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     info->bmiHeader.biWidth = bm.bmWidth;
     info->bmiHeader.biHeight = -bm.bmHeight;
@@ -510,9 +522,8 @@ static unsigned long *get_bitmap_argb( HDC hdc, HBITMAP color, HBITMAP mask, uns
     info->bmiHeader.biClrUsed = 0;
     info->bmiHeader.biClrImportant = 0;
     *size = bm.bmWidth * bm.bmHeight + 2;
-    if (!(bits = malloc( *size * sizeof(long) ))) goto failed;
-    if (!NtGdiGetDIBitsInternal( hdc, color, 0, bm.bmHeight, bits + 2, info, DIB_RGB_COLORS, 0, 0 ))
-        goto failed;
+    if (!(bits = HeapAlloc( GetProcessHeap(), 0, *size * sizeof(long) ))) goto failed;
+    if (!GetDIBits( hdc, color, 0, bm.bmHeight, bits + 2, info, DIB_RGB_COLORS )) goto failed;
 
     bits[0] = bm.bmWidth;
     bits[1] = bm.bmHeight;
@@ -526,14 +537,13 @@ static unsigned long *get_bitmap_argb( HDC hdc, HBITMAP color, HBITMAP mask, uns
         /* generate alpha channel from the mask */
         info->bmiHeader.biBitCount = 1;
         info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
-        if (!(mask_bits = malloc( info->bmiHeader.biSizeImage ))) goto failed;
-        if (!NtGdiGetDIBitsInternal( hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS, 0, 0 ))
-            goto failed;
+        if (!(mask_bits = HeapAlloc( GetProcessHeap(), 0, info->bmiHeader.biSizeImage ))) goto failed;
+        if (!GetDIBits( hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS )) goto failed;
         ptr = bits + 2;
         for (i = 0; i < bm.bmHeight; i++)
             for (j = 0; j < bm.bmWidth; j++, ptr++)
                 if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80)) *ptr |= 0xff000000;
-        free( mask_bits );
+        HeapFree( GetProcessHeap(), 0, mask_bits );
     }
 
     /* convert to array of longs */
@@ -543,8 +553,8 @@ static unsigned long *get_bitmap_argb( HDC hdc, HBITMAP color, HBITMAP mask, uns
     return (unsigned long *)bits;
 
 failed:
-    free( bits );
-    free( mask_bits );
+    HeapFree( GetProcessHeap(), 0, bits );
+    HeapFree( GetProcessHeap(), 0, mask_bits );
     return NULL;
 }
 
@@ -568,31 +578,27 @@ static BOOL create_icon_pixmaps( HDC hdc, const ICONINFO *icon, Pixmap *icon_ret
 
     info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     info->bmiHeader.biBitCount = 0;
-    if (!(lines = NtGdiGetDIBitsInternal( hdc, icon->hbmColor, 0, 0, NULL, info, DIB_RGB_COLORS, 0, 0 )))
-        goto failed;
-    if (!(bits.ptr = malloc( info->bmiHeader.biSizeImage ))) goto failed;
-    if (!NtGdiGetDIBitsInternal( hdc, icon->hbmColor, 0, lines, bits.ptr, info, DIB_RGB_COLORS, 0, 0 ))
-        goto failed;
+    if (!(lines = GetDIBits( hdc, icon->hbmColor, 0, 0, NULL, info, DIB_RGB_COLORS ))) goto failed;
+    if (!(bits.ptr = HeapAlloc( GetProcessHeap(), 0, info->bmiHeader.biSizeImage ))) goto failed;
+    if (!GetDIBits( hdc, icon->hbmColor, 0, lines, bits.ptr, info, DIB_RGB_COLORS )) goto failed;
 
     color_pixmap = create_pixmap_from_image( hdc, &vis, info, &bits, DIB_RGB_COLORS );
-    free( bits.ptr );
+    HeapFree( GetProcessHeap(), 0, bits.ptr );
     bits.ptr = NULL;
     if (!color_pixmap) goto failed;
 
     info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     info->bmiHeader.biBitCount = 0;
-    if (!(lines = NtGdiGetDIBitsInternal( hdc, icon->hbmMask, 0, 0, NULL, info, DIB_RGB_COLORS, 0, 0 )))
-        goto failed;
-    if (!(bits.ptr = malloc( info->bmiHeader.biSizeImage ))) goto failed;
-    if (!NtGdiGetDIBitsInternal( hdc, icon->hbmMask, 0, lines, bits.ptr, info, DIB_RGB_COLORS, 0, 0 ))
-        goto failed;
+    if (!(lines = GetDIBits( hdc, icon->hbmMask, 0, 0, NULL, info, DIB_RGB_COLORS ))) goto failed;
+    if (!(bits.ptr = HeapAlloc( GetProcessHeap(), 0, info->bmiHeader.biSizeImage ))) goto failed;
+    if (!GetDIBits( hdc, icon->hbmMask, 0, lines, bits.ptr, info, DIB_RGB_COLORS )) goto failed;
 
     /* invert the mask */
     for (i = 0; i < info->bmiHeader.biSizeImage / sizeof(DWORD); i++) ((DWORD *)bits.ptr)[i] ^= ~0u;
 
     vis.depth = 1;
     mask_pixmap = create_pixmap_from_image( hdc, &vis, info, &bits, DIB_RGB_COLORS );
-    free( bits.ptr );
+    HeapFree( GetProcessHeap(), 0, bits.ptr );
     bits.ptr = NULL;
     if (!mask_pixmap) goto failed;
 
@@ -602,16 +608,11 @@ static BOOL create_icon_pixmaps( HDC hdc, const ICONINFO *icon, Pixmap *icon_ret
 
 failed:
     if (color_pixmap) XFreePixmap( gdi_display, color_pixmap );
-    free( bits.ptr );
+    HeapFree( GetProcessHeap(), 0, bits.ptr );
     return FALSE;
 }
 
 
-static HICON get_icon_info( HICON icon, ICONINFO *ii )
-{
-    return icon && NtUserGetIconInfo( icon, ii, NULL, NULL, NULL, 0 ) ? icon : NULL;
-}
-
 /***********************************************************************
  *              fetch_icon_data
  */
@@ -626,27 +627,21 @@ static void fetch_icon_data( HWND hwnd, HICON icon_big, HICON icon_small )
 
     if (!icon_big)
     {
-        icon_big = get_icon_info( (HICON)send_message( hwnd, WM_GETICON, ICON_BIG, 0 ), &ii );
-        if (!icon_big)
-            icon_big = get_icon_info( (HICON)NtUserGetClassLongPtrW( hwnd, GCLP_HICON ), &ii );
-        if (!icon_big)
-        {
-            UINT winlogo = x11drv_client_call( client_load_icon, IDI_WINLOGO );
-            icon_big = get_icon_info( UlongToHandle( winlogo ), &ii );
-        }
+        icon_big = (HICON)SendMessageW( hwnd, WM_GETICON, ICON_BIG, 0 );
+        if (!icon_big) icon_big = (HICON)GetClassLongPtrW( hwnd, GCLP_HICON );
+        if (!icon_big) icon_big = LoadIconW( 0, (LPWSTR)IDI_WINLOGO );
     }
     if (!icon_small)
     {
-        icon_small = get_icon_info( (HICON)send_message( hwnd, WM_GETICON, ICON_SMALL, 0 ), &ii_small );
-        if (!icon_small)
-            icon_small = get_icon_info( (HICON)NtUserGetClassLongPtrW( hwnd, GCLP_HICONSM ), &ii_small );
+        icon_small = (HICON)SendMessageW( hwnd, WM_GETICON, ICON_SMALL, 0 );
+        if (!icon_small) icon_small = (HICON)GetClassLongPtrW( hwnd, GCLP_HICONSM );
     }
 
-    if (!icon_big) return;
+    if (!GetIconInfo(icon_big, &ii)) return;
 
-    hDC = NtGdiCreateCompatibleDC(0);
+    hDC = CreateCompatibleDC(0);
     bits = get_bitmap_argb( hDC, ii.hbmColor, ii.hbmMask, &size );
-    if (bits && icon_small)
+    if (bits && GetIconInfo( icon_small, &ii_small ))
     {
         unsigned int size_small;
         unsigned long *bits_small, *new;
@@ -654,29 +649,30 @@ static void fetch_icon_data( HWND hwnd, HICON icon_big, HICON icon_small )
         if ((bits_small = get_bitmap_argb( hDC, ii_small.hbmColor, ii_small.hbmMask, &size_small )) &&
             (bits_small[0] != bits[0] || bits_small[1] != bits[1]))  /* size must be different */
         {
-            if ((new = realloc( bits, (size + size_small) * sizeof(unsigned long) )))
+            if ((new = HeapReAlloc( GetProcessHeap(), 0, bits,
+                                    (size + size_small) * sizeof(unsigned long) )))
             {
                 bits = new;
                 memcpy( bits + size, bits_small, size_small * sizeof(unsigned long) );
                 size += size_small;
             }
         }
-        free( bits_small );
-        NtGdiDeleteObjectApp( ii_small.hbmColor );
-        NtGdiDeleteObjectApp( ii_small.hbmMask );
+        HeapFree( GetProcessHeap(), 0, bits_small );
+        DeleteObject( ii_small.hbmColor );
+        DeleteObject( ii_small.hbmMask );
     }
 
     if (!create_icon_pixmaps( hDC, &ii, &icon_pixmap, &mask_pixmap )) icon_pixmap = mask_pixmap = 0;
 
-    NtGdiDeleteObjectApp( ii.hbmColor );
-    NtGdiDeleteObjectApp( ii.hbmMask );
-    NtGdiDeleteObjectApp( hDC );
+    DeleteObject( ii.hbmColor );
+    DeleteObject( ii.hbmMask );
+    DeleteDC(hDC);
 
     if ((data = get_win_data( hwnd )))
     {
         if (data->icon_pixmap) XFreePixmap( gdi_display, data->icon_pixmap );
         if (data->icon_mask) XFreePixmap( gdi_display, data->icon_mask );
-        free( data->icon_bits );
+        HeapFree( GetProcessHeap(), 0, data->icon_bits );
         data->icon_pixmap = icon_pixmap;
         data->icon_mask = mask_pixmap;
         data->icon_bits = bits;
@@ -687,7 +683,7 @@ static void fetch_icon_data( HWND hwnd, HICON icon_big, HICON icon_small )
     {
         if (icon_pixmap) XFreePixmap( gdi_display, icon_pixmap );
         if (mask_pixmap) XFreePixmap( gdi_display, mask_pixmap );
-        free( bits );
+        HeapFree( GetProcessHeap(), 0, bits );
     }
 }
 
@@ -709,7 +705,7 @@ static void set_size_hints( struct x11drv_win_data *data, DWORD style )
     /* don't update size hints if window is not in normal state */
     if (!(style & (WS_MINIMIZE | WS_MAXIMIZE)))
     {
-        if (data->hwnd != NtUserGetDesktopWindow())  /* don't force position of desktop */
+        if (data->hwnd != GetDesktopWindow())  /* don't force position of desktop */
         {
             size_hints->x = data->whole_rect.left;
             size_hints->y = data->whole_rect.top;
@@ -740,7 +736,7 @@ static void set_mwm_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_s
 {
     MwmHints mwm_hints;
 
-    if (data->hwnd == NtUserGetDesktopWindow())
+    if (data->hwnd == GetDesktopWindow())
     {
         if (is_desktop_fullscreen()) mwm_hints.decorations = 0;
         else mwm_hints.decorations = MWM_DECOR_TITLE | MWM_DECOR_BORDER | MWM_DECOR_MENU | MWM_DECOR_MINIMIZE;
@@ -781,14 +777,14 @@ static void set_mwm_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_s
 static void set_style_hints( struct x11drv_win_data *data, DWORD style, DWORD ex_style )
 {
     Window group_leader = data->whole_window;
-    HWND owner = NtUserGetWindowRelative( data->hwnd, GW_OWNER );
+    HWND owner = GetWindow( data->hwnd, GW_OWNER );
     Window owner_win = 0;
     XWMHints *wm_hints;
     Atom window_type;
 
     if (owner)
     {
-        owner = NtUserGetAncestor( owner, GA_ROOT );
+        owner = GetAncestor( owner, GA_ROOT );
         owner_win = X11DRV_get_whole_window( owner );
     }
 
@@ -891,13 +887,13 @@ static void make_owner_managed( HWND hwnd )
 {
     HWND owner;
 
-    if (!(owner = NtUserGetWindowRelative( hwnd, GW_OWNER ))) return;
+    if (!(owner = GetWindow( hwnd, GW_OWNER ))) return;
     if (is_managed( owner )) return;
     if (!is_managed( hwnd )) return;
 
-    NtUserSetWindowPos( owner, 0, 0, 0, 0, 0,
-                        SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE |
-                        SWP_NOREDRAW | SWP_DEFERERASE | SWP_NOSENDCHANGING | SWP_STATECHANGED );
+    SetWindowPos( owner, 0, 0, 0, 0, 0,
+                  SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE |
+                  SWP_NOREDRAW | SWP_DEFERERASE | SWP_NOSENDCHANGING | SWP_STATECHANGED );
 }
 
 
@@ -910,7 +906,7 @@ static void set_wm_hints( struct x11drv_win_data *data )
 {
     DWORD style, ex_style;
 
-    if (data->hwnd == NtUserGetDesktopWindow())
+    if (data->hwnd == GetDesktopWindow())
     {
         /* force some styles for the desktop to get the correct decorations */
         style = WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;
@@ -918,8 +914,8 @@ static void set_wm_hints( struct x11drv_win_data *data )
     }
     else
     {
-        style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE );
-        ex_style = NtUserGetWindowLongW( data->hwnd, GWL_EXSTYLE );
+        style = GetWindowLongW( data->hwnd, GWL_STYLE );
+        ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
     }
 
     set_size_hints( data, style );
@@ -936,7 +932,7 @@ Window init_clip_window(void)
     struct x11drv_thread_data *data = x11drv_init_thread_data();
 
     if (!data->clip_window &&
-        (data->clip_window = (Window)NtUserGetProp( NtUserGetDesktopWindow(), clip_window_prop )))
+        (data->clip_window = (Window)GetPropA( GetDesktopWindow(), clip_window_prop )))
     {
         XSelectInput( data->display, data->clip_window, StructureNotifyMask );
     }
@@ -979,10 +975,10 @@ void update_net_wm_states( struct x11drv_win_data *data )
     if (!data->managed) return;
     if (data->whole_window == root_window) return;
 
-    style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE );
+    style = GetWindowLongW( data->hwnd, GWL_STYLE );
     if (style & WS_MINIMIZE)
         new_state |= data->net_wm_state & ((1 << NET_WM_STATE_FULLSCREEN)|(1 << NET_WM_STATE_MAXIMIZED));
-    if (NtUserIsWindowRectFullScreen( &data->whole_rect ))
+    if (is_window_rect_full_screen( &data->whole_rect ))
     {
         if ((style & WS_MAXIMIZE) && (style & WS_CAPTION) == WS_CAPTION)
             new_state |= (1 << NET_WM_STATE_MAXIMIZED);
@@ -992,14 +988,14 @@ void update_net_wm_states( struct x11drv_win_data *data )
     else if (style & WS_MAXIMIZE)
         new_state |= (1 << NET_WM_STATE_MAXIMIZED);
 
-    ex_style = NtUserGetWindowLongW( data->hwnd, GWL_EXSTYLE );
+    ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
     if (ex_style & WS_EX_TOPMOST)
         new_state |= (1 << NET_WM_STATE_ABOVE);
     if (!data->add_taskbar)
     {
         if (data->skip_taskbar || (ex_style & (WS_EX_TOOLWINDOW | WS_EX_NOACTIVATE)))
             new_state |= (1 << NET_WM_STATE_SKIP_TASKBAR) | (1 << NET_WM_STATE_SKIP_PAGER);
-        else if (!(ex_style & WS_EX_APPWINDOW) && NtUserGetWindowRelative( data->hwnd, GW_OWNER ))
+        else if (!(ex_style & WS_EX_APPWINDOW) && GetWindow( data->hwnd, GW_OWNER ))
             new_state |= (1 << NET_WM_STATE_SKIP_TASKBAR);
     }
 
@@ -1203,8 +1199,8 @@ static void get_decoration_rect( struct x11drv_win_data *data, RECT *rect,
     SetRectEmpty( rect );
     if (!data->managed) return;
 
-    style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE );
-    ex_style = NtUserGetWindowLongW( data->hwnd, GWL_EXSTYLE );
+    style = GetWindowLongW( data->hwnd, GWL_STYLE );
+    ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
     decor = get_mwm_decorations( data, style, ex_style, window_rect, client_rect );
 
     if (decor & MWM_DECOR_TITLE) style_mask |= WS_CAPTION;
@@ -1270,8 +1266,8 @@ static void sync_window_position( struct x11drv_win_data *data,
                                   UINT swp_flags, const RECT *old_window_rect,
                                   const RECT *old_whole_rect, const RECT *old_client_rect )
 {
-    DWORD style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE );
-    DWORD ex_style = NtUserGetWindowLongW( data->hwnd, GWL_EXSTYLE );
+    DWORD style = GetWindowLongW( data->hwnd, GWL_STYLE );
+    DWORD ex_style = GetWindowLongW( data->hwnd, GWL_EXSTYLE );
     XWindowChanges changes;
     unsigned int mask = 0;
 
@@ -1301,9 +1297,9 @@ static void sync_window_position( struct x11drv_win_data *data,
     if (!(swp_flags & SWP_NOZORDER) || (swp_flags & SWP_SHOWWINDOW))
     {
         /* find window that this one must be after */
-        HWND prev = NtUserGetWindowRelative( data->hwnd, GW_HWNDPREV );
-        while (prev && !(NtUserGetWindowLongW( prev, GWL_STYLE ) & WS_VISIBLE))
-            prev = NtUserGetWindowRelative( prev, GW_HWNDPREV );
+        HWND prev = GetWindow( data->hwnd, GW_HWNDPREV );
+        while (prev && !(GetWindowLongW( prev, GWL_STYLE ) & WS_VISIBLE))
+            prev = GetWindow( prev, GW_HWNDPREV );
         if (!prev)  /* top child */
         {
             changes.stack_mode = Above;
@@ -1392,9 +1388,9 @@ static void move_window_bits( HWND hwnd, Window window, const RECT *old_rect, co
     if (!window)
     {
         OffsetRect( &dst_rect, -new_window_rect->left, -new_window_rect->top );
-        parent = NtUserGetAncestor( hwnd, GA_PARENT );
-        hdc_src = NtUserGetDCEx( parent, 0, DCX_CACHE );
-        hdc_dst = NtUserGetDCEx( hwnd, 0, DCX_CACHE | DCX_WINDOW );
+        parent = GetAncestor( hwnd, GA_PARENT );
+        hdc_src = GetDCEx( parent, 0, DCX_CACHE );
+        hdc_dst = GetDCEx( hwnd, 0, DCX_CACHE | DCX_WINDOW );
     }
     else
     {
@@ -1402,48 +1398,48 @@ static void move_window_bits( HWND hwnd, Window window, const RECT *old_rect, co
         /* make src rect relative to the old position of the window */
         OffsetRect( &src_rect, -old_client_rect->left, -old_client_rect->top );
         if (dst_rect.left == src_rect.left && dst_rect.top == src_rect.top) return;
-        hdc_src = hdc_dst = NtUserGetDCEx( hwnd, 0, DCX_CACHE );
+        hdc_src = hdc_dst = GetDCEx( hwnd, 0, DCX_CACHE );
     }
 
-    rgn = NtGdiCreateRectRgn( dst_rect.left, dst_rect.top, dst_rect.right, dst_rect.bottom );
-    NtGdiExtSelectClipRgn( hdc_dst, rgn, RGN_COPY );
-    NtGdiDeleteObjectApp( rgn );
+    rgn = CreateRectRgnIndirect( &dst_rect );
+    SelectClipRgn( hdc_dst, rgn );
+    DeleteObject( rgn );
     /* WS_CLIPCHILDREN doesn't exclude children from the window update
      * region, and ExcludeUpdateRgn call may inappropriately clip valid
      * child window contents from the copied parent window bits, but we
      * still want to avoid copying invalid window bits when possible.
      */
-    if (!(NtUserGetWindowLongW( hwnd, GWL_STYLE ) & WS_CLIPCHILDREN ))
-        NtUserExcludeUpdateRgn( hdc_dst, hwnd );
+    if (!(GetWindowLongW( hwnd, GWL_STYLE ) & WS_CLIPCHILDREN ))
+        ExcludeUpdateRgn( hdc_dst, hwnd );
 
     code = X11DRV_START_EXPOSURES;
-    NtGdiExtEscape( hdc_dst, NULL, 0, X11DRV_ESCAPE, sizeof(code), (LPSTR)&code, 0, NULL );
+    ExtEscape( hdc_dst, X11DRV_ESCAPE, sizeof(code), (LPSTR)&code, 0, NULL );
 
     TRACE( "copying bits for win %p/%lx %s -> %s\n",
            hwnd, window, wine_dbgstr_rect(&src_rect), wine_dbgstr_rect(&dst_rect) );
-    NtGdiBitBlt( hdc_dst, dst_rect.left, dst_rect.top,
-                 dst_rect.right - dst_rect.left, dst_rect.bottom - dst_rect.top,
-                 hdc_src, src_rect.left, src_rect.top, SRCCOPY, 0, 0 );
+    BitBlt( hdc_dst, dst_rect.left, dst_rect.top,
+            dst_rect.right - dst_rect.left, dst_rect.bottom - dst_rect.top,
+            hdc_src, src_rect.left, src_rect.top, SRCCOPY );
 
     rgn = 0;
     code = X11DRV_END_EXPOSURES;
-    NtGdiExtEscape( hdc_dst, NULL, 0, X11DRV_ESCAPE, sizeof(code), (LPSTR)&code, sizeof(rgn), (LPSTR)&rgn );
+    ExtEscape( hdc_dst, X11DRV_ESCAPE, sizeof(code), (LPSTR)&code, sizeof(rgn), (LPSTR)&rgn );
 
-    NtUserReleaseDC( hwnd, hdc_dst );
-    if (hdc_src != hdc_dst) NtUserReleaseDC( parent, hdc_src );
+    ReleaseDC( hwnd, hdc_dst );
+    if (hdc_src != hdc_dst) ReleaseDC( parent, hdc_src );
 
     if (rgn)
     {
         if (!window)
         {
             /* map region to client rect since we are using DCX_WINDOW */
-            NtGdiOffsetRgn( rgn, new_window_rect->left - new_client_rect->left,
+            OffsetRgn( rgn, new_window_rect->left - new_client_rect->left,
                        new_window_rect->top - new_client_rect->top );
-            NtUserRedrawWindow( hwnd, NULL, rgn,
-                                RDW_INVALIDATE | RDW_FRAME | RDW_ERASE | RDW_ALLCHILDREN );
+            RedrawWindow( hwnd, NULL, rgn,
+                          RDW_INVALIDATE | RDW_FRAME | RDW_ERASE | RDW_ALLCHILDREN );
         }
-        else NtUserRedrawWindow( hwnd, NULL, rgn, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN );
-        NtGdiDeleteObjectApp( rgn );
+        else RedrawWindow( hwnd, NULL, rgn, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN );
+        DeleteObject( rgn );
     }
 }
 
@@ -1505,10 +1501,10 @@ Window create_client_window( HWND hwnd, const XVisualInfo *visual )
     if (!data)
     {
         /* explicitly create data for HWND_MESSAGE windows since they can be used for OpenGL */
-        HWND parent = NtUserGetAncestor( hwnd, GA_PARENT );
-        if (parent == NtUserGetDesktopWindow() || NtUserGetAncestor( parent, GA_PARENT )) return 0;
+        HWND parent = GetAncestor( hwnd, GA_PARENT );
+        if (parent == GetDesktopWindow() || GetAncestor( parent, GA_PARENT )) return 0;
         if (!(data = alloc_win_data( thread_init_display(), hwnd ))) return 0;
-        NtUserGetClientRect( hwnd, &data->client_rect );
+        GetClientRect( hwnd, &data->client_rect );
         data->window_rect = data->whole_rect = data->client_rect;
     }
 
@@ -1575,10 +1571,9 @@ static void create_whole_window( struct x11drv_win_data *data )
         data->managed = TRUE;
     }
 
-    if ((win_rgn = NtGdiCreateRectRgn( 0, 0, 0, 0 )) &&
-        NtUserGetWindowRgnEx( data->hwnd, win_rgn, 0 ) == ERROR)
+    if ((win_rgn = CreateRectRgn( 0, 0, 0, 0 )) && GetWindowRgn( data->hwnd, win_rgn ) == ERROR)
     {
-        NtGdiDeleteObjectApp( win_rgn );
+        DeleteObject( win_rgn );
         win_rgn = 0;
     }
     data->shaped = (win_rgn != 0);
@@ -1603,17 +1598,17 @@ static void create_whole_window( struct x11drv_win_data *data )
     set_wm_hints( data );
 
     XSaveContext( data->display, data->whole_window, winContext, (char *)data->hwnd );
-    NtUserSetProp( data->hwnd, whole_window_prop, (HANDLE)data->whole_window );
+    SetPropA( data->hwnd, whole_window_prop, (HANDLE)data->whole_window );
 
     /* set the window text */
-    if (!NtUserInternalGetWindowText( data->hwnd, text, ARRAY_SIZE( text ))) text[0] = 0;
+    if (!InternalGetWindowText( data->hwnd, text, ARRAY_SIZE( text ))) text[0] = 0;
     sync_window_text( data->display, data->whole_window, text );
 
     /* set the window region */
     if (win_rgn || IsRectEmpty( &data->window_rect )) sync_window_region( data, win_rgn );
 
     /* set the window opacity */
-    if (!NtUserGetLayeredWindowAttributes( data->hwnd, &key, &alpha, &layered_flags )) layered_flags = 0;
+    if (!GetLayeredWindowAttributes( data->hwnd, &key, &alpha, &layered_flags )) layered_flags = 0;
     sync_window_opacity( data->display, data->whole_window, key, alpha, layered_flags );
 
     XFlush( data->display );  /* make sure the window exists before we start painting to it */
@@ -1621,7 +1616,7 @@ static void create_whole_window( struct x11drv_win_data *data )
     sync_window_cursor( data->whole_window );
 
 done:
-    if (win_rgn) NtGdiDeleteObjectApp( win_rgn );
+    if (win_rgn) DeleteObject( win_rgn );
 }
 
 
@@ -1640,12 +1635,12 @@ static void destroy_whole_window( struct x11drv_win_data *data, BOOL already_des
     {
         if (data->embedded)
         {
-            Window xwin = (Window)NtUserGetProp( data->hwnd, foreign_window_prop );
+            Window xwin = (Window)GetPropA( data->hwnd, foreign_window_prop );
             if (xwin)
             {
                 if (!already_destroyed) XSelectInput( data->display, xwin, 0 );
                 XDeleteContext( data->display, xwin, winContext );
-                NtUserRemoveProp( data->hwnd, foreign_window_prop );
+                RemovePropA( data->hwnd, foreign_window_prop );
             }
             return;
         }
@@ -1677,7 +1672,7 @@ static void destroy_whole_window( struct x11drv_win_data *data, BOOL already_des
     XFlush( data->display );
     if (data->surface) window_surface_release( data->surface );
     data->surface = NULL;
-    NtUserRemoveProp( data->hwnd, whole_window_prop );
+    RemovePropA( data->hwnd, whole_window_prop );
 }
 
 
@@ -1714,7 +1709,7 @@ void set_window_visual( struct x11drv_win_data *data, const XVisualInfo *vis, BO
 /*****************************************************************
  *		SetWindowText   (X11DRV.@)
  */
-void X11DRV_SetWindowText( HWND hwnd, LPCWSTR text )
+void CDECL X11DRV_SetWindowText( HWND hwnd, LPCWSTR text )
 {
     Window win;
 
@@ -1731,12 +1726,12 @@ void X11DRV_SetWindowText( HWND hwnd, LPCWSTR text )
  *
  * Update the X state of a window to reflect a style change
  */
-void X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
+void CDECL X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
 {
     struct x11drv_win_data *data;
     DWORD changed = style->styleNew ^ style->styleOld;
 
-    if (hwnd == NtUserGetDesktopWindow()) return;
+    if (hwnd == GetDesktopWindow()) return;
     if (!(data = get_win_data( hwnd ))) return;
     if (!data->whole_window) goto done;
 
@@ -1757,7 +1752,7 @@ done:
 /***********************************************************************
  *		DestroyWindow   (X11DRV.@)
  */
-void X11DRV_DestroyWindow( HWND hwnd )
+void CDECL X11DRV_DestroyWindow( HWND hwnd )
 {
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     struct x11drv_win_data *data;
@@ -1770,10 +1765,10 @@ void X11DRV_DestroyWindow( HWND hwnd )
     if (data->icon_pixmap) XFreePixmap( gdi_display, data->icon_pixmap );
     if (data->icon_mask) XFreePixmap( gdi_display, data->icon_mask );
     if (data->client_colormap) XFreeColormap( data->display, data->client_colormap );
-    free( data->icon_bits );
+    HeapFree( GetProcessHeap(), 0, data->icon_bits );
     XDeleteContext( gdi_display, (XID)hwnd, win_data_context );
     release_win_data( data );
-    free( data );
+    HeapFree( GetProcessHeap(), 0, data );
     destroy_gl_drawable( hwnd );
     wine_vk_surface_destroy( hwnd );
 }
@@ -1793,7 +1788,7 @@ BOOL X11DRV_DestroyNotify( HWND hwnd, XEvent *event )
 
     destroy_whole_window( data, TRUE );
     release_win_data( data );
-    if (embedded) send_message( hwnd, WM_CLOSE, 0, 0 );
+    if (embedded) SendMessageW( hwnd, WM_CLOSE, 0, 0 );
     return TRUE;
 }
 
@@ -1805,10 +1800,10 @@ BOOL create_desktop_win_data( Window win )
     Display *display = thread_data->display;
     struct x11drv_win_data *data;
 
-    if (!(data = alloc_win_data( display, NtUserGetDesktopWindow() ))) return FALSE;
+    if (!(data = alloc_win_data( display, GetDesktopWindow() ))) return FALSE;
     data->whole_window = win;
     data->managed = TRUE;
-    NtUserSetProp( data->hwnd, whole_window_prop, (HANDLE)win );
+    SetPropA( data->hwnd, whole_window_prop, (HANDLE)win );
     set_initial_wm_hints( display, win );
     release_win_data( data );
     if (thread_data->clip_window) XReparentWindow( display, thread_data->clip_window, win, 0, 0 );
@@ -1818,7 +1813,7 @@ BOOL create_desktop_win_data( Window win )
 /**********************************************************************
  *		CreateDesktopWindow   (X11DRV.@)
  */
-BOOL X11DRV_CreateDesktopWindow( HWND hwnd )
+BOOL CDECL X11DRV_CreateDesktopWindow( HWND hwnd )
 {
     unsigned int width, height;
 
@@ -1835,7 +1830,7 @@ BOOL X11DRV_CreateDesktopWindow( HWND hwnd )
 
     if (!width && !height)  /* not initialized yet */
     {
-        RECT rect = NtUserGetVirtualScreenRect();
+        RECT rect = get_virtual_screen_rect();
 
         SERVER_START_REQ( set_window_pos )
         {
@@ -1853,28 +1848,27 @@ BOOL X11DRV_CreateDesktopWindow( HWND hwnd )
     }
     else
     {
-        Window win = (Window)NtUserGetProp( hwnd, whole_window_prop );
+        Window win = (Window)GetPropA( hwnd, whole_window_prop );
         if (win && win != root_window) X11DRV_init_desktop( win, width, height );
     }
     return TRUE;
 }
 
 
+static WNDPROC desktop_orig_wndproc;
+
 #define WM_WINE_NOTIFY_ACTIVITY WM_USER
 #define WM_WINE_DELETE_TAB      (WM_USER + 1)
 #define WM_WINE_ADD_TAB         (WM_USER + 2)
 
-/**********************************************************************
- *           DesktopWindowProc   (X11DRV.@)
- */
-LRESULT X11DRV_DesktopWindowProc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
+static LRESULT CALLBACK desktop_wndproc_wrapper( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
 {
     switch (msg)
     {
     case WM_WINE_NOTIFY_ACTIVITY:
     {
-        static ULONG last = 0;
-        ULONG now = NtGetTickCount();
+        static ULONGLONG last = 0;
+        ULONGLONG now = GetTickCount64();
         /* calling XResetScreenSaver too often can cause performance
          * problems, so throttle it */
         if (now > last + 5000)
@@ -1886,25 +1880,28 @@ LRESULT X11DRV_DesktopWindowProc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
         break;
     }
     case WM_WINE_DELETE_TAB:
-        send_notify_message( (HWND)wp, WM_X11DRV_DELETE_TAB, 0, 0 );
+        SendNotifyMessageW( (HWND)wp, WM_X11DRV_DELETE_TAB, 0, 0 );
         break;
     case WM_WINE_ADD_TAB:
-        send_notify_message( (HWND)wp, WM_X11DRV_ADD_TAB, 0, 0 );
+        SendNotifyMessageW( (HWND)wp, WM_X11DRV_ADD_TAB, 0, 0 );
         break;
     }
-    return NtUserMessageCall( hwnd, msg, wp, lp, 0, NtUserDefWindowProc, FALSE );
+    return desktop_orig_wndproc( hwnd, msg, wp, lp );
 }
 
 /**********************************************************************
  *		CreateWindow   (X11DRV.@)
  */
-BOOL X11DRV_CreateWindow( HWND hwnd )
+BOOL CDECL X11DRV_CreateWindow( HWND hwnd )
 {
-    if (hwnd == NtUserGetDesktopWindow())
+    if (hwnd == GetDesktopWindow())
     {
         struct x11drv_thread_data *data = x11drv_init_thread_data();
         XSetWindowAttributes attr;
 
+        desktop_orig_wndproc = (WNDPROC)SetWindowLongPtrW( hwnd, GWLP_WNDPROC,
+                                                           (LONG_PTR)desktop_wndproc_wrapper );
+
         /* create the cursor clipping window */
         attr.override_redirect = TRUE;
         attr.event_mask = StructureNotifyMask | FocusChangeMask;
@@ -1912,7 +1909,8 @@ BOOL X11DRV_CreateWindow( HWND hwnd )
                                            InputOnly, default_visual.visual,
                                            CWOverrideRedirect | CWEventMask, &attr );
         XFlush( data->display );
-        NtUserSetProp( hwnd, clip_window_prop, (HANDLE)data->clip_window );
+        SetPropA( hwnd, clip_window_prop, (HANDLE)data->clip_window );
+        X11DRV_InitClipboard();
         X11DRV_DisplayDevices_RegisterEventHandlers();
     }
     return TRUE;
@@ -1929,10 +1927,10 @@ struct x11drv_win_data *get_win_data( HWND hwnd )
     char *data;
 
     if (!hwnd) return NULL;
-    pthread_mutex_lock( &win_data_mutex );
+    EnterCriticalSection( &win_data_section );
     if (!XFindContext( gdi_display, (XID)hwnd, win_data_context, &data ))
         return (struct x11drv_win_data *)data;
-    pthread_mutex_unlock( &win_data_mutex );
+    LeaveCriticalSection( &win_data_section );
     return NULL;
 }
 
@@ -1944,7 +1942,7 @@ struct x11drv_win_data *get_win_data( HWND hwnd )
  */
 void release_win_data( struct x11drv_win_data *data )
 {
-    if (data) pthread_mutex_unlock( &win_data_mutex );
+    if (data) LeaveCriticalSection( &win_data_section );
 }
 
 
@@ -1960,12 +1958,12 @@ static struct x11drv_win_data *X11DRV_create_win_data( HWND hwnd, const RECT *wi
     struct x11drv_win_data *data;
     HWND parent;
 
-    if (!(parent = NtUserGetAncestor( hwnd, GA_PARENT ))) return NULL;  /* desktop */
+    if (!(parent = GetAncestor( hwnd, GA_PARENT ))) return NULL;  /* desktop */
 
     /* don't create win data for HWND_MESSAGE windows */
-    if (parent != NtUserGetDesktopWindow() && !NtUserGetAncestor( parent, GA_PARENT )) return NULL;
+    if (parent != GetDesktopWindow() && !GetAncestor( parent, GA_PARENT )) return NULL;
 
-    if (NtUserGetWindowThread( hwnd, NULL ) != GetCurrentThreadId()) return NULL;
+    if (GetWindowThreadProcessId( hwnd, NULL ) != GetCurrentThreadId()) return NULL;
 
     /* Recreate the parent gl_drawable now that we know there are child windows
      * that will need clipping support.
@@ -1979,7 +1977,7 @@ static struct x11drv_win_data *X11DRV_create_win_data( HWND hwnd, const RECT *wi
 
     data->whole_rect = data->window_rect = *window_rect;
     data->client_rect = *client_rect;
-    if (parent == NtUserGetDesktopWindow())
+    if (parent == GetDesktopWindow())
     {
         create_whole_window( data );
         TRACE( "win %p/%lx window %s whole %s client %s\n",
@@ -1990,6 +1988,29 @@ static struct x11drv_win_data *X11DRV_create_win_data( HWND hwnd, const RECT *wi
 }
 
 
+/* window procedure for foreign windows */
+static LRESULT WINAPI foreign_window_proc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
+{
+    switch(msg)
+    {
+    case WM_WINDOWPOSCHANGED:
+        update_systray_balloon_position();
+        break;
+    case WM_PARENTNOTIFY:
+        if (LOWORD(wparam) == WM_DESTROY)
+        {
+            TRACE( "%p: got parent notify destroy for win %lx\n", hwnd, lparam );
+            PostMessageW( hwnd, WM_CLOSE, 0, 0 );  /* so that we come back here once the child is gone */
+        }
+        return 0;
+    case WM_CLOSE:
+        if (GetWindow( hwnd, GW_CHILD )) return 0;  /* refuse to die if we still have children */
+        break;
+    }
+    return DefWindowProcW( hwnd, msg, wparam, lparam );
+}
+
+
 /***********************************************************************
  *		create_foreign_window
  *
@@ -2007,20 +2028,16 @@ HWND create_foreign_window( Display *display, Window xwin )
     unsigned int nchildren;
     XWindowAttributes attr;
     DWORD style = WS_CLIPCHILDREN;
-    UNICODE_STRING class_name;
 
     if (!class_registered)
     {
-        UNICODE_STRING version = { 0 };
         WNDCLASSEXW class;
 
         memset( &class, 0, sizeof(class) );
         class.cbSize        = sizeof(class);
-        class.lpfnWndProc   = client_foreign_window_proc;
+        class.lpfnWndProc   = foreign_window_proc;
         class.lpszClassName = classW;
-        RtlInitUnicodeString( &class_name, classW );
-        if (!NtUserRegisterClassExWOW( &class, &class_name, &version, NULL, 0, 0, NULL ) &&
-            GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
+        if (!RegisterClassExW( &class ) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
         {
             ERR( "Could not register foreign window class\n" );
             return FALSE;
@@ -2042,7 +2059,7 @@ HWND create_foreign_window( Display *display, Window xwin )
 
     if (xparent == xroot)
     {
-        parent = NtUserGetDesktopWindow();
+        parent = GetDesktopWindow();
         style |= WS_POPUP;
         pos = root_to_virtual_screen( attr.x, attr.y );
     }
@@ -2054,14 +2071,12 @@ HWND create_foreign_window( Display *display, Window xwin )
         pos.y = attr.y;
     }
 
-    RtlInitUnicodeString( &class_name, classW );
-    hwnd = NtUserCreateWindowEx( 0, &class_name, &class_name, NULL, style, pos.x, pos.y,
-                                 attr.width, attr.height, parent, 0, NULL, NULL, 0, NULL,
-                                 0, FALSE );
+    hwnd = CreateWindowW( classW, NULL, style, pos.x, pos.y, attr.width, attr.height,
+                          parent, 0, 0, NULL );
 
     if (!(data = alloc_win_data( display, hwnd )))
     {
-        NtUserDestroyWindow( hwnd );
+        DestroyWindow( hwnd );
         return 0;
     }
     SetRect( &data->window_rect, pos.x, pos.y, pos.x + attr.width, pos.y + attr.height );
@@ -2070,7 +2085,7 @@ HWND create_foreign_window( Display *display, Window xwin )
     data->embedded = TRUE;
     data->mapped = TRUE;
 
-    NtUserSetProp( hwnd, foreign_window_prop, (HANDLE)xwin );
+    SetPropA( hwnd, foreign_window_prop, (HANDLE)xwin );
     XSaveContext( display, xwin, winContext, (char *)data->hwnd );
 
     TRACE( "win %lx parent %p style %08x %s -> hwnd %p\n",
@@ -2078,168 +2093,11 @@ HWND create_foreign_window( Display *display, Window xwin )
 
     release_win_data( data );
 
-    NtUserShowWindow( hwnd, SW_SHOW );
+    ShowWindow( hwnd, SW_SHOW );
     return hwnd;
 }
 
 
-NTSTATUS x11drv_systray_init( void *arg )
-{
-    Display *display;
-
-    if (is_virtual_desktop()) return FALSE;
-
-    display = thread_init_display();
-    if (DefaultScreen( display ) == 0)
-        systray_atom = x11drv_atom(_NET_SYSTEM_TRAY_S0);
-    else
-    {
-        char systray_buffer[29]; /* strlen(_NET_SYSTEM_TRAY_S4294967295)+1 */
-        sprintf( systray_buffer, "_NET_SYSTEM_TRAY_S%u", DefaultScreen( display ) );
-        systray_atom = XInternAtom( display, systray_buffer, False );
-    }
-    XSelectInput( display, root_window, StructureNotifyMask );
-
-    return TRUE;
-}
-
-
-NTSTATUS x11drv_systray_clear( void *arg )
-{
-    HWND hwnd = *(HWND*)arg;
-    Window win = X11DRV_get_whole_window( hwnd );
-    if (win) XClearArea( gdi_display, win, 0, 0, 0, 0, True );
-    return 0;
-}
-
-
-NTSTATUS x11drv_systray_hide( void *arg )
-{
-    HWND hwnd = *(HWND*)arg;
-    struct x11drv_win_data *data;
-
-    /* make sure we don't try to unmap it, it confuses some systray docks */
-    if ((data = get_win_data( hwnd )))
-    {
-        if (data->embedded) data->mapped = FALSE;
-        release_win_data( data );
-    }
-
-    return 0;
-}
-
-
-/* find the X11 window owner the system tray selection */
-static Window get_systray_selection_owner( Display *display )
-{
-    return XGetSelectionOwner( display, systray_atom );
-}
-
-
-static void get_systray_visual_info( Display *display, Window systray_window, XVisualInfo *info )
-{
-    XVisualInfo *list, template;
-    VisualID *visual_id;
-    Atom type;
-    int format, num;
-    unsigned long count, remaining;
-
-    *info = default_visual;
-    if (XGetWindowProperty( display, systray_window, x11drv_atom(_NET_SYSTEM_TRAY_VISUAL), 0,
-                            65536/sizeof(CARD32), False, XA_VISUALID, &type, &format, &count,
-                            &remaining, (unsigned char **)&visual_id ))
-        return;
-
-    if (type == XA_VISUALID && format == 32)
-    {
-        template.visualid = visual_id[0];
-        if ((list = XGetVisualInfo( display, VisualIDMask, &template, &num )))
-        {
-            *info = list[0];
-            TRACE_(systray)( "systray window %lx got visual %lx\n", systray_window, info->visualid );
-            XFree( list );
-        }
-    }
-    XFree( visual_id );
-}
-
-
-NTSTATUS x11drv_systray_dock( void *arg )
-{
-    struct systray_dock_params *params = arg;
-    Window systray_window, window;
-    Display *display;
-    XEvent ev;
-    XSetWindowAttributes attr;
-    XVisualInfo visual;
-    struct x11drv_win_data *data;
-    UNICODE_STRING class_name;
-    BOOL layered;
-    HWND hwnd;
-
-    static const WCHAR icon_classname[] =
-        {'_','_','w','i','n','e','x','1','1','_','t','r','a','y','_','i','c','o','n',0};
-
-    if (params->event_handle)
-    {
-        XClientMessageEvent *event = (XClientMessageEvent *)(UINT_PTR)params->event_handle;
-        display = event->display;
-        systray_window = event->data.l[2];
-    }
-    else
-    {
-        display = thread_init_display();
-        if (!(systray_window = get_systray_selection_owner( display ))) return STATUS_UNSUCCESSFUL;
-    }
-
-    get_systray_visual_info( display, systray_window, &visual );
-
-    *params->layered = layered = (visual.depth == 32);
-
-    RtlInitUnicodeString( &class_name, icon_classname );
-    hwnd = NtUserCreateWindowEx( layered ? WS_EX_LAYERED : 0, &class_name, &class_name, NULL,
-                                 WS_CLIPSIBLINGS | WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT,
-                                 params->cx, params->cy, NULL, 0, NULL, params->icon, 0,
-                                 NULL, 0, FALSE );
-
-    if (!(data = get_win_data( hwnd ))) return STATUS_UNSUCCESSFUL;
-    if (layered) set_window_visual( data, &visual, TRUE );
-    make_window_embedded( data );
-    window = data->whole_window;
-    release_win_data( data );
-
-    NtUserShowWindow( hwnd, SW_SHOWNA );
-
-    TRACE_(systray)( "icon window %p/%lx\n", hwnd, window );
-
-    /* send the docking request message */
-    ev.xclient.type = ClientMessage;
-    ev.xclient.window = systray_window;
-    ev.xclient.message_type = x11drv_atom( _NET_SYSTEM_TRAY_OPCODE );
-    ev.xclient.format = 32;
-    ev.xclient.data.l[0] = CurrentTime;
-    ev.xclient.data.l[1] = SYSTEM_TRAY_REQUEST_DOCK;
-    ev.xclient.data.l[2] = window;
-    ev.xclient.data.l[3] = 0;
-    ev.xclient.data.l[4] = 0;
-    XSendEvent( display, systray_window, False, NoEventMask, &ev );
-
-    if (!layered)
-    {
-        attr.background_pixmap = ParentRelative;
-        attr.bit_gravity = ForgetGravity;
-        XChangeWindowAttributes( display, window, CWBackPixmap | CWBitGravity, &attr );
-    }
-    else
-    {
-        /* force repainig */
-        send_message( hwnd, WM_SIZE, SIZE_RESTORED, MAKELONG( params->cx, params->cy ));
-    }
-
-    return STATUS_SUCCESS;
-}
-
-
 /***********************************************************************
  *		X11DRV_get_whole_window
  *
@@ -2252,8 +2110,8 @@ Window X11DRV_get_whole_window( HWND hwnd )
 
     if (!data)
     {
-        if (hwnd == NtUserGetDesktopWindow()) return root_window;
-        return (Window)NtUserGetProp( hwnd, whole_window_prop );
+        if (hwnd == GetDesktopWindow()) return root_window;
+        return (Window)GetPropA( hwnd, whole_window_prop );
     }
     ret = data->whole_window;
     release_win_data( data );
@@ -2286,8 +2144,8 @@ XIC X11DRV_get_ic( HWND hwnd )
 /***********************************************************************
  *		X11DRV_GetDC   (X11DRV.@)
  */
-void X11DRV_GetDC( HDC hdc, HWND hwnd, HWND top, const RECT *win_rect,
-                   const RECT *top_rect, DWORD flags )
+void CDECL X11DRV_GetDC( HDC hdc, HWND hwnd, HWND top, const RECT *win_rect,
+                         const RECT *top_rect, DWORD flags )
 {
     struct x11drv_escape_set_drawable escape;
     HWND parent;
@@ -2313,13 +2171,13 @@ void X11DRV_GetDC( HDC hdc, HWND hwnd, HWND top, const RECT *win_rect,
     else
     {
         /* find the first ancestor that has a drawable */
-        for (parent = hwnd; parent && parent != top; parent = NtUserGetAncestor( parent, GA_PARENT ))
+        for (parent = hwnd; parent && parent != top; parent = GetAncestor( parent, GA_PARENT ))
             if ((escape.drawable = X11DRV_get_whole_window( parent ))) break;
 
         if (escape.drawable)
         {
             POINT pt = { 0, 0 };
-            NtUserMapWindowPoints( 0, parent, &pt, 1 );
+            MapWindowPoints( 0, parent, &pt, 1 );
             escape.dc_rect = *win_rect;
             OffsetRect( &escape.dc_rect, pt.x, pt.y );
             if (flags & DCX_CLIPCHILDREN) escape.mode = ClipByChildren;
@@ -2327,56 +2185,56 @@ void X11DRV_GetDC( HDC hdc, HWND hwnd, HWND top, const RECT *win_rect,
         else escape.drawable = X11DRV_get_whole_window( top );
     }
 
-    NtGdiExtEscape( hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    ExtEscape( hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }
 
 
 /***********************************************************************
  *		X11DRV_ReleaseDC  (X11DRV.@)
  */
-void X11DRV_ReleaseDC( HWND hwnd, HDC hdc )
+void CDECL X11DRV_ReleaseDC( HWND hwnd, HDC hdc )
 {
     struct x11drv_escape_set_drawable escape;
 
     escape.code = X11DRV_SET_DRAWABLE;
     escape.drawable = root_window;
     escape.mode = IncludeInferiors;
-    escape.dc_rect = NtUserGetVirtualScreenRect();
+    escape.dc_rect = get_virtual_screen_rect();
     OffsetRect( &escape.dc_rect, -2 * escape.dc_rect.left, -2 * escape.dc_rect.top );
-    NtGdiExtEscape( hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
+    ExtEscape( hdc, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }
 
 
 /*************************************************************************
  *		ScrollDC   (X11DRV.@)
  */
-BOOL X11DRV_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update )
+BOOL CDECL X11DRV_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update )
 {
     RECT rect;
     BOOL ret;
     HRGN expose_rgn = 0;
 
-    NtGdiGetAppClipBox( hdc, &rect );
+    GetClipBox( hdc, &rect );
 
     if (update)
     {
         INT code = X11DRV_START_EXPOSURES;
-        NtGdiExtEscape( hdc, NULL, 0, X11DRV_ESCAPE, sizeof(code), (LPSTR)&code, 0, NULL );
+        ExtEscape( hdc, X11DRV_ESCAPE, sizeof(code), (LPSTR)&code, 0, NULL );
 
-        ret = NtGdiBitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
-                           hdc, rect.left - dx, rect.top - dy, SRCCOPY, 0, 0 );
+        ret = BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                      hdc, rect.left - dx, rect.top - dy, SRCCOPY );
 
         code = X11DRV_END_EXPOSURES;
-        NtGdiExtEscape( hdc, NULL, 0, X11DRV_ESCAPE, sizeof(code), (LPSTR)&code,
-                        sizeof(expose_rgn), (LPSTR)&expose_rgn );
+        ExtEscape( hdc, X11DRV_ESCAPE, sizeof(code), (LPSTR)&code,
+                   sizeof(expose_rgn), (LPSTR)&expose_rgn );
         if (expose_rgn)
         {
-            NtGdiCombineRgn( update, update, expose_rgn, RGN_OR );
-            NtGdiDeleteObjectApp( expose_rgn );
+            CombineRgn( update, update, expose_rgn, RGN_OR );
+            DeleteObject( expose_rgn );
         }
     }
-    else ret = NtGdiBitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
-                            hdc, rect.left - dx, rect.top - dy, SRCCOPY, 0, 0 );
+    else ret = BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                       hdc, rect.left - dx, rect.top - dy, SRCCOPY );
 
     return ret;
 }
@@ -2385,7 +2243,7 @@ BOOL X11DRV_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update )
 /***********************************************************************
  *		SetCapture  (X11DRV.@)
  */
-void X11DRV_SetCapture( HWND hwnd, UINT flags )
+void CDECL X11DRV_SetCapture( HWND hwnd, UINT flags )
 {
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     struct x11drv_win_data *data;
@@ -2394,7 +2252,7 @@ void X11DRV_SetCapture( HWND hwnd, UINT flags )
 
     if (hwnd)
     {
-        if (!(data = get_win_data( NtUserGetAncestor( hwnd, GA_ROOT )))) return;
+        if (!(data = get_win_data( GetAncestor( hwnd, GA_ROOT )))) return;
         if (data->whole_window)
         {
             XFlush( gdi_display );
@@ -2420,7 +2278,7 @@ void X11DRV_SetCapture( HWND hwnd, UINT flags )
 /*****************************************************************
  *		SetParent   (X11DRV.@)
  */
-void X11DRV_SetParent( HWND hwnd, HWND parent, HWND old_parent )
+void CDECL X11DRV_SetParent( HWND hwnd, HWND parent, HWND old_parent )
 {
     struct x11drv_win_data *data;
 
@@ -2428,9 +2286,9 @@ void X11DRV_SetParent( HWND hwnd, HWND parent, HWND old_parent )
     if (!(data = get_win_data( hwnd ))) return;
     if (data->embedded) goto done;
 
-    if (parent != NtUserGetDesktopWindow()) /* a child window */
+    if (parent != GetDesktopWindow()) /* a child window */
     {
-        if (old_parent == NtUserGetDesktopWindow())
+        if (old_parent == GetDesktopWindow())
         {
             /* destroy the old X windows */
             destroy_whole_window( data, FALSE );
@@ -2456,9 +2314,9 @@ done:
 
 static inline BOOL get_surface_rect( const RECT *visible_rect, RECT *surface_rect )
 {
-    *surface_rect = NtUserGetVirtualScreenRect();
+    *surface_rect = get_virtual_screen_rect();
 
-    if (!intersect_rect( surface_rect, surface_rect, visible_rect )) return FALSE;
+    if (!IntersectRect( surface_rect, surface_rect, visible_rect )) return FALSE;
     OffsetRect( surface_rect, -visible_rect->left, -visible_rect->top );
     surface_rect->left &= ~31;
     surface_rect->top  &= ~31;
@@ -2471,15 +2329,15 @@ static inline BOOL get_surface_rect( const RECT *visible_rect, RECT *surface_rec
 /***********************************************************************
  *		WindowPosChanging   (X11DRV.@)
  */
-BOOL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flags,
-                               const RECT *window_rect, const RECT *client_rect, RECT *visible_rect,
-                               struct window_surface **surface )
+BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                     const RECT *window_rect, const RECT *client_rect, RECT *visible_rect,
+                                     struct window_surface **surface )
 {
     struct x11drv_win_data *data = get_win_data( hwnd );
     RECT surface_rect;
     DWORD flags;
     COLORREF key;
-    BOOL layered = NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED;
+    BOOL layered = GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED;
 
     if (!data && !(data = X11DRV_create_win_data( hwnd, window_rect, client_rect ))) return TRUE;
 
@@ -2521,9 +2379,9 @@ BOOL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flags,
             goto done;
         }
     }
-    else if (!(swp_flags & SWP_SHOWWINDOW) && !(NtUserGetWindowLongW( hwnd, GWL_STYLE ) & WS_VISIBLE)) goto done;
+    else if (!(swp_flags & SWP_SHOWWINDOW) && !(GetWindowLongW( hwnd, GWL_STYLE ) & WS_VISIBLE)) goto done;
 
-    if (!layered || !NtUserGetLayeredWindowAttributes( hwnd, &key, NULL, &flags ) || !(flags & LWA_COLORKEY))
+    if (!layered || !GetLayeredWindowAttributes( hwnd, &key, NULL, &flags ) || !(flags & LWA_COLORKEY))
         key = CLR_INVALID;
 
     *surface = create_surface( data->whole_window, &data->vis, &surface_rect, key, FALSE );
@@ -2537,14 +2395,14 @@ done:
 /***********************************************************************
  *		WindowPosChanged   (X11DRV.@)
  */
-void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
-                              const RECT *rectWindow, const RECT *rectClient,
-                              const RECT *visible_rect, const RECT *valid_rects,
-                              struct window_surface *surface )
+void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                    const RECT *rectWindow, const RECT *rectClient,
+                                    const RECT *visible_rect, const RECT *valid_rects,
+                                    struct window_surface *surface )
 {
     struct x11drv_thread_data *thread_data;
     struct x11drv_win_data *data;
-    DWORD new_style = NtUserGetWindowLongW( hwnd, GWL_STYLE );
+    DWORD new_style = GetWindowLongW( hwnd, GWL_STYLE );
     RECT old_window_rect, old_whole_rect, old_client_rect;
     int event_type;
 
@@ -2638,7 +2496,7 @@ void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
         {
             release_win_data( data );
             unmap_window( hwnd );
-            if (NtUserIsWindowRectFullScreen( &old_window_rect )) reset_clipping_window();
+            if (is_window_rect_full_screen( &old_window_rect )) reset_clipping_window();
             if (!(data = get_win_data( hwnd ))) return;
         }
     }
@@ -2657,7 +2515,7 @@ void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
             BOOL needs_map = TRUE;
 
             /* layered windows are mapped only once their attributes are set */
-            if (NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED)
+            if (GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED)
                 needs_map = data->layered || IsRectEmpty( rectWindow );
             release_win_data( data );
             if (needs_icon) fetch_icon_data( hwnd, 0, 0 );
@@ -2692,25 +2550,24 @@ void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
 /* check if the window icon should be hidden (i.e. moved off-screen) */
 static BOOL hide_icon( struct x11drv_win_data *data )
 {
-    static const WCHAR trayW[] = {'S','h','e','l','l','_','T','r','a','y','W','n','d'};
-    UNICODE_STRING str = { sizeof(trayW), sizeof(trayW), (WCHAR *)trayW };
+    static const WCHAR trayW[] = {'S','h','e','l','l','_','T','r','a','y','W','n','d',0};
 
     if (data->managed) return TRUE;
     /* hide icons in desktop mode when the taskbar is active */
     if (!is_virtual_desktop()) return FALSE;
-    return NtUserIsWindowVisible( NtUserFindWindowEx( 0, 0, &str, NULL, 0 ));
+    return IsWindowVisible( FindWindowW( trayW, NULL ));
 }
 
 /***********************************************************************
  *           ShowWindow   (X11DRV.@)
  */
-UINT X11DRV_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp )
+UINT CDECL X11DRV_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp )
 {
     int x, y;
     unsigned int width, height, border, depth;
     Window root, top;
     POINT pos;
-    DWORD style = NtUserGetWindowLongW( hwnd, GWL_STYLE );
+    DWORD style = GetWindowLongW( hwnd, GWL_STYLE );
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     struct x11drv_win_data *data = get_win_data( hwnd );
 
@@ -2758,7 +2615,7 @@ done:
  * first time). Complete the X11 driver-specific initialisation
  * and set the window hints.
  */
-void X11DRV_SetWindowIcon( HWND hwnd, UINT type, HICON icon )
+void CDECL X11DRV_SetWindowIcon( HWND hwnd, UINT type, HICON icon )
 {
     struct x11drv_win_data *data;
 
@@ -2781,7 +2638,7 @@ done:
  *
  * Assign specified region to window (for non-rectangular windows)
  */
-void X11DRV_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
+void CDECL X11DRV_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
 {
     struct x11drv_win_data *data;
 
@@ -2792,7 +2649,7 @@ void X11DRV_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
     }
     else if (X11DRV_get_whole_window( hwnd ))
     {
-        send_message( hwnd, WM_X11DRV_SET_WIN_REGION, 0, 0 );
+        SendMessageW( hwnd, WM_X11DRV_SET_WIN_REGION, 0, 0 );
     }
 }
 
@@ -2802,7 +2659,7 @@ void X11DRV_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw )
  *
  * Set transparency attributes for a layered window.
  */
-void X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags )
+void CDECL X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags )
 {
     struct x11drv_win_data *data = get_win_data( hwnd );
 
@@ -2818,7 +2675,7 @@ void X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWO
         data->layered = TRUE;
         if (!data->mapped)  /* mapping is delayed until attributes are set */
         {
-            DWORD style = NtUserGetWindowLongW( data->hwnd, GWL_STYLE );
+            DWORD style = GetWindowLongW( data->hwnd, GWL_STYLE );
 
             if ((style & WS_VISIBLE) &&
                 ((style & WS_MINIMIZE) || is_window_rect_mapped( &data->window_rect )))
@@ -2846,8 +2703,8 @@ void X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWO
 /*****************************************************************************
  *              UpdateLayeredWindow  (X11DRV.@)
  */
-BOOL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
-                                 const RECT *window_rect )
+BOOL CDECL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                       const RECT *window_rect )
 {
     struct window_surface *surface;
     struct x11drv_win_data *data;
@@ -2886,7 +2743,7 @@ BOOL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
     /* layered windows are mapped only once their attributes are set */
     if (!mapped)
     {
-        DWORD style = NtUserGetWindowLongW( hwnd, GWL_STYLE );
+        DWORD style = GetWindowLongW( hwnd, GWL_STYLE );
 
         if ((style & WS_VISIBLE) && ((style & WS_MINIMIZE) || is_window_rect_mapped( window_rect )))
             map_window( hwnd, style );
@@ -2901,28 +2758,27 @@ BOOL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
 
     dst_bits = surface->funcs->get_info( surface, bmi );
 
-    if (!(dib = NtGdiCreateDIBSection( info->hdcDst, NULL, 0, bmi, DIB_RGB_COLORS, 0, 0, 0, &src_bits )))
-        goto done;
-    if (!(hdc = NtGdiCreateCompatibleDC( 0 ))) goto done;
+    if (!(dib = CreateDIBSection( info->hdcDst, bmi, DIB_RGB_COLORS, &src_bits, NULL, 0 ))) goto done;
+    if (!(hdc = CreateCompatibleDC( 0 ))) goto done;
 
-    NtGdiSelectBitmap( hdc, dib );
+    SelectObject( hdc, dib );
 
     surface->funcs->lock( surface );
 
     if (info->prcDirty)
     {
-        intersect_rect( &rect, &rect, info->prcDirty );
+        IntersectRect( &rect, &rect, info->prcDirty );
         memcpy( src_bits, dst_bits, bmi->bmiHeader.biSizeImage );
-        NtGdiPatBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS );
+        PatBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS );
     }
     src_rect = rect;
     if (info->pptSrc) OffsetRect( &src_rect, info->pptSrc->x, info->pptSrc->y );
-    NtGdiTransformPoints( info->hdcSrc, (POINT *)&src_rect, (POINT *)&src_rect, 2, NtGdiDPtoLP );
+    DPtoLP( info->hdcSrc, (POINT *)&src_rect, 2 );
 
-    ret = NtGdiAlphaBlend( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
-                           info->hdcSrc, src_rect.left, src_rect.top,
-                           src_rect.right - src_rect.left, src_rect.bottom - src_rect.top,
-                           (info->dwFlags & ULW_ALPHA) ? *info->pblend : blend, 0 );
+    ret = GdiAlphaBlend( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                         info->hdcSrc, src_rect.left, src_rect.top,
+                         src_rect.right - src_rect.left, src_rect.bottom - src_rect.top,
+                         (info->dwFlags & ULW_ALPHA) ? *info->pblend : blend );
     if (ret)
     {
         memcpy( dst_bits, src_bits, bmi->bmiHeader.biSizeImage );
@@ -2934,8 +2790,8 @@ BOOL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
 
 done:
     window_surface_release( surface );
-    if (hdc) NtGdiDeleteObjectApp( hdc );
-    if (dib) NtGdiDeleteObjectApp( dib );
+    if (hdc) DeleteDC( hdc );
+    if (dib) DeleteObject( dib );
     return ret;
 }
 
@@ -2976,7 +2832,7 @@ static void taskbar_delete_tab( HWND hwnd )
 /**********************************************************************
  *           X11DRV_WindowMessage   (X11DRV.@)
  */
-LRESULT X11DRV_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
+LRESULT CDECL X11DRV_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
 {
     struct x11drv_win_data *data;
 
@@ -3074,7 +2930,7 @@ static LRESULT start_screensaver(void)
  *
  * Perform WM_SYSCOMMAND handling.
  */
-LRESULT X11DRV_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam )
+LRESULT CDECL X11DRV_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam )
 {
     WPARAM hittest = wparam & 0x0f;
     int dir;
@@ -3082,7 +2938,7 @@ LRESULT X11DRV_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam )
 
     if (!(data = get_win_data( hwnd )))
     {
-        if (wparam == SC_SCREENSAVE && hwnd == NtUserGetDesktopWindow()) return start_screensaver();
+        if (wparam == SC_SCREENSAVE && hwnd == GetDesktopWindow()) return start_screensaver();
         return -1;
     }
     if (!data->whole_window || !data->managed || !data->mapped) goto failed;
@@ -3095,7 +2951,7 @@ LRESULT X11DRV_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam )
         break;
     case SC_SIZE:
         /* windows without WS_THICKFRAME are not resizable through the window manager */
-        if (!(NtUserGetWindowLongW( hwnd, GWL_STYLE ) & WS_THICKFRAME)) goto failed;
+        if (!(GetWindowLongW( hwnd, GWL_STYLE ) & WS_THICKFRAME)) goto failed;
 
         switch (hittest)
         {
@@ -3116,8 +2972,8 @@ LRESULT X11DRV_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam )
         /* prevent a simple ALT press+release from activating the system menu,
          * as that can get confusing on managed windows */
         if ((WCHAR)lparam) goto failed;  /* got an explicit char */
-        if (NtUserGetWindowLongPtrW( hwnd, GWLP_ID )) goto failed;  /* window has a real menu */
-        if (!(NtUserGetWindowLongW( hwnd, GWL_STYLE ) & WS_SYSMENU)) goto failed;  /* no system menu */
+        if (GetMenu( hwnd )) goto failed;  /* window has a real menu */
+        if (!(GetWindowLongW( hwnd, GWL_STYLE ) & WS_SYSMENU)) goto failed;  /* no system menu */
         TRACE( "ignoring SC_KEYMENU wp %lx lp %lx\n", wparam, lparam );
         release_win_data( data );
         return 0;
@@ -3126,7 +2982,7 @@ LRESULT X11DRV_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam )
         goto failed;
     }
 
-    if (NtUserGetWindowLongW( hwnd, GWL_STYLE ) & WS_MAXIMIZE) goto failed;
+    if (IsZoomed(hwnd)) goto failed;
 
     if (!is_netwm_supported( data->display, x11drv_atom(_NET_WM_MOVERESIZE) ))
     {
@@ -3143,7 +2999,7 @@ failed:
     return -1;
 }
 
-void X11DRV_FlashWindowEx( FLASHWINFO *pfinfo )
+void CDECL X11DRV_FlashWindowEx( PFLASHWINFO pfinfo )
 {
     struct x11drv_win_data *data = get_win_data( pfinfo->hwnd );
     XEvent xev;
@@ -3171,12 +3027,3 @@ void X11DRV_FlashWindowEx( FLASHWINFO *pfinfo )
     }
     release_win_data( data );
 }
-
-void init_win_context(void)
-{
-    init_recursive_mutex( &win_data_mutex );
-
-    winContext = XUniqueContext();
-    win_data_context = XUniqueContext();
-    cursor_context = XUniqueContext();
-}
diff --git a/dlls/winex11.drv/winex11.drv.spec b/dlls/winex11.drv/winex11.drv.spec
index 77e4a6285de..6e0ccfab4b0 100644
--- a/dlls/winex11.drv/winex11.drv.spec
+++ b/dlls/winex11.drv/winex11.drv.spec
@@ -5,7 +5,7 @@
 @ cdecl WTInfoW(long long ptr) X11DRV_WTInfoW
 
 # Desktop
-@ cdecl wine_create_desktop(long long)
+@ cdecl wine_create_desktop(long long) X11DRV_create_desktop
 
 # System tray
 @ cdecl wine_notify_icon(long ptr)
diff --git a/dlls/winex11.drv/wintab.c b/dlls/winex11.drv/wintab.c
index b906a589e08..331601c3325 100644
--- a/dlls/winex11.drv/wintab.c
+++ b/dlls/winex11.drv/wintab.c
@@ -18,10 +18,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <stdlib.h>
@@ -31,7 +27,9 @@
 
 #include "windef.h"
 #include "winbase.h"
+#include "winnls.h"
 #include "x11drv.h"
+#include "wine/unicode.h"
 #include "wine/debug.h"
 #include "wintab.h"
 
@@ -484,9 +482,9 @@ static void disable_system_cursors(void)
 
 
 /***********************************************************************
- *           x11drv_tablet_load_info
+ *             X11DRV_LoadTabletInfo (X11DRV.@)
  */
-NTSTATUS x11drv_tablet_load_info( void *hwnd )
+BOOL CDECL X11DRV_LoadTabletInfo(HWND hwnddefault)
 {
     static const WCHAR SZ_CONTEXT_NAME[] = {'W','i','n','e',' ','T','a','b','l','e','t',' ','C','o','n','t','e','x','t',0};
     static const WCHAR SZ_DEVICE_NAME[] = {'W','i','n','e',' ','T','a','b','l','e','t',' ','D','e','v','i','c','e',0};
@@ -512,11 +510,11 @@ NTSTATUS x11drv_tablet_load_info( void *hwnd )
         return FALSE;
     }
 
-    hwndTabletDefault = hwnd;
+    hwndTabletDefault = hwnddefault;
 
     /* Do base initialization */
-    wcscpy(gSysContext.lcName, SZ_CONTEXT_NAME);
-    wcscpy(gSysDevice.NAME, SZ_DEVICE_NAME);
+    strcpyW(gSysContext.lcName, SZ_CONTEXT_NAME);
+    strcpyW(gSysDevice.NAME, SZ_DEVICE_NAME);
 
     gSysContext.lcOptions = CXO_SYSTEM;
     gSysContext.lcLocks = CXL_INSIZE | CXL_INASPECT | CXL_MARGIN |
@@ -539,8 +537,8 @@ NTSTATUS x11drv_tablet_load_info( void *hwnd )
     gSysContext.lcSensZ = 65536;
     gSysContext.lcSysSensX= 65536;
     gSysContext.lcSysSensY= 65536;
-    gSysContext.lcSysExtX = NtUserGetSystemMetrics( SM_CXVIRTUALSCREEN );
-    gSysContext.lcSysExtY = NtUserGetSystemMetrics( SM_CYVIRTUALSCREEN );
+    gSysContext.lcSysExtX = GetSystemMetrics(SM_CXVIRTUALSCREEN);
+    gSysContext.lcSysExtY = GetSystemMetrics(SM_CYVIRTUALSCREEN);
 
     /* initialize cursors */
     disable_system_cursors();
@@ -552,7 +550,7 @@ NTSTATUS x11drv_tablet_load_info( void *hwnd )
     gSysDevice.PKTDATA =
         PK_CONTEXT | PK_STATUS | PK_SERIAL_NUMBER| PK_TIME | PK_CURSOR |
         PK_BUTTONS |  PK_X | PK_Y | PK_NORMAL_PRESSURE | PK_ORIENTATION;
-    wcscpy(gSysDevice.PNPID, SZ_NON_PLUG_N_PLAY);
+    strcpyW(gSysDevice.PNPID, SZ_NON_PLUG_N_PLAY);
 
     devices = pXListInputDevices(data->display, &num_devices);
     if (!devices)
@@ -618,7 +616,7 @@ NTSTATUS x11drv_tablet_load_info( void *hwnd )
                 WARN("Unable to open device %s\n",target->name);
                 break;
             }
-            ntdll_umbstowcs(target->name, strlen(target->name) + 1, cursor.NAME, WT_MAX_NAME_LEN);
+            MultiByteToWideChar(CP_UNIXCP, 0, target->name, -1, cursor.NAME, WT_MAX_NAME_LEN);
 
             if (! is_tablet_cursor(target->name, device_type))
             {
@@ -739,22 +737,22 @@ NTSTATUS x11drv_tablet_load_info( void *hwnd )
                         Button = (XButtonInfoPtr) any;
                         TRACE("    ButtonInput %d: [class %d|length %d|num_buttons %d]\n",
                                 class_loop, (int) Button->class, Button->length, Button->num_buttons);
-                        cursor.BTNNAMES = malloc( sizeof(WCHAR) * cchBuf );
+                        cursor.BTNNAMES = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR)*cchBuf);
                         for (i = 0; i < cursor.BUTTONS; i++)
                         {
                             /* FIXME - these names are probably incorrect */
-                            int cch = wcslen(cursor.NAME) + 1;
+                            int cch = strlenW(cursor.NAME) + 1;
                             while (cch > cchBuf - cchPos - 1) /* we want one extra byte for the last NUL */
                             {
                                 cchBuf *= 2;
-                                cursor.BTNNAMES = realloc( cursor.BTNNAMES, sizeof(WCHAR) * cchBuf );
+                                cursor.BTNNAMES = HeapReAlloc(GetProcessHeap(), 0, cursor.BTNNAMES, sizeof(WCHAR)*cchBuf);
                             }
 
-                            wcscpy(cursor.BTNNAMES + cchPos, cursor.NAME);
+                            strcpyW(cursor.BTNNAMES + cchPos, cursor.NAME);
                             cchPos += cch;
                         }
                         cursor.BTNNAMES[cchPos++] = 0;
-                        cursor.BTNNAMES = realloc( cursor.BTNNAMES, sizeof(WCHAR)*cchPos );
+                        cursor.BTNNAMES = HeapReAlloc(GetProcessHeap(), 0, cursor.BTNNAMES, sizeof(WCHAR)*cchPos);
                         cursor.cchBTNNAMES = cchPos;
                     }
                     break;
@@ -908,7 +906,7 @@ static BOOL motion_event( HWND hwnd, XEvent *event )
     gMsgPacket.pkNormalPressure = motion->axis_data[2];
     gMsgPacket.pkButtons = get_button_state(curnum);
     gMsgPacket.pkChanged = get_changed_state(&gMsgPacket);
-    send_message( hwndTabletDefault, WT_PACKET, gMsgPacket.pkSerialNumber, (LPARAM)hwnd );
+    SendMessageW(hwndTabletDefault,WT_PACKET,gMsgPacket.pkSerialNumber,(LPARAM)hwnd);
     last_packet = gMsgPacket;
     return TRUE;
 }
@@ -947,7 +945,7 @@ static BOOL button_event( HWND hwnd, XEvent *event )
     }
     gMsgPacket.pkButtons = get_button_state(curnum);
     gMsgPacket.pkChanged = get_changed_state(&gMsgPacket);
-    send_message( hwndTabletDefault, WT_PACKET, gMsgPacket.pkSerialNumber, (LPARAM)hwnd );
+    SendMessageW(hwndTabletDefault,WT_PACKET,gMsgPacket.pkSerialNumber,(LPARAM)hwnd);
     last_packet = gMsgPacket;
     return TRUE;
 }
@@ -999,14 +997,14 @@ static BOOL proximity_event( HWND hwnd, XEvent *event )
      */
     proximity_info = MAKELPARAM((event->type == proximity_in_type),
                      (event->type == proximity_in_type) || (event->type == proximity_out_type));
-    send_message( hwndTabletDefault, WT_PROXIMITY, (WPARAM)hwnd, proximity_info );
+    SendMessageW(hwndTabletDefault, WT_PROXIMITY, (WPARAM)hwnd, proximity_info);
     return TRUE;
 }
 
 /***********************************************************************
- *           x11drv_tablet_attach_queue
+ *		X11DRV_AttachEventQueueToTablet (X11DRV.@)
  */
-NTSTATUS x11drv_tablet_attach_queue( void *owner )
+int CDECL X11DRV_AttachEventQueueToTablet(HWND hOwner)
 {
     struct x11drv_thread_data *data = x11drv_init_thread_data();
     int             num_devices;
@@ -1016,11 +1014,11 @@ NTSTATUS x11drv_tablet_attach_queue( void *owner )
     XDeviceInfo     *target = NULL;
     XDevice         *the_device;
     XEventClass     event_list[7];
-    Window          win = X11DRV_get_whole_window( owner );
+    Window          win = X11DRV_get_whole_window( hOwner );
 
     if (!win || !xinput_handle) return 0;
 
-    TRACE("Creating context for window %p (%lx)  %i cursors\n", owner, win, gNumCursors);
+    TRACE("Creating context for window %p (%lx)  %i cursors\n", hOwner, win, gNumCursors);
 
     devices = pXListInputDevices(data->display, &num_devices);
 
@@ -1033,8 +1031,7 @@ NTSTATUS x11drv_tablet_attach_queue( void *owner )
         if (!gSysCursor[cur_loop].ACTIVE) continue;
 
         /* the cursor name fits in the buffer because too long names are skipped */
-        ntdll_wcstoumbs(gSysCursor[cur_loop].NAME, wcslen(gSysCursor[cur_loop].NAME) + 1,
-                        cursorNameA, WT_MAX_NAME_LEN, FALSE);
+        WideCharToMultiByte(CP_UNIXCP, 0, gSysCursor[cur_loop].NAME, -1, cursorNameA, WT_MAX_NAME_LEN, NULL, NULL);
         for (loop=0; loop < num_devices; loop ++)
             if (strcmp(devices[loop].name, cursorNameA) == 0)
                 target = &devices[loop];
@@ -1096,11 +1093,11 @@ NTSTATUS x11drv_tablet_attach_queue( void *owner )
 }
 
 /***********************************************************************
- *           x11drv_tablet_get_packet
+ *		X11DRV_GetCurrentPacket (X11DRV.@)
  */
-NTSTATUS x11drv_tablet_get_packet( void *packet )
+int CDECL X11DRV_GetCurrentPacket(LPWTPACKET packet)
 {
-    *(WTPACKET *)packet = gMsgPacket;
+    *packet = gMsgPacket;
     return 1;
 }
 
@@ -1117,15 +1114,10 @@ static inline int CopyTabletData(LPVOID target, LPCVOID src, INT size)
 }
 
 /***********************************************************************
- *           x11drv_tablet_info
+ *		X11DRV_WTInfoW (X11DRV.@)
  */
-NTSTATUS x11drv_tablet_info( void *arg )
+UINT CDECL X11DRV_WTInfoW(UINT wCategory, UINT nIndex, LPVOID lpOutput)
 {
-    struct tablet_info_params *params = arg;
-    UINT wCategory = params->category;
-    UINT nIndex = params->index;
-    void *lpOutput = params->output;
-
     /*
      * It is valid to call WTInfoA with lpOutput == NULL, as per standard.
      * lpOutput == NULL signifies the user only wishes
@@ -1159,7 +1151,7 @@ NTSTATUS x11drv_tablet_info( void *arg )
                 case IFC_WINTABID:
                 {
                     static const WCHAR driver[] = {'W','i','n','e',' ','W','i','n','t','a','b',' ','1','.','1',0};
-                    rc = CopyTabletData(lpOutput, driver, (wcslen(driver) + 1) * sizeof(WCHAR));
+                    rc = CopyTabletData(lpOutput, driver, (strlenW(driver) + 1) * sizeof(WCHAR));
                     break;
                 }
                 case IFC_SPECVERSION:
@@ -1198,7 +1190,7 @@ NTSTATUS x11drv_tablet_info( void *arg )
                     break;
                 case CTX_NAME:
                     rc = CopyTabletData(lpOutput, gSysContext.lcName,
-                         (wcslen(gSysContext.lcName)+1) * sizeof(WCHAR));
+                         (strlenW(gSysContext.lcName)+1) * sizeof(WCHAR));
                     break;
                 case CTX_OPTIONS:
                     rc = CopyTabletData(lpOutput, &gSysContext.lcOptions,
@@ -1362,7 +1354,7 @@ NTSTATUS x11drv_tablet_info( void *arg )
                 {
                     case CSR_NAME:
                         rc = CopyTabletData(lpOutput, tgtcursor->NAME,
-                                            (wcslen(tgtcursor->NAME)+1) * sizeof(WCHAR));
+                                            (strlenW(tgtcursor->NAME)+1) * sizeof(WCHAR));
                         break;
                     case CSR_ACTIVE:
                         rc = CopyTabletData(lpOutput,&tgtcursor->ACTIVE,
@@ -1454,7 +1446,7 @@ NTSTATUS x11drv_tablet_info( void *arg )
             {
                 case DVC_NAME:
                     rc = CopyTabletData(lpOutput,gSysDevice.NAME,
-                                        (wcslen(gSysDevice.NAME)+1) * sizeof(WCHAR));
+                                        (strlenW(gSysDevice.NAME)+1) * sizeof(WCHAR));
                     break;
                 case DVC_HARDWARE:
                     rc = CopyTabletData(lpOutput,&gSysDevice.HARDWARE,
@@ -1538,7 +1530,7 @@ NTSTATUS x11drv_tablet_info( void *arg )
                     break;
                 case DVC_PNPID:
                     rc = CopyTabletData(lpOutput,gSysDevice.PNPID,
-                                        (wcslen(gSysDevice.PNPID)+1)*sizeof(WCHAR));
+                                        (strlenW(gSysDevice.PNPID)+1)*sizeof(WCHAR));
                     break;
                 default:
                     FIXME("WTI_DEVICES unhandled index %i\n",nIndex);
@@ -1554,33 +1546,33 @@ NTSTATUS x11drv_tablet_info( void *arg )
 #else /* SONAME_LIBXI */
 
 /***********************************************************************
- *           x11drv_tablet_attach_queue
+ *		AttachEventQueueToTablet (X11DRV.@)
  */
-NTSTATUS x11drv_tablet_attach_queue( void *owner )
+int CDECL X11DRV_AttachEventQueueToTablet(HWND hOwner)
 {
     return 0;
 }
 
 /***********************************************************************
- *           x11drv_tablet_get_packet
+ *		GetCurrentPacket (X11DRV.@)
  */
-NTSTATUS x11drv_tablet_get_packet( void *arg )
+int CDECL X11DRV_GetCurrentPacket(LPWTPACKET packet)
 {
     return 0;
 }
 
 /***********************************************************************
- *           x11drv_tablet_load_info
+ *		LoadTabletInfo (X11DRV.@)
  */
-NTSTATUS x11drv_tablet_load_info( void *arg )
+BOOL CDECL X11DRV_LoadTabletInfo(HWND hwnddefault)
 {
     return FALSE;
 }
 
 /***********************************************************************
- *           x11drv_tablet_info
+ *		WTInfoW (X11DRV.@)
  */
-NTSTATUS x11drv_tablet_info( void *arg )
+UINT CDECL X11DRV_WTInfoW(UINT wCategory, UINT nIndex, LPVOID lpOutput)
 {
     return 0;
 }
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 003604cd97d..f389f3e0836 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -28,8 +28,6 @@
 
 #include <limits.h>
 #include <stdarg.h>
-#include <stdlib.h>
-#include <pthread.h>
 #include <X11/Xlib.h>
 #include <X11/Xresource.h>
 #include <X11/Xutil.h>
@@ -57,14 +55,11 @@
 #undef Status  /* avoid conflict with wintrnl.h */
 typedef int Status;
 
-/* avoid conflict with processthreadsapi.h */
-#undef ControlMask
-
 #include "windef.h"
 #include "winbase.h"
-#include "ntgdi.h"
+#include "wingdi.h"
+#include "winuser.h"
 #include "wine/gdi_driver.h"
-#include "unixlib.h"
 #include "wine/list.h"
 
 #define MAX_DASHLEN 16
@@ -158,9 +153,6 @@ extern BOOL CDECL X11DRV_Arc( PHYSDEV dev, INT left, INT top, INT right,
 extern BOOL CDECL X11DRV_Chord( PHYSDEV dev, INT left, INT top, INT right, INT bottom,
                                 INT xstart, INT ystart, INT xend, INT yend ) DECLSPEC_HIDDEN;
 extern NTSTATUS CDECL X11DRV_D3DKMTCheckVidPnExclusiveOwnership( const D3DKMT_CHECKVIDPNEXCLUSIVEOWNERSHIP *desc ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL X11DRV_D3DKMTCloseAdapter( const D3DKMT_CLOSEADAPTER *desc ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL X11DRV_D3DKMTOpenAdapterFromLuid( D3DKMT_OPENADAPTERFROMLUID *desc ) DECLSPEC_HIDDEN;
-extern NTSTATUS CDECL X11DRV_D3DKMTQueryVideoMemoryInfo( D3DKMT_QUERYVIDEOMEMORYINFO *desc ) DECLSPEC_HIDDEN;
 extern NTSTATUS CDECL X11DRV_D3DKMTSetVidPnSourceOwner( const D3DKMT_SETVIDPNSOURCEOWNER *desc ) DECLSPEC_HIDDEN;
 extern BOOL CDECL X11DRV_Ellipse( PHYSDEV dev, INT left, INT top, INT right, INT bottom ) DECLSPEC_HIDDEN;
 extern BOOL CDECL X11DRV_ExtFloodFill( PHYSDEV dev, INT x, INT y, COLORREF color, UINT fillType ) DECLSPEC_HIDDEN;
@@ -201,58 +193,56 @@ extern BOOL CDECL X11DRV_StrokeAndFillPath( PHYSDEV dev ) DECLSPEC_HIDDEN;
 extern BOOL CDECL X11DRV_StrokePath( PHYSDEV dev ) DECLSPEC_HIDDEN;
 extern BOOL CDECL X11DRV_UnrealizePalette( HPALETTE hpal ) DECLSPEC_HIDDEN;
 
-extern BOOL X11DRV_ActivateKeyboardLayout( HKL hkl, UINT flags ) DECLSPEC_HIDDEN;
-extern void X11DRV_Beep(void) DECLSPEC_HIDDEN;
-extern INT X11DRV_GetKeyNameText( LONG lparam, LPWSTR buffer, INT size ) DECLSPEC_HIDDEN;
-extern UINT X11DRV_MapVirtualKeyEx( UINT code, UINT map_type, HKL hkl ) DECLSPEC_HIDDEN;
-extern INT X11DRV_ToUnicodeEx( UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
-                               LPWSTR bufW, int bufW_size, UINT flags, HKL hkl ) DECLSPEC_HIDDEN;
-extern SHORT X11DRV_VkKeyScanEx( WCHAR wChar, HKL hkl ) DECLSPEC_HIDDEN;
-extern void X11DRV_DestroyCursorIcon( HCURSOR handle ) DECLSPEC_HIDDEN;
-extern void X11DRV_SetCursor( HCURSOR handle ) DECLSPEC_HIDDEN;
-extern BOOL X11DRV_SetCursorPos( INT x, INT y ) DECLSPEC_HIDDEN;
-extern BOOL X11DRV_GetCursorPos( LPPOINT pos ) DECLSPEC_HIDDEN;
-extern BOOL X11DRV_ClipCursor( LPCRECT clip ) DECLSPEC_HIDDEN;
-extern LONG X11DRV_ChangeDisplaySettingsEx( LPCWSTR devname, LPDEVMODEW devmode,
-                                            HWND hwnd, DWORD flags, LPVOID lpvoid ) DECLSPEC_HIDDEN;
-extern BOOL X11DRV_EnumDisplaySettingsEx( LPCWSTR name, DWORD n, LPDEVMODEW devmode,
-                                          DWORD flags ) DECLSPEC_HIDDEN;
-extern void X11DRV_UpdateDisplayDevices( const struct gdi_device_manager *device_manager,
-                                         BOOL force, void *param ) DECLSPEC_HIDDEN;
-extern BOOL X11DRV_CreateDesktopWindow( HWND hwnd ) DECLSPEC_HIDDEN;
-extern BOOL X11DRV_CreateWindow( HWND hwnd ) DECLSPEC_HIDDEN;
-extern LRESULT X11DRV_DesktopWindowProc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp ) DECLSPEC_HIDDEN;
-extern void X11DRV_DestroyWindow( HWND hwnd ) DECLSPEC_HIDDEN;
-extern void X11DRV_FlashWindowEx( PFLASHWINFO pfinfo ) DECLSPEC_HIDDEN;
-extern void X11DRV_GetDC( HDC hdc, HWND hwnd, HWND top, const RECT *win_rect,
-                          const RECT *top_rect, DWORD flags ) DECLSPEC_HIDDEN;
-extern void X11DRV_ReleaseDC( HWND hwnd, HDC hdc ) DECLSPEC_HIDDEN;
-extern BOOL X11DRV_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update ) DECLSPEC_HIDDEN;
-extern void X11DRV_SetCapture( HWND hwnd, UINT flags ) DECLSPEC_HIDDEN;
-extern void X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha,
-                                               DWORD flags ) DECLSPEC_HIDDEN;
-extern void X11DRV_SetParent( HWND hwnd, HWND parent, HWND old_parent ) DECLSPEC_HIDDEN;
-extern void X11DRV_SetWindowIcon( HWND hwnd, UINT type, HICON icon ) DECLSPEC_HIDDEN;
-extern void X11DRV_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw ) DECLSPEC_HIDDEN;
-extern void X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style ) DECLSPEC_HIDDEN;
-extern void X11DRV_SetWindowText( HWND hwnd, LPCWSTR text ) DECLSPEC_HIDDEN;
-extern UINT X11DRV_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp ) DECLSPEC_HIDDEN;
-extern LRESULT X11DRV_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
-extern LRESULT X11DRV_ClipboardWindowProc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp ) DECLSPEC_HIDDEN;
-extern void X11DRV_UpdateClipboard(void) DECLSPEC_HIDDEN;
-extern BOOL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
-                                        const RECT *window_rect ) DECLSPEC_HIDDEN;
-extern LRESULT X11DRV_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp ) DECLSPEC_HIDDEN;
-extern BOOL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flags,
-                                      const RECT *window_rect, const RECT *client_rect, RECT *visible_rect,
-                                      struct window_surface **surface ) DECLSPEC_HIDDEN;
-extern void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
-                                     const RECT *rectWindow, const RECT *rectClient,
-                                     const RECT *visible_rect, const RECT *valid_rects,
-                                     struct window_surface *surface ) DECLSPEC_HIDDEN;
-extern BOOL X11DRV_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param,
-                                         UINT flags ) DECLSPEC_HIDDEN;
-extern void X11DRV_ThreadDetach(void) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_ActivateKeyboardLayout( HKL hkl, UINT flags ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_Beep(void) DECLSPEC_HIDDEN;
+extern INT CDECL X11DRV_GetKeyNameText( LONG lparam, LPWSTR buffer, INT size ) DECLSPEC_HIDDEN;
+extern UINT CDECL X11DRV_MapVirtualKeyEx( UINT code, UINT map_type, HKL hkl ) DECLSPEC_HIDDEN;
+extern INT CDECL X11DRV_ToUnicodeEx( UINT virtKey, UINT scanCode, const BYTE *lpKeyState,
+                                     LPWSTR bufW, int bufW_size, UINT flags, HKL hkl ) DECLSPEC_HIDDEN;
+extern SHORT CDECL X11DRV_VkKeyScanEx( WCHAR wChar, HKL hkl ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_DestroyCursorIcon( HCURSOR handle ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_SetCursor( HCURSOR handle ) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_SetCursorPos( INT x, INT y ) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_GetCursorPos( LPPOINT pos ) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_ClipCursor( LPCRECT clip ) DECLSPEC_HIDDEN;
+extern LONG CDECL X11DRV_ChangeDisplaySettingsEx( LPCWSTR devname, LPDEVMODEW devmode,
+                                                  HWND hwnd, DWORD flags, LPVOID lpvoid ) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_EnumDisplaySettingsEx( LPCWSTR name, DWORD n, LPDEVMODEW devmode,
+                                                DWORD flags ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_UpdateDisplayDevices( const struct gdi_device_manager *device_manager,
+                                               BOOL force, void *param ) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_CreateDesktopWindow( HWND hwnd ) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_CreateWindow( HWND hwnd ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_DestroyWindow( HWND hwnd ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_FlashWindowEx( PFLASHWINFO pfinfo ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_GetDC( HDC hdc, HWND hwnd, HWND top, const RECT *win_rect,
+                                const RECT *top_rect, DWORD flags ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_ReleaseDC( HWND hwnd, HDC hdc ) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_SetCapture( HWND hwnd, UINT flags ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha,
+                                                     DWORD flags ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_SetParent( HWND hwnd, HWND parent, HWND old_parent ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_SetWindowIcon( HWND hwnd, UINT type, HICON icon ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_SetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_SetWindowText( HWND hwnd, LPCWSTR text ) DECLSPEC_HIDDEN;
+extern UINT CDECL X11DRV_ShowWindow( HWND hwnd, INT cmd, RECT *rect, UINT swp ) DECLSPEC_HIDDEN;
+extern LRESULT CDECL X11DRV_SysCommand( HWND hwnd, WPARAM wparam, LPARAM lparam ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_UpdateClipboard(void) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                              const RECT *window_rect ) DECLSPEC_HIDDEN;
+extern LRESULT CDECL X11DRV_WindowMessage( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp ) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_WindowPosChanging( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                            const RECT *window_rect, const RECT *client_rect, RECT *visible_rect,
+                                            struct window_surface **surface ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
+                                           const RECT *rectWindow, const RECT *rectClient,
+                                           const RECT *visible_rect, const RECT *valid_rects,
+                                           struct window_surface *surface ) DECLSPEC_HIDDEN;
+extern BOOL CDECL X11DRV_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param,
+                                               UINT flags ) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_ThreadDetach(void) DECLSPEC_HIDDEN;
 
 /* X11 driver internal functions */
 
@@ -291,9 +281,24 @@ extern const struct gdi_dc_funcs *X11DRV_XRender_Init(void) DECLSPEC_HIDDEN;
 extern struct opengl_funcs *get_glx_driver(UINT) DECLSPEC_HIDDEN;
 extern const struct vulkan_funcs *get_vulkan_driver(UINT) DECLSPEC_HIDDEN;
 
-extern struct format_entry *import_xdnd_selection( Display *display, Window win, Atom selection,
-                                                   Atom *targets, UINT count,
-                                                   size_t *size ) DECLSPEC_HIDDEN;
+/* IME support */
+extern void IME_SetOpenStatus(BOOL fOpen) DECLSPEC_HIDDEN;
+extern void IME_SetCompositionStatus(BOOL fOpen) DECLSPEC_HIDDEN;
+extern INT IME_GetCursorPos(void) DECLSPEC_HIDDEN;
+extern void IME_SetCursorPos(DWORD pos) DECLSPEC_HIDDEN;
+extern void IME_UpdateAssociation(HWND focus) DECLSPEC_HIDDEN;
+extern BOOL IME_SetCompositionString(DWORD dwIndex, LPCVOID lpComp,
+                                     DWORD dwCompLen, LPCVOID lpRead,
+                                     DWORD dwReadLen) DECLSPEC_HIDDEN;
+extern void IME_SetResultString(LPWSTR lpResult, DWORD dwResultlen) DECLSPEC_HIDDEN;
+
+extern void X11DRV_XDND_EnterEvent( HWND hWnd, XClientMessageEvent *event ) DECLSPEC_HIDDEN;
+extern void X11DRV_XDND_PositionEvent( HWND hWnd, XClientMessageEvent *event ) DECLSPEC_HIDDEN;
+extern void X11DRV_XDND_DropEvent( HWND hWnd, XClientMessageEvent *event ) DECLSPEC_HIDDEN;
+extern void X11DRV_XDND_LeaveEvent( HWND hWnd, XClientMessageEvent *event ) DECLSPEC_HIDDEN;
+extern void X11DRV_CLIPBOARD_ImportSelection( Display *display, Window win, Atom selection,
+                                              Atom *targets, UINT count,
+                                              void (*callback)( Atom, UINT, HANDLE )) DECLSPEC_HIDDEN;
 
 /**************************************************************************
  * X11 GDI driver
@@ -389,10 +394,14 @@ struct x11drv_thread_data
 };
 
 extern struct x11drv_thread_data *x11drv_init_thread_data(void) DECLSPEC_HIDDEN;
+extern DWORD thread_data_tls_index DECLSPEC_HIDDEN;
 
 static inline struct x11drv_thread_data *x11drv_thread_data(void)
 {
-    return NtUserGetThreadInfo()->driver_data;
+    DWORD err = GetLastError();  /* TlsGetValue always resets last error */
+    struct x11drv_thread_data *data = TlsGetValue( thread_data_tls_index );
+    SetLastError( err );
+    return data;
 }
 
 /* retrieve the thread display, or NULL if not created yet */
@@ -442,12 +451,9 @@ extern int primary_monitor DECLSPEC_HIDDEN;
 extern int copy_default_colors DECLSPEC_HIDDEN;
 extern int alloc_system_colors DECLSPEC_HIDDEN;
 extern int xrender_error_base DECLSPEC_HIDDEN;
+extern HMODULE x11drv_module DECLSPEC_HIDDEN;
 extern char *process_name DECLSPEC_HIDDEN;
 extern Display *clipboard_display DECLSPEC_HIDDEN;
-extern WNDPROC client_foreign_window_proc;
-
-extern NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,
-                                                    BOOLEAN,const LARGE_INTEGER*) DECLSPEC_HIDDEN;
 
 /* atoms */
 
@@ -652,11 +658,9 @@ extern Window create_dummy_client_window(void) DECLSPEC_HIDDEN;
 extern Window create_client_window( HWND hwnd, const XVisualInfo *visual ) DECLSPEC_HIDDEN;
 extern void set_window_visual( struct x11drv_win_data *data, const XVisualInfo *vis, BOOL use_alpha ) DECLSPEC_HIDDEN;
 extern void change_systray_owner( Display *display, Window systray_window ) DECLSPEC_HIDDEN;
+extern void update_systray_balloon_position(void) DECLSPEC_HIDDEN;
 extern HWND create_foreign_window( Display *display, Window window ) DECLSPEC_HIDDEN;
 extern BOOL update_clipboard( HWND hwnd ) DECLSPEC_HIDDEN;
-extern void init_win_context(void) DECLSPEC_HIDDEN;
-extern void *file_list_to_drop_files( const void *data, size_t size, size_t *ret_size ) DECLSPEC_HIDDEN;
-extern void *uri_list_to_drop_files( const void *data, size_t size, size_t *ret_size ) DECLSPEC_HIDDEN;
 
 static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 {
@@ -668,10 +672,13 @@ static inline void mirror_rect( const RECT *window_rect, RECT *rect )
 
 /* X context to associate a hwnd to an X window */
 extern XContext winContext DECLSPEC_HIDDEN;
+/* X context to associate a struct x11drv_win_data to an hwnd */
+extern XContext win_data_context DECLSPEC_HIDDEN;
 /* X context to associate an X cursor to a Win32 cursor handle */
 extern XContext cursor_context DECLSPEC_HIDDEN;
 
-extern void X11DRV_SetFocus( HWND hwnd ) DECLSPEC_HIDDEN;
+extern void X11DRV_InitClipboard(void) DECLSPEC_HIDDEN;
+extern void CDECL X11DRV_SetFocus( HWND hwnd ) DECLSPEC_HIDDEN;
 extern void set_window_cursor( Window window, HCURSOR handle ) DECLSPEC_HIDDEN;
 extern void sync_window_cursor( Window window ) DECLSPEC_HIDDEN;
 extern LRESULT clip_cursor_notify( HWND hwnd, HWND prev_clip_hwnd, HWND new_clip_hwnd ) DECLSPEC_HIDDEN;
@@ -682,22 +689,22 @@ extern void retry_grab_clipping_window(void) DECLSPEC_HIDDEN;
 extern BOOL clip_fullscreen_window( HWND hwnd, BOOL reset ) DECLSPEC_HIDDEN;
 extern void move_resize_window( HWND hwnd, int dir ) DECLSPEC_HIDDEN;
 extern void X11DRV_InitKeyboard( Display *display ) DECLSPEC_HIDDEN;
-extern NTSTATUS X11DRV_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                                    const LARGE_INTEGER *timeout,
-                                                    DWORD mask, DWORD flags ) DECLSPEC_HIDDEN;
-extern HWND *build_hwnd_list(void) DECLSPEC_HIDDEN;
+extern DWORD CDECL X11DRV_MsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles, DWORD timeout,
+                                                       DWORD mask, DWORD flags ) DECLSPEC_HIDDEN;
 
 typedef int (*x11drv_error_callback)( Display *display, XErrorEvent *event, void *arg );
 
 extern void X11DRV_expect_error( Display *display, x11drv_error_callback callback, void *arg ) DECLSPEC_HIDDEN;
 extern int X11DRV_check_error(void) DECLSPEC_HIDDEN;
 extern void X11DRV_X_to_window_rect( struct x11drv_win_data *data, RECT *rect, int x, int y, int cx, int cy ) DECLSPEC_HIDDEN;
+extern BOOL is_window_rect_full_screen( const RECT *rect ) DECLSPEC_HIDDEN;
 extern POINT virtual_screen_to_root( INT x, INT y ) DECLSPEC_HIDDEN;
 extern POINT root_to_virtual_screen( INT x, INT y ) DECLSPEC_HIDDEN;
+extern RECT get_virtual_screen_rect(void) DECLSPEC_HIDDEN;
+extern RECT get_primary_monitor_rect(void) DECLSPEC_HIDDEN;
 extern RECT get_host_primary_monitor_rect(void) DECLSPEC_HIDDEN;
 extern RECT get_work_area( const RECT *monitor_rect ) DECLSPEC_HIDDEN;
 extern void xinerama_init( unsigned int width, unsigned int height ) DECLSPEC_HIDDEN;
-extern void init_recursive_mutex( pthread_mutex_t *mutex ) DECLSPEC_HIDDEN;
 
 #define DEPTH_COUNT 3
 extern const unsigned int *depths DECLSPEC_HIDDEN;
@@ -816,116 +823,22 @@ extern void X11DRV_DisplayDevices_Update(BOOL) DECLSPEC_HIDDEN;
 extern struct x11drv_display_device_handler desktop_handler DECLSPEC_HIDDEN;
 
 /* XIM support */
-extern BOOL X11DRV_InitXIM( const WCHAR *input_style ) DECLSPEC_HIDDEN;
+extern BOOL X11DRV_InitXIM( const char *input_style ) DECLSPEC_HIDDEN;
 extern XIC X11DRV_CreateIC(XIM xim, struct x11drv_win_data *data) DECLSPEC_HIDDEN;
 extern void X11DRV_SetupXIM(void) DECLSPEC_HIDDEN;
 extern void X11DRV_XIMLookupChars( const char *str, DWORD count ) DECLSPEC_HIDDEN;
+extern void X11DRV_ForceXIMReset(HWND hwnd) DECLSPEC_HIDDEN;
+extern void X11DRV_SetPreeditState(HWND hwnd, BOOL fOpen) DECLSPEC_HIDDEN;
 
 #define XEMBED_MAPPED  (1 << 0)
 
 static inline BOOL is_window_rect_mapped( const RECT *rect )
 {
-    RECT virtual_rect = NtUserGetVirtualScreenRect();
+    RECT virtual_rect = get_virtual_screen_rect();
     return (rect->left < virtual_rect.right &&
             rect->top < virtual_rect.bottom &&
             max( rect->right, rect->left + 1 ) > virtual_rect.left &&
             max( rect->bottom, rect->top + 1 ) > virtual_rect.top);
 }
 
-/* unixlib interface */
-
-extern NTSTATUS x11drv_create_desktop( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_systray_clear( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_systray_dock( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_systray_hide( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_systray_init( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_tablet_attach_queue( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_tablet_get_packet( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_tablet_load_info( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_tablet_info( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_xim_preedit_state( void *arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_xim_reset( void *arg ) DECLSPEC_HIDDEN;
-
-extern NTSTATUS x11drv_client_func( enum x11drv_client_funcs func, const void *params,
-                                    ULONG size ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_client_call( enum client_callback func, UINT arg ) DECLSPEC_HIDDEN;
-
-/* GDI helpers */
-
-static inline BOOL lp_to_dp( HDC hdc, POINT *points, INT count )
-{
-    return NtGdiTransformPoints( hdc, points, points, count, NtGdiLPtoDP );
-}
-
-static inline UINT get_palette_entries( HPALETTE palette, UINT start, UINT count, PALETTEENTRY *entries )
-{
-    return NtGdiDoPalette( palette, start, count, entries, NtGdiGetPaletteEntries, TRUE );
-}
-
-/* user helpers */
-
-static inline LRESULT send_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    return NtUserMessageCall( hwnd, msg, wparam, lparam, NULL, NtUserSendMessage, FALSE );
-}
-
-static inline LRESULT send_message_timeout( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                            UINT flags, UINT timeout, PDWORD_PTR res_ptr )
-{
-    struct send_message_timeout_params params = { .flags = flags, .timeout = timeout };
-    LRESULT res = NtUserMessageCall( hwnd, msg, wparam, lparam, &params,
-                                     NtUserSendMessageTimeout, FALSE );
-    if (res_ptr) *res_ptr = params.result;
-    return res;
-}
-
-static inline BOOL send_notify_message( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam )
-{
-    return NtUserMessageCall( hwnd, msg, wparam, lparam, 0, NtUserSendNotifyMessage, FALSE );
-}
-
-static inline HWND get_focus(void)
-{
-    GUITHREADINFO info;
-    info.cbSize = sizeof(info);
-    return NtUserGetGUIThreadInfo( GetCurrentThreadId(), &info ) ? info.hwndFocus : 0;
-}
-
-static inline HWND get_active_window(void)
-{
-    GUITHREADINFO info;
-    info.cbSize = sizeof(info);
-    return NtUserGetGUIThreadInfo( GetCurrentThreadId(), &info ) ? info.hwndActive : 0;
-}
-
-static inline BOOL intersect_rect( RECT *dst, const RECT *src1, const RECT *src2 )
-{
-    dst->left   = max( src1->left, src2->left );
-    dst->top    = max( src1->top, src2->top );
-    dst->right  = min( src1->right, src2->right );
-    dst->bottom = min( src1->bottom, src2->bottom );
-    return !IsRectEmpty( dst );
-}
-
-/* registry helpers */
-
-extern HKEY open_hkcu_key( const char *name ) DECLSPEC_HIDDEN;
-extern ULONG query_reg_value( HKEY hkey, const WCHAR *name,
-                              KEY_VALUE_PARTIAL_INFORMATION *info, ULONG size ) DECLSPEC_HIDDEN;
-extern HKEY reg_open_key( HKEY root, const WCHAR *name, ULONG name_len ) DECLSPEC_HIDDEN;
-
-/* string helpers */
-
-static inline void ascii_to_unicode( WCHAR *dst, const char *src, size_t len )
-{
-    while (len--) *dst++ = (unsigned char)*src++;
-}
-
-static inline UINT asciiz_to_unicode( WCHAR *dst, const char *src )
-{
-    WCHAR *p = dst;
-    while ((*p++ = *src++));
-    return (p - dst) * sizeof(WCHAR);
-}
-
 #endif  /* __WINE_X11DRV_H */
diff --git a/dlls/winex11.drv/x11drv_dll.h b/dlls/winex11.drv/x11drv_dll.h
deleted file mode 100644
index 047bb430d39..00000000000
--- a/dlls/winex11.drv/x11drv_dll.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * X11 driver definitions
- *
- * Copyright 2022 Jacek Caban for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#ifndef __WINE_X11DRV_DLL_H
-#define __WINE_X11DRV_DLL_H
-
-#include <stdarg.h>
-#include "windef.h"
-#include "winbase.h"
-#include "ntgdi.h"
-#include "unixlib.h"
-
-extern NTSTATUS WINAPI x11drv_dnd_enter_event( void *params, ULONG size ) DECLSPEC_HIDDEN;
-extern NTSTATUS WINAPI x11drv_dnd_position_event( void *params, ULONG size ) DECLSPEC_HIDDEN;
-extern NTSTATUS WINAPI x11drv_dnd_post_drop( void *data, ULONG size ) DECLSPEC_HIDDEN;
-extern NTSTATUS WINAPI x11drv_ime_set_composition_string( void *params, ULONG size ) DECLSPEC_HIDDEN;
-extern NTSTATUS WINAPI x11drv_ime_set_result( void *params, ULONG size ) DECLSPEC_HIDDEN;
-extern NTSTATUS WINAPI x11drv_systray_change_owner( void *params, ULONG size ) DECLSPEC_HIDDEN;
-
-extern NTSTATUS x11drv_dnd_drop_event( UINT arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_dnd_leave_event( UINT arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_ime_get_cursor_pos( UINT arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_ime_set_composition_status( UINT arg ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_ime_set_cursor_pos( UINT pos ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_ime_set_open_status( UINT open ) DECLSPEC_HIDDEN;
-extern NTSTATUS x11drv_ime_update_association( UINT arg ) DECLSPEC_HIDDEN;
-
-extern LRESULT WINAPI foreign_window_proc( HWND hwnd, UINT msg, WPARAM wparam,
-                                           LPARAM lparam ) DECLSPEC_HIDDEN;
-
-extern BOOL show_systray DECLSPEC_HIDDEN;
-extern HMODULE x11drv_module DECLSPEC_HIDDEN;
-
-#endif /* __WINE_X11DRV_DLL_H */
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index dc987ae70a2..32beb84a009 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -19,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <fcntl.h>
@@ -32,7 +28,6 @@
 #include <string.h>
 #include <sys/time.h>
 #include <unistd.h>
-#include <assert.h>
 #include <dlfcn.h>
 #include <X11/cursorfont.h>
 #include <X11/Xlib.h>
@@ -45,18 +40,17 @@
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
-
-#define VK_NO_PROTOTYPES
-#define WINE_VK_HOST
+#include "windef.h"
+#include "winbase.h"
+#include "winreg.h"
 
 #include "x11drv.h"
-#include "winreg.h"
 #include "xcomposite.h"
 #include "wine/server.h"
+#include "wine/unicode.h"
 #include "wine/debug.h"
 #include "wine/list.h"
-#include "wine/vulkan.h"
-#include "wine/vulkan_driver.h"
+#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
 WINE_DECLARE_DEBUG_CHANNEL(synchronous);
@@ -66,7 +60,6 @@ XVisualInfo default_visual = { 0 };
 XVisualInfo argb_visual = { 0 };
 Colormap default_colormap = None;
 XPixmapFormatValues **pixmap_formats;
-Atom systray_atom = 0;
 unsigned int screen_bpp;
 Window root_window;
 BOOL usexvidmode = TRUE;
@@ -88,9 +81,10 @@ BOOL client_side_with_render = TRUE;
 BOOL shape_layered_windows = TRUE;
 int copy_default_colors = 128;
 int alloc_system_colors = 256;
+DWORD thread_data_tls_index = TLS_OUT_OF_INDEXES;
 int xrender_error_base = 0;
+HMODULE x11drv_module = 0;
 char *process_name = NULL;
-WNDPROC client_foreign_window_proc = NULL;
 
 static x11drv_error_callback err_callback;   /* current callback for error */
 static Display *err_callback_display;        /* display callback is set for */
@@ -99,18 +93,25 @@ static int err_callback_result;              /* error callback result */
 static unsigned long err_serial;             /* serial number of first request */
 static int (*old_error_handler)( Display *, XErrorEvent * );
 static BOOL use_xim = TRUE;
-static WCHAR input_style[20];
+static char input_style[20];
 
-static pthread_mutex_t d3dkmt_mutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t error_mutex = PTHREAD_MUTEX_INITIALIZER;
+static CRITICAL_SECTION x11drv_section;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &x11drv_section,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+    0, 0, { (DWORD_PTR)(__FILE__ ": x11drv_section") }
+};
+static CRITICAL_SECTION x11drv_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
-struct x11_d3dkmt_adapter
+static CRITICAL_SECTION x11drv_error_section;
+static CRITICAL_SECTION_DEBUG x11drv_error_section_debug =
 {
-    D3DKMT_HANDLE handle;                   /* Kernel mode graphics adapter handle */
-    VkInstance vk_instance;                 /* Vulkan instance */
-    VkPhysicalDevice vk_device;             /* Vulkan physical device */
-    struct list entry;                      /* List entry */
+    0, 0, &x11drv_error_section,
+    { &x11drv_error_section_debug.ProcessLocksList, &x11drv_error_section_debug.ProcessLocksList },
+    0, 0, { (DWORD_PTR)(__FILE__ ": x11drv_error_section") }
 };
+static CRITICAL_SECTION x11drv_error_section = { &x11drv_error_section_debug, -1, 0, 0, 0, 0 };
 
 struct d3dkmt_vidpn_source
 {
@@ -120,7 +121,6 @@ struct d3dkmt_vidpn_source
     struct list entry;                      /* List entry */
 };
 
-static struct list x11_d3dkmt_adapters = LIST_INIT( x11_d3dkmt_adapters );
 static struct list d3dkmt_vidpn_sources = LIST_INIT( d3dkmt_vidpn_sources );   /* VidPN source information list */
 
 #define IS_OPTION_TRUE(ch) \
@@ -220,16 +220,6 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "text/uri-list"
 };
 
-/* We use use pointer to call NtWaitForMultipleObjects to make it go through
- * syscall dispatcher. We need that because win32u bypasses syscall thunks and
- * if we called NtWaitForMultipleObjects directly, it wouldn't be able to handle
- * user APCs. This will be removed as soon as we may use syscall interface
- * for NtUserMsgWaitForMultipleObjectsEx. */
-NTSTATUS (WINAPI *pNtWaitForMultipleObjects)( ULONG, const HANDLE *, BOOLEAN,
-                                              BOOLEAN, const LARGE_INTEGER* );
-
-static NTSTATUS CDECL unix_call( enum x11drv_funcs code, void *params );
-
 /***********************************************************************
  *		ignore_error
  *
@@ -272,7 +262,7 @@ static inline BOOL ignore_error( Display *display, XErrorEvent *event )
  */
 void X11DRV_expect_error( Display *display, x11drv_error_callback callback, void *arg )
 {
-    pthread_mutex_lock( &error_mutex );
+    EnterCriticalSection( &x11drv_error_section );
     err_callback         = callback;
     err_callback_display = display;
     err_callback_arg     = arg;
@@ -291,7 +281,7 @@ int X11DRV_check_error(void)
 {
     int res = err_callback_result;
     err_callback = NULL;
-    pthread_mutex_unlock( &error_mutex );
+    LeaveCriticalSection( &x11drv_error_section );
     return res;
 }
 
@@ -321,7 +311,7 @@ static int error_handler( Display *display, XErrorEvent *error_evt )
     {
         ERR( "X protocol error: serial=%ld, request_code=%d - breaking into debugger\n",
              error_evt->serial, error_evt->request_code );
-        assert( 0 );
+        DebugBreak();  /* force an entry in the debugger */
     }
     old_error_handler( display, error_evt );
     return 0;
@@ -341,103 +331,21 @@ static void init_pixmap_formats( Display *display )
                formats[i].depth, formats[i].bits_per_pixel, formats[i].scanline_pad );
         if (formats[i].depth > max) max = formats[i].depth;
     }
-    pixmap_formats = calloc( 1, sizeof(*pixmap_formats) * (max + 1) );
+    pixmap_formats = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*pixmap_formats) * (max + 1) );
     for (i = 0; i < count; i++) pixmap_formats[formats[i].depth] = &formats[i];
 }
 
 
-HKEY reg_open_key( HKEY root, const WCHAR *name, ULONG name_len )
-{
-    UNICODE_STRING nameW = { name_len, name_len, (WCHAR *)name };
-    OBJECT_ATTRIBUTES attr;
-    HANDLE ret;
-
-    attr.Length = sizeof(attr);
-    attr.RootDirectory = root;
-    attr.ObjectName = &nameW;
-    attr.Attributes = 0;
-    attr.SecurityDescriptor = NULL;
-    attr.SecurityQualityOfService = NULL;
-
-    return NtOpenKeyEx( &ret, MAXIMUM_ALLOWED, &attr, 0 ) ? 0 : ret;
-}
-
-
-HKEY open_hkcu_key( const char *name )
-{
-    WCHAR bufferW[256];
-    static HKEY hkcu;
-
-    if (!hkcu)
-    {
-        char buffer[256];
-        DWORD_PTR sid_data[(sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE) / sizeof(DWORD_PTR)];
-        DWORD i, len = sizeof(sid_data);
-        SID *sid;
-
-        if (NtQueryInformationToken( GetCurrentThreadEffectiveToken(), TokenUser, sid_data, len, &len ))
-            return 0;
-
-        sid = ((TOKEN_USER *)sid_data)->User.Sid;
-        len = sprintf( buffer, "\\Registry\\User\\S-%u-%u", sid->Revision,
-                       MAKELONG( MAKEWORD( sid->IdentifierAuthority.Value[5],
-                                           sid->IdentifierAuthority.Value[4] ),
-                                 MAKEWORD( sid->IdentifierAuthority.Value[3],
-                                           sid->IdentifierAuthority.Value[2] )));
-        for (i = 0; i < sid->SubAuthorityCount; i++)
-            len += sprintf( buffer + len, "-%u", sid->SubAuthority[i] );
-
-        ascii_to_unicode( bufferW, buffer, len );
-        hkcu = reg_open_key( NULL, bufferW, len * sizeof(WCHAR) );
-    }
-
-    return reg_open_key( hkcu, bufferW, asciiz_to_unicode( bufferW, name ) - sizeof(WCHAR) );
-}
-
-
-ULONG query_reg_value( HKEY hkey, const WCHAR *name, KEY_VALUE_PARTIAL_INFORMATION *info, ULONG size )
-{
-    unsigned int name_size = name ? lstrlenW( name ) * sizeof(WCHAR) : 0;
-    UNICODE_STRING nameW = { name_size, name_size, (WCHAR *)name };
-
-    if (NtQueryValueKey( hkey, &nameW, KeyValuePartialInformation,
-                         info, size, &size ))
-        return 0;
-
-    return size - FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data);
-}
-
-
 /***********************************************************************
  *		get_config_key
  *
  * Get a config key from either the app-specific or the default config
  */
 static inline DWORD get_config_key( HKEY defkey, HKEY appkey, const char *name,
-                                    WCHAR *buffer, DWORD size )
+                                    char *buffer, DWORD size )
 {
-    WCHAR nameW[128];
-    char buf[2048];
-    KEY_VALUE_PARTIAL_INFORMATION *info = (void *)buf;
-
-    asciiz_to_unicode( nameW, name );
-
-    if (appkey && query_reg_value( appkey, nameW, info, sizeof(buf) ))
-    {
-        size = min( info->DataLength, size - sizeof(WCHAR) );
-        memcpy( buffer, info->Data, size );
-        buffer[size / sizeof(WCHAR)] = 0;
-        return 0;
-    }
-
-    if (defkey && query_reg_value( defkey, nameW, info, sizeof(buf) ))
-    {
-        size = min( info->DataLength, size - sizeof(WCHAR) );
-        memcpy( buffer, info->Data, size );
-        buffer[size / sizeof(WCHAR)] = 0;
-        return 0;
-    }
-
+    if (appkey && !RegQueryValueExA( appkey, name, 0, NULL, (LPBYTE)buffer, &size )) return 0;
+    if (defkey && !RegQueryValueExA( defkey, name, 0, NULL, (LPBYTE)buffer, &size )) return 0;
     return ERROR_FILE_NOT_FOUND;
 }
 
@@ -450,35 +358,33 @@ static inline DWORD get_config_key( HKEY defkey, HKEY appkey, const char *name,
 static void setup_options(void)
 {
     static const WCHAR x11driverW[] = {'\\','X','1','1',' ','D','r','i','v','e','r',0};
-    WCHAR buffer[MAX_PATH+16], *p, *appname;
+    char buffer[64];
+    WCHAR bufferW[MAX_PATH+16];
     HKEY hkey, appkey = 0;
     DWORD len;
 
     /* @@ Wine registry key: HKCU\Software\Wine\X11 Driver */
-    hkey = open_hkcu_key( "Software\\Wine\\X11 Driver" );
+    if (RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\X11 Driver", &hkey )) hkey = 0;
 
     /* open the app-specific key */
 
-    appname = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
-    if ((p = wcsrchr( appname, '/' ))) appname = p + 1;
-    if ((p = wcsrchr( appname, '\\' ))) appname = p + 1;
-    len = lstrlenW( appname );
-
+    len = (GetModuleFileNameW( 0, bufferW, MAX_PATH ));
     if (len && len < MAX_PATH)
     {
         HKEY tmpkey;
-        int i;
-        for (i = 0; appname[i]; i++) buffer[i] = RtlDowncaseUnicodeChar( appname[i] );
-        buffer[i] = 0;
-        appname = buffer;
-        if ((process_name = malloc( len * 3 + 1 )))
-            ntdll_wcstoumbs( appname, len + 1, process_name, len * 3 + 1, FALSE );
-        memcpy( appname + i, x11driverW, sizeof(x11driverW) );
+        WCHAR *p, *appname = bufferW;
+        if ((p = strrchrW( appname, '/' ))) appname = p + 1;
+        if ((p = strrchrW( appname, '\\' ))) appname = p + 1;
+        CharLowerW(appname);
+        len = WideCharToMultiByte( CP_UNIXCP, 0, appname, -1, NULL, 0, NULL, NULL );
+        if ((process_name = HeapAlloc( GetProcessHeap(), 0, len )))
+            WideCharToMultiByte( CP_UNIXCP, 0, appname, -1, process_name, len, NULL, NULL );
+        strcatW( appname, x11driverW );
         /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\X11 Driver */
-        if ((tmpkey = open_hkcu_key( "Software\\Wine\\AppDefaults" )))
+        if (!RegOpenKeyA( HKEY_CURRENT_USER, "Software\\Wine\\AppDefaults", &tmpkey ))
         {
-            appkey = reg_open_key( tmpkey, appname, lstrlenW( appname ) * sizeof(WCHAR) );
-            NtClose( tmpkey );
+            if (RegOpenKeyW( tmpkey, appname, &appkey )) appkey = 0;
+            RegCloseKey( tmpkey );
         }
     }
 
@@ -513,7 +419,7 @@ static void setup_options(void)
         grab_fullscreen = IS_OPTION_TRUE( buffer[0] );
 
     if (!get_config_key( hkey, appkey, "ScreenDepth", buffer, sizeof(buffer) ))
-        default_visual.depth = wcstol( buffer, NULL, 0 );
+        default_visual.depth = atoi(buffer);
 
     if (!get_config_key( hkey, appkey, "ClientSideGraphics", buffer, sizeof(buffer) ))
         client_side_graphics = IS_OPTION_TRUE( buffer[0] );
@@ -531,18 +437,18 @@ static void setup_options(void)
         private_color_map = IS_OPTION_TRUE( buffer[0] );
 
     if (!get_config_key( hkey, appkey, "PrimaryMonitor", buffer, sizeof(buffer) ))
-        primary_monitor = wcstol( buffer, NULL, 0 );
+        primary_monitor = atoi( buffer );
 
     if (!get_config_key( hkey, appkey, "CopyDefaultColors", buffer, sizeof(buffer) ))
-        copy_default_colors = wcstol( buffer, NULL, 0 );
+        copy_default_colors = atoi(buffer);
 
     if (!get_config_key( hkey, appkey, "AllocSystemColors", buffer, sizeof(buffer) ))
-        alloc_system_colors = wcstol( buffer, NULL, 0 );
+        alloc_system_colors = atoi(buffer);
 
     get_config_key( hkey, appkey, "InputStyle", input_style, sizeof(input_style) );
 
-    NtClose( appkey );
-    NtClose( hkey );
+    if (appkey) RegCloseKey( appkey );
+    if (hkey) RegCloseKey( hkey );
 }
 
 #ifdef SONAME_LIBXCOMPOSITE
@@ -660,16 +566,15 @@ static void init_visuals( Display *display, int screen )
 /***********************************************************************
  *           X11DRV process initialisation routine
  */
-static NTSTATUS x11drv_init( void *arg )
+static BOOL process_attach(void)
 {
-    struct init_params *params = arg;
     Display *display;
     void *libx11 = dlopen( SONAME_LIBX11, RTLD_NOW|RTLD_GLOBAL );
 
     if (!libx11)
     {
         ERR( "failed to load %s: %s\n", SONAME_LIBX11, dlerror() );
-        return STATUS_UNSUCCESSFUL;
+        return FALSE;
     }
     pXGetEventData = dlsym( libx11, "XGetEventData" );
     pXFreeEventData = dlsym( libx11, "XFreeEventData" );
@@ -679,13 +584,12 @@ static NTSTATUS x11drv_init( void *arg )
 
     setup_options();
 
+    if ((thread_data_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES) return FALSE;
+
     /* Open display */
 
     if (!XInitThreads()) ERR( "XInitThreads failed, trouble ahead\n" );
-    if (!(display = XOpenDisplay( NULL ))) return STATUS_UNSUCCESSFUL;
-
-    pNtWaitForMultipleObjects = params->pNtWaitForMultipleObjects;
-    client_foreign_window_proc = params->foreign_window_proc;
+    if (!(display = XOpenDisplay( NULL ))) return FALSE;
 
     fcntl( ConnectionNumber(display), F_SETFD, 1 ); /* set close on exec flag */
     root_window = DefaultRootWindow( display );
@@ -698,7 +602,9 @@ static NTSTATUS x11drv_init( void *arg )
 
     XInternAtoms( display, (char **)atom_names, NB_XATOMS - FIRST_XATOM, False, X11DRV_Atoms );
 
-    init_win_context();
+    winContext = XUniqueContext();
+    win_data_context = XUniqueContext();
+    cursor_context = XUniqueContext();
 
     if (TRACE_ON(synchronous)) XSynchronize( display, True );
 
@@ -723,18 +629,16 @@ static NTSTATUS x11drv_init( void *arg )
 
     init_user_driver();
     X11DRV_DisplayDevices_Init(FALSE);
-    params->show_systray = show_systray;
-    params->unix_call = unix_call;
-    return STATUS_SUCCESS;
+    return TRUE;
 }
 
 
 /***********************************************************************
  *           ThreadDetach (X11DRV.@)
  */
-void X11DRV_ThreadDetach(void)
+void CDECL X11DRV_ThreadDetach(void)
 {
-    struct x11drv_thread_data *data = x11drv_thread_data();
+    struct x11drv_thread_data *data = TlsGetValue( thread_data_tls_index );
 
     if (data)
     {
@@ -742,9 +646,9 @@ void X11DRV_ThreadDetach(void)
         if (data->xim) XCloseIM( data->xim );
         if (data->font_set) XFreeFontSet( data->display, data->font_set );
         XCloseDisplay( data->display );
-        free( data );
+        HeapFree( GetProcessHeap(), 0, data );
         /* clear data in case we get re-entered from user32 before the thread is truly dead */
-        NtUserGetThreadInfo()->driver_data = NULL;
+        TlsSetValue( thread_data_tls_index, NULL );
     }
 }
 
@@ -758,7 +662,7 @@ static void set_queue_display_fd( Display *display )
     if (wine_server_fd_to_handle( ConnectionNumber(display), GENERIC_READ | SYNCHRONIZE, 0, &handle ))
     {
         MESSAGE( "x11drv: Can't allocate handle for display fd\n" );
-        NtTerminateProcess( 0, 1 );
+        ExitProcess(1);
     }
     SERVER_START_REQ( set_queue_fd )
     {
@@ -769,9 +673,9 @@ static void set_queue_display_fd( Display *display )
     if (ret)
     {
         MESSAGE( "x11drv: Can't store handle for display fd\n" );
-        NtTerminateProcess( 0, 1 );
+        ExitProcess(1);
     }
-    NtClose( handle );
+    CloseHandle( handle );
 }
 
 
@@ -784,15 +688,15 @@ struct x11drv_thread_data *x11drv_init_thread_data(void)
 
     if (data) return data;
 
-    if (!(data = calloc( 1, sizeof(*data) )))
+    if (!(data = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*data) )))
     {
         ERR( "could not create data\n" );
-        NtTerminateProcess( 0, 1 );
+        ExitProcess(1);
     }
     if (!(data->display = XOpenDisplay(NULL)))
     {
         ERR_(winediag)( "x11drv: Can't open display: %s. Please ensure that your X server is running and that $DISPLAY is set correctly.\n", XDisplayName(NULL));
-        NtTerminateProcess( 0, 1 );
+        ExitProcess(1);
     }
 
     fcntl( ConnectionNumber(data->display), F_SETFD, 1 ); /* set close on exec flag */
@@ -805,7 +709,7 @@ struct x11drv_thread_data *x11drv_init_thread_data(void)
     if (TRACE_ON(synchronous)) XSynchronize( data->display, True );
 
     set_queue_display_fd( data->display );
-    NtUserGetThreadInfo()->driver_data = data;
+    TlsSetValue( thread_data_tls_index, data );
 
     if (use_xim) X11DRV_SetupXIM();
 
@@ -813,10 +717,29 @@ struct x11drv_thread_data *x11drv_init_thread_data(void)
 }
 
 
+/***********************************************************************
+ *           X11DRV initialisation routine
+ */
+BOOL WINAPI DllMain( HINSTANCE hinst, DWORD reason, LPVOID reserved )
+{
+    BOOL ret = TRUE;
+
+    switch(reason)
+    {
+    case DLL_PROCESS_ATTACH:
+        DisableThreadLibraryCalls( hinst );
+        x11drv_module = hinst;
+        ret = process_attach();
+        break;
+    }
+    return ret;
+}
+
+
 /***********************************************************************
  *              SystemParametersInfo (X11DRV.@)
  */
-BOOL X11DRV_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param, UINT flags )
+BOOL CDECL X11DRV_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param, UINT flags )
 {
     switch (action)
     {
@@ -849,29 +772,6 @@ BOOL X11DRV_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param,
     return FALSE;  /* let user32 handle it */
 }
 
-NTSTATUS CDECL X11DRV_D3DKMTCloseAdapter( const D3DKMT_CLOSEADAPTER *desc )
-{
-    const struct vulkan_funcs *vulkan_funcs = get_vulkan_driver(WINE_VULKAN_DRIVER_VERSION);
-    struct x11_d3dkmt_adapter *adapter;
-
-    if (!vulkan_funcs)
-        return STATUS_UNSUCCESSFUL;
-
-    pthread_mutex_lock(&d3dkmt_mutex);
-    LIST_FOR_EACH_ENTRY(adapter, &x11_d3dkmt_adapters, struct x11_d3dkmt_adapter, entry)
-    {
-        if (adapter->handle == desc->hAdapter)
-        {
-            vulkan_funcs->p_vkDestroyInstance(adapter->vk_instance, NULL);
-            list_remove(&adapter->entry);
-            free(adapter);
-            break;
-        }
-    }
-    pthread_mutex_unlock(&d3dkmt_mutex);
-    return STATUS_SUCCESS;
-}
-
 /**********************************************************************
  *           X11DRV_D3DKMTSetVidPnSourceOwner
  */
@@ -884,7 +784,7 @@ NTSTATUS CDECL X11DRV_D3DKMTSetVidPnSourceOwner( const D3DKMT_SETVIDPNSOURCEOWNE
 
     TRACE("(%p)\n", desc);
 
-    pthread_mutex_lock( &d3dkmt_mutex );
+    EnterCriticalSection( &x11drv_section );
 
     /* Check parameters */
     for (i = 0; i < desc->VidPnSourceCount; ++i)
@@ -945,7 +845,7 @@ NTSTATUS CDECL X11DRV_D3DKMTSetVidPnSourceOwner( const D3DKMT_SETVIDPNSOURCEOWNE
             if (source->device == desc->hDevice)
             {
                 list_remove( &source->entry );
-                free( source );
+                heap_free( source );
             }
         }
         goto done;
@@ -968,7 +868,7 @@ NTSTATUS CDECL X11DRV_D3DKMTSetVidPnSourceOwner( const D3DKMT_SETVIDPNSOURCEOWNE
             source->type = desc->pType[i];
         else
         {
-            source = malloc( sizeof( *source ) );
+            source = heap_alloc( sizeof( *source ) );
             if (!source)
             {
                 status = STATUS_NO_MEMORY;
@@ -983,7 +883,7 @@ NTSTATUS CDECL X11DRV_D3DKMTSetVidPnSourceOwner( const D3DKMT_SETVIDPNSOURCEOWNE
     }
 
 done:
-    pthread_mutex_unlock( &d3dkmt_mutex );
+    LeaveCriticalSection( &x11drv_section );
     return status;
 }
 
@@ -999,329 +899,15 @@ NTSTATUS CDECL X11DRV_D3DKMTCheckVidPnExclusiveOwnership( const D3DKMT_CHECKVIDP
     if (!desc || !desc->hAdapter)
         return STATUS_INVALID_PARAMETER;
 
-    pthread_mutex_lock( &d3dkmt_mutex );
+    EnterCriticalSection( &x11drv_section );
     LIST_FOR_EACH_ENTRY( source, &d3dkmt_vidpn_sources, struct d3dkmt_vidpn_source, entry )
     {
         if (source->id == desc->VidPnSourceId && source->type == D3DKMT_VIDPNSOURCEOWNER_EXCLUSIVE)
         {
-            pthread_mutex_unlock( &d3dkmt_mutex );
+            LeaveCriticalSection( &x11drv_section );
             return STATUS_GRAPHICS_PRESENT_OCCLUDED;
         }
     }
-    pthread_mutex_unlock( &d3dkmt_mutex );
+    LeaveCriticalSection( &x11drv_section );
     return STATUS_SUCCESS;
 }
-
-/* Find the Vulkan device UUID corresponding to a LUID */
-static BOOL get_vulkan_uuid_from_luid( const LUID *luid, GUID *uuid )
-{
-    static const WCHAR class_guidW[] = {'C','l','a','s','s','G','U','I','D',0};
-    static const WCHAR devpropkey_gpu_vulkan_uuidW[] =
-    {
-        'P','r','o','p','e','r','t','i','e','s',
-        '\\','{','2','3','3','A','9','E','F','3','-','A','F','C','4','-','4','A','B','D',
-        '-','B','5','6','4','-','C','3','2','F','2','1','F','1','5','3','5','C','}',
-        '\\','0','0','0','2'
-    };
-    static const WCHAR devpropkey_gpu_luidW[] =
-    {
-        'P','r','o','p','e','r','t','i','e','s',
-        '\\','{','6','0','B','1','9','3','C','B','-','5','2','7','6','-','4','D','0','F',
-        '-','9','6','F','C','-','F','1','7','3','A','B','A','D','3','E','C','6','}',
-        '\\','0','0','0','2'
-    };
-    static const WCHAR guid_devclass_displayW[] =
-        {'{','4','D','3','6','E','9','6','8','-','E','3','2','5','-','1','1','C','E','-',
-         'B','F','C','1','-','0','8','0','0','2','B','E','1','0','3','1','8','}',0};
-    static const WCHAR pci_keyW[] =
-    {
-        '\\','R','e','g','i','s','t','r','y',
-        '\\','M','a','c','h','i','n','e',
-        '\\','S','y','s','t','e','m',
-        '\\','C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t',
-        '\\','E','n','u','m',
-        '\\','P','C','I'
-    };
-    char buffer[4096];
-    KEY_VALUE_PARTIAL_INFORMATION *value = (void *)buffer;
-    HKEY subkey, device_key, prop_key, pci_key;
-    KEY_NODE_INFORMATION *key = (void *)buffer;
-    DWORD size, i = 0;
-    HANDLE mutex;
-
-    mutex = get_display_device_init_mutex();
-
-    pci_key = reg_open_key(NULL, pci_keyW, sizeof(pci_keyW));
-    while (!NtEnumerateKey(pci_key, i++, KeyNodeInformation, key, sizeof(buffer), &size))
-    {
-        unsigned int j = 0;
-
-        if (!(subkey = reg_open_key(pci_key, key->Name, key->NameLength)))
-            continue;
-
-        while (!NtEnumerateKey(subkey, j++, KeyNodeInformation, key, sizeof(buffer), &size))
-        {
-            if (!(device_key = reg_open_key(subkey, key->Name, key->NameLength)))
-                continue;
-
-            size = query_reg_value(device_key, class_guidW, value, sizeof(buffer));
-            if (size != sizeof(guid_devclass_displayW) ||
-                wcscmp((WCHAR *)value->Data, guid_devclass_displayW))
-            {
-                NtClose(device_key);
-                continue;
-            }
-
-            if (!(prop_key = reg_open_key(device_key, devpropkey_gpu_luidW,
-                                          sizeof(devpropkey_gpu_luidW))))
-            {
-                NtClose(device_key);
-                continue;
-            }
-
-            size = query_reg_value(prop_key, NULL, value, sizeof(buffer));
-            NtClose(prop_key);
-            if (size != sizeof(LUID) || memcmp(value->Data, luid, sizeof(LUID)))
-            {
-                NtClose(device_key);
-                continue;
-            }
-
-            if (!(prop_key = reg_open_key(device_key, devpropkey_gpu_vulkan_uuidW,
-                                          sizeof(devpropkey_gpu_vulkan_uuidW))))
-            {
-                NtClose(device_key);
-                continue;
-            }
-
-            size = query_reg_value(prop_key, NULL, value, sizeof(buffer));
-            NtClose(prop_key);
-            if (size != sizeof(GUID))
-            {
-                NtClose(device_key);
-                continue;
-            }
-
-            *uuid = *(const GUID *)value->Data;
-            NtClose(device_key);
-            NtClose(subkey);
-            NtClose(pci_key);
-            release_display_device_init_mutex(mutex);
-            return TRUE;
-        }
-        NtClose(subkey);
-    }
-    NtClose(pci_key);
-
-    release_display_device_init_mutex(mutex);
-    return FALSE;
-}
-
-NTSTATUS CDECL X11DRV_D3DKMTOpenAdapterFromLuid( D3DKMT_OPENADAPTERFROMLUID *desc )
-{
-    static const char *extensions[] =
-    {
-        VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,
-        VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME,
-    };
-    const struct vulkan_funcs *vulkan_funcs;
-    PFN_vkGetPhysicalDeviceProperties2KHR pvkGetPhysicalDeviceProperties2KHR;
-    PFN_vkEnumeratePhysicalDevices pvkEnumeratePhysicalDevices;
-    VkPhysicalDevice *vk_physical_devices = NULL;
-    VkPhysicalDeviceProperties2 properties2;
-    NTSTATUS status = STATUS_UNSUCCESSFUL;
-    DWORD device_count, device_idx = 0;
-    struct x11_d3dkmt_adapter *adapter;
-    VkInstanceCreateInfo create_info;
-    VkPhysicalDeviceIDProperties id;
-    VkInstance vk_instance = NULL;
-    VkResult vr;
-    GUID uuid;
-
-    if (!get_vulkan_uuid_from_luid(&desc->AdapterLuid, &uuid))
-    {
-        WARN("Failed to find Vulkan device with LUID %08x:%08x.\n", desc->AdapterLuid.HighPart,
-             desc->AdapterLuid.LowPart);
-        return STATUS_INVALID_PARAMETER;
-    }
-
-    /* Find the Vulkan device with corresponding UUID */
-    if (!(vulkan_funcs = get_vulkan_driver(WINE_VULKAN_DRIVER_VERSION)))
-    {
-        WARN("Vulkan is unavailable.\n");
-        return STATUS_UNSUCCESSFUL;
-    }
-
-    memset(&create_info, 0, sizeof(create_info));
-    create_info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
-    create_info.enabledExtensionCount = ARRAY_SIZE(extensions);
-    create_info.ppEnabledExtensionNames = extensions;
-
-    vr = vulkan_funcs->p_vkCreateInstance(&create_info, NULL, &vk_instance);
-    if (vr != VK_SUCCESS)
-    {
-        WARN("Failed to create a Vulkan instance, vr %d.\n", vr);
-        goto done;
-    }
-
-#define LOAD_VK_FUNC(f)                                                           \
-    if (!(p##f = (void *)vulkan_funcs->p_vkGetInstanceProcAddr(vk_instance, #f))) \
-    {                                                                             \
-        WARN("Failed to load " #f ".\n");                                         \
-        goto done;                                                                \
-    }
-
-    LOAD_VK_FUNC(vkEnumeratePhysicalDevices)
-    LOAD_VK_FUNC(vkGetPhysicalDeviceProperties2KHR)
-#undef LOAD_VK_FUNC
-
-    vr = pvkEnumeratePhysicalDevices(vk_instance, &device_count, NULL);
-    if (vr != VK_SUCCESS || !device_count)
-    {
-        WARN("No Vulkan device found, vr %d, device_count %d.\n", vr, device_count);
-        goto done;
-    }
-
-    if (!(vk_physical_devices = calloc(device_count, sizeof(*vk_physical_devices))))
-        goto done;
-
-    vr = pvkEnumeratePhysicalDevices(vk_instance, &device_count, vk_physical_devices);
-    if (vr != VK_SUCCESS)
-    {
-        WARN("vkEnumeratePhysicalDevices failed, vr %d.\n", vr);
-        goto done;
-    }
-
-    for (device_idx = 0; device_idx < device_count; ++device_idx)
-    {
-        memset(&id, 0, sizeof(id));
-        id.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES;
-        properties2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2;
-        properties2.pNext = &id;
-
-        pvkGetPhysicalDeviceProperties2KHR(vk_physical_devices[device_idx], &properties2);
-        if (!IsEqualGUID(&uuid, id.deviceUUID))
-            continue;
-
-        if (!(adapter = malloc(sizeof(*adapter))))
-        {
-            status = STATUS_NO_MEMORY;
-            goto done;
-        }
-
-        adapter->handle = desc->hAdapter;
-        adapter->vk_instance = vk_instance;
-        adapter->vk_device = vk_physical_devices[device_idx];
-        pthread_mutex_lock(&d3dkmt_mutex);
-        list_add_head(&x11_d3dkmt_adapters, &adapter->entry);
-        pthread_mutex_unlock(&d3dkmt_mutex);
-        free(vk_physical_devices);
-        return STATUS_SUCCESS;
-    }
-
-done:
-    free(vk_physical_devices);
-    if (vk_instance)
-        vulkan_funcs->p_vkDestroyInstance(vk_instance, NULL);
-    return status;
-}
-
-NTSTATUS CDECL X11DRV_D3DKMTQueryVideoMemoryInfo( D3DKMT_QUERYVIDEOMEMORYINFO *desc )
-{
-    const struct vulkan_funcs *vulkan_funcs = get_vulkan_driver(WINE_VULKAN_DRIVER_VERSION);
-    PFN_vkGetPhysicalDeviceMemoryProperties2KHR pvkGetPhysicalDeviceMemoryProperties2KHR;
-    VkPhysicalDeviceMemoryBudgetPropertiesEXT budget;
-    VkPhysicalDeviceMemoryProperties2 properties2;
-    NTSTATUS status = STATUS_INVALID_PARAMETER;
-    struct x11_d3dkmt_adapter *adapter;
-    unsigned int i;
-
-    desc->Budget = 0;
-    desc->CurrentUsage = 0;
-    desc->CurrentReservation = 0;
-    desc->AvailableForReservation = 0;
-
-    if (!vulkan_funcs)
-    {
-        WARN("Vulkan is unavailable.\n");
-        return STATUS_UNSUCCESSFUL;
-    }
-
-    pthread_mutex_lock(&d3dkmt_mutex);
-    LIST_FOR_EACH_ENTRY(adapter, &x11_d3dkmt_adapters, struct x11_d3dkmt_adapter, entry)
-    {
-        if (adapter->handle != desc->hAdapter)
-            continue;
-
-        if (!(pvkGetPhysicalDeviceMemoryProperties2KHR = (void *)vulkan_funcs->p_vkGetInstanceProcAddr(adapter->vk_instance, "vkGetPhysicalDeviceMemoryProperties2KHR")))
-        {
-            WARN("Failed to load vkGetPhysicalDeviceMemoryProperties2KHR.\n");
-            status = STATUS_UNSUCCESSFUL;
-            goto done;
-        }
-
-        memset(&budget, 0, sizeof(budget));
-        budget.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT;
-        properties2.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2;
-        properties2.pNext = &budget;
-        pvkGetPhysicalDeviceMemoryProperties2KHR(adapter->vk_device, &properties2);
-        for (i = 0; i < properties2.memoryProperties.memoryHeapCount; ++i)
-        {
-            if ((desc->MemorySegmentGroup == D3DKMT_MEMORY_SEGMENT_GROUP_LOCAL
-                && properties2.memoryProperties.memoryHeaps[i].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)
-                || (desc->MemorySegmentGroup == D3DKMT_MEMORY_SEGMENT_GROUP_NON_LOCAL
-                && !(properties2.memoryProperties.memoryHeaps[i].flags & VK_MEMORY_HEAP_DEVICE_LOCAL_BIT)))
-            {
-                desc->Budget += budget.heapBudget[i];
-                desc->CurrentUsage += budget.heapUsage[i];
-            }
-        }
-        desc->AvailableForReservation = desc->Budget / 2;
-        status = STATUS_SUCCESS;
-        break;
-    }
-done:
-    pthread_mutex_unlock(&d3dkmt_mutex);
-    return status;
-}
-
-NTSTATUS x11drv_client_func( enum x11drv_client_funcs id, const void *params, ULONG size )
-{
-    void *ret_ptr;
-    ULONG ret_len;
-    return KeUserModeCallback( id, params, size, &ret_ptr, &ret_len );
-}
-
-
-NTSTATUS x11drv_client_call( enum client_callback func, UINT arg )
-{
-    struct client_callback_params params = { .id = func, .arg = arg };
-    return x11drv_client_func( client_func_callback, &params, sizeof(params) );
-}
-
-
-const unixlib_entry_t __wine_unix_call_funcs[] =
-{
-    x11drv_create_desktop,
-    x11drv_init,
-    x11drv_systray_clear,
-    x11drv_systray_dock,
-    x11drv_systray_hide,
-    x11drv_systray_init,
-    x11drv_tablet_attach_queue,
-    x11drv_tablet_get_packet,
-    x11drv_tablet_info,
-    x11drv_tablet_load_info,
-    x11drv_xim_preedit_state,
-    x11drv_xim_reset,
-};
-
-
-C_ASSERT( ARRAYSIZE(__wine_unix_call_funcs) == unix_funcs_count );
-
-
-/* FIXME: Use __wine_unix_call instead */
-static NTSTATUS CDECL unix_call( enum x11drv_funcs code, void *params )
-{
-    return __wine_unix_call_funcs[code]( params );
-}
diff --git a/dlls/winex11.drv/xdnd.c b/dlls/winex11.drv/xdnd.c
index 9137f46b5dc..eb685613b7b 100644
--- a/dlls/winex11.drv/xdnd.c
+++ b/dlls/winex11.drv/xdnd.c
@@ -19,19 +19,41 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#define COBJMACROS
+#include "config.h"
+
+#include <string.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <stdio.h>
+
 #define NONAMELESSUNION
 
-#include "x11drv_dll.h"
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "winuser.h"
+
+#define COBJMACROS
+#include "x11drv.h"
 #include "shellapi.h"
-#include "shlobj.h"
+#include "shlobj.h"  /* DROPFILES */
+#include "oleidl.h"
+#include "objidl.h"
 
 #include "wine/debug.h"
 #include "wine/list.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(xdnd);
 
-static struct format_entry *xdnd_formats, *xdnd_formats_end;
+typedef struct tagXDNDDATA
+{
+    int cf_win;
+    Atom cf_xdnd;
+    HANDLE contents;
+    struct list entry;
+} XDNDDATA, *LPXDNDDATA;
+
+static struct list xdndData = LIST_INIT(xdndData);
 static POINT XDNDxy = { 0, 0 };
 static IDataObject XDNDDataObject;
 static BOOL XDNDAccepted = FALSE;
@@ -41,6 +63,9 @@ static HWND XDNDLastTargetWnd;
 /* might be an ancestor of XDNDLastTargetWnd */
 static HWND XDNDLastDropTargetWnd;
 
+static void X11DRV_XDND_InsertXDNDData( Atom property, UINT format, HANDLE contents );
+static void X11DRV_XDND_ResolveProperty(Display *display, Window xwin, Time tm,
+    Atom *types, unsigned long count);
 static BOOL X11DRV_XDND_HasHDROP(void);
 static HRESULT X11DRV_XDND_SendDropFiles(HWND hwnd);
 static void X11DRV_XDND_FreeDragDropOp(void);
@@ -55,12 +80,6 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 static CRITICAL_SECTION xdnd_cs = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 
-static struct format_entry *next_format( struct format_entry *entry )
-{
-    return (struct format_entry *)&entry->data[(entry->size + 7) & ~7];
-}
-
-
 /* Based on functions in dlls/ole32/ole2.c */
 static HANDLE get_droptarget_local_handle(HWND hwnd)
 {
@@ -128,6 +147,108 @@ static IDropTarget* get_droptarget_pointer(HWND hwnd)
     return droptarget;
 }
 
+/**************************************************************************
+ * X11DRV_XDND_XdndActionToDROPEFFECT
+ */
+static DWORD X11DRV_XDND_XdndActionToDROPEFFECT(long action)
+{
+    /* In Windows, nothing but the given effects is allowed.
+     * In X the given action is just a hint, and you can always
+     * XdndActionCopy and XdndActionPrivate, so be more permissive. */
+    if (action == x11drv_atom(XdndActionCopy))
+        return DROPEFFECT_COPY;
+    else if (action == x11drv_atom(XdndActionMove))
+        return DROPEFFECT_MOVE | DROPEFFECT_COPY;
+    else if (action == x11drv_atom(XdndActionLink))
+        return DROPEFFECT_LINK | DROPEFFECT_COPY;
+    else if (action == x11drv_atom(XdndActionAsk))
+        /* FIXME: should we somehow ask the user what to do here? */
+        return DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK;
+    FIXME("unknown action %ld, assuming DROPEFFECT_COPY\n", action);
+    return DROPEFFECT_COPY;
+}
+
+/**************************************************************************
+ * X11DRV_XDND_DROPEFFECTToXdndAction
+ */
+static long X11DRV_XDND_DROPEFFECTToXdndAction(DWORD effect)
+{
+    if (effect == DROPEFFECT_COPY)
+        return x11drv_atom(XdndActionCopy);
+    else if (effect == DROPEFFECT_MOVE)
+        return x11drv_atom(XdndActionMove);
+    else if (effect == DROPEFFECT_LINK)
+        return x11drv_atom(XdndActionLink);
+    FIXME("unknown drop effect %u, assuming XdndActionCopy\n", effect);
+    return x11drv_atom(XdndActionCopy);
+}
+
+/**************************************************************************
+ * X11DRV_XDND_EnterEvent
+ *
+ * Handle an XdndEnter event.
+ */
+void X11DRV_XDND_EnterEvent( HWND hWnd, XClientMessageEvent *event )
+{
+    int version;
+    Atom *xdndtypes;
+    unsigned long count = 0;
+
+    version = (event->data.l[1] & 0xFF000000) >> 24;
+    TRACE("ver(%d) check-XdndTypeList(%ld) data=%ld,%ld,%ld,%ld,%ld\n",
+          version, (event->data.l[1] & 1),
+          event->data.l[0], event->data.l[1], event->data.l[2],
+          event->data.l[3], event->data.l[4]);
+
+    if (version > WINE_XDND_VERSION)
+    {
+        ERR("ignoring unsupported XDND version %d\n", version);
+        return;
+    }
+
+    XDNDAccepted = FALSE;
+
+    /* If the source supports more than 3 data types we retrieve
+     * the entire list. */
+    if (event->data.l[1] & 1)
+    {
+        Atom acttype;
+        int actfmt;
+        unsigned long bytesret;
+
+        /* Request supported formats from source window */
+        XGetWindowProperty(event->display, event->data.l[0], x11drv_atom(XdndTypeList),
+                           0, 65535, FALSE, AnyPropertyType, &acttype, &actfmt, &count,
+                           &bytesret, (unsigned char**)&xdndtypes);
+    }
+    else
+    {
+        count = 3;
+        xdndtypes = (Atom*) &event->data.l[2];
+    }
+
+    if (TRACE_ON(xdnd))
+    {
+        unsigned int i;
+
+        for (i = 0; i < count; i++)
+        {
+            if (xdndtypes[i] != 0)
+            {
+                char * pn = XGetAtomName(event->display, xdndtypes[i]);
+                TRACE("XDNDEnterAtom %ld: %s\n", xdndtypes[i], pn);
+                XFree(pn);
+            }
+        }
+    }
+
+    /* Do a one-time data read and cache results */
+    X11DRV_XDND_ResolveProperty(event->display, event->window,
+                                event->data.l[1], xdndtypes, count);
+
+    if (event->data.l[1] & 1)
+        XFree(xdndtypes);
+}
 
 /* Recursively searches for a window on given coordinates in a drag&drop specific manner.
  *
@@ -162,22 +283,26 @@ static HWND window_accepting_files(HWND hwnd)
 }
 
 /**************************************************************************
- *           x11drv_dnd_position_event
+ * X11DRV_XDND_PositionEvent
  *
  * Handle an XdndPosition event.
  */
-NTSTATUS WINAPI x11drv_dnd_position_event( void *arg, ULONG size )
+void X11DRV_XDND_PositionEvent( HWND hWnd, XClientMessageEvent *event )
 {
-    struct dnd_position_event_params *params = arg;
+    XClientMessageEvent e;
     int accept = 0; /* Assume we're not accepting */
     IDropTarget *dropTarget = NULL;
-    DWORD effect = params->effect;
-    POINTL pointl = { .x = params->point.x, .y = params->point.y };
+    DWORD effect;
+    POINTL pointl;
     HWND targetWindow;
     HRESULT hr;
 
-    XDNDxy = params->point;
-    targetWindow = window_from_point_dnd( params->hwnd, XDNDxy );
+    XDNDxy = root_to_virtual_screen( event->data.l[2] >> 16, event->data.l[2] & 0xFFFF );
+    targetWindow = window_from_point_dnd(hWnd, XDNDxy);
+
+    pointl.x = XDNDxy.x;
+    pointl.y = XDNDxy.y;
+    effect = X11DRV_XDND_XdndActionToDROPEFFECT(event->data.l[4]);
 
     if (!XDNDAccepted || XDNDLastTargetWnd != targetWindow)
     {
@@ -248,11 +373,37 @@ NTSTATUS WINAPI x11drv_dnd_position_event( void *arg, ULONG size )
         }
     }
 
-    return accept ? effect : 0;
+    TRACE("actionRequested(%ld) accept(%d) chosen(0x%x) at x(%d),y(%d)\n",
+          event->data.l[4], accept, effect, XDNDxy.x, XDNDxy.y);
+
+    /*
+     * Let source know if we're accepting the drop by
+     * sending a status message.
+     */
+    e.type = ClientMessage;
+    e.display = event->display;
+    e.window = event->data.l[0];
+    e.message_type = x11drv_atom(XdndStatus);
+    e.format = 32;
+    e.data.l[0] = event->window;
+    e.data.l[1] = accept;
+    e.data.l[2] = 0; /* Empty Rect */
+    e.data.l[3] = 0; /* Empty Rect */
+    if (accept)
+        e.data.l[4] = X11DRV_XDND_DROPEFFECTToXdndAction(effect);
+    else
+        e.data.l[4] = None;
+    XSendEvent(event->display, event->data.l[0], False, NoEventMask, (XEvent*)&e);
 }
 
-NTSTATUS x11drv_dnd_drop_event( UINT arg )
+/**************************************************************************
+ * X11DRV_XDND_DropEvent
+ *
+ * Handle an XdndDrop event.
+ */
+void X11DRV_XDND_DropEvent( HWND hWnd, XClientMessageEvent *event )
 {
+    XClientMessageEvent e;
     IDropTarget *dropTarget;
     DWORD effect = XDNDDropEffect;
     int accept = 0; /* Assume we're not accepting */
@@ -305,7 +456,7 @@ NTSTATUS x11drv_dnd_drop_event( UINT arg )
         /* Only send WM_DROPFILES if Drop didn't succeed or DROPEFFECT_NONE was set.
          * Doing both causes winamp to duplicate the dropped files (#29081) */
 
-        HWND hwnd_drop = window_accepting_files(window_from_point_dnd( UlongToHandle(arg), XDNDxy ));
+        HWND hwnd_drop = window_accepting_files(window_from_point_dnd(hWnd, XDNDxy));
 
         if (hwnd_drop && X11DRV_XDND_HasHDROP())
         {
@@ -321,15 +472,28 @@ NTSTATUS x11drv_dnd_drop_event( UINT arg )
     TRACE("effectRequested(0x%x) accept(%d) performed(0x%x) at x(%d),y(%d)\n",
           XDNDDropEffect, accept, effect, XDNDxy.x, XDNDxy.y);
 
-    return accept ? effect : 0;
+    /* Tell the target we are finished. */
+    memset(&e, 0, sizeof(e));
+    e.type = ClientMessage;
+    e.display = event->display;
+    e.window = event->data.l[0];
+    e.message_type = x11drv_atom(XdndFinished);
+    e.format = 32;
+    e.data.l[0] = event->window;
+    e.data.l[1] = accept;
+    if (accept)
+        e.data.l[2] = X11DRV_XDND_DROPEFFECTToXdndAction(effect);
+    else
+        e.data.l[2] = None;
+    XSendEvent(event->display, event->data.l[0], False, NoEventMask, (XEvent*)&e);
 }
 
 /**************************************************************************
- *           x11drv_dnd_leave_event
+ * X11DRV_XDND_LeaveEvent
  *
  * Handle an XdndLeave event.
  */
-NTSTATUS x11drv_dnd_leave_event( UINT arg )
+void X11DRV_XDND_LeaveEvent( HWND hWnd, XClientMessageEvent *event )
 {
     IDropTarget *dropTarget;
 
@@ -349,25 +513,71 @@ NTSTATUS x11drv_dnd_leave_event( UINT arg )
     }
 
     X11DRV_XDND_FreeDragDropOp();
-    return 0;
 }
 
 
 /**************************************************************************
- *           x11drv_dnd_enter_event
+ * X11DRV_XDND_ResolveProperty
+ *
+ * Resolve all MIME types to windows clipboard formats. All data is cached.
  */
-NTSTATUS WINAPI x11drv_dnd_enter_event( void *params, ULONG size )
+static void X11DRV_XDND_ResolveProperty(Display *display, Window xwin, Time tm,
+                                        Atom *types, unsigned long count)
 {
-    struct format_entry *formats = params;
-    XDNDAccepted = FALSE;
+    XDNDDATA *current, *next;
+    BOOL haveHDROP = FALSE;
+
+    TRACE("count(%ld)\n", count);
+
     X11DRV_XDND_FreeDragDropOp(); /* Clear previously cached data */
 
-    if ((xdnd_formats = HeapAlloc( GetProcessHeap(), 0, size )))
+    X11DRV_CLIPBOARD_ImportSelection( display, xwin, x11drv_atom(XdndSelection),
+                                      types, count, X11DRV_XDND_InsertXDNDData );
+
+    /* On Windows when there is a CF_HDROP, there are no other CF_ formats.
+     * foobar2000 relies on this (spaces -> %20's without it).
+     */
+    LIST_FOR_EACH_ENTRY(current, &xdndData, XDNDDATA, entry)
     {
-        memcpy( xdnd_formats, formats, size );
-        xdnd_formats_end = (struct format_entry *)((char *)xdnd_formats + size);
+        if (current->cf_win == CF_HDROP)
+        {
+            haveHDROP = TRUE;
+            break;
+        }
+    }
+    if (haveHDROP)
+    {
+        LIST_FOR_EACH_ENTRY_SAFE(current, next, &xdndData, XDNDDATA, entry)
+        {
+            if (current->cf_win != CF_HDROP && current->cf_win < CF_MAX)
+            {
+                list_remove(&current->entry);
+                GlobalFree(current->contents);
+                HeapFree(GetProcessHeap(), 0, current);
+            }
+        }
+    }
+}
+
+
+/**************************************************************************
+ * X11DRV_XDND_InsertXDNDData
+ *
+ * Cache available XDND property
+ */
+static void X11DRV_XDND_InsertXDNDData( Atom property, UINT format, HANDLE contents )
+{
+    LPXDNDDATA current = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(XDNDDATA));
+
+    if (current)
+    {
+        EnterCriticalSection(&xdnd_cs);
+        current->cf_xdnd = property;
+        current->cf_win = format;
+        current->contents = contents;
+        list_add_tail(&xdndData, &current->entry);
+        LeaveCriticalSection(&xdnd_cs);
     }
-    return 0;
 }
 
 
@@ -376,15 +586,15 @@ NTSTATUS WINAPI x11drv_dnd_enter_event( void *params, ULONG size )
  */
 static BOOL X11DRV_XDND_HasHDROP(void)
 {
-    struct format_entry *iter;
+    LPXDNDDATA current = NULL;
     BOOL found = FALSE;
 
     EnterCriticalSection(&xdnd_cs);
 
     /* Find CF_HDROP type if any */
-    for (iter = xdnd_formats; iter < xdnd_formats_end; iter = next_format( iter ))
+    LIST_FOR_EACH_ENTRY(current, &xdndData, XDNDDATA, entry)
     {
-        if (iter->format == CF_HDROP)
+        if (current->cf_win == CF_HDROP)
         {
             found = TRUE;
             break;
@@ -401,15 +611,15 @@ static BOOL X11DRV_XDND_HasHDROP(void)
  */
 static HRESULT X11DRV_XDND_SendDropFiles(HWND hwnd)
 {
-    struct format_entry *iter;
     HRESULT hr;
+    LPXDNDDATA current = NULL;
     BOOL found = FALSE;
 
     EnterCriticalSection(&xdnd_cs);
 
-    for (iter = xdnd_formats; iter < xdnd_formats_end; iter = next_format( iter ))
+    LIST_FOR_EACH_ENTRY(current, &xdndData, XDNDDATA, entry)
     {
-         if (iter->format == CF_HDROP)
+         if (current->cf_win == CF_HDROP)
          {
              found = TRUE;
              break;
@@ -417,12 +627,13 @@ static HRESULT X11DRV_XDND_SendDropFiles(HWND hwnd)
     }
     if (found)
     {
-        HGLOBAL dropHandle = GlobalAlloc(GMEM_FIXED, iter->size);
+        HGLOBAL dropHandle = GlobalAlloc(GMEM_FIXED, GlobalSize(current->contents));
         if (dropHandle)
         {
             RECT rect;
             DROPFILES *lpDrop = GlobalLock(dropHandle);
-            memcpy(lpDrop, iter->data, iter->size);
+            memcpy(lpDrop, GlobalLock(current->contents), GlobalSize(current->contents));
+            GlobalUnlock(current->contents);
             lpDrop->pt.x = XDNDxy.x;
             lpDrop->pt.y = XDNDxy.y;
             lpDrop->fNC  = !(ScreenToClient(hwnd, &lpDrop->pt) &&
@@ -457,12 +668,20 @@ static HRESULT X11DRV_XDND_SendDropFiles(HWND hwnd)
  */
 static void X11DRV_XDND_FreeDragDropOp(void)
 {
+    LPXDNDDATA next;
+    LPXDNDDATA current;
+
     TRACE("\n");
 
     EnterCriticalSection(&xdnd_cs);
 
-    HeapFree( GetProcessHeap(), 0, xdnd_formats );
-    xdnd_formats = xdnd_formats_end = NULL;
+    /** Free data cache */
+    LIST_FOR_EACH_ENTRY_SAFE(current, next, &xdndData, XDNDDATA, entry)
+    {
+        list_remove(&current->entry);
+        GlobalFree(current->contents);
+        HeapFree(GetProcessHeap(), 0, current);
+    }
 
     XDNDxy.x = XDNDxy.y = 0;
     XDNDLastTargetWnd = NULL;
@@ -559,18 +778,18 @@ static HRESULT WINAPI XDNDDATAOBJECT_GetData(IDataObject *dataObject,
     hr = IDataObject_QueryGetData(dataObject, formatEtc);
     if (SUCCEEDED(hr))
     {
-        struct format_entry *iter;
-
-        for (iter = xdnd_formats; iter < xdnd_formats_end; iter = next_format( iter ))
+        XDNDDATA *current;
+        LIST_FOR_EACH_ENTRY(current, &xdndData, XDNDDATA, entry)
         {
-            if (iter->format == formatEtc->cfFormat)
+            if (current->cf_win == formatEtc->cfFormat)
             {
                 pMedium->tymed = TYMED_HGLOBAL;
-                pMedium->u.hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, iter->size);
+                pMedium->u.hGlobal = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, GlobalSize(current->contents));
                 if (pMedium->u.hGlobal == NULL)
                     return E_OUTOFMEMORY;
-                memcpy(GlobalLock(pMedium->u.hGlobal), iter->data, iter->size);
+                memcpy(GlobalLock(pMedium->u.hGlobal), GlobalLock(current->contents), GlobalSize(current->contents));
                 GlobalUnlock(pMedium->u.hGlobal);
+                GlobalUnlock(current->contents);
                 pMedium->pUnkForRelease = 0;
                 return S_OK;
             }
@@ -590,8 +809,8 @@ static HRESULT WINAPI XDNDDATAOBJECT_GetDataHere(IDataObject *dataObject,
 static HRESULT WINAPI XDNDDATAOBJECT_QueryGetData(IDataObject *dataObject,
                                                   FORMATETC *formatEtc)
 {
-    struct format_entry *iter;
     char formatDesc[1024];
+    XDNDDATA *current;
 
     TRACE("(%p, %p={.tymed=0x%x, .dwAspect=%d, .cfFormat=%d}\n",
         dataObject, formatEtc, formatEtc->tymed, formatEtc->dwAspect, formatEtc->cfFormat);
@@ -606,9 +825,9 @@ static HRESULT WINAPI XDNDDATAOBJECT_QueryGetData(IDataObject *dataObject,
      * and we have no way to implement them on XDnD anyway, so ignore them too.
      */
 
-    for (iter = xdnd_formats; iter < xdnd_formats_end; iter = next_format( iter ))
+    LIST_FOR_EACH_ENTRY(current, &xdndData, XDNDDATA, entry)
     {
-        if (iter->format == formatEtc->cfFormat)
+        if (current->cf_win == formatEtc->cfFormat)
         {
             TRACE("application found %s\n", formatDesc);
             return S_OK;
@@ -640,8 +859,7 @@ static HRESULT WINAPI XDNDDATAOBJECT_EnumFormatEtc(IDataObject *dataObject,
                                                    DWORD dwDirection,
                                                    IEnumFORMATETC **ppEnumFormatEtc)
 {
-    struct format_entry *iter;
-    DWORD count = 0;
+    DWORD count;
     FORMATETC *formats;
 
     TRACE("(%p, %u, %p)\n", dataObject, dwDirection, ppEnumFormatEtc);
@@ -652,16 +870,16 @@ static HRESULT WINAPI XDNDDATAOBJECT_EnumFormatEtc(IDataObject *dataObject,
         return E_NOTIMPL;
     }
 
-    for (iter = xdnd_formats; iter < xdnd_formats_end; iter = next_format( iter )) count++;
-
+    count = list_count(&xdndData);
     formats = HeapAlloc(GetProcessHeap(), 0, count * sizeof(FORMATETC));
     if (formats)
     {
+        XDNDDATA *current;
         DWORD i = 0;
         HRESULT hr;
-        for (iter = xdnd_formats; iter < xdnd_formats_end; iter = next_format( iter ))
+        LIST_FOR_EACH_ENTRY(current, &xdndData, XDNDDATA, entry)
         {
-            formats[i].cfFormat = iter->format;
+            formats[i].cfFormat = current->cf_win;
             formats[i].ptd = NULL;
             formats[i].dwAspect = DVASPECT_CONTENT;
             formats[i].lindex = -1;
@@ -717,21 +935,3 @@ static IDataObjectVtbl xdndDataObjectVtbl =
 };
 
 static IDataObject XDNDDataObject = { &xdndDataObjectVtbl };
-
-NTSTATUS WINAPI x11drv_dnd_post_drop( void *data, ULONG size )
-{
-    HDROP handle;
-
-    if ((handle = GlobalAlloc( GMEM_SHARE, size )))
-    {
-        DROPFILES *ptr = GlobalLock( handle );
-        HWND hwnd;
-        memcpy( ptr, data, size );
-        hwnd = UlongToHandle( ptr->fWide );
-        ptr->fWide = TRUE;
-        GlobalUnlock( handle );
-        PostMessageW( hwnd, WM_DROPFILES, (WPARAM)handle, 0 );
-    }
-
-    return 0;
-}
diff --git a/dlls/winex11.drv/xim.c b/dlls/winex11.drv/xim.c
index 00c15bb3bcf..3994c2106cc 100644
--- a/dlls/winex11.drv/xim.c
+++ b/dlls/winex11.drv/xim.c
@@ -18,10 +18,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 #include <stdio.h>
 #include <stdlib.h>
@@ -75,7 +71,13 @@ static void X11DRV_ImmSetInternalString(DWORD dwOffset,
 
     if (byte_expansion + dwCompStringLength >= dwCompStringSize)
     {
-        ptr_new = realloc( CompositionString, dwCompStringSize + byte_expansion );
+        if (CompositionString)
+            ptr_new = HeapReAlloc(GetProcessHeap(), 0, CompositionString,
+                                  dwCompStringSize + byte_expansion);
+        else
+            ptr_new = HeapAlloc(GetProcessHeap(), 0,
+                                dwCompStringSize + byte_expansion);
+
         if (ptr_new == NULL)
         {
             ERR("Couldn't expand composition string buffer\n");
@@ -92,22 +94,29 @@ static void X11DRV_ImmSetInternalString(DWORD dwOffset,
     if (lpComp) memcpy(ptr_new, lpComp, byte_length);
     dwCompStringLength += byte_expansion;
 
-    x11drv_client_func( client_func_ime_set_composition_string,
-                        CompositionString, dwCompStringLength );
+    IME_SetCompositionString(SCS_SETSTR, CompositionString,
+                             dwCompStringLength, NULL, 0);
 }
 
 void X11DRV_XIMLookupChars( const char *str, DWORD count )
 {
-    WCHAR *output;
-    DWORD len;
+    DWORD dwOutput;
+    WCHAR *wcOutput;
+    HWND focus;
 
     TRACE("%p %u\n", str, count);
 
-    if (!(output = malloc( count * sizeof(WCHAR) ))) return;
-    len = ntdll_umbstowcs( str, count, output, count );
+    dwOutput = MultiByteToWideChar(CP_UNIXCP, 0, str, count, NULL, 0);
+    wcOutput = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR) * dwOutput);
+    if (wcOutput == NULL)
+        return;
+    MultiByteToWideChar(CP_UNIXCP, 0, str, count, wcOutput, dwOutput);
+
+    if ((focus = GetFocus()))
+        IME_UpdateAssociation(focus);
 
-    x11drv_client_func( client_func_ime_set_result, output, len * sizeof(WCHAR) );
-    free( output );
+    IME_SetResultString(wcOutput, dwOutput);
+    HeapFree(GetProcessHeap(), 0, wcOutput);
 }
 
 static BOOL XIMPreEditStateNotifyCallback(XIC xic, XPointer p, XPointer data)
@@ -119,22 +128,21 @@ static BOOL XIMPreEditStateNotifyCallback(XIC xic, XPointer p, XPointer data)
     switch (state)
     {
     case XIMPreeditEnable:
-        x11drv_client_call( client_ime_set_open_status, TRUE );
+        IME_SetOpenStatus(TRUE);
         break;
     case XIMPreeditDisable:
-        x11drv_client_call( client_ime_set_open_status, FALSE );
+        IME_SetOpenStatus(FALSE);
         break;
     default:
         break;
     }
-
     return TRUE;
 }
 
 static int XIMPreEditStartCallback(XIC ic, XPointer client_data, XPointer call_data)
 {
     TRACE("PreEditStartCallback %p\n",ic);
-    x11drv_client_call( client_ime_set_composition_status, TRUE );
+    IME_SetCompositionStatus(TRUE);
     ximInComposeMode = TRUE;
     return -1;
 }
@@ -144,11 +152,11 @@ static void XIMPreEditDoneCallback(XIC ic, XPointer client_data, XPointer call_d
     TRACE("PreeditDoneCallback %p\n",ic);
     ximInComposeMode = FALSE;
     if (dwCompStringSize)
-        free( CompositionString );
+        HeapFree(GetProcessHeap(), 0, CompositionString);
     dwCompStringSize = 0;
     dwCompStringLength = 0;
     CompositionString = NULL;
-    x11drv_client_call( client_ime_set_composition_status, FALSE );
+    IME_SetCompositionStatus(FALSE);
 }
 
 static void XIMPreEditDrawCallback(XIM ic, XPointer client_data,
@@ -164,18 +172,24 @@ static void XIMPreEditDrawCallback(XIM ic, XPointer client_data,
         {
             if (! P_DR->text->encoding_is_wchar)
             {
-                size_t text_len;
-                WCHAR *output;
+                DWORD dwOutput;
+                WCHAR *wcOutput;
 
                 TRACE("multibyte\n");
-                text_len = strlen( P_DR->text->string.multi_byte );
-                if ((output = malloc( text_len * sizeof(WCHAR) )))
+                dwOutput = MultiByteToWideChar(CP_UNIXCP, 0,
+                           P_DR->text->string.multi_byte, -1,
+                           NULL, 0);
+                wcOutput = HeapAlloc(GetProcessHeap(), 0, sizeof (WCHAR) * dwOutput);
+                if (wcOutput)
                 {
-                    text_len = ntdll_umbstowcs( P_DR->text->string.multi_byte, text_len,
-                                                output, text_len );
-
-                    X11DRV_ImmSetInternalString( sel, len, output, text_len );
-                    free( output );
+                    dwOutput = MultiByteToWideChar(CP_UNIXCP, 0,
+                               P_DR->text->string.multi_byte, -1,
+                               wcOutput, dwOutput);
+
+                    /* ignore null */
+                    dwOutput --;
+                    X11DRV_ImmSetInternalString (sel, len, wcOutput, dwOutput);
+                    HeapFree(GetProcessHeap(), 0, wcOutput);
                 }
             }
             else
@@ -188,7 +202,7 @@ static void XIMPreEditDrawCallback(XIM ic, XPointer client_data,
         }
         else
             X11DRV_ImmSetInternalString (sel, len, NULL, 0);
-        x11drv_client_call( client_ime_set_cursor_pos, P_DR->caret );
+        IME_SetCursorPos(P_DR->caret);
     }
     TRACE("Finished\n");
 }
@@ -200,7 +214,7 @@ static void XIMPreEditCaretCallback(XIC ic, XPointer client_data,
 
     if (P_C)
     {
-        int pos = x11drv_client_call( client_ime_get_cursor_pos, 0 );
+        int pos = IME_GetCursorPos();
         TRACE("pos: %d\n", pos);
         switch(P_C->direction)
         {
@@ -229,13 +243,13 @@ static void XIMPreEditCaretCallback(XIC ic, XPointer client_data,
                 FIXME("Not implemented\n");
                 break;
         }
-        x11drv_client_call( client_ime_set_cursor_pos, pos );
+        IME_SetCursorPos(pos);
         P_C->position = pos;
     }
     TRACE("Finished\n");
 }
 
-NTSTATUS x11drv_xim_reset( void *hwnd )
+void X11DRV_ForceXIMReset(HWND hwnd)
 {
     XIC ic = X11DRV_get_ic(hwnd);
     if (ic)
@@ -245,21 +259,19 @@ NTSTATUS x11drv_xim_reset( void *hwnd )
         leftover = XmbResetIC(ic);
         XFree(leftover);
     }
-    return 0;
 }
 
-NTSTATUS x11drv_xim_preedit_state( void *arg )
+void X11DRV_SetPreeditState(HWND hwnd, BOOL fOpen)
 {
-    struct xim_preedit_state_params *params = arg;
     XIC ic;
     XIMPreeditState state;
     XVaNestedList attr;
 
-    ic = X11DRV_get_ic( params->hwnd );
+    ic = X11DRV_get_ic(hwnd);
     if (!ic)
-        return 0;
+        return;
 
-    if (params->open)
+    if (fOpen)
         state = XIMPreeditEnable;
     else
         state = XIMPreeditDisable;
@@ -270,7 +282,6 @@ NTSTATUS x11drv_xim_preedit_state( void *arg )
         XSetICValues(ic, XNPreeditAttributes, attr, NULL);
         XFree(attr);
     }
-    return 0;
 }
 
 
@@ -279,17 +290,13 @@ NTSTATUS x11drv_xim_preedit_state( void *arg )
  *
  * Process-wide XIM initialization.
  */
-BOOL X11DRV_InitXIM( const WCHAR *input_style )
+BOOL X11DRV_InitXIM( const char *input_style )
 {
-    static const WCHAR offthespotW[] = {'o','f','f','t','h','e','s','p','o','t',0};
-    static const WCHAR overthespotW[] = {'o','v','e','r','t','h','e','s','p','o','t',0};
-    static const WCHAR rootW[] = {'r','o','o','t',0};
-
-    if (!wcsicmp( input_style, offthespotW ))
+    if (!_strnicmp(input_style, "offthespot", -1))
         ximStyleRequest = STYLE_OFFTHESPOT;
-    else if (!wcsicmp( input_style, overthespotW ))
+    else if (!_strnicmp(input_style, "overthespot", -1))
         ximStyleRequest = STYLE_OVERTHESPOT;
-    else if (!wcsicmp( input_style, rootW ))
+    else if (!_strnicmp(input_style, "root", -1))
         ximStyleRequest = STYLE_ROOT;
 
     if (!XSupportsLocale())
@@ -423,7 +430,7 @@ static BOOL open_xim( Display *display )
     else
         thread_data->font_set = NULL;
 
-    x11drv_client_call( client_ime_update_association, 0 );
+    IME_UpdateAssociation(NULL);
     return TRUE;
 }
 
@@ -458,24 +465,17 @@ XIC X11DRV_CreateIC(XIM xim, struct x11drv_win_data *data)
     XIC xic;
     XICCallback destroy = {(XPointer)data, X11DRV_DestroyIC};
     XICCallback P_StateNotifyCB, P_StartCB, P_DoneCB, P_DrawCB, P_CaretCB;
-    LCID lcid;
+    LANGID langid = PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale()));
     Window win = data->whole_window;
     XFontSet fontSet = x11drv_thread_data()->font_set;
 
     TRACE("xim = %p\n", xim);
 
-    lcid = NtCurrentTeb()->CurrentLocale;
-    if (!lcid) NtQueryDefaultLocale( TRUE, &lcid );
-
     /* use complex and slow XIC initialization method only for CJK */
-    switch (PRIMARYLANGID(LANGIDFROMLCID(lcid)))
+    if (langid != LANG_CHINESE &&
+        langid != LANG_JAPANESE &&
+        langid != LANG_KOREAN)
     {
-    case LANG_CHINESE:
-    case LANG_JAPANESE:
-    case LANG_KOREAN:
-        break;
-
-    default:
         xic = XCreateIC(xim,
                         XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
                         XNClientWindow, win,
diff --git a/dlls/winex11.drv/xinerama.c b/dlls/winex11.drv/xinerama.c
index 847b8fb6efb..b707574a0ab 100644
--- a/dlls/winex11.drv/xinerama.c
+++ b/dlls/winex11.drv/xinerama.c
@@ -18,10 +18,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <stdarg.h>
@@ -33,6 +29,7 @@
 #include <dlfcn.h>
 #include "x11drv.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
 
@@ -90,8 +87,8 @@ static int query_screens(void)
         !pXineramaQueryExtension( gdi_display, &event_base, &error_base ) ||
         !(screens = pXineramaQueryScreens( gdi_display, &count ))) return 0;
 
-    if (monitors != &default_monitor) free( monitors );
-    if ((monitors = malloc( count * sizeof(*monitors) )))
+    if (monitors != &default_monitor) HeapFree( GetProcessHeap(), 0, monitors );
+    if ((monitors = HeapAlloc( GetProcessHeap(), 0, count * sizeof(*monitors) )))
     {
         nb_monitors = count;
         for (i = 0; i < nb_monitors; i++)
@@ -128,7 +125,7 @@ static BOOL xinerama_get_gpus( struct gdi_gpu **new_gpus, int *count )
     struct gdi_gpu *gpus;
 
     /* Xinerama has no support for GPU, faking one */
-    gpus = calloc( 1, sizeof(*gpus) );
+    gpus = heap_calloc( 1, sizeof(*gpus) );
     if (!gpus)
         return FALSE;
 
@@ -142,7 +139,7 @@ static BOOL xinerama_get_gpus( struct gdi_gpu **new_gpus, int *count )
 
 static void xinerama_free_gpus( struct gdi_gpu *gpus )
 {
-    free( gpus );
+    heap_free( gpus );
 }
 
 static BOOL xinerama_get_adapters( ULONG_PTR gpu_id, struct gdi_adapter **new_adapters, int *count )
@@ -157,7 +154,7 @@ static BOOL xinerama_get_adapters( ULONG_PTR gpu_id, struct gdi_adapter **new_ad
         return FALSE;
 
     /* Being lazy, actual adapter count may be less */
-    adapters = calloc( nb_monitors, sizeof(*adapters) );
+    adapters = heap_calloc( nb_monitors, sizeof(*adapters) );
     if (!adapters)
         return FALSE;
 
@@ -209,7 +206,7 @@ static BOOL xinerama_get_adapters( ULONG_PTR gpu_id, struct gdi_adapter **new_ad
 
 static void xinerama_free_adapters( struct gdi_adapter *adapters )
 {
-    free( adapters );
+    heap_free( adapters );
 }
 
 static BOOL xinerama_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **new_monitors, int *count )
@@ -231,7 +228,7 @@ static BOOL xinerama_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **ne
             monitor_count++;
     }
 
-    monitor = calloc( monitor_count, sizeof(*monitor) );
+    monitor = heap_calloc( monitor_count, sizeof(*monitor) );
     if (!monitor)
         return FALSE;
 
@@ -262,7 +259,7 @@ static BOOL xinerama_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **ne
 
 static void xinerama_free_monitors( struct gdi_monitor *monitors, int count )
 {
-    free( monitors );
+    heap_free( monitors );
 }
 
 void xinerama_init( unsigned int width, unsigned int height )
diff --git a/dlls/winex11.drv/xrandr.c b/dlls/winex11.drv/xrandr.c
index d3b96e3170b..fb7a4405a1e 100644
--- a/dlls/winex11.drv/xrandr.c
+++ b/dlls/winex11.drv/xrandr.c
@@ -20,10 +20,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #define NONAMELESSSTRUCT
@@ -47,6 +43,8 @@ WINE_DECLARE_DEBUG_CHANNEL(winediag);
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
 
+#include "wine/heap.h"
+#include "wine/unicode.h"
 #include "wine/vulkan.h"
 #include "wine/vulkan_driver.h"
 
@@ -154,7 +152,7 @@ static BOOL xrandr10_get_id( const WCHAR *device_name, ULONG_PTR *id )
     /* RandR 1.0 only supports changing the primary adapter settings.
      * For non-primary adapters, an id is still provided but getting
      * and changing non-primary adapters' settings will be ignored. */
-    *id = !wcsicmp( device_name, primary_adapter ) ? 1 : 0;
+    *id = !lstrcmpiW( device_name, primary_adapter ) ? 1 : 0;
     return TRUE;
 }
 
@@ -201,7 +199,7 @@ static BOOL xrandr10_get_modes( ULONG_PTR id, DWORD flags, DEVMODEW **new_modes,
 
     /* Allocate space for reported modes in three depths, and put an SizeID at the end of DEVMODEW as
      * driver private data */
-    modes = calloc( mode_count * DEPTH_COUNT, sizeof(*modes) + sizeof(SizeID) );
+    modes = heap_calloc( mode_count * DEPTH_COUNT, sizeof(*modes) + sizeof(SizeID) );
     if (!modes)
     {
         SetLastError( ERROR_NOT_ENOUGH_MEMORY );
@@ -237,7 +235,7 @@ static BOOL xrandr10_get_modes( ULONG_PTR id, DWORD flags, DEVMODEW **new_modes,
 
 static void xrandr10_free_modes( DEVMODEW *modes )
 {
-    free( modes );
+    heap_free( modes );
 }
 
 static BOOL xrandr10_get_current_mode( ULONG_PTR id, DEVMODEW *mode )
@@ -336,15 +334,22 @@ static struct current_mode
 } *current_modes;
 static int current_mode_count;
 
-static pthread_mutex_t xrandr_mutex = PTHREAD_MUTEX_INITIALIZER;
+static CRITICAL_SECTION current_modes_section;
+static CRITICAL_SECTION_DEBUG current_modes_critsect_debug =
+{
+    0, 0, &current_modes_section,
+    {&current_modes_critsect_debug.ProcessLocksList, &current_modes_critsect_debug.ProcessLocksList},
+     0, 0, {(DWORD_PTR)(__FILE__ ": current_modes_section")}
+};
+static CRITICAL_SECTION current_modes_section = {&current_modes_critsect_debug, -1, 0, 0, 0, 0};
 
 static void xrandr14_invalidate_current_mode_cache(void)
 {
-    pthread_mutex_lock( &xrandr_mutex );
-    free( current_modes);
+    EnterCriticalSection( &current_modes_section );
+    heap_free( current_modes);
     current_modes = NULL;
     current_mode_count = 0;
-    pthread_mutex_unlock( &xrandr_mutex );
+    LeaveCriticalSection( &current_modes_section );
 }
 
 static XRRScreenResources *xrandr_get_screen_resources(void)
@@ -633,8 +638,7 @@ static BOOL is_crtc_primary( RECT primary, const XRRCrtcInfo *crtc )
 
 VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDisplayKHR)
 
-static BOOL get_gpu_properties_from_vulkan( struct gdi_gpu *gpu, const XRRProviderInfo *provider_info,
-                                            struct gdi_gpu *prev_gpus, int prev_gpu_count )
+static BOOL get_gpu_properties_from_vulkan( struct gdi_gpu *gpu, const XRRProviderInfo *provider_info )
 {
     static const char *extensions[] =
     {
@@ -649,14 +653,13 @@ static BOOL get_gpu_properties_from_vulkan( struct gdi_gpu *gpu, const XRRProvid
     VkResult (*pvkGetRandROutputDisplayEXT)( VkPhysicalDevice, Display *, RROutput, VkDisplayKHR * );
     PFN_vkGetPhysicalDeviceProperties2KHR pvkGetPhysicalDeviceProperties2KHR;
     PFN_vkEnumeratePhysicalDevices pvkEnumeratePhysicalDevices;
-    uint32_t device_count, device_idx, output_idx, i;
+    uint32_t device_count, device_idx, output_idx;
     VkPhysicalDevice *vk_physical_devices = NULL;
     VkPhysicalDeviceProperties2 properties2;
     VkInstanceCreateInfo create_info;
     VkPhysicalDeviceIDProperties id;
     VkInstance vk_instance = NULL;
     VkDisplayKHR vk_display;
-    DWORD len;
     BOOL ret = FALSE;
     VkResult vr;
 
@@ -694,7 +697,7 @@ static BOOL get_gpu_properties_from_vulkan( struct gdi_gpu *gpu, const XRRProvid
         goto done;
     }
 
-    if (!(vk_physical_devices = calloc( device_count, sizeof(*vk_physical_devices) )))
+    if (!(vk_physical_devices = heap_calloc( device_count, sizeof(*vk_physical_devices) )))
         goto done;
 
     vr = pvkEnumeratePhysicalDevices( vk_instance, &device_count, vk_physical_devices );
@@ -704,8 +707,6 @@ static BOOL get_gpu_properties_from_vulkan( struct gdi_gpu *gpu, const XRRProvid
         goto done;
     }
 
-    TRACE("provider name %s.\n", debugstr_a(provider_info->name));
-
     for (device_idx = 0; device_idx < device_count; ++device_idx)
     {
         for (output_idx = 0; output_idx < provider_info->noutputs; ++output_idx)
@@ -723,34 +724,21 @@ static BOOL get_gpu_properties_from_vulkan( struct gdi_gpu *gpu, const XRRProvid
             properties2.pNext = &id;
 
             pvkGetPhysicalDeviceProperties2KHR( vk_physical_devices[device_idx], &properties2 );
-            for (i = 0; i < prev_gpu_count; ++i)
-            {
-                if (!memcmp( &prev_gpus[i].vulkan_uuid, &id.deviceUUID, sizeof(id.deviceUUID) ))
-                {
-                    WARN( "device UUID %#x:%#x already assigned to GPU %u.\n", *((uint32_t *)id.deviceUUID + 1),
-                          *(uint32_t *)id.deviceUUID, i );
-                    break;
-                }
-            }
-            if (i < prev_gpu_count) continue;
-
             memcpy( &gpu->vulkan_uuid, id.deviceUUID, sizeof(id.deviceUUID) );
-
             /* Ignore Khronos vendor IDs */
             if (properties2.properties.vendorID < 0x10000)
             {
                 gpu->vendor_id = properties2.properties.vendorID;
                 gpu->device_id = properties2.properties.deviceID;
             }
-            RtlUTF8ToUnicodeN( gpu->name, sizeof(gpu->name), &len, properties2.properties.deviceName,
-                               strlen( properties2.properties.deviceName ) + 1 );
+            MultiByteToWideChar( CP_UTF8, 0, properties2.properties.deviceName, -1, gpu->name, ARRAY_SIZE(gpu->name) );
             ret = TRUE;
             goto done;
         }
     }
 
 done:
-    free( vk_physical_devices );
+    heap_free( vk_physical_devices );
     if (vk_instance)
         vulkan_funcs->p_vkDestroyInstance( vk_instance, NULL );
     return ret;
@@ -769,7 +757,6 @@ static BOOL xrandr14_get_gpus2( struct gdi_gpu **new_gpus, int *count, BOOL get_
     INT primary_provider = -1;
     RECT primary_rect;
     BOOL ret = FALSE;
-    DWORD len;
     INT i, j;
 
     screen_resources = xrandr_get_screen_resources();
@@ -780,7 +767,7 @@ static BOOL xrandr14_get_gpus2( struct gdi_gpu **new_gpus, int *count, BOOL get_
     if (!provider_resources)
         goto done;
 
-    gpus = calloc( provider_resources->nproviders ? provider_resources->nproviders : 1, sizeof(*gpus) );
+    gpus = heap_calloc( provider_resources->nproviders ? provider_resources->nproviders : 1, sizeof(*gpus) );
     if (!gpus)
         goto done;
 
@@ -823,9 +810,8 @@ static BOOL xrandr14_get_gpus2( struct gdi_gpu **new_gpus, int *count, BOOL get_
         gpus[i].id = provider_resources->providers[i];
         if (get_properties)
         {
-            if (!get_gpu_properties_from_vulkan( &gpus[i], provider_info, gpus, i ))
-                RtlUTF8ToUnicodeN( gpus[i].name, sizeof(gpus[i].name), &len, provider_info->name,
-                                   strlen( provider_info->name ) + 1 );
+            if (!get_gpu_properties_from_vulkan( &gpus[i], provider_info ))
+                MultiByteToWideChar( CP_UTF8, 0, provider_info->name, -1, gpus[i].name, ARRAY_SIZE(gpus[i].name) );
             /* FIXME: Add an alternate method of getting PCI IDs, for systems that don't support Vulkan */
         }
         pXRRFreeProviderInfo( provider_info );
@@ -849,7 +835,7 @@ done:
         pXRRFreeScreenResources( screen_resources );
     if (!ret)
     {
-        free( gpus );
+        heap_free( gpus );
         ERR("Failed to get gpus\n");
     }
     return ret;
@@ -862,7 +848,7 @@ static BOOL xrandr14_get_gpus( struct gdi_gpu **new_gpus, int *count )
 
 static void xrandr14_free_gpus( struct gdi_gpu *gpus )
 {
-    free( gpus );
+    heap_free( gpus );
 }
 
 static BOOL xrandr14_get_adapters( ULONG_PTR gpu_id, struct gdi_adapter **new_adapters, int *count )
@@ -904,7 +890,7 @@ static BOOL xrandr14_get_adapters( ULONG_PTR gpu_id, struct gdi_adapter **new_ad
     }
 
     /* Actual adapter count could be less */
-    adapters = calloc( crtc_count, sizeof(*adapters) );
+    adapters = heap_calloc( crtc_count, sizeof(*adapters) );
     if (!adapters)
         goto done;
 
@@ -1020,7 +1006,7 @@ done:
         pXRRFreeCrtcInfo( crtc_info );
     if (!ret)
     {
-        free( adapters );
+        heap_free( adapters );
         ERR("Failed to get adapters\n");
     }
     return ret;
@@ -1028,7 +1014,7 @@ done:
 
 static void xrandr14_free_adapters( struct gdi_adapter *adapters )
 {
-    free( adapters );
+    heap_free( adapters );
 }
 
 static BOOL xrandr14_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **new_monitors, int *count )
@@ -1051,7 +1037,7 @@ static BOOL xrandr14_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **ne
 
     /* First start with a 2 monitors, should be enough for most cases */
     capacity = 2;
-    monitors = calloc( capacity, sizeof(*monitors) );
+    monitors = heap_calloc( capacity, sizeof(*monitors) );
     if (!monitors)
         goto done;
 
@@ -1097,7 +1083,7 @@ static BOOL xrandr14_get_monitors( ULONG_PTR adapter_id, struct gdi_monitor **ne
             if (monitor_count >= capacity)
             {
                 capacity *= 2;
-                realloc_monitors = realloc( monitors, capacity * sizeof(*monitors) );
+                realloc_monitors = heap_realloc( monitors, capacity * sizeof(*monitors) );
                 if (!realloc_monitors)
                     goto done;
                 monitors = realloc_monitors;
@@ -1175,7 +1161,7 @@ done:
             if (monitors[i].edid)
                 XFree( monitors[i].edid );
         }
-        free( monitors );
+        heap_free( monitors );
         ERR("Failed to get monitors\n");
     }
     return ret;
@@ -1190,13 +1176,13 @@ static void xrandr14_free_monitors( struct gdi_monitor *monitors, int count )
         if (monitors[i].edid)
             XFree( monitors[i].edid );
     }
-    free( monitors );
+    heap_free( monitors );
 }
 
 static BOOL xrandr14_device_change_handler( HWND hwnd, XEvent *event )
 {
     xrandr14_invalidate_current_mode_cache();
-    if (hwnd == NtUserGetDesktopWindow() && NtUserGetWindowThread( hwnd, NULL ) == GetCurrentThreadId())
+    if (hwnd == GetDesktopWindow() && GetWindowThreadProcessId( hwnd, NULL ) == GetCurrentThreadId())
     {
         /* Don't send a WM_DISPLAYCHANGE message here because this event may be a result from
          * ChangeDisplaySettings(). Otherwise, ChangeDisplaySettings() would send multiple
@@ -1237,17 +1223,17 @@ static BOOL xrandr14_get_id( const WCHAR *device_name, ULONG_PTR *id )
     WCHAR *end;
 
     /* Parse \\.\DISPLAY%d */
-    display_idx = wcstol( device_name + 11, &end, 10 ) - 1;
+    display_idx = strtolW( device_name + 11, &end, 10 ) - 1;
     if (*end)
         return FALSE;
 
     /* Update cache */
-    pthread_mutex_lock( &xrandr_mutex );
+    EnterCriticalSection( &current_modes_section );
     if (!current_modes)
     {
         if (!xrandr14_get_gpus2( &gpus, &gpu_count, FALSE ))
         {
-            pthread_mutex_unlock( &xrandr_mutex );
+            LeaveCriticalSection( &current_modes_section );
             return FALSE;
         }
 
@@ -1256,7 +1242,11 @@ static BOOL xrandr14_get_id( const WCHAR *device_name, ULONG_PTR *id )
             if (!xrandr14_get_adapters( gpus[gpu_idx].id, &adapters, &adapter_count ))
                 break;
 
-            tmp_modes = realloc( new_current_modes, (new_current_mode_count + adapter_count) * sizeof(*tmp_modes) );
+            if (!new_current_modes)
+                tmp_modes = heap_alloc( adapter_count * sizeof(*tmp_modes) );
+            else
+                tmp_modes = heap_realloc( new_current_modes, (new_current_mode_count + adapter_count) * sizeof(*tmp_modes) );
+
             if (!tmp_modes)
             {
                 xrandr14_free_adapters( adapters );
@@ -1276,7 +1266,7 @@ static BOOL xrandr14_get_id( const WCHAR *device_name, ULONG_PTR *id )
 
         if (new_current_modes)
         {
-            free( current_modes );
+            heap_free( current_modes );
             current_modes = new_current_modes;
             current_mode_count = new_current_mode_count;
         }
@@ -1284,12 +1274,12 @@ static BOOL xrandr14_get_id( const WCHAR *device_name, ULONG_PTR *id )
 
     if (display_idx >= current_mode_count)
     {
-        pthread_mutex_unlock( &xrandr_mutex );
+        LeaveCriticalSection( &current_modes_section );
         return FALSE;
     }
 
     *id = current_modes[display_idx].id;
-    pthread_mutex_unlock( &xrandr_mutex );
+    LeaveCriticalSection( &current_modes_section );
     return TRUE;
 }
 
@@ -1388,8 +1378,8 @@ static BOOL xrandr14_get_modes( ULONG_PTR id, DWORD flags, DEVMODEW **new_modes,
 
     /* Allocate space for display modes in different color depths and orientations.
      * Store a RRMode at the end of each DEVMODEW as private driver data */
-    modes = calloc( output_info->nmode * DEPTH_COUNT * orientation_count,
-                    sizeof(*modes) + sizeof(RRMode) );
+    modes = heap_calloc( output_info->nmode * DEPTH_COUNT * orientation_count,
+                         sizeof(*modes) + sizeof(RRMode) );
     if (!modes)
         goto done;
 
@@ -1435,7 +1425,7 @@ done:
 
 static void xrandr14_free_modes( DEVMODEW *modes )
 {
-    free( modes );
+    heap_free( modes );
 }
 
 static BOOL xrandr14_get_current_mode( ULONG_PTR id, DEVMODEW *mode )
@@ -1450,7 +1440,7 @@ static BOOL xrandr14_get_current_mode( ULONG_PTR id, DEVMODEW *mode )
     RECT primary;
     INT mode_idx;
 
-    pthread_mutex_lock( &xrandr_mutex );
+    EnterCriticalSection( &current_modes_section );
     for (mode_idx = 0; mode_idx < current_mode_count; ++mode_idx)
     {
         if (current_modes[mode_idx].id != id)
@@ -1463,7 +1453,7 @@ static BOOL xrandr14_get_current_mode( ULONG_PTR id, DEVMODEW *mode )
         }
 
         memcpy( mode, &current_modes[mode_idx].mode, sizeof(*mode) );
-        pthread_mutex_unlock( &xrandr_mutex );
+        LeaveCriticalSection( &current_modes_section );
         return TRUE;
     }
 
@@ -1534,7 +1524,7 @@ done:
         mode_ptr->mode.dmDriverExtra = 0;
         mode_ptr->loaded = TRUE;
     }
-    pthread_mutex_unlock( &xrandr_mutex );
+    LeaveCriticalSection( &current_modes_section );
     if (crtc_info)
         pXRRFreeCrtcInfo( crtc_info );
     if (output_info)
diff --git a/dlls/winex11.drv/xrender.c b/dlls/winex11.drv/xrender.c
index 585299cba9e..5ede97fb026 100644
--- a/dlls/winex11.drv/xrender.c
+++ b/dlls/winex11.drv/xrender.c
@@ -23,10 +23,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <assert.h>
@@ -39,6 +35,7 @@
 #include "winbase.h"
 #include "x11drv.h"
 #include "winternl.h"
+#include "wine/unicode.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(xrender);
@@ -193,7 +190,14 @@ MAKE_FUNCPTR(XRenderQueryExtension)
 
 #undef MAKE_FUNCPTR
 
-static pthread_mutex_t xrender_mutex = PTHREAD_MUTEX_INITIALIZER;
+static CRITICAL_SECTION xrender_cs;
+static CRITICAL_SECTION_DEBUG critsect_debug =
+{
+    0, 0, &xrender_cs,
+    { &critsect_debug.ProcessLocksList, &critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": xrender_cs") }
+};
+static CRITICAL_SECTION xrender_cs = { &critsect_debug, -1, 0, 0, 0, 0 };
 
 #define MS_MAKE_TAG( _x1, _x2, _x3, _x4 ) \
           ( ( (ULONG)_x4 << 24 ) |     \
@@ -365,7 +369,8 @@ const struct gdi_dc_funcs *X11DRV_XRender_Init(void)
         return NULL;
     }
 
-    glyphsetCache = calloc( sizeof(*glyphsetCache), INIT_CACHE_SIZE );
+    glyphsetCache = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                              sizeof(*glyphsetCache) * INIT_CACHE_SIZE);
 
     glyphsetCacheSize = INIT_CACHE_SIZE;
     lastfree = 0;
@@ -383,11 +388,11 @@ static void get_xrender_color( struct xrender_physdev *physdev, COLORREF src_col
 {
     if (src_color & (1 << 24))  /* PALETTEINDEX */
     {
-        HPALETTE pal = NtGdiGetDCObject( physdev->dev.hdc, NTGDI_OBJ_PAL );
+        HPALETTE pal = GetCurrentObject( physdev->dev.hdc, OBJ_PAL );
         PALETTEENTRY pal_ent;
 
-        if (!get_palette_entries( pal, LOWORD(src_color), 1, &pal_ent ))
-            get_palette_entries( pal, 0, 1, &pal_ent );
+        if (!GetPaletteEntries( pal, LOWORD(src_color), 1, &pal_ent ))
+            GetPaletteEntries( pal, 0, 1, &pal_ent );
         dst_color->red   = pal_ent.peRed   * 257;
         dst_color->green = pal_ent.peGreen * 257;
         dst_color->blue  = pal_ent.peBlue  * 257;
@@ -473,7 +478,7 @@ static void update_xrender_clipping( struct xrender_physdev *dev, HRGN rgn )
         pXRenderSetPictureClipRectangles( gdi_display, dev->pict,
                                           dev->x11dev->dc_rect.left, dev->x11dev->dc_rect.top,
                                           (XRectangle *)data->Buffer, data->rdh.nCount );
-        free( data );
+        HeapFree( GetProcessHeap(), 0, data );
     }
 }
 
@@ -494,20 +499,20 @@ static Picture get_xrender_picture( struct xrender_physdev *dev, HRGN clip_rgn,
 
     if (clip_rect)
     {
-        HRGN rgn = NtGdiCreateRectRgn( clip_rect->left, clip_rect->top, clip_rect->right, clip_rect->bottom );
-        if (clip_rgn) NtGdiCombineRgn( rgn, rgn, clip_rgn, RGN_AND );
-        if (dev->region) NtGdiCombineRgn( rgn, rgn, dev->region, RGN_AND );
+        HRGN rgn = CreateRectRgnIndirect( clip_rect );
+        if (clip_rgn) CombineRgn( rgn, rgn, clip_rgn, RGN_AND );
+        if (dev->region) CombineRgn( rgn, rgn, dev->region, RGN_AND );
         update_xrender_clipping( dev, rgn );
-        NtGdiDeleteObjectApp( rgn );
+        DeleteObject( rgn );
     }
     else if (clip_rgn)
     {
         if (dev->region)
         {
-            HRGN rgn = NtGdiCreateRectRgn( 0, 0, 0, 0 );
-            NtGdiCombineRgn( rgn, clip_rgn, dev->region, RGN_AND );
+            HRGN rgn = CreateRectRgn( 0, 0, 0, 0 );
+            CombineRgn( rgn, clip_rgn, dev->region, RGN_AND );
             update_xrender_clipping( dev, rgn );
-            NtGdiDeleteObjectApp( rgn );
+            DeleteObject( rgn );
         }
         else update_xrender_clipping( dev, clip_rgn );
     }
@@ -561,7 +566,7 @@ static Picture get_no_alpha_mask(void)
     static Pixmap pixmap;
     static Picture pict;
 
-    pthread_mutex_lock( &xrender_mutex );
+    EnterCriticalSection( &xrender_cs );
     if (!pict)
     {
         XRenderPictureAttributes pa;
@@ -576,7 +581,7 @@ static Picture get_no_alpha_mask(void)
         col.alpha = 0;
         pXRenderFillRectangle( gdi_display, PictOpSrc, pict, &col, 0, 0, 1, 1 );
     }
-    pthread_mutex_unlock( &xrender_mutex );
+    LeaveCriticalSection( &xrender_cs );
     return pict;
 }
 
@@ -586,7 +591,7 @@ static BOOL fontcmp(LFANDSIZE *p1, LFANDSIZE *p2)
   if(memcmp(&p1->devsize, &p2->devsize, sizeof(p1->devsize))) return TRUE;
   if(memcmp(&p1->xform, &p2->xform, sizeof(p1->xform))) return TRUE;
   if(memcmp(&p1->lf, &p2->lf, offsetof(LOGFONTW, lfFaceName))) return TRUE;
-  return wcsicmp( p1->lf.lfFaceName, p2->lf.lfFaceName );
+  return strcmpiW(p1->lf.lfFaceName, p2->lf.lfFaceName);
 }
 
 static int LookupEntry(LFANDSIZE *plfsz)
@@ -632,14 +637,14 @@ static void FreeEntry(int entry)
                 formatEntry->glyphset = 0;
             }
             if(formatEntry->nrealized) {
-                free( formatEntry->realized );
+                HeapFree(GetProcessHeap(), 0, formatEntry->realized);
                 formatEntry->realized = NULL;
-                free( formatEntry->gis );
+                HeapFree(GetProcessHeap(), 0, formatEntry->gis);
                 formatEntry->gis = NULL;
                 formatEntry->nrealized = 0;
             }
 
-            free( formatEntry );
+            HeapFree(GetProcessHeap(), 0, formatEntry);
             glyphsetCache[entry].format[type][format] = NULL;
         }
     }
@@ -686,12 +691,18 @@ static int AllocEntry(void)
 
   TRACE("Growing cache\n");
   
-  glyphsetCache = realloc( glyphsetCache,
-                           (glyphsetCacheSize + INIT_CACHE_SIZE) * sizeof(*glyphsetCache) );
-
-  for (best = i = glyphsetCacheSize; i < glyphsetCacheSize + INIT_CACHE_SIZE; i++)
-  {
-    memset( &glyphsetCache[i], 0, sizeof(glyphsetCache[i]) );
+  if (glyphsetCache)
+    glyphsetCache = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+			      glyphsetCache,
+			      (glyphsetCacheSize + INIT_CACHE_SIZE)
+			      * sizeof(*glyphsetCache));
+  else
+    glyphsetCache = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+			      (glyphsetCacheSize + INIT_CACHE_SIZE)
+			      * sizeof(*glyphsetCache));
+
+  for(best = i = glyphsetCacheSize; i < glyphsetCacheSize + INIT_CACHE_SIZE;
+      i++) {
     glyphsetCache[i].next = i + 1;
     glyphsetCache[i].count = -1;
   }
@@ -743,9 +754,9 @@ static void lfsz_calc_hash(LFANDSIZE *plfsz)
     two_chars = *ptr;
     pwc = (WCHAR *)&two_chars;
     if(!*pwc) break;
-    *pwc = RtlUpcaseUnicodeChar( *pwc );
+    *pwc = toupperW(*pwc);
     pwc++;
-    *pwc = RtlUpcaseUnicodeChar( *pwc );
+    *pwc = toupperW(*pwc);
     hash ^= two_chars;
     if(!*pwc) break;
   }
@@ -777,7 +788,7 @@ static AA_Type aa_type_from_flags( UINT aa_flags )
 
 static UINT get_xft_aa_flags( const LOGFONTW *lf )
 {
-    char *value, *p;
+    char *value;
     UINT ret = 0;
 
     switch (lf->lfQuality)
@@ -788,8 +799,8 @@ static UINT get_xft_aa_flags( const LOGFONTW *lf )
     default:
         if (!(value = XGetDefault( gdi_display, "Xft", "antialias" ))) break;
         TRACE( "got antialias '%s'\n", value );
-        for (p = value; *p; p++) if ('A' <= *p && *p <= 'Z') *p += 'a' - 'A'; /* to lower */
-        if (value[0] == 'f' || value[0] == 'n' || value[0] == '0' || !strcmp( value, "off" ))
+        if (tolower(value[0]) == 'f' || tolower(value[0]) == 'n' ||
+            value[0] == '0' || !_strnicmp( value, "off", -1 ))
         {
             ret = GGO_BITMAP;
             break;
@@ -818,10 +829,9 @@ static HFONT CDECL xrenderdrv_SelectFont( PHYSDEV dev, HFONT hfont, UINT *aa_fla
     LFANDSIZE lfsz;
     struct xrender_physdev *physdev = get_xrender_dev( dev );
     PHYSDEV next = GET_NEXT_PHYSDEV( dev, pSelectFont );
-    DWORD mode;
     HFONT ret;
 
-    NtGdiExtGetObjectW( hfont, sizeof(lfsz.lf), &lfsz.lf );
+    GetObjectW( hfont, sizeof(lfsz.lf), &lfsz.lf );
     if (!*aa_flags) *aa_flags = get_xft_aa_flags( &lfsz.lf );
 
     ret = next->funcs->pSelectFont( next, hfont, aa_flags );
@@ -849,12 +859,11 @@ static HFONT CDECL xrenderdrv_SelectFont( PHYSDEV dev, HFONT hfont, UINT *aa_fla
     lfsz.devsize.cx = X11DRV_XWStoDS( dev->hdc, lfsz.lf.lfWidth );
     lfsz.devsize.cy = X11DRV_YWStoDS( dev->hdc, lfsz.lf.lfHeight );
 
-    NtGdiGetTransform( dev->hdc, 0x204, &lfsz.xform );
+    GetTransform( dev->hdc, 0x204, &lfsz.xform );
     TRACE("font transform %f %f %f %f\n", lfsz.xform.eM11, lfsz.xform.eM12,
           lfsz.xform.eM21, lfsz.xform.eM22);
 
-    NtGdiGetDCDword( dev->hdc, NtGdiGetGraphicsMode, &mode );
-    if (mode == GM_COMPATIBLE)
+    if (GetGraphicsMode( dev->hdc ) == GM_COMPATIBLE)
     {
         lfsz.lf.lfOrientation = lfsz.lf.lfEscapement;
         if (lfsz.xform.eM11 * lfsz.xform.eM22 < 0)
@@ -866,11 +875,11 @@ static HFONT CDECL xrenderdrv_SelectFont( PHYSDEV dev, HFONT hfont, UINT *aa_fla
 
     lfsz_calc_hash(&lfsz);
 
-    pthread_mutex_lock( &xrender_mutex );
+    EnterCriticalSection(&xrender_cs);
     if (physdev->cache_index != -1)
         dec_ref_cache( physdev->cache_index );
     physdev->cache_index = GetCacheEntry( &lfsz );
-    pthread_mutex_unlock( &xrender_mutex );
+    LeaveCriticalSection(&xrender_cs);
     return ret;
 }
 
@@ -887,7 +896,7 @@ static void set_physdev_format( struct xrender_physdev *physdev, enum wxr_format
 static BOOL create_xrender_dc( PHYSDEV *pdev, enum wxr_format format )
 {
     X11DRV_PDEVICE *x11dev = get_x11drv_dev( *pdev );
-    struct xrender_physdev *physdev = calloc( 1, sizeof(*physdev) );
+    struct xrender_physdev *physdev = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*physdev) );
 
     if (!physdev) return FALSE;
     physdev->x11dev = x11dev;
@@ -959,11 +968,11 @@ static BOOL CDECL xrenderdrv_DeleteDC( PHYSDEV dev )
 
     free_xrender_picture( physdev );
 
-    pthread_mutex_lock( &xrender_mutex );
+    EnterCriticalSection( &xrender_cs );
     if (physdev->cache_index != -1) dec_ref_cache( physdev->cache_index );
-    pthread_mutex_unlock( &xrender_mutex );
+    LeaveCriticalSection( &xrender_cs );
 
-    free( physdev );
+    HeapFree( GetProcessHeap(), 0, physdev );
     return TRUE;
 }
 
@@ -1011,7 +1020,7 @@ static void CDECL xrenderdrv_SetDeviceClipping( PHYSDEV dev, HRGN rgn )
 /************************************************************************
  *   UploadGlyph
  *
- * Helper to ExtTextOut.  Must be called inside xrender_mutex
+ * Helper to ExtTextOut.  Must be called inside xrender_cs
  */
 static void UploadGlyph(struct xrender_physdev *physDev, UINT glyph, enum glyph_type type)
 {
@@ -1029,23 +1038,20 @@ static void UploadGlyph(struct xrender_physdev *physDev, UINT glyph, enum glyph_
     static const MAT2 identity = { {0,1},{0,0},{0,0},{0,1} };
 
     if (type == GLYPH_INDEX) ggo_format |= GGO_GLYPH_INDEX;
-    buflen = NtGdiGetGlyphOutline( physDev->dev.hdc, glyph, ggo_format, &gm, 0, NULL, &identity, FALSE );
+    buflen = GetGlyphOutlineW(physDev->dev.hdc, glyph, ggo_format, &gm, 0, NULL, &identity);
     if(buflen == GDI_ERROR) {
         if(format != AA_None) {
             format = AA_None;
             physDev->aa_flags = GGO_BITMAP;
             ggo_format = (ggo_format & GGO_GLYPH_INDEX) | GGO_BITMAP;
-            buflen = NtGdiGetGlyphOutline( physDev->dev.hdc, glyph, ggo_format, &gm, 0, NULL,
-                                           &identity, FALSE);
+            buflen = GetGlyphOutlineW(physDev->dev.hdc, glyph, ggo_format, &gm, 0, NULL, &identity);
         }
         if(buflen == GDI_ERROR) {
             WARN("GetGlyphOutlineW failed using default glyph\n");
-            buflen = NtGdiGetGlyphOutline( physDev->dev.hdc, 0, ggo_format, &gm, 0, NULL,
-                                           &identity, FALSE );
+            buflen = GetGlyphOutlineW(physDev->dev.hdc, 0, ggo_format, &gm, 0, NULL, &identity);
             if(buflen == GDI_ERROR) {
                 WARN("GetGlyphOutlineW failed for default glyph trying for space\n");
-                buflen = NtGdiGetGlyphOutline( physDev->dev.hdc, 0x20, ggo_format, &gm, 0, NULL,
-                                               &identity, FALSE );
+                buflen = GetGlyphOutlineW(physDev->dev.hdc, 0x20, ggo_format, &gm, 0, NULL, &identity);
                 if(buflen == GDI_ERROR) {
                     ERR("GetGlyphOutlineW for all attempts unable to upload a glyph\n");
                     return;
@@ -1057,22 +1063,34 @@ static void UploadGlyph(struct xrender_physdev *physDev, UINT glyph, enum glyph_
 
     /* If there is nothing for the current type, we create the entry. */
     if( !entry->format[type][format] ) {
-        entry->format[type][format] = calloc( 1, sizeof(gsCacheEntryFormat) );
+        entry->format[type][format] = HeapAlloc(GetProcessHeap(),
+                                          HEAP_ZERO_MEMORY,
+                                          sizeof(gsCacheEntryFormat));
     }
     formatEntry = entry->format[type][format];
 
     if(formatEntry->nrealized <= glyph) {
-        size_t new_size = (glyph / 128 + 1) * 128;
-
-        formatEntry->realized = realloc( formatEntry->realized, new_size * sizeof(BOOL) );
-        memset( formatEntry->realized + formatEntry->nrealized, 0,
-                (new_size - formatEntry->nrealized) * sizeof(BOOL) );
-
-        formatEntry->gis = realloc( formatEntry->gis, new_size * sizeof(formatEntry->gis[0]) );
-        memset( formatEntry->gis + formatEntry->nrealized, 0,
-                (new_size - formatEntry->nrealized) * sizeof(formatEntry->gis[0]) );
-
-        formatEntry->nrealized = new_size;
+        formatEntry->nrealized = (glyph / 128 + 1) * 128;
+
+	if (formatEntry->realized)
+	    formatEntry->realized = HeapReAlloc(GetProcessHeap(),
+				      HEAP_ZERO_MEMORY,
+				      formatEntry->realized,
+				      formatEntry->nrealized * sizeof(BOOL));
+	else
+	    formatEntry->realized = HeapAlloc(GetProcessHeap(),
+				      HEAP_ZERO_MEMORY,
+				      formatEntry->nrealized * sizeof(BOOL));
+
+        if (formatEntry->gis)
+	    formatEntry->gis = HeapReAlloc(GetProcessHeap(),
+				   HEAP_ZERO_MEMORY,
+				   formatEntry->gis,
+				   formatEntry->nrealized * sizeof(formatEntry->gis[0]));
+        else
+	    formatEntry->gis = HeapAlloc(GetProcessHeap(),
+				   HEAP_ZERO_MEMORY,
+                                   formatEntry->nrealized * sizeof(formatEntry->gis[0]));
     }
 
 
@@ -1102,9 +1120,9 @@ static void UploadGlyph(struct xrender_physdev *physDev, UINT glyph, enum glyph_
     }
 
 
-    buf = calloc( 1, buflen );
+    buf = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buflen);
     if (buflen)
-        NtGdiGetGlyphOutline( physDev->dev.hdc, glyph, ggo_format, &gm, buflen, buf, &identity, FALSE );
+        GetGlyphOutlineW(physDev->dev.hdc, glyph, ggo_format, &gm, buflen, buf, &identity);
     else
         gm.gmBlackBoxX = gm.gmBlackBoxY = 0;  /* empty glyph */
     formatEntry->realized[glyph] = TRUE;
@@ -1193,7 +1211,7 @@ static void UploadGlyph(struct xrender_physdev *physDev, UINT glyph, enum glyph_
                           buflen ? buf : zero, buflen ? buflen : sizeof(zero));
     }
 
-    free( buf );
+    HeapFree(GetProcessHeap(), 0, buf);
     formatEntry->gis[glyph] = gi;
 }
 
@@ -1201,7 +1219,7 @@ static void UploadGlyph(struct xrender_physdev *physDev, UINT glyph, enum glyph_
  *                 get_tile_pict
  *
  * Returns an appropriate Picture for tiling the text colour.
- * Call and use result within the xrender_mutex
+ * Call and use result within the xrender_cs
  */
 static Picture get_tile_pict( enum wxr_format wxr_format, const XRenderColor *color)
 {
@@ -1250,7 +1268,7 @@ static Picture get_tile_pict( enum wxr_format wxr_format, const XRenderColor *co
  *                 get_mask_pict
  *
  * Returns an appropriate Picture for masking with the specified alpha.
- * Call and use result within the xrender_mutex
+ * Call and use result within the xrender_cs
  */
 static Picture get_mask_pict( int alpha )
 {
@@ -1291,7 +1309,6 @@ static BOOL CDECL xrenderdrv_ExtTextOut( PHYSDEV dev, INT x, INT y, UINT flags,
     gsCacheEntry *entry;
     gsCacheEntryFormat *formatEntry;
     unsigned int idx;
-    DWORD text_color;
     Picture pict, tile_pict = 0;
     XGlyphElt16 *elts;
     POINT offset, desired, current;
@@ -1300,8 +1317,7 @@ static BOOL CDECL xrenderdrv_ExtTextOut( PHYSDEV dev, INT x, INT y, UINT flags,
     RECT rect, bounds;
     enum glyph_type type = (flags & ETO_GLYPH_INDEX) ? GLYPH_INDEX : GLYPH_WCHAR;
 
-    NtGdiGetDCDword( physdev->dev.hdc, NtGdiGetTextColor, &text_color );
-    get_xrender_color( physdev, text_color, &col );
+    get_xrender_color( physdev, GetTextColor( physdev->dev.hdc ), &col );
     pict = get_xrender_picture( physdev, 0, (flags & ETO_CLIPPED) ? lprect : NULL );
 
     if(flags & ETO_OPAQUE)
@@ -1312,11 +1328,7 @@ static BOOL CDECL xrenderdrv_ExtTextOut( PHYSDEV dev, INT x, INT y, UINT flags,
             /* use the inverse of the text color */
             bg.red = bg.green = bg.blue = bg.alpha = ~col.alpha;
         else
-        {
-            DWORD bg_color;
-            NtGdiGetDCDword( physdev->dev.hdc, NtGdiGetBkColor, &bg_color );
-            get_xrender_color( physdev, bg_color, &bg );
-        }
+            get_xrender_color( physdev, GetBkColor( physdev->dev.hdc ), &bg );
 
         set_xrender_transformation( pict, 1, 1, 0, 0 );
         pXRenderFillRectangle( gdi_display, PictOpSrc, pict, &bg,
@@ -1329,7 +1341,7 @@ static BOOL CDECL xrenderdrv_ExtTextOut( PHYSDEV dev, INT x, INT y, UINT flags,
 
     if(count == 0) return TRUE;
 
-    pthread_mutex_lock( &xrender_mutex );
+    EnterCriticalSection(&xrender_cs);
 
     entry = glyphsetCache + physdev->cache_index;
     formatEntry = entry->format[type][aa_type_from_flags( physdev->aa_flags )];
@@ -1346,14 +1358,14 @@ static BOOL CDECL xrenderdrv_ExtTextOut( PHYSDEV dev, INT x, INT y, UINT flags,
     if (!formatEntry)
     {
         WARN("could not upload requested glyphs\n");
-        pthread_mutex_unlock( &xrender_mutex );
+        LeaveCriticalSection(&xrender_cs);
         return FALSE;
     }
 
     TRACE("Writing %s at %d,%d\n", debugstr_wn(wstr,count),
           physdev->x11dev->dc_rect.left + x, physdev->x11dev->dc_rect.top + y);
 
-    elts = malloc( sizeof(XGlyphElt16) * count );
+    elts = HeapAlloc(GetProcessHeap(), 0, sizeof(XGlyphElt16) * count);
 
     /* There's a bug in XRenderCompositeText that ignores the xDst and yDst parameters.
        So we pass zeros to the function and move to our starting position using the first
@@ -1415,9 +1427,9 @@ static BOOL CDECL xrenderdrv_ExtTextOut( PHYSDEV dev, INT x, INT y, UINT flags,
                             pict,
                             formatEntry->font_format,
                             0, 0, 0, 0, elts, count);
-    free( elts );
+    HeapFree(GetProcessHeap(), 0, elts);
 
-    pthread_mutex_unlock( &xrender_mutex );
+    LeaveCriticalSection(&xrender_cs);
     add_device_bounds( physdev->x11dev, &bounds );
     return TRUE;
 }
@@ -1534,7 +1546,7 @@ static void xrender_mono_blit( Picture src_pict, Picture dst_pict,
      * contains a 1x1 picture for tiling. The source data effectively acts as an alpha channel to
      * the tile data.
      */
-    pthread_mutex_lock( &xrender_mutex );
+    EnterCriticalSection( &xrender_cs );
     color = *bg;
     color.alpha = 0xffff;  /* tile pict needs 100% alpha */
     tile_pict = get_tile_pict( dst_format, &color );
@@ -1558,7 +1570,7 @@ static void xrender_mono_blit( Picture src_pict, Picture dst_pict,
     }
     pXRenderComposite(gdi_display, PictOpOver, tile_pict, src_pict, dst_pict,
                       0, 0, x_offset, y_offset, x_dst, y_dst, width_dst, height_dst );
-    pthread_mutex_unlock( &xrender_mutex );
+    LeaveCriticalSection( &xrender_cs );
 
     /* force the alpha channel for background pixels, it has been set to 100% by the tile */
     if (bg->alpha != 0xffff && (dst_format == WXR_FORMAT_A8R8G8B8 || dst_format == WXR_FORMAT_B8G8R8A8))
@@ -1636,13 +1648,10 @@ static void xrender_stretch_blit( struct xrender_physdev *physdev_src, struct xr
     /* mono -> color */
     if (physdev_src->format == WXR_FORMAT_MONO && physdev_dst->format != WXR_FORMAT_MONO)
     {
-        DWORD text_color, bg_color;
         XRenderColor fg, bg;
 
-        NtGdiGetDCDword( physdev_dst->dev.hdc, NtGdiGetTextColor, &text_color );
-        NtGdiGetDCDword( physdev_dst->dev.hdc, NtGdiGetBkColor, &bg_color );
-        get_xrender_color( physdev_dst, text_color, &fg );
-        get_xrender_color( physdev_dst, bg_color, &bg );
+        get_xrender_color( physdev_dst, GetTextColor( physdev_dst->dev.hdc ), &fg );
+        get_xrender_color( physdev_dst, GetBkColor( physdev_dst->dev.hdc ), &bg );
         fg.alpha = bg.alpha = 0;
 
         xrender_mono_blit( src_pict, dst_pict, physdev_dst->format, &fg, &bg,
@@ -1685,7 +1694,7 @@ static void xrender_put_image( Pixmap src_pixmap, Picture src_pict, Picture mask
         if (clip_data)
             pXRenderSetPictureClipRectangles( gdi_display, dst_pict, 0, 0,
                                               (XRectangle *)clip_data->Buffer, clip_data->rdh.nCount );
-        free( clip_data );
+        HeapFree( GetProcessHeap(), 0, clip_data );
     }
     else
     {
@@ -1896,7 +1905,7 @@ static DWORD CDECL xrenderdrv_BlendImage( PHYSDEV dev, BITMAPINFO *info, const s
 
         dst_pict = get_xrender_picture( physdev, 0, &dst->visrect );
 
-        pthread_mutex_lock( &xrender_mutex );
+        EnterCriticalSection( &xrender_cs );
         mask_pict = get_mask_pict( func.SourceConstantAlpha * 257 );
 
         xrender_blit( PictOpOver, src_pict, mask_pict, dst_pict,
@@ -1908,7 +1917,7 @@ static DWORD CDECL xrenderdrv_BlendImage( PHYSDEV dev, BITMAPINFO *info, const s
         pXRenderFreePicture( gdi_display, src_pict );
         XFreePixmap( gdi_display, src_pixmap );
 
-        pthread_mutex_unlock( &xrender_mutex );
+        LeaveCriticalSection( &xrender_cs );
         add_device_bounds( physdev->x11dev, &dst->visrect );
     }
     return ret;
@@ -1985,7 +1994,7 @@ static BOOL CDECL xrenderdrv_AlphaBlend( PHYSDEV dst_dev, struct bitblt_coords *
 
     if (tmp_pict) src_pict = tmp_pict;
 
-    pthread_mutex_lock( &xrender_mutex );
+    EnterCriticalSection( &xrender_cs );
     mask_pict = get_mask_pict( blendfn.SourceConstantAlpha * 257 );
 
     xrender_blit( PictOpOver, src_pict, mask_pict, dst_pict,
@@ -1999,7 +2008,7 @@ static BOOL CDECL xrenderdrv_AlphaBlend( PHYSDEV dst_dev, struct bitblt_coords *
     if (tmp_pict) pXRenderFreePicture( gdi_display, tmp_pict );
     if (tmp_pixmap) XFreePixmap( gdi_display, tmp_pixmap );
 
-    pthread_mutex_unlock( &xrender_mutex );
+    LeaveCriticalSection( &xrender_cs );
     add_device_bounds( physdev_dst->x11dev, &dst->visrect );
     return TRUE;
 }
@@ -2048,7 +2057,7 @@ static BOOL CDECL xrenderdrv_GradientFill( PHYSDEV dev, TRIVERTEX *vert_array, U
             pt[0].y = v1->y;
             pt[1].x = v2->x;
             pt[1].y = v2->y;
-            lp_to_dp( dev->hdc, pt, 2 );
+            LPtoDP( dev->hdc, pt, 2 );
             if (mode == GRADIENT_FILL_RECT_H)
             {
                 gradient.p1.y = gradient.p2.y = 0;
@@ -2236,9 +2245,6 @@ static const struct gdi_dc_funcs xrender_funcs =
     NULL,                               /* pStrokePath */
     NULL,                               /* pUnrealizePalette */
     NULL,                               /* pD3DKMTCheckVidPnExclusiveOwnership */
-    NULL,                               /* pD3DKMTCloseAdapter */
-    NULL,                               /* pD3DKMTOpenAdapterFromLuid */
-    NULL,                               /* pD3DKMTQueryVideoMemoryInfo */
     NULL,                               /* pD3DKMTSetVidPnSourceOwner */
     GDI_PRIORITY_GRAPHICS_DRV + 10      /* priority */
 };
diff --git a/dlls/winex11.drv/xvidmode.c b/dlls/winex11.drv/xvidmode.c
index 4ca7bc1ac59..d0be58342a5 100644
--- a/dlls/winex11.drv/xvidmode.c
+++ b/dlls/winex11.drv/xvidmode.c
@@ -19,10 +19,6 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#if 0
-#pragma makedep unix
-#endif
-
 #include "config.h"
 
 #include <assert.h>
@@ -46,6 +42,7 @@
 #include "windef.h"
 #include "wingdi.h"
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(xvidmode);
 
@@ -95,7 +92,7 @@ static BOOL xf86vm_get_id(const WCHAR *device_name, ULONG_PTR *id)
     /* XVidMode only supports changing the primary adapter settings.
      * For non-primary adapters, an id is still provided but getting
      * and changing non-primary adapters' settings will be ignored. */
-    *id = !wcsicmp( device_name, primary_adapter ) ? 1 : 0;
+    *id = !lstrcmpiW( device_name, primary_adapter ) ? 1 : 0;
     return TRUE;
 }
 
@@ -137,7 +134,7 @@ static BOOL xf86vm_get_modes(ULONG_PTR id, DWORD flags, DEVMODEW **new_modes, UI
     /* Display modes in different color depth, with a XF86VidModeModeInfo * at the end of each
      * DEVMODEW as driver private data */
     size += (xf86vm_mode_count * DEPTH_COUNT) * (sizeof(DEVMODEW) + sizeof(XF86VidModeModeInfo *));
-    ptr = calloc(1, size);
+    ptr = heap_alloc_zero(size);
     if (!ptr)
     {
         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
@@ -171,7 +168,7 @@ static void xf86vm_free_modes(DEVMODEW *modes)
         memcpy(&xf86vm_modes, (BYTE *)modes - sizeof(xf86vm_modes), sizeof(xf86vm_modes));
         XFree(xf86vm_modes);
     }
-    free(modes);
+    heap_free(modes);
 }
 
 static BOOL xf86vm_get_current_mode(ULONG_PTR id, DEVMODEW *mode)
@@ -457,7 +454,7 @@ static BOOL xf86vm_get_gamma_ramp(struct x11drv_gamma_ramp *ramp)
     }
     else
     {
-        if (!(red = calloc(xf86vm_gammaramp_size, 3 * sizeof(*red))))
+        if (!(red = heap_calloc(xf86vm_gammaramp_size, 3 * sizeof(*red))))
             return FALSE;
         green = red + xf86vm_gammaramp_size;
         blue = green + xf86vm_gammaramp_size;
@@ -469,7 +466,7 @@ static BOOL xf86vm_get_gamma_ramp(struct x11drv_gamma_ramp *ramp)
         interpolate_gamma_ramp(ramp->red, ramp->green, ramp->blue, GAMMA_RAMP_SIZE,
                                red, green, blue, xf86vm_gammaramp_size);
     if (red != ramp->red)
-        free(red);
+        heap_free(red);
     return ret;
 }
 
@@ -486,7 +483,7 @@ static BOOL xf86vm_set_gamma_ramp(struct x11drv_gamma_ramp *ramp)
     }
     else
     {
-        if (!(red = calloc(xf86vm_gammaramp_size, 3 * sizeof(*red))))
+        if (!(red = heap_calloc(xf86vm_gammaramp_size, 3 * sizeof(*red))))
             return FALSE;
         green = red + xf86vm_gammaramp_size;
         blue = green + xf86vm_gammaramp_size;
@@ -502,7 +499,7 @@ static BOOL xf86vm_set_gamma_ramp(struct x11drv_gamma_ramp *ramp)
     if (X11DRV_check_error()) ret = FALSE;
 
     if (red != ramp->red)
-        free(red);
+        heap_free(red);
     return ret;
 }
 #endif
diff --git a/dlls/wow64/process.c b/dlls/wow64/process.c
index 0c6726b9c6e..82ca4181116 100644
--- a/dlls/wow64/process.c
+++ b/dlls/wow64/process.c
@@ -1158,7 +1158,6 @@ NTSTATUS WINAPI wow64_NtSetInformationThread( UINT *args )
     case ThreadBasePriority:   /* ULONG */
     case ThreadHideFromDebugger:   /* void */
     case ThreadEnableAlignmentFaultFixup:   /* BOOLEAN */
-    case ThreadPowerThrottlingState:  /* THREAD_POWER_THROTTLING_STATE */
         return NtSetInformationThread( handle, class, ptr, len );
 
     case ThreadImpersonationToken:   /* HANDLE */
diff --git a/dlls/wow64win/gdi.c b/dlls/wow64win/gdi.c
index c821b90122e..ed85754640d 100644
--- a/dlls/wow64win/gdi.c
+++ b/dlls/wow64win/gdi.c
@@ -602,6 +602,13 @@ NTSTATUS WINAPI wow64_NtGdiFlush( UINT *args )
     return NtGdiFlush();
 }
 
+NTSTATUS WINAPI wow64_NtGdiDdDDICloseAdapter( UINT *args )
+{
+    const D3DKMT_CLOSEADAPTER *desc = get_ptr( &args );
+
+    return NtGdiDdDDICloseAdapter( desc );
+}
+
 NTSTATUS WINAPI wow64_NtGdiDdDDICreateDevice( UINT *args )
 {
     struct
@@ -637,6 +644,26 @@ NTSTATUS WINAPI wow64_NtGdiDdDDICreateDevice( UINT *args )
     return status;
 }
 
+NTSTATUS WINAPI wow64_NtGdiDdDDIOpenAdapterFromDeviceName( UINT *args )
+{
+    struct
+    {
+        ULONG pDeviceName;
+        D3DKMT_HANDLE hAdapter;
+        LUID AdapterLuid;
+    } *desc32 = get_ptr( &args );
+
+    D3DKMT_OPENADAPTERFROMDEVICENAME desc = { UlongToPtr( desc32->pDeviceName ) };
+    NTSTATUS status;
+
+    if (!(status = NtGdiDdDDIOpenAdapterFromDeviceName( &desc )))
+    {
+        desc32->hAdapter = desc.hAdapter;
+        desc32->AdapterLuid = desc.AdapterLuid;
+    }
+    return status;
+}
+
 NTSTATUS WINAPI wow64_NtGdiDdDDIOpenAdapterFromHdc( UINT *args )
 {
     struct
@@ -659,6 +686,13 @@ NTSTATUS WINAPI wow64_NtGdiDdDDIOpenAdapterFromHdc( UINT *args )
     return status;
 }
 
+NTSTATUS WINAPI wow64_NtGdiDdDDIOpenAdapterFromLuid( UINT *args )
+{
+    D3DKMT_OPENADAPTERFROMLUID *desc = get_ptr( &args );
+
+    return NtGdiDdDDIOpenAdapterFromLuid( desc );
+}
+
 NTSTATUS WINAPI wow64_NtGdiDdDDIQueryStatistics( UINT *args )
 {
     D3DKMT_QUERYSTATISTICS *stats = get_ptr( &args );
diff --git a/dlls/wow64win/syscall.h b/dlls/wow64win/syscall.h
index fde87498131..ba921e7e543 100644
--- a/dlls/wow64win/syscall.h
+++ b/dlls/wow64win/syscall.h
@@ -38,8 +38,11 @@
     SYSCALL_ENTRY( NtGdiCreateRectRgn ) \
     SYSCALL_ENTRY( NtGdiCreateRoundRectRgn ) \
     SYSCALL_ENTRY( NtGdiCreateSolidBrush ) \
+    SYSCALL_ENTRY( NtGdiDdDDICloseAdapter ) \
     SYSCALL_ENTRY( NtGdiDdDDICreateDevice ) \
+    SYSCALL_ENTRY( NtGdiDdDDIOpenAdapterFromDeviceName ) \
     SYSCALL_ENTRY( NtGdiDdDDIOpenAdapterFromHdc ) \
+    SYSCALL_ENTRY( NtGdiDdDDIOpenAdapterFromLuid ) \
     SYSCALL_ENTRY( NtGdiDdDDIQueryStatistics ) \
     SYSCALL_ENTRY( NtGdiDdDDISetQueuedLimit ) \
     SYSCALL_ENTRY( NtGdiDeleteClientObj ) \
@@ -90,23 +93,16 @@
     SYSCALL_ENTRY( NtUserAddClipboardFormatListener ) \
     SYSCALL_ENTRY( NtUserAttachThreadInput ) \
     SYSCALL_ENTRY( NtUserBuildHwndList ) \
-    SYSCALL_ENTRY( NtUserCallMsgFilter ) \
-    SYSCALL_ENTRY( NtUserCheckMenuItem ) \
-    SYSCALL_ENTRY( NtUserChildWindowFromPointEx ) \
     SYSCALL_ENTRY( NtUserCloseDesktop ) \
     SYSCALL_ENTRY( NtUserCloseWindowStation ) \
     SYSCALL_ENTRY( NtUserCopyAcceleratorTable ) \
     SYSCALL_ENTRY( NtUserCreateAcceleratorTable ) \
     SYSCALL_ENTRY( NtUserCreateDesktopEx ) \
     SYSCALL_ENTRY( NtUserCreateWindowStation ) \
-    SYSCALL_ENTRY( NtUserDeleteMenu ) \
     SYSCALL_ENTRY( NtUserDestroyAcceleratorTable ) \
     SYSCALL_ENTRY( NtUserFindExistingCursorIcon ) \
-    SYSCALL_ENTRY( NtUserFindWindowEx ) \
     SYSCALL_ENTRY( NtUserGetAncestor ) \
     SYSCALL_ENTRY( NtUserGetAtomName ) \
-    SYSCALL_ENTRY( NtUserGetCaretBlinkTime ) \
-    SYSCALL_ENTRY( NtUserGetCaretPos ) \
     SYSCALL_ENTRY( NtUserGetClassName ) \
     SYSCALL_ENTRY( NtUserGetClipboardFormatName ) \
     SYSCALL_ENTRY( NtUserGetClipboardOwner ) \
@@ -124,7 +120,6 @@
     SYSCALL_ENTRY( NtUserGetKeyboardLayoutName ) \
     SYSCALL_ENTRY( NtUserGetKeyboardState ) \
     SYSCALL_ENTRY( NtUserGetLayeredWindowAttributes ) \
-    SYSCALL_ENTRY( NtUserGetMenuItemRect ) \
     SYSCALL_ENTRY( NtUserGetMouseMovePointsEx ) \
     SYSCALL_ENTRY( NtUserGetObjectInformation ) \
     SYSCALL_ENTRY( NtUserGetOpenClipboardWindow ) \
@@ -142,11 +137,8 @@
     SYSCALL_ENTRY( NtUserOpenInputDesktop ) \
     SYSCALL_ENTRY( NtUserOpenWindowStation ) \
     SYSCALL_ENTRY( NtUserRemoveClipboardFormatListener ) \
-    SYSCALL_ENTRY( NtUserRemoveMenu ) \
     SYSCALL_ENTRY( NtUserRemoveProp ) \
     SYSCALL_ENTRY( NtUserSetKeyboardState ) \
-    SYSCALL_ENTRY( NtUserSetMenuContextHelpId ) \
-    SYSCALL_ENTRY( NtUserSetMenuDefaultItem ) \
     SYSCALL_ENTRY( NtUserSetObjectInformation ) \
     SYSCALL_ENTRY( NtUserSetProcessDpiAwarenessContext ) \
     SYSCALL_ENTRY( NtUserSetProcessWindowStation ) \
@@ -156,8 +148,6 @@
     SYSCALL_ENTRY( NtUserSetTimer ) \
     SYSCALL_ENTRY( NtUserSetWinEventHook ) \
     SYSCALL_ENTRY( NtUserSetWindowsHookEx ) \
-    SYSCALL_ENTRY( NtUserThunkedMenuInfo ) \
-    SYSCALL_ENTRY( NtUserThunkedMenuItemInfo ) \
     SYSCALL_ENTRY( NtUserUnhookWinEvent ) \
     SYSCALL_ENTRY( NtUserUnhookWindowsHookEx ) \
     SYSCALL_ENTRY( NtUserWindowFromDC )
diff --git a/dlls/wow64win/user.c b/dlls/wow64win/user.c
index e828dae5247..9d957673ceb 100644
--- a/dlls/wow64win/user.c
+++ b/dlls/wow64win/user.c
@@ -30,58 +30,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(wow);
 
-typedef struct
-{
-    UINT    cbSize;
-    UINT    fMask;
-    UINT    fType;
-    UINT    fState;
-    UINT    wID;
-    UINT32  hSubMenu;
-    UINT32  hbmpChecked;
-    UINT32  hbmpUnchecked;
-    UINT32  dwItemData;
-    UINT32  dwTypeData;
-    UINT    cch;
-    UINT32  hbmpItem;
-} MENUITEMINFOW32;
-
-typedef struct
-{
-    UINT32  hwnd;
-    UINT    message;
-    UINT32  wParam;
-    UINT32  lParam;
-    DWORD   time;
-    POINT   pt;
-} MSG32;
-
-static MSG *msg_32to64( MSG *msg, MSG32 *msg32 )
-{
-    if (!msg32) return NULL;
-
-    msg->hwnd    = UlongToHandle( msg32->hwnd );
-    msg->message = msg32->message;
-    msg->wParam  = msg32->wParam;
-    msg->lParam  = msg32->lParam;
-    msg->time    = msg32->time;
-    msg->pt      = msg32->pt;
-    return msg;
-}
-
-static MSG32 *msg_64to32( MSG *msg, MSG32 *msg32 )
-{
-    if (!msg32) return NULL;
-
-    msg32->hwnd    = HandleToUlong( msg->hwnd );
-    msg32->message = msg->message;
-    msg32->wParam  = msg->wParam;
-    msg32->lParam  = msg->lParam;
-    msg32->time    = msg->time;
-    msg32->pt      = msg->pt;
-    return msg32;
-}
-
 NTSTATUS WINAPI wow64_NtUserInitializeClientPfnArrays( UINT *args )
 {
     FIXME( "\n" );
@@ -311,22 +259,6 @@ NTSTATUS WINAPI wow64_NtUserBuildHwndList( UINT *args )
     return status;
 }
 
-NTSTATUS WINAPI wow64_NtUserFindWindowEx( UINT *args )
-{
-    HWND parent = get_handle( &args );
-    HWND child = get_handle( &args );
-    UNICODE_STRING32 *class32 = get_ptr( &args );
-    UNICODE_STRING32 *title32 = get_ptr( &args );
-    ULONG unk = get_ulong( &args );
-
-    UNICODE_STRING class, title;
-    HWND ret;
-
-    ret = NtUserFindWindowEx( parent, child, unicode_str_32to64( &class, class32 ),
-                              unicode_str_32to64( &title, title32 ), unk );
-    return HandleToUlong( ret );
-}
-
 NTSTATUS WINAPI wow64_NtUserInternalGetWindowText( UINT *args )
 {
     HWND hwnd = get_handle( &args );
@@ -484,16 +416,6 @@ NTSTATUS WINAPI wow64_NtUserGetMouseMovePointsEx( UINT *args )
     return NtUserGetMouseMovePointsEx( size, ptin, ptout, count, resolution );
 }
 
-NTSTATUS WINAPI wow64_NtUserChildWindowFromPointEx( UINT *args )
-{
-    HWND parent = get_handle( &args );
-    LONG x = get_ulong( &args );
-    LONG y = get_ulong( &args );
-    UINT flags = get_ulong( &args );
-
-    return HandleToUlong( NtUserChildWindowFromPointEx( parent, x, y, flags ));
-}
-
 NTSTATUS WINAPI wow64_NtUserSetProcessDpiAwarenessContext( UINT *args )
 {
     ULONG awareness = get_ulong( &args );
@@ -591,18 +513,6 @@ NTSTATUS WINAPI wow64_NtUserUnhookWindowsHookEx( UINT *args )
     return NtUserUnhookWindowsHookEx( handle );
 }
 
-NTSTATUS WINAPI wow64_NtUserCallMsgFilter( UINT *args )
-{
-    MSG32 *msg32 = get_ptr( &args );
-    INT code = get_ulong( &args );
-    MSG msg;
-    BOOL ret;
-
-    ret = NtUserCallMsgFilter( msg_32to64( &msg, msg32 ), code );
-    msg_64to32( &msg, msg32 );
-    return ret;
-}
-
 NTSTATUS WINAPI wow64_NtUserGetForegroundWindow( UINT *args )
 {
     return HandleToUlong( NtUserGetForegroundWindow() );
@@ -649,8 +559,9 @@ NTSTATUS WINAPI wow64_NtUserSetSystemTimer( UINT *args )
     HWND hwnd = get_handle( &args );
     UINT_PTR id = get_ulong( &args );
     UINT timeout = get_ulong( &args );
+    TIMERPROC proc = get_ptr( &args );
 
-    return NtUserSetSystemTimer( hwnd, id, timeout );
+    return NtUserSetSystemTimer( hwnd, id, timeout, proc );
 }
 
 NTSTATUS WINAPI wow64_NtUserSetTimer( UINT *args )
@@ -672,18 +583,6 @@ NTSTATUS WINAPI wow64_NtUserKillTimer( UINT *args )
     return NtUserKillTimer( hwnd, id );
 }
 
-NTSTATUS WINAPI wow64_NtUserGetCaretBlinkTime( UINT *args )
-{
-    return NtUserGetCaretBlinkTime();
-}
-
-NTSTATUS WINAPI wow64_NtUserGetCaretPos( UINT *args )
-{
-    POINT *pt = get_ptr( &args );
-
-    return NtUserGetCaretPos( pt );
-}
-
 NTSTATUS WINAPI wow64_NtUserCopyAcceleratorTable( UINT *args )
 {
     HACCEL src = get_handle( &args );
@@ -707,124 +606,3 @@ NTSTATUS WINAPI wow64_NtUserDestroyAcceleratorTable( UINT *args )
 
     return NtUserDestroyAcceleratorTable( handle );
 }
-
-NTSTATUS WINAPI wow64_NtUserCheckMenuItem( UINT *args )
-{
-    HMENU handle = get_handle( &args );
-    UINT id = get_ulong( &args );
-    UINT flags = get_ulong( &args );
-
-    return NtUserCheckMenuItem( handle, id, flags );
-}
-
-NTSTATUS WINAPI wow64_NtUserDeleteMenu( UINT *args )
-{
-    HMENU menu = get_handle( &args );
-    UINT id = get_ulong( &args );
-    UINT flags = get_ulong( &args );
-
-    return NtUserDeleteMenu( menu, id, flags );
-}
-
-NTSTATUS WINAPI wow64_NtUserGetMenuItemRect( UINT *args )
-{
-    HWND hwnd = get_handle( &args );
-    HMENU handle = get_handle( &args );
-    UINT item = get_ulong( &args );
-    RECT *rect = get_ptr( &args );
-
-    return NtUserGetMenuItemRect( hwnd, handle, item, rect );
-}
-
-NTSTATUS WINAPI wow64_NtUserSetMenuContextHelpId( UINT *args )
-{
-    HMENU menu = get_handle( &args );
-    DWORD id = get_ulong( &args );
-
-    return NtUserSetMenuContextHelpId( menu, id );
-}
-
-NTSTATUS WINAPI wow64_NtUserSetMenuDefaultItem( UINT *args )
-{
-    HMENU handle = get_handle( &args );
-    UINT item = get_ulong( &args );
-    UINT bypos = get_ulong( &args );
-
-    return NtUserSetMenuDefaultItem( handle, item, bypos );
-}
-
-NTSTATUS WINAPI wow64_NtUserThunkedMenuInfo( UINT *args )
-{
-    HMENU menu = get_handle( &args );
-    const struct
-    {
-        DWORD cbSize;
-        DWORD fMask;
-        DWORD dwStyle;
-        UINT  cyMax;
-        ULONG hbrBack;
-        DWORD dwContextHelpID;
-        ULONG dwMenuData;
-    } *info32 = get_ptr( &args );
-    MENUINFO info;
-
-    if (info32)
-    {
-        info.cbSize = sizeof(info);
-        info.fMask = info32->fMask;
-        info.dwStyle = info32->dwStyle;
-        info.cyMax = info32->cyMax;
-        info.hbrBack = UlongToHandle( info32->hbrBack );
-        info.dwContextHelpID = info32->dwContextHelpID;
-        info.dwMenuData = info32->dwMenuData;
-    }
-
-    return NtUserThunkedMenuInfo( menu, info32 ? &info : NULL );
-}
-
-NTSTATUS WINAPI wow64_NtUserThunkedMenuItemInfo( UINT *args )
-{
-    HMENU handle = get_handle( &args );
-    UINT pos = get_ulong( &args );
-    UINT flags = get_ulong( &args );
-    UINT method = get_ulong( &args );
-    MENUITEMINFOW32 *info32 = get_ptr( &args );
-    UNICODE_STRING32 *str32 = get_ptr( &args );
-    MENUITEMINFOW info = { sizeof(info) }, *info_ptr;
-    UNICODE_STRING str;
-
-    if (info32)
-    {
-        info.cbSize = sizeof(info);
-        info.fMask = info32->fMask;
-        switch (method)
-        {
-        case NtUserSetMenuItemInfo:
-        case NtUserInsertMenuItem:
-            info.fType = info32->fType;
-            info.fState = info32->fState;
-            info.wID = info32->wID;
-            info.hSubMenu = UlongToHandle( info32->hSubMenu );
-            info.hbmpChecked = UlongToHandle( info32->hbmpUnchecked );
-            info.dwItemData = info32->dwItemData;
-            info.dwTypeData = UlongToPtr( info32->dwTypeData );
-            info.cch = info32->cch;
-            info.hbmpItem = UlongToHandle( info32->hbmpItem );
-            break;
-        }
-        info_ptr = &info;
-    }
-    else info_ptr = NULL;
-
-    return NtUserThunkedMenuItemInfo( handle, pos, flags, method, info_ptr,
-                                      unicode_str_32to64( &str, str32 ));
-}
-
-NTSTATUS WINAPI wow64_NtUserRemoveMenu( UINT *args )
-{
-    HMENU handle = get_handle( &args );
-    UINT id = get_ulong( &args );
-    UINT flags = get_ulong( &args );
-
-    return NtUserRemoveMenu( handle, id, flags );
-}
diff --git a/include/ddk/d3dkmthk.h b/include/ddk/d3dkmthk.h
index b65fcb8c9c6..663a5d31ada 100644
--- a/include/ddk/d3dkmthk.h
+++ b/include/ddk/d3dkmthk.h
@@ -30,12 +30,6 @@ typedef enum _D3DKMT_VIDPNSOURCEOWNER_TYPE
     D3DKMT_VIDPNSOURCEOWNER_EMULATED = 4
 } D3DKMT_VIDPNSOURCEOWNER_TYPE;
 
-typedef enum _D3DKMT_MEMORY_SEGMENT_GROUP
-{
-    D3DKMT_MEMORY_SEGMENT_GROUP_LOCAL = 0,
-    D3DKMT_MEMORY_SEGMENT_GROUP_NON_LOCAL = 1
-} D3DKMT_MEMORY_SEGMENT_GROUP;
-
 typedef struct _D3DKMT_CREATEDEVICEFLAGS
 {
     UINT LegacyMode : 1;
@@ -609,18 +603,6 @@ typedef struct _D3DKMT_QUERYSTATISTICS
     } DUMMYUNIONNAME;
 } D3DKMT_QUERYSTATISTICS;
 
-typedef struct _D3DKMT_QUERYVIDEOMEMORYINFO
-{
-    HANDLE                      hProcess;
-    D3DKMT_HANDLE               hAdapter;
-    D3DKMT_MEMORY_SEGMENT_GROUP MemorySegmentGroup;
-    UINT64                      Budget;
-    UINT64                      CurrentUsage;
-    UINT64                      CurrentReservation;
-    UINT64                      AvailableForReservation;
-    UINT                        PhysicalAdapterIndex;
-} D3DKMT_QUERYVIDEOMEMORYINFO;
-
 typedef enum _D3DKMT_QUEUEDLIMIT_TYPE
 {
     D3DKMT_SET_QUEUEDLIMIT_PRESENT = 1,
@@ -681,9 +663,7 @@ NTSTATUS WINAPI D3DKMTDestroyDevice(const D3DKMT_DESTROYDEVICE *desc);
 NTSTATUS WINAPI D3DKMTEscape( const D3DKMT_ESCAPE *desc );
 NTSTATUS WINAPI D3DKMTOpenAdapterFromGdiDisplayName(D3DKMT_OPENADAPTERFROMGDIDISPLAYNAME *desc);
 NTSTATUS WINAPI D3DKMTOpenAdapterFromHdc( D3DKMT_OPENADAPTERFROMHDC *desc );
-NTSTATUS WINAPI D3DKMTOpenAdapterFromLuid( D3DKMT_OPENADAPTERFROMLUID * desc );
 NTSTATUS WINAPI D3DKMTQueryStatistics(D3DKMT_QUERYSTATISTICS *stats);
-NTSTATUS WINAPI D3DKMTQueryVideoMemoryInfo(D3DKMT_QUERYVIDEOMEMORYINFO *desc);
 NTSTATUS WINAPI D3DKMTSetQueuedLimit(D3DKMT_SETQUEUEDLIMIT *desc);
 NTSTATUS WINAPI D3DKMTSetVidPnSourceOwner(const D3DKMT_SETVIDPNSOURCEOWNER *desc);
 
diff --git a/include/ntgdi.h b/include/ntgdi.h
index 5a9d5a798fe..1322c0dc13c 100644
--- a/include/ntgdi.h
+++ b/include/ntgdi.h
@@ -207,9 +207,6 @@ struct font_enum_entry
 /* flag for NtGdiGetRandomRgn to respect LAYOUT_RTL */
 #define NTGDI_RGN_MIRROR_RTL   0x80000000
 
-/* magic driver version that we use for win16 DCs with DIB surfaces */
-#define NTGDI_WIN16_DIB  0xfafa000
-
 #endif /* __WINESRC__ */
 
 struct font_realization_info
@@ -472,7 +469,6 @@ NTSTATUS WINAPI NtGdiDdDDIOpenAdapterFromHdc( D3DKMT_OPENADAPTERFROMHDC *desc );
 NTSTATUS WINAPI NtGdiDdDDIOpenAdapterFromDeviceName( D3DKMT_OPENADAPTERFROMDEVICENAME *desc );
 NTSTATUS WINAPI NtGdiDdDDIOpenAdapterFromLuid( D3DKMT_OPENADAPTERFROMLUID *desc );
 NTSTATUS WINAPI NtGdiDdDDIQueryStatistics( D3DKMT_QUERYSTATISTICS *stats );
-NTSTATUS WINAPI NtGdiDdDDIQueryVideoMemoryInfo( D3DKMT_QUERYVIDEOMEMORYINFO *desc );
 NTSTATUS WINAPI NtGdiDdDDISetQueuedLimit( D3DKMT_SETQUEUEDLIMIT *desc );
 NTSTATUS WINAPI NtGdiDdDDISetVidPnSourceOwner( const D3DKMT_SETVIDPNSOURCEOWNER *desc );
 
diff --git a/include/ntuser.h b/include/ntuser.h
index 091d34c3a5f..8157723f588 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -28,43 +28,17 @@ enum
 {
     /* user32 callbacks */
     NtUserCallEnumDisplayMonitor,
-    NtUserCallSendAsyncCallback,
     NtUserCallWinEventHook,
-    NtUserCallWinProc,
     NtUserCallWindowsHook,
-    NtUserCopyImage,
-    NtUserFreeCachedClipboardData,
     NtUserLoadDriver,
-    NtUserRegisterBuiltinClasses,
-    NtUserRenderSynthesizedFormat,
     /* win16 hooks */
     NtUserCallFreeIcon,
-    NtUserThunkLock,
     /* Vulkan support */
     NtUserCallVulkanDebugReportCallback,
     NtUserCallVulkanDebugUtilsCallback,
-    /* Driver-specific callbacks */
-    NtUserDriverCallbackFirst,
-    NtUserDriverCallbackLast = NtUserDriverCallbackFirst + 10,
     NtUserCallCount
 };
 
-/* TEB thread info, not compatible with Windows */
-struct ntuser_thread_info
-{
-    void      *driver_data;       /* driver-specific data */
-    DWORD      message_time;      /* value for GetMessageTime */
-    DWORD      message_pos;       /* value for GetMessagePos */
-    ULONG_PTR  message_extra;     /* value for GetMessageExtraInfo */
-    HWND       top_window;        /* desktop window */
-    HWND       msg_window;        /* HWND_MESSAGE parent window */
-};
-
-static inline struct ntuser_thread_info *NtUserGetThreadInfo(void)
-{
-    return (struct ntuser_thread_info *)NtCurrentTeb()->Win32ClientInfo;
-}
-
 /* NtUserCallEnumDisplayMonitor params */
 struct enum_display_monitor_params
 {
@@ -75,16 +49,6 @@ struct enum_display_monitor_params
     LPARAM lparam;
 };
 
-/* NtUserCallSendAsyncCallback params */
-struct send_async_params
-{
-    SENDASYNCPROC callback;
-    HWND hwnd;
-    UINT msg;
-    ULONG_PTR data;
-    LRESULT result;
-};
-
 /* NtUserCallWinEventHook params */
 struct win_event_hook_params
 {
@@ -124,7 +88,6 @@ struct win_proc_params
     BOOL ansi;
     BOOL ansi_dst;
     BOOL is_dialog;
-    BOOL needs_unpack;
     enum wm_char_mapping mapping;
     DPI_AWARENESS_CONTEXT dpi_awareness;
     WNDPROC procA;
@@ -147,30 +110,6 @@ struct win_hook_params
     WCHAR module[MAX_PATH];
 };
 
-/* NtUserCopyMessage params */
-struct copy_image_params
-{
-    HANDLE hwnd;
-    UINT type;
-    INT dx;
-    INT dy;
-    UINT flags;
-};
-
-/* NtUserFreeCachedClipboardData params */
-struct free_cached_data_params
-{
-    UINT format;
-    HANDLE handle;
-};
-
-/* NtUserRenderSynthesizedFormat params */
-struct render_synthesized_format_params
-{
-    UINT format;
-    UINT from;
-};
-
 /* process DPI awareness contexts */
 #define NTUSER_DPI_UNAWARE                0x00006010
 #define NTUSER_DPI_SYSTEM_AWARE           0x00006011
@@ -178,42 +117,117 @@ struct render_synthesized_format_params
 #define NTUSER_DPI_PER_MONITOR_AWARE_V2   0x00000022
 #define NTUSER_DPI_PER_UNAWARE_GDISCALED  0x40006010
 
-/* NtUserMessageCall codes */
+/* NtUserCallNoParam codes, not compatible with Windows */
 enum
 {
-    NtUserDesktopWindowProc   = 0x029d,
-    NtUserDefWindowProc       = 0x029e,
-    NtUserCallWindowProc      = 0x02ab,
-    NtUserSendMessage         = 0x02b1,
-    NtUserSendMessageTimeout  = 0x02b3,
-    NtUserSendNotifyMessage   = 0x02b7,
-    NtUserSendMessageCallback = 0x02b8,
-    /* Wine-specific exports */
-    NtUserClipboardWindowProc = 0x0300,
-    NtUserSpyEnter            = 0x0301,
-    NtUserSpyExit             = 0x0302,
+    NtUserGetDesktopWindow,
+    NtUserGetInputState,
+    NtUserReleaseCapture,
+    /* temporary exports */
+    NtUserExitingThread,
+    NtUserThreadDetach,
 };
 
-/* NtUserThunkedMenuItemInfo codes */
+/* NtUserCallOneParam codes, not compatible with Windows */
 enum
 {
-    NtUserSetMenuItemInfo,
-    NtUserInsertMenuItem,
-    /* Wine extensions */
-    NtUserGetMenuState,
+    NtUserBeginDeferWindowPos,
+    NtUserCreateCursorIcon,
+    NtUserEnableDC,
+    NtUserGetClipCursor,
+    NtUserGetCursorPos,
+    NtUserGetIconParam,
+    NtUserGetPrimaryMonitorRect,
+    NtUserGetSysColor,
+    NtUserGetSysColorBrush,
+    NtUserGetSysColorPen,
+    NtUserGetSystemMetrics,
+    NtUserGetVirtualScreenRect,
+    NtUserMessageBeep,
+    NtUserRealizePalette,
+    /* temporary exports */
+    NtUserCallHooks,
+    NtUserFlushWindowSurfaces,
+    NtUserGetDeskPattern,
+    NtUserGetWinProcPtr,
+    NtUserHandleInternalMessage,
+    NtUserIncrementKeyStateCounter,
+    NtUserLock,
+    NtUserSetCallbacks,
 };
 
-struct send_message_timeout_params
+/* NtUserCallTwoParam codes, not compatible with Windows */
+enum
 {
-    UINT flags;
-    UINT timeout;
-    DWORD_PTR result;
+    NtUserGetMonitorInfo,
+    NtUserGetSystemMetricsForDpi,
+    NtUserMirrorRgn,
+    NtUserMonitorFromRect,
+    NtUserSetIconParam,
+    NtUserUnhookWindowsHook,
+    /* temporary exports */
+    NtUserAllocHandle,
+    NtUserAllocWinProc,
+    NtUserFreeHandle,
+    NtUserGetHandlePtr,
+    NtUserInvalidateDCE,
+    NtUserRegisterWindowSurface,
+    NtUserSetHandlePtr,
 };
 
-struct send_message_callback_params
+/* NtUserCallHwnd codes, not compatible with Windows */
+enum
+{
+    NtUserGetDpiForWindow,
+    NtUserGetParent,
+    NtUserGetWindowContextHelpId,
+    NtUserGetWindowDpiAwarenessContext,
+    NtUserGetWindowTextLength,
+    NtUserIsWindow,
+    NtUserIsWindowUnicode,
+    NtUserIsWindowVisible,
+    /* temporary exports */
+    NtUserCreateDesktopWindow,
+    NtUserDestroyWindowHandle,
+    NtUserGetDummySurface,
+};
+
+/* NtUserCallHwndParam codes, not compatible with Windows */
+enum
 {
-    SENDASYNCPROC callback;
-    ULONG_PTR data;
+    NtUserGetClassLongA,
+    NtUserGetClassLongW,
+    NtUserGetClassLongPtrA,
+    NtUserGetClassLongPtrW,
+    NtUserGetClassWord,
+    NtUserGetClientRect,
+    NtUserGetMinMaxInfo,
+    NtUserGetWindowInfo,
+    NtUserGetWindowLongA,
+    NtUserGetWindowLongW,
+    NtUserGetWindowLongPtrA,
+    NtUserGetWindowLongPtrW,
+    NtUserGetWindowPlacement,
+    NtUserGetWindowRect,
+    NtUserGetWindowRelative,
+    NtUserGetWindowThread,
+    NtUserGetWindowWord,
+    NtUserIsChild,
+    NtUserKillSystemTimer,
+    NtUserMonitorFromWindow,
+    NtUserScreenToClient,
+    NtUserSetCaptureWindow,
+    NtUserSetForegroundWindow,
+    NtUserSetWindowPixelFormat,
+    /* temporary exports */
+    NtUserIsWindowDrawable,
+    NtUserSetWindowStyle,
+};
+
+/* NtUserMessageCall codes */
+enum
+{
+    FNID_SENDNOTIFYMESSAGE  = 0x02b7,
 };
 
 /* color index used to retrieve system 55aa brush */
@@ -276,25 +290,6 @@ struct client_menu_name
     UNICODE_STRING *nameUS;
 };
 
-/* NtUserGetClipboardData params, not compatible with Windows */
-struct get_clipboard_params
-{
-    void  *data;
-    size_t size;
-    size_t data_size;
-    UINT   seqno;
-    BOOL data_only;
-};
-
-/* NtUserSetClipboardData params, not compatible with Windows */
-struct set_clipboard_params
-{
-    void  *data;
-    size_t size;
-    BOOL   cache_only;
-    UINT   seqno;
-};
-
 /* internal messages codes */
 enum wine_internal_message
 {
@@ -313,158 +308,6 @@ enum wine_internal_message
     WM_WINE_LAST_DRIVER_MSG = 0x80001fff
 };
 
-/* the various structures that can be sent in messages, in platform-independent layout */
-struct packed_CREATESTRUCTW
-{
-    ULONGLONG lpCreateParams;
-    ULONGLONG hInstance;
-    UINT      hMenu;
-    DWORD     __pad1;
-    UINT      hwndParent;
-    DWORD     __pad2;
-    INT       cy;
-    INT       cx;
-    INT       y;
-    INT       x;
-    LONG      style;
-    ULONGLONG lpszName;
-    ULONGLONG lpszClass;
-    DWORD     dwExStyle;
-    DWORD     __pad3;
-};
-
-struct packed_DRAWITEMSTRUCT
-{
-    UINT      CtlType;
-    UINT      CtlID;
-    UINT      itemID;
-    UINT      itemAction;
-    UINT      itemState;
-    UINT      hwndItem;
-    DWORD     __pad1;
-    UINT      hDC;
-    DWORD     __pad2;
-    RECT      rcItem;
-    ULONGLONG itemData;
-};
-
-struct packed_MEASUREITEMSTRUCT
-{
-    UINT      CtlType;
-    UINT      CtlID;
-    UINT      itemID;
-    UINT      itemWidth;
-    UINT      itemHeight;
-    ULONGLONG itemData;
-};
-
-struct packed_DELETEITEMSTRUCT
-{
-    UINT      CtlType;
-    UINT      CtlID;
-    UINT      itemID;
-    UINT      hwndItem;
-    DWORD     __pad;
-    ULONGLONG itemData;
-};
-
-struct packed_COMPAREITEMSTRUCT
-{
-    UINT      CtlType;
-    UINT      CtlID;
-    UINT      hwndItem;
-    DWORD     __pad1;
-    UINT      itemID1;
-    ULONGLONG itemData1;
-    UINT      itemID2;
-    ULONGLONG itemData2;
-    DWORD     dwLocaleId;
-    DWORD     __pad2;
-};
-
-struct packed_WINDOWPOS
-{
-    UINT      hwnd;
-    DWORD     __pad1;
-    UINT      hwndInsertAfter;
-    DWORD     __pad2;
-    INT       x;
-    INT       y;
-    INT       cx;
-    INT       cy;
-    UINT      flags;
-    DWORD     __pad3;
-};
-
-struct packed_COPYDATASTRUCT
-{
-    ULONGLONG dwData;
-    DWORD     cbData;
-    ULONGLONG lpData;
-};
-
-struct packed_HELPINFO
-{
-    UINT      cbSize;
-    INT       iContextType;
-    INT       iCtrlId;
-    UINT      hItemHandle;
-    DWORD     __pad;
-    ULONGLONG dwContextId;
-    POINT     MousePos;
-};
-
-struct packed_NCCALCSIZE_PARAMS
-{
-    RECT      rgrc[3];
-    ULONGLONG __pad1;
-    UINT      hwnd;
-    DWORD     __pad2;
-    UINT      hwndInsertAfter;
-    DWORD     __pad3;
-    INT       x;
-    INT       y;
-    INT       cx;
-    INT       cy;
-    UINT      flags;
-    DWORD     __pad4;
-};
-
-struct packed_MSG
-{
-    UINT      hwnd;
-    DWORD     __pad1;
-    UINT      message;
-    ULONGLONG wParam;
-    ULONGLONG lParam;
-    DWORD     time;
-    POINT     pt;
-    DWORD     __pad2;
-};
-
-struct packed_MDINEXTMENU
-{
-    UINT      hmenuIn;
-    DWORD     __pad1;
-    UINT      hmenuNext;
-    DWORD     __pad2;
-    UINT      hwndNext;
-    DWORD     __pad3;
-};
-
-struct packed_MDICREATESTRUCTW
-{
-    ULONGLONG szClass;
-    ULONGLONG szTitle;
-    ULONGLONG hOwner;
-    INT       x;
-    INT       y;
-    INT       cx;
-    INT       cy;
-    DWORD     style;
-    ULONGLONG lParam;
-};
-
 
 HKL     WINAPI NtUserActivateKeyboardLayout( HKL layout, UINT flags );
 BOOL    WINAPI NtUserAddClipboardFormatListener( HWND hwnd );
@@ -475,45 +318,30 @@ NTSTATUS WINAPI NtUserBuildHwndList( HDESK desktop, ULONG unk2, ULONG unk3, ULON
 ULONG_PTR WINAPI NtUserCallHwnd( HWND hwnd, DWORD code );
 ULONG_PTR WINAPI NtUserCallHwndParam( HWND hwnd, DWORD_PTR param, DWORD code );
 LRESULT WINAPI NtUserCallNextHookEx( HHOOK hhook, INT code, WPARAM wparam, LPARAM lparam );
-BOOL    WINAPI NtUserCallMsgFilter( MSG *msg, INT code );
 ULONG_PTR WINAPI NtUserCallNoParam( ULONG code );
 ULONG_PTR WINAPI NtUserCallOneParam( ULONG_PTR arg, ULONG code );
 ULONG_PTR WINAPI NtUserCallTwoParam( ULONG_PTR arg1, ULONG_PTR arg2, ULONG code );
-BOOL    WINAPI NtUserChangeClipboardChain( HWND hwnd, HWND next );
 LONG    WINAPI NtUserChangeDisplaySettings( UNICODE_STRING *devname, DEVMODEW *devmode, HWND hwnd,
                                             DWORD flags, void *lparam );
-DWORD   WINAPI NtUserCheckMenuItem( HMENU handle, UINT id, UINT flags );
-HWND    WINAPI NtUserChildWindowFromPointEx( HWND parent, LONG x, LONG y, UINT flags );
 BOOL    WINAPI NtUserClipCursor( const RECT *rect );
-BOOL    WINAPI NtUserCloseClipboard(void);
 BOOL    WINAPI NtUserCloseDesktop( HDESK handle );
 BOOL    WINAPI NtUserCloseWindowStation( HWINSTA handle );
 INT     WINAPI NtUserCopyAcceleratorTable( HACCEL src, ACCEL *dst, INT count );
 INT     WINAPI NtUserCountClipboardFormats(void);
 HACCEL  WINAPI NtUserCreateAcceleratorTable( ACCEL *table, INT count );
-BOOL    WINAPI NtUserCreateCaret( HWND hwnd, HBITMAP bitmap, int width, int height );
 HDESK   WINAPI NtUserCreateDesktopEx( OBJECT_ATTRIBUTES *attr, UNICODE_STRING *device,
                                       DEVMODEW *devmode, DWORD flags, ACCESS_MASK access,
                                       ULONG heap_size );
-HWND    WINAPI NtUserCreateWindowEx( DWORD ex_style, UNICODE_STRING *class_name,
-                                     UNICODE_STRING *version, UNICODE_STRING *window_name,
-                                     DWORD style, INT x, INT y, INT cx, INT cy,
-                                     HWND parent, HMENU menu, HINSTANCE instance, void *params,
-                                     DWORD flags, CBT_CREATEWNDW *cbtc, DWORD unk, BOOL ansi );
 HWINSTA WINAPI NtUserCreateWindowStation( OBJECT_ATTRIBUTES *attr, ACCESS_MASK mask, ULONG arg3,
                                           ULONG arg4, ULONG arg5, ULONG arg6, ULONG arg7 );
 HDWP    WINAPI NtUserDeferWindowPosAndBand( HDWP hdwp, HWND hwnd, HWND after, INT x, INT y,
                                             INT cx, INT cy, UINT flags, UINT unk1, UINT unk2 );
-BOOL    WINAPI NtUserDeleteMenu( HMENU menu, UINT id, UINT flags );
 BOOL    WINAPI NtUserDestroyAcceleratorTable( HACCEL handle );
 BOOL    WINAPI NtUserDestroyCursor( HCURSOR cursor, ULONG arg );
 BOOL    WINAPI NtUserDestroyMenu( HMENU menu );
 BOOL    WINAPI NtUserDestroyWindow( HWND hwnd );
-LRESULT WINAPI NtUserDispatchMessage( const MSG *msg );
 BOOL    WINAPI NtUserDrawIconEx( HDC hdc, INT x0, INT y0, HICON icon, INT width,
                                  INT height, UINT istep, HBRUSH hbr, UINT flags );
-BOOL    WINAPI NtUserEmptyClipboard(void);
-BOOL    WINAPI NtUserEnableMenuItem( HMENU handle, UINT id, UINT flags );
 BOOL    WINAPI NtUserEndDeferWindowPosEx( HDWP hdwp, BOOL async );
 BOOL    WINAPI NtUserEndPaint( HWND hwnd, const PAINTSTRUCT *ps );
 NTSTATUS WINAPI NtUserEnumDisplayDevices( UNICODE_STRING *device, DWORD index,
@@ -521,21 +349,15 @@ NTSTATUS WINAPI NtUserEnumDisplayDevices( UNICODE_STRING *device, DWORD index,
 BOOL    WINAPI NtUserEnumDisplayMonitors( HDC hdc, RECT *rect, MONITORENUMPROC proc, LPARAM lp );
 BOOL    WINAPI NtUserEnumDisplaySettings( UNICODE_STRING *device, DWORD mode,
                                           DEVMODEW *dev_mode, DWORD flags );
-INT     WINAPI NtUserExcludeUpdateRgn( HDC hdc, HWND hwnd );
 HICON   WINAPI NtUserFindExistingCursorIcon( UNICODE_STRING *module, UNICODE_STRING *res_name,
                                              void *desc );
-HWND    WINAPI NtUserFindWindowEx( HWND parent, HWND child, UNICODE_STRING *class,
-                                   UNICODE_STRING *title, ULONG unk );
 BOOL    WINAPI NtUserFlashWindowEx( FLASHWINFO *info );
 HWND    WINAPI NtUserGetAncestor( HWND hwnd, UINT type );
 SHORT   WINAPI NtUserGetAsyncKeyState( INT key );
 ULONG   WINAPI NtUserGetAtomName( ATOM atom, UNICODE_STRING *name );
-UINT    WINAPI NtUserGetCaretBlinkTime(void);
-BOOL    WINAPI NtUserGetCaretPos( POINT *point );
 ATOM    WINAPI NtUserGetClassInfoEx( HINSTANCE instance, UNICODE_STRING *name, WNDCLASSEXW *wc,
                                      struct client_menu_name *menu_name, BOOL ansi );
 INT     WINAPI NtUserGetClassName( HWND hwnd, BOOL real, UNICODE_STRING *name );
-HANDLE  WINAPI NtUserGetClipboardData( UINT format, struct get_clipboard_params *params );
 INT     WINAPI NtUserGetClipboardFormatName( UINT format, WCHAR *buffer, INT maxlen );
 HWND    WINAPI NtUserGetClipboardOwner(void);
 DWORD   WINAPI NtUserGetClipboardSequenceNumber(void);
@@ -561,8 +383,6 @@ UINT    WINAPI NtUserGetKeyboardLayoutList( INT size, HKL *layouts );
 BOOL    WINAPI NtUserGetKeyboardLayoutName( WCHAR *name );
 BOOL    WINAPI NtUserGetKeyboardState( BYTE *state );
 BOOL    WINAPI NtUserGetLayeredWindowAttributes( HWND hwnd, COLORREF *key, BYTE *alpha, DWORD *flags );
-BOOL    WINAPI NtUserGetMenuItemRect( HWND hwnd, HMENU menu, UINT item, RECT *rect );
-BOOL    WINAPI NtUserGetMessage( MSG *msg, HWND hwnd, UINT first, UINT last );
 int     WINAPI NtUserGetMouseMovePointsEx( UINT size, MOUSEMOVEPOINT *ptin, MOUSEMOVEPOINT *ptout,
                                            int count, DWORD resolution );
 BOOL    WINAPI NtUserGetObjectInformation( HANDLE handle, INT index, void *info,
@@ -574,14 +394,11 @@ HANDLE  WINAPI NtUserGetProp( HWND hwnd, const WCHAR *str );
 ULONG   WINAPI NtUserGetProcessDpiAwarenessContext( HANDLE process );
 DWORD   WINAPI NtUserGetQueueStatus( UINT flags );
 ULONG   WINAPI NtUserGetSystemDpiForProcess( HANDLE process );
-HMENU   WINAPI NtUserGetSystemMenu( HWND hwnd, BOOL revert );
 HDESK   WINAPI NtUserGetThreadDesktop( DWORD thread );
 INT     WINAPI NtUserGetUpdateRgn( HWND hwnd, HRGN hrgn, BOOL erase );
 BOOL    WINAPI NtUserGetUpdatedClipboardFormats( UINT *formats, UINT size, UINT *out_size );
 BOOL    WINAPI NtUserGetUpdateRect( HWND hwnd, RECT *rect, BOOL erase );
-BOOL    WINAPI NtUserGetWindowPlacement( HWND hwnd, WINDOWPLACEMENT *placement );
 int     WINAPI NtUserGetWindowRgnEx( HWND hwnd, HRGN hrgn, UINT unk );
-BOOL    WINAPI NtUserHideCaret( HWND hwnd );
 NTSTATUS WINAPI NtUserInitializeClientPfnArrays( const struct user_client_procs *client_procsA,
                                                  const struct user_client_procs *client_procsW,
                                                  const void *client_workers, HINSTANCE user_module );
@@ -589,20 +406,14 @@ INT     WINAPI NtUserInternalGetWindowText( HWND hwnd, WCHAR *text, INT count );
 BOOL    WINAPI NtUserIsClipboardFormatAvailable( UINT format );
 BOOL    WINAPI NtUserKillTimer( HWND hwnd, UINT_PTR id );
 UINT    WINAPI NtUserMapVirtualKeyEx( UINT code, UINT type, HKL layout );
-LRESULT WINAPI NtUserMessageCall( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
-                                  void *result_info, DWORD type, BOOL ansi );
+BOOL    WINAPI NtUserMessageCall( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
+                                  ULONG_PTR result_info, DWORD type, BOOL ansi );
 BOOL    WINAPI NtUserMoveWindow( HWND hwnd, INT x, INT y, INT cx, INT cy, BOOL repaint );
-DWORD   WINAPI NtUserMsgWaitForMultipleObjectsEx( DWORD count, const HANDLE *handles,
-                                                  DWORD timeout, DWORD mask, DWORD flags );
 void    WINAPI NtUserNotifyWinEvent( DWORD event, HWND hwnd, LONG object_id, LONG child_id );
 HWINSTA WINAPI NtUserOpenWindowStation( OBJECT_ATTRIBUTES *attr, ACCESS_MASK access );
 BOOL    WINAPI NtUserSetObjectInformation( HANDLE handle, INT index, void *info, DWORD len );
-BOOL    WINAPI NtUserOpenClipboard( HWND hwnd, ULONG unk );
 HDESK   WINAPI NtUserOpenDesktop( OBJECT_ATTRIBUTES *attr, DWORD flags, ACCESS_MASK access );
 HDESK   WINAPI NtUserOpenInputDesktop( DWORD flags, BOOL inherit, ACCESS_MASK access );
-BOOL    WINAPI NtUserPeekMessage( MSG *msg_out, HWND hwnd, UINT first, UINT last, UINT flags );
-BOOL    WINAPI NtUserPostMessage( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam );
-BOOL    WINAPI NtUserPostThreadMessage( DWORD thread, UINT msg, WPARAM wparam, LPARAM lparam );
 BOOL    WINAPI NtUserRedrawWindow( HWND hwnd, const RECT *rect, HRGN hrgn, UINT flags );
 ATOM    WINAPI NtUserRegisterClassExWOW( const WNDCLASSEXW *wc, UNICODE_STRING *name, UNICODE_STRING *version,
                                          struct client_menu_name *client_menu_name, DWORD fnid, DWORD flags,
@@ -610,42 +421,32 @@ ATOM    WINAPI NtUserRegisterClassExWOW( const WNDCLASSEXW *wc, UNICODE_STRING *
 BOOL    WINAPI NtUserRegisterHotKey( HWND hwnd, INT id, UINT modifiers, UINT vk );
 INT     WINAPI NtUserReleaseDC( HWND hwnd, HDC hdc );
 BOOL    WINAPI NtUserRemoveClipboardFormatListener( HWND hwnd );
-BOOL    WINAPI NtUserRemoveMenu( HMENU menu, UINT id, UINT flags );
 HANDLE  WINAPI NtUserRemoveProp( HWND hwnd, const WCHAR *str );
 BOOL    WINAPI NtUserScrollDC( HDC hdc, INT dx, INT dy, const RECT *scroll, const RECT *clip,
                                HRGN ret_update_rgn, RECT *update_rect );
 HPALETTE WINAPI NtUserSelectPalette( HDC hdc, HPALETTE palette, WORD force_background );
-UINT     WINAPI NtUserSendInput( UINT count, INPUT *inputs, int size );
 HWND     WINAPI NtUserSetActiveWindow( HWND hwnd );
 HWND     WINAPI NtUserSetCapture( HWND hwnd );
 DWORD    WINAPI NtUserSetClassLong( HWND hwnd, INT offset, LONG newval, BOOL ansi );
 ULONG_PTR WINAPI NtUserSetClassLongPtr( HWND hwnd, INT offset, LONG_PTR newval, BOOL ansi );
 WORD    WINAPI NtUserSetClassWord( HWND hwnd, INT offset, WORD newval );
-NTSTATUS WINAPI NtUserSetClipboardData( UINT format, HANDLE handle, struct set_clipboard_params *params );
-HWND    WINAPI NtUserSetClipboardViewer( HWND hwnd );
 HCURSOR WINAPI NtUserSetCursor( HCURSOR cursor );
 BOOL    WINAPI NtUserSetCursorIconData( HCURSOR cursor, UNICODE_STRING *module, UNICODE_STRING *res_name,
                                         struct cursoricon_desc *desc );
 BOOL    WINAPI NtUserSetCursorPos( INT x, INT y );
 HWND    WINAPI NtUserSetFocus( HWND hwnd );
-void    WINAPI NtUserSetInternalWindowPos( HWND hwnd, UINT cmd, RECT *rect, POINT *pt );
 BOOL    WINAPI NtUserSetKeyboardState( BYTE *state );
 BOOL    WINAPI NtUserSetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWORD flags );
-BOOL    WINAPI NtUserSetMenu( HWND hwnd, HMENU menu );
-BOOL    WINAPI NtUserSetMenuContextHelpId( HMENU handle, DWORD id );
-BOOL    WINAPI NtUserSetMenuDefaultItem( HMENU handle, UINT item, UINT bypos );
 HWND    WINAPI NtUserSetParent( HWND hwnd, HWND parent );
 BOOL    WINAPI NtUserSetProcessDpiAwarenessContext( ULONG awareness, ULONG unknown );
 BOOL    WINAPI NtUserSetProcessWindowStation( HWINSTA handle );
 BOOL    WINAPI NtUserSetProp( HWND hwnd, const WCHAR *str, HANDLE handle );
 BOOL    WINAPI NtUserSetSysColors( INT count, const INT *colors, const COLORREF *values );
-BOOL    WINAPI NtUserSetSystemMenu( HWND hwnd, HMENU menu );
-UINT_PTR WINAPI NtUserSetSystemTimer( HWND hwnd, UINT_PTR id, UINT timeout );
+UINT_PTR WINAPI NtUserSetSystemTimer( HWND hwnd, UINT_PTR id, UINT timeout, TIMERPROC proc );
 BOOL    WINAPI NtUserSetThreadDesktop( HDESK handle );
 UINT_PTR WINAPI NtUserSetTimer( HWND hwnd, UINT_PTR id, UINT timeout, TIMERPROC proc, ULONG tolerance );
 LONG    WINAPI NtUserSetWindowLong( HWND hwnd, INT offset, LONG newval, BOOL ansi );
 LONG_PTR WINAPI NtUserSetWindowLongPtr( HWND hwnd, INT offset, LONG_PTR newval, BOOL ansi );
-BOOL    WINAPI NtUserSetWindowPlacement( HWND hwnd, const WINDOWPLACEMENT *wpl );
 BOOL    WINAPI NtUserSetWindowPos( HWND hwnd, HWND after, INT x, INT y, INT cx, INT cy, UINT flags );
 int     WINAPI NtUserSetWindowRgn( HWND hwnd, HRGN hrgn, BOOL redraw );
 WORD    WINAPI NtUserSetWindowWord( HWND hwnd, INT offset, WORD newval );
@@ -654,20 +455,13 @@ HHOOK   WINAPI NtUserSetWindowsHookEx( HINSTANCE inst, UNICODE_STRING *module, D
 HWINEVENTHOOK WINAPI NtUserSetWinEventHook( DWORD event_min, DWORD event_max, HMODULE inst,
                                             UNICODE_STRING *module, WINEVENTPROC proc,
                                             DWORD pid, DWORD tid, DWORD flags );
-BOOL    WINAPI NtUserShowCaret( HWND hwnd );
 INT     WINAPI NtUserShowCursor( BOOL show );
 BOOL    WINAPI NtUserShowWindow( HWND hwnd, INT cmd );
 BOOL    WINAPI NtUserShowWindowAsync( HWND hwnd, INT cmd );
 BOOL    WINAPI NtUserSystemParametersInfo( UINT action, UINT val, void *ptr, UINT winini );
 BOOL    WINAPI NtUserSystemParametersInfoForDpi( UINT action, UINT val, PVOID ptr, UINT winini, UINT dpi );
-BOOL    WINAPI NtUserThunkedMenuInfo( HMENU menu, const MENUINFO *info );
-UINT    WINAPI NtUserThunkedMenuItemInfo( HMENU menu, UINT pos, UINT flags, UINT method,
-                                          MENUITEMINFOW *info, UNICODE_STRING *str );
 INT     WINAPI NtUserToUnicodeEx( UINT virt, UINT scan, const BYTE *state,
                                   WCHAR *str, int size, UINT flags, HKL layout );
-BOOL    WINAPI NtUserTrackMouseEvent( TRACKMOUSEEVENT *info );
-INT     WINAPI NtUserTranslateAccelerator( HWND hwnd, HACCEL accel, MSG *msg );
-BOOL    WINAPI NtUserTranslateMessage( const MSG *msg, UINT flags );
 BOOL    WINAPI NtUserUnhookWinEvent( HWINEVENTHOOK hEventHook );
 BOOL    WINAPI NtUserUnhookWindowsHookEx( HHOOK handle );
 BOOL    WINAPI NtUserUnregisterClass( UNICODE_STRING *name, HINSTANCE instance,
@@ -681,497 +475,4 @@ DWORD   WINAPI NtUserWaitForInputIdle( HANDLE process, DWORD timeout, BOOL wow )
 HWND    WINAPI NtUserWindowFromDC( HDC hdc );
 HWND    WINAPI NtUserWindowFromPoint( LONG x, LONG y );
 
-/* NtUserCallNoParam codes, not compatible with Windows */
-enum
-{
-    NtUserCallNoParam_DestroyCaret,
-    NtUserCallNoParam_GetDesktopWindow,
-    NtUserCallNoParam_GetInputState,
-    NtUserCallNoParam_ReleaseCapture,
-    /* temporary exports */
-    NtUserExitingThread,
-    NtUserThreadDetach,
-};
-
-static inline BOOL NtUserDestroyCaret(void)
-{
-    return NtUserCallNoParam( NtUserCallNoParam_DestroyCaret );
-}
-
-static inline HWND NtUserGetDesktopWindow(void)
-{
-    return UlongToHandle( NtUserCallNoParam( NtUserCallNoParam_GetDesktopWindow ));
-}
-
-static inline BOOL NtUserGetInputState(void)
-{
-    return NtUserCallNoParam( NtUserCallNoParam_GetInputState );
-}
-
-static inline BOOL NtUserReleaseCapture(void)
-{
-    return NtUserCallNoParam( NtUserCallNoParam_ReleaseCapture );
-}
-
-/* NtUserCallOneParam codes, not compatible with Windows */
-enum
-{
-    NtUserCallOneParam_BeginDeferWindowPos,
-    NtUserCallOneParam_CreateCursorIcon,
-    NtUserCallOneParam_CreateMenu,
-    NtUserCallOneParam_DispatchMessageA,
-    NtUserCallOneParam_EnableDC,
-    NtUserCallOneParam_EnableThunkLock,
-    NtUserCallOneParam_EnumClipboardFormats,
-    NtUserCallOneParam_GetClipCursor,
-    NtUserCallOneParam_GetCursorPos,
-    NtUserCallOneParam_GetIconParam,
-    NtUserCallOneParam_GetMenuItemCount,
-    NtUserCallOneParam_GetPrimaryMonitorRect,
-    NtUserCallOneParam_GetSysColor,
-    NtUserCallOneParam_GetSysColorBrush,
-    NtUserCallOneParam_GetSysColorPen,
-    NtUserCallOneParam_GetSystemMetrics,
-    NtUserCallOneParam_GetVirtualScreenRect,
-    NtUserCallOneParam_IsWindowRectFullScreen,
-    NtUserCallOneParam_MessageBeep,
-    NtUserCallOneParam_RealizePalette,
-    NtUserCallOneParam_SetCaretBlinkTime,
-    /* temporary exports */
-    NtUserCallHooks,
-    NtUserGetDeskPattern,
-    NtUserGetWinProcPtr,
-    NtUserLock,
-    NtUserSetCallbacks,
-    NtUserSpyGetVKeyName,
-};
-
-static inline HDWP NtUserBeginDeferWindowPos( INT count )
-{
-    return UlongToHandle( NtUserCallOneParam( count, NtUserCallOneParam_BeginDeferWindowPos ));
-}
-
-static inline HICON NtUserCreateCursorIcon( BOOL is_icon )
-{
-    return UlongToHandle( NtUserCallOneParam( is_icon, NtUserCallOneParam_CreateCursorIcon ));
-}
-
-static inline HMENU NtUserCreateMenu( BOOL is_popup )
-{
-    return UlongToHandle( NtUserCallOneParam( is_popup, NtUserCallOneParam_CreateMenu ));
-}
-
-static inline LRESULT NtUserDispatchMessageA( const MSG *msg )
-{
-    return NtUserCallOneParam( (UINT_PTR)msg, NtUserCallOneParam_DispatchMessageA );
-}
-
-static inline WORD NtUserEnableDC( HDC hdc )
-{
-    return NtUserCallOneParam( HandleToUlong(hdc), NtUserCallOneParam_EnableDC );
-}
-
-static inline void NtUserEnableThunkLock( BOOL enable )
-{
-    NtUserCallOneParam( enable, NtUserCallOneParam_EnableThunkLock );
-}
-
-static inline UINT NtUserEnumClipboardFormats( UINT format )
-{
-    return NtUserCallOneParam( format, NtUserCallOneParam_EnumClipboardFormats );
-}
-
-static inline BOOL NtUserGetClipCursor( RECT *rect )
-{
-    return NtUserCallOneParam( (UINT_PTR)rect, NtUserCallOneParam_GetClipCursor );
-}
-
-static inline BOOL NtUserGetCursorPos( POINT *pt )
-{
-    return NtUserCallOneParam( (UINT_PTR)pt, NtUserCallOneParam_GetCursorPos );
-}
-
-static inline UINT_PTR NtUserGetIconParam( HICON icon )
-{
-    return NtUserCallOneParam( HandleToUlong(icon), NtUserCallOneParam_GetIconParam );
-}
-
-static inline UINT_PTR NtUserGetMenuItemCount( HMENU menu )
-{
-    return NtUserCallOneParam( HandleToUlong(menu), NtUserCallOneParam_GetMenuItemCount );
-}
-
-static inline RECT NtUserGetPrimaryMonitorRect(void)
-{
-    RECT primary;
-    NtUserCallOneParam( (UINT_PTR)&primary, NtUserCallOneParam_GetPrimaryMonitorRect );
-    return primary;
-}
-
-static inline BOOL NtUserSetCaretBlinkTime( unsigned int time )
-{
-    return NtUserCallOneParam( time, NtUserCallOneParam_SetCaretBlinkTime );
-}
-
-static inline COLORREF NtUserGetSysColor( INT index )
-{
-    return NtUserCallOneParam( index, NtUserCallOneParam_GetSysColor );
-}
-
-static inline HBRUSH NtUserGetSysColorBrush( INT index )
-{
-    return UlongToHandle( NtUserCallOneParam( index, NtUserCallOneParam_GetSysColorBrush ));
-}
-
-static inline HPEN NtUserGetSysColorPen( INT index )
-{
-    return UlongToHandle( NtUserCallOneParam( index, NtUserCallOneParam_GetSysColorPen ));
-}
-
-static inline INT NtUserGetSystemMetrics( INT index )
-{
-    return NtUserCallOneParam( index, NtUserCallOneParam_GetSystemMetrics );
-}
-
-static inline RECT NtUserGetVirtualScreenRect(void)
-{
-    RECT virtual;
-    NtUserCallOneParam( (UINT_PTR)&virtual, NtUserCallOneParam_GetVirtualScreenRect );
-    return virtual;
-}
-
-static inline BOOL NtUserIsWindowRectFullScreen( const RECT *rect )
-{
-    return NtUserCallOneParam( (UINT_PTR)rect, NtUserCallOneParam_IsWindowRectFullScreen );
-}
-
-static inline BOOL NtUserMessageBeep( UINT i )
-{
-    return NtUserCallOneParam( i, NtUserCallOneParam_MessageBeep );
-}
-
-static inline UINT NtUserRealizePalette( HDC hdc )
-{
-    return NtUserCallOneParam( HandleToUlong(hdc), NtUserCallOneParam_RealizePalette );
-}
-
-/* NtUserCallTwoParam codes, not compatible with Windows */
-enum
-{
-    NtUserCallTwoParam_GetMenuInfo,
-    NtUserCallTwoParam_GetMonitorInfo,
-    NtUserCallTwoParam_GetSystemMetricsForDpi,
-    NtUserCallTwoParam_MonitorFromRect,
-    NtUserCallTwoParam_ReplyMessage,
-    NtUserCallTwoParam_SetCaretPos,
-    NtUserCallTwoParam_SetIconParam,
-    NtUserCallTwoParam_UnhookWindowsHook,
-    /* temporary exports */
-    NtUserAllocWinProc,
-    NtUserGetHandlePtr,
-};
-
-static inline BOOL NtUserGetMenuInfo( HMENU menu, MENUINFO *info )
-{
-    return NtUserCallTwoParam( HandleToUlong(menu), (ULONG_PTR)info,
-                               NtUserCallTwoParam_GetMenuInfo );
-}
-
-static inline BOOL NtUserGetMonitorInfo( HMONITOR monitor, MONITORINFO *info )
-{
-    return NtUserCallTwoParam( HandleToUlong(monitor), (ULONG_PTR)info,
-                               NtUserCallTwoParam_GetMonitorInfo );
-}
-
-static inline INT NtUserGetSystemMetricsForDpi( INT index, UINT dpi )
-{
-    return NtUserCallTwoParam( index, dpi, NtUserCallTwoParam_GetSystemMetricsForDpi );
-}
-
-static inline HMONITOR NtUserMonitorFromRect( const RECT *rect, DWORD flags )
-{
-    ULONG ret = NtUserCallTwoParam( (LONG_PTR)rect, flags, NtUserCallTwoParam_MonitorFromRect );
-    return UlongToHandle( ret );
-}
-
-static inline BOOL NtUserReplyMessage( LRESULT result, MSG *msg )
-{
-    return NtUserCallTwoParam( result, (UINT_PTR)msg, NtUserCallTwoParam_ReplyMessage );
-}
-
-static inline BOOL NtUserSetCaretPos( int x, int y )
-{
-    return NtUserCallTwoParam( x, y, NtUserCallTwoParam_SetCaretPos );
-}
-
-static inline UINT_PTR NtUserSetIconParam( HICON icon, ULONG_PTR param )
-{
-    return NtUserCallTwoParam( HandleToUlong(icon), param, NtUserCallTwoParam_SetIconParam );
-}
-
-static inline BOOL NtUserUnhookWindowsHook( INT id, HOOKPROC proc )
-{
-    return NtUserCallTwoParam( id, (UINT_PTR)proc, NtUserCallTwoParam_UnhookWindowsHook );
-}
-
-/* NtUserCallHwnd codes, not compatible with Windows */
-enum
-{
-    NtUserCallHwnd_ArrangeIconicWindows,
-    NtUserCallHwnd_DrawMenuBar,
-    NtUserCallHwnd_GetDpiForWindow,
-    NtUserCallHwnd_GetParent,
-    NtUserCallHwnd_GetWindowContextHelpId,
-    NtUserCallHwnd_GetWindowDpiAwarenessContext,
-    NtUserCallHwnd_GetWindowTextLength,
-    NtUserCallHwnd_IsWindow,
-    NtUserCallHwnd_IsWindowEnabled,
-    NtUserCallHwnd_IsWindowUnicode,
-    NtUserCallHwnd_IsWindowVisible,
-};
-
-static inline UINT NtUserArrangeIconicWindows( HWND parent )
-{
-    return NtUserCallHwnd( parent, NtUserCallHwnd_ArrangeIconicWindows );
-}
-
-static inline BOOL NtUserDrawMenuBar( HWND hwnd )
-{
-    return NtUserCallHwnd( hwnd, NtUserCallHwnd_DrawMenuBar );
-}
-
-static inline DWORD NtUserGetWindowContextHelpId( HWND hwnd )
-{
-    return NtUserCallHwnd( hwnd, NtUserCallHwnd_GetWindowContextHelpId );
-}
-
-static inline UINT NtUserGetDpiForWindow( HWND hwnd )
-{
-    return NtUserCallHwnd( hwnd, NtUserCallHwnd_GetDpiForWindow );
-}
-
-static inline HWND NtUserGetParent( HWND hwnd )
-{
-    return UlongToHandle( NtUserCallHwnd( hwnd, NtUserCallHwnd_GetParent ));
-}
-
-static inline DPI_AWARENESS_CONTEXT NtUserGetWindowDpiAwarenessContext( HWND hwnd )
-{
-    return (DPI_AWARENESS_CONTEXT)NtUserCallHwnd( hwnd,
-                                                  NtUserCallHwnd_GetWindowDpiAwarenessContext );
-}
-
-static inline INT NtUserGetWindowTextLength( HWND hwnd )
-{
-    return NtUserCallHwnd( hwnd, NtUserCallHwnd_GetWindowTextLength );
-}
-
-static inline BOOL NtUserIsWindow( HWND hwnd )
-{
-    return NtUserCallHwnd( hwnd, NtUserCallHwnd_IsWindow );
-}
-
-static inline BOOL NtUserIsWindowEnabled( HWND hwnd )
-{
-    return NtUserCallHwnd( hwnd, NtUserCallHwnd_IsWindowEnabled );
-}
-
-static inline BOOL NtUserIsWindowUnicode( HWND hwnd )
-{
-    return NtUserCallHwnd( hwnd, NtUserCallHwnd_IsWindowUnicode );
-}
-
-static inline BOOL NtUserIsWindowVisible( HWND hwnd )
-{
-    return NtUserCallHwnd( hwnd, NtUserCallHwnd_IsWindowVisible );
-}
-
-/* NtUserCallHwndParam codes, not compatible with Windows */
-enum
-{
-    NtUserCallHwndParam_ClientToScreen,
-    NtUserCallHwndParam_EnableWindow,
-    NtUserCallHwndParam_GetClassLongA,
-    NtUserCallHwndParam_GetClassLongW,
-    NtUserCallHwndParam_GetClassLongPtrA,
-    NtUserCallHwndParam_GetClassLongPtrW,
-    NtUserCallHwndParam_GetClassWord,
-    NtUserCallHwndParam_GetClientRect,
-    NtUserCallHwndParam_GetMinMaxInfo,
-    NtUserCallHwndParam_GetWindowInfo,
-    NtUserCallHwndParam_GetWindowLongA,
-    NtUserCallHwndParam_GetWindowLongW,
-    NtUserCallHwndParam_GetWindowLongPtrA,
-    NtUserCallHwndParam_GetWindowLongPtrW,
-    NtUserCallHwndParam_GetWindowRect,
-    NtUserCallHwndParam_GetWindowRelative,
-    NtUserCallHwndParam_GetWindowThread,
-    NtUserCallHwndParam_GetWindowWord,
-    NtUserCallHwndParam_IsChild,
-    NtUserCallHwndParam_KillSystemTimer,
-    NtUserCallHwndParam_MapWindowPoints,
-    NtUserCallHwndParam_MirrorRgn,
-    NtUserCallHwndParam_MonitorFromWindow,
-    NtUserCallHwndParam_ScreenToClient,
-    NtUserCallHwndParam_SetForegroundWindow,
-    NtUserCallHwndParam_SetWindowPixelFormat,
-    NtUserCallHwndParam_ShowOwnedPopups,
-    /* temporary exports */
-    NtUserIsWindowDrawable,
-    NtUserSetCaptureWindow,
-    NtUserSetWindowStyle,
-    NtUserSpyGetMsgName,
-};
-
-static inline BOOL NtUserClientToScreen( HWND hwnd, POINT *pt )
-{
-    return NtUserCallHwndParam( hwnd, (UINT_PTR)pt, NtUserCallHwndParam_ClientToScreen );
-}
-
-static inline BOOL NtUserEnableWindow( HWND hwnd, BOOL enable )
-{
-    return NtUserCallHwndParam( hwnd, enable, NtUserCallHwndParam_EnableWindow );
-}
-
-static inline DWORD NtUserGetClassLongA( HWND hwnd, INT offset )
-{
-    return NtUserCallHwndParam( hwnd, offset, NtUserCallHwndParam_GetClassLongA );
-}
-
-static inline ULONG_PTR NtUserGetClassLongPtrA( HWND hwnd, INT offset )
-{
-    return NtUserCallHwndParam( hwnd, offset, NtUserCallHwndParam_GetClassLongPtrA );
-}
-
-static inline ULONG_PTR NtUserGetClassLongPtrW( HWND hwnd, INT offset )
-{
-    return NtUserCallHwndParam( hwnd, offset, NtUserCallHwndParam_GetClassLongPtrW );
-}
-
-static inline DWORD NtUserGetClassLongW( HWND hwnd, INT offset )
-{
-    return NtUserCallHwndParam( hwnd, offset, NtUserCallHwndParam_GetClassLongW );
-}
-
-static inline WORD NtUserGetClassWord( HWND hwnd, INT offset )
-{
-    return NtUserCallHwndParam( hwnd, offset, NtUserCallHwndParam_GetClassWord );
-}
-
-static inline BOOL NtUserGetClientRect( HWND hwnd, RECT *rect )
-{
-    return NtUserCallHwndParam( hwnd, (UINT_PTR)rect, NtUserCallHwndParam_GetClientRect );
-}
-
-static inline MINMAXINFO NtUserGetMinMaxInfo( HWND hwnd )
-{
-    MINMAXINFO info;
-    NtUserCallHwndParam( hwnd, (UINT_PTR)&info, NtUserCallHwndParam_GetMinMaxInfo );
-    return info;
-}
-
-static inline BOOL NtUserGetWindowInfo( HWND hwnd, WINDOWINFO *info )
-{
-    return NtUserCallHwndParam( hwnd, (UINT_PTR)info, NtUserCallHwndParam_GetWindowInfo );
-}
-
-static inline LONG NtUserGetWindowLongA( HWND hwnd, INT offset )
-{
-    return NtUserCallHwndParam( hwnd, offset, NtUserCallHwndParam_GetWindowLongA );
-}
-
-static inline LONG_PTR NtUserGetWindowLongPtrA( HWND hwnd, INT offset )
-{
-    return NtUserCallHwndParam( hwnd, offset, NtUserCallHwndParam_GetWindowLongPtrA );
-}
-
-static inline LONG_PTR NtUserGetWindowLongPtrW( HWND hwnd, INT offset )
-{
-    return NtUserCallHwndParam( hwnd, offset, NtUserCallHwndParam_GetWindowLongPtrW );
-}
-
-static inline LONG NtUserGetWindowLongW( HWND hwnd, INT offset )
-{
-    return NtUserCallHwndParam( hwnd, offset, NtUserCallHwndParam_GetWindowLongW );
-}
-
-static inline BOOL NtUserGetWindowRect( HWND hwnd, RECT *rect )
-{
-    return NtUserCallHwndParam( hwnd, (UINT_PTR)rect, NtUserCallHwndParam_GetWindowRect );
-}
-
-static inline HWND NtUserGetWindowRelative( HWND hwnd, UINT rel )
-{
-    return UlongToHandle( NtUserCallHwndParam( hwnd, rel,
-                                               NtUserCallHwndParam_GetWindowRelative ));
-}
-
-static inline DWORD NtUserGetWindowThread( HWND hwnd, DWORD *process )
-{
-    return NtUserCallHwndParam( hwnd, (UINT_PTR)process, NtUserCallHwndParam_GetWindowThread );
-}
-
-static inline WORD NtUserGetWindowWord( HWND hwnd, INT offset )
-{
-    return NtUserCallHwndParam( hwnd, offset, NtUserCallHwndParam_GetWindowWord );
-}
-
-static inline BOOL NtUserIsChild( HWND parent, HWND child )
-{
-    return NtUserCallHwndParam( parent, HandleToUlong(child), NtUserCallHwndParam_IsChild );
-}
-
-static inline BOOL NtUserKillSystemTimer( HWND hwnd, UINT_PTR id )
-{
-    return NtUserCallHwndParam( hwnd, id, NtUserCallHwndParam_KillSystemTimer );
-}
-
-struct map_window_points_params
-{
-    HWND hwnd_to;
-    POINT *points;
-    UINT count;
-};
-
-static inline int NtUserMapWindowPoints( HWND hwnd_from, HWND hwnd_to, POINT *points, UINT count )
-{
-    struct map_window_points_params params;
-    params.hwnd_to = hwnd_to;
-    params.points = points;
-    params.count = count;
-    return NtUserCallHwndParam( hwnd_from, (UINT_PTR)&params,
-                                NtUserCallHwndParam_MapWindowPoints );
-}
-
-static inline BOOL NtUserMirrorRgn( HWND hwnd, HRGN hrgn )
-{
-    return NtUserCallHwndParam( hwnd, HandleToUlong(hrgn), NtUserCallHwndParam_MirrorRgn );
-}
-
-static inline HMONITOR NtUserMonitorFromWindow( HWND hwnd, DWORD flags )
-{
-    ULONG ret = NtUserCallHwndParam(  hwnd, flags, NtUserCallHwndParam_MonitorFromWindow );
-    return UlongToHandle( ret );
-}
-
-static inline BOOL NtUserScreenToClient( HWND hwnd, POINT *pt )
-{
-    return NtUserCallHwndParam( hwnd, (UINT_PTR)pt, NtUserCallHwndParam_ScreenToClient );
-}
-
-static inline BOOL NtUserSetForegroundWindow( HWND hwnd, BOOL mouse )
-{
-    return NtUserCallHwndParam( hwnd, mouse, NtUserCallHwndParam_SetForegroundWindow );
-}
-
-static inline BOOL NtUserSetWindowPixelFormat( HWND hwnd, int format )
-{
-    return NtUserCallHwndParam( hwnd, format, NtUserCallHwndParam_SetWindowPixelFormat );
-}
-
-static inline BOOL NtUserShowOwnedPopups( HWND hwnd, BOOL show )
-{
-    return NtUserCallHwndParam( hwnd, show, NtUserCallHwndParam_ShowOwnedPopups );
-}
-
 #endif /* _NTUSER_ */
diff --git a/include/processthreadsapi.h b/include/processthreadsapi.h
index f2554950952..d266b7a727b 100644
--- a/include/processthreadsapi.h
+++ b/include/processthreadsapi.h
@@ -37,13 +37,6 @@ typedef struct _MEMORY_PRIORITY_INFORMATION
     ULONG MemoryPriority;
 } MEMORY_PRIORITY_INFORMATION, *PMEMORY_PRIORITY_INFORMATION;
 
-typedef struct _THREAD_POWER_THROTTLING_STATE
-{
-    ULONG Version;
-    ULONG ControlMask;
-    ULONG StateMask;
-} THREAD_POWER_THROTTLING_STATE;
-
 WINBASEAPI HRESULT WINAPI GetThreadDescription(HANDLE,PWSTR *);
 WINBASEAPI HRESULT WINAPI SetThreadDescription(HANDLE,PCWSTR);
 WINBASEAPI BOOL WINAPI SetThreadInformation(HANDLE,THREAD_INFORMATION_CLASS,LPVOID,DWORD);
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index 52fd6fe49d3..b3c77a1d2c1 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -158,9 +158,6 @@ struct gdi_dc_funcs
     BOOL     (CDECL *pStrokePath)(PHYSDEV);
     BOOL     (CDECL *pUnrealizePalette)(HPALETTE);
     NTSTATUS (CDECL *pD3DKMTCheckVidPnExclusiveOwnership)(const D3DKMT_CHECKVIDPNEXCLUSIVEOWNERSHIP *);
-    NTSTATUS (CDECL *pD3DKMTCloseAdapter)(const D3DKMT_CLOSEADAPTER *);
-    NTSTATUS (CDECL *pD3DKMTOpenAdapterFromLuid)(D3DKMT_OPENADAPTERFROMLUID *);
-    NTSTATUS (CDECL *pD3DKMTQueryVideoMemoryInfo)(D3DKMT_QUERYVIDEOMEMORYINFO *);
     NTSTATUS (CDECL *pD3DKMTSetVidPnSourceOwner)(const D3DKMT_SETVIDPNSOURCEOWNER *);
 
     /* priority order for the driver on the stack */
@@ -168,7 +165,7 @@ struct gdi_dc_funcs
 };
 
 /* increment this when you change the DC function table */
-#define WINE_GDI_DRIVER_VERSION 79
+#define WINE_GDI_DRIVER_VERSION 75
 
 #define GDI_PRIORITY_NULL_DRV        0  /* null driver */
 #define GDI_PRIORITY_FONT_DRV      100  /* any font driver */
@@ -198,17 +195,15 @@ static inline void push_dc_driver( PHYSDEV *dev, PHYSDEV physdev, const struct g
 
 struct window_surface;
 
-#ifndef __WINE_USE_MSVCRT
-
 struct window_surface_funcs
 {
-    void  (*lock)( struct window_surface *surface );
-    void  (*unlock)( struct window_surface *surface );
-    void* (*get_info)( struct window_surface *surface, BITMAPINFO *info );
-    RECT* (*get_bounds)( struct window_surface *surface );
-    void  (*set_region)( struct window_surface *surface, HRGN region );
-    void  (*flush)( struct window_surface *surface );
-    void  (*destroy)( struct window_surface *surface );
+    void  (CDECL *lock)( struct window_surface *surface );
+    void  (CDECL *unlock)( struct window_surface *surface );
+    void* (CDECL *get_info)( struct window_surface *surface, BITMAPINFO *info );
+    RECT* (CDECL *get_bounds)( struct window_surface *surface );
+    void  (CDECL *set_region)( struct window_surface *surface, HRGN region );
+    void  (CDECL *flush)( struct window_surface *surface );
+    void  (CDECL *destroy)( struct window_surface *surface );
 };
 
 struct window_surface
@@ -275,68 +270,66 @@ struct user_driver_funcs
     struct gdi_dc_funcs dc_funcs;
 
     /* keyboard functions */
-    BOOL    (*pActivateKeyboardLayout)(HKL, UINT);
-    void    (*pBeep)(void);
-    INT     (*pGetKeyNameText)(LONG,LPWSTR,INT);
-    UINT    (*pGetKeyboardLayoutList)(INT, HKL *);
-    UINT    (*pMapVirtualKeyEx)(UINT,UINT,HKL);
-    BOOL    (*pRegisterHotKey)(HWND,UINT,UINT);
-    INT     (*pToUnicodeEx)(UINT,UINT,const BYTE *,LPWSTR,int,UINT,HKL);
-    void    (*pUnregisterHotKey)(HWND, UINT, UINT);
-    SHORT   (*pVkKeyScanEx)(WCHAR, HKL);
+    BOOL    (CDECL *pActivateKeyboardLayout)(HKL, UINT);
+    void    (CDECL *pBeep)(void);
+    INT     (CDECL *pGetKeyNameText)(LONG,LPWSTR,INT);
+    UINT    (CDECL *pGetKeyboardLayoutList)(INT, HKL *);
+    UINT    (CDECL *pMapVirtualKeyEx)(UINT,UINT,HKL);
+    BOOL    (CDECL *pRegisterHotKey)(HWND,UINT,UINT);
+    INT     (CDECL *pToUnicodeEx)(UINT,UINT,const BYTE *,LPWSTR,int,UINT,HKL);
+    void    (CDECL *pUnregisterHotKey)(HWND, UINT, UINT);
+    SHORT   (CDECL *pVkKeyScanEx)(WCHAR, HKL);
     /* cursor/icon functions */
-    void    (*pDestroyCursorIcon)(HCURSOR);
-    void    (*pSetCursor)(HCURSOR);
-    BOOL    (*pGetCursorPos)(LPPOINT);
-    BOOL    (*pSetCursorPos)(INT,INT);
-    BOOL    (*pClipCursor)(LPCRECT);
+    void    (CDECL *pDestroyCursorIcon)(HCURSOR);
+    void    (CDECL *pSetCursor)(HCURSOR);
+    BOOL    (CDECL *pGetCursorPos)(LPPOINT);
+    BOOL    (CDECL *pSetCursorPos)(INT,INT);
+    BOOL    (CDECL *pClipCursor)(LPCRECT);
     /* clipboard functions */
-    LRESULT (*pClipboardWindowProc)(HWND,UINT,WPARAM,LPARAM);
-    void    (*pUpdateClipboard)(void);
+    void    (CDECL *pUpdateClipboard)(void);
     /* display modes */
-    LONG    (*pChangeDisplaySettingsEx)(LPCWSTR,LPDEVMODEW,HWND,DWORD,LPVOID);
-    BOOL    (*pEnumDisplaySettingsEx)(LPCWSTR,DWORD,LPDEVMODEW,DWORD);
-    void    (*pUpdateDisplayDevices)(const struct gdi_device_manager *,BOOL,void*);
+    LONG    (CDECL *pChangeDisplaySettingsEx)(LPCWSTR,LPDEVMODEW,HWND,DWORD,LPVOID);
+    BOOL    (CDECL *pEnumDisplaySettingsEx)(LPCWSTR,DWORD,LPDEVMODEW,DWORD);
+    void    (CDECL *pUpdateDisplayDevices)(const struct gdi_device_manager *,BOOL,void*);
     /* windowing functions */
-    BOOL    (*pCreateDesktopWindow)(HWND);
-    BOOL    (*pCreateWindow)(HWND);
-    LRESULT (*pDesktopWindowProc)(HWND,UINT,WPARAM,LPARAM);
-    void    (*pDestroyWindow)(HWND);
-    void    (*pFlashWindowEx)(FLASHWINFO*);
-    void    (*pGetDC)(HDC,HWND,HWND,const RECT *,const RECT *,DWORD);
-    NTSTATUS (*pMsgWaitForMultipleObjectsEx)(DWORD,const HANDLE*,const LARGE_INTEGER*,DWORD,DWORD);
-    void    (*pReleaseDC)(HWND,HDC);
-    BOOL    (*pScrollDC)(HDC,INT,INT,HRGN);
-    void    (*pSetCapture)(HWND,UINT);
-    void    (*pSetFocus)(HWND);
-    void    (*pSetLayeredWindowAttributes)(HWND,COLORREF,BYTE,DWORD);
-    void    (*pSetParent)(HWND,HWND,HWND);
-    void    (*pSetWindowRgn)(HWND,HRGN,BOOL);
-    void    (*pSetWindowIcon)(HWND,UINT,HICON);
-    void    (*pSetWindowStyle)(HWND,INT,STYLESTRUCT*);
-    void    (*pSetWindowText)(HWND,LPCWSTR);
-    UINT    (*pShowWindow)(HWND,INT,RECT*,UINT);
-    LRESULT (*pSysCommand)(HWND,WPARAM,LPARAM);
-    BOOL    (*pUpdateLayeredWindow)(HWND,const struct tagUPDATELAYEREDWINDOWINFO *,const RECT *);
-    LRESULT (*pWindowMessage)(HWND,UINT,WPARAM,LPARAM);
-    BOOL    (*pWindowPosChanging)(HWND,HWND,UINT,const RECT *,const RECT *,RECT *,
-                                  struct window_surface**);
-    void    (*pWindowPosChanged)(HWND,HWND,UINT,const RECT *,const RECT *,const RECT *,
-                                 const RECT *,struct window_surface*);
+    BOOL    (CDECL *pCreateDesktopWindow)(HWND);
+    BOOL    (CDECL *pCreateWindow)(HWND);
+    void    (CDECL *pDestroyWindow)(HWND);
+    void    (CDECL *pFlashWindowEx)(FLASHWINFO*);
+    void    (CDECL *pGetDC)(HDC,HWND,HWND,const RECT *,const RECT *,DWORD);
+    DWORD   (CDECL *pMsgWaitForMultipleObjectsEx)(DWORD,const HANDLE*,DWORD,DWORD,DWORD);
+    void    (CDECL *pReleaseDC)(HWND,HDC);
+    BOOL    (CDECL *pScrollDC)(HDC,INT,INT,HRGN);
+    void    (CDECL *pSetCapture)(HWND,UINT);
+    void    (CDECL *pSetFocus)(HWND);
+    void    (CDECL *pSetLayeredWindowAttributes)(HWND,COLORREF,BYTE,DWORD);
+    void    (CDECL *pSetParent)(HWND,HWND,HWND);
+    void    (CDECL *pSetWindowRgn)(HWND,HRGN,BOOL);
+    void    (CDECL *pSetWindowIcon)(HWND,UINT,HICON);
+    void    (CDECL *pSetWindowStyle)(HWND,INT,STYLESTRUCT*);
+    void    (CDECL *pSetWindowText)(HWND,LPCWSTR);
+    UINT    (CDECL *pShowWindow)(HWND,INT,RECT*,UINT);
+    LRESULT (CDECL *pSysCommand)(HWND,WPARAM,LPARAM);
+    BOOL    (CDECL *pUpdateLayeredWindow)(HWND,const struct tagUPDATELAYEREDWINDOWINFO *,const RECT *);
+    LRESULT (CDECL *pWindowMessage)(HWND,UINT,WPARAM,LPARAM);
+    BOOL    (CDECL *pWindowPosChanging)(HWND,HWND,UINT,const RECT *,const RECT *,RECT *,
+                                        struct window_surface**);
+    void    (CDECL *pWindowPosChanged)(HWND,HWND,UINT,const RECT *,const RECT *,const RECT *,
+                                       const RECT *,struct window_surface*);
     /* system parameters */
-    BOOL    (*pSystemParametersInfo)(UINT,UINT,void*,UINT);
+    BOOL    (CDECL *pSystemParametersInfo)(UINT,UINT,void*,UINT);
     /* vulkan support */
-    const struct vulkan_funcs * (*pwine_get_vulkan_driver)(UINT);
+    const struct vulkan_funcs * (CDECL *pwine_get_vulkan_driver)(UINT);
     /* opengl support */
-    struct opengl_funcs * (*pwine_get_wgl_driver)(UINT);
+    struct opengl_funcs * (CDECL *pwine_get_wgl_driver)(UINT);
     /* thread management */
-    void    (*pThreadDetach)(void);
+    void    (CDECL *pThreadDetach)(void);
 };
 
-#endif /* __WINE_USE_MSVCRT */
-
-struct user_driver_funcs;
 extern void CDECL __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT version );
+extern void CDECL __wine_set_visible_region( HDC hdc, HRGN hrgn, const RECT *vis_rect,
+                                             const RECT *device_rect, struct window_surface *surface );
+extern void CDECL __wine_set_display_driver( struct user_driver_funcs *funcs, UINT version );
 extern struct opengl_funcs * CDECL __wine_get_wgl_driver( HDC hdc, UINT version );
 extern const struct vulkan_funcs * CDECL __wine_get_vulkan_driver( UINT version );
 
diff --git a/include/wine/unixlib.h b/include/wine/unixlib.h
index ef60b32184c..a7cfb8f6cab 100644
--- a/include/wine/unixlib.h
+++ b/include/wine/unixlib.h
@@ -84,11 +84,6 @@ NTSTATUS WINAPI KeUserModeCallback( ULONG id, const void *args, ULONG len, void
 
 /* wide char string functions */
 
-static inline int ntdll_iswspace( WCHAR wc )
-{
-    return ('\t' <= wc && wc <= '\r') || wc == ' ' || wc == 0xa0;
-}
-
 static inline size_t ntdll_wcslen( const WCHAR *str )
 {
     const WCHAR *s = str;
@@ -155,100 +150,6 @@ static inline SIZE_T ntdll_wcscspn( const WCHAR *str, const WCHAR *reject )
     return ptr - str;
 }
 
-static inline LONG ntdll_wcstol( const WCHAR *s, WCHAR **end, int base )
-{
-    BOOL negative = FALSE, empty = TRUE;
-    LONG ret = 0;
-
-    if (base < 0 || base == 1 || base > 36) return 0;
-    if (end) *end = (WCHAR *)s;
-    while (ntdll_iswspace(*s)) s++;
-
-    if (*s == '-')
-    {
-        negative = TRUE;
-        s++;
-    }
-    else if (*s == '+') s++;
-
-    if ((base == 0 || base == 16) && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
-    {
-        base = 16;
-        s += 2;
-    }
-    if (base == 0) base = s[0] != '0' ? 10 : 8;
-
-    while (*s)
-    {
-        int v;
-
-        if ('0' <= *s && *s <= '9') v = *s - '0';
-        else if ('A' <= *s && *s <= 'Z') v = *s - 'A' + 10;
-        else if ('a' <= *s && *s <= 'z') v = *s - 'a' + 10;
-        else break;
-        if (v >= base) break;
-        if (negative) v = -v;
-        s++;
-        empty = FALSE;
-
-        if (!negative && (ret > MAXLONG / base || ret * base > MAXLONG - v))
-            ret = MAXLONG;
-        else if (negative && (ret < (LONG)MINLONG / base || ret * base < (LONG)(MINLONG - v)))
-            ret = MINLONG;
-        else
-            ret = ret * base + v;
-    }
-
-    if (end && !empty) *end = (WCHAR *)s;
-    return ret;
-}
-
-static inline ULONG ntdll_wcstoul( const WCHAR *s, WCHAR **end, int base )
-{
-    BOOL negative = FALSE, empty = TRUE;
-    ULONG ret = 0;
-
-    if (base < 0 || base == 1 || base > 36) return 0;
-    if (end) *end = (WCHAR *)s;
-    while (ntdll_iswspace(*s)) s++;
-
-    if (*s == '-')
-    {
-        negative = TRUE;
-        s++;
-    }
-    else if (*s == '+') s++;
-
-    if ((base == 0 || base == 16) && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'))
-    {
-        base = 16;
-        s += 2;
-    }
-    if (base == 0) base = s[0] != '0' ? 10 : 8;
-
-    while (*s)
-    {
-        int v;
-
-        if ('0' <= *s && *s <= '9') v = *s - '0';
-        else if ('A' <= *s && *s <= 'Z') v = *s - 'A' + 10;
-        else if ('a' <= *s && *s <= 'z') v = *s - 'a' + 10;
-        else break;
-        if (v >= base) break;
-        s++;
-        empty = FALSE;
-
-        if (ret > MAXDWORD / base || ret * base > MAXDWORD - v)
-            ret = MAXDWORD;
-        else
-            ret = ret * base + v;
-    }
-
-    if (end && !empty) *end = (WCHAR *)s;
-    return negative ? -ret : ret;
-}
-
-#define iswspace(ch)       ntdll_iswspace(ch)
 #define wcslen(str)        ntdll_wcslen(str)
 #define wcscpy(dst,src)    ntdll_wcscpy(dst,src)
 #define wcscat(dst,src)    ntdll_wcscat(dst,src)
@@ -261,8 +162,6 @@ static inline ULONG ntdll_wcstoul( const WCHAR *s, WCHAR **end, int base )
 #define wcscspn(str,rej)   ntdll_wcscspn(str,rej)
 #define wcsicmp(s1, s2)    ntdll_wcsicmp(s1,s2)
 #define wcsnicmp(s1, s2,n) ntdll_wcsnicmp(s1,s2,n)
-#define wcstol(str,e,b)    ntdll_wcstol(str,e,b)
-#define wcstoul(str,e,b)   ntdll_wcstoul(str,e,b)
 
 #endif /* WINE_UNIX_LIB */
 
diff --git a/include/wine/wgl_driver.h b/include/wine/wgl_driver.h
index 36b1f384ddf..f077a3d0f09 100644
--- a/include/wine/wgl_driver.h
+++ b/include/wine/wgl_driver.h
@@ -3406,5 +3406,6 @@ struct opengl_funcs
     USE_GL_FUNC(glViewport)
 
 extern struct opengl_funcs * CDECL __wine_get_wgl_driver( HDC hdc, UINT version );
+extern BOOL CDECL __wine_set_pixel_format( HWND hwnd, int format );
 
 #endif /* __WINE_WGL_DRIVER_H */
diff --git a/include/wine/wined3d.h b/include/wine/wined3d.h
index 116aea82348..ee241ab3b1d 100644
--- a/include/wine/wined3d.h
+++ b/include/wine/wined3d.h
@@ -876,12 +876,6 @@ enum wined3d_pipeline
     WINED3D_PIPELINE_COUNT,
 };
 
-enum wined3d_memory_segment_group
-{
-    WINED3D_MEMORY_SEGMENT_GROUP_LOCAL = 0,
-    WINED3D_MEMORY_SEGMENT_GROUP_NON_LOCAL = 1,
-};
-
 #define WINED3DCOLORWRITEENABLE_RED                             (1u << 0)
 #define WINED3DCOLORWRITEENABLE_GREEN                           (1u << 1)
 #define WINED3DCOLORWRITEENABLE_BLUE                            (1u << 2)
@@ -1771,14 +1765,6 @@ struct wined3d_adapter_identifier
     SIZE_T shared_system_memory;
 };
 
-struct wined3d_video_memory_info
-{
-    UINT64 budget;
-    UINT64 current_usage;
-    UINT64 current_reservation;
-    UINT64 available_reservation;
-};
-
 struct wined3d_swapchain_desc
 {
     struct wined3d_output *output;
@@ -2361,12 +2347,6 @@ HRESULT __cdecl wined3d_adapter_get_identifier(const struct wined3d_adapter *ada
 struct wined3d_output * __cdecl wined3d_adapter_get_output(const struct wined3d_adapter *adapter,
         unsigned int idx);
 unsigned int __cdecl wined3d_adapter_get_output_count(const struct wined3d_adapter *adapter);
-HRESULT __cdecl wined3d_adapter_get_video_memory_info(const struct wined3d_adapter *adapter,
-        unsigned int node_idx, enum wined3d_memory_segment_group group,
-        struct wined3d_video_memory_info *info);
-HRESULT __cdecl wined3d_adapter_register_budget_change_notification(const struct wined3d_adapter *adapter,
-        HANDLE event, DWORD *cookie);
-HRESULT __cdecl wined3d_adapter_unregister_budget_change_notification(DWORD cookie);
 
 HRESULT __cdecl wined3d_buffer_create(struct wined3d_device *device, const struct wined3d_buffer_desc *desc,
         const struct wined3d_sub_resource_data *data, void *parent, const struct wined3d_parent_ops *parent_ops,
diff --git a/include/winuser.h b/include/winuser.h
index 4e43d6c1170..05074f144fc 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -4569,7 +4569,7 @@ WINUSERAPI BOOL        WINAPI SetScrollRange(HWND,INT,INT,INT,BOOL);
 #define                       SetSysModalWindow(hwnd) ((HWND)0)
 WINUSERAPI BOOL        WINAPI SetSystemCursor(HCURSOR,DWORD);
 WINUSERAPI BOOL        WINAPI SetSystemMenu(HWND,HMENU);
-WINUSERAPI UINT_PTR    WINAPI SetSystemTimer(HWND,UINT_PTR,UINT,void*);
+WINUSERAPI UINT_PTR    WINAPI SetSystemTimer(HWND,UINT_PTR,UINT,TIMERPROC);
 WINUSERAPI BOOL        WINAPI SetThreadDesktop(HDESK);
 WINUSERAPI DPI_AWARENESS_CONTEXT WINAPI SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT);
 WINUSERAPI UINT_PTR    WINAPI SetTimer(HWND,UINT_PTR,UINT,TIMERPROC);
@@ -4794,7 +4794,7 @@ struct user_api_hook
     LRESULT (WINAPI *pScrollBarWndProc)(HWND, UINT, WPARAM, LPARAM, BOOL);
 };
 
-WINUSERAPI BOOL WINAPI RegisterUserApiHook(const struct user_api_hook *new_hook, struct user_api_hook *old_hook);
+WINUSERAPI BOOL WINAPI RegisterUserApiHook(const struct user_api_hook *new, struct user_api_hook *old);
 WINUSERAPI void WINAPI UnregisterUserApiHook(void);
 #endif
 
diff --git a/programs/explorer/Makefile.in b/programs/explorer/Makefile.in
index 3a2ddec3fd4..5507d747bb1 100644
--- a/programs/explorer/Makefile.in
+++ b/programs/explorer/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = explorer.exe
-IMPORTS   = rpcrt4 user32 gdi32 advapi32 win32u
+IMPORTS   = rpcrt4 user32 gdi32 advapi32
 DELAYIMPORTS = comctl32 shell32 oleaut32 ole32 shlwapi
 
 EXTRADLLFLAGS = -mwindows -municode
diff --git a/programs/explorer/desktop.c b/programs/explorer/desktop.c
index 96673adc254..400cc1d560e 100644
--- a/programs/explorer/desktop.c
+++ b/programs/explorer/desktop.c
@@ -29,7 +29,6 @@
 #include <rpc.h>
 #include <shlobj.h>
 #include <shellapi.h>
-#include <ntuser.h>
 #include "exdisp.h"
 
 #include "wine/debug.h"
@@ -619,91 +618,6 @@ static void initialize_launchers( HWND hwnd )
     }
 }
 
-/**************************************************************************
- *		wait_clipboard_mutex
- *
- * Make sure that there's only one clipboard thread per window station.
- */
-static BOOL wait_clipboard_mutex(void)
-{
-    static const WCHAR prefix[] = L"__wine_clipboard_";
-    WCHAR buffer[MAX_PATH + ARRAY_SIZE( prefix )];
-    HANDLE mutex;
-
-    memcpy( buffer, prefix, sizeof(prefix) );
-    if (!GetUserObjectInformationW( GetProcessWindowStation(), UOI_NAME,
-                                    buffer + ARRAY_SIZE( prefix ) - 1,
-                                    sizeof(buffer) - sizeof(prefix), NULL ))
-    {
-        ERR( "failed to get winstation name\n" );
-        return FALSE;
-    }
-    mutex = CreateMutexW( NULL, TRUE, buffer );
-    if (GetLastError() == ERROR_ALREADY_EXISTS)
-    {
-        TRACE( "waiting for mutex %s\n", debugstr_w( buffer ));
-        WaitForSingleObject( mutex, INFINITE );
-    }
-    return TRUE;
-}
-
-
-/**************************************************************************
- *		clipboard_wndproc
- *
- * Window procedure for the clipboard manager.
- */
-static LRESULT CALLBACK clipboard_wndproc( HWND hwnd, UINT msg, WPARAM wp, LPARAM lp )
-{
-    switch (msg)
-    {
-    case WM_NCCREATE:
-    case WM_CLIPBOARDUPDATE:
-    case WM_RENDERFORMAT:
-    case WM_TIMER:
-    case WM_DESTROYCLIPBOARD:
-    case WM_USER:
-        return NtUserMessageCall( hwnd, msg, wp, lp, 0, NtUserClipboardWindowProc, FALSE );
-    }
-
-    return DefWindowProcW( hwnd, msg, wp, lp );
-}
-
-
-/**************************************************************************
- *		clipboard_thread
- *
- * Thread running inside the desktop process to manage the clipboard
- */
-static DWORD WINAPI clipboard_thread( void *arg )
-{
-    static const WCHAR clipboard_classname[] = L"__wine_clipboard_manager";
-    WNDCLASSW class;
-    ATOM atom;
-    MSG msg;
-
-    if (!wait_clipboard_mutex()) return 0;
-
-    memset( &class, 0, sizeof(class) );
-    class.lpfnWndProc   = clipboard_wndproc;
-    class.lpszClassName = clipboard_classname;
-
-    if (!(atom = RegisterClassW( &class )) && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
-    {
-        ERR( "could not register clipboard window class err %lu\n", GetLastError() );
-        return 0;
-    }
-    if (!CreateWindowW( clipboard_classname, NULL, 0, 0, 0, 0, 0, HWND_MESSAGE, 0, 0, NULL ))
-    {
-        TRACE( "failed to create clipboard window err %lu\n", GetLastError() );
-        UnregisterClassW( MAKEINTRESOURCEW(atom), NULL );
-        return 0;
-    }
-
-    while (GetMessageW( &msg, 0, 0, 0 )) DispatchMessageW( &msg );
-    return 0;
-}
-
 static WNDPROC desktop_orig_wndproc;
 
 /* window procedure for the desktop window */
@@ -1047,8 +961,6 @@ void manage_desktop( WCHAR *arg )
     BOOL enable_shell = FALSE;
     void (WINAPI *pShellDDEInit)( BOOL ) = NULL;
     HMODULE shell32;
-    HANDLE thread;
-    DWORD id;
 
     /* get the rest of the command line (if any) */
     while (*p && !is_whitespace(*p)) p++;
@@ -1113,8 +1025,6 @@ void manage_desktop( WCHAR *arg )
         SetWindowPos( hwnd, 0, GetSystemMetrics(SM_XVIRTUALSCREEN), GetSystemMetrics(SM_YVIRTUALSCREEN),
                       GetSystemMetrics(SM_CXVIRTUALSCREEN), GetSystemMetrics(SM_CYVIRTUALSCREEN),
                       SWP_SHOWWINDOW );
-        thread = CreateThread( NULL, 0, clipboard_thread, NULL, 0, &id );
-        if (thread) CloseHandle( thread );
         SystemParametersInfoW( SPI_SETDESKWALLPAPER, 0, NULL, FALSE );
         ClipCursor( NULL );
         initialize_display_settings();
diff --git a/tools/winewrapper b/tools/winewrapper
index 031a0c05f69..93d44bcd06c 100755
--- a/tools/winewrapper
+++ b/tools/winewrapper
@@ -69,9 +69,9 @@ if [ "`uname -s`" = "Darwin" ]
 then
   if [ -n "$DYLD_LIBRARY_PATH" ]
   then
-    DYLD_LIBRARY_PATH="$topdir/libs/wine:$topdir/dlls/ntdll:$topdir/dlls/win32u:$DYLD_LIBRARY_PATH"
+    DYLD_LIBRARY_PATH="$topdir/libs/wine:$topdir/dlls/ntdll:$DYLD_LIBRARY_PATH"
   else
-    DYLD_LIBRARY_PATH="$topdir/libs/wine:$topdir/dlls/ntdll:$topdir/dlls/win32u"
+    DYLD_LIBRARY_PATH="$topdir/libs/wine:$topdir/dlls/ntdll"
   fi
   export DYLD_LIBRARY_PATH
 else
-- 
2.36.1

