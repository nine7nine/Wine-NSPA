--- a/dlls/ntdll/unix/loader.c  2023-04-19 13:47:15.586561461 -0500
+++ b/dlls/ntdll/unix/loader.c	2023-04-19 13:46:17.232263562 -0500
@@ -108,6 +108,19 @@ static const char so_dir[] = "/aarch64-u
 static const char so_dir[] = "";
 #endif
 
+static int get_priority( const char *variable, int min, int max )
+{
+    const char *env;
+    int val;
+
+    env = getenv( variable );
+    if (!env) return -1;
+
+    val = atoi( env );
+    if (val >= min && val <= max) return val;
+    return -1;
+}
+
 void     (WINAPI *pDbgUiRemoteBreakin)( void *arg ) = NULL;
 NTSTATUS (WINAPI *pKiRaiseUserExceptionDispatcher)(void) = NULL;
 NTSTATUS (WINAPI *pKiUserExceptionDispatcher)(EXCEPTION_RECORD*,CONTEXT*) = NULL;
@@ -2166,11 +2166,46 @@ static void start_main_thread(void)
     sigset_t blocked_signals;
     pthread_t thread;
     void *ret;
+    pthread_attr_t pthread_attr;
+    struct sched_param param;
+    int wine_rt_policy;
+    
+    // Get Wineserver RT policy
+    const char *policyStr = getenv("WINE_RT_POLICY");
+
+    // Set RT Priority min, max.
+    int min, max, priority;    
+    min = sched_get_priority_min( SCHED_FIFO );
+    max = sched_get_priority_max( SCHED_FIFO );
+    if (min == -1 || max == -1)
+        return;
+ 
+    // Set RT policy.
+    if (policyStr) {
+        if (strcmp(policyStr, "RR")==0)
+            wine_rt_policy = SCHED_RR;
+        if (strcmp(policyStr, "FF")==0)
+            wine_rt_policy = SCHED_FIFO;
+        else if (strcmp(policyStr, "TS")==0)
+            wine_rt_policy = SCHED_OTHER;
+    } 
+
+    if ((priority = get_priority( "WINE_RT_PRIO", min, max -1)) != -1)
+    {
+        memset( &param, 0, sizeof(param) );
+        param.sched_priority = priority -1;    
+        // Set pthread_attr, so they get for Wineserver threads
+        pthread_attr_init( &pthread_attr );
+        pthread_attr_setschedpolicy (&pthread_attr, wine_rt_policy | SCHED_RESET_ON_FORK);
+        pthread_attr_setschedparam (&pthread_attr, &param);
+        pthread_attr_setinheritsched (&pthread_attr, PTHREAD_EXPLICIT_SCHED);
+        pthread_attr_setscope( &pthread_attr, PTHREAD_SCOPE_SYSTEM );
+    }
 
     /* block all signals for this thread, it cannot handle them */
     sigfillset( &blocked_signals );
     pthread_sigmask( SIG_BLOCK, &blocked_signals, NULL );
-    pthread_create( &thread, NULL, pthread_main_wrapper, &blocked_signals );
+    pthread_create( &thread, &pthread_attr, pthread_main_wrapper, &blocked_signals );
 
     /* wait for it to return, so the process isn't considered a zombie */
     pthread_join( thread, &ret );

