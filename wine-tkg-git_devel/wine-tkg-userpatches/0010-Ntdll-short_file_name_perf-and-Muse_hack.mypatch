 - Tweak hash_short_file_name() hash algorithm (with Remi's patchwork included)
 
 This supposedly helped with avoiding hash collisions in the old wine-muse builds.
 
 updated for wine-7.22+
 
 johnstonljordan <AT> gmail <DOT> com

--- a/dlls/ntdll/unix/file.c	2021-12-07 11:04:56.412552038 -0500
+++ b/dlls/ntdll/unix/file.c	2021-12-07 11:04:42.861379431 -0500
@@ -177,9 +177,6 @@ typedef struct
 
 #define IS_SEPARATOR(ch)   ((ch) == '\\' || (ch) == '/')
 
-#define INVALID_NT_CHARS   '*','?','<','>','|','"'
-#define INVALID_DOS_CHARS  INVALID_NT_CHARS,'+','=',',',';','[',']',' ','\345'
-
 #define MAX_DIR_ENTRY_LEN 255  /* max length of a directory entry in chars */
 
 #define MAX_IGNORED_FILES 4
@@ -426,9 +423,38 @@ static int mkdir_p( int dirfd, const cha
 /* check if a given Unicode char is OK in a DOS short name */
 static inline BOOL is_invalid_dos_char( WCHAR ch )
 {
-    static const WCHAR invalid_chars[] = { INVALID_DOS_CHARS,'~','.',0 };
-    if (ch > 0x7f) return TRUE;
-    return wcschr( invalid_chars, ch ) != NULL;
+    static const char is_invalid[0x7f] =
+    {
+        ['*'] = 1, ['?'] = 1, ['<'] = 1, ['>'] = 1, ['|'] = 1, ['"'] = 1, ['+'] = 1, ['='] = 1,
+        [','] = 1, [';'] = 1, ['['] = 1, [']'] = 1, [' '] = 1, ['~'] = 1, ['.'] = 1,
+    };
+    return ch <= 0x7f ? is_invalid[ch] : TRUE;
+}
+
+static inline BOOL is_invalid_8dot3_char( WCHAR ch )
+{
+    static const char is_invalid[0x7f] =
+    {
+        ['*'] = 1, ['?'] = 1, ['<'] = 1, ['>'] = 1, ['|'] = 1, ['"'] = 1, ['+'] = 1, ['='] = 1,
+        [','] = 1, [';'] = 1, ['['] = 1, [']'] = 1, [' '] = 1, [':'] = 1, ['/'] = 1, ['\\'] = 1,
+    };
+    return ch <= 0x7f ? is_invalid[ch] : TRUE;
+}
+
+static inline BOOL is_invalid_nt_char( WCHAR ch )
+{
+    static const char is_invalid[0x7f] =
+    {
+        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+        ['*'] = 1, ['?'] = 1, ['<'] = 1, ['>'] = 1, ['|'] = 1, ['"'] = 1,
+    };
+    return ch <= 0x7f ? is_invalid[ch] : FALSE;
+}
+
+static inline BOOL is_invalid_unix_char( WCHAR ch )
+{
+    if (ch == '/') return TRUE;
+    return is_invalid_nt_char( ch );
 }
 
 /* check if the device can be a mounted volume */
@@ -1497,7 +1523,7 @@ static ULONG hash_short_file_name( const
 
     LPCWSTR p, ext, end = name + length;
     LPWSTR dst;
-    unsigned short hash;
+    unsigned int hash;
     int i;
 
     /* Compute the hash code of the file name */
@@ -1512,23 +1538,25 @@ static ULONG hash_short_file_name( const
     else
     {
         for (p = name, hash = 0xbeef; p < end - 1; p++)
-            hash = (hash << 3) ^ (hash >> 5) ^ *p ^ (p[1] << 8);
+            hash = (hash << 3) ^ (hash >> 5) ^ *p ^ (p[1] << 8) ^ (p[2] << 16);
         hash = (hash << 3) ^ (hash >> 5) ^ *p;  /* Last character */
     }
 
     /* Find last dot for start of the extension */
-    for (p = name + 1, ext = NULL; p < end - 1; p++) if (*p == '.') ext = p;
+    for (ext = end - 2; ext > name; ext--) if (*ext == '.') break;
+    if (ext == name) ext = NULL;
 
-    /* Copy first 4 chars, replacing invalid chars with '_' */
-    for (i = 4, p = name, dst = buffer; i > 0; i--, p++)
+    /* Copy first 3 chars, replacing invalid chars with '_' */
+    for (i = 3, p = name, dst = buffer; i > 0; i--, p++)
     {
         if (p == end || p == ext) break;
         *dst++ = is_invalid_dos_char(*p) ? '_' : *p;
     }
-    /* Pad to 5 chars with '~' */
+    /* Pad to 4 chars with '~' */
     while (i-- >= 0) *dst++ = '~';
 
     /* Insert hash code converted to 3 ASCII chars */
+    *dst++ = hash_chars[(hash >> 15) & 0x1f];
     *dst++ = hash_chars[(hash >> 10) & 0x1f];
     *dst++ = hash_chars[(hash >> 5) & 0x1f];
     *dst++ = hash_chars[hash & 0x1f];
@@ -1634,7 +1662,6 @@ static BOOLEAN match_filename( const WCH
  */
 static BOOLEAN is_legal_8dot3_name( const WCHAR *name, int len )
 {
-    static const WCHAR invalid_chars[] = { INVALID_DOS_CHARS,':','/','\\',0 };
     int i, dot = -1;
 
     if (len > 12) return FALSE;
@@ -1644,8 +1671,7 @@ static BOOLEAN is_legal_8dot3_name( cons
 
     for (i = 0; i < len; i++)
     {
-        if (name[i] > 0x7f) return FALSE;
-        if (wcschr( invalid_chars, name[i] )) return FALSE;
+        if (is_invalid_8dot3_char( name[i] )) return FALSE;
         if (name[i] == '.')
         {
             if (dot != -1) return FALSE;
@@ -4239,7 +4265,6 @@ static NTSTATUS lookup_unix_name( FILE_O
                                   char **buffer, int unix_len, int pos, UINT disposition,
                                   BOOL is_unix )
 {
-    static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, '/', 0 };
     const WCHAR *fullname = fileobj->FileName.Buffer;
     NTSTATUS status;
     int ret;
@@ -4267,7 +4292,7 @@ static NTSTATUS lookup_unix_name( FILE_O
         {
             if (!*ptr) return STATUS_OBJECT_NAME_INVALID;
             if (is_unix) continue;
-            if (*ptr < 32 || wcschr( invalid_charsW, *ptr )) return STATUS_OBJECT_NAME_INVALID;
+            if (is_invalid_unix_char( *ptr )) return STATUS_OBJECT_NAME_INVALID;
         }
     }
 
@@ -4385,7 +4410,6 @@ static NTSTATUS nt_to_unix_file_name_no_
                                               UINT disposition )
 {
     static const WCHAR unixW[] = {'u','n','i','x'};
-    static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, 0 };
     const UNICODE_STRING *nameW = &fileobj->FileName;
     NTSTATUS status = STATUS_SUCCESS;
     const WCHAR *name;
@@ -4412,8 +4436,7 @@ static NTSTATUS nt_to_unix_file_name_no_
     for (pos = 0; pos < name_len && pos <= MAX_DIR_ENTRY_LEN; pos++)
     {
         if (name[pos] == '\\') break;
-        if (name[pos] < 32 || wcschr( invalid_charsW, name[pos] ))
-            return STATUS_OBJECT_NAME_INVALID;
+        if (is_invalid_nt_char( name[pos] )) return STATUS_OBJECT_NAME_INVALID;
         prefix[pos] = (name[pos] >= 'A' && name[pos] <= 'Z') ? name[pos] + 'a' - 'A' : name[pos];
     }
     if (pos > MAX_DIR_ENTRY_LEN) return STATUS_OBJECT_NAME_INVALID;

