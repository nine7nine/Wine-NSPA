From c069cc6645c7363400f960e195aeddcb1f0ff2c4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 11 Oct 2021 10:58:33 +0200
Subject: [PATCH] ntdll: Use RTLD_NOLOAD to find already mapped modules.

This makes it possible to detect modules that weren't unmapped from
dlclose, and that we should not fixup again.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=49640
---
 dlls/ntdll/unix/loader.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 3bb7f056b2a..cd2019be582 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -1274,9 +1274,11 @@ static NTSTATUS dlopen_dll( const char *so_name, UNICODE_STRING *nt_name, void *
 {
     void *module, *handle;
     const IMAGE_NT_HEADERS *nt;
+    BOOL mapped = FALSE;
 
     callback_module = (void *)1;
-    handle = dlopen( so_name, RTLD_NOW );
+    if ((handle = dlopen( so_name, RTLD_NOW | RTLD_NOLOAD ))) mapped = TRUE;
+    else handle = dlopen( so_name, RTLD_NOW );
     if (!handle)
     {
         WARN( "failed to load .so lib %s: %s\n", debugstr_a(so_name), dlerror() );
@@ -1293,7 +1295,7 @@ static NTSTATUS dlopen_dll( const char *so_name, UNICODE_STRING *nt_name, void *
     {
         module = (HMODULE)((nt->OptionalHeader.ImageBase + 0xffff) & ~0xffff);
         if (get_builtin_so_handle( module )) goto already_loaded;
-        if (map_so_dll( nt, module ))
+        if (!mapped && map_so_dll( nt, module ))
         {
             dlclose( handle );
             return STATUS_NO_MEMORY;
-- 
GitLab

From 82010317528d56c623a3c4f243f43a94ddfc6b9d Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Wed, 23 Nov 2022 15:03:06 +0800
Subject: [PATCH] combase: Use SendMessageW() in
 ClientRpcChannelBuffer_SendReceive() for STAs.

An application has a thread 1 sending WM_DESTROY to windows in thread 2. When handling the message
in thread 2, RevokeDragDrop() is called to release a COM object in thread 1. Then deadlock happens
when using PostMessageW() because the DM_EXECUTERPC message will not be handled as thread 1 is still
waiting for thread 2 to finish handling WM_DESTROY.
---
 dlls/combase/rpc.c | 11 +----------
 1 file changed, 1 insertion(+), 10 deletions(-)

diff --git a/dlls/combase/rpc.c b/dlls/combase/rpc.c
index c51b59de4bf..1862c8bddca 100644
--- a/dlls/combase/rpc.c
+++ b/dlls/combase/rpc.c
@@ -1416,16 +1416,7 @@ static HRESULT WINAPI ClientRpcChannelBuffer_SendReceive(LPRPCCHANNELBUFFER ifac
 
         msg->ProcNum &= ~RPC_FLAGS_VALID_BIT;
 
-        if (!PostMessageW(message_state->target_hwnd, DM_EXECUTERPC, 0,
-                          (LPARAM)&message_state->params))
-        {
-            ERR("PostMessage failed with error %lu\n", GetLastError());
-
-            /* Note: message_state->params.iface doesn't have a reference and
-             * so doesn't need to be released */
-
-            hr = HRESULT_FROM_WIN32(GetLastError());
-        }
+        SendMessageW(message_state->target_hwnd, DM_EXECUTERPC, 0, (LPARAM)&message_state->params);
     }
     else
     {
-- 
GitLab
