From e01b590edf3636fdc921161b5140c363b8b16fea Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 21:58:41 -0700
Subject: [PATCH] dbghelp: Handle memory allocation failure in
 image_locate_build_id_target (cppcheck).

---
 dlls/dbghelp/module.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/dbghelp/module.c b/dlls/dbghelp/module.c
index d590877497d..1890b87369f 100644
--- a/dlls/dbghelp/module.c
+++ b/dlls/dbghelp/module.c
@@ -660,6 +660,7 @@ static BOOL image_locate_build_id_target(struct image_file_map* fmap, const BYTE
 
     p = malloc(sizeof(L"/usr/lib/debug/.build-id/") +
                (idlen * 2 + 1) * sizeof(WCHAR) + sizeof(L".debug"));
+    if (!p) goto fail;
     wcscpy(p, L"/usr/lib/debug/.build-id/");
     z = p + wcslen(p);
     if (idlen)
@@ -684,9 +685,11 @@ static BOOL image_locate_build_id_target(struct image_file_map* fmap, const BYTE
     sz = GetEnvironmentVariableW(L"WINEHOMEDIR", NULL, 0);
     if (sz)
     {
-        p = realloc(p, sz * sizeof(WCHAR) +
+        z = realloc(p, sz * sizeof(WCHAR) +
                     sizeof(L"\\.cache\\debuginfod_client\\") +
                     idlen * 2 * sizeof(WCHAR) + sizeof(L"\\debuginfo") + 500);
+        if (!z) goto fail;
+        p = z;
         GetEnvironmentVariableW(L"WINEHOMEDIR", p, sz);
         z = p + sz - 1;
         wcscpy(z, L"\\.cache\\debuginfod_client\\");
@@ -703,6 +706,7 @@ static BOOL image_locate_build_id_target(struct image_file_map* fmap, const BYTE
     }
 
     TRACE("not found\n");
+fail:
     free(p);
     HeapFree(GetProcessHeap(), 0, fmap_link);
     return FALSE;
-- 
GitLab

From ed73e97e13240d230e90dcadad831dfc80f8a04d Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Wed, 14 Dec 2022 21:19:01 -0700
Subject: [PATCH] dwrite: Handle memory allocation failure in
 bidi_compute_bracket_pairs (cppcheck).

---
 dlls/dwrite/bidi.c | 65 +++++++++++++++++++++++-----------------------
 1 file changed, 32 insertions(+), 33 deletions(-)

diff --git a/dlls/dwrite/bidi.c b/dlls/dwrite/bidi.c
index 142c82f19d0..940f147b880 100644
--- a/dlls/dwrite/bidi.c
+++ b/dlls/dwrite/bidi.c
@@ -632,51 +632,50 @@ static BracketPair *bidi_compute_bracket_pairs(IsolatedRun *iso_run)
     WCHAR *open_stack;
     int *stack_index;
     int stack_top = iso_run->length;
-    BracketPair *out = NULL;
+    BracketPair *out;
     int pair_count = 0;
     int i;
 
     open_stack = malloc(sizeof(WCHAR) * iso_run->length);
     stack_index = malloc(sizeof(int) * iso_run->length);
+    out = malloc(sizeof(BracketPair) * iso_run->length);
 
-    for (i = 0; i < iso_run->length; i++) {
-        unsigned short ubv = get_table_entry_16(bidi_bracket_table, iso_run->item[i].ch);
-        if (ubv)
-        {
-            if (!out)
-            {
-                out = malloc(sizeof(BracketPair));
-                out[0].start = -1;
-            }
+    if (open_stack && stack_index && out) {
+        out[0].start = -1;
 
-            if ((ubv >> 8) == 0) {
-                stack_top--;
-                open_stack[stack_top] = iso_run->item[i].ch + (signed char)(ubv & 0xff);
-                /* deal with canonical equivalent U+2329/232A and U+3008/3009 */
-                if (open_stack[stack_top] == 0x232A)
-                    open_stack[stack_top] = 0x3009;
-                stack_index[stack_top] = i;
-            }
-            else if ((ubv >> 8) == 1) {
-                int j;
-
-                if (stack_top == iso_run->length) continue;
-                for (j = stack_top; j < iso_run->length; j++) {
-                    WCHAR c = iso_run->item[i].ch;
-                    if (c == 0x232A) c = 0x3009;
-                    if (c == open_stack[j]) {
-                        out[pair_count].start = stack_index[j];
-                        out[pair_count].end = i;
-                        pair_count++;
-                        out = realloc(out, sizeof(BracketPair) * (pair_count+1));
-                        out[pair_count].start = -1;
-                        stack_top = j+1;
-                        break;
+        for (i = 0; i < iso_run->length; i++) {
+            unsigned short ubv = get_table_entry_16(bidi_bracket_table, iso_run->item[i].ch);
+            if (ubv)
+            {
+                if ((ubv >> 8) == 0) {
+                    stack_top--;
+                    open_stack[stack_top] = iso_run->item[i].ch + (signed char)(ubv & 0xff);
+                    /* deal with canonical equivalent U+2329/232A and U+3008/3009 */
+                    if (open_stack[stack_top] == 0x232A)
+                        open_stack[stack_top] = 0x3009;
+                    stack_index[stack_top] = i;
+                }
+                else if ((ubv >> 8) == 1) {
+                    int j;
+
+                    if (stack_top == iso_run->length) continue;
+                    for (j = stack_top; j < iso_run->length; j++) {
+                        WCHAR c = iso_run->item[i].ch;
+                        if (c == 0x232A) c = 0x3009;
+                        if (c == open_stack[j]) {
+                            out[pair_count].start = stack_index[j];
+                            out[pair_count].end = i;
+                            pair_count++;
+                            out[pair_count].start = -1;
+                            stack_top = j+1;
+                            break;
+                        }
                     }
                 }
             }
         }
     }
+
     if (pair_count == 0)
     {
         free(out);
-- 
GitLab

From 42fe30f3fa6ef2b3554d388032d792286e206674 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 22:15:04 -0700
Subject: [PATCH] hhctrl: Handle memory allocation failure in ReadChmSystem
 (cppcheck).

---
 dlls/hhctrl.ocx/chm.c | 21 ++++++++++++++++-----
 1 file changed, 16 insertions(+), 5 deletions(-)

diff --git a/dlls/hhctrl.ocx/chm.c b/dlls/hhctrl.ocx/chm.c
index fb982303a3c..4be86bd165a 100644
--- a/dlls/hhctrl.ocx/chm.c
+++ b/dlls/hhctrl.ocx/chm.c
@@ -82,7 +82,7 @@ static BOOL ReadChmSystem(CHMInfo *chm)
 {
     IStream *stream;
     DWORD ver=0xdeadbeef, read, buf_size;
-    char *buf;
+    char *buf, *new_buf;
     HRESULT hres;
 
     struct {
@@ -101,16 +101,27 @@ static BOOL ReadChmSystem(CHMInfo *chm)
     IStream_Read(stream, &ver, sizeof(ver), &read);
     TRACE("version is %lx\n", ver);
 
-    buf = malloc(8 * sizeof(DWORD));
-    buf_size = 8*sizeof(DWORD);
+    buf_size = 8 * sizeof(DWORD);
+    buf = malloc(buf_size);
+    if(!buf) {
+        IStream_Release(stream);
+        return FALSE;
+    }
 
     while(1) {
         hres = IStream_Read(stream, &entry, sizeof(entry), &read);
         if(hres != S_OK)
             break;
 
-        if(entry.len > buf_size)
-            buf = realloc(buf, buf_size=entry.len);
+        if(entry.len > buf_size) {
+            new_buf = realloc(buf, entry.len);
+            if(!new_buf) {
+                hres = E_OUTOFMEMORY;
+                break;
+            }
+            buf = new_buf;
+            buf_size = entry.len;
+        }
 
         hres = IStream_Read(stream, buf, entry.len, &read);
         if(hres != S_OK)
-- 
GitLab

From 799cba0242451fbefcb972b49a4d595ea68657d1 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 22:20:32 -0700
Subject: [PATCH] hhctrl: Handle memory allocation failure in SearchCHM_File
 (cppcheck).

---
 dlls/hhctrl.ocx/search.c | 14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

diff --git a/dlls/hhctrl.ocx/search.c b/dlls/hhctrl.ocx/search.c
index c6fe30afc14..64b71e87ac7 100644
--- a/dlls/hhctrl.ocx/search.c
+++ b/dlls/hhctrl.ocx/search.c
@@ -72,7 +72,7 @@ static void fill_search_tree(HWND hwndList, SearchItem *item)
  */
 static WCHAR *SearchCHM_File(IStorage *pStorage, const WCHAR *file, const char *needle)
 {
-    char *buffer = malloc(BLOCK_SIZE);
+    char *buffer = NULL, *new_buffer;
     strbuf_t content, node, node_name;
     IStream *temp_stream = NULL;
     DWORD i, buffer_size = 0;
@@ -84,7 +84,7 @@ static WCHAR *SearchCHM_File(IStorage *pStorage, const WCHAR *file, const char *
     hres = IStorage_OpenStream(pStorage, file, NULL, STGM_READ, 0, &temp_stream);
     if(FAILED(hres)) {
         FIXME("Could not open '%s' stream: %08lx\n", debugstr_w(file), hres);
-        goto cleanup;
+        return NULL;
     }
 
     strbuf_init(&node);
@@ -110,7 +110,9 @@ static WCHAR *SearchCHM_File(IStorage *pStorage, const WCHAR *file, const char *
                 title[wlen] = 0;
             }
 
-            buffer = realloc(buffer, buffer_size + textlen + 1);
+            new_buffer = realloc(buffer, buffer_size + textlen + 1);
+            if(!new_buffer) goto cleanup;
+            buffer = new_buffer;
             memcpy(&buffer[buffer_size], text, textlen);
             buffer[buffer_size + textlen] = '\0';
             buffer_size += textlen;
@@ -130,14 +132,14 @@ static WCHAR *SearchCHM_File(IStorage *pStorage, const WCHAR *file, const char *
     if(strstr(buffer, needle))
         found = TRUE;
 
+cleanup:
     strbuf_free(&node);
     strbuf_free(&content);
     strbuf_free(&node_name);
 
-cleanup:
     free(buffer);
-    if(temp_stream)
-        IStream_Release(temp_stream);
+    IStream_Release(temp_stream);
+
     if(!found)
     {
         free(title);
-- 
GitLab

From f4a2898bad5b539d1da3e337c80ceaa0089e758d Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 22:24:30 -0700
Subject: [PATCH] inetcomm: Fix memory leak on realloc failure in
 copy_headers_to_buf (cppcheck).

---
 dlls/inetcomm/mimeole.c | 14 +++++---------
 1 file changed, 5 insertions(+), 9 deletions(-)

diff --git a/dlls/inetcomm/mimeole.c b/dlls/inetcomm/mimeole.c
index 232e09aa075..dd2c00b01fa 100644
--- a/dlls/inetcomm/mimeole.c
+++ b/dlls/inetcomm/mimeole.c
@@ -485,7 +485,7 @@ static inline propschema *impl_from_IMimePropertySchema(IMimePropertySchema *ifa
  */
 static HRESULT copy_headers_to_buf(IStream *stm, char **ptr)
 {
-    char *buf = NULL;
+    char *buf = NULL, *new_buf;
     DWORD size = PARSER_BUF_SIZE, offset = 0, last_end = 0;
     HRESULT hr;
     BOOL done = FALSE;
@@ -497,18 +497,14 @@ static HRESULT copy_headers_to_buf(IStream *stm, char **ptr)
         char *end;
         DWORD read;
 
-        if(!buf)
-            buf = malloc(size + 1);
-        else
-        {
-            size *= 2;
-            buf = realloc(buf, size + 1);
-        }
-        if(!buf)
+        if(buf) size *= 2;
+        new_buf = realloc(buf, size + 1);
+        if(!new_buf)
         {
             hr = E_OUTOFMEMORY;
             goto fail;
         }
+        buf = new_buf;
 
         hr = IStream_Read(stm, buf + offset, size - offset, &read);
         if(FAILED(hr)) goto fail;
-- 
GitLab

From 1022117c95fa7c55da828ea9a54f481e7bec8083 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 21:10:02 -0700
Subject: [PATCH] mshtml: Handle memory allocation failure in set_statustext.

---
 dlls/mshtml/main.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/mshtml/main.c b/dlls/mshtml/main.c
index 14c34f2f36a..a45a2c111dc 100644
--- a/dlls/mshtml/main.c
+++ b/dlls/mshtml/main.c
@@ -407,6 +407,7 @@ void set_statustext(HTMLDocumentObj* doc, INT id, LPCWSTR arg)
     if(!p) {
         len = 255;
         p = malloc(len * sizeof(WCHAR));
+        if (!p) return;
         len = LoadStringW(hInst, id, p, len) + 1;
         p = realloc(p, len * sizeof(WCHAR));
         if(InterlockedCompareExchangePointer((void**)&status_strings[index], p, NULL)) {
@@ -420,6 +421,7 @@ void set_statustext(HTMLDocumentObj* doc, INT id, LPCWSTR arg)
 
         len = lstrlenW(p) + lstrlenW(arg) - 1;
         buf = malloc(len * sizeof(WCHAR));
+        if (!buf) return;
 
         swprintf(buf, len, p, arg);
 
-- 
GitLab

From 0ccb91cf00eb315f0d3cb4c517f5ed94d4da84ea Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 21:23:50 -0700
Subject: [PATCH] msi: Fix memory leak on realloc failure in
 create_diff_row_query (cppcheck).

---
 dlls/msi/database.c | 11 ++++-------
 1 file changed, 4 insertions(+), 7 deletions(-)

diff --git a/dlls/msi/database.c b/dlls/msi/database.c
index c0845fbadcb..c50e34cc8cd 100644
--- a/dlls/msi/database.c
+++ b/dlls/msi/database.c
@@ -1412,7 +1412,7 @@ static LPWSTR get_key_value(MSIQUERY *view, LPCWSTR key, MSIRECORD *rec)
 static LPWSTR create_diff_row_query(MSIDATABASE *merge, MSIQUERY *view,
                                     LPWSTR table, MSIRECORD *rec)
 {
-    LPWSTR query = NULL, clause = NULL, val;
+    WCHAR *query = NULL, *clause = NULL, *new_clause, *val;
     LPCWSTR setptr, key;
     DWORD size, oldsize;
     MSIRECORD *keys;
@@ -1422,10 +1422,6 @@ static LPWSTR create_diff_row_query(MSIDATABASE *merge, MSIQUERY *view,
     if (r != ERROR_SUCCESS)
         return NULL;
 
-    clause = calloc(1, sizeof(WCHAR));
-    if (!clause)
-        goto done;
-
     size = 1;
     count = MSI_RecordGetFieldCount(keys);
     for (i = 1; i <= count; i++)
@@ -1440,12 +1436,13 @@ static LPWSTR create_diff_row_query(MSIDATABASE *merge, MSIQUERY *view,
 
         oldsize = size;
         size += lstrlenW(setptr) + lstrlenW(key) + lstrlenW(val) - 4;
-        clause = realloc(clause, size * sizeof(WCHAR));
-        if (!clause)
+        new_clause = realloc(clause, size * sizeof(WCHAR));
+        if (!new_clause)
         {
             free(val);
             goto done;
         }
+        clause = new_clause;
 
         swprintf(clause + oldsize - 1, size - (oldsize - 1), setptr, key, val);
         free(val);
-- 
GitLab

From de7897effb5fa350a76f9a425dedcf3d1472986f Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 21:28:03 -0700
Subject: [PATCH] msi: Fix memory leak on realloc failure in
 msi_get_window_text (cppcheck).

---
 dlls/msi/dialog.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/msi/dialog.c b/dlls/msi/dialog.c
index e5a2208cb6f..cfd39d4921c 100644
--- a/dlls/msi/dialog.c
+++ b/dlls/msi/dialog.c
@@ -143,7 +143,7 @@ static HWND hMsiHiddenWindow;
 static LPWSTR msi_get_window_text( HWND hwnd )
 {
     UINT sz, r;
-    LPWSTR buf;
+    WCHAR *buf, *new_buf;
 
     sz = 0x20;
     buf = malloc( sz * sizeof(WCHAR) );
@@ -153,7 +153,10 @@ static LPWSTR msi_get_window_text( HWND hwnd )
         if ( r < (sz - 1) )
             break;
         sz *= 2;
-        buf = realloc( buf, sz * sizeof(WCHAR) );
+        new_buf = realloc( buf, sz * sizeof(WCHAR) );
+        if ( !new_buf )
+            free( buf );
+        buf = new_buf;
     }
 
     return buf;
-- 
GitLab

From dcd9be1e7ce39b2d0ee2fa8c38a036c34fab1788 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 22:36:56 -0700
Subject: [PATCH] msi: Fix memory leak on realloc failure in search_directory
 (cppcheck).

---
 dlls/msi/appsearch.c | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/dlls/msi/appsearch.c b/dlls/msi/appsearch.c
index 9693fc92833..95c3312b3df 100644
--- a/dlls/msi/appsearch.c
+++ b/dlls/msi/appsearch.c
@@ -875,7 +875,7 @@ static UINT search_directory( MSIPACKAGE *package, MSISIGNATURE *sig, const WCHA
 {
     UINT rc;
     DWORD attr;
-    LPWSTR val = NULL;
+    WCHAR *val = NULL, *new_val;
 
     TRACE("%p, %p, %s, %d, %p\n", package, sig, debugstr_w(path), depth, appValue);
 
@@ -920,11 +920,18 @@ static UINT search_directory( MSIPACKAGE *package, MSISIGNATURE *sig, const WCHA
     if (attr != INVALID_FILE_ATTRIBUTES && (attr & FILE_ATTRIBUTE_DIRECTORY) &&
         val && val[lstrlenW(val) - 1] != '\\')
     {
-        val = realloc(val, (wcslen(val) + 2) * sizeof(WCHAR));
-        if (!val)
+        new_val = realloc(val, (wcslen(val) + 2) * sizeof(WCHAR));
+        if (!new_val)
+        {
+            free(val);
+            val = NULL;
             rc = ERROR_OUTOFMEMORY;
+        }
         else
+        {
+            val = new_val;
             PathAddBackslashW(val);
+        }
     }
 
     *appValue = val;
-- 
GitLab

From 995c0a050228b1396e830429360a3c4bf431198b Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 22:45:22 -0700
Subject: [PATCH] shell32: Handle memory allocation failure in Dde_OnRequest
 (cppcheck).

---
 dlls/shell32/dde.c | 20 +++++++++++++++-----
 1 file changed, 15 insertions(+), 5 deletions(-)

diff --git a/dlls/shell32/dde.c b/dlls/shell32/dde.c
index 96b5a243f93..10bdb11501f 100644
--- a/dlls/shell32/dde.c
+++ b/dlls/shell32/dde.c
@@ -145,9 +145,9 @@ static inline HDDEDATA Dde_OnRequest(UINT uFmt, HCONV hconv, HSZ hszTopic,
         WIN32_FIND_DATAW finddata;
         HANDLE hfind;
         int len = 1;
-        WCHAR *groups_data = malloc(sizeof(WCHAR));
+        WCHAR *groups_data = malloc(sizeof(WCHAR)), *new_groups_data;
         char *groups_dataA;
-        HDDEDATA ret;
+        HDDEDATA ret = NULL;
 
         groups_data[0] = 0;
         programs = get_programs_path(L"*", FALSE);
@@ -160,7 +160,14 @@ static inline HDDEDATA Dde_OnRequest(UINT uFmt, HCONV hconv, HSZ hszTopic,
                     wcscmp(finddata.cFileName, L".") && wcscmp(finddata.cFileName, L".."))
                 {
                     len += lstrlenW(finddata.cFileName) + 2;
-                    groups_data = realloc(groups_data, len * sizeof(WCHAR));
+                    new_groups_data = realloc(groups_data, len * sizeof(WCHAR));
+                    if (!new_groups_data)
+                    {
+                        free(groups_data);
+                        free(programs);
+                        return NULL;
+                    }
+                    groups_data = new_groups_data;
                     lstrcatW(groups_data, finddata.cFileName);
                     lstrcatW(groups_data, L"\r\n");
                 }
@@ -170,8 +177,11 @@ static inline HDDEDATA Dde_OnRequest(UINT uFmt, HCONV hconv, HSZ hszTopic,
 
         len = WideCharToMultiByte(CP_ACP, 0, groups_data, -1, NULL, 0, NULL, NULL);
         groups_dataA = malloc(len * sizeof(WCHAR));
-        WideCharToMultiByte(CP_ACP, 0, groups_data, -1, groups_dataA, len, NULL, NULL);
-        ret = DdeCreateDataHandle(dwDDEInst, (BYTE *)groups_dataA, len, 0, hszGroups, uFmt, 0);
+        if (groups_dataA)
+        {
+            WideCharToMultiByte(CP_ACP, 0, groups_data, -1, groups_dataA, len, NULL, NULL);
+            ret = DdeCreateDataHandle(dwDDEInst, (BYTE *)groups_dataA, len, 0, hszGroups, uFmt, 0);
+        }
 
         free(groups_dataA);
         free(groups_data);
-- 
GitLab

From 788c2acd30a6bfb7cb4f4651df150bb4e20e9435 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 21:40:17 -0700
Subject: [PATCH] shell32: Handle memory allocation failure in
 parse_dde_command (cppcheck).

---
 dlls/shell32/dde.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/dlls/shell32/dde.c b/dlls/shell32/dde.c
index 96b5a243f93..c96ed855576 100644
--- a/dlls/shell32/dde.c
+++ b/dlls/shell32/dde.c
@@ -337,7 +337,7 @@ static DWORD PROGMAN_OnExecute(WCHAR *command, int argc, WCHAR **argv)
 static DWORD parse_dde_command(HSZ hszTopic, WCHAR *command)
 {
     WCHAR *original = command;
-    WCHAR *opcode = NULL, **argv = NULL, *p;
+    WCHAR *opcode, **argv, **new_argv, *p;
     int argc = 0, i;
     DWORD ret = DDE_FACK;
 
@@ -347,7 +347,7 @@ static DWORD parse_dde_command(HSZ hszTopic, WCHAR *command)
     while (*command == '[')
     {
         argc = 0;
-        argv = malloc(sizeof(*argv));
+        argv = NULL;
 
         command++;
         while (*command == ' ') command++;
@@ -375,9 +375,11 @@ static DWORD parse_dde_command(HSZ hszTopic, WCHAR *command)
                     while (p[-1] == ' ') p--;
                 }
 
+                new_argv = realloc(argv, (argc + 1) * sizeof(*argv));
+                if (!new_argv) goto error;
+                argv = new_argv;
+                argv[argc] = strndupW(command, p - command);
                 argc++;
-                argv = realloc(argv, argc * sizeof(*argv));
-                argv[argc-1] = strndupW(command, p - command);
 
                 command = p;
                 if (*command == '"') command++;
-- 
GitLab

From c5f1621372c304f49e1fcf81b56009f771804849 Mon Sep 17 00:00:00 2001
From: Alex Henrie <alexhenrie24@gmail.com>
Date: Sun, 11 Dec 2022 22:50:34 -0700
Subject: [PATCH] twain_32: Handle realloc failure in twain_add_onedriver
 (cppcheck).

---
 dlls/twain_32/dsm_ctrl.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/dlls/twain_32/dsm_ctrl.c b/dlls/twain_32/dsm_ctrl.c
index 6854093017a..13503e6772c 100644
--- a/dlls/twain_32/dsm_ctrl.c
+++ b/dlls/twain_32/dsm_ctrl.c
@@ -53,6 +53,7 @@ twain_add_onedriver(const WCHAR *dsname) {
 	DSENTRYPROC	dsEntry;
 	TW_IDENTITY	fakeOrigin;
 	TW_IDENTITY	sourceId;
+	struct all_devices *new_devices;
 	TW_UINT16	ret;
         WCHAR path[MAX_PATH];
 
@@ -89,7 +90,10 @@ twain_add_onedriver(const WCHAR *dsname) {
 		}
 		if (i < nrdevices)
 			break;
-                devices = realloc( devices, sizeof(devices[0])*(nrdevices+1) );
+		new_devices = realloc( devices, sizeof(devices[0]) * (nrdevices + 1) );
+		if (!new_devices)
+			break;
+		devices = new_devices;
 		devices[nrdevices].modname = wcsdup( path );
 		devices[nrdevices].identity = sourceId;
 		nrdevices++;
-- 
GitLab

From db3008323098e00313bd23dd2ffbdfd56c4ccee8 Mon Sep 17 00:00:00 2001
From: Fabian Maurer <dark.shadow4@web.de>
Date: Mon, 12 Dec 2022 17:12:13 +0100
Subject: [PATCH 2/2] wldap32: Set error code in error cases (Coverity)

Signed-off-by: Fabian Maurer <dark.shadow4@web.de>
---
 dlls/wldap32/misc.c | 38 ++++++++++++++++++++++++++++----------
 1 file changed, 28 insertions(+), 10 deletions(-)

diff --git a/dlls/wldap32/misc.c b/dlls/wldap32/misc.c
index a8d27a87b78..f515698d095 100644
--- a/dlls/wldap32/misc.c
+++ b/dlls/wldap32/misc.c
@@ -218,13 +218,19 @@ WCHAR * CDECL ldap_first_attributeW( LDAP *ld, WLDAP32_LDAPMessage *entry, WLDAP
     if (ld && entry) retU = ldap_first_attribute( CTX(ld), MSG(entry), &berU );
     else return NULL;
 
-    if (retU && (ber = malloc( sizeof(*ber) )))
+    if (!retU)
+        return NULL;
+
+    if (!(ber = malloc( sizeof(*ber) )))
     {
-        ber->opaque = (char *)berU;
-        *ptr = ber;
-        ret = strUtoW( retU );
+        ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
+        ldap_memfree( retU );
+        return NULL;
     }
 
+    ber->opaque = (char *)berU;
+    *ptr = ber;
+    ret = strUtoW( retU );
     ldap_memfree( retU );
     return ret;
 }
@@ -358,12 +364,18 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_entry( LDAP *ld, WLDAP32_LDAPMessa
     if (entry->lm_next) return entry->lm_next;
 
     msgU = ldap_next_entry( CTX(ld), MSG(entry) );
-    if (msgU && (msg = calloc( 1, sizeof(*msg) )))
+
+    if (!msgU)
+        return NULL;
+
+    if (!(msg = calloc( 1, sizeof(*msg) )))
     {
-        MSG(msg) = msgU;
-        entry->lm_next = msg;
+        ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
+        return NULL;
     }
 
+    MSG(msg) = msgU;
+    entry->lm_next = msg;
     return msg;
 }
 
@@ -382,12 +394,18 @@ WLDAP32_LDAPMessage * CDECL WLDAP32_ldap_next_reference( LDAP *ld, WLDAP32_LDAPM
     if (entry->lm_next) return entry->lm_next;
 
     msgU = ldap_next_reference( CTX(ld), MSG(entry) );
-    if (msgU && (msg = calloc( 1, sizeof(*msg) )))
+
+    if (!msgU)
+        return NULL;
+
+    if (!(msg = calloc( 1, sizeof(*msg) )))
     {
-        MSG(msg) = msgU;
-        entry->lm_next = msg;
+        ld->ld_errno = WLDAP32_LDAP_NO_MEMORY;
+        return NULL;
     }
 
+    MSG(msg) = msgU;
+    entry->lm_next = msg;
     return msg;
 }
 
-- 
GitLab

