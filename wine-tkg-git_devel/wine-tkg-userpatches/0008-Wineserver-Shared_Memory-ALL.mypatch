From 5afe6de435796ffe23be98efde2c63deca1ad436 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 6 Mar 2021 00:05:36 +0100
Subject: [PATCH 01/44] server: Create a desktop shared mapping.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/directory.c  | 17 +++++++++++++++++
 server/file.h       |  6 ++++++
 server/mapping.c    | 19 ++++++++++++++++++-
 server/protocol.def |  5 +++++
 server/user.h       | 28 +++++++++++++++-------------
 server/winstation.c | 22 ++++++++++++++++++++++
 6 files changed, 83 insertions(+), 14 deletions(-)

diff --git a/server/directory.c b/server/directory.c
index 11111111111..11111111111 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -37,6 +37,7 @@
 #include "process.h"
 #include "file.h"
 #include "unicode.h"
+#include "user.h"
 
 #define HASH_SIZE 7  /* default hash size */
 
@@ -283,6 +284,22 @@ struct object *get_directory_obj( struct process *process, obj_handle_t handle )
     return get_handle_obj( process, handle, 0, &directory_ops );
 }
 
+struct object *create_desktop_map_directory( struct winstation *winstation )
+{
+    static const WCHAR dir_desktop_mapsW[] = {'_','_','w','i','n','e','_','d','e','s','k','t','o','p','_','m','a','p','p','i','n','g','s'};
+    static const struct unicode_str dir_desktop_maps_str = {dir_desktop_mapsW, sizeof(dir_desktop_mapsW)};
+    struct object *root;
+    struct directory *mapping_root, *ret;
+    const struct unicode_str winsta_name = {winstation->obj.name->name, winstation->obj.name->len};
+
+    root = winstation->obj.name->parent;
+    mapping_root = create_directory( root, &dir_desktop_maps_str, OBJ_OPENIF, HASH_SIZE, NULL );
+    ret = create_directory( &mapping_root->obj, &winsta_name, OBJ_OPENIF, HASH_SIZE, NULL );
+    release_object( &mapping_root->obj );
+
+    return &ret->obj;
+}
+
 /* Global initialization */
 
 static void create_session( unsigned int id )
diff --git a/server/file.h b/server/file.h
index 11111111111..11111111111 100644
--- a/server/file.h
+++ b/server/file.h
@@ -167,6 +167,10 @@ extern struct timeout_user *add_timeout_user( timeout_t when, timeout_callback f
 extern void remove_timeout_user( struct timeout_user *user );
 extern const char *get_timeout_str( timeout_t timeout );
 
+/* directory functions */
+
+extern struct object *create_desktop_map_directory( struct winstation *winstation );
+
 /* file functions */
 
 extern struct file *get_file_obj( struct process *process, obj_handle_t handle,
@@ -190,6 +195,8 @@ extern struct mapping *create_fd_mapping
                                           unsigned int attr, const struct security_descriptor *sd );
 extern struct object *create_user_data_mapping( struct object *root, const struct unicode_str *name,
                                                 unsigned int attr, const struct security_descriptor *sd );
+extern struct object *create_shared_mapping( struct object *root, const struct unicode_str *name,
+                                             mem_size_t size, const struct security_descriptor *sd, void **ptr );
 
 /* device functions */
 
diff --git a/server/mapping.c b/server/mapping.c
index 11111111111..11111111111 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -1107,7 +1107,7 @@ int get_page_size(void)
 }
 
 struct object *create_user_data_mapping( struct object *root, const struct unicode_str *name,
-                                        unsigned int attr, const struct security_descriptor *sd )
+                                         unsigned int attr, const struct security_descriptor *sd )
 {
     void *ptr;
     struct mapping *mapping;
@@ -1137,6 +1137,23 @@ struct object *create_hypervisor_data_mapping( struct object *root, const struct
     return &mapping->obj;
 }
 
+struct object *create_shared_mapping( struct object *root, const struct unicode_str *name,
+                                      mem_size_t size, const struct security_descriptor *sd, void **ptr )
+{
+    struct mapping *mapping;
+
+    if (!(mapping = create_mapping( root, name, OBJ_OPENIF, size, SEC_COMMIT, 0,
+                                    FILE_READ_DATA | FILE_WRITE_DATA, sd ))) return NULL;
+    *ptr = mmap( NULL, mapping->size, PROT_WRITE, MAP_SHARED, get_unix_fd( mapping->fd ), 0 );
+    if (*ptr == MAP_FAILED)
+    {
+        release_object( &mapping->obj );
+        return NULL;
+    }
+
+    return &mapping->obj;
+}
+
 /* create a file mapping */
 DECL_HANDLER(create_mapping)
 {
diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -853,6 +853,11 @@ struct cpu_topology_override
     unsigned char host_cpu_id[64];
 };
 
+struct desktop_shared_memory
+{
+    int placeholder;
+};
+
 /****************************************************************/
 /* Request declarations */
 
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -64,19 +64,21 @@ struct global_cursor
 
 struct desktop
 {
-    struct object        obj;              /* object header */
-    unsigned int         flags;            /* desktop flags */
-    struct winstation   *winstation;       /* winstation this desktop belongs to */
-    struct list          entry;            /* entry in winstation list of desktops */
-    struct window       *top_window;       /* desktop window for this desktop */
-    struct window       *msg_window;       /* HWND_MESSAGE top window */
-    struct hook_table   *global_hooks;     /* table of global hooks on this desktop */
-    struct list          hotkeys;          /* list of registered hotkeys */
-    struct timeout_user *close_timeout;    /* timeout before closing the desktop */
-    struct thread_input *foreground_input; /* thread input of foreground thread */
-    unsigned int         users;            /* processes and threads using this desktop */
-    struct global_cursor cursor;           /* global cursor information */
-    unsigned char        keystate[256];    /* asynchronous key state */
+    struct object                          obj;              /* object header */
+    unsigned int                           flags;            /* desktop flags */
+    struct winstation                     *winstation;       /* winstation this desktop belongs to */
+    struct list                            entry;            /* entry in winstation list of desktops */
+    struct window                         *top_window;       /* desktop window for this desktop */
+    struct window                         *msg_window;       /* HWND_MESSAGE top window */
+    struct hook_table                     *global_hooks;     /* table of global hooks on this desktop */
+    struct list                            hotkeys;          /* list of registered hotkeys */
+    struct timeout_user                   *close_timeout;    /* timeout before closing the desktop */
+    struct thread_input                   *foreground_input; /* thread input of foreground thread */
+    unsigned int                           users;            /* processes and threads using this desktop */
+    struct global_cursor                   cursor;           /* global cursor information */
+    struct object                         *shared_mapping;   /* desktop shared memory mapping */
+    volatile struct desktop_shared_memory *shared;           /* desktop shared memory ptr */
+    unsigned char                          keystate[256];    /* asynchronous key state */
 };
 
 /* user handles functions */
diff --git a/server/winstation.c b/server/winstation.c
index 11111111111..11111111111 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -222,6 +222,22 @@ struct desktop *get_desktop_obj( struct process *process, obj_handle_t handle, u
     return (struct desktop *)get_handle_obj( process, handle, access, &desktop_ops );
 }
 
+static volatile void *init_desktop_mapping( struct desktop *desktop, const struct unicode_str *name )
+{
+    struct object *dir = create_desktop_map_directory( desktop->winstation );
+
+    desktop->shared = NULL;
+    desktop->shared_mapping = NULL;
+
+    if (!dir) return NULL;
+
+    desktop->shared_mapping = create_shared_mapping( dir, name, sizeof(struct desktop_shared_memory),
+                                                     NULL, (void **)&desktop->shared );
+    release_object( dir );
+    if (desktop->shared) memset( (void *)desktop->shared, 0, sizeof(*desktop->shared) );
+    return desktop->shared;
+}
+
 /* create a desktop object */
 static struct desktop *create_desktop( const struct unicode_str *name, unsigned int attr,
                                        unsigned int flags, struct winstation *winstation )
@@ -245,6 +261,11 @@ static struct desktop *create_desktop( const struct unicode_str *name, unsigned
             memset( desktop->keystate, 0, sizeof(desktop->keystate) );
             list_add_tail( &winstation->desktops, &desktop->entry );
             list_init( &desktop->hotkeys );
+            if (!init_desktop_mapping( desktop, name ))
+            {
+                release_object( desktop );
+                return NULL;
+            }
         }
         else clear_error();
     }
@@ -298,6 +319,7 @@ static void desktop_destroy( struct object *obj )
     if (desktop->global_hooks) release_object( desktop->global_hooks );
     if (desktop->close_timeout) remove_timeout_user( desktop->close_timeout );
     list_remove( &desktop->entry );
+    release_object( desktop->shared_mapping );
     release_object( desktop->winstation );
 }
 

From ca63abe8cd0110b9421dfd08c570b217356c482e Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Mon, 29 Jun 2020 11:30:14 +0100
Subject: [PATCH 03/44] server: Move the cursor position and last change time
 to the shared data.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/protocol.def |  9 ++++++-
 server/user.h       |  3 ---
 3 files changed, 37 insertions(+), 33 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -853,9 +853,16 @@ struct cpu_topology_override
     unsigned char host_cpu_id[64];
 };
 
+struct shared_cursor
+{
+    int                  x;                /* cursor position */
+    int                  y;
+    unsigned int         last_change;      /* time of last position change */
+};
+
 struct desktop_shared_memory
 {
-    int placeholder;
+    struct shared_cursor cursor;           /* global cursor information */
 };
 
 /****************************************************************/
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -54,11 +54,8 @@ struct winstation
 
 struct global_cursor
 {
-    int                  x;                /* cursor position */
-    int                  y;
     rectangle_t          clip;             /* cursor clip rectangle */
     unsigned int         clip_msg;         /* message to post for cursor clip changes */
-    unsigned int         last_change;      /* time of last position change */
     user_handle_t        win;              /* window that contains the cursor */
 };
 

From e94799cae183654611e931cea0f7555729840621 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Mon, 29 Jun 2020 12:57:39 +0100
Subject: [PATCH 04/44] server: Add a sequence number to the shared data.

The client should check that the lower SEQUENCE_MASK_BITS are zero before
reading the data and confirm that the number is unchanged when it's finished.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/protocol.def |  5 +++++
 2 files changed, 50 insertions(+), 1 deletion(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -862,9 +862,14 @@ struct shared_cursor
 
 struct desktop_shared_memory
 {
+    unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     struct shared_cursor cursor;           /* global cursor information */
 };
 
+/* Bits that must be clear for client to read */
+#define SEQUENCE_MASK_BITS  4
+#define SEQUENCE_MASK ((1UL << SEQUENCE_MASK_BITS) - 1)
+
 /****************************************************************/
 /* Request declarations */
 
From c687ba0ba20a7352ec8913308d9784f41a9c92f4 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 11:24:53 +0100
Subject: [PATCH 05/44] win32u: Use the desktop shared data for get_cursor_pos().

---
 dlls/win32u/input.c          | 20 +++++-----
 dlls/win32u/ntuser_private.h |  2 +
 dlls/win32u/sysparams.c      |  7 ++++
 dlls/win32u/win32u_private.h | 23 ++++++++++++
 dlls/win32u/winstation.c     | 72 ++++++++++++++++++++++++++++++++++++
 5 files changed, 113 insertions(+), 11 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -217,25 +217,23 @@ BOOL WINAPI NtUserSetCursorPos( INT x, INT y )
  */
 BOOL get_cursor_pos( POINT *pt )
 {
-    BOOL ret;
+    BOOL ret = TRUE;
     DWORD last_change;
     UINT dpi;
+    volatile struct desktop_shared_memory *shared = get_desktop_shared_memory();
 
-    if (!pt) return FALSE;
+    if (!pt || !shared) return FALSE;
 
-    SERVER_START_REQ( set_cursor )
+    SHARED_READ_BEGIN( &shared->seq )
     {
-        if ((ret = !wine_server_call( req )))
-        {
-            pt->x = reply->new_x;
-            pt->y = reply->new_y;
-            last_change = reply->last_change;
-        }
+        pt->x = shared->cursor.x;
+        pt->y = shared->cursor.y;
+        last_change = shared->cursor.last_change;
     }
-    SERVER_END_REQ;
+    SHARED_READ_END( &shared->seq );
 
     /* query new position from graphics driver if we haven't updated recently */
-    if (ret && NtGetTickCount() - last_change > 100) ret = user_driver->pGetCursorPos( pt );
+    if (NtGetTickCount() - last_change > 100) ret = user_driver->pGetCursorPos( pt );
     if (ret && (dpi = get_thread_dpi()))
     {
         HMONITOR monitor = monitor_from_point( *pt, MONITOR_DEFAULTTOPRIMARY, 0 );
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -135,6 +135,8 @@ struct user_thread_info
     DWORD                         kbd_layout_id;          /* Current keyboard layout ID */
     struct rawinput_thread_data  *rawinput;               /* RawInput thread local data / buffer */
     UINT                          spy_indent;             /* Current spy indent */
+    HANDLE                        desktop_shared_map;     /* HANDLE to server's desktop shared memory */
+    struct desktop_shared_memory *desktop_shared_memory;  /* Ptr to server's desktop shared memory */
 };
 
 C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo) );
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4917,6 +4917,13 @@ static void thread_detach(void)
     cleanup_imm_thread();
     NtClose( thread_info->server_queue );
 
+    if (thread_info->desktop_shared_map)
+    {
+        NtClose( thread_info->desktop_shared_map );
+        thread_info->desktop_shared_map = NULL;
+        thread_info->desktop_shared_memory = NULL;
+    }
+
     exiting_thread_id = 0;
 }
 
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -409,6 +409,9 @@ static inline void release_win_ptr( struct tagWND *ptr )
     user_unlock();
 }
 
+/* winstation.c */
+extern volatile struct desktop_shared_memory *get_desktop_shared_memory( void ) DECLSPEC_HIDDEN;
+
 extern void wrappers_init( unixlib_handle_t handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS gdi_init(void) DECLSPEC_HIDDEN;
 extern NTSTATUS callbacks_init( void *args ) DECLSPEC_HIDDEN;
@@ -504,4 +507,24 @@ static inline const char *debugstr_us( const UNICODE_STRING *us )
     return debugstr_wn( us->Buffer, us->Length / sizeof(WCHAR) );
 }
 
+#if defined(__i386__) || defined(__x86_64__)
+#define __SHARED_READ_SEQ( x ) (*(x))
+#define __SHARED_READ_FENCE do {} while(0)
+#else
+#define __SHARED_READ_SEQ( x ) __atomic_load_n( x, __ATOMIC_RELAXED )
+#define __SHARED_READ_FENCE __atomic_thread_fence( __ATOMIC_ACQUIRE )
+#endif
+
+#define SHARED_READ_BEGIN( x )                                          \
+    do {                                                                \
+        unsigned int __seq;                                             \
+        do {                                                            \
+            while ((__seq = __SHARED_READ_SEQ( x )) & SEQUENCE_MASK) NtYieldExecution(); \
+            __SHARED_READ_FENCE;
+
+#define SHARED_READ_END( x )                       \
+            __SHARED_READ_FENCE;                   \
+        } while (__SHARED_READ_SEQ( x ) != __seq); \
+    } while(0)
+
 #endif /* __WINE_WIN32U_PRIVATE */
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -242,6 +242,12 @@ BOOL WINAPI NtUserSetThreadDesktop( HDESK handle )
         thread_info->client_info.top_window = 0;
         thread_info->client_info.msg_window = 0;
         if (key_state_info) key_state_info->time = 0;
+        if (thread_info->desktop_shared_map)
+        {
+            NtClose( thread_info->desktop_shared_map );
+            thread_info->desktop_shared_map = NULL;
+            thread_info->desktop_shared_memory = NULL;
+        }
     }
     return ret;
 }
@@ -567,6 +573,72 @@ static const WCHAR *get_default_desktop( void *buf, size_t buf_size )
     return defaultW;
 }
 
+
+static void map_shared_memory_section( const WCHAR *name, SIZE_T size, HANDLE root, HANDLE *handle, void **ptr )
+{
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING section_str;
+    NTSTATUS status;
+
+    section_str.Length = wcslen(name) * sizeof(WCHAR);
+    section_str.MaximumLength = section_str.Length + sizeof(WCHAR);
+    section_str.Buffer = (WCHAR *)name;
+    InitializeObjectAttributes( &attr, &section_str, 0, root, NULL );
+    status = NtOpenSection( handle, SECTION_ALL_ACCESS, &attr );
+    if (status)
+    {
+        ERR( "failed to open section %s: %08x\n", debugstr_w(name), status );
+        *ptr = NULL;
+        *handle = NULL;
+        return;
+    }
+
+    *ptr = NULL;
+    status = NtMapViewOfSection( *handle, GetCurrentProcess(), ptr, 0, 0, NULL,
+                                 &size, ViewUnmap, 0, PAGE_READONLY );
+    if (status)
+    {
+        ERR( "failed to map view of section %s: %08x\n", debugstr_w(name), status );
+        NtClose( *handle );
+        *ptr = NULL;
+        *handle = NULL;
+    }
+}
+
+
+volatile struct desktop_shared_memory *get_desktop_shared_memory( void )
+{
+    static const WCHAR dir_desktop_mapsW[] = {'_','_','w','i','n','e','_','d','e','s','k','t','o','p','_','m','a','p','p','i','n','g','s','\\',0};
+    struct user_thread_info *thread_info = get_user_thread_info();
+    HANDLE root, handles[2];
+    WCHAR buf[MAX_PATH], *ptr;
+    DWORD i, needed;
+
+    if (thread_info->desktop_shared_memory) return thread_info->desktop_shared_memory;
+
+    root = get_winstations_dir_handle();
+
+    handles[0] = NtUserGetProcessWindowStation();
+    handles[1] = NtUserGetThreadDesktop( GetCurrentThreadId() );
+
+    memcpy( buf, dir_desktop_mapsW, sizeof(dir_desktop_mapsW) );
+    ptr = buf + ARRAY_SIZE(dir_desktop_mapsW) - 1;
+
+    for (i = 0; i < 2; i++)
+    {
+        NtUserGetObjectInformation( handles[i], UOI_NAME, (void *)ptr, sizeof(buf) - (ptr - buf) * sizeof(WCHAR), &needed );
+        ptr += needed / sizeof(WCHAR);
+        if (i == 0) *(ptr - 1) = '\\';
+    }
+
+    map_shared_memory_section( buf, sizeof(struct desktop_shared_memory), root,
+                               &thread_info->desktop_shared_map, (void **)&thread_info->desktop_shared_memory );
+
+    NtClose( root );
+    return thread_info->desktop_shared_memory;
+}
+
+
 /***********************************************************************
  *           winstation_init
  *

From c7f9447aeafb896ecaaba9e4344b3d1d0d35630e Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 13:58:26 +0100
Subject: [PATCH 06/44] server: Use the helper to reset the clip rect when the
 desktop size changes.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/user.h   | 1 +
 server/window.c | 2 +-
 3 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -119,6 +119,7 @@ extern void post_win_event( struct thread *thread, unsigned int event,
                             const WCHAR *module, data_size_t module_size,
                             user_handle_t handle );
 extern void free_hotkeys( struct desktop *desktop, user_handle_t window );
+extern void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect, int send_clip_msg );
 
 /* region functions */
 
diff --git a/server/window.c b/server/window.c
index 11111111111..11111111111 100644
--- a/server/window.c
+++ b/server/window.c
@@ -1806,7 +1806,7 @@ static void set_window_pos( struct window *win, struct window *previous,
     }
 
     /* reset cursor clip rectangle when the desktop changes size */
-    if (win == win->desktop->top_window) win->desktop->cursor.clip = *window_rect;
+    if (win == win->desktop->top_window) set_clip_rectangle( win->desktop, NULL, 0 );
 
     /* if the window is not visible, everything is easy */
     if (!visible) return;

From ae06f12836cabcde908734a907351e98a8327bfa Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 14:12:52 +0100
Subject: [PATCH 07/44] server: Store the cursor clip rect in the shared data.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/protocol.def |  1 +
 server/user.h       |  1 -
 3 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -858,6 +858,7 @@ struct shared_cursor
     int                  x;                /* cursor position */
     int                  y;
     unsigned int         last_change;      /* time of last position change */
+    rectangle_t          clip;             /* cursor clip rectangle */
 };
 
 struct desktop_shared_memory
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -54,7 +54,6 @@ struct winstation
 
 struct global_cursor
 {
-    rectangle_t          clip;             /* cursor clip rectangle */
     unsigned int         clip_msg;         /* message to post for cursor clip changes */
     user_handle_t        win;              /* window that contains the cursor */
 };

From ae8ad0149a554db1b9e4b658ce36df1430045c4a Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 14:28:15 +0100
Subject: [PATCH 08/44] win32u: Use the desktop shared data for
 get_clip_cursor().

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 dlls/win32u/cursoricon.c | 24 ++++++++++--------------
 1 file changed, 10 insertions(+), 14 deletions(-)

diff --git a/dlls/win32u/cursoricon.c b/dlls/win32u/cursoricon.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/cursoricon.c
+++ b/dlls/win32u/cursoricon.c
@@ -200,30 +200,26 @@ BOOL WINAPI NtUserClipCursor( const RECT *rect )
 
 BOOL get_clip_cursor( RECT *rect )
 {
+    volatile struct desktop_shared_memory *shared = get_desktop_shared_memory();
     UINT dpi;
-    BOOL ret;
 
-    if (!rect) return FALSE;
+    if (!rect || !shared) return FALSE;
 
-    SERVER_START_REQ( set_cursor )
+    SHARED_READ_BEGIN( &shared->seq )
     {
-        req->flags = 0;
-        if ((ret = !wine_server_call( req )))
-        {
-            rect->left   = reply->new_clip.left;
-            rect->top    = reply->new_clip.top;
-            rect->right  = reply->new_clip.right;
-            rect->bottom = reply->new_clip.bottom;
-        }
+        rect->left   = shared->cursor.clip.left;
+        rect->top    = shared->cursor.clip.top;
+        rect->right  = shared->cursor.clip.right;
+        rect->bottom = shared->cursor.clip.bottom;
     }
-    SERVER_END_REQ;
+    SHARED_READ_END( &shared->seq );
 
-    if (ret && (dpi = get_thread_dpi()))
+    if ((dpi = get_thread_dpi()))
     {
         HMONITOR monitor = monitor_from_rect( rect, MONITOR_DEFAULTTOPRIMARY, 0 );
         *rect = map_dpi_rect( *rect, get_monitor_dpi( monitor ), dpi );
     }
-    return ret;
+    return TRUE;
 }

 
 HICON alloc_cursoricon_handle( BOOL is_icon )
From c9bd87fe6413b5873818280b71695d8868a1a754 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 14:41:57 +0100
Subject: [PATCH 09/44] server: Get rid of the global cursor structure.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/user.h       |  9 ++-------
 server/winstation.c |  3 ++-
 3 files changed, 9 insertions(+), 13 deletions(-)

diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -52,12 +52,6 @@ struct winstation
     struct namespace  *desktop_names;      /* namespace for desktops of this winstation */
 };
 
-struct global_cursor
-{
-    unsigned int         clip_msg;         /* message to post for cursor clip changes */
-    user_handle_t        win;              /* window that contains the cursor */
-};
-
 struct desktop
 {
     struct object                          obj;              /* object header */
@@ -71,7 +65,8 @@ struct desktop
     struct timeout_user                   *close_timeout;    /* timeout before closing the desktop */
     struct thread_input                   *foreground_input; /* thread input of foreground thread */
     unsigned int                           users;            /* processes and threads using this desktop */
-    struct global_cursor                   cursor;           /* global cursor information */
+    unsigned int                           cursor_clip_msg;  /* message to post for cursor clip changes */
+    user_handle_t                          cursor_win;       /* window that contains the cursor */
     struct object                         *shared_mapping;   /* desktop shared memory mapping */
     volatile struct desktop_shared_memory *shared;           /* desktop shared memory ptr */
     unsigned char                          keystate[256];    /* asynchronous key state */
diff --git a/server/winstation.c b/server/winstation.c
index 11111111111..11111111111 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -257,7 +257,8 @@ static struct desktop *create_desktop( const struct unicode_str *name, unsigned
             desktop->close_timeout = NULL;
             desktop->foreground_input = NULL;
             desktop->users = 0;
-            memset( &desktop->cursor, 0, sizeof(desktop->cursor) );
+            desktop->cursor_clip_msg = 0;
+            desktop->cursor_win = 0;
             memset( desktop->keystate, 0, sizeof(desktop->keystate) );
             list_add_tail( &winstation->desktops, &desktop->entry );
             list_init( &desktop->hotkeys );

From 652000a24b990e79e8143ed40c31dae8af151969 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Tue, 30 Jun 2020 15:42:25 +0100
Subject: [PATCH 10/44] server: Use a separate variable to determine the
 message on Alt release.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---

 server/user.h       |  1 +
 server/winstation.c |  1 +
 3 files changed, 7 insertions(+), 6 deletions(-)

diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -69,6 +69,7 @@ struct desktop
     user_handle_t                          cursor_win;       /* window that contains the cursor */
     struct object                         *shared_mapping;   /* desktop shared memory mapping */
     volatile struct desktop_shared_memory *shared;           /* desktop shared memory ptr */
+    unsigned int                           last_press_alt:1; /* last key press was Alt (used to determine msg on Alt release) */
     unsigned char                          keystate[256];    /* asynchronous key state */
 };
 
diff --git a/server/winstation.c b/server/winstation.c
index 11111111111..11111111111 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -259,6 +259,7 @@ static struct desktop *create_desktop( const struct unicode_str *name, unsigned
             desktop->users = 0;
             desktop->cursor_clip_msg = 0;
             desktop->cursor_win = 0;
+            desktop->last_press_alt = 0;
             memset( desktop->keystate, 0, sizeof(desktop->keystate) );
             list_add_tail( &winstation->desktops, &desktop->entry );
             list_init( &desktop->hotkeys );

From d967d8d4c8f5b9e51aa1467e543a964935d143d2 Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Wed, 8 Jul 2020 08:26:21 +0100
Subject: [PATCH 13/44] server: Move the desktop keystate to shared memory.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/protocol.def |  1 +
 server/user.h       |  1 -
 server/winstation.c |  1 -
 4 files changed, 39 insertions(+), 32 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -865,6 +865,7 @@ struct desktop_shared_memory
 {
     unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     struct shared_cursor cursor;           /* global cursor information */
+    unsigned char        keystate[256];    /* asynchronous key state */
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -70,7 +70,6 @@ struct desktop
     struct object                         *shared_mapping;   /* desktop shared memory mapping */
     volatile struct desktop_shared_memory *shared;           /* desktop shared memory ptr */
     unsigned int                           last_press_alt:1; /* last key press was Alt (used to determine msg on Alt release) */
-    unsigned char                          keystate[256];    /* asynchronous key state */
 };
 
 /* user handles functions */
diff --git a/server/winstation.c b/server/winstation.c
index 11111111111..11111111111 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -260,7 +260,6 @@ static struct desktop *create_desktop( const struct unicode_str *name, unsigned
             desktop->cursor_clip_msg = 0;
             desktop->cursor_win = 0;
             desktop->last_press_alt = 0;
-            memset( desktop->keystate, 0, sizeof(desktop->keystate) );
             list_add_tail( &winstation->desktops, &desktop->entry );
             list_init( &desktop->hotkeys );
             if (!init_desktop_mapping( desktop, name ))

From 56cba0a75a2bcfaa7cb10f4d582c05b1eb608cdf Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Wed, 8 Jul 2020 15:45:24 +0100
Subject: [PATCH 14/44] win32u: Use the shared data if possible for
 NtUserGetAsyncKeyState().

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 dlls/win32u/hook.c           |  2 --
 dlls/win32u/input.c          | 38 +++++++++---------------------------
 dlls/win32u/message.c        | 16 ++-------------
 dlls/win32u/ntuser_private.h |  1 -
 dlls/win32u/sysparams.c      |  2 --
 dlls/win32u/win32u_private.h |  1 -
 dlls/win32u/winstation.c     |  2 --
 7 files changed, 11 insertions(+), 51 deletions(-)

diff --git a/dlls/win32u/hook.c b/dlls/win32u/hook.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/hook.c
+++ b/dlls/win32u/hook.c
@@ -267,8 +267,6 @@ static LRESULT call_hook( struct win_hook_params *info )
         thread_info->hook_call_depth--;
     }
 
-    if (info->id == WH_KEYBOARD_LL || info->id == WH_MOUSE_LL)
-        InterlockedIncrement( &global_key_state_counter ); /* force refreshing the key state cache */
     return ret;
 }
 
diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -277,52 +277,32 @@ static void check_for_events( UINT flags )
  */
 SHORT WINAPI NtUserGetAsyncKeyState( INT key )
 {
-    struct user_key_state_info *key_state_info = get_user_thread_info()->key_state;
-    INT counter = global_key_state_counter;
-    BYTE prev_key_state;
+    volatile struct desktop_shared_memory *shared = get_desktop_shared_memory();
+    BYTE state;
     SHORT ret;
 
-    if (key < 0 || key >= 256) return 0;
+    if (key < 0 || key >= 256 || !shared) return 0;
 
     check_for_events( QS_INPUT );
 
-    if (key_state_info && !(key_state_info->state[key] & 0xc0) &&
-        key_state_info->counter == counter && NtGetTickCount() - key_state_info->time < 50)
-    {
-        /* use cached value */
-        return 0;
-    }
-    else if (!key_state_info)
+    SHARED_READ_BEGIN( &shared->seq )
     {
-        key_state_info = calloc( 1, sizeof(*key_state_info) );
-        get_user_thread_info()->key_state = key_state_info;
+        state = shared->keystate[key];
     }
+    SHARED_READ_END( &shared->seq );
 
+    if (!(state & 0x40)) return (state & 0x80) << 8;
+
+    /* Need to make a server call to reset the last pressed bit */
     ret = 0;
     SERVER_START_REQ( get_key_state )
     {
         req->async = 1;
         req->key = key;
-        if (key_state_info)
-        {
-            prev_key_state = key_state_info->state[key];
-            wine_server_set_reply( req, key_state_info->state, sizeof(key_state_info->state) );
-        }
         if (!wine_server_call( req ))
         {
             if (reply->state & 0x40) ret |= 0x0001;
             if (reply->state & 0x80) ret |= 0x8000;
-            if (key_state_info)
-            {
-                /* force refreshing the key state cache - some multithreaded programs
-                 * (like Adobe Photoshop CS5) expect that changes to the async key state
-                 * are also immediately available in other threads. */
-                if (prev_key_state != key_state_info->state[key])
-                    counter = InterlockedIncrement( &global_key_state_counter );
-
-                key_state_info->time    = NtGetTickCount();
-                key_state_info->counter = counter;
-            }
         }
     }
     SERVER_END_REQ;
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -2414,10 +2414,8 @@ LRESULT send_internal_message_timeout( DWORD dest_pid, DWORD dest_tid,
  */
 NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *rawinput, UINT flags )
 {
-    struct user_key_state_info *key_state_info = get_user_thread_info()->key_state;
     struct send_message_info info;
     int prev_x, prev_y, new_x, new_y;
-    INT counter = global_key_state_counter;
     USAGE hid_usage_page, hid_usage;
     NTSTATUS ret;
     BOOL wait;
@@ -2501,8 +2499,6 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *r
             }
             break;
         }
-        if (key_state_info) wine_server_set_reply( req, key_state_info->state,
-                                                   sizeof(key_state_info->state) );
         ret = wine_server_call( req );
         wait = reply->wait;
         prev_x = reply->prev_x;
@@ -2512,16 +2508,8 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *r
     }
     SERVER_END_REQ;
 
-    if (!ret)
-    {
-        if (key_state_info)
-        {
-            key_state_info->time    = NtGetTickCount();
-            key_state_info->counter = counter;
-        }
-        if ((flags & SEND_HWMSG_INJECTED) && (prev_x != new_x || prev_y != new_y))
-            user_driver->pSetCursorPos( new_x, new_y );
-    }
+    if ((flags & SEND_HWMSG_INJECTED) && (prev_x != new_x || prev_y != new_y))
+        user_driver->pSetCursorPos( new_x, new_y );
 
     if (wait)
     {
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -129,7 +129,6 @@ struct user_thread_info
     HHOOK                         hook;                   /* Current hook */
     UINT                          active_hooks;           /* Bitmap of active hooks */
     struct received_message_info *receive_info;           /* Message being currently received */
-    struct user_key_state_info   *key_state;              /* Cache of global key state */
     struct imm_thread_data       *imm_thread_data;        /* IMM thread data */
     HKL                           kbd_layout;             /* Current keyboard layout */
     DWORD                         kbd_layout_id;          /* Current keyboard layout ID */
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4909,8 +4909,6 @@ static void thread_detach(void)
 
     user_driver->pThreadDetach();
 
-    free( thread_info->key_state );
-    thread_info->key_state = 0;
     free( thread_info->rawinput );
 
     destroy_thread_windows();
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -265,7 +265,6 @@ extern void unregister_imm_window( HWND hwnd ) DECLSPEC_HIDDEN;
 
 /* input.c */
 extern BOOL destroy_caret(void) DECLSPEC_HIDDEN;
-extern LONG global_key_state_counter DECLSPEC_HIDDEN;
 extern HWND get_active_window(void) DECLSPEC_HIDDEN;
 extern HWND get_capture(void) DECLSPEC_HIDDEN;
 extern BOOL get_cursor_pos( POINT *pt ) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -238,10 +238,8 @@ BOOL WINAPI NtUserSetThreadDesktop( HDESK handle )
     if (ret)  /* reset the desktop windows */
     {
         struct user_thread_info *thread_info = get_user_thread_info();
-        struct user_key_state_info *key_state_info = thread_info->key_state;
         thread_info->client_info.top_window = 0;
         thread_info->client_info.msg_window = 0;
-        if (key_state_info) key_state_info->time = 0;
         if (thread_info->desktop_shared_map)
         {
             NtClose( thread_info->desktop_shared_map );
From 567913044477b0f371118789b68cca735f3ef2ca Mon Sep 17 00:00:00 2001
From: Huw Davies <huw@codeweavers.com>
Date: Wed, 8 Jul 2020 16:07:08 +0100
Subject: [PATCH 15/44] server: Don't return the desktop keystate from the
 send_hardware_message request.

Signed-off-by: Huw Davies <huw@codeweavers.com>
---
 server/protocol.def | 1 -
 2 files changed, 3 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2088,7 +2088,6 @@ enum message_type
     int             prev_y;
     int             new_x;     /* new cursor position */
     int             new_y;
-    VARARG(keystate,bytes);    /* global state array for all the keys */
 @END
 #define SEND_HWMSG_INJECTED    0x01
 #define SEND_HWMSG_RAWINPUT    0x02
 

From fdc72bc8fc7ad22d51cbf604de174618640f7ff4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 23 Nov 2020 17:21:46 +0100
Subject: [PATCH 16/44] win32u: Refresh active hook list only when needed.

Instead of doing it on every get_message request.
---
 dlls/win32u/hook.c    | 27 +++++++++++++++++++++++----
 dlls/win32u/message.c |  4 +++-
 server/hook.c         |  8 +++++++-
 server/protocol.def   |  8 +++++++-
 server/user.h         |  1 -
 6 files changed, 40 insertions(+), 10 deletions(-)

diff --git a/dlls/win32u/hook.c b/dlls/win32u/hook.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/hook.c
+++ b/dlls/win32u/hook.c
@@ -60,12 +60,31 @@ static const char *debugstr_hook_id( unsigned int id )
     return hook_names[id - WH_MINHOOK];
 }
 
-BOOL is_hooked( INT id )
+/***********************************************************************
+ *      get_active_hooks
+ *
+ */
+static UINT get_active_hooks(void)
 {
     struct user_thread_info *thread_info = get_user_thread_info();
 
-    if (!thread_info->active_hooks) return TRUE;
-    return (thread_info->active_hooks & (1 << (id - WH_MINHOOK))) != 0;
+    if (!thread_info->active_hooks)
+    {
+        SERVER_START_REQ( get_active_hooks )
+        {
+            if (!wine_server_call( req )) thread_info->active_hooks = reply->active_hooks;
+        }
+        SERVER_END_REQ;
+    }
+
+    return thread_info->active_hooks;
+}
+
+BOOL is_hooked( INT id )
+{
+    UINT active_hooks = get_active_hooks();
+    if (!active_hooks) return TRUE;
+    return (active_hooks & (1 << (id - WH_MINHOOK))) != 0;
 }
 
 /***********************************************************************
@@ -348,7 +367,7 @@ LRESULT call_hooks( INT id, INT code, WPARAM wparam, LPARAM lparam, BOOL unicode
 
     if (!is_hooked( id ))
     {
-        TRACE( "skipping hook %s mask %x\n", hook_names[id-WH_MINHOOK], thread_info->active_hooks );
+        TRACE( "skipping hook %s mask %x\n", hook_names[id-WH_MINHOOK], get_active_hooks() );
         return 0;
     }
 
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -1691,12 +1691,14 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                 info.msg.pt.x    = reply->x;
                 info.msg.pt.y    = reply->y;
                 hw_id            = 0;
-                thread_info->active_hooks = reply->active_hooks;
             }
             else buffer_size = reply->total;
         }
         SERVER_END_REQ;
 
+        /* force refreshing hooks */
+        thread_info->active_hooks = 0;
+
         if (res)
         {
             free( buffer );
diff --git a/server/hook.c b/server/hook.c
index 11111111111..11111111111 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -358,7 +358,7 @@ static int is_hook_active( struct hook_table *table, int index )
 }
 
 /* get a bitmap of all active hooks for the current thread */
-unsigned int get_active_hooks(void)
+static unsigned int get_active_hooks(void)
 {
     struct hook_table *table = get_queue_hooks( current );
     struct hook_table *global_hooks = get_global_hooks( current );
@@ -385,6 +385,12 @@ struct thread *get_first_global_hook( int id )
     return hook->owner;
 }
 
+/* get thread active hooks */
+DECL_HANDLER(get_active_hooks)
+{
+    reply->active_hooks = get_active_hooks();
+}
+
 /* set a window hook */
 DECL_HANDLER(set_hook)
 {
diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2111,7 +2111,6 @@ enum message_type
     int             x;         /* message x position */
     int             y;         /* message y position */
     unsigned int    time;      /* message time */
-    unsigned int    active_hooks; /* active hooks bitmap */
     data_size_t     total;     /* total size of extra data */
     VARARG(data,message_data); /* message data for sent messages */
 @END
@@ -2907,6 +2906,13 @@ enum caret_state
 };
 
 
+/* get thread active hooks */
+@REQ(get_active_hooks)
+@REPLY
+    unsigned int   active_hooks;   /* active hooks bitmap */
+@END
+
+
 /* Set a window hook */
 @REQ(set_hook)
     int            id;             /* id of the hook */
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -90,7 +90,6 @@ extern void cleanup_clipboard_thread( struct thread *thread );
 /* hook functions */
 
 extern void remove_thread_hooks( struct thread *thread );
-extern unsigned int get_active_hooks(void);
 extern struct thread *get_first_global_hook( int id );
 
 /* queue functions */

From c206b344205a912b2e40f7e077bafadb86c63e9e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 21 Nov 2020 00:20:27 +0100
Subject: [PATCH 17/44] server: Create a thread queue shared mapping.

---
 server/directory.c  | 15 ++++++++
 server/file.h       |  1 +
 server/protocol.def |  6 ++++
 server/thread.c     | 32 +++++++++++++++++
 server/thread.h     |  2 ++
 6 files changed, 101 insertions(+), 40 deletions(-)

diff --git a/server/directory.c b/server/directory.c
index 11111111111..11111111111 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -300,6 +300,21 @@ struct object *create_desktop_map_directory( struct winstation *winstation )
     return &ret->obj;
 }
 
+struct object *create_thread_map_directory( void )
+{
+    static const WCHAR dir_kernelW[] = {'K','e','r','n','e','l','O','b','j','e','c','t','s'};
+    static const WCHAR dir_thread_mapsW[] = {'_','_','w','i','n','e','_','t','h','r','e','a','d','_','m','a','p','p','i','n','g','s'};
+    static const struct unicode_str dir_kernel_str = {dir_kernelW, sizeof(dir_kernelW)};
+    static const struct unicode_str dir_thread_maps_str = {dir_thread_mapsW, sizeof(dir_thread_mapsW)};
+    struct directory *mapping_root, *ret;
+
+    mapping_root = create_directory( &root_directory->obj, &dir_kernel_str, OBJ_OPENIF, HASH_SIZE, NULL );
+    ret = create_directory( &mapping_root->obj, &dir_thread_maps_str, OBJ_OPENIF, HASH_SIZE, NULL );
+    release_object( &mapping_root->obj );
+
+    return &ret->obj;
+}
+
 /* Global initialization */
 
 static void create_session( unsigned int id )
diff --git a/server/file.h b/server/file.h
index 11111111111..11111111111 100644
--- a/server/file.h
+++ b/server/file.h
@@ -170,6 +170,7 @@ extern const char *get_timeout_str( timeout_t timeout );
 /* directory functions */
 
 extern struct object *create_desktop_map_directory( struct winstation *winstation );
+extern struct object *create_thread_map_directory( void );
 
 /* file functions */
 
diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -868,6 +868,12 @@ struct desktop_shared_memory
     unsigned char        keystate[256];    /* asynchronous key state */
 };
 
+struct queue_shared_memory
+{
+    unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
+    int                  created;          /* queue has been created */
+};
+
 /* Bits that must be clear for client to read */
 #define SEQUENCE_MASK_BITS  4
 #define SEQUENCE_MASK ((1UL << SEQUENCE_MASK_BITS) - 1)
diff --git a/server/thread.c b/server/thread.c
index 11111111111..11111111111 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -56,6 +56,7 @@
 #include "request.h"
 #include "user.h"
 #include "security.h"
+#include "unicode.h"
 #include "esync.h"
 #include "fsync.h"
 
@@ -361,6 +362,10 @@ static inline void init_thread_structure
     thread->desc            = NULL;
     thread->desc_len        = 0;
     thread->exit_poll       = NULL;
+    thread->queue_shared_mapping = NULL;
+    thread->queue_shared         = NULL;
+    thread->input_shared_mapping = NULL;
+    thread->input_shared         = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -397,6 +400,28 @@ static struct context *create_thread_context( struct thread *thread )
 }
 
 
+static volatile void *init_queue_mapping( struct thread *thread )
+{
+    struct unicode_str name;
+    struct object *dir = create_thread_map_directory();
+    char nameA[MAX_PATH];
+    WCHAR *nameW;
+
+    if (!dir) return NULL;
+
+    sprintf( nameA, "%08x-queue", thread->id );
+    nameW = ascii_to_unicode_str( nameA, &name );
+
+    thread->queue_shared_mapping = create_shared_mapping( dir, &name, sizeof(struct queue_shared_memory),
+                                                          NULL, (void **)&thread->queue_shared );
+    release_object( dir );
+    if (thread->queue_shared) memset( (void *)thread->queue_shared, 0, sizeof(*thread->queue_shared) );
+
+    free( nameW );
+    return thread->queue_shared;
+}
+
+
 /* create a new thread */
 struct thread *create_thread( int fd, struct process *process, const struct security_descriptor *sd )
 {
@@ -485,6 +510,11 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
         thread->esync_fd = esync_create_fd( 0, 0 );
         thread->esync_apc_fd = esync_create_fd( 0, 0 );
     }
+    if (!init_queue_mapping( thread ))
+    {
+        release_object( thread );
+        return NULL;
+    }
 
     set_fd_events( thread->request_fd, POLLIN );  /* start listening to events */
     add_process_thread( thread->process, thread );
@@ -553,6 +583,8 @@ static void cleanup_thread( struct thread *thread )
         }
     }
     free( thread->desc );
+    if (thread->queue_shared_mapping) release_object( thread->queue_shared_mapping );
+    thread->queue_shared_mapping = NULL;
     thread->req_data = NULL;
     thread->reply_data = NULL;
     thread->request_fd = NULL;
diff --git a/server/thread.h b/server/thread.h
index 11111111111..11111111111 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -99,6 +99,10 @@ struct thread
     data_size_t            desc_len;      /* thread description length in bytes */
     WCHAR                 *desc;          /* thread description string */
     struct timeout_user   *exit_poll;     /* poll if the thread/process has exited already */
+    struct object         *queue_shared_mapping; /* thread queue shared memory mapping */
+    volatile struct queue_shared_memory *queue_shared;  /* thread queue shared memory ptr */ 
+    struct object         *input_shared_mapping; /* thread input shared memory mapping */
+    volatile struct input_shared_memory *input_shared;  /* thread input shared memory ptr */
 };
 
 extern struct thread *current;

From 6b91d470b98666212f4d486ce6193148a8f2680c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 12 Dec 2021 13:15:26 +0100
Subject: [PATCH 18/44] win32u: Use the thread queue shared data for
 peek_message.

---
 dlls/win32u/message.c        | 33 ++++++++++++++++++++++++++++-
 dlls/win32u/ntuser_private.h | 22 ++++++++++++++++++++
 dlls/win32u/sysparams.c      | 10 +++++++++
 dlls/win32u/win32u_private.h | 21 +------------------
 dlls/win32u/winstation.c     | 23 ++++++++++++++++++---
 include/ntuser.h             |  1 +
 server/protocol.def          |  4 ++++
 8 files changed, 130 insertions(+), 24 deletions(-)

diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -1648,12 +1648,14 @@ static BOOL process_hardware_message( MSG *msg, UINT hw_id, const struct hardwar
 static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags, UINT changed_mask )
 {
     LRESULT result;
+    volatile struct queue_shared_memory *shared = get_queue_shared_memory();
     struct user_thread_info *thread_info = get_user_thread_info();
     INPUT_MESSAGE_SOURCE prev_source = thread_info->client_info.msg_source;
     struct received_message_info info;
     unsigned int hw_id = 0;  /* id of previous hardware message */
     void *buffer;
     size_t buffer_size = 1024;
+    BOOL skip = FALSE;
 
     if (!(buffer = malloc( buffer_size ))) return -1;
 
@@ -1666,10 +1668,39 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
         size_t size = 0;
         const message_data_t *msg_data = buffer;
         BOOL needs_unpack = FALSE;
+        UINT wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
+        DWORD clear_bits = 0, filter = flags >> 16 ? flags >> 16 : QS_ALLINPUT;
+        if (filter & QS_POSTMESSAGE)
+        {
+            clear_bits |= QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER;
+            if (first == 0 && last == ~0U) clear_bits |= QS_ALLPOSTMESSAGE;
+        }
+        if (filter & QS_INPUT) clear_bits |= QS_INPUT;
+        if (filter & QS_PAINT) clear_bits |= QS_PAINT;
 
         thread_info->client_info.msg_source = prev_source;
 
-        SERVER_START_REQ( get_message )
+        if (!shared) skip = FALSE;
+        else SHARED_READ_BEGIN( &shared->seq )
+        {
+            /* not created yet */
+            if (!shared->created) skip = FALSE;
+            /* if the masks need an update */
+            else if (shared->wake_mask != wake_mask) skip = FALSE;
+            else if (shared->changed_mask != changed_mask) skip = FALSE;
+            /* or if the queue is signaled */
+            else if (shared->wake_bits & wake_mask) skip = FALSE;
+            else if (shared->changed_bits & changed_mask) skip = FALSE;
+            /* or if the filter matches some bits */
+            else if (shared->wake_bits & filter) skip = FALSE;
+            /* or if we should clear some bits */
+            else if (shared->changed_bits & clear_bits) skip = FALSE;
+            else skip = TRUE;
+        }
+        SHARED_READ_END( &shared->seq );
+
+        if (skip) res = STATUS_PENDING;
+        else SERVER_START_REQ( get_message )
         {
             req->flags     = flags;
             req->get_win   = wine_server_user_handle( hwnd );
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -136,6 +136,8 @@ struct user_thread_info
     UINT                          spy_indent;             /* Current spy indent */
     HANDLE                        desktop_shared_map;     /* HANDLE to server's desktop shared memory */
     struct desktop_shared_memory *desktop_shared_memory;  /* Ptr to server's desktop shared memory */
+    HANDLE                        queue_shared_map;       /* HANDLE to server's thread queue shared memory */
+    struct queue_shared_memory   *queue_shared_memory;     /* Ptr to server's thread queue shared memory */
 };
 
 C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo) );
@@ -267,4 +269,24 @@ WND *get_win_ptr( HWND hwnd ) DECLSPEC_HIDDEN;
 BOOL is_child( HWND parent, HWND child );
 BOOL is_window( HWND hwnd ) DECLSPEC_HIDDEN;
 
+#if defined(__i386__) || defined(__x86_64__)
+#define __SHARED_READ_SEQ( x ) (*(x))
+#define __SHARED_READ_FENCE do {} while(0)
+#else
+#define __SHARED_READ_SEQ( x ) __atomic_load_n( x, __ATOMIC_RELAXED )
+#define __SHARED_READ_FENCE __atomic_thread_fence( __ATOMIC_ACQUIRE )
+#endif
+
+#define SHARED_READ_BEGIN( x )                                          \
+    do {                                                                \
+        unsigned int __seq;                                             \
+        do {                                                            \
+            while ((__seq = __SHARED_READ_SEQ( x )) & SEQUENCE_MASK) NtYieldExecution(); \
+            __SHARED_READ_FENCE;
+
+#define SHARED_READ_END( x )                       \
+            __SHARED_READ_FENCE;                   \
+        } while (__SHARED_READ_SEQ( x ) != __seq); \
+    } while(0)
+
 #endif /* __WINE_NTUSER_PRIVATE_H */
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4922,6 +4922,13 @@ static void thread_detach(void)
         thread_info->desktop_shared_memory = NULL;
     }
 
+    if (thread_info->queue_shared_map)
+    {
+        NtClose( thread_info->queue_shared_map );
+        thread_info->queue_shared_map = NULL;
+        thread_info->queue_shared_memory = NULL;
+    }
+
     exiting_thread_id = 0;
 }
 
@@ -4959,6 +4966,9 @@ ULONG_PTR WINAPI NtUserCallNoParam( ULONG code )
         thread_detach();
         return 0;
 
+    case NtUserGetQueueSharedMemory:
+        return (ULONG_PTR)get_queue_shared_memory();
+
     default:
         FIXME( "invalid code %u\n", code );
         return 0;
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -410,6 +410,7 @@ static inline void release_win_ptr( struct tagWND *ptr )
 
 /* winstation.c */
 extern volatile struct desktop_shared_memory *get_desktop_shared_memory( void ) DECLSPEC_HIDDEN;
+extern volatile struct queue_shared_memory *get_queue_shared_memory( void ) DECLSPEC_HIDDEN;
 
 extern void wrappers_init( unixlib_handle_t handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS gdi_init(void) DECLSPEC_HIDDEN;
@@ -506,24 +507,4 @@ static inline const char *debugstr_us( const UNICODE_STRING *us )
     return debugstr_wn( us->Buffer, us->Length / sizeof(WCHAR) );
 }
 
-#if defined(__i386__) || defined(__x86_64__)
-#define __SHARED_READ_SEQ( x ) (*(x))
-#define __SHARED_READ_FENCE do {} while(0)
-#else
-#define __SHARED_READ_SEQ( x ) __atomic_load_n( x, __ATOMIC_RELAXED )
-#define __SHARED_READ_FENCE __atomic_thread_fence( __ATOMIC_ACQUIRE )
-#endif
-
-#define SHARED_READ_BEGIN( x )                                          \
-    do {                                                                \
-        unsigned int __seq;                                             \
-        do {                                                            \
-            while ((__seq = __SHARED_READ_SEQ( x )) & SEQUENCE_MASK) NtYieldExecution(); \
-            __SHARED_READ_FENCE;
-
-#define SHARED_READ_END( x )                       \
-            __SHARED_READ_FENCE;                   \
-        } while (__SHARED_READ_SEQ( x ) != __seq); \
-    } while(0)
-
 #endif /* __WINE_WIN32U_PRIVATE */
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -572,13 +572,13 @@ static const WCHAR *get_default_desktop( void *buf, size_t buf_size )
 }
 
 
-static void map_shared_memory_section( const WCHAR *name, SIZE_T size, HANDLE root, HANDLE *handle, void **ptr )
+static void map_shared_memory_section( const WCHAR *name, UINT namelen, SIZE_T size, HANDLE root, HANDLE *handle, void **ptr )
 {
     OBJECT_ATTRIBUTES attr;
     UNICODE_STRING section_str;
     NTSTATUS status;
 
-    section_str.Length = wcslen(name) * sizeof(WCHAR);
+    section_str.Length = (namelen ? namelen : wcslen(name)) * sizeof(WCHAR);
     section_str.MaximumLength = section_str.Length + sizeof(WCHAR);
     section_str.Buffer = (WCHAR *)name;
     InitializeObjectAttributes( &attr, &section_str, 0, root, NULL );
@@ -629,7 +629,7 @@ volatile struct desktop_shared_memory *get_desktop_shared_memory( void )
         if (i == 0) *(ptr - 1) = '\\';
     }
 
-    map_shared_memory_section( buf, sizeof(struct desktop_shared_memory), root,
+    map_shared_memory_section( buf, ptr - buf - 1, sizeof(struct desktop_shared_memory), root,
                                &thread_info->desktop_shared_map, (void **)&thread_info->desktop_shared_memory );
 
     NtClose( root );
@@ -637,6 +637,23 @@ volatile struct desktop_shared_memory *get_desktop_shared_memory( void )
 }
 
 
+volatile struct queue_shared_memory *get_queue_shared_memory( void )
+{
+    struct user_thread_info *thread_info = get_user_thread_info();
+    char bufA[MAX_PATH];
+    WCHAR buf[MAX_PATH];
+    UINT len;
+
+    if (thread_info->queue_shared_memory) return thread_info->queue_shared_memory;
+
+    snprintf( bufA, ARRAY_SIZE(buf), "\\KernelObjects\\__wine_thread_mappings\\%08x-queue", GetCurrentThreadId() );
+    len = asciiz_to_unicode( buf, bufA ) / sizeof(WCHAR) - 1;
+    map_shared_memory_section( buf, len, sizeof(struct queue_shared_memory), NULL,
+                               &thread_info->queue_shared_map, (void **)&thread_info->queue_shared_memory );
+    return thread_info->queue_shared_memory;
+}
+
+
 /***********************************************************************
  *           winstation_init
  *
diff --git a/include/ntuser.h b/include/ntuser.h
index 11111111111..11111111111 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -888,6 +888,7 @@ enum
     /* temporary exports */
     NtUserExitingThread,
     NtUserThreadDetach,
+    NtUserGetQueueSharedMemory,
 };
 
 static inline BOOL NtUserDestroyCaret(void)
diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -872,6 +872,10 @@ struct queue_shared_memory
 {
     unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     int                  created;          /* queue has been created */
+    unsigned int         wake_bits;
+    unsigned int         changed_bits;
+    unsigned int         wake_mask;
+    unsigned int         changed_mask;
 };
 
 /* Bits that must be clear for client to read */

From 7ea980634b9db3af7b8ac8a1994d6e96ccc3fdfc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 12 Dec 2021 13:15:45 +0100
Subject: [PATCH 19/44] win32u: Don't check for driver events so often.

Now that PeekMessage may return quickly we don't want to check for
driver events on every call.
---
 dlls/win32u/message.c        | 14 ++++++++++----
 dlls/win32u/ntuser_private.h |  1 +
 2 files changed, 11 insertions(+), 4 deletions(-)

diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -1972,7 +1972,8 @@ static HANDLE get_server_queue_handle(void)
 /* check for driver events if we detect that the app is not properly consuming messages */
 static inline void check_for_driver_events( UINT msg )
 {
-    if (get_user_thread_info()->message_count > 200)
+    struct user_thread_info *thread_info = get_user_thread_info();
+    if (thread_info->message_count > 200)
     {
         LARGE_INTEGER zero = { .QuadPart = 0 };
         flush_window_surfaces( FALSE );
@@ -1981,9 +1982,9 @@ static inline void check_for_driver_events( UINT msg )
     else if (msg == WM_TIMER || msg == WM_SYSTIMER)
     {
         /* driver events should have priority over timers, so make sure we'll check for them soon */
-        get_user_thread_info()->message_count += 100;
+        thread_info->message_count += 100;
     }
-    else get_user_thread_info()->message_count++;
+    else thread_info->message_count++;
 }
 
 /* helper for kernel32->ntdll timeout format conversion */
@@ -2148,17 +2149,21 @@ DWORD WINAPI NtUserWaitForInputIdle( HANDLE process, DWORD timeout, BOOL wow )
  */
 BOOL WINAPI NtUserPeekMessage( MSG *msg_out, HWND hwnd, UINT first, UINT last, UINT flags )
 {
+    struct user_thread_info *thread_info = get_user_thread_info();
     MSG msg;
     int ret;
 
     user_check_not_lock();
-    check_for_driver_events( 0 );
+    if (thread_info->last_driver_time != NtGetTickCount())
+        check_for_driver_events( 0 );
 
     ret = peek_message( &msg, hwnd, first, last, flags, 0 );
     if (ret < 0) return FALSE;
 
     if (!ret)
     {
+        if (thread_info->last_driver_time == NtGetTickCount()) return FALSE;
+        thread_info->last_driver_time = NtGetTickCount();
         flush_window_surfaces( TRUE );
         ret = wait_message( 0, NULL, 0, QS_ALLINPUT, 0 );
         /* if we received driver events, check again for a pending message */
@@ -2166,6 +2171,7 @@ BOOL WINAPI NtUserPeekMessage( MSG *msg_out, HWND hwnd, UINT first, UINT last, U
     }
 
     check_for_driver_events( msg.message );
+    thread_info->last_driver_time = NtGetTickCount() - 1;
 
     /* copy back our internal safe copy of message data to msg_out.
      * msg_out is a variable from the *program*, so it can't be used
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -123,6 +123,7 @@ struct user_thread_info
     HANDLE                        server_queue;           /* Handle to server-side queue */
     DWORD                         wake_mask;              /* Current queue wake mask */
     DWORD                         changed_mask;           /* Current queue changed mask */
+    DWORD                         last_driver_time;       /* Get/PeekMessage driver event time */
     WORD                          message_count;          /* Get/PeekMessage loop counter */
     WORD                          hook_call_depth;        /* Number of recursively called hook procs */
     WORD                          hook_unicode;           /* Is current hook unicode? */

From 0ec3a8f613f4f90bec735b181712eb0d4f8c8940 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 24 Nov 2020 19:21:42 +0100
Subject: [PATCH 20/44] esync: win32u: Always call get_message request after
 waiting.

Because with esync and fsync the wait happens on the client-side, so
we need to make the request to do the server side effects.
---
 dlls/win32u/message.c | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -1645,7 +1645,7 @@ static BOOL process_hardware_message( MSG *msg, UINT hw_id, const struct hardwar
  * available; -1 on error.
  * All pending sent messages are processed before returning.
  */
-static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags, UINT changed_mask )
+static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags, UINT changed_mask, BOOL waited )
 {
     LRESULT result;
     volatile struct queue_shared_memory *shared = get_queue_shared_memory();
@@ -1680,7 +1680,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
 
         thread_info->client_info.msg_source = prev_source;
 
-        if (!shared) skip = FALSE;
+        if (!shared || waited) skip = FALSE;
         else SHARED_READ_BEGIN( &shared->seq )
         {
             /* not created yet */
@@ -1880,7 +1880,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                 }
                 else
                     peek_message( msg, info.msg.hwnd, info.msg.message,
-                                  info.msg.message, flags | PM_REMOVE, changed_mask );
+                                  info.msg.message, flags | PM_REMOVE, changed_mask, TRUE );
                 continue;
             }
             if (info.msg.message >= WM_DDE_FIRST && info.msg.message <= WM_DDE_LAST)
@@ -1942,7 +1942,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
 static void process_sent_messages(void)
 {
     MSG msg;
-    peek_message( &msg, 0, 0, 0, PM_REMOVE | PM_QS_SENDMESSAGE, 0 );
+    peek_message( &msg, 0, 0, 0, PM_REMOVE | PM_QS_SENDMESSAGE, 0, FALSE );
 }
 
 /***********************************************************************
@@ -2157,7 +2157,7 @@ BOOL WINAPI NtUserPeekMessage( MSG *msg_out, HWND hwnd, UINT first, UINT last, U
     if (thread_info->last_driver_time != NtGetTickCount())
         check_for_driver_events( 0 );
 
-    ret = peek_message( &msg, hwnd, first, last, flags, 0 );
+    ret = peek_message( &msg, hwnd, first, last, flags, 0, FALSE );
     if (ret < 0) return FALSE;
 
     if (!ret)
@@ -2167,7 +2167,7 @@ BOOL WINAPI NtUserPeekMessage( MSG *msg_out, HWND hwnd, UINT first, UINT last, U
         flush_window_surfaces( TRUE );
         ret = wait_message( 0, NULL, 0, QS_ALLINPUT, 0 );
         /* if we received driver events, check again for a pending message */
-        if (ret == WAIT_TIMEOUT || peek_message( &msg, hwnd, first, last, flags, 0 ) <= 0) return FALSE;
+        if (ret == WAIT_TIMEOUT || peek_message( &msg, hwnd, first, last, flags, 0, TRUE ) <= 0) return FALSE;
     }
 
     check_for_driver_events( msg.message );
@@ -2209,7 +2209,7 @@ BOOL WINAPI NtUserGetMessage( MSG *msg, HWND hwnd, UINT first, UINT last )
     }
     else mask = QS_ALLINPUT;
 
-    while (!(ret = peek_message( msg, hwnd, first, last, PM_REMOVE | (mask << 16), mask )))
+    while (!(ret = peek_message( msg, hwnd, first, last, PM_REMOVE | (mask << 16), mask, TRUE )))
     {
         wait_objects( 1, &server_queue, INFINITE, mask & (QS_SENDMESSAGE | QS_SMRESULT), mask, 0 );
     }

From 19ff7b62ab6eefaaf1aad8ca342e118e133c9dc9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 12 Dec 2021 13:16:00 +0100
Subject: [PATCH 21/44] win32u: Call get_message request at least once every
 3s.

So that the thread queue isn't incorrectly flagged as hung.
---
 dlls/win32u/message.c        | 3 ++-
 dlls/win32u/ntuser_private.h | 1 +
 2 files changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -1680,7 +1680,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
 
         thread_info->client_info.msg_source = prev_source;
 
-        if (!shared || waited) skip = FALSE;
+        if (!shared || waited || NtGetTickCount() - thread_info->last_getmsg_time >= 3000) skip = FALSE;
         else SHARED_READ_BEGIN( &shared->seq )
         {
             /* not created yet */
@@ -1710,6 +1710,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
             req->wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
             req->changed_mask = changed_mask;
             wine_server_set_reply( req, buffer, buffer_size );
+            thread_info->last_getmsg_time = NtGetTickCount();
             if (!(res = wine_server_call( req )))
             {
                 size = wine_server_reply_size( reply );
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -124,6 +124,7 @@ struct user_thread_info
     DWORD                         wake_mask;              /* Current queue wake mask */
     DWORD                         changed_mask;           /* Current queue changed mask */
     DWORD                         last_driver_time;       /* Get/PeekMessage driver event time */
+    DWORD                         last_getmsg_time;       /* Get/PeekMessage last request time */
     WORD                          message_count;          /* Get/PeekMessage loop counter */
     WORD                          hook_call_depth;        /* Number of recursively called hook procs */
     WORD                          hook_unicode;           /* Is current hook unicode? */
From 5a7ff5331e0c29110417c02f2e494aaecf8b5794 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 29 Apr 2021 11:36:15 +0200
Subject: [PATCH 22/44] win32u: Allocate heap in peek_message only when
 necessary.

---
 dlls/win32u/message.c | 30 ++++++++++++++++++++++--------
 1 file changed, 22 insertions(+), 8 deletions(-)

diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -1653,12 +1653,11 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
     INPUT_MESSAGE_SOURCE prev_source = thread_info->client_info.msg_source;
     struct received_message_info info;
     unsigned int hw_id = 0;  /* id of previous hardware message */
-    void *buffer;
+    char buffer_init[1024];
     size_t buffer_size = 1024;
+    void *buffer = buffer_init;
     BOOL skip = FALSE;
 
-    if (!(buffer = malloc( buffer_size ))) return -1;
-
     if (!first && !last) last = ~0;
     if (hwnd == HWND_BROADCAST) hwnd = HWND_TOPMOST;
 
@@ -1733,19 +1732,22 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
 
         if (res)
         {
-            free( buffer );
             if (res == STATUS_PENDING)
             {
                 thread_info->wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
                 thread_info->changed_mask = changed_mask;
+                if (buffer != buffer_init) free( buffer );
                 return 0;
             }
             if (res != STATUS_BUFFER_OVERFLOW)
             {
                 RtlSetLastWin32Error( RtlNtStatusToDosError(res) );
+                if (buffer != buffer_init) free( buffer );
                 return -1;
             }
-            if (!(buffer = malloc( buffer_size ))) return -1;
+            if (buffer == buffer_init) buffer = malloc( buffer_size );
+            else buffer = realloc( buffer, buffer_size );
+            if (!buffer) return -1;
             continue;
         }
 
@@ -1762,6 +1764,12 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
             break;
         case MSG_NOTIFY:
             info.flags = ISMEX_NOTIFY;
+            /* unpack_message may have to reallocate */
+            if (buffer == buffer_init)
+            {
+                buffer = malloc( buffer_size );
+                memcpy( buffer, buffer_init, buffer_size );
+            }
             if (!unpack_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
                                  &info.msg.lParam, &buffer, size ))
                 continue;
@@ -1837,6 +1845,12 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
             continue;
         case MSG_OTHER_PROCESS:
             info.flags = ISMEX_SEND;
+            /* unpack_message may have to reallocate */
+            if (buffer == buffer_init)
+            {
+                buffer = malloc( buffer_size );
+                memcpy( buffer, buffer_init, buffer_size );
+            }
             if (!unpack_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
                                  &info.msg.lParam, &buffer, size ))
             {
@@ -1860,7 +1874,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                 thread_info->client_info.message_pos   = MAKELONG( info.msg.pt.x, info.msg.pt.y );
                 thread_info->client_info.message_time  = info.msg.time;
                 thread_info->client_info.message_extra = msg_data->hardware.info;
-                free( buffer );
+                if (buffer != buffer_init) free( buffer );
                 call_hooks( WH_GETMESSAGE, HC_ACTION, flags & PM_REMOVE, (LPARAM)msg, sizeof(*msg) );
                 return 1;
             }
@@ -1875,7 +1889,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                     /* if this is a nested call return right away */
                     if (first == info.msg.message && last == info.msg.message)
                     {
-                        free( buffer );
+                        if (buffer != buffer_init) free( buffer );
                         return 0;
                     }
                 }
@@ -1913,7 +1927,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
             thread_info->client_info.message_time  = info.msg.time;
             thread_info->client_info.message_extra = 0;
             thread_info->client_info.msg_source = msg_source_unavailable;
-            free( buffer );
+            if (buffer != buffer_init) free( buffer );
             call_hooks( WH_GETMESSAGE, HC_ACTION, flags & PM_REMOVE, (LPARAM)msg, sizeof(*msg) );
             return 1;
         }

From f8230e1736c8f2b3ae25f2ab71b5bbb8172921ee Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 29 Apr 2021 20:07:16 +0200
Subject: [PATCH 23/44] win32u: Yield thread in peek_message when no message
 was found.

---
 dlls/win32u/message.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -1737,6 +1737,7 @@ static int peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags,
                 thread_info->wake_mask = changed_mask & (QS_SENDMESSAGE | QS_SMRESULT);
                 thread_info->changed_mask = changed_mask;
                 if (buffer != buffer_init) free( buffer );
+                NtYieldExecution();
                 return 0;
             }
             if (res != STATUS_BUFFER_OVERFLOW)

From f5ae6d0a9a4217880d8f312b1687b5ec5fe89803 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 14 Jan 2021 15:22:05 +0100
Subject: [PATCH 24/44] server: Create a thread input shared mapping.

---
 server/protocol.def |  8 ++++++++
 server/thread.c     | 41 ++++++++++++++++++++++++++++++++++++++++-
 server/thread.h     |  2 ++
 4 files changed, 70 insertions(+), 2 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -876,6 +876,14 @@ struct queue_shared_memory
     unsigned int         changed_bits;
     unsigned int         wake_mask;
     unsigned int         changed_mask;
+    thread_id_t          input_tid;
+};
+
+struct input_shared_memory
+{
+    unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
+    int                  created;
+    thread_id_t          tid;
 };
 
 /* Bits that must be clear for client to read */
diff --git a/server/thread.c b/server/thread.c
index 11111111111..11111111111 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -415,13 +417,43 @@ static volatile void *init_queue_mapping( struct thread *thread )
     thread->queue_shared_mapping = create_shared_mapping( dir, &name, sizeof(struct queue_shared_memory),
                                                           NULL, (void **)&thread->queue_shared );
     release_object( dir );
-    if (thread->queue_shared) memset( (void *)thread->queue_shared, 0, sizeof(*thread->queue_shared) );
+    if (thread->queue_shared)
+    {
+        memset( (void *)thread->queue_shared, 0, sizeof(*thread->queue_shared) );
+        thread->queue_shared->input_tid = thread->id;
+    }
 
     free( nameW );
     return thread->queue_shared;
 }
 
 
+static volatile void *init_input_mapping( struct thread *thread )
+{
+    struct unicode_str name;
+    struct object *dir = create_thread_map_directory();
+    char nameA[MAX_PATH];
+    WCHAR *nameW;
+
+    if (!dir) return NULL;
+
+    sprintf( nameA, "%08x-input", thread->id );
+    nameW = ascii_to_unicode_str( nameA, &name );
+
+    thread->input_shared_mapping = create_shared_mapping( dir, &name, sizeof(struct input_shared_memory),
+                                                          NULL, (void **)&thread->input_shared );
+    release_object( dir );
+    if (thread->input_shared)
+    {
+        memset( (void *)thread->input_shared, 0, sizeof(*thread->input_shared) );
+        thread->input_shared->tid = thread->id;
+    }
+
+    free( nameW );
+    return thread->input_shared;
+}
+
+
 /* create a new thread */
 struct thread *create_thread( int fd, struct process *process, const struct security_descriptor *sd )
 {
@@ -515,6 +547,11 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
         release_object( thread );
         return NULL;
     }
+    if (!init_input_mapping( thread ))
+    {
+        release_object( thread );
+        return NULL;
+    }
 
     set_fd_events( thread->request_fd, POLLIN );  /* start listening to events */
     add_process_thread( thread->process, thread );
@@ -585,6 +622,8 @@ static void cleanup_thread( struct thread *thread )
     free( thread->desc );
     if (thread->queue_shared_mapping) release_object( thread->queue_shared_mapping );
     thread->queue_shared_mapping = NULL;
+    if (thread->input_shared_mapping) release_object( thread->input_shared_mapping );
+    thread->input_shared_mapping = NULL;
     thread->req_data = NULL;
     thread->reply_data = NULL;
     thread->request_fd = NULL;

From 4faa990701250ede63fbe0565edfa81757db9289 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 17:35:50 +0100
Subject: [PATCH 25/44] server: Move active window to input shared memory.

---
 server/protocol.def |  1 +
 2 files changed, 29 insertions(+), 16 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -884,6 +884,7 @@ struct input_shared_memory
     unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     int                  created;
     thread_id_t          tid;
+    user_handle_t        active;           /* handle to the active window */
 };
 
 /* Bits that must be clear for client to read */

From e5b6abb3a523b76484f845038ac8c4d7cd251647 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 22:09:12 +0100
Subject: [PATCH 27/44] server: Move focus window to input shared memory.

---
 server/protocol.def |  1 +
 2 files changed, 20 insertions(+), 14 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -884,6 +884,7 @@ struct input_shared_memory
     unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     int                  created;
     thread_id_t          tid;
+    user_handle_t        focus;            /* handle to the focus window */
     user_handle_t        active;           /* handle to the active window */
 };
 
From ce9855cbfc8a40565f1087b3e52612d0616747f2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 17:58:36 +0100
Subject: [PATCH 29/44] server: Add foreground TID to desktop shared memory.

---
 server/protocol.def | 1 +
 2 files changed, 4 insertions(+)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -866,6 +866,7 @@ struct desktop_shared_memory
     unsigned int         seq;              /* sequence number - server updating if (seq_no & SEQUENCE_MASK) != 0 */
     struct shared_cursor cursor;           /* global cursor information */
     unsigned char        keystate[256];    /* asynchronous key state */
+    thread_id_t          foreground_tid;   /* tid of the foreground thread */
 };
 
 struct queue_shared_memory

From ca77e4d54b94134ede5fd155e8af5eda7ae36a0c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 17:58:36 +0100
Subject: [PATCH 30/44] win32u: Use desktop shared memory for
 NtUserGetForegroundWindow.

---
 dlls/win32u/input.c          |  9 +++++----
 dlls/win32u/ntuser_private.h |  2 ++
 dlls/win32u/sysparams.c      | 10 ++++++++++
 dlls/win32u/win32u_private.h |  1 +
 dlls/win32u/winstation.c     | 37 ++++++++++++++++++++++++++++++++++++
 include/ntuser.h             |  1 +
 6 files changed, 56 insertions(+), 4 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -1457,14 +1457,15 @@ BOOL WINAPI release_capture(void)
  */
 HWND WINAPI NtUserGetForegroundWindow(void)
 {
+    volatile struct input_shared_memory *shared = (void *)NtUserCallNoParam( NtUserGetForegroundSharedMemory );
     HWND ret = 0;
 
-    SERVER_START_REQ( get_thread_input )
+    if (!shared) return 0;
+    SHARED_READ_BEGIN( &shared->seq )
     {
-        req->tid = 0;
-        if (!wine_server_call_err( req )) ret = wine_server_ptr_handle( reply->foreground );
+        ret = wine_server_ptr_handle( shared->active );
     }
-    SERVER_END_REQ;
+    SHARED_READ_END( &shared->seq );
     return ret;
 }
 
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -140,6 +140,8 @@ struct user_thread_info
     struct desktop_shared_memory *desktop_shared_memory;  /* Ptr to server's desktop shared memory */
     HANDLE                        queue_shared_map;       /* HANDLE to server's thread queue shared memory */
     struct queue_shared_memory   *queue_shared_memory;     /* Ptr to server's thread queue shared memory */
+    HANDLE                        foreground_shared_map;    /* HANDLE to server's thread input shared memory */
+    struct input_shared_memory   *foreground_shared_memory; /* Ptr to server's thread input shared memory */
 };
 
 C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo) );
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4929,6 +4929,13 @@ static void thread_detach(void)
         thread_info->queue_shared_memory = NULL;
     }
 
+    if (thread_info->foreground_shared_memory)
+    {
+        NtClose( thread_info->foreground_shared_map );
+        thread_info->foreground_shared_map = NULL;
+        thread_info->foreground_shared_memory = NULL;
+    }
+
     exiting_thread_id = 0;
 }
 
@@ -4969,6 +4976,9 @@ ULONG_PTR WINAPI NtUserCallNoParam( ULONG code )
     case NtUserGetQueueSharedMemory:
         return (ULONG_PTR)get_queue_shared_memory();
 
+    case NtUserGetForegroundSharedMemory:
+        return (ULONG_PTR)get_foreground_shared_memory();
+
     default:
         FIXME( "invalid code %u\n", code );
         return 0;
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -411,6 +411,7 @@ static inline void release_win_ptr( struct tagWND *ptr )
 /* winstation.c */
 extern volatile struct desktop_shared_memory *get_desktop_shared_memory( void ) DECLSPEC_HIDDEN;
 extern volatile struct queue_shared_memory *get_queue_shared_memory( void ) DECLSPEC_HIDDEN;
+extern volatile struct input_shared_memory *get_foreground_shared_memory( void ) DECLSPEC_HIDDEN;
 
 extern void wrappers_init( unixlib_handle_t handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS gdi_init(void) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -654,6 +654,43 @@ volatile struct queue_shared_memory *get_queue_shared_memory( void )
 }
 
 
+static volatile struct input_shared_memory *get_thread_input_shared_memory( DWORD tid, HANDLE *handle,
+                                                                            struct input_shared_memory **ptr )
+{
+    char bufA[MAX_PATH];
+    WCHAR buf[MAX_PATH];
+    UINT len;
+
+    if (*ptr && (*ptr)->tid == tid) return *ptr;
+    if (*ptr) NtClose( *handle );
+
+    snprintf( bufA, ARRAY_SIZE(buf), "\\KernelObjects\\__wine_thread_mappings\\%08x-input", tid );
+    len = asciiz_to_unicode( buf, bufA ) / sizeof(WCHAR) - 1;
+    map_shared_memory_section( buf, len, sizeof(struct input_shared_memory), NULL,
+                               handle, (void **)ptr );
+    return *ptr;
+}
+
+
+volatile struct input_shared_memory *get_foreground_shared_memory( void )
+{
+    volatile struct desktop_shared_memory *desktop = get_desktop_shared_memory();
+    struct user_thread_info *thread_info = get_user_thread_info();
+    DWORD tid;
+
+    if (!desktop) return NULL;
+    SHARED_READ_BEGIN( &desktop->seq )
+    {
+        tid = desktop->foreground_tid;
+    }
+    SHARED_READ_END( &desktop->seq );
+
+    if (!tid) return NULL;
+    return get_thread_input_shared_memory( tid, &thread_info->foreground_shared_map,
+                                           &thread_info->foreground_shared_memory );
+}
+
+
 /***********************************************************************
  *           winstation_init
  *
diff --git a/include/ntuser.h b/include/ntuser.h
index 11111111111..11111111111 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -889,6 +889,7 @@ enum
     NtUserExitingThread,
     NtUserThreadDetach,
     NtUserGetQueueSharedMemory,
+    NtUserGetForegroundSharedMemory,
 };
 

 static inline BOOL NtUserDestroyCaret(void)
From cde69743bd41781e7399d28340170fdd53f41ed0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 22:10:36 +0100
Subject: [PATCH 31/44] server: Move capture window to input shared memory.

As well as menu owner / menu size window handles.
---
 server/protocol.def |  3 +++
 2 files changed, 22 insertions(+), 20 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -886,7 +886,10 @@ struct input_shared_memory
     int                  created;
     thread_id_t          tid;
     user_handle_t        focus;            /* handle to the focus window */
+    user_handle_t        capture;          /* handle to the capture window */
     user_handle_t        active;           /* handle to the active window */
+    user_handle_t        menu_owner;       /* handle to the menu owner */
+    user_handle_t        move_size;        /* handle to the moving/resizing window */
 };
 
 /* Bits that must be clear for client to read */
 

From 2f7d72a74d8a8f1fcb9721e7f9abe484dbb4e015 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 18:44:03 +0100
Subject: [PATCH 33/44] server: Move caret window and rect to input shared
 memory.

---
 server/protocol.def |  2 ++
 2 files changed, 28 insertions(+), 22 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -890,6 +890,8 @@ struct input_shared_memory
     user_handle_t        active;           /* handle to the active window */
     user_handle_t        menu_owner;       /* handle to the menu owner */
     user_handle_t        move_size;        /* handle to the moving/resizing window */
+    user_handle_t        caret;            /* handle to the caret window */
+    rectangle_t          caret_rect;       /* caret rectangle */
 };
 
 /* Bits that must be clear for client to read */

From c2f5ed4a58ea39c4672edbf98138dbab7da54361 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 19:05:34 +0100
Subject: [PATCH 34/44] win32u: Use input shared memory for
 NtUserGetGUIThreadInfo.

When the current thread is requested.
---
 dlls/win32u/message.c        | 28 ++++++++++++++++++++++++++++
 dlls/win32u/ntuser_private.h |  2 ++
 dlls/win32u/sysparams.c      | 10 ++++++++++
 dlls/win32u/win32u_private.h |  1 +
 dlls/win32u/winstation.c     | 18 ++++++++++++++++++
 include/ntuser.h             |  1 +
 6 files changed, 60 insertions(+)

diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -1162,6 +1162,7 @@ static LRESULT handle_internal_message( HWND hwnd, UINT msg, WPARAM wparam, LPAR
  */
 BOOL WINAPI NtUserGetGUIThreadInfo( DWORD id, GUITHREADINFO *info )
 {
+    volatile struct input_shared_memory *shared;
     BOOL ret;
 
     if (info->cbSize != sizeof(*info))
@@ -1170,6 +1171,33 @@ BOOL WINAPI NtUserGetGUIThreadInfo( DWORD id, GUITHREADINFO *info )
         return FALSE;
     }
 
+    if (id == GetCurrentThreadId()) shared = get_input_shared_memory();
+    else if (id == 0) shared = get_foreground_shared_memory();
+    else shared = NULL;
+
+    if (shared)
+    {
+        SHARED_READ_BEGIN( &shared->seq )
+        {
+            info->flags          = 0;
+            info->hwndActive     = wine_server_ptr_handle( shared->active );
+            info->hwndFocus      = wine_server_ptr_handle( shared->focus );
+            info->hwndCapture    = wine_server_ptr_handle( shared->capture );
+            info->hwndMenuOwner  = wine_server_ptr_handle( shared->menu_owner );
+            info->hwndMoveSize   = wine_server_ptr_handle( shared->move_size );
+            info->hwndCaret      = wine_server_ptr_handle( shared->caret );
+            info->rcCaret.left   = shared->caret_rect.left;
+            info->rcCaret.top    = shared->caret_rect.top;
+            info->rcCaret.right  = shared->caret_rect.right;
+            info->rcCaret.bottom = shared->caret_rect.bottom;
+        }
+        SHARED_READ_END( &shared->seq );
+        if (info->hwndMenuOwner) info->flags |= GUI_INMENUMODE;
+        if (info->hwndMoveSize) info->flags |= GUI_INMOVESIZE;
+        if (info->hwndCaret) info->flags |= GUI_CARETBLINKING;
+        return TRUE;
+    }
+
     SERVER_START_REQ( get_thread_input )
     {
         req->tid = id;
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -140,6 +140,8 @@ struct user_thread_info
     struct desktop_shared_memory *desktop_shared_memory;  /* Ptr to server's desktop shared memory */
     HANDLE                        queue_shared_map;       /* HANDLE to server's thread queue shared memory */
     struct queue_shared_memory   *queue_shared_memory;     /* Ptr to server's thread queue shared memory */
+    HANDLE                        input_shared_map;       /* HANDLE to server's thread input shared memory */
+    struct input_shared_memory   *input_shared_memory;    /* Ptr to server's thread input shared memory */
     HANDLE                        foreground_shared_map;    /* HANDLE to server's thread input shared memory */
     struct input_shared_memory   *foreground_shared_memory; /* Ptr to server's thread input shared memory */
 };
diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4936,6 +4936,13 @@ static void thread_detach(void)
         thread_info->foreground_shared_memory = NULL;
     }
 
+    if (thread_info->input_shared_map)
+    {
+        NtClose( thread_info->input_shared_map );
+        thread_info->input_shared_map = NULL;
+        thread_info->input_shared_memory = NULL;
+    }
+
     exiting_thread_id = 0;
 }
 
@@ -4976,6 +4983,9 @@ ULONG_PTR WINAPI NtUserCallNoParam( ULONG code )
     case NtUserGetQueueSharedMemory:
         return (ULONG_PTR)get_queue_shared_memory();
 
+    case NtUserGetInputSharedMemory:
+        return (ULONG_PTR)get_input_shared_memory();
+
     case NtUserGetForegroundSharedMemory:
         return (ULONG_PTR)get_foreground_shared_memory();
 
diff --git a/dlls/win32u/win32u_private.h b/dlls/win32u/win32u_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/win32u_private.h
+++ b/dlls/win32u/win32u_private.h
@@ -411,6 +411,7 @@ static inline void release_win_ptr( struct tagWND *ptr )
 /* winstation.c */
 extern volatile struct desktop_shared_memory *get_desktop_shared_memory( void ) DECLSPEC_HIDDEN;
 extern volatile struct queue_shared_memory *get_queue_shared_memory( void ) DECLSPEC_HIDDEN;
+extern volatile struct input_shared_memory *get_input_shared_memory( void ) DECLSPEC_HIDDEN;
 extern volatile struct input_shared_memory *get_foreground_shared_memory( void ) DECLSPEC_HIDDEN;
 
 extern void wrappers_init( unixlib_handle_t handle ) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/winstation.c b/dlls/win32u/winstation.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/winstation.c
+++ b/dlls/win32u/winstation.c
@@ -672,6 +672,24 @@ static volatile struct input_shared_memory *get_thread_input_shared_memory( DWOR
 }
 
 
+volatile struct input_shared_memory *get_input_shared_memory( void )
+{
+    volatile struct queue_shared_memory *queue = get_queue_shared_memory();
+    struct user_thread_info *thread_info = get_user_thread_info();
+    DWORD tid;
+
+    if (!queue) return NULL;
+    SHARED_READ_BEGIN( &queue->seq )
+    {
+        tid = queue->input_tid;
+    }
+    SHARED_READ_END( &queue->seq );
+
+    return get_thread_input_shared_memory( tid, &thread_info->input_shared_map,
+                                           &thread_info->input_shared_memory );
+}
+
+
 volatile struct input_shared_memory *get_foreground_shared_memory( void )
 {
     volatile struct desktop_shared_memory *desktop = get_desktop_shared_memory();
diff --git a/include/ntuser.h b/include/ntuser.h
index 11111111111..11111111111 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -889,6 +889,7 @@ enum
     NtUserExitingThread,
     NtUserThreadDetach,
     NtUserGetQueueSharedMemory,
+    NtUserGetInputSharedMemory,
     NtUserGetForegroundSharedMemory,
 };
 

From 5dff1abe64d7bf7101719238bea1b38503674e7f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 22:11:03 +0100
Subject: [PATCH 35/44] server: Add cursor handle and count to desktop shared
 memory.

---
 server/protocol.def |  2 ++
 2 files changed, 28 insertions(+), 18 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -891,7 +891,9 @@ struct input_shared_memory
     user_handle_t        menu_owner;       /* handle to the menu owner */
     user_handle_t        move_size;        /* handle to the moving/resizing window */
     user_handle_t        caret;            /* handle to the caret window */
+    user_handle_t        cursor;           /* handle to the cursor */
     rectangle_t          caret_rect;       /* caret rectangle */
+    int                  cursor_count;     /* cursor show count */
 };
 
 /* Bits that must be clear for client to read */

From 767573f9d1e60eda9bd96a967087be7833711883 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 19:19:51 +0100
Subject: [PATCH 36/44] win32u: Use input shared memory for
 NtUserGetCursorInfo.

---
 dlls/win32u/input.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -247,20 +247,19 @@ BOOL get_cursor_pos( POINT *pt )
  */
 BOOL WINAPI NtUserGetCursorInfo( CURSORINFO *info )
 {
+    volatile struct input_shared_memory *shared = get_foreground_shared_memory();
     BOOL ret;
 
     if (!info) return FALSE;
 
-    SERVER_START_REQ( get_thread_input )
+    if (!shared) ret = FALSE;
+    else SHARED_READ_BEGIN( &shared->seq )
     {
-        req->tid = 0;
-        if ((ret = !wine_server_call( req )))
-        {
-            info->hCursor = wine_server_ptr_handle( reply->cursor );
-            info->flags = reply->show_count >= 0 ? CURSOR_SHOWING : 0;
-        }
+        info->hCursor = wine_server_ptr_handle( shared->cursor );
+        info->flags = (shared->cursor_count >= 0) ? CURSOR_SHOWING : 0;
+        ret = TRUE;
     }
-    SERVER_END_REQ;
+    SHARED_READ_END( &shared->seq );
     get_cursor_pos( &info->ptScreenPos );
     return ret;
 }

From be54be762ed7aedc15d980c6702470d0e1ddeb52 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 19:21:09 +0100
Subject: [PATCH 37/44] server: Remove cursor and show_count from
 get_thread_input.

---
 server/protocol.def | 2 --
 2 files changed, 4 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2832,8 +2832,6 @@ enum coords_relative
     user_handle_t  menu_owner;    /* handle to the menu owner */
     user_handle_t  move_size;     /* handle to the moving/resizing window */
     user_handle_t  caret;         /* handle to the caret window */
-    user_handle_t  cursor;        /* handle to the cursor */
-    int            show_count;    /* cursor show count */
     rectangle_t    rect;          /* caret rectangle */
 @END
 

From 39b9c877184c02da92579ce802a6065b5f13a318 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 18 Jan 2021 22:12:08 +0100
Subject: [PATCH 38/44] server: Remove foreground window from get_thread_input.

---
 server/protocol.def | 1 -
 2 files changed, 3 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -2828,7 +2828,6 @@ enum coords_relative
     user_handle_t  focus;         /* handle to the focus window */
     user_handle_t  capture;       /* handle to the capture window */
     user_handle_t  active;        /* handle to the active window */
-    user_handle_t  foreground;    /* handle to the global foreground window */
     user_handle_t  menu_owner;    /* handle to the menu owner */
     user_handle_t  move_size;     /* handle to the moving/resizing window */
     user_handle_t  caret;         /* handle to the caret window */

From 220995052ae29bf019797b94acda32edea1ef2ac Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 1 Mar 2021 20:19:52 +0100
Subject: [PATCH 39/44] HACK: win32u: Always pretend that
 NtUserGetAsyncKeyState recent bit is 0.

---
 dlls/win32u/input.c | 19 +------------------
 1 file changed, 1 insertion(+), 18 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -278,7 +278,6 @@ SHORT WINAPI NtUserGetAsyncKeyState( INT key )
 {
     volatile struct desktop_shared_memory *shared = get_desktop_shared_memory();
     BYTE state;
-    SHORT ret;
 
     if (key < 0 || key >= 256 || !shared) return 0;
 
@@ -290,23 +289,7 @@ SHORT WINAPI NtUserGetAsyncKeyState( INT key )
     }
     SHARED_READ_END( &shared->seq );
 
-    if (!(state & 0x40)) return (state & 0x80) << 8;
-
-    /* Need to make a server call to reset the last pressed bit */
-    ret = 0;
-    SERVER_START_REQ( get_key_state )
-    {
-        req->async = 1;
-        req->key = key;
-        if (!wine_server_call( req ))
-        {
-            if (reply->state & 0x40) ret |= 0x0001;
-            if (reply->state & 0x80) ret |= 0x8000;
-        }
-    }
-    SERVER_END_REQ;
-
-    return ret;
+    return (state & 0x80) << 8;
 }
 

 /***********************************************************************


From f3f46208febe592baf64c9e475556cbe6ae03fcf Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 17 Aug 2021 17:14:13 +0200
Subject: [PATCH 41/44] server: Expose thread input keystate through shared
 memory.

---
 server/protocol.def |  1 +
 2 files changed, 19 insertions(+), 8 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -894,6 +894,7 @@ struct input_shared_memory
     user_handle_t        cursor;           /* handle to the cursor */
     rectangle_t          caret_rect;       /* caret rectangle */
     int                  cursor_count;     /* cursor show count */
+    unsigned char        keystate[256];    /* key state */
 };
 
 /* Bits that must be clear for client to read */

From 883ca3744ca413973955dd569dc0012c4ba8c673 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Mon, 28 Mar 2022 06:41:24 +0200
Subject: [PATCH 42/44] win32u: Use input shared memory in
 NtUserGetKeyboardState.

Almost entirely copied from a commit by Rmi Bernon.
---
 dlls/win32u/input.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -416,11 +416,23 @@ SHORT WINAPI NtUserGetKeyState( INT vkey )
  */
 BOOL WINAPI NtUserGetKeyboardState( BYTE *state )
 {
+    volatile struct input_shared_memory *shared = get_input_shared_memory();
+    BOOL skip = TRUE;
     BOOL ret;
     UINT i;
 
     TRACE("(%p)\n", state);
 
+    if (!shared) skip = FALSE;
+    else SHARED_READ_BEGIN( &shared->seq )
+    {
+        if (!shared->created) skip = FALSE; /* server needs to create the queue */
+        else memcpy( state, (const void *)shared->keystate, 256 );
+    }
+    SHARED_READ_END( &shared->seq );
+
+    if (skip) return TRUE;
+
     memset( state, 0, 256 );
     SERVER_START_REQ( get_key_state )
     {
-- 
2.37.2

From c0ab0960e7741fda399f0faea953fc713b02b3df Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 17 Aug 2021 17:22:26 +0200
Subject: [PATCH 43/44] server: Expose thread input keystate lock through
 shared memory.

---
 server/protocol.def |  1 +
 2 files changed, 10 insertions(+), 6 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -895,6 +895,7 @@ struct input_shared_memory
     rectangle_t          caret_rect;       /* caret rectangle */
     int                  cursor_count;     /* cursor show count */
     unsigned char        keystate[256];    /* key state */
+    int                  keystate_lock;    /* keystate is locked */
 };
 
 /* Bits that must be clear for client to read */

From b2858cafcbbe79f227b464acfd295a9888560e1a Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Mon, 28 Mar 2022 06:36:00 +0200
Subject: [PATCH 44/44] win32u: Use input shared memory for NtUserGetKeyState.

Almost entirely copied from a commit by Rmi Bernon.
---
 dlls/win32u/input.c | 22 ++++++++++++++++++----
 1 file changed, 18 insertions(+), 4 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -399,14 +399,28 @@ HKL WINAPI NtUserGetKeyboardLayout( DWORD thread_id )
  */
 SHORT WINAPI NtUserGetKeyState( INT vkey )
 {
+    volatile struct input_shared_memory *shared = get_input_shared_memory();
     SHORT retval = 0;
+    BOOL skip = TRUE;
 
-    SERVER_START_REQ( get_key_state )
+    if (!shared) skip = FALSE;
+    else SHARED_READ_BEGIN( &shared->seq )
     {
-        req->key = vkey;
-        if (!wine_server_call( req )) retval = (signed char)(reply->state & 0x81);
+        if (!shared->created) skip = FALSE; /* server needs to create the queue */
+        else if (!shared->keystate_lock) skip = FALSE; /* server needs to call sync_input_keystate */
+        else retval = (signed char)(shared->keystate[vkey & 0xff] & 0x81);
+    }
+    SHARED_READ_END( &shared->seq );
+
+    if (!skip)
+    {
+        SERVER_START_REQ( get_key_state )
+        {
+            req->key = vkey;
+            if (!wine_server_call( req )) retval = (signed char)(reply->state & 0x81);
+        }
+        SERVER_END_REQ;
     }
-    SERVER_END_REQ;
     TRACE("key (0x%x) -> %x\n", vkey, retval);
     return retval;
 }
-- 
2.37.2

From b4b45f190c154600a7a51f5972f01eaccfef10f6 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Mon, 28 Mar 2022 06:32:47 +0200
Subject: [PATCH 45/44] winex11.drv: Use desktop shared memory for
 get_async_key_state.

---
 dlls/win32u/sysparams.c     |  3 +++
 dlls/winex11.drv/keyboard.c | 11 ++++++++++-
 dlls/winex11.drv/x11drv.h   | 20 ++++++++++++++++++++
 include/ntuser.h            |  1 +
 4 files changed, 34 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/sysparams.c b/dlls/win32u/sysparams.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/sysparams.c
+++ b/dlls/win32u/sysparams.c
@@ -4980,6 +4980,9 @@ ULONG_PTR WINAPI NtUserCallNoParam( ULONG code )
         thread_detach();
         return 0;
 
+    case NtUserGetDesktopSharedMemory:
+        return (ULONG_PTR)get_desktop_shared_memory();
+
     case NtUserGetQueueSharedMemory:
         return (ULONG_PTR)get_queue_shared_memory();
 
diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index 11111111111..11111111111 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -1155,7 +1155,16 @@ static void X11DRV_send_keyboard_input( HWND hwnd, WORD vkey, WORD scan, DWORD f
  */
 static BOOL get_async_key_state( BYTE state[256] )
 {
-    BOOL ret;
+    volatile struct desktop_shared_memory *shared = (void *)NtUserCallNoParam( NtUserGetDesktopSharedMemory );
+    BOOL skip = TRUE, ret;
+
+    if (!shared) skip = FALSE;
+    else SHARED_READ_BEGIN( &shared->seq )
+    {
+        memcpy( state, (void*)shared->keystate, 256 );
+    }
+    SHARED_READ_END( &shared->seq );
+    if (skip) return TRUE;
 
     SERVER_START_REQ( get_key_state )
     {
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 11111111111..11111111111 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -939,4 +939,24 @@ static inline UINT asciiz_to_unicode( WCHAR *dst, const char *src )
     return (p - dst) * sizeof(WCHAR);
 }
 
+#if defined(__i386__) || defined(__x86_64__)
+#define __SHARED_READ_SEQ( x ) (*(x))
+#define __SHARED_READ_FENCE do {} while(0)
+#else
+#define __SHARED_READ_SEQ( x ) __atomic_load_n( x, __ATOMIC_RELAXED )
+#define __SHARED_READ_FENCE __atomic_thread_fence( __ATOMIC_ACQUIRE )
+#endif
+
+#define SHARED_READ_BEGIN( x )                                          \
+    do {                                                                \
+        unsigned int __seq;                                             \
+        do {                                                            \
+            while ((__seq = __SHARED_READ_SEQ( x )) & SEQUENCE_MASK) NtYieldExecution(); \
+            __SHARED_READ_FENCE;
+
+#define SHARED_READ_END( x )                       \
+            __SHARED_READ_FENCE;                   \
+        } while (__SHARED_READ_SEQ( x ) != __seq); \
+    } while(0)
+
 #endif  /* __WINE_X11DRV_H */
diff --git a/include/ntuser.h b/include/ntuser.h
index 11111111111..11111111111 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -888,6 +888,7 @@ enum
     /* temporary exports */
     NtUserExitingThread,
     NtUserThreadDetach,
+    NtUserGetDesktopSharedMemory,
     NtUserGetQueueSharedMemory,
     NtUserGetInputSharedMemory,
     NtUserGetForegroundSharedMemory,
-- 
2.37.2

From c3ec84dd82f38df2364e2aa4efd3d6ce85a46616 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Tue, 29 Mar 2022 02:13:14 +0200
Subject: [PATCH 46/44] HACK: win32u: Skip setting the cursor position if the new
 position matches the cached one.

---
 dlls/win32u/input.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -183,6 +183,8 @@ UINT WINAPI NtUserSendInput( UINT count, INPUT *inputs, int size )
  */
 BOOL WINAPI NtUserSetCursorPos( INT x, INT y )
 {
+    volatile struct desktop_shared_memory *shared = get_desktop_shared_memory();
+    DWORD last_change;
     POINT pt = { x, y };
     BOOL ret;
     INT prev_x, prev_y, new_x, new_y;
@@ -194,6 +196,17 @@ BOOL WINAPI NtUserSetCursorPos( INT x, INT y )
         pt = map_dpi_point( pt, dpi, get_monitor_dpi( monitor ));
     }
 
+    /* HACK: Doesn't generate any window messages but skips the server call. */
+    SHARED_READ_BEGIN( &shared->seq )
+    {
+        prev_x = shared->cursor.x;
+        prev_y = shared->cursor.y;
+        last_change = shared->cursor.last_change;
+    }
+    SHARED_READ_END( &shared->seq );
+    if (last_change != 0 && x == prev_x && y == prev_y)
+        return TRUE;
+
     SERVER_START_REQ( set_cursor )
     {
         req->flags = SET_CURSOR_POS;
-- 
2.37.2

From 25fa395dd2917ad93b668165303fb0fee7caa7a0 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Tue, 29 Mar 2022 02:30:12 +0200
Subject: [PATCH 47/44] HACK: win32u: Get key state from desktop memory if
 !keystate_lock.

---
 dlls/win32u/input.c | 27 ++++++++++++++++++++-------
 1 file changed, 20 insertions(+), 7 deletions(-)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -412,18 +412,31 @@ HKL WINAPI NtUserGetKeyboardLayout( DWORD thread_id )
  */
 SHORT WINAPI NtUserGetKeyState( INT vkey )
 {
-    volatile struct input_shared_memory *shared = get_input_shared_memory();
+    volatile struct input_shared_memory *input_shared = get_input_shared_memory();
+    volatile struct desktop_shared_memory *desktop_shared = get_desktop_shared_memory();
     SHORT retval = 0;
     BOOL skip = TRUE;
+    BOOL keystate_lock = FALSE;
 
-    if (!shared) skip = FALSE;
-    else SHARED_READ_BEGIN( &shared->seq )
+    if (!input_shared) skip = FALSE;
+    else SHARED_READ_BEGIN( &input_shared->seq )
     {
-        if (!shared->created) skip = FALSE; /* server needs to create the queue */
-        else if (!shared->keystate_lock) skip = FALSE; /* server needs to call sync_input_keystate */
-        else retval = (signed char)(shared->keystate[vkey & 0xff] & 0x81);
+        if (!input_shared->created) skip = FALSE; /* server needs to create the queue */
+        else if (!input_shared->keystate_lock) keystate_lock = TRUE; /* server needs to call sync_input_keystate */
+        else retval = (signed char)(input_shared->keystate[vkey & 0xff] & 0x81);
+    }
+    SHARED_READ_END( &input_shared->seq );
+
+    /* HACK: Introduces a race condition but skips the server call. */
+    if (keystate_lock)
+    {
+        if (!desktop_shared) skip = FALSE;
+        else SHARED_READ_BEGIN( &desktop_shared->seq )
+        {
+            retval = (signed char)(desktop_shared->keystate[vkey & 0xff] & 0x81);
+        }
+        SHARED_READ_END( &desktop_shared->seq );
     }
-    SHARED_READ_END( &shared->seq );
 
     if (!skip)
     {
-- 
2.37.2

From 1139cc01518d0701fb5440754f8c60a907359940 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Tue, 29 Mar 2022 05:06:55 +0200
Subject: [PATCH 48/44] HACK: server, win32u: Move active_hooks bitmap into shared
 memory.

---
 dlls/win32u/hook.c  | 20 ++++++++++++++-
 server/hook.c       | 59 +++++++++++++++++++++++++++++++++++++++++++++
 server/protocol.def |  2 ++
 server/user.h       |  4 +++
 5 files changed, 100 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/hook.c b/dlls/win32u/hook.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/hook.c
+++ b/dlls/win32u/hook.c
@@ -70,7 +70,25 @@ static UINT get_active_hooks(void)
 
     if (!thread_info->active_hooks)
     {
-        SERVER_START_REQ( get_active_hooks )
+        volatile struct desktop_shared_memory *desktop_shared = get_desktop_shared_memory();
+        volatile struct queue_shared_memory *queue_shared = get_queue_shared_memory();
+        unsigned int desktop_active_hooks, queue_active_hooks;
+        BOOL skip = TRUE;
+
+        SHARED_READ_BEGIN( &desktop_shared->seq )
+        {
+            desktop_active_hooks = desktop_shared->active_hooks;
+        }
+        SHARED_READ_END( &desktop_shared->seq );
+        SHARED_READ_BEGIN( &queue_shared->seq )
+        {
+            skip = queue_shared->created;
+            queue_active_hooks = queue_shared->active_hooks;
+        }
+        SHARED_READ_END( &queue_shared->seq );
+
+        if (skip) thread_info->active_hooks = desktop_active_hooks | queue_active_hooks;
+        else SERVER_START_REQ( get_active_hooks )
         {
             if (!wine_server_call( req )) thread_info->active_hooks = reply->active_hooks;
         }
diff --git a/server/hook.c b/server/hook.c
index 11111111111..11111111111 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -43,11 +43,13 @@ struct hook
 {
     struct list         chain;    /* hook chain entry */
     user_handle_t       handle;   /* user handle for this hook */
+    struct desktop     *desktop;  /* desktop that the hook is set on */
     struct process     *process;  /* process the hook is set to */
     struct thread      *thread;   /* thread the hook is set to */
     struct thread      *owner;    /* owner of the out of context hook */
     struct hook_table  *table;    /* hook table that contains this hook */
     int                 index;    /* hook table index */
+    int                 is_global; /* whether this hook is global */
     int                 event_min;
     int                 event_max;
     int                 flags;
@@ -148,9 +150,11 @@ static struct hook *add_hook( struct desktop *desktop, struct thread *thread, in
         free( hook );
         return NULL;
     }
+    hook->desktop = (struct desktop *)grab_object( desktop );
     hook->thread = thread ? (struct thread *)grab_object( thread ) : NULL;
     hook->table  = table;
     hook->index  = index;
+    hook->is_global = global;
     list_add_head( &table->hooks[index], &hook->chain );
     if (thread) thread->desktop_users++;
     return hook;
@@ -168,6 +172,7 @@ static void free_hook( struct hook *hook )
         release_object( hook->thread );
     }
     if (hook->process) release_object( hook->process );
+    release_object( hook->desktop );
     release_object( hook->owner );
     list_remove( &hook->chain );
     free( hook );
@@ -297,10 +302,22 @@ static void hook_table_destroy( struct object *obj )
 /* remove a hook, freeing it if the chain is not in use */
 static void remove_hook( struct hook *hook )
 {
+    int global = hook->is_global;
+    struct desktop *desktop = (struct desktop *)grab_object( hook->desktop );
+    struct thread *thread = hook->thread ? (struct thread *)grab_object( hook->thread ) : NULL;
+
     if (hook->table->counts[hook->index])
         hook->proc = 0; /* chain is in use, just mark it and return */
     else
         free_hook( hook );
+
+    if (global)
+        update_global_active_hooks( desktop );
+    else
+        update_queue_active_hooks( thread );
+
+    release_object( desktop );
+    if (thread) release_object( thread );
 }
 
 /* release a hook chain, removing deleted hooks if the use count drops to 0 */
@@ -357,6 +374,44 @@ static int is_hook_active( struct hook_table *table, int index )
     return 0;
 }
 
+void update_global_active_hooks( struct desktop *desktop )
+{
+    struct hook_table *global_hooks = desktop->global_hooks;
+    unsigned int active_hooks = 1u << 31;  /* set high bit to indicate that the bitmap is valid */
+
+    if (global_hooks)
+    {
+        int id;
+        for (id = WH_MINHOOK; id <= WH_WINEVENT; id++)
+        {
+            if (is_hook_active( global_hooks, id - WH_MINHOOK ))
+                active_hooks |= 1 << (id - WH_MINHOOK);
+        }
+    }
+
+    write_global_active_hooks( desktop, active_hooks );
+}
+
+void update_queue_active_hooks( struct thread *thread )
+{
+    struct hook_table *queue_hooks = get_queue_hooks( thread );
+    unsigned int active_hooks = 1u << 31;  /* set high bit to indicate that the bitmap is valid */
+
+    if (!thread->queue) return;
+
+    if (queue_hooks)
+    {
+        int id;
+        for (id = WH_MINHOOK; id <= WH_WINEVENT; id++)
+        {
+            if (is_hook_active( queue_hooks, id - WH_MINHOOK ))
+                active_hooks |= 1 << (id - WH_MINHOOK);
+        }
+    }
+
+    write_queue_active_hooks( thread, active_hooks );
+}
+
 /* get a bitmap of all active hooks for the current thread */
 static unsigned int get_active_hooks(void)
 {
@@ -471,6 +526,10 @@ DECL_HANDLER(set_hook)
         hook->unicode     = req->unicode;
         hook->module      = module;
         hook->module_size = module_size;
+        if (global)
+            update_global_active_hooks( desktop );
+        else
+            update_queue_active_hooks( thread );
         reply->handle = hook->handle;
         reply->active_hooks = get_active_hooks();
     }
diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -867,6 +867,7 @@ struct desktop_shared_memory
     struct shared_cursor cursor;           /* global cursor information */
     unsigned char        keystate[256];    /* asynchronous key state */
     thread_id_t          foreground_tid;   /* tid of the foreground thread */
+    unsigned int         active_hooks;     /* desktop active hooks */
 };
 
 struct queue_shared_memory
@@ -878,6 +879,7 @@ struct queue_shared_memory
     unsigned int         wake_mask;
     unsigned int         changed_mask;
     thread_id_t          input_tid;
+    unsigned int         active_hooks;     /* thread active hooks */
 };
 
 struct input_shared_memory
diff --git a/server/user.h b/server/user.h
index 11111111111..11111111111 100644
--- a/server/user.h
+++ b/server/user.h
@@ -90,6 +90,8 @@ extern void cleanup_clipboard_thread( struct thread *thread );
 /* hook functions */
 
 extern void remove_thread_hooks( struct thread *thread );
+extern void update_global_active_hooks( struct desktop *desktop );
+extern void update_queue_active_hooks( struct thread *thread );
 extern struct thread *get_first_global_hook( int id );
 
 /* queue functions */
@@ -97,6 +99,8 @@ extern struct thread *get_first_global_hook( int id );
 extern void free_msg_queue( struct thread *thread );
 extern struct hook_table *get_queue_hooks( struct thread *thread );
 extern void set_queue_hooks( struct thread *thread, struct hook_table *hooks );
+extern void write_global_active_hooks( struct desktop *desktop, unsigned int active_hooks );
+extern void write_queue_active_hooks( struct thread *thread, unsigned int active_hooks );
 extern void inc_queue_paint_count( struct thread *thread, int incr );
 extern void queue_cleanup_window( struct thread *thread, user_handle_t win );
 extern int init_thread_queue( struct thread *thread );
-- 
2.37.2

From 2ac02791c0d42d04c014eabf042ebdbcf18048ee Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Fri, 29 Jul 2022 03:50:59 +0200
Subject: [PATCH 49/49] user32: Use the desktop shared data for
 GetLastInputInfo().

---
 dlls/user32/input.c          | 11 +++++++++++
 dlls/win32u/ntuser_private.h | 20 --------------------
 include/ntuser.h             | 20 ++++++++++++++++++++
 server/protocol.def          |  1 +
 server/queue.c               | 12 ++++++++----
 5 files changed, 40 insertions(+), 24 deletions(-)

diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index 11111111111..11111111111 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -195,6 +195,7 @@ BOOL WINAPI GetInputState(void)
  */
 BOOL WINAPI GetLastInputInfo(PLASTINPUTINFO plii)
 {
+    volatile struct desktop_shared_memory *shared = (void *)NtUserCallNoParam( NtUserGetDesktopSharedMemory );
     BOOL ret;
 
     TRACE("%p\n", plii);
@@ -205,6 +206,16 @@ BOOL WINAPI GetLastInputInfo(PLASTINPUTINFO plii)
         return FALSE;
     }
 
+    if (shared)
+    {
+        SHARED_READ_BEGIN( &shared->seq )
+        {
+            plii->dwTime = shared->last_input_time;
+        }
+        SHARED_READ_END( &shared->seq );
+        return TRUE;
+    }
+
     SERVER_START_REQ( get_last_input_time )
     {
         ret = !wine_server_call_err( req );
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -275,24 +275,4 @@ WND *get_win_ptr( HWND hwnd ) DECLSPEC_HIDDEN;
 BOOL is_child( HWND parent, HWND child );
 BOOL is_window( HWND hwnd ) DECLSPEC_HIDDEN;
 
-#if defined(__i386__) || defined(__x86_64__)
-#define __SHARED_READ_SEQ( x ) (*(x))
-#define __SHARED_READ_FENCE do {} while(0)
-#else
-#define __SHARED_READ_SEQ( x ) __atomic_load_n( x, __ATOMIC_RELAXED )
-#define __SHARED_READ_FENCE __atomic_thread_fence( __ATOMIC_ACQUIRE )
-#endif
-
-#define SHARED_READ_BEGIN( x )                                          \
-    do {                                                                \
-        unsigned int __seq;                                             \
-        do {                                                            \
-            while ((__seq = __SHARED_READ_SEQ( x )) & SEQUENCE_MASK) NtYieldExecution(); \
-            __SHARED_READ_FENCE;
-
-#define SHARED_READ_END( x )                       \
-            __SHARED_READ_FENCE;                   \
-        } while (__SHARED_READ_SEQ( x ) != __seq); \
-    } while(0)
-
 #endif /* __WINE_NTUSER_PRIVATE_H */
diff --git a/include/ntuser.h b/include/ntuser.h
index 11111111111..11111111111 100644
--- a/include/ntuser.h
+++ b/include/ntuser.h
@@ -1452,4 +1452,24 @@ static inline BOOL NtUserShowOwnedPopups( HWND hwnd, BOOL show )
     return NtUserCallHwndParam( hwnd, show, NtUserCallHwndParam_ShowOwnedPopups );
 }
 
+#if defined(__i386__) || defined(__x86_64__)
+#define __SHARED_READ_SEQ( x ) (*(x))
+#define __SHARED_READ_FENCE do {} while(0)
+#else
+#define __SHARED_READ_SEQ( x ) __atomic_load_n( x, __ATOMIC_RELAXED )
+#define __SHARED_READ_FENCE __atomic_thread_fence( __ATOMIC_ACQUIRE )
+#endif
+
+#define SHARED_READ_BEGIN( x )                                          \
+    do {                                                                \
+        unsigned int __seq;                                             \
+        do {                                                            \
+            while ((__seq = __SHARED_READ_SEQ( x )) & SEQUENCE_MASK) NtYieldExecution(); \
+            __SHARED_READ_FENCE;
+
+#define SHARED_READ_END( x )                       \
+            __SHARED_READ_FENCE;                   \
+        } while (__SHARED_READ_SEQ( x ) != __seq); \
+    } while(0)
+
 #endif /* _NTUSER_ */
diff --git a/server/protocol.def b/server/protocol.def
index 11111111111..11111111111 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -868,6 +868,7 @@ struct desktop_shared_memory
     unsigned char        keystate[256];    /* asynchronous key state */
     thread_id_t          foreground_tid;   /* tid of the foreground thread */
     unsigned int         active_hooks;     /* desktop active hooks */
+    unsigned int         last_input_time;  /* timestamp of most recent input */
 };
 
 struct queue_shared_memory
diff --git a/server/queue.c b/server/queue.c
index 11111111111..11111111111 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -101,21 +101,12 @@ struct thread_input
 {
     struct object          obj;           /* object header */
     struct desktop        *desktop;       /* desktop that this thread input belongs to */
-    user_handle_t          focus;         /* focus window */
-    user_handle_t          capture;       /* capture window */
-    user_handle_t          active;        /* active window */
-    user_handle_t          menu_owner;    /* current menu owner window */
-    user_handle_t          move_size;     /* current moving/resizing window */
-    user_handle_t          caret;         /* caret window */
-    rectangle_t            caret_rect;    /* caret rectangle */
     int                    caret_hide;    /* caret hide count */
     int                    caret_state;   /* caret on/off state */
-    user_handle_t          cursor;        /* current cursor */
-    int                    cursor_count;  /* cursor show count */
     struct list            msg_list;      /* list of hardware messages */
-    unsigned char          keystate[256]; /* state of each key */
     unsigned char          desktop_keystate[256]; /* desktop keystate when keystate was synced */
-    int                    keystate_lock; /* keystate is locked */
+    struct object         *shared_mapping; /* thread input shared memory mapping */
+    volatile struct input_shared_memory *shared;  /* thread input shared memory ptr */
 };
 
 struct msg_queue
@@ -148,6 +139,7 @@ struct msg_queue
     int                    esync_in_msgwait; /* our thread is currently waiting on us */
     unsigned int           fsync_idx;
     int                    fsync_in_msgwait; /* our thread is currently waiting on us */
+    volatile struct queue_shared_memory *shared;  /* thread queue shared memory ptr */
 };
 
 struct hotkey
@@ -238,28 +230,67 @@ static const struct object_ops thread_in
     thread_input_destroy          /* destroy */
 };
 
-/* pointer to input structure of foreground thread */
-static unsigned int last_input_time;
-
 static cursor_pos_t cursor_history[64];
 static unsigned int cursor_history_latest;
 
+#if defined(__i386__) || defined(__x86_64__)
+
+#define SHARED_WRITE_BEGIN( x )                                  \
+    do {                                                         \
+        volatile unsigned int __seq = *(x);                      \
+        assert( (__seq & SEQUENCE_MASK) != SEQUENCE_MASK );      \
+        *(x) = ++__seq;                                          \
+    } while(0)
+
+#define SHARED_WRITE_END( x )                                    \
+    do {                                                         \
+        volatile unsigned int __seq = *(x);                      \
+        assert( (__seq & SEQUENCE_MASK) != 0 );                  \
+        if ((__seq & SEQUENCE_MASK) > 1) __seq--;                \
+        else __seq += SEQUENCE_MASK;                             \
+        *(x) = __seq;                                            \
+    } while(0)
+
+#else
+
+#define SHARED_WRITE_BEGIN( x )                                         \
+    do {                                                                \
+        assert( (*(x) & SEQUENCE_MASK) != SEQUENCE_MASK );              \
+        if ((__atomic_add_fetch( x, 1, __ATOMIC_RELAXED ) & SEQUENCE_MASK) == 1) \
+            __atomic_thread_fence( __ATOMIC_RELEASE );                  \
+    } while(0)
+
+#define SHARED_WRITE_END( x )                                           \
+    do {                                                                \
+        assert( (*(x) & SEQUENCE_MASK) != 0 );                          \
+        if ((*(x) & SEQUENCE_MASK) > 1)                                 \
+            __atomic_sub_fetch( x, 1, __ATOMIC_RELAXED );               \
+        else {                                                          \
+            __atomic_thread_fence( __ATOMIC_RELEASE );                  \
+            __atomic_add_fetch( x, SEQUENCE_MASK, __ATOMIC_RELAXED );   \
+        }                                                               \
+    } while(0)
+
+#endif
+
 static void queue_hardware_message( struct desktop *desktop, struct message *msg, int always_queue );
 static void free_message( struct message *msg );
 
 /* set the caret window in a given thread input */
 static void set_caret_window( struct thread_input *input, user_handle_t win )
 {
-    if (!win || win != input->caret)
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    if (!win || win != input->shared->caret)
     {
-        input->caret_rect.left   = 0;
-        input->caret_rect.top    = 0;
-        input->caret_rect.right  = 0;
-        input->caret_rect.bottom = 0;
+        input->shared->caret_rect.left   = 0;
+        input->shared->caret_rect.top    = 0;
+        input->shared->caret_rect.right  = 0;
+        input->shared->caret_rect.bottom = 0;
     }
-    input->caret             = win;
+    input->shared->caret     = win;
     input->caret_hide        = 1;
     input->caret_state       = 0;
+    SHARED_WRITE_END( &input->shared->seq );
 }
 
 /* create a thread input object */
@@ -269,24 +300,33 @@ static struct thread_input *create_threa
 
     if ((input = alloc_object( &thread_input_ops )))
     {
-        input->focus        = 0;
-        input->capture      = 0;
-        input->active       = 0;
-        input->menu_owner   = 0;
-        input->move_size    = 0;
-        input->cursor       = 0;
-        input->cursor_count = 0;
+        input->shared_mapping = grab_object( thread->input_shared_mapping );
+        input->shared = thread->input_shared;
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        input->shared->focus        = 0;
+        input->shared->capture      = 0;
+        input->shared->active       = 0;
+        input->shared->menu_owner   = 0;
+        input->shared->move_size    = 0;
+        input->shared->cursor       = 0;
+        input->shared->cursor_count = 0;
+        input->shared->keystate_lock = 0;
+        memset( (void *)input->shared->keystate, 0, sizeof(input->shared->keystate) );
+        SHARED_WRITE_END( &input->shared->seq );
         list_init( &input->msg_list );
         set_caret_window( input, 0 );
-        memset( input->keystate, 0, sizeof(input->keystate) );
-        input->keystate_lock = 0;
 
         if (!(input->desktop = get_thread_desktop( thread, 0 /* FIXME: access rights */ )))
         {
             release_object( input );
             return NULL;
         }
-        memcpy( input->desktop_keystate, input->desktop->keystate, sizeof(input->desktop_keystate) );
+        memcpy( input->desktop_keystate, (void *)input->desktop->shared->keystate,
+                sizeof(input->desktop_keystate) );
+
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        input->shared->created = TRUE;
+        SHARED_WRITE_END( &input->shared->seq );
     }
     return input;
 }
@@ -327,6 +367,7 @@ static struct msg_queue *create_msg_queu
         queue->esync_in_msgwait = 0;
         queue->fsync_idx       = 0;
         queue->fsync_in_msgwait = 0;
+        queue->shared          = thread->queue_shared;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
@@ -339,9 +380,18 @@ static struct msg_queue *create_msg_queu
         if (do_esync())
             queue->esync_fd = esync_create_fd( 0, 0 );
 
+        SHARED_WRITE_BEGIN( &queue->shared->seq );
+        queue->shared->created = TRUE;
+        SHARED_WRITE_END( &queue->shared->seq );
         thread->queue = queue;
     }
-    if (new_input) release_object( new_input );
+    if (new_input)
+    {
+        SHARED_WRITE_BEGIN( &queue->shared->seq );
+        queue->shared->input_tid = new_input->shared->tid;
+        SHARED_WRITE_END( &queue->shared->seq );
+        release_object( new_input );
+    }
     return queue;
 }
 
@@ -358,25 +408,31 @@ void free_msg_queue( struct thread *thre
 static void sync_input_keystate( struct thread_input *input )
 {
     int i;
-    if (!input->desktop || input->keystate_lock) return;
-    for (i = 0; i < sizeof(input->keystate); ++i)
+    if (!input->desktop || input->shared->keystate_lock) return;
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    for (i = 0; i < sizeof(input->shared->keystate); ++i)
     {
-        if (input->desktop_keystate[i] == input->desktop->keystate[i]) continue;
-        input->keystate[i] = input->desktop_keystate[i] = input->desktop->keystate[i];
+        if (input->desktop_keystate[i] == input->desktop->shared->keystate[i]) continue;
+        input->shared->keystate[i] = input->desktop_keystate[i] = input->desktop->shared->keystate[i];
     }
+    SHARED_WRITE_END( &input->shared->seq );
 }
 
 /* locks thread input keystate to prevent synchronization */
 static void lock_input_keystate( struct thread_input *input )
 {
-    input->keystate_lock++;
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    input->shared->keystate_lock++;
+    SHARED_WRITE_END( &input->shared->seq );
 }
 
 /* unlock the thread input keystate and synchronize it again */
 static void unlock_input_keystate( struct thread_input *input )
 {
-    input->keystate_lock--;
-    if (!input->keystate_lock) sync_input_keystate( input );
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    input->shared->keystate_lock--;
+    SHARED_WRITE_END( &input->shared->seq );
+    if (!input->shared->keystate_lock) sync_input_keystate( input );
 }
 
 /* change the thread input data of a given thread */
@@ -391,13 +447,21 @@ static int assign_thread_input( struct t
     }
     if (queue->input)
     {
-        queue->input->cursor_count -= queue->cursor_count;
+        SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+        queue->input->shared->cursor_count -= queue->cursor_count;
+        SHARED_WRITE_END( &queue->input->shared->seq );
         if (queue->keystate_lock) unlock_input_keystate( queue->input );
         release_object( queue->input );
     }
     queue->input = (struct thread_input *)grab_object( new_input );
     if (queue->keystate_lock) lock_input_keystate( queue->input );
-    new_input->cursor_count += queue->cursor_count;
+    SHARED_WRITE_BEGIN( &new_input->shared->seq );
+    new_input->shared->cursor_count += queue->cursor_count;
+    SHARED_WRITE_END( &new_input->shared->seq );
+
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->input_tid = queue->input->shared->tid;
+    SHARED_WRITE_END( &queue->shared->seq );
     return 1;
 }
 
@@ -430,13 +494,17 @@ static struct message *alloc_hardware_me
 static int update_desktop_cursor_pos( struct desktop *desktop, int x, int y )
 {
     int updated;
+    unsigned int time = get_tick_count();
 
-    x = max( min( x, desktop->cursor.clip.right - 1 ), desktop->cursor.clip.left );
-    y = max( min( y, desktop->cursor.clip.bottom - 1 ), desktop->cursor.clip.top );
-    updated = (desktop->cursor.x != x || desktop->cursor.y != y);
-    desktop->cursor.x = x;
-    desktop->cursor.y = y;
-    desktop->cursor.last_change = get_tick_count();
+    x = max( min( x, desktop->shared->cursor.clip.right - 1 ), desktop->shared->cursor.clip.left );
+    y = max( min( y, desktop->shared->cursor.clip.bottom - 1 ), desktop->shared->cursor.clip.top );
+    updated = (desktop->shared->cursor.x != x || desktop->shared->cursor.y != y);
+
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
+    desktop->shared->cursor.x = x;
+    desktop->shared->cursor.y = y;
+    desktop->shared->cursor.last_change = time;
+    SHARED_WRITE_END( &desktop->shared->seq );
 
     return updated;
 }
@@ -467,37 +535,40 @@ static void get_message_defaults( struct
 {
     struct desktop *desktop = queue->input->desktop;
 
-    *x = desktop->cursor.x;
-    *y = desktop->cursor.y;
+    *x = desktop->shared->cursor.x;
+    *y = desktop->shared->cursor.y;
     *time = get_tick_count();
 }
 
 /* set the cursor clip rectangle */
-static void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect, int send_clip_msg )
+void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect, int send_clip_msg )
 {
-    rectangle_t top_rect;
+    rectangle_t top_rect, new_rect;
     int x, y;
 
     get_top_window_rectangle( desktop, &top_rect );
     if (rect)
     {
-        rectangle_t new_rect = *rect;
+        new_rect = *rect;
         if (new_rect.left   < top_rect.left)   new_rect.left   = top_rect.left;
         if (new_rect.right  > top_rect.right)  new_rect.right  = top_rect.right;
         if (new_rect.top    < top_rect.top)    new_rect.top    = top_rect.top;
         if (new_rect.bottom > top_rect.bottom) new_rect.bottom = top_rect.bottom;
         if (new_rect.left > new_rect.right || new_rect.top > new_rect.bottom) new_rect = top_rect;
-        desktop->cursor.clip = new_rect;
     }
-    else desktop->cursor.clip = top_rect;
+    else new_rect = top_rect;
+
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
+    desktop->shared->cursor.clip = new_rect;
 
-    if (desktop->cursor.clip_msg && send_clip_msg)
-        post_desktop_message( desktop, desktop->cursor.clip_msg, rect != NULL, 0 );
+    if (desktop->cursor_clip_msg && send_clip_msg)
+        post_desktop_message( desktop, desktop->cursor_clip_msg, rect != NULL, 0 );
 
     /* warp the mouse to be inside the clip rect */
-    x = max( min( desktop->cursor.x, desktop->cursor.clip.right - 1 ), desktop->cursor.clip.left );
-    y = max( min( desktop->cursor.y, desktop->cursor.clip.bottom - 1 ), desktop->cursor.clip.top );
-    if (x != desktop->cursor.x || y != desktop->cursor.y) set_cursor_pos( desktop, x, y );
+    x = max( min( desktop->shared->cursor.x, desktop->shared->cursor.clip.right - 1 ), desktop->shared->cursor.clip.left );
+    y = max( min( desktop->shared->cursor.y, desktop->shared->cursor.clip.bottom - 1 ), desktop->shared->cursor.clip.top );
+    if (x != desktop->shared->cursor.x || y != desktop->shared->cursor.y) set_cursor_pos( desktop, x, y );
+    SHARED_WRITE_END( &desktop->shared->seq );
 }
 
 /* change the foreground input and reset the cursor clip rect */
@@ -506,6 +577,9 @@ static void set_foreground_input( struct
     if (desktop->foreground_input == input) return;
     set_clip_rectangle( desktop, NULL, 1 );
     desktop->foreground_input = input;
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
+    desktop->shared->foreground_tid = input ? input->shared->tid : 0;
+    SHARED_WRITE_END( &desktop->shared->seq );
 }
 
 /* get the hook table for a given thread */
@@ -524,6 +598,22 @@ void set_queue_hooks( struct thread *thr
     queue->hooks = hooks;
 }
 
+void write_global_active_hooks( struct desktop *desktop, unsigned int active_hooks )
+{
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
+    desktop->shared->active_hooks = active_hooks;
+    SHARED_WRITE_END( &desktop->shared->seq );
+}
+
+void write_queue_active_hooks( struct thread *thread, unsigned int active_hooks )
+{
+    struct msg_queue *queue = thread->queue;
+    if (!queue && !(queue = create_msg_queue( thread, NULL ))) return;
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->active_hooks = active_hooks;
+    SHARED_WRITE_END( &queue->shared->seq );
+}
+
 /* check the queue status */
 static inline int is_signaled( struct msg_queue *queue )
 {
@@ -540,6 +630,12 @@ static inline void set_queue_bits( struc
     }
     queue->wake_bits |= bits;
     queue->changed_bits |= bits;
+    
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->wake_bits = queue->wake_bits;
+    queue->shared->changed_bits = queue->changed_bits;
+    SHARED_WRITE_END( &queue->shared->seq );
+    
     if (is_signaled( queue )) wake_up( &queue->obj, 0 );
 }
 
@@ -559,6 +655,11 @@ static inline void clear_queue_bits( str
 
     if (do_esync() && !is_signaled( queue ))
         esync_clear( queue->esync_fd );
+
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->wake_bits = queue->wake_bits;
+    queue->shared->changed_bits = queue->changed_bits;
+    SHARED_WRITE_END( &queue->shared->seq );
 }
 
 /* check whether msg is a keyboard message */
@@ -1098,6 +1199,11 @@ static void msg_queue_satisfied( struct
     struct msg_queue *queue = (struct msg_queue *)obj;
     queue->wake_mask = 0;
     queue->changed_mask = 0;
+    
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->wake_mask = queue->wake_mask;
+    queue->shared->changed_mask = queue->changed_mask;
+    SHARED_WRITE_END( &queue->shared->seq );    
 }
 
 static void msg_queue_destroy( struct object *obj )
@@ -1132,7 +1238,9 @@ static void msg_queue_destroy( struct ob
         free( timer );
     }
     if (queue->timeout) remove_timeout_user( queue->timeout );
-    queue->input->cursor_count -= queue->cursor_count;
+    SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+    queue->input->shared->cursor_count -= queue->cursor_count;
+    SHARED_WRITE_END( &queue->input->shared->seq );
     if (queue->keystate_lock) unlock_input_keystate( queue->input );
     release_object( queue->input );
     if (queue->hooks) release_object( queue->hooks );
@@ -1154,7 +1262,7 @@ static void thread_input_dump( struct ob
 {
     struct thread_input *input = (struct thread_input *)obj;
     fprintf( stderr, "Thread input focus=%08x capture=%08x active=%08x\n",
-             input->focus, input->capture, input->active );
+             input->shared->focus, input->shared->capture, input->shared->active );
 }
 
 static void thread_input_destroy( struct object *obj )
@@ -1167,6 +1275,7 @@ static void thread_input_destroy( struct
         if (input->desktop->foreground_input == input) set_foreground_input( input->desktop, NULL );
         release_object( input->desktop );
     }
+    release_object( input->shared_mapping );
 }
 
 /* fix the thread input data when a window is destroyed */
@@ -1174,12 +1283,14 @@ static inline void thread_input_cleanup_
 {
     struct thread_input *input = queue->input;
 
-    if (window == input->focus) input->focus = 0;
-    if (window == input->capture) input->capture = 0;
-    if (window == input->active) input->active = 0;
-    if (window == input->menu_owner) input->menu_owner = 0;
-    if (window == input->move_size) input->move_size = 0;
-    if (window == input->caret) set_caret_window( input, 0 );
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    if (window == input->shared->focus) input->shared->focus = 0;
+    if (window == input->shared->capture) input->shared->capture = 0;
+    if (window == input->shared->active) input->shared->active = 0;
+    if (window == input->shared->menu_owner) input->shared->menu_owner = 0;
+    if (window == input->shared->move_size) input->shared->move_size = 0;
+    if (window == input->shared->caret) set_caret_window( input, 0 );
+    SHARED_WRITE_END( &input->shared->seq );
 }
 
 /* check if the specified window can be set in the input data of a given queue */
@@ -1212,7 +1323,7 @@ int init_thread_queue( struct thread *th
 int attach_thread_input( struct thread *thread_from, struct thread *thread_to )
 {
     struct desktop *desktop;
-    struct thread_input *input;
+    struct thread_input *input, *old_input;
     int ret;
 
     if (!thread_to->queue && !(thread_to->queue = create_msg_queue( thread_to, NULL ))) return 0;
@@ -1229,12 +1340,20 @@ int attach_thread_input( struct thread *
 
     if (thread_from->queue)
     {
-        if (!input->focus) input->focus = thread_from->queue->input->focus;
-        if (!input->active) input->active = thread_from->queue->input->active;
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        old_input = thread_from->queue->input;
+        if (!input->shared->focus) input->shared->focus = old_input->shared->focus;
+        if (!input->shared->active) input->shared->active = old_input->shared->active;
+        SHARED_WRITE_END( &input->shared->seq );
     }
 
     ret = assign_thread_input( thread_from, input );
-    if (ret) memset( input->keystate, 0, sizeof(input->keystate) );
+    if (ret)
+    {
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        memset( (void *)input->shared->keystate, 0, sizeof(input->shared->keystate) );
+        SHARED_WRITE_END( &input->shared->seq );
+    }
     release_object( input );
     return ret;
 }
@@ -1247,21 +1366,29 @@ void detach_thread_input( struct thread
 
     if ((input = create_thread_input( thread_from )))
     {
-        if (old_input->focus && (thread = get_window_thread( old_input->focus )))
+        if (old_input->shared->focus && (thread = get_window_thread( old_input->shared->focus )))
         {
             if (thread == thread_from)
             {
-                input->focus = old_input->focus;
-                old_input->focus = 0;
+                SHARED_WRITE_BEGIN( &input->shared->seq );
+                input->shared->focus = old_input->shared->focus;
+                SHARED_WRITE_END( &input->shared->seq );
+                SHARED_WRITE_BEGIN( &old_input->shared->seq );
+                old_input->shared->focus = 0;
+                SHARED_WRITE_END( &old_input->shared->seq );
             }
             release_object( thread );
         }
-        if (old_input->active && (thread = get_window_thread( old_input->active )))
+        if (old_input->shared->active && (thread = get_window_thread( old_input->shared->active )))
         {
             if (thread == thread_from)
             {
-                input->active = old_input->active;
-                old_input->active = 0;
+                SHARED_WRITE_BEGIN( &input->shared->seq );
+                input->shared->active = old_input->shared->active;
+                SHARED_WRITE_END( &input->shared->seq );
+                SHARED_WRITE_BEGIN( &old_input->shared->seq );
+                old_input->shared->active = 0;
+                SHARED_WRITE_END( &old_input->shared->seq );
             }
             release_object( thread );
         }
@@ -1394,7 +1521,7 @@ static struct timer *set_timer( struct m
 }
 
 /* change the input key state for a given key */
-static void set_input_key_state( unsigned char *keystate, unsigned char key, int down )
+static void set_input_key_state( volatile unsigned char *keystate, unsigned char key, unsigned char down )
 {
     if (down)
     {
@@ -1405,34 +1532,33 @@ static void set_input_key_state( unsigne
 }
 
 /* update the input key state for a keyboard message */
-static void update_input_key_state( struct desktop *desktop, unsigned char *keystate,
-                                    unsigned int msg, lparam_t wparam )
+static void update_key_state( volatile unsigned char *keystate, unsigned int msg,
+                              lparam_t wparam, int desktop )
 {
-    unsigned char key;
-    int down = 0;
+    unsigned char key, down = 0, down_val = desktop ? 0xc0 : 0x80;
 
     switch (msg)
     {
     case WM_LBUTTONDOWN:
-        down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+        down = down_val;
         /* fall through */
     case WM_LBUTTONUP:
         set_input_key_state( keystate, VK_LBUTTON, down );
         break;
     case WM_MBUTTONDOWN:
-        down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+        down = down_val;
         /* fall through */
     case WM_MBUTTONUP:
         set_input_key_state( keystate, VK_MBUTTON, down );
         break;
     case WM_RBUTTONDOWN:
-        down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+        down = down_val;
         /* fall through */
     case WM_RBUTTONUP:
         set_input_key_state( keystate, VK_RBUTTON, down );
         break;
     case WM_XBUTTONDOWN:
-        down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+        down = down_val;
         /* fall through */
     case WM_XBUTTONUP:
         if (wparam >> 16 == XBUTTON1) set_input_key_state( keystate, VK_XBUTTON1, down );
@@ -1440,7 +1566,7 @@ static void update_input_key_state( stru
         break;
     case WM_KEYDOWN:
     case WM_SYSKEYDOWN:
-        down = (keystate == desktop->keystate) ? 0xc0 : 0x80;
+        down = down_val;
         /* fall through */
     case WM_KEYUP:
     case WM_SYSKEYUP:
@@ -1468,6 +1594,20 @@ static void update_input_key_state( stru
     }
 }
 
+static void update_input_key_state( struct thread_input *input, unsigned int msg, lparam_t wparam )
+{
+    SHARED_WRITE_BEGIN( &input->shared->seq );
+    update_key_state( input->shared->keystate, msg, wparam, 0 );
+    SHARED_WRITE_END( &input->shared->seq );
+}
+
+static void update_desktop_key_state( struct desktop *desktop, unsigned int msg, lparam_t wparam )
+{
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
+    update_key_state( desktop->shared->keystate, msg, wparam, 1 );
+    SHARED_WRITE_END( &desktop->shared->seq );
+}
+
 /* update the desktop key state according to a mouse message flags */
 static void update_desktop_mouse_state( struct desktop *desktop, unsigned int flags,
                                         int x, int y, lparam_t wparam )
@@ -1475,21 +1615,21 @@ static void update_desktop_mouse_state(
     if (flags & MOUSEEVENTF_MOVE)
         update_desktop_cursor_pos( desktop, x, y );
     if (flags & MOUSEEVENTF_LEFTDOWN)
-        update_input_key_state( desktop, desktop->keystate, WM_LBUTTONDOWN, wparam );
+        update_desktop_key_state( desktop, WM_LBUTTONDOWN, wparam );
     if (flags & MOUSEEVENTF_LEFTUP)
-        update_input_key_state( desktop, desktop->keystate, WM_LBUTTONUP, wparam );
+        update_desktop_key_state( desktop, WM_LBUTTONUP, wparam );
     if (flags & MOUSEEVENTF_RIGHTDOWN)
-        update_input_key_state( desktop, desktop->keystate, WM_RBUTTONDOWN, wparam );
+        update_desktop_key_state( desktop, WM_RBUTTONDOWN, wparam );
     if (flags & MOUSEEVENTF_RIGHTUP)
-        update_input_key_state( desktop, desktop->keystate, WM_RBUTTONUP, wparam );
+        update_desktop_key_state( desktop, WM_RBUTTONUP, wparam );
     if (flags & MOUSEEVENTF_MIDDLEDOWN)
-        update_input_key_state( desktop, desktop->keystate, WM_MBUTTONDOWN, wparam );
+        update_desktop_key_state( desktop, WM_MBUTTONDOWN, wparam );
     if (flags & MOUSEEVENTF_MIDDLEUP)
-        update_input_key_state( desktop, desktop->keystate, WM_MBUTTONUP, wparam );
+        update_desktop_key_state( desktop, WM_MBUTTONUP, wparam );
     if (flags & MOUSEEVENTF_XDOWN)
-        update_input_key_state( desktop, desktop->keystate, WM_XBUTTONDOWN, wparam );
+        update_desktop_key_state( desktop, WM_XBUTTONDOWN, wparam );
     if (flags & MOUSEEVENTF_XUP)
-        update_input_key_state( desktop, desktop->keystate, WM_XBUTTONUP, wparam );
+        update_desktop_key_state( desktop, WM_XBUTTONUP, wparam );
 }
 
 /* release the hardware message currently being processed by the given thread */
@@ -1517,7 +1657,7 @@ static void release_hardware_message( st
     }
     if (clr_bit) clear_queue_bits( queue, clr_bit );
 
-    update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
+    update_input_key_state( input, msg->msg, msg->wparam );
     list_remove( &msg->entry );
     free_message( msg );
 }
@@ -1529,10 +1669,10 @@ static int queue_hotkey_message( struct
 
     if (msg->msg != WM_KEYDOWN && msg->msg != WM_SYSKEYDOWN) return 0;
 
-    if (desktop->keystate[VK_MENU] & 0x80) modifiers |= MOD_ALT;
-    if (desktop->keystate[VK_CONTROL] & 0x80) modifiers |= MOD_CONTROL;
-    if (desktop->keystate[VK_SHIFT] & 0x80) modifiers |= MOD_SHIFT;
-    if ((desktop->keystate[VK_LWIN] & 0x80) || (desktop->keystate[VK_RWIN] & 0x80)) modifiers |= MOD_WIN;
+    if (desktop->shared->keystate[VK_MENU] & 0x80) modifiers |= MOD_ALT;
+    if (desktop->shared->keystate[VK_CONTROL] & 0x80) modifiers |= MOD_CONTROL;
+    if (desktop->shared->keystate[VK_SHIFT] & 0x80) modifiers |= MOD_SHIFT;
+    if ((desktop->shared->keystate[VK_LWIN] & 0x80) || (desktop->shared->keystate[VK_RWIN] & 0x80)) modifiers |= MOD_WIN;
 
     LIST_FOR_EACH_ENTRY( hotkey, &desktop->hotkeys, struct hotkey, entry )
     {
@@ -1571,17 +1711,17 @@ static user_handle_t find_hardware_messa
     *msg_code = msg->msg;
     if (msg->msg == WM_INPUT || msg->msg == WM_INPUT_DEVICE_CHANGE)
     {
-        if (!(win = msg->win) && input) win = input->focus;
+        if (!(win = msg->win) && input) win = input->shared->focus;
     }
     else if (is_keyboard_msg( msg ))
     {
-        if (input && !(win = input->focus))
+        if (input && !(win = input->shared->focus))
         {
-            win = input->active;
+            win = input->shared->active;
             if (*msg_code < WM_SYSKEYDOWN) *msg_code += WM_SYSKEYDOWN - WM_KEYDOWN;
         }
     }
-    else if (!input || !(win = input->capture)) /* mouse message */
+    else if (!input || !(win = input->shared->capture)) /* mouse message */
     {
         if (is_window_visible( msg->win ) && !is_window_transparent( msg->win )) win = msg->win;
         else win = shallow_window_from_point( desktop, msg->x, msg->y );
@@ -1624,16 +1764,20 @@ static void queue_hardware_message( stru
     struct thread *thread;
     struct thread_input *input;
     struct hardware_msg_data *msg_data = msg->data;
+    unsigned int last_input_time;
     unsigned int msg_code;
 
-    update_input_key_state( desktop, desktop->keystate, msg->msg, msg->wparam );
+    update_desktop_key_state( desktop, msg->msg, msg->wparam );
     last_input_time = get_tick_count();
+    SHARED_WRITE_BEGIN( &desktop->shared->seq );
+    desktop->shared->last_input_time = last_input_time;
+    SHARED_WRITE_END( &desktop->shared->seq );
     if (msg->msg != WM_MOUSEMOVE) always_queue = 1;
 
     if (is_keyboard_msg( msg ))
     {
         if (queue_hotkey_message( desktop, msg )) return;
-        if (desktop->keystate[VK_MENU] & 0x80) msg->lparam |= KF_ALTDOWN << 16;
+        if (desktop->shared->keystate[VK_MENU] & 0x80) msg->lparam |= KF_ALTDOWN << 16;
         if (msg->wparam == VK_SHIFT || msg->wparam == VK_LSHIFT || msg->wparam == VK_RSHIFT)
             msg->lparam &= ~(KF_EXTENDED << 16);
     }
@@ -1644,16 +1788,16 @@ static void queue_hardware_message( stru
             prepend_cursor_history( msg->x, msg->y, msg->time, msg_data->info );
             if (update_desktop_cursor_pos( desktop, msg->x, msg->y )) always_queue = 1;
         }
-        if (desktop->keystate[VK_LBUTTON] & 0x80)  msg->wparam |= MK_LBUTTON;
-        if (desktop->keystate[VK_MBUTTON] & 0x80)  msg->wparam |= MK_MBUTTON;
-        if (desktop->keystate[VK_RBUTTON] & 0x80)  msg->wparam |= MK_RBUTTON;
-        if (desktop->keystate[VK_SHIFT] & 0x80)    msg->wparam |= MK_SHIFT;
-        if (desktop->keystate[VK_CONTROL] & 0x80)  msg->wparam |= MK_CONTROL;
-        if (desktop->keystate[VK_XBUTTON1] & 0x80) msg->wparam |= MK_XBUTTON1;
-        if (desktop->keystate[VK_XBUTTON2] & 0x80) msg->wparam |= MK_XBUTTON2;
+        if (desktop->shared->keystate[VK_LBUTTON] & 0x80)  msg->wparam |= MK_LBUTTON;
+        if (desktop->shared->keystate[VK_MBUTTON] & 0x80)  msg->wparam |= MK_MBUTTON;
+        if (desktop->shared->keystate[VK_RBUTTON] & 0x80)  msg->wparam |= MK_RBUTTON;
+        if (desktop->shared->keystate[VK_SHIFT] & 0x80)    msg->wparam |= MK_SHIFT;
+        if (desktop->shared->keystate[VK_CONTROL] & 0x80)  msg->wparam |= MK_CONTROL;
+        if (desktop->shared->keystate[VK_XBUTTON1] & 0x80) msg->wparam |= MK_XBUTTON1;
+        if (desktop->shared->keystate[VK_XBUTTON2] & 0x80) msg->wparam |= MK_XBUTTON2;
     }
-    msg->x = desktop->cursor.x;
-    msg->y = desktop->cursor.y;
+    msg->x = desktop->shared->cursor.x;
+    msg->y = desktop->shared->cursor.y;
 
     if (msg->win && (thread = get_window_thread( msg->win )))
     {
@@ -1665,14 +1809,14 @@ static void queue_hardware_message( stru
     win = find_hardware_message_window( desktop, input, msg, &msg_code, &thread );
     if (!win || !thread)
     {
-        if (input) update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
+        if (input) update_input_key_state( input, msg->msg, msg->wparam );
         free_message( msg );
         return;
     }
     input = thread->queue->input;
 
-    if (win != desktop->cursor.win) always_queue = 1;
-    desktop->cursor.win = win;
+    if (win != desktop->cursor_win) always_queue = 1;
+    desktop->cursor_win = win;
 
     if (!always_queue || merge_message( input, msg )) free_message( msg );
     else
@@ -1735,7 +1879,7 @@ static int send_hook_ll_message( struct
 static struct thread *get_foreground_thread( struct desktop *desktop, user_handle_t window )
 {
     /* if desktop has no foreground process, assume the receiving window is */
-    if (desktop->foreground_input) return get_window_thread( desktop->foreground_input->focus );
+    if (desktop->foreground_input) return get_window_thread( desktop->foreground_input->shared->focus );
     if (window) return get_window_thread( window );
     return NULL;
 }
@@ -1846,10 +1990,10 @@ static int queue_mouse_message( struct d
         WM_MOUSEHWHEEL   /* 0x1000 = MOUSEEVENTF_HWHEEL */
     };
 
-    desktop->cursor.last_change = get_tick_count();
+    update_desktop_cursor_pos( desktop, desktop->shared->cursor.x, desktop->shared->cursor.y ); /* Update last change time */
     flags = input->mouse.flags;
     time  = input->mouse.time;
-    if (!time) time = desktop->cursor.last_change;
+    if (!time) time = desktop->shared->cursor.last_change;
 
     if (flags & MOUSEEVENTF_MOVE)
     {
@@ -1858,19 +2002,19 @@ static int queue_mouse_message( struct d
             x = input->mouse.x;
             y = input->mouse.y;
             if (flags & ~(MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE) &&
-                x == desktop->cursor.x && y == desktop->cursor.y)
+                x == desktop->shared->cursor.x && y == desktop->shared->cursor.y)
                 flags &= ~MOUSEEVENTF_MOVE;
         }
         else
         {
-            x = desktop->cursor.x + input->mouse.x;
-            y = desktop->cursor.y + input->mouse.y;
+            x = desktop->shared->cursor.x + input->mouse.x;
+            y = desktop->shared->cursor.y + input->mouse.y;
         }
     }
     else
     {
-        x = desktop->cursor.x;
-        y = desktop->cursor.y;
+        x = desktop->shared->cursor.x;
+        y = desktop->shared->cursor.y;
     }
 
     if ((req_flags & SEND_HWMSG_RAWINPUT) && (foreground = get_foreground_thread( desktop, win )))
@@ -1976,17 +2120,16 @@ static int queue_keyboard_message( struc
         if (input->kbd.flags & KEYEVENTF_KEYUP)
         {
             /* send WM_SYSKEYUP if Alt still pressed and no other key in between */
-            /* we use 0x02 as a flag to track if some other SYSKEYUP was sent already */
-            if ((desktop->keystate[VK_MENU] & 0x82) != 0x82) break;
+            if (!(desktop->shared->keystate[VK_MENU] & 0x80) || !desktop->last_press_alt) break;
             message_code = WM_SYSKEYUP;
-            desktop->keystate[VK_MENU] &= ~0x02;
+            desktop->last_press_alt = 0;
         }
         else
         {
             /* send WM_SYSKEYDOWN for Alt except with Ctrl */
-            if (desktop->keystate[VK_CONTROL] & 0x80) break;
+            if (desktop->shared->keystate[VK_CONTROL] & 0x80) break;
             message_code = WM_SYSKEYDOWN;
-            desktop->keystate[VK_MENU] |= 0x02;
+            desktop->last_press_alt = 1;
         }
         break;
 
@@ -1994,19 +2137,19 @@ static int queue_keyboard_message( struc
     case VK_RCONTROL:
         /* send WM_SYSKEYUP on release if Alt still pressed */
         if (!(input->kbd.flags & KEYEVENTF_KEYUP)) break;
-        if (!(desktop->keystate[VK_MENU] & 0x80)) break;
+        if (!(desktop->shared->keystate[VK_MENU] & 0x80)) break;
         message_code = WM_SYSKEYUP;
-        desktop->keystate[VK_MENU] &= ~0x02;
+        desktop->last_press_alt = 0;
         break;
 
     default:
         /* send WM_SYSKEY for Alt-anykey and for F10 */
-        if (desktop->keystate[VK_CONTROL] & 0x80) break;
-        if (!(desktop->keystate[VK_MENU] & 0x80)) break;
+        if (desktop->shared->keystate[VK_CONTROL] & 0x80) break;
+        if (!(desktop->shared->keystate[VK_MENU] & 0x80)) break;
         /* fall through */
     case VK_F10:
         message_code = (input->kbd.flags & KEYEVENTF_KEYUP) ? WM_SYSKEYUP : WM_SYSKEYDOWN;
-        desktop->keystate[VK_MENU] &= ~0x02;
+        desktop->last_press_alt = 0;
         break;
     }
 
@@ -2034,7 +2177,7 @@ static int queue_keyboard_message( struc
 
     if ((device = current->process->rawinput_kbd) && (device->flags & RIDEV_NOLEGACY))
     {
-        update_input_key_state( desktop, desktop->keystate, message_code, vkey );
+        update_desktop_key_state( desktop, message_code, vkey );
         return 0;
     }
 
@@ -2056,7 +2199,7 @@ static int queue_keyboard_message( struc
         if (input->kbd.flags & KEYEVENTF_EXTENDEDKEY) flags |= KF_EXTENDED;
         /* FIXME: set KF_DLGMODE and KF_MENUMODE when needed */
         if (input->kbd.flags & KEYEVENTF_KEYUP) flags |= KF_REPEAT | KF_UP;
-        else if (desktop->keystate[vkey] & 0x80) flags |= KF_REPEAT;
+        else if (desktop->shared->keystate[vkey] & 0x80) flags |= KF_REPEAT;
 
         msg->wparam = vkey;
         msg->lparam |= flags << 16;
@@ -2117,8 +2260,8 @@ static void queue_custom_hardware_messag
     msg->msg       = input->hw.msg;
     msg->wparam    = 0;
     msg->lparam    = input->hw.lparam;
-    msg->x         = desktop->cursor.x;
-    msg->y         = desktop->cursor.y;
+    msg->x         = desktop->shared->cursor.x;
+    msg->y         = desktop->shared->cursor.y;
 
     queue_hardware_message( desktop, msg, 1 );
 }
@@ -2198,7 +2341,7 @@ static int get_hardware_message( struct
         if (!win || !win_thread)
         {
             /* no window at all, remove it */
-            update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
+            update_input_key_state( input, msg->msg, msg->wparam );
             list_remove( &msg->entry );
             free_message( msg );
             continue;
@@ -2214,7 +2357,7 @@ static int get_hardware_message( struct
             else
             {
                 /* for another thread input, drop it */
-                update_input_key_state( input->desktop, input->keystate, msg->msg, msg->wparam );
+                update_input_key_state( input, msg->msg, msg->wparam );
                 list_remove( &msg->entry );
                 free_message( msg );
             }
@@ -2506,10 +2649,23 @@ DECL_HANDLER(set_queue_mask)
         queue->changed_mask = req->changed_mask;
         reply->wake_bits    = queue->wake_bits;
         reply->changed_bits = queue->changed_bits;
+        
+        SHARED_WRITE_BEGIN( &queue->shared->seq );
+        queue->shared->wake_mask = queue->wake_mask;
+        queue->shared->changed_mask = queue->changed_mask;
+        SHARED_WRITE_END( &queue->shared->seq );
+
         if (is_signaled( queue ))
         {
             /* if skip wait is set, do what would have been done in the subsequent wait */
-            if (req->skip_wait) queue->wake_mask = queue->changed_mask = 0;
+            if (req->skip_wait)
+            {   
+                queue->wake_mask = queue->changed_mask = 0;
+                SHARED_WRITE_BEGIN( &queue->shared->seq );
+                queue->shared->wake_mask = queue->wake_mask;
+                queue->shared->changed_mask = queue->changed_mask;
+                SHARED_WRITE_END( &queue->shared->seq );
+            }
             else wake_up( &queue->obj, 0 );
         }
         if (do_fsync() && !is_signaled( queue ))
@@ -2536,6 +2692,10 @@ DECL_HANDLER(get_queue_status)
 
         if (do_esync() && !is_signaled( queue ))
             esync_clear( queue->esync_fd );
+
+        SHARED_WRITE_BEGIN( &queue->shared->seq );
+        queue->shared->changed_bits = queue->changed_bits;
+        SHARED_WRITE_END( &queue->shared->seq );
     }
     else reply->wake_bits = reply->changed_bits = 0;
 }
@@ -2629,7 +2789,6 @@ DECL_HANDLER(send_hardware_message)
     struct desktop *desktop;
     unsigned int origin = (req->flags & SEND_HWMSG_INJECTED ? IMO_INJECTED : IMO_HARDWARE);
     struct msg_queue *sender = get_current_queue();
-    data_size_t size = min( 256, get_reply_max_size() );
 
     if (!(desktop = get_thread_desktop( current, 0 ))) return;
 
@@ -2644,8 +2803,8 @@ DECL_HANDLER(send_hardware_message)
         }
     }
 
-    reply->prev_x = desktop->cursor.x;
-    reply->prev_y = desktop->cursor.y;
+    reply->prev_x = desktop->shared->cursor.x;
+    reply->prev_y = desktop->shared->cursor.y;
 
     switch (req->input.type)
     {
@@ -2663,9 +2822,8 @@ DECL_HANDLER(send_hardware_message)
     }
     if (thread) release_object( thread );
 
-    reply->new_x = desktop->cursor.x;
-    reply->new_y = desktop->cursor.y;
-    set_reply_data( desktop->keystate, size );
+    reply->new_x = desktop->shared->cursor.x;
+    reply->new_y = desktop->shared->cursor.y;
     release_object( desktop );
 }
 
@@ -2691,8 +2849,6 @@ DECL_HANDLER(get_message)
     user_handle_t get_win = get_user_full_handle( req->get_win );
     unsigned int filter = req->flags >> 16;
 
-    reply->active_hooks = get_active_hooks();
-
     if (get_win && get_win != 1 && get_win != -1 && !get_user_object( get_win, USER_WINDOW ))
     {
         set_win32_error( ERROR_INVALID_WINDOW_HANDLE );
@@ -2720,6 +2876,10 @@ DECL_HANDLER(get_message)
     if (filter & QS_INPUT) queue->changed_bits &= ~QS_INPUT;
     if (filter & QS_PAINT) queue->changed_bits &= ~QS_PAINT;
 
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->changed_bits = queue->changed_bits;
+    SHARED_WRITE_END( &queue->shared->seq );
+
     /* then check for posted messages */
     if ((filter & QS_POSTMESSAGE) &&
         get_posted_message( queue, queue->ignore_post_msg, get_win, req->get_first, req->get_last, req->flags, reply ))
@@ -2783,6 +2943,12 @@ DECL_HANDLER(get_message)
     if (get_win == -1 && current->process->idle_event) set_event( current->process->idle_event );
     queue->wake_mask = req->wake_mask;
     queue->changed_mask = req->changed_mask;
+    
+    SHARED_WRITE_BEGIN( &queue->shared->seq );
+    queue->shared->wake_mask = queue->wake_mask;
+    queue->shared->changed_mask = queue->changed_mask;
+    SHARED_WRITE_END( &queue->shared->seq );
+    
     set_error( STATUS_PENDING );  /* FIXME */
 
     if (do_fsync() && !is_signaled( queue ))
@@ -3144,19 +3310,15 @@ DECL_HANDLER(get_thread_input)
 
     if (input)
     {
-        reply->focus      = input->focus;
-        reply->capture    = input->capture;
-        reply->active     = input->active;
-        reply->menu_owner = input->menu_owner;
-        reply->move_size  = input->move_size;
-        reply->caret      = input->caret;
-        reply->cursor     = input->cursor;
-        reply->show_count = input->cursor_count;
-        reply->rect       = input->caret_rect;
+        reply->focus      = input->shared->focus;
+        reply->capture    = input->shared->capture;
+        reply->active     = input->shared->active;
+        reply->menu_owner = input->shared->menu_owner;
+        reply->move_size  = input->shared->move_size;
+        reply->caret      = input->shared->caret;
+        reply->rect       = input->shared->caret_rect;
     }
 
-    /* foreground window is active window of foreground thread */
-    reply->foreground = desktop->foreground_input ? desktop->foreground_input->active : 0;
     if (thread) release_object( thread );
     release_object( desktop );
 }
@@ -3173,22 +3335,24 @@ DECL_HANDLER(get_key_state)
         if (!(desktop = get_thread_desktop( current, 0 ))) return;
         if (req->key >= 0)
         {
-            reply->state = desktop->keystate[req->key & 0xff];
-            desktop->keystate[req->key & 0xff] &= ~0x40;
+            reply->state = desktop->shared->keystate[req->key & 0xff];
+            SHARED_WRITE_BEGIN( &desktop->shared->seq );
+            desktop->shared->keystate[req->key & 0xff] &= ~0x40;
+            SHARED_WRITE_END( &desktop->shared->seq );
         }
-        set_reply_data( desktop->keystate, size );
+        else set_reply_data( (void *)desktop->shared->keystate, size );
         release_object( desktop );
     }
     else
     {
         struct msg_queue *queue = get_current_queue();
-        unsigned char *keystate = queue->input->keystate;
+        unsigned char *keystate = (void *)queue->input->shared->keystate;
         if (req->key >= 0)
         {
             sync_input_keystate( queue->input );
             reply->state = keystate[req->key & 0xff];
         }
-        set_reply_data( keystate, size );
+        else set_reply_data( keystate, size );
     }
 }
 
@@ -3200,11 +3364,16 @@ DECL_HANDLER(set_key_state)
     struct msg_queue *queue = get_current_queue();
     data_size_t size = min( 256, get_req_data_size() );
 
-    memcpy( queue->input->keystate, get_req_data(), size );
-    memcpy( queue->input->desktop_keystate, queue->input->desktop->keystate, 256 );
+    SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+    memcpy( (void *)queue->input->shared->keystate, get_req_data(), size );
+    SHARED_WRITE_END( &queue->input->shared->seq );
+    memcpy( queue->input->desktop_keystate, (void *)queue->input->desktop->shared->keystate,
+            sizeof(queue->input->desktop_keystate) );
     if (req->async && (desktop = get_thread_desktop( current, 0 )))
     {
-        memcpy( desktop->keystate, get_req_data(), size );
+        SHARED_WRITE_BEGIN( &desktop->shared->seq );
+        memcpy( (void *)desktop->shared->keystate, get_req_data(), size );
+        SHARED_WRITE_END( &desktop->shared->seq );
         release_object( desktop );
     }
 }
@@ -3218,7 +3387,7 @@ DECL_HANDLER(set_foreground_window)
     struct msg_queue *queue = get_current_queue();
 
     if (!(desktop = get_thread_desktop( current, 0 ))) return;
-    reply->previous = desktop->foreground_input ? desktop->foreground_input->active : 0;
+    reply->previous = desktop->foreground_input ? desktop->foreground_input->shared->active : 0;
     reply->send_msg_old = (reply->previous && desktop->foreground_input != queue->input);
     reply->send_msg_new = FALSE;
 
@@ -3244,8 +3413,10 @@ DECL_HANDLER(set_focus_window)
     reply->previous = 0;
     if (queue && check_queue_input_window( queue, req->handle ))
     {
-        reply->previous = queue->input->focus;
-        queue->input->focus = get_user_full_handle( req->handle );
+        reply->previous = queue->input->shared->focus;
+        SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+        queue->input->shared->focus = get_user_full_handle( req->handle );
+        SHARED_WRITE_END( &queue->input->shared->seq );
     }
 }
 
@@ -3260,8 +3431,10 @@ DECL_HANDLER(set_active_window)
     {
         if (!req->handle || make_window_active( req->handle ))
         {
-            reply->previous = queue->input->active;
-            queue->input->active = get_user_full_handle( req->handle );
+            reply->previous = queue->input->shared->active;
+            SHARED_WRITE_BEGIN( &queue->input->shared->seq );
+            queue->input->shared->active = get_user_full_handle( req->handle );
+            SHARED_WRITE_END( &queue->input->shared->seq );
         }
         else set_error( STATUS_INVALID_HANDLE );
     }
@@ -3279,16 +3452,18 @@ DECL_HANDLER(set_capture_window)
         struct thread_input *input = queue->input;
 
         /* if in menu mode, reject all requests to change focus, except if the menu bit is set */
-        if (input->menu_owner && !(req->flags & CAPTURE_MENU))
+        if (input->shared->menu_owner && !(req->flags & CAPTURE_MENU))
         {
             set_error(STATUS_ACCESS_DENIED);
             return;
         }
-        reply->previous = input->capture;
-        input->capture = get_user_full_handle( req->handle );
-        input->menu_owner = (req->flags & CAPTURE_MENU) ? input->capture : 0;
-        input->move_size = (req->flags & CAPTURE_MOVESIZE) ? input->capture : 0;
-        reply->full_handle = input->capture;
+        reply->previous = input->shared->capture;
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        input->shared->capture = get_user_full_handle( req->handle );
+        input->shared->menu_owner = (req->flags & CAPTURE_MENU) ? input->shared->capture : 0;
+        input->shared->move_size = (req->flags & CAPTURE_MOVESIZE) ? input->shared->capture : 0;
+        SHARED_WRITE_END( &input->shared->seq );
+        reply->full_handle = input->shared->capture;
     }
 }
 
@@ -3303,14 +3478,16 @@ DECL_HANDLER(set_caret_window)
     {
         struct thread_input *input = queue->input;
 
-        reply->previous  = input->caret;
-        reply->old_rect  = input->caret_rect;
+        reply->previous  = input->shared->caret;
+        reply->old_rect  = input->shared->caret_rect;
         reply->old_hide  = input->caret_hide;
         reply->old_state = input->caret_state;
 
+        SHARED_WRITE_BEGIN( &input->shared->seq );
         set_caret_window( input, get_user_full_handle(req->handle) );
-        input->caret_rect.right  = input->caret_rect.left + req->width;
-        input->caret_rect.bottom = input->caret_rect.top + req->height;
+        input->shared->caret_rect.right  = input->shared->caret_rect.left + req->width;
+        input->shared->caret_rect.bottom = input->shared->caret_rect.top + req->height;
+        SHARED_WRITE_END( &input->shared->seq );
     }
 }
 
@@ -3323,22 +3500,24 @@ DECL_HANDLER(set_caret_info)
 
     if (!queue) return;
     input = queue->input;
-    reply->full_handle = input->caret;
-    reply->old_rect    = input->caret_rect;
+    reply->full_handle = input->shared->caret;
+    reply->old_rect    = input->shared->caret_rect;
     reply->old_hide    = input->caret_hide;
     reply->old_state   = input->caret_state;
 
-    if (req->handle && get_user_full_handle(req->handle) != input->caret)
+    if (req->handle && get_user_full_handle(req->handle) != input->shared->caret)
     {
         set_error( STATUS_ACCESS_DENIED );
         return;
     }
     if (req->flags & SET_CARET_POS)
     {
-        input->caret_rect.right  += req->x - input->caret_rect.left;
-        input->caret_rect.bottom += req->y - input->caret_rect.top;
-        input->caret_rect.left = req->x;
-        input->caret_rect.top  = req->y;
+        SHARED_WRITE_BEGIN( &input->shared->seq );
+        input->shared->caret_rect.right  += req->x - input->shared->caret_rect.left;
+        input->shared->caret_rect.bottom += req->y - input->shared->caret_rect.top;
+        input->shared->caret_rect.left = req->x;
+        input->shared->caret_rect.top  = req->y;
+        SHARED_WRITE_END( &input->shared->seq );
     }
     if (req->flags & SET_CARET_HIDE)
     {
@@ -3363,7 +3542,10 @@ DECL_HANDLER(set_caret_info)
 /* get the time of the last input event */
 DECL_HANDLER(get_last_input_time)
 {
-    reply->time = last_input_time;
+    struct desktop *desktop;
+    if (!(desktop = get_thread_desktop( current, 0 ))) return;
+    reply->time = desktop->shared->last_input_time;
+    release_object( desktop );
 }
 
 /* set/get the current cursor */
@@ -3375,25 +3557,29 @@ DECL_HANDLER(set_cursor)
     if (!queue) return;
     input = queue->input;
 
-    reply->prev_handle = input->cursor;
-    reply->prev_count  = input->cursor_count;
-    reply->prev_x      = input->desktop->cursor.x;
-    reply->prev_y      = input->desktop->cursor.y;
+    reply->prev_handle = input->shared->cursor;
+    reply->prev_count  = input->shared->cursor_count;
+    reply->prev_x      = input->desktop->shared->cursor.x;
+    reply->prev_y      = input->desktop->shared->cursor.y;
+
+    if ((req->flags & SET_CURSOR_HANDLE) && req->handle &&
+        !get_user_object( req->handle, USER_CLIENT ))
+    {
+        set_win32_error( ERROR_INVALID_CURSOR_HANDLE );
+        return;
+    }
 
+    SHARED_WRITE_BEGIN( &input->shared->seq );
     if (req->flags & SET_CURSOR_HANDLE)
     {
-        if (req->handle && !get_user_object( req->handle, USER_CLIENT ))
-        {
-            set_win32_error( ERROR_INVALID_CURSOR_HANDLE );
-            return;
-        }
-        input->cursor = req->handle;
+        input->shared->cursor = req->handle;
     }
     if (req->flags & SET_CURSOR_COUNT)
     {
         queue->cursor_count += req->show_count;
-        input->cursor_count += req->show_count;
+        input->shared->cursor_count += req->show_count;
     }
+    SHARED_WRITE_END( &input->shared->seq );
     if (req->flags & SET_CURSOR_POS)
     {
         set_cursor_pos( input->desktop, req->x, req->y );
@@ -3404,15 +3590,15 @@ DECL_HANDLER(set_cursor)
 
         /* only the desktop owner can set the message */
         if (req->clip_msg && get_top_window_owner(desktop) == current->process)
-            desktop->cursor.clip_msg = req->clip_msg;
+            desktop->cursor_clip_msg = req->clip_msg;
 
         set_clip_rectangle( desktop, (req->flags & SET_CURSOR_NOCLIP) ? NULL : &req->clip, 0 );
     }
 
-    reply->new_x       = input->desktop->cursor.x;
-    reply->new_y       = input->desktop->cursor.y;
-    reply->new_clip    = input->desktop->cursor.clip;
-    reply->last_change = input->desktop->cursor.last_change;
+    reply->new_x       = input->desktop->shared->cursor.x;
+    reply->new_y       = input->desktop->shared->cursor.y;
+    reply->new_clip    = input->desktop->shared->cursor.clip;
+    reply->last_change = input->desktop->shared->cursor.last_change;
 }
 
 /* Get the history of the 64 last cursor positions */

-- 
2.37.2

