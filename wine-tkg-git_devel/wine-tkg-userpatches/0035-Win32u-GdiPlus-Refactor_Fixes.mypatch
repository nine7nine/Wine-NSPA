From: Jeff Smith <whydoubt@gmail.com>
Subject: [PATCH] gdi32: Allow any mode passed to SetBkMode().
Message-Id: <20201007042229.1313789-1-whydoubt@gmail.com>
Date: Tue,  6 Oct 2020 23:22:29 -0500

Signed-off-by: Jeff Smith <whydoubt@gmail.com>
---
Testing revealed that SetBkMode() does not treat 'invalid' values as one
might assume.  Discovered this when working on another issue.  Note that
fixing this to match Windows simplifies one of the tests for that bug.

 dlls/gdi32/dc.c       |  6 ------
 dlls/gdi32/tests/dc.c | 19 ++++++++++++++++++-
 2 files changed, 18 insertions(+), 7 deletions(-)

diff --git a/dlls/gdi32/dc.c b/dlls/gdi32/dc.c
index 11111111111..11111111111 100644
--- a/dlls/gdi32/dc.c
+++ b/dlls/gdi32/dc.c
@@ -678,12 +678,6 @@ INT WINAPI SetBkMode( HDC hdc, INT mode )
     DC_ATTR *dc_attr;
     INT ret;
 
-    if (mode <= 0 || mode > BKMODE_LAST)
-    {
-        SetLastError(ERROR_INVALID_PARAMETER);
-        return 0;
-    }
-
     if (is_meta_dc( hdc )) return METADC_SetBkMode( hdc, mode );
     if (!(dc_attr = get_dc_attr( hdc ))) return 0;
     if (dc_attr->emf && !EMFDC_SetBkMode( dc_attr, mode )) return 0;
diff --git a/dlls/gdi32/tests/dc.c b/dlls/gdi32/tests/dc.c
index 11111111111..11111111111 100644
--- a/dlls/gdi32/tests/dc.c
+++ b/dlls/gdi32/tests/dc.c
@@ -40,7 +40,7 @@ static void test_dc_values(void)
 {
     HDC hdc = CreateDCA("DISPLAY", NULL, NULL, NULL);
     COLORREF color;
-    int extra, attr;
+    int extra, attr, mode;
 
     ok( hdc != NULL, "CreateDC failed\n" );
     color = SetBkColor( hdc, 0x12345678 );
@@ -94,6 +94,23 @@ static void test_dc_values(void)
     ok(!attr, "GetDeviceCaps rets %d\n", attr);
     ok(GetLastError() == ERROR_INVALID_HANDLE, "GetLastError() = %lu\n", GetLastError());
 
+    mode = SetBkMode( hdc, TRANSPARENT );
+    ok( mode == OPAQUE, "initial mode %08x\n", mode );
+    mode = GetBkMode( hdc );
+    ok( mode == TRANSPARENT, "wrong mode %08x\n", mode );
+    mode = SetBkMode( hdc, OPAQUE );
+    ok( mode == TRANSPARENT, "wrong mode %08x\n", mode );
+    mode = GetBkMode( hdc );
+    ok( mode == OPAQUE, "wrong mode %08x\n", mode );
+    mode = SetBkMode( hdc, 0 );
+    ok( mode == OPAQUE, "wrong mode %08x\n", mode );
+    mode = GetBkMode( hdc );
+    ok( mode == 0, "wrong mode %08x\n", mode );
+    mode = SetBkMode( hdc, BKMODE_LAST + 1 );
+    ok( mode == 0, "wrong mode %08x\n", mode );
+    mode = GetBkMode( hdc );
+    ok( mode == BKMODE_LAST + 1, "wrong mode %08x\n", mode );
+
     DeleteDC( hdc );
 }
 
From a2cde919a94954b42af9b5fd2f587e605923c2c7 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 7 Nov 2020 03:48:02 +0100
Subject: [PATCH 08/11] win32u: Lazily initialize the font list.

---
 dlls/win32u/font.c | 58 +++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 52 insertions(+), 6 deletions(-)

diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -462,6 +462,10 @@ static const struct nls_update_font_list
 
 static pthread_mutex_t font_lock = PTHREAD_MUTEX_INITIALIZER;
 
+pthread_once_t font_list_init_once = PTHREAD_ONCE_INIT;
+DWORD font_list_init_disposition;
+void font_list_init(void);
+
 #ifndef WINE_FONT_DIR
 #define WINE_FONT_DIR "fonts"
 #endif
@@ -2836,6 +2840,7 @@ static BOOL CDECL font_CreateDC( PHYSDEV *dev, LPCWSTR device, LPCWSTR output,
 {
     struct font_physdev *physdev;
 
+    pthread_once( &font_list_init_once, font_list_init );
     if (!font_funcs) return TRUE;
     if (!(physdev = calloc( 1, sizeof(*physdev) ))) return FALSE;
     push_dc_driver( dev, &physdev->dev, &font_driver );
@@ -3124,6 +3129,8 @@ static BOOL CDECL font_EnumFonts( PHYSDEV dev, LOGFONTW *lf, FONTENUMPROCW proc,
     struct enum_charset enum_charsets[32];
     DWORD count, charset;
 
+    pthread_once( &font_list_init_once, font_list_init );
+
     charset = lf ? lf->lfCharSet : DEFAULT_CHARSET;
 
     count = create_enum_charset_list( charset, enum_charsets );
@@ -4122,6 +4129,7 @@ static HFONT CDECL font_SelectFont( PHYSDEV dev, HFONT hfont, UINT *aa_flags )
     struct gdi_font *font = NULL, *prev = physdev->font;
     DC *dc = get_physdev_dc( dev );
 
+    pthread_once( &font_list_init_once, font_list_init );
     if (hfont)
     {
         LOGFONTW lf;
@@ -5858,6 +5866,7 @@ BOOL CDECL __wine_get_file_outline_text_metric( const WCHAR *path, OUTLINETEXTME
 {
     struct gdi_font *font = NULL;
 
+    pthread_once( &font_list_init_once, font_list_init );
     if (!path || !font_funcs) return FALSE;
 
     if (!(font = alloc_gdi_font( path, NULL, 0 ))) goto done;
@@ -6319,8 +6328,41 @@ UINT font_init(void)
     if (!dpi) return 96;
     update_codepage( dpi );
 
+
+    attr.Attributes = OBJ_OPENIF;
+    attr.ObjectName = &name;
+    name.Buffer = wine_font_mutexW;
+    name.Length = name.MaximumLength = sizeof(wine_font_mutexW);
+
+    if (NtCreateMutant( &mutex, MUTEX_ALL_ACCESS, &attr, FALSE ) < 0) return dpi;
+    NtWaitForSingleObject( mutex, FALSE, NULL );
+
+    wine_fonts_cache_key = reg_create_key( wine_fonts_key, cacheW, sizeof(cacheW),
+                                           REG_OPTION_VOLATILE, &disposition );
+
+    if (disposition == REG_CREATED_NEW_KEY)
+    {
+        font_list_init_disposition = disposition;
+        pthread_once( &font_list_init_once, font_list_init );
+    }
+
+    NtReleaseMutant( mutex, NULL );
+    return dpi;
+}
+
+void font_list_init(void)
+{
+    OBJECT_ATTRIBUTES attr = { sizeof(attr) };
+    UNICODE_STRING name;
+    DWORD disposition = font_list_init_disposition;
+    HANDLE mutex;
+
+    static WCHAR wine_font_mutexW[] =
+        {'\\','B','a','s','e','N','a','m','e','d','O','b','j','e','c','t','s',
+         '\\','_','_','W','I','N','E','_','F','O','N','T','_','M','U','T','E','X','_','_'};
+
     if (!(font_funcs = init_freetype_lib()))
-        return dpi;
+        return;
 
     load_system_bitmap_fonts();
     load_file_system_fonts();
@@ -6331,12 +6373,9 @@ UINT font_init(void)
     name.Buffer = wine_font_mutexW;
     name.Length = name.MaximumLength = sizeof(wine_font_mutexW);
 
-    if (NtCreateMutant( &mutex, MUTEX_ALL_ACCESS, &attr, FALSE ) < 0) return dpi;
+    if (NtCreateMutant( &mutex, MUTEX_ALL_ACCESS, &attr, FALSE ) < 0) return FALSE;
     NtWaitForSingleObject( mutex, FALSE, NULL );
 
-    wine_fonts_cache_key = reg_create_key( wine_fonts_key, cacheW, sizeof(cacheW),
-                                           REG_OPTION_VOLATILE, &disposition );
-
     if (disposition == REG_CREATED_NEW_KEY)
     {
         load_registry_fonts();
@@ -6357,7 +6396,8 @@ UINT font_init(void)
     load_system_links();
     dump_gdi_font_list();
     dump_gdi_font_subst();
-    return dpi;
+
+    return;
 }
 
 /***********************************************************************
@@ -6366,6 +6406,7 @@ UINT font_init(void)
 INT WINAPI NtGdiAddFontResourceW( const WCHAR *str, ULONG size, ULONG files, DWORD flags,
                                   DWORD tid, void *dv )
 {
+    pthread_once( &font_list_init_once, font_list_init );
     if (!font_funcs) return 1;
     return add_font_resource( str, flags );
 }
@@ -6385,6 +6426,7 @@ HANDLE WINAPI NtGdiAddFontMemResourceEx( void *ptr, DWORD size, void *dv, ULONG
         RtlSetLastWin32Error(ERROR_INVALID_PARAMETER);
         return NULL;
     }
+    pthread_once( &font_list_init_once, font_list_init );
     if (!font_funcs) return NULL;
     if (!(copy = malloc( size ))) return NULL;
     memcpy( copy, ptr, size );
@@ -6434,6 +6476,7 @@ BOOL WINAPI NtGdiRemoveFontMemResourceEx( HANDLE handle )
 BOOL WINAPI NtGdiRemoveFontResourceW( const WCHAR *str, ULONG size, ULONG files, DWORD flags,
                                       DWORD tid, void *dv )
 {
+    pthread_once( &font_list_init_once, font_list_init );
     if (!font_funcs) return TRUE;
     return remove_font_resource( str, flags );
 }
@@ -6512,6 +6555,7 @@ BOOL WINAPI NtGdiGetRealizationInfo( HDC hdc, struct font_realization_info *info
  */
 BOOL WINAPI NtGdiGetRasterizerCaps( RASTERIZER_STATUS *status, UINT size )
 {
+    pthread_once( &font_list_init_once, font_list_init );
     status->nSize = sizeof(RASTERIZER_STATUS);
     status->wFlags = font_funcs ? (TT_AVAILABLE | TT_ENABLED) : 0;
     status->nLanguageID = 0;
@@ -6528,6 +6572,7 @@ BOOL WINAPI NtGdiGetFontFileData( DWORD instance_id, DWORD file_index, UINT64 *o
     DWORD tag = 0, size;
     BOOL ret = FALSE;
 
+    pthread_once( &font_list_init_once, font_list_init );
     if (!font_funcs) return FALSE;
     pthread_mutex_lock( &font_lock );
     if ((font = get_font_from_handle( instance_id )))
@@ -6553,6 +6598,7 @@ BOOL WINAPI NtGdiGetFontFileInfo( DWORD instance_id, DWORD file_index, struct fo
     struct gdi_font *font;
     BOOL ret = FALSE;
 
+    pthread_once( &font_list_init_once, font_list_init );
     pthread_mutex_lock( &font_lock );
 
     if ((font = get_font_from_handle( instance_id )))
-- 
2.37.2

From 9936c5de2c495584cb6773a8120d59e192d08be4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Nov 2020 18:44:10 +0100
Subject: [PATCH 09/11] win32u: Print full bitmap size in the font list.

---
 dlls/win32u/font.c | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -94,6 +94,12 @@ struct gdi_font_face
     struct wine_rb_entry       full_name_entry;
 };
 
+static inline const char *debugstr_bitmap_font_size(struct bitmap_font_size *size)
+{
+    return wine_dbg_sprintf("width %2d, height %2d, size %2d, xppem %4d, yppem %4d, il %2d",
+                            size->width, size->height, size->size, size->x_ppem, size->y_ppem, size->internal_leading);
+}
+
 static const struct font_backend_funcs *font_funcs;
 
 static const MAT2 identity = { {0,1}, {0,0}, {0,0}, {0,1} };
@@ -988,7 +998,7 @@ static void dump_gdi_font_list(void)
         {
             TRACE( "\t%s\t%s\t%08x", debugstr_w(face->style_name), debugstr_w(face->full_name),
                    (int)face->fs.fsCsb[0] );
-            if (!face->scalable) TRACE(" %d", face->size.height );
+            if (!face->scalable) TRACE(" %s", debugstr_bitmap_font_size(&face->size) );
             TRACE("\n");
 	}
     }
-- 
2.37.2

From 5514f6ff8f2ae346374702a971a64eab65ffe7f2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 13 Nov 2020 11:39:03 +0100
Subject: [PATCH 10/11] win32u: Add WinFNT font parser to replace FreeType.

---
 dlls/win32u/freetype.c      |  31 +++++++-
 dlls/win32u/ntgdi_private.h |   4 +
 dlls/win32u/opentype.c      | 150 ++++++++++++++++++++++++++++++++++++
 3 files changed, 184 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/freetype.c b/dlls/win32u/freetype.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/freetype.c
+++ b/dlls/win32u/freetype.c
@@ -1173,9 +1173,11 @@ static struct unix_face *unix_face_create( const char *unix_name, void *data_ptr
 
     const struct ttc_sfnt_v1 *ttc_sfnt_v1;
     const struct tt_name_v0 *tt_name_v0;
+    const char *family_name_a = NULL, *style_name_a = NULL;
     struct unix_face *This;
     struct stat st;
-    DWORD face_count;
+    DWORD face_count, needed;
+    WORD width, height, points, ppem, in_leading;
     int fd, length;
 
     TRACE( "unix_name %s, face_index %u, data_ptr %p, data_size %u, flags %#x\n",
@@ -1242,6 +1244,33 @@ static struct unix_face *unix_face_create( const char *unix_name, void *data_ptr
             WARN( "full name not found, using %s instead\n", debugstr_w(This->full_name) );
         }
     }
+    else if (winfnt_parse_font_face( data_ptr, data_size, face_index, &face_count,
+                                     &family_name_a, &style_name_a, &This->fs, &This->ntm_flags,
+                                     &width, &height, &points, &ppem, &in_leading ))
+    {
+        This->scalable = FALSE;
+        This->num_faces = face_count;
+        This->font_version = 0;
+
+        This->family_name = towstr( family_name_a );
+        This->second_name = NULL;
+        This->style_name = towstr( style_name_a );
+
+        TRACE( "parsed font names family_name %s, style_name %s\n", debugstr_w(This->family_name), debugstr_w(This->style_name) );
+
+        length = lstrlenW( This->family_name ) + lstrlenW( space_w ) + lstrlenW( This->style_name ) + 1;
+        This->full_name = malloc( length * sizeof(WCHAR) );
+        lstrcpyW( This->full_name, This->family_name );
+        lstrcatW( This->full_name, space_w );
+        lstrcatW( This->full_name, This->style_name );
+
+        This->size.height = height;
+        This->size.width = width;
+        This->size.size = points * 64;
+        This->size.y_ppem = ppem;
+        This->size.x_ppem = ppem;
+        This->size.internal_leading = in_leading;
+    }
     else if ((This->ft_face = new_ft_face( unix_name, data_ptr, data_size, face_index, flags & ADDFONT_ALLOW_BITMAP )))
     {
         WARN( "unable to parse font, falling back to FreeType\n" );
diff --git a/dlls/win32u/ntgdi_private.h b/dlls/win32u/ntgdi_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntgdi_private.h
+++ b/dlls/win32u/ntgdi_private.h
@@ -372,6 +372,10 @@ extern BOOL opentype_get_properties( const void *data, size_t size, const struct
                                      DWORD *version, FONTSIGNATURE *fs, DWORD *ntm_flags ) DECLSPEC_HIDDEN;
 extern BOOL translate_charset_info( DWORD *src, CHARSETINFO *cs, DWORD flags ) DECLSPEC_HIDDEN;
 
+extern BOOL winfnt_parse_font_face( const void *data, size_t size, DWORD index, DWORD *count,
+                                    const char **family_name, const char **style_name, FONTSIGNATURE *fs, DWORD *ntm_flags,
+                                    WORD *width, WORD *height, WORD *points, WORD *ppem, WORD *in_leading ) DECLSPEC_HIDDEN;
+
 /* gdiobj.c */
 extern HGDIOBJ alloc_gdi_handle( struct gdi_obj_header *obj, DWORD type,
                                  const struct gdi_obj_funcs *funcs ) DECLSPEC_HIDDEN;
diff --git a/dlls/win32u/opentype.c b/dlls/win32u/opentype.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/opentype.c
+++ b/dlls/win32u/opentype.c
@@ -632,6 +632,7 @@ BOOL opentype_get_ttc_sfnt_v1( const void *data, size_t size, DWORD index, DWORD
     default:
         WARN( "unsupported font format %x\n", fourcc );
         return FALSE;
+    case 0x010d5a4d: /* WinFNT header */ return FALSE;
     case MS_TTCF_TAG:
         if (size < sizeof(ttc_header_v1)) return FALSE;
         if (index >= (*count = GET_BE_DWORD( ttc_header_v1->numFonts ))) return FALSE;
@@ -769,3 +770,152 @@ BOOL opentype_get_properties( const void *data, size_t size, const struct ttc_sf
     *ntm_flags = flags;
     return TRUE;
 }
+
+#include "pshpack1.h"
+typedef struct
+{
+    INT16 dfType;
+    INT16 dfPoints;
+    INT16 dfVertRes;
+    INT16 dfHorizRes;
+    INT16 dfAscent;
+    INT16 dfInternalLeading;
+    INT16 dfExternalLeading;
+    BYTE  dfItalic;
+    BYTE  dfUnderline;
+    BYTE  dfStrikeOut;
+    INT16 dfWeight;
+    BYTE  dfCharSet;
+    INT16 dfPixWidth;
+    INT16 dfPixHeight;
+    BYTE  dfPitchAndFamily;
+    INT16 dfAvgWidth;
+    INT16 dfMaxWidth;
+    BYTE  dfFirstChar;
+    BYTE  dfLastChar;
+    BYTE  dfDefaultChar;
+    BYTE  dfBreakChar;
+    INT16 dfWidthBytes;
+    LONG  dfDevice;
+    LONG  dfFace;
+    LONG  dfBitsPointer;
+    LONG  dfBitsOffset;
+    BYTE  dfReserved;
+    LONG  dfFlags;
+    INT16 dfAspace;
+    INT16 dfBspace;
+    INT16 dfCspace;
+    LONG  dfColorPointer;
+    LONG  dfReserved1[4];
+} FONTINFO16;
+
+typedef struct
+{
+    WORD dfVersion;
+    DWORD dfSize;
+    char dfCopyright[60];
+    FONTINFO16 fi;
+} FNT_HEADER;
+
+typedef struct
+{
+    WORD  offset;
+    WORD  length;
+    WORD  flags;
+    WORD  id;
+    WORD  handle;
+    WORD  usage;
+} NE_NAMEINFO;
+
+typedef struct
+{
+    WORD  type_id;
+    WORD  count;
+    DWORD resloader;
+} NE_TYPEINFO;
+#include "poppack.h"
+
+#define NE_RSCTYPE_FONTDIR 0x8007
+#define NE_RSCTYPE_FONT    0x8008
+
+BOOL winfnt_parse_font_face( const void *data, size_t size, DWORD index, DWORD *count,
+                             const char **family_name, const char **style_name, FONTSIGNATURE *fs, DWORD *ntm_flags,
+                             WORD *width, WORD *height, WORD *points, WORD *ppem, WORD *in_leading )
+{
+    const IMAGE_DOS_HEADER *dos = data;
+    const IMAGE_OS2_HEADER *os2 = (const IMAGE_OS2_HEADER *)((const char *)data + dos->e_lfanew);
+    DWORD offset, flags;
+    WORD align;
+
+    if (dos->e_magic != IMAGE_DOS_SIGNATURE) return FALSE;
+
+    if (dos->e_lfanew <= size && dos->e_lfanew + sizeof(*os2) <= size &&
+        os2->ne_magic == IMAGE_OS2_SIGNATURE)
+    {
+        const char *rsrc_table = (const char *)os2 + os2->ne_rsrctab;
+        const char *res_table = (const char *)os2 + os2->ne_restab;
+        const NE_TYPEINFO *type = (const NE_TYPEINFO *)(rsrc_table + sizeof(align));
+        const NE_NAMEINFO *name = (const NE_NAMEINFO *)(type + 1);
+        const FNT_HEADER *fnt_header;
+
+        if ((const char *)name >= res_table) return FALSE;
+        memcpy(&align, rsrc_table, sizeof(align));
+
+        if (type->type_id != NE_RSCTYPE_FONTDIR) return FALSE;
+        if (rsrc_table + name->id >= res_table) return FALSE;
+        if (*(rsrc_table + name->id) != strlen("FONTDIR")) return FALSE;
+        if (memcmp(rsrc_table + name->id + 1, "FONTDIR", strlen("FONTDIR"))) return FALSE;
+
+        type = (const NE_TYPEINFO *)(name + 1);
+        if (type->type_id != NE_RSCTYPE_FONT) return FALSE;
+        *count = type->count;
+
+        if (index >= type->count) return FALSE;
+        name = (const NE_NAMEINFO *)(type + 1) + index;
+        offset = name->offset << align;
+
+        if (offset >= size || offset + sizeof(*fnt_header) >= size) return FALSE;
+        fnt_header = (const FNT_HEADER *)((const char *)data + offset);
+
+        *family_name = (const char *)fnt_header + fnt_header->fi.dfFace;
+        switch (fnt_header->fi.dfCharSet)
+        {
+            case ANSI_CHARSET:        fs->fsCsb[0] = FS_LATIN1; break;
+            case EASTEUROPE_CHARSET:  fs->fsCsb[0] = FS_LATIN2; break;
+            case RUSSIAN_CHARSET:     fs->fsCsb[0] = FS_CYRILLIC; break;
+            case GREEK_CHARSET:       fs->fsCsb[0] = FS_GREEK; break;
+            case TURKISH_CHARSET:     fs->fsCsb[0] = FS_TURKISH; break;
+            case HEBREW_CHARSET:      fs->fsCsb[0] = FS_HEBREW; break;
+            case ARABIC_CHARSET:      fs->fsCsb[0] = FS_ARABIC; break;
+            case BALTIC_CHARSET:      fs->fsCsb[0] = FS_BALTIC; break;
+            case VIETNAMESE_CHARSET:  fs->fsCsb[0] = FS_VIETNAMESE; break;
+            case THAI_CHARSET:        fs->fsCsb[0] = FS_THAI; break;
+            case SHIFTJIS_CHARSET:    fs->fsCsb[0] = FS_JISJAPAN; break;
+            case GB2312_CHARSET:      fs->fsCsb[0] = FS_CHINESESIMP; break;
+            case HANGEUL_CHARSET:     fs->fsCsb[0] = FS_WANSUNG; break;
+            case CHINESEBIG5_CHARSET: fs->fsCsb[0] = FS_CHINESETRAD; break;
+            case JOHAB_CHARSET:       fs->fsCsb[0] = FS_JOHAB; break;
+            case SYMBOL_CHARSET:      fs->fsCsb[0] = FS_SYMBOL; break;
+        }
+
+        flags = 0;
+        if (fnt_header->fi.dfItalic) flags |= NTM_ITALIC;
+        if (fnt_header->fi.dfWeight > FW_NORMAL) flags |= NTM_BOLD;
+        if (flags == 0) flags = NTM_REGULAR;
+        *ntm_flags = flags;
+
+        if (flags == (NTM_BOLD|NTM_ITALIC)) *style_name = "Bold Italic";
+        else if (flags == NTM_BOLD) *style_name = "Bold";
+        else if (flags == NTM_ITALIC) *style_name = "Italic";
+        else *style_name = "Regular";
+
+        *width = fnt_header->fi.dfAvgWidth;
+        *height = fnt_header->fi.dfPixHeight;
+        *points = fnt_header->fi.dfPoints;
+        *ppem = ((fnt_header->fi.dfPoints * fnt_header->fi.dfVertRes * 0x40) / 72
+                 + fnt_header->fi.dfInternalLeading + fnt_header->fi.dfExternalLeading + 0x20) & ~0x3f;
+        *in_leading = fnt_header->fi.dfInternalLeading;
+    }
+
+    return TRUE;
+}
-- 
2.37.2

From 7dfe5729f4e5b015b360cf114f41f7cc5fe4977d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Nov 2020 19:53:50 +0100
Subject: [PATCH 11/11] WIP: win32u: Partially fix WinFNT font issue.

---
 dlls/gdi32/tests/font.c |  2 +-
 dlls/win32u/font.c      | 24 ++++++++++++++----------
 dlls/win32u/opentype.c  | 28 ++++++++++++++--------------
 3 files changed, 29 insertions(+), 25 deletions(-)

diff --git a/dlls/gdi32/tests/font.c b/dlls/gdi32/tests/font.c
index 11111111111..11111111111 100644
--- a/dlls/gdi32/tests/font.c
+++ b/dlls/gdi32/tests/font.c
@@ -968,7 +968,7 @@ static void test_bitmap_font_metrics(void)
             if ((is_CJK() || expected_cs == 254) && lf.lfCharSet == ANSI_CHARSET)
                 ok(ret == ANSI_CHARSET, "got charset %d, expected ANSI_CHARSETd\n", ret);
             else
-                ok(ret == expected_cs, "got charset %d, expected %d\n", ret, expected_cs);
+                ok(ret == expected_cs, "%d: got charset %d, expected %d\n", i, ret, expected_cs);
 
             if(fd[i].dpi == tm.tmDigitizedAspectX)
             {
diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -1083,14 +1083,6 @@ static int remove_font( const WCHAR *file, DWORD flags )
     return count;
 }
 
-static inline BOOL faces_equal( const struct gdi_font_face *f1, const struct gdi_font_face *f2 )
-{
-    if (facename_compare( f1->full_name, f2->full_name, -1 )) return FALSE;
-    if (f1->scalable) return TRUE;
-    if (f1->size.y_ppem != f2->size.y_ppem) return FALSE;
-    return !memcmp( &f1->fs, &f2->fs, sizeof(f1->fs) );
-}
-
 static inline int style_order( const struct gdi_font_face *face )
 {
     switch (face->ntmFlags & (NTM_REGULAR | NTM_BOLD | NTM_ITALIC))
@@ -1110,13 +1102,25 @@ static inline int style_order( const struct gdi_font_face *face )
     }
 }
 
+static inline int gdi_font_face_compare( const struct gdi_font_face *f1, const struct gdi_font_face *f2 )
+{
+    int ret;
+    if ((ret = style_order(f1) - style_order(f2))) return ret;
+    if ((ret = facename_compare( f1->full_name, f2->full_name, -1 ))) return ret;
+    if (f1->scalable && f2->scalable) return 0;
+    if ((ret = (f1->fs.fsCsb[0] - f2->fs.fsCsb[0]))) return ret;
+    if ((ret = (f1->size.y_ppem - f2->size.y_ppem))) return ret;
+    return memcmp( &f1->fs, &f2->fs, sizeof(f1->fs) );
+}
+
 static BOOL insert_face_in_family_list( struct gdi_font_face *face, struct gdi_font_family *family )
 {
+    int ret;
     struct gdi_font_face *cursor;
 
     LIST_FOR_EACH_ENTRY( cursor, &family->faces, struct gdi_font_face, entry )
     {
-        if (faces_equal( face, cursor ))
+        if (!(ret = gdi_font_face_compare( face, cursor )))
         {
             TRACE( "Already loaded face %s in family %s, original version %x, new version %x\n",
                    debugstr_w(face->full_name), debugstr_w(family->family_name),
@@ -1152,7 +1156,7 @@ static BOOL insert_face_in_family_list( struct gdi_font_face *face, struct gdi_f
                 return TRUE;
             }
         }
-        if (style_order( face ) < style_order( cursor )) break;
+        else if (ret < 0) break;
     }
 
     TRACE( "Adding face %s in family %s from %s\n", debugstr_w(face->full_name),
diff --git a/dlls/win32u/opentype.c b/dlls/win32u/opentype.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/opentype.c
+++ b/dlls/win32u/opentype.c
@@ -881,20 +881,20 @@ BOOL winfnt_parse_font_face( const void *data, size_t size, DWORD index, DWORD *
         switch (fnt_header->fi.dfCharSet)
         {
             case ANSI_CHARSET:        fs->fsCsb[0] = FS_LATIN1; break;
-            case EASTEUROPE_CHARSET:  fs->fsCsb[0] = FS_LATIN2; break;
-            case RUSSIAN_CHARSET:     fs->fsCsb[0] = FS_CYRILLIC; break;
-            case GREEK_CHARSET:       fs->fsCsb[0] = FS_GREEK; break;
-            case TURKISH_CHARSET:     fs->fsCsb[0] = FS_TURKISH; break;
-            case HEBREW_CHARSET:      fs->fsCsb[0] = FS_HEBREW; break;
-            case ARABIC_CHARSET:      fs->fsCsb[0] = FS_ARABIC; break;
-            case BALTIC_CHARSET:      fs->fsCsb[0] = FS_BALTIC; break;
-            case VIETNAMESE_CHARSET:  fs->fsCsb[0] = FS_VIETNAMESE; break;
-            case THAI_CHARSET:        fs->fsCsb[0] = FS_THAI; break;
-            case SHIFTJIS_CHARSET:    fs->fsCsb[0] = FS_JISJAPAN; break;
-            case GB2312_CHARSET:      fs->fsCsb[0] = FS_CHINESESIMP; break;
-            case HANGEUL_CHARSET:     fs->fsCsb[0] = FS_WANSUNG; break;
-            case CHINESEBIG5_CHARSET: fs->fsCsb[0] = FS_CHINESETRAD; break;
-            case JOHAB_CHARSET:       fs->fsCsb[0] = FS_JOHAB; break;
+            case EASTEUROPE_CHARSET:  fs->fsCsb[0] = FS_LATIN2; return FALSE;
+            case RUSSIAN_CHARSET:     fs->fsCsb[0] = FS_CYRILLIC; return FALSE;
+            case GREEK_CHARSET:       fs->fsCsb[0] = FS_GREEK; return FALSE;
+            case TURKISH_CHARSET:     fs->fsCsb[0] = FS_TURKISH; return FALSE;
+            case HEBREW_CHARSET:      fs->fsCsb[0] = FS_HEBREW; return FALSE;
+            case ARABIC_CHARSET:      fs->fsCsb[0] = FS_ARABIC; return FALSE;
+            case BALTIC_CHARSET:      fs->fsCsb[0] = FS_BALTIC; return FALSE;
+            case VIETNAMESE_CHARSET:  fs->fsCsb[0] = FS_VIETNAMESE; return FALSE;
+            case THAI_CHARSET:        fs->fsCsb[0] = FS_THAI; return FALSE;
+            case SHIFTJIS_CHARSET:    fs->fsCsb[0] = FS_JISJAPAN; return FALSE;
+            case GB2312_CHARSET:      fs->fsCsb[0] = FS_CHINESESIMP; return FALSE;
+            case HANGEUL_CHARSET:     fs->fsCsb[0] = FS_WANSUNG; return FALSE;
+            case CHINESEBIG5_CHARSET: fs->fsCsb[0] = FS_CHINESETRAD; return FALSE;
+            case JOHAB_CHARSET:       fs->fsCsb[0] = FS_JOHAB; return FALSE;
             case SYMBOL_CHARSET:      fs->fsCsb[0] = FS_SYMBOL; break;
         }
 
-- 
2.37.2

From: "Rafał Mużyło" <galtgendo@o2.pl>
Subject: [PATCH] win32u: fix another font->base_font regression
Message-Id: <20201114153442.GA3329@blackspire3>
Date: Sat, 14 Nov 2020 16:34:42 +0100

This regression has pretty much the same reason as the other recent one.
Simply reverting to the properly working code.

Signed-off-by: Rafał Mużyło <galtgendo@o2.pl>

diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -3350,6 +3350,7 @@ static UINT get_glyph_index_linked( struct gdi_font **font, UINT glyph )
     struct gdi_font *child;
     UINT res;
 
+    if ((*font)->base_font) *font = (*font)->base_font;
     if ((res = get_glyph_index( *font, glyph ))) return res;
     if (glyph < 32) return 0;  /* don't check linked fonts for control characters */
 

From: Damjan Jovanovic <damjan.jov@gmail.com>
Subject: [PATCH v2] win32u: fix PatBlt() drawing with negative width/height
Message-Id: <CAJm2B-nGcPd+7XpfuC=rYYeLuxEodSq6JsVBzp=a6fZR7fyuSg@mail.gmail.com>
Date: Fri, 23 Apr 2021 11:25:10 +0200

In a (x, y, w, h) rectangle passed to PatBlt(), a negative w results in
the rectangle drawn being (x+w, y, -w, h), and negative h results in
(x, y+h, w, -h). Wine instead does (x+w+1, y, -w, h) and
(x, y+h+1, w, -h), so the rectangle drawn is misplaced:

Windows
 (0,0)
   +------+
   |+-----++
   ||     ||
   ++-----+|
    +------+
           Wine

This patch recalculates the rectangle dimensions correctly.

Try 2 tests brush patterns and multiple DIB/DDB formats.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=27584
Signed-off-by: Damjan Jovanovic <damjan.jov@gmail.com>
---
 dlls/gdi32/tests/dib.c | 86 ++++++++++++++++++++++++------------------
 dlls/win32u/bitblt.c   | 11 ++++++
 2 files changed, 61 insertions(+), 36 deletions(-)

<div dir="ltr"><font face="monospace"><br>In a (x, y, w, h) rectangle passed to PatBlt(), a negative w results in<br>the rectangle drawn being (x+w, y, -w, h), and negative h results in<br>(x, y+h, w, -h). Wine instead does (x+w+1, y, -w, h) and<br>(x, y+h+1, w, -h), so the rectangle drawn is misplaced:<br><br>Windows<br> (0,0)<br>   +------+<br>   |+-----++<br>   ||     ||<br>   ++-----+|<br>    +------+<br>           Wine<br><br>This patch recalculates the rectangle dimensions correctly.<br><br>Try 2 tests brush patterns and multiple DIB/DDB formats.<br><br>Wine-Bug: <a href="https://bugs.winehq.org/show_bug.cgi?id=27584">https://bugs.winehq.org/show_bug.cgi?id=27584</a><br>Signed-off-by: Damjan Jovanovic &lt;<a href="mailto:damjan.jov@gmail.com">damjan.jov@gmail.com</a>&gt;<br>---<br> dlls/gdi32/bitblt.c    | 11 ++++++<br> dlls/gdi32/tests/dib.c | 86 ++++++++++++++++++++++++------------------<br> 2 files changed, 61 insertions(+), 36 deletions(-)<br></font></div>

diff --git a/dlls/gdi32/tests/dib.c b/dlls/gdi32/tests/dib.c
index 11111111111..11111111111 100644
--- a/dlls/gdi32/tests/dib.c
+++ b/dlls/gdi32/tests/dib.c
@@ -80,7 +80,7 @@ static const char *sha1_graphics_a8r8g8b8[] =
     "2426172d9e8fec27d9228088f382ef3c93717da9",
     "9e8f27ca952cdba01dbf25d07c34e86a7820c012",
     "664fac17803859a4015c6ae29e5538e314d5c827",
-    "17b2c177bdce5e94433574a928bda5c94a8cdfa5",
+    "c070896a2188d3b6a0abeb8d5c64b716c441b695",
     "fe6cc678fb13a3ead67839481bf22348adc69f52",
     "d51bd330cec510cdccf5394328bd8e5411901e9e",
     "df4aebf98d91f11be560dd232123b3ae327303d7",
@@ -91,7 +91,7 @@ static const char *sha1_graphics_a8r8g8b8[] =
     "6c530622a025d872a642e8f950867884d7b136cb",
     "7c07d91b8f68fb31821701b3dcb96de018bf0c66",
     "b2261353decda2712b83538ab434a49ce21f3172",
-    "35f731c0f6356b8f30651bb3cbe0d922c49deba5",
+    "a30c8797c21a4b077fd5e7111866601c68953324",
     "9b9874c1c1d92afa554137e191d34ea33acc322f",
     "c311dd74325e8cebfc8529a6d24a6fa4ecb7137e",
     "d7398de15b2837a58a62a701ca1b3384625afec4",
@@ -152,7 +152,7 @@ static const char *sha1_graphics_a8r8g8b8_bitfields[] =
     "2426172d9e8fec27d9228088f382ef3c93717da9",
     "9e8f27ca952cdba01dbf25d07c34e86a7820c012",
     "664fac17803859a4015c6ae29e5538e314d5c827",
-    "17b2c177bdce5e94433574a928bda5c94a8cdfa5",
+    "c070896a2188d3b6a0abeb8d5c64b716c441b695",
     "fe6cc678fb13a3ead67839481bf22348adc69f52",
     "d51bd330cec510cdccf5394328bd8e5411901e9e",
     "df4aebf98d91f11be560dd232123b3ae327303d7",
@@ -163,7 +163,7 @@ static const char *sha1_graphics_a8r8g8b8_bitfields[] =
     "6c530622a025d872a642e8f950867884d7b136cb",
     "7c07d91b8f68fb31821701b3dcb96de018bf0c66",
     "b2261353decda2712b83538ab434a49ce21f3172",
-    "35f731c0f6356b8f30651bb3cbe0d922c49deba5",
+    "a30c8797c21a4b077fd5e7111866601c68953324",
     "9b9874c1c1d92afa554137e191d34ea33acc322f",
     "c311dd74325e8cebfc8529a6d24a6fa4ecb7137e",
     "d7398de15b2837a58a62a701ca1b3384625afec4",
@@ -224,7 +224,7 @@ static const char *sha1_graphics_a8b8g8r8[] =
     "e0bc877697093ed440e125154e247ca9d65e933c",
     "c6d7faf5a502299f99d59eef3f7650bd63dbe108",
     "9d8c05c3ebd786e7d052418e905a80a64bf7853d",
-    "3da12af0a810fd993fa3dbe23328a4fcd2b6c92a",
+    "f6e685c28f56ee4cee61009e99aba283a9e4574f",
     "b91c8f21cc4d7994abc551feff5b6927d267a9db",
     "d49dd2c6a37e975b6dc3d201ccc217a788b30284",
     "ca6753f9eb44529cf8c67cd6abcd4ed1ef758904",
@@ -235,7 +235,7 @@ static const char *sha1_graphics_a8b8g8r8[] =
     "bf57a6a37fb107d29ed3d45695919887abcb7902",
     "3db0f8bcca3d94920aa57be6321202b8c3c08822",
     "1f1fc165a4dae7ba118ddccb58a279bfe3876b0a",
-    "8e09abb108e137c99527ab4c9bd07d95b9254bbb",
+    "b65d84bcdaa0a2c4112a2765702c33afc3c85273",
     "b0178632775d29bec2b16de7b9b8287115c40d0f",
     "ca7e859647b9498b53fdd92543ad8aea98ff46f3",
     "3369889a67d6c79a24ee15f7d14374f9995215e4",
@@ -296,7 +296,7 @@ static const char *sha1_graphics_r10g10b10[] =
     "b340b5d4750dd3dcd95d73c41b2c3a17f799210b",
     "b1db68f35022c5fd43519ec8e98047e16bc4fff8",
     "6e1902eb24865e74066fa9f2a7a49e6f9154f62f",
-    "35df9f4b0965fedf7bca36aa4f17b0fa20e2cd03",
+    "8fb8aea5aef62a13ff31b292ef4259c1e45a7b01",
     "5652e1feb7d4f22c8a2721fd141157e0b9ef965e",
     "22d89d5933f8b9bd60e9b22e42e7f5659269b63d",
     "0ad27de0c916c073d0d18484fff899bbdb258db7",
@@ -307,7 +307,7 @@ static const char *sha1_graphics_r10g10b10[] =
     "ca4b25a5459885ce1e0a36844612087893d425b1",
     "181bd4616796d89174cedc0332fb320b65aeb0e2",
     "6c417b1798ee319eeb404efe4aa136ed7ed37966",
-    "9a9f83e2035aa591d18101c919d1fd5b3456b46c",
+    "d7d1fa3b8c432e5daf688eb2da2f8d7c3b0c368e",
     "74ce9f5658cd8aeae4601fe72fcef07d9f75ec26",
     "536eaaa901d652805a8977ecb2dc73f651094c5b",
     "b8b1ac11bcc7174c5b23c18cc7919d09a04255c2",
@@ -368,7 +368,7 @@ static const char *sha1_graphics_r6g6b6[] =
     "a1adb32e70188a00f82fe58156b4da74f3ef7a0a",
     "5b9dab3d8411afb25fbbeba0313db526815ac189",
     "6415f551e28e1b38b2d721f0a9e003b7d215f6b2",
-    "2028d1b0d1acef35dc07027135023f35fb9746b9",
+    "daecf695dd8e31e79e8749540ccf7014e479ba31",
     "378713720dcb5aadb730435ad0989a68ab189114",
     "084152773feb01a85df6006f2f4f288a1442d37a",
     "97b824953f60fc9a91028045baacbe7b7dc82b14",
@@ -379,7 +379,7 @@ static const char *sha1_graphics_r6g6b6[] =
     "e51bcf80211cd06e7d10225534b7a79b5454be27",
     "9bf91a547f47b29bf370e9b60eae7cd6ce987617",
     "0b94e0a5b739ab0020130646522e53da35a149ad",
-    "eab6e532845dfd5dc2701ef90669a5f7b63e9539",
+    "aefe1a05104dab7c9a5c96ba1ca705aac2d7c693",
     "90deb2e2502186b3c62a58ec9b1c9d2b7b4089c1",
     "a4e451f76a77bbc3e224a41e9b4fa78cb841a8af",
     "084607a5c99a84140d93db57d1b0f3a0f51afdac",
@@ -440,7 +440,7 @@ static const char *sha1_graphics_24[] =
     "edbd7bab3d957fbc85e89612197cf918f5f5af20",
     "6a7efb3b6e0b49336df1bd2937ca09a11d976531",
     "236eb5ca9da70ec7cc719cd2fd291bab14000257",
-    "f98023c7cd8c068f2d7a77ce3600004b90ea12d6",
+    "a3eb1ece6c51500e82a2ea1d6a33cca46ae5ff46",
     "5c4cb9cea2226fc671bb4a11f8253343ee94bb4b",
     "fd4be592483623dbc800fe28210a1f0daa71999b",
     "788b8de98c47974fa9f232a6042ae4ca546ddb7d",
@@ -451,7 +451,7 @@ static const char *sha1_graphics_24[] =
     "0fa8cf332a56bb6d7e14e85861fdd60f51d70501",
     "593d694cdcc8349b3bfc8257041dbcb27e61da45",
     "1036b91d93e31cd1d4740d0c8642e115e5a38188",
-    "1898073cdb35ca4d2b21bba933ac16a0b4297317",
+    "b7c4548dad31005c92c8ac24c5387a6f7d6d0c3f",
     "5068bff794553cf5a3145ae407c9a2984357844c",
     "413a7989969c229dee4ab1798362f32f96cf0a10",
     "0bb222e540b82720d4971e4a2fc626899af03e03",
@@ -512,7 +512,7 @@ static const char *sha1_graphics_r5g5b5[] =
     "847005cf7371f511bcc837251cde07b1796f6113",
     "a8f75743a930843ec14d516cd048b6e0468e5d89",
     "d094f51ce9b9daa9c1d9594ea88be2a2db651459",
-    "cf3928e240c9149788e1635b115a4e5baea0dd8f",
+    "64092fae4a08576b3e3334f732036070e9942ab9",
     "a9034a905daa91757b4f63345c0e40638cd53ca8",
     "15ee915d989e49bb9bab5b834d8f355bd067cd8f",
     "99474fecf11df7b7035c35be6b8b697be9889418",
@@ -523,7 +523,7 @@ static const char *sha1_graphics_r5g5b5[] =
     "420e39ff3bdd04c4b6cc2c98e99cb7993c7a0de5",
     "1fabf0fdd046857b1974e31c1c1764fa9d1a762f",
     "449092689226a1172b6086ba1181d6b6d6499f26",
-    "1a92a60f190d33ef06d9decb56fd3fdd33f3af03",
+    "6ac53acaae75ecde90fb093a643defb5ee1a773d",
     "e61f5978c2e28c0c6d8f5eefe0f840c975586efc",
     "897d16f4d6a6ddad685d23ed7828d4f676539b75",
     "9d21bcfdeaf1ca5d47eb823bdefc24d7a95f4f56",
@@ -583,7 +583,7 @@ static const char *sha1_graphics_r4g4b4[] =
     "cfa0ab83ee93283ad914c3748f0532da1697af1d",
     "8bd18697d1ef27492805667a0bc956343ac08667",
     "e8501c830321584474654f90e40eaf27dc21e6a8",
-    "d95ab10fcfb8447b41742e89f1ae8cd297a32fc4",
+    "004da00e7d36aa719cba49447f1bb752b108e823",
     "821177710961d2cb5f7e7dfc0e06e767b6042753",
     "667124365ffadeea1d8791bedda77a0c7b898de8",
     "c9f23e684b600dea17575b4b17175fbd9106c3a9",
@@ -594,7 +594,7 @@ static const char *sha1_graphics_r4g4b4[] =
     "115a6bd382410a4a1d3c1fa71d8bf02536863e38",
     "65c6d1228e3b6d63d42647f14217bc1658b70d9a",
     "25fcb75aa687aac35b8f72640889fe92413e00c5",
-    "3bddf9d53e89560b083302b146cd33791b13d941",
+    "67773a67ff653c2539a192ed1326db046dbb55a2",
     "a81504498c7a7bb46340ce74476a42f70f2730b1",
     "e61a4f2657a444d8c49f84fb944f9f847667bf2b",
     "32b6e0aa79b7e96cd0ab2da167f6463c011023a8",
@@ -654,7 +654,7 @@ static const char *sha1_graphics_8_color[] =
     "e313bb57f699587b0bae2f17f5da5d977e6f2a61",
     "49024d6cbdf1614327dfda9eda17675e76805f7e",
     "63ba8ab7e7996857d52d4c2b995cfcd304daf25f",
-    "92295ae66712df050cfd6cc9fd2fd4101784c5fc",
+    "eed8cfd234683ef946c944f8adf4c12812ce6f85",
     "84d85009d35ae10abbc435f3913422544105cea2",
     "eae349c2a481d6e8bfdf9a7f4f49384a14716a5f",
     "6c51068ca1db36d948eaa34aed4a44d2cd1e8b32",
@@ -665,7 +665,7 @@ static const char *sha1_graphics_8_color[] =
     "108732d9909ee5f3542a9b90b3ad96ec82446ab9",
     "06c76c53dcf3ba5e213d483e27d841404c9aa90a",
     "ae8fcdbdd44ba58e9bd46a4c56eb54f37483913c",
-    "89711289be6d5c55734878410e4923d5cca9aca9",
+    "91c4edb9368242fafdb5659a763f5431540b1a6e",
     "8355caf57d51ad4e14275943088392e37dc75d33",
     "5992b2e331a0e0f752598cc8d083cbecb5f4dde6",
     "6f0570da9dea7f043f678088f8362ee458cd79fa",
@@ -725,7 +725,7 @@ static const char *sha1_graphics_8_grayscale[] =
     "df35491dd5038187c05bac06921402ba6d7773a8",
     "c8cd6d34e011d5f9ca4b1190eec3b416e5e68e53",
     "66a686ac22cd0ec326f2c97ef473781cabe9690b",
-    "9bddef7b97b8b03569f07011e66ddd67fe82d787",
+    "9b05996004d621dc61f40ff3045723121d5fff56",
     "2a4cea20974bcfb92cf40b05746fc7eb465c4b0f",
     "0a87689ca33f888f05dbfa21ddec11c069990d8b",
     "8d0a92e6333e1b99591962e2def9bc9121111cf5",
@@ -736,7 +736,7 @@ static const char *sha1_graphics_8_grayscale[] =
     "aa66ea7c9b7214339858b9fc9bd4720d05e8c843",
     "114bb377b4e78a1978e1ac09388c48861b5223a3",
     "8d0a92e6333e1b99591962e2def9bc9121111cf5",
-    "9dc511d6947fe816185cdff93bf0cfe0349b72b4",
+    "49a9b6883a8dde39779d97076900a27e16776e17",
     "216388ddf6b563dd2058a9df65b40b6f72df1715",
     "47f72be971bd2d3399dabd018201f4f5075e96fe",
     "f39ab890a2b99d0c31e6e047f2315244972f5ffd",
@@ -797,7 +797,7 @@ static const char *sha1_graphics_8[] =
     "512246d4886ab889a090b167ba194577cb95272e",
     "921e852d4564cb9e5ac15ff68b5207bebea871d1",
     "9636b0ebefc443ea11949ccd28f6ca454277dd41",
-    "aa9050da55e6b6957c60b7d603fce539cb5c0048",
+    "4a233bbc81f5f2252a02c2a969589e54c56498c1",
     "e2b93aca15fb1233ac09a713dced1f4cd950b1e4",
     "3e3a603fc26cc305aa27f88da7d2a3b0073877d8",
     "390b2bf70daba36310683f46af9cd50b9a061396",
@@ -808,7 +808,7 @@ static const char *sha1_graphics_8[] =
     "5ba8f99ca034666effa556748c49a0f5a015125f",
     "b67ba2f55659c75ac72c1112494461bb3086e1a4",
     "73e2859ce849f756f954718ce3c90f02e31712b6",
-    "b1dff0f5dd233b44ee568878c5d3f8ae1d80c6d9",
+    "e3a2a7790ed19c73c49d3cb1a7e1ca5704dac7e7",
     "1f27dc1a1316fb7a4a78fe40fcd4bdae3aaad218",
     "6e375e1485a1e45ac6ab10af49645d5fb2e76dff",
     "cfc67c325c7cdf96d90af9b3cceb8d0504cbb3b0",
@@ -868,7 +868,7 @@ static const char *sha1_graphics_4[] =
     "256d742b4da96b373b4fa5663d0ad3b5faab5c8e",
     "d96d8f4232b930bccd53b903b5efaf8c0bdb16f4",
     "9401799e6116c35e5f0e5bdca07ea25316757a72",
-    "482ae2b0ef1d64752b5ef11cc7f35a33eb55d07c",
+    "b7b31c5b983f3abeffbfe69d3ea81247894ce391",
     "dcfb3e01100b41c0f75a1c5f84b6de6b90138281",
     "2505598845fa026ea7187582461efbf06cb6904f",
     "3981a19363beca8f28d32a5928ac296fd22a5296",
@@ -879,7 +879,7 @@ static const char *sha1_graphics_4[] =
     "665bbbc749a5ffeedc0d62aef0661a5ce845b017",
     "1f26a01730f67d40ea711a50d9d801bac15a642e",
     "3b53d24178cfacba53103a44dfd5d072b15a6781",
-    "c52cfd57f26037723d37192722fc3a217f280c9e",
+    "e7616ed63c6864941d3c75cd67ac95f42fe2ab48",
     "e34da6500cf2e424d980714d92737cf6c31a7bda",
     "d17f4358ae529f920960ed89e535902ee13b0033",
     "0f44e12ecd1ea7e39433890443626d4fc35204a4",
@@ -939,7 +939,7 @@ static const char *sha1_graphics_4_grayscale[] =
     "6611ea6cb24bcf34c5f3688d57e2874aecb39c24",
     "5ab1d3f8f5938c5d20a2fa3237e319077b21e716",
     "1c201d149c0bd886ff8a427ad513f15a70991174",
-    "44646e67842a4d055bea1fad0434e6e4a0eb5465",
+    "2101954b2c2cc636f5d2e776de8c2e1d0d7ecabb",
     "315189097a02024d2eae61d524c4de07a396aee7",
     "73ac786015dea36ac466a6524dba757d5d238ece",
     "6e328cc4d53627f034b23706d8bf26afe18512ae",
@@ -950,7 +950,7 @@ static const char *sha1_graphics_4_grayscale[] =
     "7f1cb06597b14edbea03b860aec3cebc4ebc3d62",
     "ec3879342b5a44f6de6efe946243ae5ade00980d",
     "6e328cc4d53627f034b23706d8bf26afe18512ae",
-    "51b50968a3a0570d5ed690fe44ba1a78a4d62ce2",
+    "b309aee5780f96835a3f8f79df0464acbb131122",
     "d5bab61f78ac3355aa2e0776b2d5d9d71d61e77b",
     "fa47c5195405f6a0eefba3e3a60ad463c7ee94c7",
     "b2bda683edef912957845a33edc055902a801fed",
@@ -1010,7 +1010,7 @@ static const char *sha1_graphics_1[] =
     "61ade9054d4477fb89cf830539a5e8b4e45f0688",
     "ac530c5dbaf837e15b2337347e974184fad73643",
     "95fdcda26262d5948a9ade77d83fd698e0031050",
-    "1dd5cee06af78d026e5da8bfe3f45e1cf51faa13",
+    "f18dde3f44b4f6316dc184bbab5a3404a508bf23",
     "f6b61ecf03ad11752775faca1d4404c6bb5065f5",
     "d7ad44d6f377598268e9968333ae2cf23a0715ca",
     "5871339cd7e6cee12d4dc45934a89071c73efe6b",
@@ -1021,7 +1021,7 @@ static const char *sha1_graphics_1[] =
     "4c686508a994ca4c7a0a73b8c0fe52423c180d9c",
     "b0cc1f5e244ae0c0835a9866a46abdfcd56d1cb1",
     "7ddf19df5bbdf4475b6ec1bc042425e382502864",
-    "144c9a846e5e37ac6efd5ed3a97ec231479e8fca",
+    "8edd1609010d5d60ee00730f3677767105804827",
     "400a21caa01e015096ee1afcf1b54e7f8ec515bd",
     "144c9a846e5e37ac6efd5ed3a97ec231479e8fca",
     "a4964d8bbf80fe785f906bc0f7c5b113242a58fc",
@@ -1083,8 +1083,8 @@ static const char *sha1_graphics_1_ddb[] =
     "ff18f1f84bf1e9c83cedacadba4c10cfd5aaec1e",
     "cc54ff65557b63ed2ffd31af2013e5b9f06f18a6",
     "4325e5d95e1fd395c3bdff4559871aa3bd9d46bc",
-    "4d37b727337f642c71ab962a34ce1dbea638bd55",
-    "8e5c8e6006a11e516b1cf23bdd1d5ba4ff9fd0db",
+    "57cb45c2015687e06401e602b15c8a2aabd0d5b0",
+    "ea1b42368eb9e2c5417987ff40277db50b1a90f8",
     "34c609751431850b92af2ace6c39a69704af2ab9",
     "42cca4bd7471bfdad39b588cb376a8c79226e028",
     "9995abea51677434c840082221520116db3586cc",
@@ -1096,7 +1096,7 @@ static const char *sha1_graphics_1_ddb[] =
     "3f12111d820af648e4b3c2d2bbfbf7862049619f",
     "0e8f567f7dda687840c656be4ddee2647e39cf77",
     "baaef56da8622dd15bb69121cac97a8dc014f1a5",
-    "816e21e1185367ccd6e8e0e6ee16f93e6300b7fb",
+    "986b4609ebe8aa880c701f801246418c873b02c7",
     "86417cc40c76c2258614ce81490795dff20025d6",
     "816e21e1185367ccd6e8e0e6ee16f93e6300b7fb",
     "dd95e98da4fd06d9969e04cc4fcfd6df67296c7d",
@@ -1176,8 +1176,8 @@ static const char *sha1_graphics_1_ddb_inverted[] =
     "ee903dd1611aa68a41f5b46e9ebd2511da36ea32",
     "d8d2f298610311b3d49e03bd3b0ea7f2511a139d",
     "1cb1a544bf6e19780626c02c34756d259a50a77e",
-    "4d37b727337f642c71ab962a34ce1dbea638bd55",
-    "5de18a789a8ecc4ec53ecfe521a8a8294b19113d",
+    "679502d28952f4e7d04f9355ba09053e4de93a87",
+    "ea1b42368eb9e2c5417987ff40277db50b1a90f8",
     "fda1709b9b23e5294fff73e6764f29960ccc1eee",
     "babf8cc5cce61e2da52b1cd1a151c45774aa35d7",
     "c9005d98a9a5890f5b74dca436068e58a31db44d",
@@ -1189,7 +1189,7 @@ static const char *sha1_graphics_1_ddb_inverted[] =
     "3f12111d820af648e4b3c2d2bbfbf7862049619f",
     "0e8f567f7dda687840c656be4ddee2647e39cf77",
     "baaef56da8622dd15bb69121cac97a8dc014f1a5",
-    "816e21e1185367ccd6e8e0e6ee16f93e6300b7fb",
+    "986b4609ebe8aa880c701f801246418c873b02c7",
     "86417cc40c76c2258614ce81490795dff20025d6",
     "816e21e1185367ccd6e8e0e6ee16f93e6300b7fb",
     "dd95e98da4fd06d9969e04cc4fcfd6df67296c7d",
@@ -1269,7 +1269,7 @@ static const RECT graphics_bounds[] =
     { 10, 3, 219, 101 },
     { 100, 100, 301, 301 },
     { 0, 0, 201, 201 },
-    { 10, 10, 110, 320 },
+    { 10, 10, 210, 320 },
     { 10, 99, 300, 200 },
     { 99, 12, 201, 200 },
     { 90, 110, 300, 200 },
@@ -1280,7 +1280,7 @@ static const RECT graphics_bounds[] =
     { 99, 11, 201, 200 },
     { 90, 110, 300, 200 },
     { 90, 110, 300, 200 },
-    { 10, 10, 365, 405 },
+    { 10, 10, 465, 405 },
     { 10, 10, 365, 405 },
     { 10, 10, 365, 405 },
     { 10, 10, 365, 405 },
@@ -1840,6 +1840,18 @@ static void draw_graphics(HDC hdc, const BITMAPINFO *bmi, BYTE *bits)
         }
 
     }
+    for(i=0, y=20; i < 256; i++)
+    {
+        ret = PatBlt(hdc, 210, y, -100, -10, rop3[i]);
+
+        if(rop_uses_src(rop3[i]))
+            ok(ret == FALSE || broken(is_ddb), "got TRUE for %lx\n", rop3[i]);
+        else
+        {
+            ok(ret, "got FALSE for %lx\n", rop3[i]);
+            y += 20;
+        }
+    }
     compare_hash_broken_todo(hdc, bmi, bits, "solid patblt", is_ddb, is_ddb);
 
     /* clipped lines */
@@ -1956,6 +1968,8 @@ static void draw_graphics(HDC hdc, const BITMAPINFO *bmi, BYTE *bits)
         {
             ret = PatBlt(hdc, 10 + i, y, 100, 20, rop3[i]);
             ok(ret, "got FALSE for %lx\n", rop3[i]);
+            ret = PatBlt(hdc, 210 + i, y + 20, -100, -20, rop3[i]);
+            ok(ret, "got FALSE for %lx\n", rop3[i]);
             y += 25;
         }
     }

diff --git a/dlls/win32u/bitblt.c b/dlls/win32u/bitblt.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/bitblt.c
+++ b/dlls/win32u/bitblt.c
@@ -543,6 +543,17 @@ BOOL WINAPI NtGdiPatBlt( HDC hdc, INT left, INT top, INT width, INT height, DWOR
 
         update_dc( dc );
 
+        if (width < 0)
+        {
+            left += width;
+            width = -width;
+        }
+        if (height < 0)
+        {
+            top += height;
+            height = -height;
+        }
+
         dst.log_x      = left;
         dst.log_y      = top;
         dst.log_width  = width;
From: "Jiangyi Chen" <cjy520lcy@163.com>
Subject: [PATCH] win32u: Add match for second_name.
Message-Id: <2dae835a.4417.179456d7c7c.Coremail.cjy520lcy@163.com>
Date: Fri, 7 May 2021 14:04:33 +0800 (CST)

From c96631bc19deeb2465d9ffba4beaacfa0fe9e871 Mon Sep 17 00:00:00 2001
From: Jiangyi Chen <chenjiangyi@uniontech.com>
Date: Fri, 7 May 2021 14:01:13 +0800
#Subject: [PATCH] win32u: Add match for second_name. eg: there is a substituting
  MS Shell Dlg -> SimSun .the first parameter of GdipCreateFontFamilyFromName
 is MS Shell Dlg,then second_name is needed to find SimSun.Otherwise, it may
 cause GdipDrawString to crash indirectly.

Signed-off-by: Jiangyi Chen <chenjiangyi@uniontech.com>
---
 dlls/win32u/font.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -3056,6 +3056,7 @@ static BOOL family_matches( struct gdi_font_family *family, const WCHAR *face_na
     struct gdi_font_face *face;
 
     if (!facename_compare( face_name, family->family_name, LF_FACESIZE - 1 )) return TRUE;
+    if (!facename_compare( face_name, family->second_name, LF_FACESIZE - 1 )) return TRUE;
     LIST_FOR_EACH_ENTRY( face, get_family_face_list(family), struct gdi_font_face, entry )
         if (!facename_compare( face_name, face->full_name, LF_FACESIZE - 1 )) return TRUE;
     return FALSE;
@@ -3165,7 +3166,7 @@ static BOOL CDECL font_EnumFonts( PHYSDEV dev, LOGFONTW *lf, FONTENUMPROCW proc,
             if (!family_matches(family, face_name)) continue;
             LIST_FOR_EACH_ENTRY( face, get_family_face_list(family), struct gdi_font_face, entry )
             {
-                if (!face_matches( family->family_name, face, face_name )) continue;
+                if (!face_matches( family->family_name, face, face_name ) && !face_matches( family->second_name, face, face_name )) continue;
                 if (!enum_face_charsets( family, face, enum_charsets, count, proc, lparam, orig_name ))
                     return FALSE;
 	    }

-- 
2.37.2

From: Chao Long <longchao@uniontech.com>
Subject: [PATCH] win32u: fix freetype crash.
Message-Id: <20211008052521.17067-1-longchao@uniontech.com>
Date: Fri,  8 Oct 2021 13:25:21 +0800

Signed-off-by: Chao Long <longchao@uniontech.com>
---
 dlls/win32u/freetype.c | 39 ++++++++++++++++++++++++++-------------
 1 file changed, 26 insertions(+), 13 deletions(-)

diff --git a/dlls/win32u/freetype.c b/dlls/win32u/freetype.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/freetype.c
+++ b/dlls/win32u/freetype.c
@@ -2441,6 +2441,7 @@ static BOOL freetype_load_font( struct gdi_font *font )
 
     if (pFT_New_Memory_Face( library, data_ptr, data_size, font->face_index, &ft_face )) return FALSE;
 
+    TRACE("face: %p, charmaps count: %d\n", ft_face, ft_face->num_charmaps);
     data->ft_face = ft_face;
     font->scalable = FT_IS_SCALABLE( ft_face );
     if (!font->fs.fsCsb[0]) get_fontsig( ft_face, &font->fs );
@@ -2543,20 +2544,24 @@ static BOOL freetype_get_glyph_index( struct gdi_font *font, UINT *glyph, BOOL u
 {
     FT_Face ft_face = get_ft_face( font );
 
-    if (!use_encoding ^ (ft_face->charmap->encoding == FT_ENCODING_NONE)) return FALSE;
-
-    if (ft_face->charmap->encoding == FT_ENCODING_MS_SYMBOL)
+    TRACE("face: %p, charmaps count: %d\n", ft_face, ft_face->num_charmaps);
+    if (ft_face->num_charmaps > 0)
     {
-        if (!(*glyph = get_glyph_index_symbol( font, *glyph )))
+        if (!use_encoding ^ (ft_face->charmap->encoding == FT_ENCODING_NONE)) return FALSE;
+
+        if (ft_face->charmap->encoding == FT_ENCODING_MS_SYMBOL)
         {
-            WCHAR wc = *glyph;
-            DWORD len;
-            char ch;
+            if (!(*glyph = get_glyph_index_symbol( font, *glyph )))
+            {
+                WCHAR wc = *glyph;
+                DWORD len;
+                char ch;
 
-            len = win32u_wctomb( &ansi_cp, &ch, 1, &wc, 1 );
-            if (len) *glyph = get_glyph_index_symbol( font, (unsigned char)ch );
+                len = win32u_wctomb( &ansi_cp, &ch, 1, &wc, 1 );
+                if (len) *glyph = get_glyph_index_symbol( font, (unsigned char)ch );
+            }
+            return TRUE;
         }
-        return TRUE;
     }
     *glyph = pFT_Get_Char_Index( ft_face, *glyph );
     return TRUE;
@@ -3980,6 +3985,9 @@ static DWORD freetype_get_unicode_ranges( struct gdi_font *font, GLYPHSET *gs )
     FT_Face ft_face = get_ft_face( font );
     DWORD num_ranges = 0;
 
+    if (ft_face->num_charmaps <= 0)
+        return num_ranges;
+
     if (ft_face->charmap->encoding == FT_ENCODING_UNICODE)
     {
         FT_UInt glyph_code;
@@ -4165,7 +4173,7 @@ static DWORD freetype_get_kerning_pairs( struct gdi_font *font, KERNINGPAIR **pa
         return 0;
     }
 
-    if (ft_face->charmap->encoding == FT_ENCODING_UNICODE)
+    if (ft_face->num_charmaps > 0 && ft_face->charmap->encoding == FT_ENCODING_UNICODE)
     {
         FT_UInt glyph_code;
         FT_ULong char_code;
@@ -4192,10 +4200,15 @@ static DWORD freetype_get_kerning_pairs( struct gdi_font *font, KERNINGPAIR **pa
     }
     else
     {
-        DWORD encoding = RtlUlongByteSwap(ft_face->charmap->encoding);
         ULONG n;
 
-        FIXME("encoding %s not supported\n", debugstr_an((char *)&encoding, 4));
+        if (ft_face->num_charmaps > 0)
+        {
+            DWORD encoding = RtlUlongByteSwap(ft_face->charmap->encoding);
+
+            FIXME("encoding %s not supported\n", debugstr_an((char *)&encoding, 4));
+        }
+
         for (n = 0; n <= 65535; n++)
             glyph_to_char[n] = (USHORT)n;
     }

-- 
2.37.2

From: Oleh Nykyforchyn <oleh.nyk@gmail.com>
Subject: [PATCH] gdi32: Accept 16-bit handles in get_dc_attr().
Message-Id: <20211023073459.25299-1-olen.nyk@gmail.com>
Date: Sat, 23 Oct 2021 10:34:58 +0300

When background is erased in a 16 bit app, a handle to DC is passed
through USER16 functions, namely CallWindowProc16 (USER.122) and
DefDriverProc16 (USER.255), whose respective parameters are of type
WPARAM16, hence the upper part of the handle is cut. Later
the returned handle is rejected by get_dc_attr() in GDI32 because
its type is 0, although such handles are accepted by handle_entry().
This results in black and not cleared background.  Allowing type==0
in get_dc_attr() solves the problem.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=51899
Signed-off-by: Oleh Nykyforchyn <oleh.nyk@gmail.com>
---
 dlls/gdi32/dc.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/gdi32/dc.c b/dlls/gdi32/dc.c
index 11111111111..11111111111 100644
--- a/dlls/gdi32/dc.c
+++ b/dlls/gdi32/dc.c
@@ -56,7 +56,7 @@ DC_ATTR *get_dc_attr( HDC hdc )
 {
     DWORD type = gdi_handle_type( hdc );
     DC_ATTR *dc_attr;
-    if ((type & 0x1f0000) != NTGDI_OBJ_DC || !(dc_attr = get_gdi_client_ptr( hdc, 0 )))
+    if ((type && (type & 0x1f0000) != NTGDI_OBJ_DC) || !(dc_attr = get_gdi_client_ptr( hdc, 0 )))
     {
         SetLastError( ERROR_INVALID_HANDLE );
         return NULL;

-- 
2.37.2

From: Akihiro Sagawa <sagawa.aki@gmail.com>
Subject: [PATCH resend] win32u: Make elfFullName from family name in the font replacement.
Message-Id: <20211118224937.1F2A.375B48EC@gmail.com>
Date: Thu, 18 Nov 2021 22:49:53 +0900


The original Kusanagi code, commit eab02574929d, was implemented in this way.
However, commit abc8f2c6c270 and f360057e2f99 made it from face->full_name.

Signed-off-by: Akihiro Sagawa <sagawa.aki@gmail.com>
---
 dlls/win32u/font.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -3097,7 +3097,14 @@ static BOOL enum_face_charsets( const struct gdi_font_family *family, struct gdi
     if (family != face->family)
     {
         lstrcpynW( elf.elfLogFont.lfFaceName, family->family_name, LF_FACESIZE );
-        lstrcpynW( elf.elfFullName, face->full_name, LF_FULLFACESIZE );
+        lstrcpynW( elf.elfFullName, family->family_name, LF_FULLFACESIZE );
+        if (!(face->ntmFlags & NTM_REGULAR) &&
+            lstrlenW( elf.elfFullName ) + lstrlenW( face->style_name ) + 1 < LF_FULLFACESIZE)
+        {
+            static const WCHAR spaceW[] = {' ',0};
+            lstrcatW( elf.elfFullName, spaceW );
+            lstrcatW( elf.elfFullName, face->style_name );
+        }
     }
     if (subst) lstrcpynW( elf.elfLogFont.lfFaceName, subst, LF_FACESIZE );
 

From: Konstantin Romanov <incubusrk@gmail.com>
Subject: [PATCH] gdiplus: Handle NULL elementdata.combine.left/right in delete_element
Message-Id: <20220120055826.666-1-incubusrk@gmail.com>
Date: Thu, 20 Jan 2022 08:58:26 +0300

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52423

Signed-off-by: Konstantin Romanov <incubusrk@gmail.com>
---
 dlls/gdiplus/gdiplus.c | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/dlls/gdiplus/gdiplus.c b/dlls/gdiplus/gdiplus.c
index 11111111111..11111111111 100644
--- a/dlls/gdiplus/gdiplus.c
+++ b/dlls/gdiplus/gdiplus.c
@@ -473,10 +473,14 @@ void delete_element(region_element* element)
         case RegionDataInfiniteRect:
             break;
         default:
-            delete_element(element->elementdata.combine.left);
-            delete_element(element->elementdata.combine.right);
-            heap_free(element->elementdata.combine.left);
-            heap_free(element->elementdata.combine.right);
+            if(element->elementdata.combine.left){
+                delete_element(element->elementdata.combine.left);
+                heap_free(element->elementdata.combine.left);
+            }
+            if(element->elementdata.combine.right){
+                delete_element(element->elementdata.combine.right);
+                heap_free(element->elementdata.combine.right);
+            }
             break;
     }
 }

-- 
2.37.2

From 55efb8b4cea3ccb1d5c7db2c70df5676506e7132 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bernhard=20K=C3=B6lbl?= <besentv@gmail.com>
Date: Sun, 12 Dec 2021 22:24:44 +0100
Subject: [PATCH 1/2] gdiplus: Improve performance of alpha_blend_bmp_pixels().
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Bernhard Kölbl <besentv@gmail.com>
---
 dlls/gdiplus/gdiplus_private.h |   3 +
 dlls/gdiplus/graphics.c        |  41 ----------
 dlls/gdiplus/image.c           | 137 +++++++++++++++++++++++++++++++++
 3 files changed, 140 insertions(+), 41 deletions(-)

diff --git a/dlls/gdiplus/gdiplus_private.h b/dlls/gdiplus/gdiplus_private.h
index 11111111111..11111111111 100644
--- a/dlls/gdiplus/gdiplus_private.h
+++ b/dlls/gdiplus/gdiplus_private.h
@@ -210,6 +210,9 @@ extern GpStatus convert_pixels(INT width, INT height,
     INT dst_stride, BYTE *dst_bits, PixelFormat dst_format, ColorPalette *dst_palette,
     INT src_stride, const BYTE *src_bits, PixelFormat src_format, ColorPalette *src_palette) DECLSPEC_HIDDEN;
 
+extern GpStatus alpha_blend_bmp_pixels(GpGraphics *graphics, INT dst_x, INT dst_y,
+    const BYTE *src, INT src_width, INT src_height, INT src_stride, const PixelFormat fmt) DECLSPEC_HIDDEN;
+
 extern PixelFormat apply_image_attributes(const GpImageAttributes *attributes, LPBYTE data,
     UINT width, UINT height, INT stride, ColorAdjustType type, PixelFormat fmt) DECLSPEC_HIDDEN;
 
diff --git a/dlls/gdiplus/graphics.c b/dlls/gdiplus/graphics.c
index 11111111111..11111111111 100644
--- a/dlls/gdiplus/graphics.c
+++ b/dlls/gdiplus/graphics.c
@@ -412,45 +412,6 @@ static GpStatus get_clip_hrgn(GpGraphics
     return stat;
 }
 
-/* Draw ARGB data to the given graphics object */
-static GpStatus alpha_blend_bmp_pixels(GpGraphics *graphics, INT dst_x, INT dst_y,
-    const BYTE *src, INT src_width, INT src_height, INT src_stride, const PixelFormat fmt)
-{
-    GpBitmap *dst_bitmap = (GpBitmap*)graphics->image;
-    INT x, y;
-    CompositingMode comp_mode = graphics->compmode;
-
-    for (y=0; y<src_height; y++)
-    {
-        for (x=0; x<src_width; x++)
-        {
-            ARGB dst_color, src_color;
-            src_color = ((ARGB*)(src + src_stride * y))[x];
-
-            if (comp_mode == CompositingModeSourceCopy)
-            {
-                if (!(src_color & 0xff000000))
-                    GdipBitmapSetPixel(dst_bitmap, x+dst_x, y+dst_y, 0);
-                else
-                    GdipBitmapSetPixel(dst_bitmap, x+dst_x, y+dst_y, src_color);
-            }
-            else
-            {
-                if (!(src_color & 0xff000000))
-                    continue;
-
-                GdipBitmapGetPixel(dst_bitmap, x+dst_x, y+dst_y, &dst_color);
-                if (fmt & PixelFormatPAlpha)
-                    GdipBitmapSetPixel(dst_bitmap, x+dst_x, y+dst_y, color_over_fgpremult(dst_color, src_color));
-                else
-                    GdipBitmapSetPixel(dst_bitmap, x+dst_x, y+dst_y, color_over(dst_color, src_color));
-            }
-        }
-    }
-
-    return Ok;
-}
-
 static GpStatus alpha_blend_hdc_pixels(GpGraphics *graphics, INT dst_x, INT dst_y,
     const BYTE *src, INT src_width, INT src_height, INT src_stride, PixelFormat fmt)
 {
diff --git a/dlls/gdiplus/image.c b/dlls/gdiplus/image.c
index 11111111111..11111111111 100644
--- a/dlls/gdiplus/image.c
+++ b/dlls/gdiplus/image.c
@@ -1079,6 +1079,143 @@ GpStatus convert_pixels(INT width, INT height,
     return NotImplemented;
 }
 
+/* Draw ARGB data to the given graphics object */
+GpStatus alpha_blend_bmp_pixels(GpGraphics *graphics, INT dst_x, INT dst_y,
+    const BYTE *src, INT src_width, INT src_height, INT src_stride, const PixelFormat fmt)
+{
+    GpBitmap *dst_bitmap = (GpBitmap*)graphics->image;
+    INT x, y;
+    CompositingMode comp_mode;
+
+#define blend_indexed(getpixel_function, setpixel_function) do { \
+    for (y=0; y<src_height; y++) \
+    { \
+        BYTE *row; \
+        row = dst_bitmap->bits+dst_bitmap->stride*(y+dst_y); \
+        for (x=0; x<src_width; x++) \
+        { \
+            BYTE index; \
+            ARGB dst_color, src_color; \
+            src_color = ((ARGB*)(src + src_stride * y))[x]; \
+            \
+            if (comp_mode == CompositingModeSourceCopy) \
+            { \
+                if (!(src_color & 0xff000000)) \
+                    setpixel_function( 0x00, 0x00, 0x00, 0x00, row , x+dst_x, dst_bitmap->image.palette); \
+                else \
+                    setpixel_function(src_color>>16, src_color>>8, src_color, src_color>>24, row , x+dst_x, dst_bitmap->image.palette); \
+            } \
+            else \
+            { \
+                if (!(src_color & 0xff000000)) \
+                    continue; \
+                \
+                getpixel_function(&index, row, x+dst_x); \
+                dst_color = dst_bitmap->image.palette->Entries[index]; \
+                if (fmt & PixelFormatPAlpha) \
+                    dst_color = color_over_fgpremult(dst_color, src_color); \
+                else \
+                    dst_color = color_over(dst_color, src_color); \
+                setpixel_function(dst_color>>16, dst_color>>8, dst_color, dst_color>>24, row , x+dst_x, dst_bitmap->image.palette); \
+            } \
+        } \
+    } \
+} \
+while(0)\
+
+#define blend_rgb(getpixel_function, setpixel_function) do { \
+    for (y=0; y<src_height; y++) \
+    { \
+        BYTE *row; \
+        row = dst_bitmap->bits+dst_bitmap->stride*(y+dst_y); \
+        for (x=0; x<src_width; x++) \
+        { \
+            BYTE r, g, b, a; \
+            ARGB dst_color, src_color; \
+            src_color = ((ARGB*)(src + src_stride * y))[x]; \
+            \
+            if (comp_mode == CompositingModeSourceCopy) \
+            { \
+                if (!(src_color & 0xff000000)) \
+                    setpixel_function(0x00, 0x00, 0x00, 0x00, row, x+dst_x); \
+                else \
+                    setpixel_function(src_color>>16, src_color>>8, src_color, src_color>>24, row, x+dst_x); \
+            } \
+            else \
+            { \
+                if (!(src_color & 0xff000000)) \
+                    continue; \
+                \
+                getpixel_function(&r, &g, &b, &a, row, x+dst_x); \
+                dst_color = a<<24|r<<16|g<<8|b; \
+                if (fmt & PixelFormatPAlpha) \
+                    dst_color = color_over_fgpremult(dst_color, src_color); \
+                else \
+                    dst_color = color_over(dst_color, src_color); \
+                setpixel_function(dst_color>>16, dst_color>>8, dst_color, dst_color>>24, row, x+dst_x); \
+            } \
+        } \
+    } \
+} \
+while(0)\
+
+    GdipGetCompositingMode(graphics, &comp_mode);
+
+    switch (dst_bitmap->format)
+    {
+        case PixelFormat1bppIndexed:
+            blend_indexed(getpixel_1bppIndexed, setpixel_1bppIndexed);
+            break;
+        case PixelFormat4bppIndexed:
+            blend_indexed(getpixel_1bppIndexed, setpixel_4bppIndexed);
+            break;
+        case PixelFormat8bppIndexed:
+            blend_indexed(getpixel_1bppIndexed, setpixel_8bppIndexed);
+            break;
+        case PixelFormat16bppGrayScale:
+            blend_rgb(getpixel_16bppGrayScale, setpixel_16bppGrayScale);
+            break;
+        case PixelFormat16bppRGB555:
+            blend_rgb(getpixel_16bppRGB555, setpixel_16bppRGB555);
+            break;
+        case PixelFormat16bppRGB565:
+            blend_rgb(getpixel_16bppRGB565, setpixel_16bppRGB565);
+            break;
+        case PixelFormat16bppARGB1555:
+            blend_rgb(getpixel_16bppARGB1555, setpixel_16bppARGB1555);
+            break;
+        case PixelFormat24bppRGB:
+            blend_rgb(getpixel_24bppRGB, setpixel_24bppRGB);
+            break;
+        case PixelFormat32bppRGB:
+            blend_rgb(getpixel_32bppRGB, setpixel_32bppRGB);
+            break;
+        case PixelFormat32bppARGB:
+            blend_rgb(getpixel_32bppARGB, setpixel_32bppARGB);
+            break;
+        case PixelFormat32bppPARGB:
+            blend_rgb(getpixel_32bppPARGB, setpixel_32bppPARGB);
+            break;
+        case PixelFormat48bppRGB:
+            blend_rgb(getpixel_48bppRGB, setpixel_48bppRGB);
+            break;
+        case PixelFormat64bppARGB:
+            blend_rgb(getpixel_64bppARGB, setpixel_64bppARGB);
+            break;
+        case PixelFormat64bppPARGB:
+            blend_rgb(getpixel_64bppPARGB, setpixel_64bppPARGB);
+            break;
+        default:
+            FIXME("not implemented for format 0x%x\n", dst_bitmap->format);
+            return NotImplemented;
+    }
+
+#undef blend_indexed
+#undef blend_rgb
+
+    return Ok;
+}
+
 /* This function returns a pointer to an array of pixels that represents the
  * bitmap. The *entire* bitmap is locked according to the lock mode specified by
  * flags.  It is correct behavior that a user who calls this function with write
-- 
2.37.2

From: Robert Feuerbach <rjfeuerbach@gmail.com>
Subject: [PATCH 1/2] gdiplus/tests: New path that can cause stack overflow in GdipFlattenPath.
Message-Id: <20220204155848.28870-1-rjfeuerbach@gmail.com>
Date: Fri,  4 Feb 2022 10:58:47 -0500

A bezier curve found in an application has caused endless recursive
calls to flatten_bezier due to float point precision limitations in
the flatness test.  This curve has been added to the graphicpath.c
test to check for the resulting stack overflow error.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52492
Signed-off-by: Robert Feuerbach <rjfeuerbach@gmail.com>
---
 dlls/gdiplus/tests/graphicspath.c | 55 ++++++++++++++++++++++++++++++-
 1 file changed, 54 insertions(+), 1 deletion(-)

diff --git a/dlls/gdiplus/tests/graphicspath.c b/dlls/gdiplus/tests/graphicspath.c
index 11111111111..11111111111 100644
--- a/dlls/gdiplus/tests/graphicspath.c
+++ b/dlls/gdiplus/tests/graphicspath.c
@@ -1253,6 +1253,58 @@ static void test_flatten(void)
     GdipDeletePath(path);
 }
 
+static void test_flatten2(void)
+{
+    GpStatus status;
+    GpPath *path;
+    INT count;
+    
+    status = GdipCreatePath(0, &path);
+    expect(Ok, status);
+    status = GdipStartPathFigure(path);
+    expect(Ok, status);
+    /* path seen in the wild that caused a stack overflow */
+    /* low-precision points that can cause a crash */
+    status = GdipAddPathBezier(path,
+			       154.950806, 33.391144,
+			       221.586075, 15.536285,
+			       291.747314, 15.536285,
+			       358.382568, 33.391144);
+    expect(Ok, status);
+    status = GdipAddPathBezier(path,
+			       256.666809, 412.999512,
+			       256.666718, 412.999481,
+			       256.666656, 412.999481,
+			       256.666565, 412.999512);
+    expect(Ok, status);
+    status = GdipClosePathFigure(path);
+    expect(Ok, status);
+    trace("Flattening good and problematic bezier curves\n");
+    status = GdipFlattenPath(path, NULL, 1.0);
+
+    /* now redo with hexadecimal floats to replicate the points exactly */
+    status = GdipResetPath(path);
+    expect(Ok, status);
+    status = GdipAddPathBezier(path,
+			       0x1.35e6d00000000p+7, 0x1.0b21100000000p+5,
+			       0x1.bb2c120000000p+7, 0x1.f129400000000p+3,
+			       0x1.23bf500000000p+8, 0x1.f129400000000p+3,
+			       0x1.6661f00000000p+8, 0x1.0b21100000000p+5);
+    expect(Ok, status);
+    status = GdipAddPathBezier(path,
+			       0x1.00aab40000000p+8, 0x1.9cffe00000000p+8,
+			       0x1.00aaae0000000p+8, 0x1.9cffde0000000p+8,
+			       0x1.00aaaa0000000p+8, 0x1.9cffde0000000p+8,
+			       0x1.00aaa40000000p+8, 0x1.9cffe00000000p+8);
+    expect(Ok, status);
+    status = GdipClosePathFigure(path);
+    expect(Ok, status);
+    trace("Flattening precise copied problematic curves\n");
+    status = GdipFlattenPath(path, NULL, 1.0);
+    
+    GdipDeletePath(path);
+}
+
 static path_test_t widenline_path[] = {
     {5.0, 5.0,   PathPointTypeStart, 0, 0}, /*0*/
     {50.0, 5.0,  PathPointTypeLine,  0, 0}, /*1*/
@@ -1900,6 +1952,7 @@ START_TEST(graphicspath)
     test_widen_cap();
     test_isvisible();
     test_empty_rect();
-
+    test_flatten2();
+    
     GdiplusShutdown(gdiplusToken);
 }

-- 
2.37.2

From: Robert Feuerbach <rjfeuerbach@gmail.com>
Subject: [PATCH 2/2] gdiplus: Revise closeness check for bezier curve flattening.
Message-Id: <20220204155848.28870-2-rjfeuerbach@gmail.com>
Date: Fri,  4 Feb 2022 10:58:48 -0500
In-Reply-To: <20220204155848.28870-1-rjfeuerbach@gmail.com>
References: <20220204155848.28870-1-rjfeuerbach@gmail.com>

The float equality and flatness calculation in flatten_bezier
can fail due to the limited precision of the float math.
The equality test was replaced with a simple check against
the given flatness tolerance.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=52492
Signed-off-by: Robert Feuerbach <rjfeuerbach@gmail.com>
---
 dlls/gdiplus/graphicspath.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/dlls/gdiplus/graphicspath.c b/dlls/gdiplus/graphicspath.c
index 11111111111..11111111111 100644
--- a/dlls/gdiplus/graphicspath.c
+++ b/dlls/gdiplus/graphicspath.c
@@ -109,7 +109,7 @@ static INT path_list_count(path_list_node_t *node)
  *  - (x2, y2): first control point;
  *  - (x3, y3): second control point;
  *  - end     : pointer to end point node
- *  - flatness: admissible error of linear approximation.
+ *  - flatness: admissible error of linear approximation in coordinate units.
  *
  * Return value:
  *  TRUE : success
@@ -142,12 +142,13 @@ static BOOL flatten_bezier(path_list_node_t *start, REAL x2, REAL y2, REAL x3, R
     mp[2].X = (mp[1].X + mp[3].X) / 2.0;
     mp[2].Y = (mp[1].Y + mp[3].Y) / 2.0;
 
-    if ((x2 == mp[0].X && y2 == mp[0].Y && x3 == mp[1].X && y3 == mp[1].Y) ||
-        (x2 == mp[3].X && y2 == mp[3].Y && x3 == mp[4].X && y3 == mp[4].Y))
-        return TRUE;
-
     pt = end->pt;
     pt_st = start->pt;
+    /* test for closely spaced points to avoid limited-precision errors in flatness check */
+    if((fabs(pt.X - mp[2].X) + fabs(pt.Y - mp[2].Y) +
+        fabs(pt_st.X - mp[2].X) + fabs(pt_st.Y - mp[2].Y) ) <= flatness)
+        return TRUE;
+
     /* check flatness as a half of distance between middle point and a linearized path */
     if(fabs(((pt.Y - pt_st.Y)*mp[2].X + (pt_st.X - pt.X)*mp[2].Y +
         (pt_st.Y*pt.X - pt_st.X*pt.Y))) <=

-- 
2.37.2

From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Subject: [PATCH 1/4] win32u: Add freelist cache allocator.
Message-Id: <7303da75-56e4-7139-34ce-b90da9eccc03@gmail.com>
Date: Mon, 21 Mar 2022 05:41:48 +0900

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/win32u/Makefile.in     |   1 +
 dlls/win32u/alloc.c         | 173 ++++++++++++++++++++++++++++++++++++
 dlls/win32u/ntgdi_private.h |   4 +
 3 files changed, 178 insertions(+)
 create mode 100644 dlls/win32u/alloc.c

diff --git a/dlls/win32u/Makefile.in b/dlls/win32u/Makefile.in
index 11111111111..11111111111 100644
--- a/dlls/win32u/Makefile.in
+++ b/dlls/win32u/Makefile.in
@@ -9,6 +9,7 @@ UNIX_LIBS    = $(CARBON_LIBS) $(APPKIT_LIBS) $(PTHREAD_LIBS) -lm
 EXTRADLLFLAGS = -nodefaultlibs -Wb,--syscall-table,1
 
 C_SRCS = \
+	alloc.c \
 	bitblt.c \
 	bitmap.c \
 	brush.c \
diff --git a/dlls/win32u/alloc.c b/dlls/win32u/alloc.c
new file mode 100644
index 00000000000..11111111111
--- /dev/null
+++ b/dlls/win32u/alloc.c
@@ -0,0 +1,173 @@
+/*
+ * simple freelist cache allocator
+ *
+ * Copyright 2022 Jinoh Kang
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <pthread.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wingdi.h"
+#include "ntgdi_private.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(gdi);
+
+
+#define MEM_CACHE_NR_BUCKETS 1024
+#define MEM_CACHE_MIN_SIZE 16384
+#define MEM_CACHE_STEP 4096
+#ifdef _WIN64
+#define MEM_CACHE_THRESHOLD (32UL << 20)  /* 32MB */
+#else
+#define MEM_CACHE_THRESHOLD ( 8UL << 20)   /* 8MB */
+#endif
+
+static pthread_mutex_t mem_cache_lock = PTHREAD_MUTEX_INITIALIZER;
+static void **mem_cache_buckets[MEM_CACHE_NR_BUCKETS];
+static SIZE_T mem_cache_total_size;
+
+static SIZE_T get_bucket_index( SIZE_T size )
+{
+    if (size < MEM_CACHE_MIN_SIZE) return (SIZE_T)-1;
+    return (size - MEM_CACHE_MIN_SIZE + MEM_CACHE_STEP - 1) / MEM_CACHE_STEP;
+}
+
+static SIZE_T get_bucket_chunk_size( SIZE_T index )
+{
+    return index * MEM_CACHE_STEP + MEM_CACHE_MIN_SIZE;
+}
+
+static void *bucket_pop_chunk( SIZE_T i )
+{
+    SIZE_T real_size = get_bucket_chunk_size( i );
+    void *mem;
+
+    if (!(mem = mem_cache_buckets[i]))
+        return NULL;
+
+    assert(mem_cache_total_size >= real_size);
+    mem_cache_buckets[i] = *(void **)mem;
+    mem_cache_total_size -= real_size;
+    return mem;
+}
+
+static void bucket_push_chunk( SIZE_T i, void *mem )
+{
+    SIZE_T real_size = get_bucket_chunk_size( i );
+
+    mem_cache_total_size += real_size;
+    *(void **)mem = mem_cache_buckets[i];
+    mem_cache_buckets[i] = mem;
+}
+
+void *alloc_gdi_cache_memory( SIZE_T size, BOOL zero_mem )
+{
+    SIZE_T i, real_size = size;
+    SIZE_T real_bucket_i;
+    void *mem = NULL;
+
+    i = get_bucket_index( real_size );
+    if (i < MEM_CACHE_NR_BUCKETS)
+    {
+        real_size = get_bucket_chunk_size( i );
+        assert(real_size >= size);
+
+        pthread_mutex_lock( &mem_cache_lock );
+
+        real_bucket_i = i;
+        while (!(mem = bucket_pop_chunk( real_bucket_i )))
+        {
+            if (++real_bucket_i >= MEM_CACHE_NR_BUCKETS) break;
+        }
+
+        pthread_mutex_unlock( &mem_cache_lock );
+
+        if (mem)
+        {
+            if (i != real_bucket_i)
+            {
+                void *realloc_mem = realloc( mem, real_size );
+                if (realloc_mem)
+                    mem = realloc_mem;
+            }
+            if (zero_mem)
+                memset(mem, 0, size);
+        }
+        else TRACE("no cache for %lu\n", real_size);
+    }
+
+    if (!mem)
+    {
+        if (zero_mem)
+            mem = calloc( 1, real_size );
+        else
+            mem = malloc( real_size );
+    }
+
+    return mem;
+}
+
+void free_gdi_cache_memory( void *mem, SIZE_T size )
+{
+    SIZE_T i, real_size;
+    SIZE_T free_bucket_i;
+
+    i = get_bucket_index( size );
+    if (i < MEM_CACHE_NR_BUCKETS)
+    {
+        real_size = get_bucket_chunk_size( i );
+
+        pthread_mutex_lock( &mem_cache_lock );
+
+        free_bucket_i = 0;
+        while (real_size > MEM_CACHE_THRESHOLD - mem_cache_total_size)
+        {
+            void *old_mem = bucket_pop_chunk( free_bucket_i );
+            if (old_mem)
+            {
+                TRACE("pop cache %p (%lu)\n", old_mem, real_size);
+                free( old_mem );
+            }
+            if (++free_bucket_i >= MEM_CACHE_NR_BUCKETS) break;
+        }
+
+        if (real_size <= MEM_CACHE_THRESHOLD - mem_cache_total_size)
+        {
+            bucket_push_chunk( i, mem );
+            mem = NULL;
+        }
+        else
+        {
+            TRACE("discard memory %p (%lu)\n", mem, real_size);
+        }
+
+        pthread_mutex_unlock( &mem_cache_lock );
+    }
+
+    if (mem)
+        free( mem );
+}
diff --git a/dlls/win32u/ntgdi_private.h b/dlls/win32u/ntgdi_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntgdi_private.h
+++ b/dlls/win32u/ntgdi_private.h
@@ -431,6 +431,10 @@ extern HRGN create_polypolygon_region( const POINT *pts, const INT *count, INT n
 extern BOOL delete_dce( struct dce *dce ) DECLSPEC_HIDDEN;
 extern void update_dc( DC *dc ) DECLSPEC_HIDDEN;
 
+/* alloc.c */
+extern void *alloc_gdi_cache_memory( SIZE_T size, BOOL zero_mem ) DECLSPEC_HIDDEN;
+extern void free_gdi_cache_memory( void *mem, SIZE_T size ) DECLSPEC_HIDDEN;
+
 #define RGN_DEFAULT_RECTS 4
 typedef struct
 {

-- 
2.37.2

From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Subject: [PATCH 2/4] win32u: Use freelist cache allocator for NtGdiCreateBitmap.
Message-Id: <37e70aa4-109f-b223-b650-aa6f18a3eb43@gmail.com>
Date: Mon, 21 Mar 2022 05:42:36 +0900
In-Reply-To: <7303da75-56e4-7139-34ce-b90da9eccc03@gmail.com>
References: <7303da75-56e4-7139-34ce-b90da9eccc03@gmail.com>

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/win32u/bitmap.c | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/dlls/win32u/bitmap.c b/dlls/win32u/bitmap.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/bitmap.c
+++ b/dlls/win32u/bitmap.c
@@ -159,7 +159,7 @@ HBITMAP WINAPI NtGdiCreateBitmap( INT width, INT height, UINT planes,
     bmpobj->dib.dsBm.bmWidthBytes = get_bitmap_stride( width, bpp );
     bmpobj->dib.dsBm.bmPlanes     = planes;
     bmpobj->dib.dsBm.bmBitsPixel  = bpp;
-    bmpobj->dib.dsBm.bmBits       = calloc( 1, size );
+    bmpobj->dib.dsBm.bmBits       = alloc_gdi_cache_memory( size, TRUE );
     if (!bmpobj->dib.dsBm.bmBits)
     {
         free( bmpobj );
@@ -169,7 +169,7 @@ HBITMAP WINAPI NtGdiCreateBitmap( INT width, INT height, UINT planes,
 
     if (!(hbitmap = alloc_gdi_handle( &bmpobj->obj, NTGDI_OBJ_BITMAP, &bitmap_funcs )))
     {
-        free( bmpobj->dib.dsBm.bmBits );
+        free_gdi_cache_memory( bmpobj->dib.dsBm.bmBits, size );
         free( bmpobj );
         return 0;
     }
@@ -444,9 +444,15 @@ HGDIOBJ WINAPI NtGdiSelectBitmap( HDC hdc, HGDIOBJ handle )
 static BOOL BITMAP_DeleteObject( HGDIOBJ handle )
 {
     BITMAPOBJ *bmp = free_gdi_handle( handle );
+    INT dib_stride;
+    SIZE_T size;
 
     if (!bmp) return FALSE;
-    free( bmp->dib.dsBm.bmBits );
+
+    dib_stride = get_dib_stride( bmp->dib.dsBm.bmWidth, bmp->dib.dsBm.bmBitsPixel );
+    size = dib_stride * bmp->dib.dsBm.bmHeight;
+
+    free_gdi_cache_memory( bmp->dib.dsBm.bmBits, size );
     free( bmp );
     return TRUE;
 }

-- 
2.37.2

From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Subject: [PATCH 3/4] win32u: Add gdi_image_bits allocation function based on freelist cache allocator.
Message-Id: <f5b1a8fe-cdc8-92b8-db1e-ce5e67355fa0@gmail.com>
Date: Mon, 21 Mar 2022 05:42:45 +0900
In-Reply-To: <7303da75-56e4-7139-34ce-b90da9eccc03@gmail.com>
References: <7303da75-56e4-7139-34ce-b90da9eccc03@gmail.com>

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/win32u/bitblt.c        | 19 +++++++++++++++++++
 dlls/win32u/ntgdi_private.h |  4 ++++
 2 files changed, 23 insertions(+)

diff --git a/dlls/win32u/bitblt.c b/dlls/win32u/bitblt.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/bitblt.c
+++ b/dlls/win32u/bitblt.c
@@ -168,6 +168,25 @@ void CDECL free_heap_bits( struct gdi_image_bits *bits )
     free( bits->ptr );
 }
 
+static void CDECL free_gdi_cache_bits( struct gdi_image_bits *bits )
+{
+    free_gdi_cache_memory( bits->ptr, (SIZE_T)bits->param );
+}
+
+BOOL alloc_gdi_cache_bits( struct gdi_image_bits *bits, SIZE_T size, int flags )
+{
+    void *mem = alloc_gdi_cache_memory( size, flags & ALLOC_ZERO_MEMORY );
+
+    if (!mem)
+        return FALSE;
+
+    bits->ptr = mem;
+    bits->is_copy = !!(flags & ALLOC_IS_COPY);
+    bits->free = free_gdi_cache_bits;
+    bits->param = (void *)size;
+    return TRUE;
+}
+
 DWORD convert_bits( const BITMAPINFO *src_info, struct bitblt_coords *src,
                     BITMAPINFO *dst_info, struct gdi_image_bits *bits )
 {
diff --git a/dlls/win32u/ntgdi_private.h b/dlls/win32u/ntgdi_private.h
index 11111111111..11111111111 100644
--- a/dlls/win32u/ntgdi_private.h
+++ b/dlls/win32u/ntgdi_private.h
@@ -655,6 +655,10 @@ static inline void copy_bitmapinfo( BITMAPINFO *dst, const BITMAPINFO *src )
     memcpy( dst, src, get_dib_info_size( src, DIB_RGB_COLORS ));
 }
 
+#define ALLOC_ZERO_MEMORY  1
+#define ALLOC_IS_COPY      2
+
+extern BOOL alloc_gdi_cache_bits( struct gdi_image_bits *bits, SIZE_T size, int flags ) DECLSPEC_HIDDEN;
 extern void CDECL free_heap_bits( struct gdi_image_bits *bits ) DECLSPEC_HIDDEN;
 
 void set_gdi_client_ptr( HGDIOBJ handle, void *ptr ) DECLSPEC_HIDDEN;

-- 
2.37.2

From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Subject: [PATCH 4/4] win32u: Use alloc_gdi_cache_bits in place of malloc / free.
Message-Id: <f719e600-3e14-0624-505b-c994d0b805f3@gmail.com>
Date: Mon, 21 Mar 2022 05:42:52 +0900
In-Reply-To: <7303da75-56e4-7139-34ce-b90da9eccc03@gmail.com>
References: <7303da75-56e4-7139-34ce-b90da9eccc03@gmail.com>

Signed-off-by: Jinoh Kang <jinoh.kang.kr@gmail.com>
---
 dlls/win32u/bitblt.c         | 34 +++++++++++++---------------------
 dlls/win32u/bitmap.c         |  4 +---
 dlls/win32u/brush.c          |  3 +--
 dlls/win32u/dib.c            | 12 ++++++------
 dlls/win32u/dibdrv/bitblt.c  | 18 +++++-------------
 dlls/win32u/dibdrv/objects.c |  5 ++---
 dlls/win32u/font.c           | 25 +++++++------------------
 7 files changed, 35 insertions(+), 66 deletions(-)

diff --git a/dlls/win32u/bitblt.c b/dlls/win32u/bitblt.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/bitblt.c
+++ b/dlls/win32u/bitblt.c
@@ -190,7 +190,7 @@ BOOL alloc_gdi_cache_bits( struct gdi_image_bits *bits, SIZE_T size, int flags )
 DWORD convert_bits( const BITMAPINFO *src_info, struct bitblt_coords *src,
                     BITMAPINFO *dst_info, struct gdi_image_bits *bits )
 {
-    void *ptr;
+    struct gdi_image_bits new_bits;
     DWORD err;
     BOOL top_down = dst_info->bmiHeader.biHeight < 0;
 
@@ -199,14 +199,12 @@ DWORD convert_bits( const BITMAPINFO *src_info, struct bitblt_coords *src,
     dst_info->bmiHeader.biSizeImage = get_dib_image_size( dst_info );
     if (top_down) dst_info->bmiHeader.biHeight = -dst_info->bmiHeader.biHeight;
 
-    if (!(ptr = malloc( dst_info->bmiHeader.biSizeImage )))
+    if (!alloc_gdi_cache_bits( &new_bits, dst_info->bmiHeader.biSizeImage, ALLOC_IS_COPY ))
         return ERROR_OUTOFMEMORY;
 
-    err = convert_bitmapinfo( src_info, bits->ptr, src, dst_info, ptr );
+    err = convert_bitmapinfo( src_info, bits->ptr, src, dst_info, new_bits.ptr );
     if (bits->free) bits->free( bits );
-    bits->ptr = ptr;
-    bits->is_copy = TRUE;
-    bits->free = free_heap_bits;
+    *bits = new_bits;
     return err;
 }
 
@@ -214,7 +212,7 @@ DWORD stretch_bits( const BITMAPINFO *src_info, struct bitblt_coords *src,
                     BITMAPINFO *dst_info, struct bitblt_coords *dst,
                     struct gdi_image_bits *bits, int mode )
 {
-    void *ptr;
+    struct gdi_image_bits new_bits;
     DWORD err;
 
     dst_info->bmiHeader.biWidth = dst->visrect.right - dst->visrect.left;
@@ -222,14 +220,12 @@ DWORD stretch_bits( const BITMAPINFO *src_info, struct bitblt_coords *src,
     dst_info->bmiHeader.biSizeImage = get_dib_image_size( dst_info );
 
     if (src_info->bmiHeader.biHeight < 0) dst_info->bmiHeader.biHeight = -dst_info->bmiHeader.biHeight;
-    if (!(ptr = malloc( dst_info->bmiHeader.biSizeImage )))
+    if (!alloc_gdi_cache_bits( &new_bits, dst_info->bmiHeader.biSizeImage, ALLOC_IS_COPY ))
         return ERROR_OUTOFMEMORY;
 
-    err = stretch_bitmapinfo( src_info, bits->ptr, src, dst_info, ptr, dst, mode );
+    err = stretch_bitmapinfo( src_info, bits->ptr, src, dst_info, new_bits.ptr, dst, mode );
     if (bits->free) bits->free( bits );
-    bits->ptr = ptr;
-    bits->is_copy = TRUE;
-    bits->free = free_heap_bits;
+    *bits = new_bits;
     return err;
 }
 
@@ -240,13 +236,11 @@ static DWORD blend_bits( const BITMAPINFO *src_info, const struct gdi_image_bits
     if (!dst_bits->is_copy)
     {
         int size = dst_info->bmiHeader.biSizeImage;
-        void *ptr = malloc( size );
-        if (!ptr) return ERROR_OUTOFMEMORY;
-        memcpy( ptr, dst_bits->ptr, size );
+        struct gdi_image_bits new_bits;
+        if (!alloc_gdi_cache_bits( &new_bits, size, ALLOC_IS_COPY )) return ERROR_OUTOFMEMORY;
+        memcpy( new_bits.ptr, dst_bits->ptr, size );
         if (dst_bits->free) dst_bits->free( dst_bits );
-        dst_bits->ptr = ptr;
-        dst_bits->is_copy = TRUE;
-        dst_bits->free = free_heap_bits;
+        *dst_bits = new_bits;
     }
     return blend_bitmapinfo( src_info, src_bits->ptr, src, dst_info, dst_bits->ptr, dst, blend );
 }
@@ -489,10 +483,8 @@ BOOL CDECL nulldrv_GradientFill( PHYSDEV dev, TRIVERTEX *vert_array, ULONG nvert
     if (err && err != ERROR_BAD_FORMAT) goto done;
 
     info->bmiHeader.biSizeImage = get_dib_image_size( info );
-    if (!(bits.ptr = calloc( 1, info->bmiHeader.biSizeImage )))
+    if (!alloc_gdi_cache_bits( &bits, info->bmiHeader.biSizeImage, ALLOC_ZERO_MEMORY | ALLOC_IS_COPY ))
         goto done;
-    bits.is_copy = TRUE;
-    bits.free = free_heap_bits;
 
     /* make src and points relative to the bitmap */
     src = dst;
diff --git a/dlls/win32u/bitmap.c b/dlls/win32u/bitmap.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/bitmap.c
+++ b/dlls/win32u/bitmap.c
@@ -322,13 +322,11 @@ LONG WINAPI NtGdiSetBitmapBits(
     }
     else
     {
-        if (!(src_bits.ptr = malloc( dst.height * dst_stride )))
+        if (!alloc_gdi_cache_bits( &src_bits, dst.height * dst_stride, ALLOC_IS_COPY ))
         {
             GDI_ReleaseObj( hbitmap );
             return 0;
         }
-        src_bits.is_copy = TRUE;
-        src_bits.free = free_heap_bits;
         for (i = 0; i < count / src_stride; i++)
             memcpy( (char *)src_bits.ptr + i * dst_stride, (char *)bits + i * src_stride, src_stride );
         if (count % src_stride)
diff --git a/dlls/win32u/brush.c b/dlls/win32u/brush.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/brush.c
+++ b/dlls/win32u/brush.c
@@ -73,9 +73,8 @@ static BOOL copy_bitmap( struct brush_pattern *brush, HBITMAP bitmap )
     brush->bits = bits;
     if (!bits.free)
     {
-        if (!(brush->bits.ptr = malloc( info->bmiHeader.biSizeImage ))) goto done;
+        if (!alloc_gdi_cache_bits( &brush->bits, info->bmiHeader.biSizeImage, 0 )) goto done;
         memcpy( brush->bits.ptr, bits.ptr, info->bmiHeader.biSizeImage );
-        brush->bits.free = free_heap_bits;
     }
 
     if (!(brush->info = malloc( get_dib_info_size( info, DIB_RGB_COLORS ))))
diff --git a/dlls/win32u/dib.c b/dlls/win32u/dib.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/dib.c
+++ b/dlls/win32u/dib.c
@@ -67,6 +67,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <assert.h>
+#include <sys/mman.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -323,14 +324,15 @@ static BOOL build_rle_bitmap( BITMAPINFO *info, struct gdi_image_bits *bits, HRG
     int x, y, width = info->bmiHeader.biWidth, height = info->bmiHeader.biHeight;
     HRGN run = NULL;
     BYTE skip, num, data;
-    BYTE *out_bits, *in_bits = bits->ptr;
+    BYTE *out_bits = NULL, *in_bits = bits->ptr;
+    struct gdi_image_bits new_bits;
 
     if (clip) *clip = NULL;
 
     assert( info->bmiHeader.biBitCount == 4 || info->bmiHeader.biBitCount == 8 );
 
-    out_bits = calloc( 1, get_dib_image_size( info ) );
-    if (!out_bits) goto fail;
+    if (!alloc_gdi_cache_bits( &new_bits, get_dib_image_size( info ), ALLOC_ZERO_MEMORY | ALLOC_IS_COPY)) goto fail;
+    out_bits = new_bits.ptr;
 
     if (clip)
     {
@@ -446,9 +448,7 @@ done:
     if (run) NtGdiDeleteObjectApp( run );
     if (bits->free) bits->free( bits );
 
-    bits->ptr     = out_bits;
-    bits->is_copy = TRUE;
-    bits->free    = free_heap_bits;
+    *bits = new_bits;
     info->bmiHeader.biSizeImage = get_dib_image_size( info );
 
     return TRUE;
diff --git a/dlls/win32u/dibdrv/bitblt.c b/dlls/win32u/dibdrv/bitblt.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/dibdrv/bitblt.c
+++ b/dlls/win32u/dibdrv/bitblt.c
@@ -699,22 +699,19 @@ static DWORD copy_src_bits( dib_info *src, RECT *src_rect )
 {
     int y, stride = get_dib_stride( src->width, src->bit_count );
     int height = src_rect->bottom - src_rect->top;
-    void *ptr = malloc( stride * height );
+    struct gdi_image_bits new_bits;
 
-    if (!ptr) return ERROR_OUTOFMEMORY;
+    if (!alloc_gdi_cache_bits( &new_bits, stride * height, ALLOC_IS_COPY )) return ERROR_OUTOFMEMORY;
 
     for (y = 0; y < height; y++)
-        memcpy( (char *)ptr + y * stride,
+        memcpy( (char *)new_bits.ptr + y * stride,
                 (char *)src->bits.ptr + (src->rect.top + src_rect->top + y) * src->stride, stride );
     src->stride = stride;
     src->height = height;
     src->rect.top = 0;
     src->rect.bottom = height;
     if (src->bits.free) src->bits.free( &src->bits );
-    src->bits.is_copy = TRUE;
-    src->bits.ptr = ptr;
-    src->bits.free = free_heap_bits;
-    src->bits.param = NULL;
+    src->bits = new_bits;
 
     OffsetRect( src_rect, 0, -src_rect->top );
     return ERROR_SUCCESS;
@@ -730,12 +727,7 @@ static DWORD create_tmp_dib( const dib_info *copy, int width, int height, dib_in
     ret->rect.top    = 0;
     ret->rect.right  = width;
     ret->rect.bottom = height;
-    ret->bits.ptr = malloc( ret->height * ret->stride );
-    ret->bits.is_copy = TRUE;
-    ret->bits.free = free_heap_bits;
-    ret->bits.param = NULL;
-
-    return ret->bits.ptr ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;
+    return alloc_gdi_cache_bits( &ret->bits, ret->height * ret->stride, ALLOC_IS_COPY ) ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;
 }
 
 static DWORD execute_rop( dibdrv_physdev *pdev, const RECT *dst_rect, dib_info *src,
diff --git a/dlls/win32u/dibdrv/objects.c b/dlls/win32u/dibdrv/objects.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/dibdrv/objects.c
+++ b/dlls/win32u/dibdrv/objects.c
@@ -2022,9 +2022,8 @@ static BOOL select_pattern_brush( dibdrv_physdev *pdev, dib_brush *brush, BOOL *
     }
     else
     {
-        brush->dib.bits.ptr     = malloc( brush->dib.height * brush->dib.stride );
-        brush->dib.bits.is_copy = TRUE;
-        brush->dib.bits.free    = free_heap_bits;
+        memset( &brush->dib.bits, 0, sizeof(brush->dib.bits) );
+        alloc_gdi_cache_bits( &brush->dib.bits, brush->dib.height * brush->dib.stride, ALLOC_IS_COPY );
         brush->dib.funcs->convert_to(&brush->dib, &pattern, &pattern.rect, dither);
     }
     return TRUE;
diff --git a/dlls/win32u/font.c b/dlls/win32u/font.c
index 11111111111..11111111111 100644
--- a/dlls/win32u/font.c
+++ b/dlls/win32u/font.c
@@ -5130,15 +5130,13 @@ static DWORD get_glyph_bitmap( HDC hdc, UINT index, UINT flags, UINT aa_flags,
     stride = get_dib_stride( metrics->gmBlackBoxX, 1 );
     size = metrics->gmBlackBoxY * stride;
 
-    if (!(image->ptr = malloc( size ))) return ERROR_OUTOFMEMORY;
-    image->is_copy = TRUE;
-    image->free = free_heap_bits;
+    if (!alloc_gdi_cache_bits( image, size, ALLOC_IS_COPY )) return ERROR_OUTOFMEMORY;
 
     ret = NtGdiGetGlyphOutline( hdc, index, aa_flags, metrics, size, image->ptr,
                                 &identity, FALSE );
     if (ret == GDI_ERROR)
     {
-        free( image->ptr );
+        if (image->free) image->free( image );
         return ERROR_NOT_FOUND;
     }
     return ERROR_SUCCESS;
@@ -5301,10 +5299,7 @@ BOOL CDECL nulldrv_ExtTextOut( PHYSDEV dev, INT x, INT y, UINT flags, const RECT
                 src.visrect.right = src.width;
                 src.visrect.bottom = src.height;
 
-                bits.ptr = malloc( info->bmiHeader.biSizeImage );
-                if (!bits.ptr) return ERROR_OUTOFMEMORY;
-                bits.is_copy = TRUE;
-                bits.free = free_heap_bits;
+                if (!alloc_gdi_cache_bits( &bits, info->bmiHeader.biSizeImage, ALLOC_IS_COPY )) return ERROR_OUTOFMEMORY;
                 err = ERROR_SUCCESS;
             }
         }
@@ -5314,17 +5309,11 @@ BOOL CDECL nulldrv_ExtTextOut( PHYSDEV dev, INT x, INT y, UINT flags, const RECT
             err = src_dev->funcs->pGetImage( src_dev, info, &bits, &src );
             if (!err && !bits.is_copy)
             {
-                void *ptr = malloc( info->bmiHeader.biSizeImage );
-                if (!ptr)
-                {
-                    if (bits.free) bits.free( &bits );
-                    return ERROR_OUTOFMEMORY;
-                }
-                memcpy( ptr, bits.ptr, info->bmiHeader.biSizeImage );
+                struct gdi_image_bits new_bits;
+                if (!alloc_gdi_cache_bits( &new_bits, info->bmiHeader.biSizeImage, ALLOC_IS_COPY )) return ERROR_OUTOFMEMORY;
+                memcpy( new_bits.ptr, bits.ptr, info->bmiHeader.biSizeImage );
                 if (bits.free) bits.free( &bits );
-                bits.ptr = ptr;
-                bits.is_copy = TRUE;
-                bits.free = free_heap_bits;
+                bits = new_bits;
             }
         }
         if (!err)

-- 
2.37.2

From e12b02d2c9a460c60ffa746a4f600bdd85f478f3 Mon Sep 17 00:00:00 2001
From: Torge Matthies <openglfreak@googlemail.com>
Date: Wed, 23 Mar 2022 03:09:09 +0100
Subject: [PATCH] dlls/gdiplus: Find also private fonts in
 GdipCreateFontFamilyFromName

Signed-off-by: Torge Matthies <openglfreak@googlemail.com>
---
 dlls/gdiplus/font.c            | 67 +++++++++++++++++++++++++++-------
 dlls/gdiplus/gdiplus_private.h |  1 +
 2 files changed, 54 insertions(+), 14 deletions(-)

diff --git a/dlls/gdiplus/font.c b/dlls/gdiplus/font.c
index 11111111111..11111111111 100644
--- a/dlls/gdiplus/font.c
+++ b/dlls/gdiplus/font.c
@@ -126,6 +126,17 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION font_cs = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+struct list font_list_head = LIST_INIT( font_list_head );
+
+static CRITICAL_SECTION font_list_cs;
+static CRITICAL_SECTION_DEBUG font_list_critsect_debug =
+{
+    0, 0, &font_list_cs,
+    { &font_list_critsect_debug.ProcessLocksList, &font_list_critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": font_list_cs") }
+};
+static CRITICAL_SECTION font_list_cs = { &font_list_critsect_debug, -1, 0, 0, 0, 0 };
+
 /*******************************************************************************
  * GdipCreateFont [GDIPLUS.@]
  *
@@ -729,25 +740,41 @@ GpStatus WINGDIPAPI GdipCreateFontFamilyFromName(GDIPCONST WCHAR *name,
     if (!name || !family)
         return InvalidParameter;
 
-    if (!collection)
-    {
-        status = GdipNewInstalledFontCollection(&collection);
-        if (status != Ok) return status;
-    }
-
     status = FontFamilyNotFound;
 
     hdc = CreateCompatibleDC(0);
 
     if (!EnumFontFamiliesW(hdc, name, is_font_installed_proc, (LPARAM)&lf))
     {
-        for (i = 0; i < collection->count; i++)
+        if (!collection)
         {
-            if (!wcsicmp(lf.lfFaceName, collection->FontFamilies[i]->FamilyName))
+            GpFontFamily *font;
+            EnterCriticalSection(&font_list_cs);
+            LIST_FOR_EACH_ENTRY( font, &font_list_head, GpFontFamily, font_list_entry )
             {
-                status = GdipCloneFontFamily(collection->FontFamilies[i], family);
-                TRACE("<-- %p\n", *family);
-                break;
+                if (!wcsicmp(lf.lfFaceName, font->FamilyName))
+                {
+                    status = GdipCloneFontFamily(font, family);
+                    TRACE("<-- %p\n", *family);
+                    break;
+                }
+            }
+            LeaveCriticalSection(&font_list_cs);
+
+            if (status == FontFamilyNotFound)
+                status = GdipNewInstalledFontCollection(&collection);
+        }
+
+        if (status == FontFamilyNotFound)
+        {
+            for (i = 0; i < collection->count; i++)
+            {
+                if (!wcsicmp(lf.lfFaceName, collection->FontFamilies[i]->FamilyName))
+                {
+                    status = GdipCloneFontFamily(collection->FontFamilies[i], family);
+                    TRACE("<-- %p\n", *family);
+                    break;
+                }
             }
         }
     }
@@ -837,13 +864,21 @@ GpStatus WINGDIPAPI GdipGetFamilyName (GDIPCONST GpFontFamily *family,
  */
 GpStatus WINGDIPAPI GdipDeleteFontFamily(GpFontFamily *FontFamily)
 {
+    LONG refcount;
+
     if (!FontFamily)
         return InvalidParameter;
 
-    if (!FontFamily->installed && !InterlockedDecrement(&FontFamily->ref))
-    {
+    if (FontFamily->installed)
+        return Ok;
+
+    EnterCriticalSection(&font_list_cs);
+    refcount = InterlockedDecrement(&FontFamily->ref);
+    if (!refcount)
+        list_remove(&FontFamily->font_list_entry);
+    LeaveCriticalSection(&font_list_cs);
+    if (!refcount)
         heap_free(FontFamily);
-    }
 
     return Ok;
 }
@@ -1663,6 +1698,10 @@ static INT CALLBACK add_font_proc(const LOGFONTW *lfw, const TEXTMETRICW *ntm,
 
     fonts->FontFamilies[fonts->count++] = family;
 
+    EnterCriticalSection(&font_list_cs);
+    list_add_head(&font_list_head, &family->font_list_entry);
+    LeaveCriticalSection(&font_list_cs);
+
     return 1;
 }
 
diff --git a/dlls/gdiplus/gdiplus_private.h b/dlls/gdiplus/gdiplus_private.h
index 11111111111..11111111111 100644
--- a/dlls/gdiplus/gdiplus_private.h
+++ b/dlls/gdiplus/gdiplus_private.h
@@ -548,6 +548,7 @@ struct GpFontFamily{
     int dpi;
     BOOL installed;
     LONG ref;
+    struct list font_list_entry;
 };
 
 /* internal use */
-- 
2.37.2

